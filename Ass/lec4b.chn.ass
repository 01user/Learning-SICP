[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Movies/SICP480p/lec4b_480_muxed.mp4
Video File: ../../../../Movies/SICP480p/lec4b_480_muxed.mp4
Video AR Mode: 4
Video AR Value: 1.333333
Video Zoom Percent: 2.000000
Active Line: 6
Video Position: 690

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:02.25,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:04.33,0:00:10.35,title,,0,0,0,,{\fad(600,800)\pos(324,32)}计算机程序的构造和解释
Dialogue: 0,0:00:04.33,0:00:10.35,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:04.33,0:00:10.35,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N刘殊君（rtmagic）
Dialogue: 0,0:00:04.33,0:00:10.35,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:04.33,0:00:10.35,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:11.40,0:00:16.50,Declare,,0,0,0,,{\an2\fad(500,500)}通用运算符
Dialogue: 0,0:00:20.18,0:00:21.84,Default,,0,0,0,,教授：到目前为止 我们已经进行了很多
Dialogue: 0,0:00:21.84,0:00:23.78,Default,,0,0,0,,关于数据抽象的讨论
Dialogue: 0,0:00:23.78,0:00:27.15,Default,,0,0,0,,关键理念就是在构造系统的时候
Dialogue: 0,0:00:27.74,0:00:32.56,Default,,0,0,0,,在其中加入水平的抽象屏障 这些抽象屏障
Dialogue: 0,0:00:33.42,0:00:39.21,Default,,0,0,0,,把你使用一个数据对象的方式
Dialogue: 0,0:00:39.93,0:00:41.18,Default,,0,0,0,,和表示它的方式区分开来
Dialogue: 0,0:00:49.40,0:00:52.03,Default,,0,0,0,,或者可以这样理解它 在上层有一个老板
Dialogue: 0,0:00:52.11,0:00:55.50,Default,,0,0,0,,想要调用某种数据对象
Dialogue: 0,0:00:57.11,0:01:02.31,Default,,0,0,0,,而在下层 George负责它的具体实现
Dialogue: 0,0:01:02.31,0:01:05.42,Default,,0,0,0,,这种把使用与表示分离的想法
Dialogue: 0,0:01:05.44,0:01:09.76,Default,,0,0,0,,可以让你分开考虑这两个问题
Dialogue: 0,0:01:10.60,0:01:14.76,Default,,0,0,0,,这是一种非常强大的编程的方法论 -- 数据抽象
Dialogue: 0,0:01:15.93,0:01:18.81,Default,,0,0,0,,但另一方面 数据抽象在那些真正复杂的系统上
Dialogue: 0,0:01:19.56,0:01:21.84,Default,,0,0,0,,并不是很有效
Dialogue: 0,0:01:22.96,0:01:27.64,Default,,0,0,0,,这个问题就出在George这里
Dialogue: 0,0:01:28.64,0:01:32.09,Default,,0,0,0,,或者说 实际上 问题就在于
Dialogue: 0,0:01:32.09,0:01:32.78,Default,,0,0,0,,现在有太多的George
Dialogue: 0,0:01:34.63,0:01:35.39,Default,,0,0,0,,具体地说
Dialogue: 0,0:01:35.39,0:01:39.18,Default,,0,0,0,,假设现在有George和Martha两个人
Dialogue: 0,0:01:41.19,0:01:44.22,Default,,0,0,0,,他们都是这个系统的开发人员
Dialogue: 0,0:01:46.04,0:01:47.29,Default,,0,0,0,,都在设计数据的表示方法
Dialogue: 0,0:01:48.41,0:01:50.67,Default,,0,0,0,,而且他们完全合不来
Dialogue: 0,0:01:51.75,0:01:53.62,Default,,0,0,0,,他们不会合作开发同一种表示方法
Dialogue: 0,0:01:54.01,0:01:55.34,Default,,0,0,0,,永远也不会
Dialogue: 0,0:01:57.48,0:01:59.72,Default,,0,0,0,,现在的问题是 假设你想要这样一个系统
Dialogue: 0,0:02:00.06,0:02:02.60,Default,,0,0,0,,在这个系统中George和Martha都为它设计了数据表示方法
Dialogue: 0,0:02:03.82,0:02:08.08,Default,,0,0,0,,但是如果你在高于这个抽象屏障的层面思考
Dialogue: 0,0:02:09.40,0:02:11.04,Default,,0,0,0,,你就不用去操心这些事情
Dialogue: 0,0:02:11.66,0:02:14.18,Default,,0,0,0,,不用操心 某个东西是到底是George做的还是Martha做的
Dialogue: 0,0:02:14.18,0:02:15.43,Default,,0,0,0,,同时你也不想让George和Martha
Dialogue: 0,0:02:15.43,0:02:16.48,Default,,0,0,0,,妨碍彼此的工作
Dialogue: 0,0:02:16.63,0:02:20.31,Default,,0,0,0,,你在设计系统的时候 不仅仅需要这些
Dialogue: 0,0:02:20.31,0:02:23.84,Default,,0,0,0,,水平的抽象屏障 同时也想设置一道
Dialogue: 0,0:02:25.82,0:02:30.64,Default,,0,0,0,,垂直的屏障 -- 来把George和Martha分离开
Dialogue: 0,0:02:32.98,0:02:35.40,Default,,0,0,0,,我们来说得再具体一点
Dialogue: 0,0:02:36.56,0:02:40.54,Default,,0,0,0,,想象一个很大的公司的人事记录
Dialogue: 0,0:02:41.18,0:02:46.11,Default,,0,0,0,,这个公司里有很多部门没什么联系
Dialogue: 0,0:02:47.90,0:02:49.71,Default,,0,0,0,,并且部门之间合作得也不太好
Dialogue: 0,0:02:50.43,0:02:57.04,Default,,0,0,0,,甚至还可以想象这个大公司就是由
Dialogue: 0,0:02:57.04,0:02:59.45,Default,,0,0,0,,很多公司组成的 而且每个公司
Dialogue: 0,0:02:59.45,0:03:00.70,Default,,0,0,0,,都有自己的一套人事记录
Dialogue: 0,0:03:03.25,0:03:06.57,Default,,0,0,0,,想象一下突然有一天 这些部门
Dialogue: 0,0:03:06.57,0:03:08.53,Default,,0,0,0,,被一种神奇的卫星网络连接起来
Dialogue: 0,0:03:08.53,0:03:10.52,Default,,0,0,0,,它们各自的数据库都被放到了一起
Dialogue: 0,0:03:12.24,0:03:13.85,Default,,0,0,0,,现在你想要
Dialogue: 0,0:03:14.84,0:03:16.33,Default,,0,0,0,,在公司的任何地方
Dialogue: 0,0:03:17.26,0:03:23.13,Default,,0,0,0,,都能够知道 哦 某一条人事记录里的
Dialogue: 0,0:03:23.13,0:03:23.87,Default,,0,0,0,,“姓名”是什么
Dialogue: 0,0:03:26.30,0:03:29.15,Default,,0,0,0,,或者一条记录里的“工作”是什么
Dialogue: 0,0:03:30.54,0:03:34.40,Default,,0,0,0,,同时又不需要担心每一个部门
Dialogue: 0,0:03:34.84,0:03:36.76,Default,,0,0,0,,对于人事记录的格式
Dialogue: 0,0:03:36.76,0:03:39.37,Default,,0,0,0,,有着完全不同的习惯
Dialogue: 0,0:03:41.58,0:03:43.26,Default,,0,0,0,,从你的视角上你不想去了解这些东西
Dialogue: 0,0:03:44.96,0:03:47.92,Default,,0,0,0,,那么怎么才能做到这样呢？
Dialogue: 0,0:03:48.43,0:03:52.41,Default,,0,0,0,,当然 一种方法是下发一个告示
Dialogue: 0,0:03:52.64,0:03:56.29,Default,,0,0,0,,来通知所有人把他们的记录格式
Dialogue: 0,0:03:56.29,0:03:57.24,Default,,0,0,0,,都改成某种标准的格式
Dialogue: 0,0:03:58.07,0:04:00.12,Default,,0,0,0,,人们经常这样做 但都没有成功
Dialogue: 0,0:04:01.82,0:04:07.34,Default,,0,0,0,,另一个办法则是重新安排这些记录
Dialogue: 0,0:04:08.33,0:04:09.90,Default,,0,0,0,,让它们中间有这种垂直的抽象屏障
Dialogue: 0,0:04:11.25,0:04:14.40,Default,,0,0,0,,当你查询一份人事档案里的姓名的时候
Dialogue: 0,0:04:14.43,0:04:17.97,Default,,0,0,0,,不管它是什么格式 name这个过程都能设法
Dialogue: 0,0:04:17.97,0:04:19.42,Default,,0,0,0,,搞清楚怎么正确地完成这件事
Dialogue: 0,0:04:22.73,0:04:25.53,Default,,0,0,0,,我们把name叫做一个 所谓的“通用运算符”
Dialogue: 0,0:04:26.26,0:04:30.06,Default,,0,0,0,,通用运算符意味着它会根据数据的种类
Dialogue: 0,0:04:30.06,0:04:31.69,Default,,0,0,0,,准确地做出对应的操作
Dialogue: 0,0:04:33.65,0:04:36.62,Default,,0,0,0,,更进一步讲 你想让这个系统在
Dialogue: 0,0:04:36.92,0:04:39.79,Default,,0,0,0,,下次公司里多了一个新的人员划分的时候
Dialogue: 0,0:04:42.51,0:04:45.64,Default,,0,0,0,,人们连接系统的方法不会有很大的变化
Dialogue: 0,0:04:45.64,0:04:50.11,Default,,0,0,0,,并且公司里剩下的部门
Dialogue: 0,0:04:50.11,0:04:52.01,Default,,0,0,0,,要把它们的人员记录添加到这个系统
Dialogue: 0,0:04:52.27,0:04:53.93,Default,,0,0,0,,也不需要做什么大的修改
Dialogue: 0,0:04:55.52,0:04:57.52,Default,,0,0,0,,那么这就是你应该考虑的问题
Dialogue: 0,0:04:58.70,0:05:00.77,Default,,0,0,0,,或者这就是你的工作
Dialogue: 0,0:05:00.77,0:05:03.77,Default,,0,0,0,,要让系统可以用最少的改动来拥抱变化
Dialogue: 0,0:05:05.98,0:05:08.12,Default,,0,0,0,,这就是我们今天要讨论的问题
Dialogue: 0,0:05:09.44,0:05:14.22,Default,,0,0,0,,你脑子里应该有这个分布式的人事档案系统
Dialogue: 0,0:05:14.24,0:05:16.62,Default,,0,0,0,,但是实际上 我今天要讨论的是一个
Dialogue: 0,0:05:16.62,0:05:18.48,Default,,0,0,0,,比那要更加自成体系的问题
Dialogue: 0,0:05:19.29,0:05:21.76,Default,,0,0,0,,我觉得用它可以把事情说得更清楚一点
Dialogue: 0,0:05:21.87,0:05:26.01,Default,,0,0,0,,我们要讨论的是 复数域上的算术系统
Dialogue: 0,0:05:27.77,0:05:28.92,Default,,0,0,0,,我们来看看这个系统
Dialogue: 0,0:05:30.69,0:05:31.74,Default,,0,0,0,,来复习一下
Dialogue: 0,0:05:32.04,0:05:33.53,Default,,0,0,0,,什么是“复数”
Dialogue: 0,0:05:35.25,0:05:38.22,Default,,0,0,0,,复数z可以看做复平面上的一点
Dialogue: 0,0:05:39.37,0:05:47.19,Default,,0,0,0,,我们将复数表示为实数部分和虚数部分
Dialogue: 0,0:05:47.19,0:05:50.83,Default,,0,0,0,,所以如果这个是复数z 它的实部是这么多
Dialogue: 0,0:05:51.50,0:05:53.24,Default,,0,0,0,,它的虚部是那么多
Dialogue: 0,0:05:54.33,0:05:56.44,Default,,0,0,0,,我们就可以记z=x+iy
Dialogue: 0,0:05:59.11,0:06:03.21,Default,,0,0,0,,还有另一种方法来表示一个复数 比如说
Dialogue: 0,0:06:03.21,0:06:09.00,Default,,0,0,0,,这个点与原点的距离是多少 在原点的什么角度上
Dialogue: 0,0:06:11.32,0:06:16.67,Default,,0,0,0,,像这样 复数也可以表示为半径乘以一个角度
Dialogue: 0,0:06:19.52,0:06:21.92,Default,,0,0,0,,第一种表示法称为 直角坐标系表示
Dialogue: 0,0:06:22.59,0:06:25.45,Default,,0,0,0,,或者说实部-虚部表示
Dialogue: 0,0:06:26.20,0:06:30.04,Default,,0,0,0,,而后一种是用模和辐角两部分的极坐标表示
Dialogue: 0,0:06:30.04,0:06:31.48,Default,,0,0,0,,并且如果你知道了一个复数的实部和虚部
Dialogue: 0,0:06:31.53,0:06:33.36,Default,,0,0,0,,你就能计算出它的模和辐角
Dialogue: 0,0:06:33.72,0:06:36.97,Default,,0,0,0,,如果知道了x和y 就能用这个式子算出r
Dialogue: 0,0:06:37.19,0:06:39.48,Default,,0,0,0,,等于两个数平方和的平方根 然后就可以
Dialogue: 0,0:06:39.48,0:06:40.76,Default,,0,0,0,,用反三角函数算出辐角的值
Dialogue: 0,0:06:41.42,0:06:44.42,Default,,0,0,0,,或者反过来 如果你知道了r和A
Dialogue: 0,0:06:44.42,0:06:45.31,Default,,0,0,0,,你也能计算出x和y
Dialogue: 0,0:06:45.80,0:06:49.43,Default,,0,0,0,,x=r·cos(A) y=r·sin(A)
Dialogue: 0,0:06:51.34,0:06:53.66,Default,,0,0,0,,这是表示复数的两种不同方法
Dialogue: 0,0:06:54.13,0:06:57.15,Default,,0,0,0,,分别是极坐标形式和直角坐标形式
Dialogue: 0,0:06:57.15,0:06:58.12,Default,,0,0,0,,我们要设计的是
Dialogue: 0,0:06:58.32,0:07:01.32,Default,,0,0,0,,一个复数域上的算术系统
Dialogue: 0,0:07:03.95,0:07:05.12,Default,,0,0,0,,换句话讲 我们要
Dialogue: 0,0:07:05.58,0:07:06.99,Default,,0,0,0,,就像之前课上有理数运算的例子一样
Dialogue: 0,0:07:07.38,0:07:10.20,Default,,0,0,0,,是构造一个叫做+c的操作
Dialogue: 0,0:07:10.73,0:07:13.90,Default,,0,0,0,,它将两个复数然后把它们相加、相减
Dialogue: 0,0:07:14.35,0:07:16.94,Default,,0,0,0,,相乘或者相除
Dialogue: 0,0:07:20.73,0:07:25.28,Default,,0,0,0,,那么我们要用到一点点数学
Dialogue: 0,0:07:25.28,0:07:28.36,Default,,0,0,0,,对它们进行操作的具体的算式是什么
Dialogue: 0,0:07:30.41,0:07:31.92,Default,,0,0,0,,它们是怎么得出来的 并不重要
Dialogue: 0,0:07:34.00,0:07:35.79,Default,,0,0,0,,我们只是用它们实现运算
Dialogue: 0,0:07:35.80,0:07:37.95,Default,,0,0,0,,如果想要把两个复数相加
Dialogue: 0,0:07:39.13,0:07:42.66,Default,,0,0,0,,可以很容易地获取它们的实部和虚部
Dialogue: 0,0:07:42.66,0:07:45.93,Default,,0,0,0,,两个复数的和的实部
Dialogue: 0,0:07:47.72,0:07:49.72,Default,,0,0,0,,z1+z2的实部
Dialogue: 0,0:07:50.06,0:07:54.64,Default,,0,0,0,,就是z1的实部加上z2的实部
Dialogue: 0,0:07:57.82,0:08:01.60,Default,,0,0,0,,然后z1+z2的虚部也就是
Dialogue: 0,0:08:01.74,0:08:05.66,Default,,0,0,0,,z1的虚部加上z2的虚部
Dialogue: 0,0:08:07.41,0:08:09.48,Default,,0,0,0,,所以复数相加是非常简单的事情
Dialogue: 0,0:08:09.48,0:08:10.99,Default,,0,0,0,,你只要把各个部分分别加起来
Dialogue: 0,0:08:11.31,0:08:13.18,Default,,0,0,0,,然后用结果构建一个新的复数
Dialogue: 0,0:08:13.37,0:08:14.73,Default,,0,0,0,,如果你想要让复数相乘
Dialogue: 0,0:08:15.53,0:08:17.82,Default,,0,0,0,,那么在极坐标下运算会方便很多
Dialogue: 0,0:08:17.82,0:08:20.38,Default,,0,0,0,,因为对于两个复数
Dialogue: 0,0:08:20.40,0:08:26.54,Default,,0,0,0,,两复数积之模 就是它们各自的模的乘积
Dialogue: 0,0:08:28.85,0:08:33.88,Default,,0,0,0,,它们的积的辐角 就是两个辐角的和
Dialogue: 0,0:08:35.80,0:08:40.54,Default,,0,0,0,,这就是复数域上的运算所需的数学知识
Dialogue: 0,0:08:40.54,0:08:42.38,Default,,0,0,0,,我们来想一想具体的实现
Dialogue: 0,0:08:43.72,0:08:47.39,Default,,0,0,0,,我们就像之前运算有理数那样做
Dialogue: 0,0:08:49.84,0:08:53.47,Default,,0,0,0,,来到底层 假设有一些构造函数和选择函数
Dialogue: 0,0:08:53.76,0:08:54.52,Default,,0,0,0,,它们应该是什么样子呢
Dialogue: 0,0:08:55.33,0:08:58.16,Default,,0,0,0,,假设我们制造了一些表示数据对象的“云彩”
Dialogue: 0,0:08:58.54,0:09:00.78,Default,,0,0,0,,也就是用某种形式表示的复数
Dialogue: 0,0:09:01.79,0:09:04.67,Default,,0,0,0,,我们能从这个复数中得到它的实部
Dialogue: 0,0:09:05.52,0:09:09.64,Default,,0,0,0,,可以获得 虚部、模、或者辐角
Dialogue: 0,0:09:12.15,0:09:14.01,Default,,0,0,0,,然后我们需要一种方法来构造复数
Dialogue: 0,0:09:14.03,0:09:15.64,Default,,0,0,0,,不仅要有选择函数 还要有构造函数
Dialogue: 0,0:09:16.80,0:09:19.52,Default,,0,0,0,,那么假设我们有一个叫做make-rectangular的过程
Dialogue: 0,0:09:19.53,0:09:24.27,Default,,0,0,0,,这个过程的功能是接受一个实部
Dialogue: 0,0:09:24.51,0:09:29.36,Default,,0,0,0,,和一个虚部 然后把这两个部分组合成一个复数
Dialogue: 0,0:09:31.92,0:09:35.01,Default,,0,0,0,,同样我们也可以构造一个make-polar过程
Dialogue: 0,0:09:35.01,0:09:37.85,Default,,0,0,0,,它接受一个模和一个辐角
Dialogue: 0,0:09:40.83,0:09:43.90,Default,,0,0,0,,然后用这两个值 组成一个复数
Dialogue: 0,0:09:44.68,0:09:45.46,Default,,0,0,0,,那么这个系统
Dialogue: 0,0:09:45.46,0:09:47.77,Default,,0,0,0,,里面会有两个构造函数和四个选择函数
Dialogue: 0,0:09:48.91,0:09:55.15,Default,,0,0,0,,现在 就像之前课程中那样 我们基于这个抽象的数据结构
Dialogue: 0,0:09:55.15,0:09:59.22,Default,,0,0,0,,继续实现复数的各种运算
Dialogue: 0,0:09:59.22,0:10:02.30,Default,,0,0,0,,而这些Lisp代码
Dialogue: 0,0:10:03.23,0:10:07.47,Default,,0,0,0,,是从我之前写的算术公式“翻译”而来的
Dialogue: 0,0:10:08.06,0:10:09.98,Default,,0,0,0,,如果我想把两个复数相加
Dialogue: 0,0:10:11.76,0:10:15.56,Default,,0,0,0,,我就要用一个实部和一个虚部构造一个复数
Dialogue: 0,0:10:16.72,0:10:19.02,Default,,0,0,0,,这个新的复数的实部是
Dialogue: 0,0:10:19.40,0:10:21.80,Default,,0,0,0,,两个复数的实部的和
Dialogue: 0,0:10:23.31,0:10:25.37,Default,,0,0,0,,它的虚数部分是
Dialogue: 0,0:10:25.40,0:10:27.52,Default,,0,0,0,,两个复数的虚部的和
Dialogue: 0,0:10:30.31,0:10:32.09,Default,,0,0,0,,我把它们放到一起 构造出一个复数
Dialogue: 0,0:10:32.16,0:10:34.44,Default,,0,0,0,,这就是实现复数加法的方法
Dialogue: 0,0:10:35.78,0:10:38.49,Default,,0,0,0,,减法实际上是一样的
Dialogue: 0,0:10:39.65,0:10:42.97,Default,,0,0,0,,只需要把各个部分相加变成把它们相减
Dialogue: 0,0:10:45.14,0:10:47.07,Default,,0,0,0,,要把两个复数相乘
Dialogue: 0,0:10:47.74,0:10:49.02,Default,,0,0,0,,要用另外一个式子
Dialogue: 0,0:10:49.27,0:10:53.84,Default,,0,0,0,,我会用一个模和一个辐角来构造一个复数
Dialogue: 0,0:10:55.35,0:10:56.44,Default,,0,0,0,,z1*z2的模
Dialogue: 0,0:10:56.65,0:11:00.97,Default,,0,0,0,,就是z1的模乘以z2的模
Dialogue: 0,0:11:03.71,0:11:05.93,Default,,0,0,0,,而z1*z2的辐角则是
Dialogue: 0,0:11:06.16,0:11:08.51,Default,,0,0,0,,z1的辐角加上z2的辐角
Dialogue: 0,0:11:09.62,0:11:10.96,Default,,0,0,0,,那么这就是乘法的实现
Dialogue: 0,0:11:11.23,0:11:12.25,Default,,0,0,0,,然后是除法
Dialogue: 0,0:11:14.27,0:11:15.90,Default,,0,0,0,,除法和乘法几乎是一样的
Dialogue: 0,0:11:17.37,0:11:19.58,Default,,0,0,0,,我只要把两个模相除 把辐角相减就可以了
Dialogue: 0,0:11:28.36,0:11:30.46,Default,,0,0,0,,现在我已经实现了各种运算
Dialogue: 0,0:11:31.87,0:11:33.64,Default,,0,0,0,,然后我们做什么
Dialogue: 0,0:11:33.64,0:11:34.52,Default,,0,0,0,,我们把George叫来
Dialogue: 0,0:11:36.06,0:11:38.79,Default,,0,0,0,,我们完成了“使用”的部分 现在应该考虑“表示”了
Dialogue: 0,0:11:38.80,0:11:40.94,Default,,0,0,0,,我们叫来George然后对他说
Dialogue: 0,0:11:40.97,0:11:43.61,Default,,0,0,0,,“为我们设计一个一套复数的表示方法”
Dialogue: 0,0:11:45.25,0:11:47.44,Default,,0,0,0,,很好
Dialogue: 0,0:11:47.77,0:11:52.66,Default,,0,0,0,,George可能会说 我们把一个复数
Dialogue: 0,0:11:52.66,0:11:57.15,Default,,0,0,0,,实现为 一个由实部和虚部组成的序对
Dialogue: 0,0:11:57.20,0:12:02.62,Default,,0,0,0,,那么如果我想用某个实部和虚部来构造复数
Dialogue: 0,0:12:03.36,0:12:05.55,Default,,0,0,0,,我只需要把它们cons起来即可 这样可以--
Dialogue: 0,0:12:06.03,0:12:08.11,Default,,0,0,0,,这就是George表示复数的方法
Dialogue: 0,0:12:09.78,0:12:12.42,Default,,0,0,0,,那么如果我想获得它的实部 我只需要
Dialogue: 0,0:12:12.42,0:12:14.12,Default,,0,0,0,,提取出序对的car部分 -- 它的首部分
Dialogue: 0,0:12:14.35,0:12:16.67,Default,,0,0,0,,如果我想要得到虚部 我就提取出它的cdr部分
Dialogue: 0,0:12:19.64,0:12:21.77,Default,,0,0,0,,那对于模和辐角 又该如何取得呢？
Dialogue: 0,0:12:22.22,0:12:25.75,Default,,0,0,0,,如果我想取得某个复数的模
Dialogue: 0,0:12:25.75,0:12:32.30,Default,,0,0,0,,我需要计算该复数car与cdr的平方和的算术平方根
Dialogue: 0,0:12:33.79,0:12:39.26,Default,,0,0,0,,如果我想得到辐角 我就计算它的cdr与car比值的反正切
Dialogue: 0,0:12:39.53,0:12:42.86,Default,,0,0,0,,这个Lisp过程用于计算反正切
Dialogue: 0,0:12:44.97,0:12:48.59,Default,,0,0,0,,要是有人给我一个模和辐角
Dialogue: 0,0:12:48.94,0:12:50.56,Default,,0,0,0,,并说：“给我构造一个复数”
Dialogue: 0,0:12:50.89,0:12:56.24,Default,,0,0,0,,用它们计算出实部 r*cos(a) 和虚部 r*sin(a)
Dialogue: 0,0:12:57.77,0:12:59.05,Default,,0,0,0,,连接成一个序对就行了
Dialogue: 0,0:13:01.46,0:13:02.26,Default,,0,0,0,,完成了
Dialogue: 0,0:13:02.26,0:13:04.75,Default,,0,0,0,,实际上我做的事情 在概念上讲
Dialogue: 0,0:13:06.89,0:13:09.37,Default,,0,0,0,,和我们之前提过的有理数的表示
Dialogue: 0,0:13:10.60,0:13:12.44,Default,,0,0,0,,是完全没有区别的
Dialogue: 0,0:13:12.75,0:13:13.91,Default,,0,0,0,,它们的思想相同
Dialogue: 0,0:13:13.91,0:13:16.28,Default,,0,0,0,,实现具体过程 选择一种表示方法
Dialogue: 0,0:13:18.07,0:13:18.65,Default,,0,0,0,,没有什么不同
Dialogue: 0,0:13:20.07,0:13:21.56,Default,,0,0,0,,现在我们来关心一下Martha
Dialogue: 0,0:13:23.21,0:13:24.52,Default,,0,0,0,,嗯 Martha的想法不太一样
Dialogue: 0,0:13:26.67,0:13:28.57,Default,,0,0,0,,她不想把复数表示成
Dialogue: 0,0:13:28.59,0:13:30.90,Default,,0,0,0,,由实部和虚部组成的序对
Dialogue: 0,0:13:30.90,0:13:34.17,Default,,0,0,0,,她比较喜欢把它们表示成
Dialogue: 0,0:13:34.17,0:13:37.69,Default,,0,0,0,,由模和辐角组成的序对
Dialogue: 0,0:13:39.55,0:13:42.13,Default,,0,0,0,,那么如果我们没有让George而是让Martha
Dialogue: 0,0:13:42.13,0:13:43.74,Default,,0,0,0,,来设计复数的表示方法 我们就会得到这样的东西
Dialogue: 0,0:13:44.57,0:13:47.16,Default,,0,0,0,,有一个make-polar过程
Dialogue: 0,0:13:47.16,0:13:50.22,Default,,0,0,0,,当然了 有了一个模和一个辐角之后
Dialogue: 0,0:13:50.22,0:13:53.07,Default,,0,0,0,,我们只要把它们组合成一个序对就行了
Dialogue: 0,0:13:55.43,0:13:57.68,Default,,0,0,0,,如果你想取得复数的模 那很简单
Dialogue: 0,0:13:58.24,0:13:59.37,Default,,0,0,0,,你只需要取序对的car部分即可
Dialogue: 0,0:13:59.78,0:14:02.67,Default,,0,0,0,,当然 想取得复数的辐角 那也很简单
Dialogue: 0,0:14:02.67,0:14:03.63,Default,,0,0,0,,只需取cdr部分即可
Dialogue: 0,0:14:04.81,0:14:07.02,Default,,0,0,0,,但是如果你想要获得实部和虚部
Dialogue: 0,0:14:07.42,0:14:08.49,Default,,0,0,0,,那就得费点力气
Dialogue: 0,0:14:08.88,0:14:14.58,Default,,0,0,0,,想得到实部 你就得计算r*cos(a)
Dialogue: 0,0:14:14.58,0:14:19.99,Default,,0,0,0,,换句话讲 用序对的car部分去乘以
Dialogue: 0,0:14:19.99,0:14:20.95,Default,,0,0,0,,cdr部分的余弦值
Dialogue: 0,0:14:20.95,0:14:26.23,Default,,0,0,0,,然后你就算出了r*cos(a)
Dialogue: 0,0:14:26.54,0:14:27.48,Default,,0,0,0,,这就是这个复数的实部
Dialogue: 0,0:14:28.33,0:14:31.40,Default,,0,0,0,,要是想算出它的虚部 用r乘以sin(a)就可以了
Dialogue: 0,0:14:32.66,0:14:37.93,Default,,0,0,0,,现在如果我给你一个实部和虚部 然后说
Dialogue: 0,0:14:37.93,0:14:42.03,Default,,0,0,0,,用它们给我构造一个复数
Dialogue: 0,0:14:42.03,0:14:44.17,Default,,0,0,0,,那就要先算出
Dialogue: 0,0:14:44.17,0:14:45.54,Default,,0,0,0,,模和辐角是多少
Dialogue: 0,0:14:45.54,0:14:47.85,Default,,0,0,0,,模是实部和虚部的平方和的算术平方根
Dialogue: 0,0:14:48.09,0:14:49.23,Default,,0,0,0,,辐角是这个反正切
Dialogue: 0,0:14:49.23,0:14:50.22,Default,,0,0,0,,我用这两个数构造一个序对
Dialogue: 0,0:14:52.09,0:14:54.17,Default,,0,0,0,,以上就是Martha的想法
Dialogue: 0,0:14:56.69,0:14:57.37,Default,,0,0,0,,那么哪种比较好呢？
Dialogue: 0,0:14:59.68,0:15:03.15,Default,,0,0,0,,如果你需要做很多加法 那么George的比较好
Dialogue: 0,0:15:03.16,0:15:05.61,Default,,0,0,0,,因为你总是要用到复数的实部和虚部
Dialogue: 0,0:15:05.85,0:15:08.40,Default,,0,0,0,,如果你大多数时间都是在做乘法
Dialogue: 0,0:15:09.48,0:15:11.14,Default,,0,0,0,,那可能Martha的办法就要好一些
Dialogue: 0,0:15:11.14,0:15:14.84,Default,,0,0,0,,又或者 -- 这就是问题所在了 -- 你决定不了
Dialogue: 0,0:15:16.59,0:15:22.32,Default,,0,0,0,,或者出于某些个人原因 你想让它们同时存在
Dialogue: 0,0:15:23.48,0:15:26.76,Default,,0,0,0,,也可能你是真的无法决定你更喜欢哪种表示法
Dialogue: 0,0:15:28.56,0:15:32.32,Default,,0,0,0,,回到这个话题 我们真正想要的是这样一个系统
Dialogue: 0,0:15:32.65,0:15:36.17,Default,,0,0,0,,这里面 既有George 他实现了
Dialogue: 0,0:15:36.83,0:15:39.64,Default,,0,0,0,,复数的直角坐标表示
Dialogue: 0,0:15:41.47,0:15:44.25,Default,,0,0,0,,又有Martha 她实现了复数的极坐标表示
Dialogue: 0,0:15:46.12,0:15:49.69,Default,,0,0,0,,然后我们有各种运算
Dialogue: 0,0:15:50.28,0:15:56.89,Default,,0,0,0,,用来对复数进行加减乘除
Dialogue: 0,0:15:57.56,0:15:58.76,Default,,0,0,0,,那么这些运算
Dialogue: 0,0:15:59.34,0:16:02.79,Default,,0,0,0,,不应该被系统中同时存在的两种
Dialogue: 0,0:16:02.79,0:16:03.98,Default,,0,0,0,,互不兼容的复数表示方法影响
Dialogue: 0,0:16:04.41,0:16:08.33,Default,,0,0,0,,或者说 我们不光有像这样的一个抽象屏障
Dialogue: 0,0:16:09.64,0:16:11.84,Default,,0,0,0,,它里面有real-part
Dialogue: 0,0:16:15.77,0:16:21.71,Default,,0,0,0,,还有 IMAG-PART、MAG 和 ANG 等几个过程
Dialogue: 0,0:16:23.83,0:16:25.36,Default,,0,0,0,,不光有一层抽象屏障
Dialogue: 0,0:16:25.39,0:16:28.38,Default,,0,0,0,,把实际的数据表示隐藏起来
Dialogue: 0,0:16:29.10,0:16:31.52,Default,,0,0,0,,还有一层垂直的屏障
Dialogue: 0,0:16:32.19,0:16:35.02,Default,,0,0,0,,容许不同的表示方法彼此共存
Dialogue: 0,0:16:35.87,0:16:37.40,Default,,0,0,0,,而不互相干预
Dialogue: 0,0:16:38.57,0:16:41.07,Default,,0,0,0,,我们的想法是把这些东西
Dialogue: 0,0:16:41.90,0:16:44.12,Default,,0,0,0,,REAL-PART、IMAG-PART、MAG、ANG 这些过程
Dialogue: 0,0:16:44.12,0:16:46.49,Default,,0,0,0,,设计成通用运算符
Dialogue: 0,0:16:47.31,0:16:49.45,Default,,0,0,0,,如果你调用real-part过程 它就会判断
Dialogue: 0,0:16:49.98,0:16:51.31,Default,,0,0,0,,要在哪一种表示方法中寻找它
Dialogue: 0,0:16:53.88,0:16:55.10,Default,,0,0,0,,那么我们怎么做到这一点呢
Dialogue: 0,0:16:56.84,0:16:59.23,Default,,0,0,0,,实际上有一个很容易想到的办法
Dialogue: 0,0:16:59.84,0:17:01.68,Default,,0,0,0,,如果你习惯了思考复数的模式
Dialogue: 0,0:17:02.52,0:17:04.44,Default,,0,0,0,,如果你已经习惯了复合数据的思想
Dialogue: 0,0:17:06.33,0:17:10.99,Default,,0,0,0,,假设你只要观察一个复数
Dialogue: 0,0:17:12.17,0:17:13.95,Default,,0,0,0,,就能看出它是被George还是Martha构造出来的
Dialogue: 0,0:17:15.79,0:17:18.90,Default,,0,0,0,,换句话说 在你眼前漂浮的这些东西
Dialogue: 0,0:17:18.90,0:17:20.91,Default,,0,0,0,,不是普通的复数 对吗？
Dialogue: 0,0:17:20.91,0:17:22.94,Default,,0,0,0,,它们是被某个设计者“构想”出来的
Dialogue: 0,0:17:24.39,0:17:28.04,Default,,0,0,0,,当考察一个复数 我们会发现它“不仅仅”是个复数
Dialogue: 0,0:17:28.04,0:17:29.16,Default,,0,0,0,,它上面有一个标签
Dialogue: 0,0:17:29.19,0:17:30.75,Default,,0,0,0,,写着这个是由Martha制造的
Dialogue: 0,0:17:31.45,0:17:34.22,Default,,0,0,0,,或者这个是由George制造的
Dialogue: 0,0:17:34.48,0:17:35.39,Default,,0,0,0,,对吧？它们被签了名字
Dialogue: 0,0:17:36.86,0:17:40.15,Default,,0,0,0,,在这之后 无论何时我们看见一个复数
Dialogue: 0,0:17:40.15,0:17:45.48,Default,,0,0,0,,我们只要看它的标签  然后我们就能知道
Dialogue: 0,0:17:45.80,0:17:46.72,Default,,0,0,0,,应该怎么对它进行运算
Dialogue: 0,0:17:48.03,0:17:51.19,Default,,0,0,0,,或者说 我们想要的不只是普通的数据对象
Dialogue: 0,0:17:51.19,0:17:54.37,Default,,0,0,0,,我们引入一个概念：带类型的数据
Dialogue: 0,0:17:59.76,0:18:02.81,Default,,0,0,0,,带类型的数据就意味着 这里有一朵“云彩”
Dialogue: 0,0:18:03.94,0:18:08.93,Default,,0,0,0,,它里面有我们之前所说的那种
Dialogue: 0,0:18:08.93,0:18:09.90,Default,,0,0,0,,普通的数据对象
Dialogue: 0,0:18:13.18,0:18:16.54,Default,,0,0,0,,这是它的内容 就是实际的数据
Dialogue: 0,0:18:19.32,0:18:21.56,Default,,0,0,0,,它里面还有一个叫做类型的东西
Dialogue: 0,0:18:22.56,0:18:25.24,Default,,0,0,0,,被George或者Martha签了名
Dialogue: 0,0:18:25.99,0:18:28.27,Default,,0,0,0,,那么我们现在就要从无类型的数据进入带类型数据的领域
Dialogue: 0,0:18:31.95,0:18:32.71,Default,,0,0,0,,我们怎么构造它
Dialogue: 0,0:18:32.71,0:18:33.50,Default,,0,0,0,,那很简单
Dialogue: 0,0:18:33.84,0:18:35.32,Default,,0,0,0,,我们知道怎么构造“云彩”
Dialogue: 0,0:18:35.80,0:18:36.88,Default,,0,0,0,,我们用序对来组成它们
Dialogue: 0,0:18:37.92,0:18:41.82,Default,,0,0,0,,那么我们就有了一种方法来表示带类型的数据
Dialogue: 0,0:18:43.51,0:18:49.64,Default,,0,0,0,,这种方法叫做 把类型附加到内容上
Dialogue: 0,0:18:49.69,0:18:50.64,Default,,0,0,0,,用cons就可以做到
Dialogue: 0,0:18:51.64,0:18:54.11,Default,,0,0,0,,然后面对一个带类型的数据 我们就可以知道它的类型
Dialogue: 0,0:18:55.21,0:18:56.00,Default,,0,0,0,,也就是序对的car部分
Dialogue: 0,0:18:56.29,0:18:58.30,Default,,0,0,0,,我们也可以知道它的具体内容 就是它的cdr部分
Dialogue: 0,0:18:59.96,0:19:04.28,Default,,0,0,0,,我们用这种方法使用带类型的数据
Dialogue: 0,0:19:05.29,0:19:07.26,Default,,0,0,0,,面对一段类型数据就能知道它是什么类型
Dialogue: 0,0:19:07.52,0:19:09.26,Default,,0,0,0,,那么我们现在有了几种判断类型的谓词
Dialogue: 0,0:19:10.51,0:19:13.73,Default,,0,0,0,,举例来讲 想要知道一个复数
Dialogue: 0,0:19:13.73,0:19:16.86,Default,,0,0,0,,是不是George构造的 是不是直角坐标表示的 我们只需要看
Dialogue: 0,0:19:16.86,0:19:21.85,Default,,0,0,0,,它的“类型”是不是rectangular这个符号
Dialogue: 0,0:19:23.68,0:19:25.05,Default,,0,0,0,,对吧？检查 rectangular 符号
Dialogue: 0,0:19:27.20,0:19:30.33,Default,,0,0,0,,同理 想要知道一个复数是不是Martha构造的
Dialogue: 0,0:19:30.33,0:19:33.42,Default,,0,0,0,,我们就看它的“类型”是不是polar这个符号
Dialogue: 0,0:19:36.46,0:19:39.21,Default,,0,0,0,,那么这就是一种识别数字的类型的方法
Dialogue: 0,0:19:40.75,0:19:42.81,Default,,0,0,0,,现在来想想 怎么用这种方法来构建系统
Dialogue: 0,0:19:43.87,0:19:46.73,Default,,0,0,0,,我们假设George和Martha分别在做各自的工作
Dialogue: 0,0:19:47.36,0:19:52.64,Default,,0,0,0,,每一个人都设计了他们的复数表示程序包
Dialogue: 0,0:19:52.64,0:19:58.52,Default,,0,0,0,,他们怎么让自己的东西成为系统的一部分
Dialogue: 0,0:19:58.73,0:20:00.14,Default,,0,0,0,,和对方友好共存呢
Dialogue: 0,0:20:00.14,0:20:02.11,Default,,0,0,0,,那其实非常简单
Dialogue: 0,0:20:02.72,0:20:04.51,Default,,0,0,0,,回忆一下 George做了这个程序包
Dialogue: 0,0:20:05.97,0:20:08.48,Default,,0,0,0,,这就是George的程序包 或者说它的一部分
Dialogue: 0,0:20:08.98,0:20:11.15,Default,,0,0,0,,然后红色下划线标出的部分是他需要做的修改
Dialogue: 0,0:20:12.09,0:20:16.43,Default,,0,0,0,,之前 当George用x和y构建了一个复数的时候
Dialogue: 0,0:20:17.52,0:20:19.85,Default,,0,0,0,,他只是把它们组合成一个序对
Dialogue: 0,0:20:20.93,0:20:23.39,Default,,0,0,0,,现在唯一不同的地方是 他给它们打了标签
Dialogue: 0,0:20:24.09,0:20:28.08,Default,,0,0,0,,他把类型 -- 也就是 rectangular符号 -- 附加到这个序对上面
Dialogue: 0,0:20:30.60,0:20:33.26,Default,,0,0,0,,剩下的事情都和之前一样 除了一点
Dialogue: 0,0:20:33.92,0:20:38.06,Default,,0,0,0,,就是George和Martha的程序都有叫做real-part和imaginary-part的过程
Dialogue: 0,0:20:38.70,0:20:42.96,Default,,0,0,0,,为了这些过程存在于在同一个Lisp环境中
Dialogue: 0,0:20:44.22,0:20:45.92,Default,,0,0,0,,George就要修改他的过程名字
Dialogue: 0,0:20:45.92,0:20:49.14,Default,,0,0,0,,那么我们说 这是George的real-part过程
Dialogue: 0,0:20:49.14,0:20:51.16,Default,,0,0,0,,叫做real-part-rectangular过程
Dialogue: 0,0:20:51.48,0:20:54.06,Default,,0,0,0,,还有 imag-part-rectangular过程
Dialogue: 0,0:20:55.42,0:20:57.24,Default,,0,0,0,,那么这里是George的程序包剩下的部分
Dialogue: 0,0:20:59.13,0:21:02.06,Default,,0,0,0,,他已经有了magnitude和angle过程 只要把它们改名
Dialogue: 0,0:21:02.06,0:21:04.16,Default,,0,0,0,,叫magnitude-rectangular和angle-rectangular就好了
Dialogue: 0,0:21:06.08,0:21:07.96,Default,,0,0,0,,Martha要做的事情基本相同
Dialogue: 0,0:21:09.86,0:21:16.22,Default,,0,0,0,,在这之前 当她用模和辐角构造复数的时候
Dialogue: 0,0:21:18.14,0:21:19.27,Default,,0,0,0,,她只是把这两个东西cons起来
Dialogue: 0,0:21:19.27,0:21:20.86,Default,,0,0,0,,现在她额外附加类型 polar
Dialogue: 0,0:21:23.95,0:21:25.61,Default,,0,0,0,,然后修改过程的名字
Dialogue: 0,0:21:25.66,0:21:29.85,Default,,0,0,0,,来避免保证她的real-part过程和George的产生冲突
Dialogue: 0,0:21:30.71,0:21:32.99,Default,,0,0,0,,分别改为real-part-polar和imaginary-part-polar
Dialogue: 0,0:21:34.54,0:21:38.06,Default,,0,0,0,,magnitude-polar和angle-polar这四个过程
Dialogue: 0,0:21:45.00,0:21:46.13,Default,,0,0,0,,现在我们的系统
Dialogue: 0,0:21:46.13,0:21:47.92,Default,,0,0,0,,在它里面既有George又有Martha
Dialogue: 0,0:21:49.16,0:21:51.68,Default,,0,0,0,,然后现在我们需要一个经理来对类型进行判断
Dialogue: 0,0:21:52.83,0:21:56.48,Default,,0,0,0,,那么在George和Martha给我们提供了类型数据之后
Dialogue: 0,0:21:57.05,0:21:59.40,Default,,0,0,0,,这个系统现在怎么工作呢？
Dialogue: 0,0:22:00.53,0:22:04.30,Default,,0,0,0,,我们手里有的 是一堆通用选择函数
Dialogue: 0,0:22:05.26,0:22:10.63,Default,,0,0,0,,用于复数的通用选择函数比如 real-part、imag-part、magnitude和angle等
Dialogue: 0,0:22:14.14,0:22:15.40,Default,,0,0,0,,让我们更进一步观察它们
Dialogue: 0,0:22:17.93,0:22:19.00,Default,,0,0,0,,real-part过程应该做什么
Dialogue: 0,0:22:19.31,0:22:22.76,Default,,0,0,0,,如果我想得到一个复数的实部
Dialogue: 0,0:22:24.07,0:22:24.91,Default,,0,0,0,,那么我先要观察它
Dialogue: 0,0:22:25.80,0:22:26.69,Default,,0,0,0,,我观察它的类型
Dialogue: 0,0:22:26.69,0:22:28.12,Default,,0,0,0,,考虑它是用直角坐标表示的吗
Dialogue: 0,0:22:31.02,0:22:35.36,Default,,0,0,0,,如果是的话 我就对这个复数的"内容"部分
Dialogue: 0,0:22:36.06,0:22:37.92,Default,,0,0,0,,调用George的real-part过程
Dialogue: 0,0:22:41.07,0:22:42.94,Default,,0,0,0,,这是一个带有类型的数字
Dialogue: 0,0:22:43.72,0:22:47.66,Default,,0,0,0,,我用contents过程剥掉类型 并且对它应用George的过程
Dialogue: 0,0:22:50.70,0:22:52.86,Default,,0,0,0,,那如果是一个用极坐标表示的复数呢？
Dialogue: 0,0:22:53.95,0:22:54.97,Default,,0,0,0,,如果我想要得到它的实部
Dialogue: 0,0:22:55.45,0:22:58.78,Default,,0,0,0,,我就把Martha的real-part过程应用在这个数的内容上
Dialogue: 0,0:22:59.85,0:23:01.15,Default,,0,0,0,,这就是real-part工作的方式
Dialogue: 0,0:23:02.26,0:23:05.66,Default,,0,0,0,,还有类似的imag-part过程 几乎是一样的
Dialogue: 0,0:23:06.51,0:23:09.60,Default,,0,0,0,,它先观察这个数字 它是直角坐标表示的
Dialogue: 0,0:23:09.60,0:23:11.13,Default,,0,0,0,,就调用George的imaginary-part过程
Dialogue: 0,0:23:11.13,0:23:12.83,Default,,0,0,0,,是极坐标表示的 就用Martha的过程
Dialogue: 0,0:23:13.38,0:23:17.40,Default,,0,0,0,,同理也可以构造出magnitude和angle两个过程
Dialogue: 0,0:23:19.71,0:23:21.02,Default,,0,0,0,,我们的系统是这个样子
Dialogue: 0,0:23:23.00,0:23:24.26,Default,,0,0,0,,它里面有三个部分
Dialogue: 0,0:23:24.26,0:23:26.59,Default,,0,0,0,,有George、Martha和一个经理
Dialogue: 0,0:23:26.76,0:23:28.97,Default,,0,0,0,,这就是实现通用操作符的方法
Dialogue: 0,0:23:28.97,0:23:32.92,Default,,0,0,0,,为了把它说清楚 我们举一个简单的实例
Dialogue: 0,0:23:33.50,0:23:35.12,Default,,0,0,0,,但是准确描述了它工作的方式
Dialogue: 0,0:23:36.54,0:23:43.98,Default,,0,0,0,,假设你现在 面对一个实部是1
Dialogue: 0,0:23:44.52,0:23:46.09,Default,,0,0,0,,虚部是2的复数
Dialogue: 0,0:23:46.09,0:23:48.44,Default,,0,0,0,,也就是1+2i
Dialogue: 0,0:23:50.31,0:23:52.64,Default,,0,0,0,,现在在这里
Dialogue: 0,0:23:55.28,0:23:57.53,Default,,0,0,0,,在操作发生的上层
Dialogue: 0,0:23:57.63,0:24:08.27,Default,,0,0,0,,复数被表示成一个由1和2组成的序对加上类型信息
Dialogue: 0,0:24:10.48,0:24:11.39,Default,,0,0,0,,（1和2）是内容
Dialogue: 0,0:24:11.87,0:24:17.96,Default,,0,0,0,,整个的数据就是在那之上加上一个rectangular符号
Dialogue: 0,0:24:18.14,0:24:21.53,Default,,0,0,0,,这就是复数在这个系统里存在的形式
Dialogue: 0,0:24:22.33,0:24:24.92,Default,,0,0,0,,你要调取real-part的时候
Dialogue: 0,0:24:25.84,0:24:28.89,Default,,0,0,0,,经理会检查这个数然后说 这是George构造的数字
Dialogue: 0,0:24:30.27,0:24:31.53,Default,,0,0,0,,他会先把类型拿掉
Dialogue: 0,0:24:33.34,0:24:36.91,Default,,0,0,0,,然后把 (1,2) 这个序对传递给George
Dialogue: 0,0:24:38.00,0:24:42.27,Default,,0,0,0,,这是George的系统可以直接处理的数据
Dialogue: 0,0:24:44.36,0:24:45.92,Default,,0,0,0,,那么它被拆了出来
Dialogue: 0,0:24:46.52,0:24:49.76,Default,,0,0,0,,之后 如果你让George构造一个复数
Dialogue: 0,0:24:51.24,0:24:54.56,Default,,0,0,0,,George就会把它构造成序对
Dialogue: 0,0:24:55.07,0:24:58.24,Default,,0,0,0,,在数据被传递到上层之前
Dialogue: 0,0:24:59.42,0:25:01.13,Default,,0,0,0,,经理会再给它加上rectangular类型
Dialogue: 0,0:25:03.92,0:25:04.65,Default,,0,0,0,,看这个过程
Dialogue: 0,0:25:04.65,0:25:05.85,Default,,0,0,0,,这个系统不会发生混乱
Dialogue: 0,0:25:05.85,0:25:10.84,Default,,0,0,0,,就算在Martha的世界里 序对(1 2)的含义完全不同
Dialogue: 0,0:25:13.50,0:25:15.75,Default,,0,0,0,,也并没有什么影响
Dialogue: 0,0:25:15.75,0:25:18.44,Default,,0,0,0,,在Martha的世界里这个序对代表了
Dialogue: 0,0:25:18.44,0:25:20.78,Default,,0,0,0,,一个模为1 辐角为2的复数
Dialogue: 0,0:25:21.19,0:25:22.19,Default,,0,0,0,,但是这并不会造成混乱
Dialogue: 0,0:25:22.22,0:25:27.25,Default,,0,0,0,,因为每当有一个这样的序对经由经理之手
Dialogue: 0,0:25:27.25,0:25:29.61,Default,,0,0,0,,被交给主系统的时候 它都会被附加上polar的类型标志
Dialogue: 0,0:25:31.21,0:25:33.67,Default,,0,0,0,,而这个就会被贴上rectangular类型的标签
Dialogue: 0,0:25:36.93,0:25:37.90,Default,,0,0,0,,好 我们休息一下
Dialogue: 0,0:25:40.77,0:25:55.55,Default,,0,0,0,,[音乐]
Dialogue: 0,0:25:55.69,0:25:57.77,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:25:57.77,0:25:59.76,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:26:05.21,0:26:11.95,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:26:12.84,0:26:16.75,Declare,,0,0,0,,{\an2\fad(500,500)}通用运算符
Dialogue: 0,0:26:20.21,0:26:24.15,Default,,0,0,0,,我们刚刚提出了一种实现通用运算符的策略
Dialogue: 0,0:26:24.15,0:26:31.40,Default,,0,0,0,,这种策略有一个名字 叫做“基于类型的分派”
Dialogue: 0,0:26:34.31,0:26:39.36,Default,,0,0,0,,它的想法就是你要把你的系统分成很多小块
Dialogue: 0,0:26:39.36,0:26:42.67,Default,,0,0,0,,里面有George和Martha在设计表示方法
Dialogue: 0,0:26:43.37,0:26:44.38,Default,,0,0,0,,还有一个经理
Dialogue: 0,0:26:46.12,0:26:48.06,Default,,0,0,0,,负责去看数据上的类型是什么
Dialogue: 0,0:26:48.51,0:26:50.59,Default,,0,0,0,,然后分派给正确的人去处理
Dialogue: 0,0:26:51.99,0:26:56.01,Default,,0,0,0,,这种组织系统的方法有什么缺点呢？
Dialogue: 0,0:26:58.15,0:27:00.40,Default,,0,0,0,,首先 有个小小的烦人的问题
Dialogue: 0,0:27:00.40,0:27:03.05,Default,,0,0,0,,George和Martha需要修改他们的过程的名字
Dialogue: 0,0:27:04.00,0:27:05.95,Default,,0,0,0,,George一开始写了一个real-part过程
Dialogue: 0,0:27:05.98,0:27:08.28,Default,,0,0,0,,现在他必须把它的名字改成real-part-rectangular
Dialogue: 0,0:27:08.30,0:27:10.83,Default,,0,0,0,,才能让它不与Martha的real-part过程相互冲突
Dialogue: 0,0:27:10.84,0:27:12.76,Default,,0,0,0,,而Martha的过程现在改叫real-part-polar
Dialogue: 0,0:27:13.64,0:27:16.68,Default,,0,0,0,,这是为了不和经理的那个叫做real-part的过程发生冲突
Dialogue: 0,0:27:17.31,0:27:18.94,Default,,0,0,0,,这个问题确实很恼人
Dialogue: 0,0:27:19.46,0:27:21.13,Default,,0,0,0,,但是我现在暂时不讨论这个问题
Dialogue: 0,0:27:21.27,0:27:22.35,Default,,0,0,0,,我们稍后将会看到
Dialogue: 0,0:27:23.26,0:27:26.12,Default,,0,0,0,,在讨论到Lisp名称与环境的结构的时候
Dialogue: 0,0:27:26.12,0:27:30.39,Default,,0,0,0,,我们会有方法把这些所谓的命名空间分开来封装
Dialogue: 0,0:27:30.39,0:27:31.56,Default,,0,0,0,,然后它们就不会互相影响了
Dialogue: 0,0:27:32.50,0:27:34.01,Default,,0,0,0,,现在我们暂时不去考虑这个问题
Dialogue: 0,0:27:35.72,0:27:38.19,Default,,0,0,0,,我现在想关注的问题是
Dialogue: 0,0:27:38.36,0:27:43.24,Default,,0,0,0,,你把一个新人招纳进系统之中会发生什么
Dialogue: 0,0:27:44.51,0:27:45.32,Default,,0,0,0,,会发生什么？
Dialogue: 0,0:27:45.32,0:27:46.81,Default,,0,0,0,,George和Martha并不关心
Dialogue: 0,0:27:47.42,0:27:50.73,Default,,0,0,0,,George在他的直角坐标世界里
Dialogue: 0,0:27:52.20,0:27:53.84,Default,,0,0,0,,坐拥着他的过程和数据类型
Dialogue: 0,0:27:54.09,0:27:55.74,Default,,0,0,0,,而Martha待在她的极坐标世界中
Dialogue: 0,0:27:55.93,0:27:57.02,Default,,0,0,0,,不问世事
Dialogue: 0,0:27:59.38,0:28:00.54,Default,,0,0,0,,但是经理呢？
Dialogue: 0,0:28:00.62,0:28:02.84,Default,,0,0,0,,经理需要做什么？
Dialogue: 0,0:28:03.18,0:28:06.20,Default,,0,0,0,,现在经理带着他的运算来了
Dialogue: 0,0:28:07.36,0:28:09.04,Default,,0,0,0,,有直角坐标的判断
Dialogue: 0,0:28:09.04,0:28:10.14,Default,,0,0,0,,和极坐标的判断过程
Dialogue: 0,0:28:10.14,0:28:14.91,Default,,0,0,0,,如果Harry带着某种新型的复数表示方法 进入这个系统
Dialogue: 0,0:28:17.21,0:28:19.96,Default,,0,0,0,,同时带来了一个新的类型--Harry型复数
Dialogue: 0,0:28:20.27,0:28:23.28,Default,,0,0,0,,经理就需要修改他所有的过程
Dialogue: 0,0:28:25.24,0:28:26.94,Default,,0,0,0,,所以这个系统的不灵活之处
Dialogue: 0,0:28:26.96,0:28:32.41,Default,,0,0,0,,也就是需要大量工作才能适应变化的地方 就在这个经理身上
Dialogue: 0,0:28:34.89,0:28:35.99,Default,,0,0,0,,那是非常恼人的事情
Dialogue: 0,0:28:35.99,0:28:37.21,Default,,0,0,0,,更恼人的是
Dialogue: 0,0:28:39.05,0:28:41.21,Default,,0,0,0,,你意识到这个经理实际上什么也不做
Dialogue: 0,0:28:42.59,0:28:44.67,Default,,0,0,0,,这个经理只负责“传递公文”而已
Dialogue: 0,0:28:45.84,0:28:51.13,Default,,0,0,0,,我们再来看看这些程序 它们在做什么
Dialogue: 0,0:28:51.76,0:28:52.72,Default,,0,0,0,,real-part过程在做什么
Dialogue: 0,0:28:52.88,0:28:56.17,Default,,0,0,0,,这个过程说 哦 这个复数是
Dialogue: 0,0:28:56.17,0:28:57.00,Default,,0,0,0,,George会处理的那一种吗
Dialogue: 0,0:28:57.00,0:28:58.27,Default,,0,0,0,,如果是的话 好 把它交给George处理
Dialogue: 0,0:28:59.41,0:29:01.76,Default,,0,0,0,,它是Martha能操作的那一种吗
Dialogue: 0,0:29:01.82,0:29:04.06,Default,,0,0,0,,是的话 把它交给Martha处理
Dialogue: 0,0:29:05.04,0:29:08.72,Default,,0,0,0,,这个系统真正恼人之处 也就是这个系统的瓶颈
Dialogue: 0,0:29:08.72,0:29:11.66,Default,,0,0,0,,它降低灵活性 阻碍变化
Dialogue: 0,0:29:12.09,0:29:14.36,Default,,0,0,0,,完全是一种的官僚主义
Dialogue: 0,0:29:15.00,0:29:17.02,Default,,0,0,0,,而不是任何做实事的人
Dialogue: 0,0:29:19.70,0:29:21.80,Default,,0,0,0,,很可惜这种情况经常发生
Dialogue: 0,0:29:23.18,0:29:24.41,Default,,0,0,0,,实际上发生的事情是
Dialogue: 0,0:29:24.48,0:29:26.97,Default,,0,0,0,,在系统中 有一张抽象的表格
Dialogue: 0,0:29:28.10,0:29:30.08,Default,,0,0,0,,实际发生的事情是 有这样一张表格
Dialogue: 0,0:29:30.84,0:29:33.64,Default,,0,0,0,,其中有各种类型
Dialogue: 0,0:29:34.40,0:29:38.96,Default,,0,0,0,,有polar和rectangular
Dialogue: 0,0:29:41.55,0:29:43.02,Default,,0,0,0,,可能Harry也在这里
Dialogue: 0,0:29:44.38,0:29:46.56,Default,,0,0,0,,然后这里是各种运算符
Dialogue: 0,0:29:48.05,0:29:58.24,Default,,0,0,0,,各种运算符 比如real-part和imag-part
Dialogue: 0,0:30:00.01,0:30:04.22,Default,,0,0,0,,还有magnitude、angle这些运算符
Dialogue: 0,0:30:05.83,0:30:18.97,Default,,0,0,0,,单元格中对应的是相应过程
Dialogue: 0,0:30:19.28,0:30:21.99,Default,,0,0,0,,那么填在这里 负责polar类型的real-part过程的是
Dialogue: 0,0:30:21.99,0:30:27.56,Default,,0,0,0,,Martha的real-part-polar过程
Dialogue: 0,0:30:30.57,0:30:36.62,Default,,0,0,0,,然后在这里是George的real-part-rectangular过程
Dialogue: 0,0:30:37.74,0:30:43.07,Default,,0,0,0,,然后这里是Martha的magnitude-polar过程
Dialogue: 0,0:30:44.46,0:30:49.76,Default,,0,0,0,,然后是George的magnitude-rectangular过程 等等等等
Dialogue: 0,0:30:49.76,0:30:51.24,Default,,0,0,0,,剩下的单元格也像这样填好
Dialogue: 0,0:30:52.39,0:30:54.26,Default,,0,0,0,,这就是实际上发生的事情
Dialogue: 0,0:30:57.63,0:31:01.74,Default,,0,0,0,,从某种意义上讲 经理做的事情就是
Dialogue: 0,0:31:02.11,0:31:04.11,Default,,0,0,0,,去扮演这张表格
Dialogue: 0,0:31:06.86,0:31:08.70,Default,,0,0,0,,那我们怎么去修补这个系统呢
Dialogue: 0,0:31:11.74,0:31:13.77,Default,,0,0,0,,怎么去消灭这种官僚主义？
Dialogue: 0,0:31:13.77,0:31:15.44,Default,,0,0,0,,你要做的就是让这个经理走人
Dialogue: 0,0:31:16.01,0:31:19.55,Default,,0,0,0,,我们用一台计算机来代替他
Dialogue: 0,0:31:20.17,0:31:21.76,Default,,0,0,0,,我们要让自动操作抹掉他存在的意义
Dialogue: 0,0:31:23.32,0:31:26.57,Default,,0,0,0,,也就是说 我们不用这个经理去查阅这个表格
Dialogue: 0,0:31:27.45,0:31:29.32,Default,,0,0,0,,而是让我们的系统直接去查阅它
Dialogue: 0,0:31:31.02,0:31:32.11,Default,,0,0,0,,这是什么意思呢？
Dialogue: 0,0:31:32.11,0:31:36.19,Default,,0,0,0,,我们来假设 还是用数据抽象的观点
Dialogue: 0,0:31:37.71,0:31:40.40,Default,,0,0,0,,我们有这样一种表格数据结构
Dialogue: 0,0:31:40.88,0:31:43.61,Default,,0,0,0,,而且我们还有把东西填进去和从中删除的方法
Dialogue: 0,0:31:44.35,0:31:49.04,Default,,0,0,0,,为了把话说清楚 我们假设现在有一个叫put的方法
Dialogue: 0,0:31:50.30,0:31:58.32,Default,,0,0,0,,本例中put方法接受两个参数 -- 我们称其为“关键字” -- key1和key2
Dialogue: 0,0:32:00.13,0:32:00.99,Default,,0,0,0,,还有接受一个值
Dialogue: 0,0:32:06.20,0:32:11.12,Default,,0,0,0,,put过程把value存放在表格key1和key2对应的格子里
Dialogue: 0,0:32:11.49,0:32:13.16,Default,,0,0,0,,然后我们假设有另一个叫get的过程
Dialogue: 0,0:32:15.23,0:32:18.72,Default,,0,0,0,,它是这样的一个东西 如果我说把表格里
Dialogue: 0,0:32:19.40,0:32:22.76,Default,,0,0,0,,存储在key1和key2对应的格子中的数据给我
Dialogue: 0,0:32:23.40,0:32:25.39,Default,,0,0,0,,它会把存储在那里的东西返回给我
Dialogue: 0,0:32:26.73,0:32:29.44,Default,,0,0,0,,我们先不要担心这个表格怎么实现
Dialogue: 0,0:32:30.00,0:32:32.52,Default,,0,0,0,,那又是另一个数据抽象了 是George需要考虑的问题
Dialogue: 0,0:32:33.06,0:32:34.36,Default,,0,0,0,,也许稍后我们还会看到
Dialogue: 0,0:32:34.70,0:32:36.97,Default,,0,0,0,,我们还会讨论怎么用Lisp建立这个表格
Dialogue: 0,0:32:40.71,0:32:45.50,Default,,0,0,0,,我们有了这个组织结构 George和Martha需要做什么呢？
Dialogue: 0,0:32:47.38,0:32:49.07,Default,,0,0,0,,当他们构建自己的系统的时候
Dialogue: 0,0:32:49.13,0:32:51.08,Default,,0,0,0,,都有责任在表格里
Dialogue: 0,0:32:51.44,0:32:53.82,Default,,0,0,0,,正确地添加上自己的那一列
Dialogue: 0,0:32:55.21,0:32:57.47,Default,,0,0,0,,比如说 对于George
Dialogue: 0,0:32:59.79,0:33:02.06,Default,,0,0,0,,当他定义过程的时候 他需要做的就是
Dialogue: 0,0:33:02.27,0:33:07.99,Default,,0,0,0,,把它们放进表格中的rectangular类型的那一列下面
Dialogue: 0,0:33:09.82,0:33:12.12,Default,,0,0,0,,然后操作的名字是real-part
Dialogue: 0,0:33:13.31,0:33:15.26,Default,,0,0,0,,放入他的real-part-rectangular过程
Dialogue: 0,0:33:16.25,0:33:17.78,Default,,0,0,0,,注意有什么被放到了表格里
Dialogue: 0,0:33:17.78,0:33:22.10,Default,,0,0,0,,这里的两个key是这两个符号：rectangular和real-part
Dialogue: 0,0:33:22.10,0:33:22.75,Default,,0,0,0,,这是引用
Dialogue: 0,0:33:24.40,0:33:26.75,Default,,0,0,0,,要被填到表里的东西
Dialogue: 0,0:33:26.84,0:33:29.21,Default,,0,0,0,,是他编写的real-part-rectangular过程
Dialogue: 0,0:33:31.85,0:33:34.30,Default,,0,0,0,,然后把这个获取虚部的过程也放进表里
Dialogue: 0,0:33:34.59,0:33:37.80,Default,,0,0,0,,分类到rectangular和imag-part两个关键字之下
Dialogue: 0,0:33:38.62,0:33:42.88,Default,,0,0,0,,获取模值的过程放到rectangular和magnitude下面
Dialogue: 0,0:33:43.61,0:33:45.20,Default,,0,0,0,,获取辐角的过程放到rectangular和angle下面
Dialogue: 0,0:33:47.04,0:33:50.84,Default,,0,0,0,,George作为系统的一部分 就要做以上这些事情
Dialogue: 0,0:33:54.42,0:33:58.86,Default,,0,0,0,,Martha用同样的方法填好表格中关于polar的这一列
Dialogue: 0,0:33:59.43,0:34:00.65,Default,,0,0,0,,在polar和real-part对应的这一栏
Dialogue: 0,0:34:01.69,0:34:03.58,Default,,0,0,0,,应该填的过程是real-part-polar是吧？
Dialogue: 0,0:34:04.34,0:34:07.29,Default,,0,0,0,,然后分别是imag-part、magnitude和angle过程
Dialogue: 0,0:34:08.91,0:34:11.40,Default,,0,0,0,,Martha想要加入系统当中就要做这些事情
Dialogue: 0,0:34:11.40,0:34:13.55,Default,,0,0,0,,每个设计了数据表示的人
Dialogue: 0,0:34:13.55,0:34:17.63,Default,,0,0,0,,都必须在表格里设置自己的一列
Dialogue: 0,0:34:17.76,0:34:19.90,Default,,0,0,0,,那么Harry带着他的绝妙的复数实现方法
Dialogue: 0,0:34:19.90,0:34:21.80,Default,,0,0,0,,过来的时候 他需要做什么呢
Dialogue: 0,0:34:21.80,0:34:23.96,Default,,0,0,0,,他先把过程写好
Dialogue: 0,0:34:24.04,0:34:26.52,Default,,0,0,0,,然后在表格里再建立一列
Dialogue: 0,0:34:28.55,0:34:30.04,Default,,0,0,0,,那么现在经理怎么样了呢
Dialogue: 0,0:34:31.33,0:34:34.61,Default,,0,0,0,,经理的存在被自动操作所取代
Dialogue: 0,0:34:34.61,0:34:37.11,Default,,0,0,0,,被一个叫做operate的过程代替
Dialogue: 0,0:34:37.11,0:34:39.55,Default,,0,0,0,,这是这个系统最关键的一个过程
Dialogue: 0,0:34:40.38,0:34:45.92,Default,,0,0,0,,(define operate
Dialogue: 0,0:34:51.06,0:34:56.09,Default,,0,0,0,,Operate过程接收你想要采取的运算
Dialogue: 0,0:34:57.75,0:34:58.88,Default,,0,0,0,,应该说是这个运算的名字
Dialogue: 0,0:34:59.20,0:35:03.28,Default,,0,0,0,,和被运算的对象
Dialogue: 0,0:35:04.21,0:35:09.76,Default,,0,0,0,,那么举例来说 对一个复数调用real-part operate过程会做什么呢
Dialogue: 0,0:35:09.95,0:35:11.90,Default,,0,0,0,,它要做的第一件事就是去查表
Dialogue: 0,0:35:12.64,0:35:13.87,Default,,0,0,0,,它查询这个表格
Dialogue: 0,0:35:14.80,0:35:22.56,Default,,0,0,0,,试图去找到存储在表格里的一个过程
Dialogue: 0,0:35:23.15,0:35:24.80,Default,,0,0,0,,所以它要对表格调用get过程
Dialogue: 0,0:35:25.50,0:35:33.92,Default,,0,0,0,,用对象的类型和运算的名称作为关键字进行检索
Dialogue: 0,0:35:38.92,0:35:40.14,Default,,0,0,0,,这样就可以知道在表格中
Dialogue: 0,0:35:40.38,0:35:42.72,Default,,0,0,0,,与数据的类型和要进行的运算相对应的是什么了
Dialogue: 0,0:35:42.89,0:35:44.35,Default,,0,0,0,,对应的这一格里填了什么东西
Dialogue: 0,0:35:44.44,0:35:45.93,Default,,0,0,0,,我们假设get过程已经被实现好了
Dialogue: 0,0:35:45.93,0:35:47.72,Default,,0,0,0,,所以如果在那一格什么也没有
Dialogue: 0,0:35:48.11,0:35:51.79,Default,,0,0,0,,它就会返回一个空表
Dialogue: 0,0:35:52.67,0:35:55.39,Default,,0,0,0,,如果那里确实有什么东西
Dialogue: 0,0:35:56.62,0:36:00.43,Default,,0,0,0,,如果存储有这样的一个过程
Dialogue: 0,0:36:03.15,0:36:07.12,Default,,0,0,0,,那么就会把在表格里找到的这个过程
Dialogue: 0,0:36:09.79,0:36:15.00,Default,,0,0,0,,应用到对象的具体内容上去
Dialogue: 0,0:36:18.25,0:36:20.40,Default,,0,0,0,,如果那里没有东西的话
Dialogue: 0,0:36:20.67,0:36:22.51,Default,,0,0,0,,它就会 -- 我们可以决定
Dialogue: 0,0:36:22.81,0:36:27.12,Default,,0,0,0,,本例中 我们让它输出一个错误消息：“未定义的运算符”
Dialogue: 0,0:36:28.48,0:36:30.24,Default,,0,0,0,,没有支持这种类型的运算符
Dialogue: 0,0:36:33.07,0:36:34.72,Default,,0,0,0,,或者其它合适的错误信息
Dialogue: 0,0:36:39.07,0:36:39.48,Default,,0,0,0,,对吧？
Dialogue: 0,0:36:39.72,0:36:41.04,Default,,0,0,0,,这个东西替代了经理
Dialogue: 0,0:36:41.89,0:36:42.91,Default,,0,0,0,,我们怎么去使用它呢
Dialogue: 0,0:36:43.96,0:36:49.80,Default,,0,0,0,,我们的想法是用operate过程来定义通用选择函数
Dialogue: 0,0:36:50.04,0:36:56.75,Default,,0,0,0,,我们可以说一个对象的real-part
Dialogue: 0,0:36:57.14,0:37:05.66,Default,,0,0,0,,是这个对象被operate应用了叫做real-part的运算后得到的结果
Dialogue: 0,0:37:08.07,0:37:12.22,Default,,0,0,0,,那么类似地 imag-part是operate对obj应用imag-part运算
Dialogue: 0,0:37:12.22,0:37:13.98,Default,,0,0,0,,magnitude和angle同理
Dialogue: 0,0:37:15.36,0:37:17.43,Default,,0,0,0,,这就是我们的实现方法
Dialogue: 0,0:37:17.43,0:37:20.48,Default,,0,0,0,,由它们加上类型再加上operate过程组成
Dialogue: 0,0:37:21.33,0:37:24.00,Default,,0,0,0,,这个表格现在就有效地完成了之前经理的工作
Dialogue: 0,0:37:24.06,0:37:27.69,Default,,0,0,0,,我们来梳理一下在这个过程中发生的事情
Dialogue: 0,0:37:27.90,0:37:33.00,Default,,0,0,0,,假设我有一个由Martha构造的复数
Dialogue: 0,0:37:33.53,0:37:38.80,Default,,0,0,0,,它的模值是1 辐角是2
Dialogue: 0,0:37:39.10,0:37:40.22,Default,,0,0,0,,它是由Martha构造的
Dialogue: 0,0:37:40.22,0:37:45.45,Default,,0,0,0,,所以它被贴上了polar的标签
Dialogue: 0,0:37:47.24,0:37:48.00,Default,,0,0,0,,我们叫它z
Dialogue: 0,0:37:48.00,0:37:48.91,Default,,0,0,0,,假设这就是z
Dialogue: 0,0:37:51.77,0:37:54.46,Default,,0,0,0,,然后假设在这种实现方法下
Dialogue: 0,0:37:54.80,0:37:57.92,Default,,0,0,0,,有人想要取z的实部
Dialogue: 0,0:38:04.87,0:38:07.96,Default,,0,0,0,,由于real-part现在是用operate来定义的
Dialogue: 0,0:38:09.16,0:38:10.57,Default,,0,0,0,,这就等同于说
Dialogue: 0,0:38:12.09,0:38:24.81,Default,,0,0,0,,调用 (operate 'real-part z)
Dialogue: 0,0:38:27.06,0:38:28.09,Default,,0,0,0,,然后operate过程
Dialogue: 0,0:38:28.09,0:38:29.24,Default,,0,0,0,,就会去查询表格
Dialogue: 0,0:38:31.04,0:38:34.36,Default,,0,0,0,,然后试图去寻找在表格里存放的
Dialogue: 0,0:38:39.00,0:38:46.22,Default,,0,0,0,,查询表格中与对象的类型相对应的一列
Dialogue: 0,0:38:46.72,0:38:48.22,Default,,0,0,0,,那么z的类型是polar
Dialogue: 0,0:38:48.79,0:38:51.37,Default,,0,0,0,,所以它就要说 我用polar作为关键字查表
Dialogue: 0,0:38:52.99,0:38:58.57,Default,,0,0,0,,然后运算的名称是real-part
Dialogue: 0,0:39:05.96,0:39:13.63,Default,,0,0,0,,它查询对应的过程 然后应用到z的内容上去
Dialogue: 0,0:39:14.83,0:39:17.13,Default,,0,0,0,,如果所有东西都安排妥当的话
Dialogue: 0,0:39:17.74,0:39:21.70,Default,,0,0,0,,如果它找到的过程就是Martha编写的过程
Dialogue: 0,0:39:21.70,0:39:22.95,Default,,0,0,0,,也就是real-part-polar
Dialogue: 0,0:39:31.05,0:39:35.13,Default,,0,0,0,,然后这就是z去掉类型之后的东西
Dialogue: 0,0:39:35.44,0:39:38.94,Default,,0,0,0,,是Martha最初设计的数据表示
Dialogue: 0,0:39:39.40,0:39:40.43,Default,,0,0,0,,也就是这里的(1 2)
Dialogue: 0,0:39:43.71,0:39:45.87,Default,,0,0,0,,所以说在整个系统中 operate过程
Dialogue: 0,0:39:46.46,0:39:48.89,Default,,0,0,0,,和之前的经理做的事情没什么区别
Dialogue: 0,0:39:49.45,0:39:52.59,Default,,0,0,0,,它通过查询表格找到正确的东西  然后剥离类型
Dialogue: 0,0:39:53.58,0:39:57.52,Default,,0,0,0,,然后把它传递给能够处理它的人
Dialogue: 0,0:39:58.88,0:40:05.48,Default,,0,0,0,,你会发现 这是另一种 在大多数情况下
Dialogue: 0,0:40:06.22,0:40:08.04,Default,,0,0,0,,更灵活地实现通用运算符的方法
Dialogue: 0,0:40:08.08,0:40:15.69,Default,,0,0,0,,我们把它叫做“数据导向编程”
Dialogue: 0,0:40:20.35,0:40:21.96,Default,,0,0,0,,其理念是
Dialogue: 0,0:40:23.42,0:40:25.55,Default,,0,0,0,,在某种意义上 这些数据对象本身
Dialogue: 0,0:40:26.04,0:40:28.35,Default,,0,0,0,,这些充斥在系统中的复数
Dialogue: 0,0:40:28.73,0:40:33.16,Default,,0,0,0,,它们自身就携带着 关于应该怎么去操作它们的信息
Dialogue: 0,0:40:35.74,0:40:36.78,Default,,0,0,0,,有什么疑问吗？
Dialogue: 0,0:40:41.00,0:40:41.24,Default,,0,0,0,,请说
Dialogue: 0,0:40:41.24,0:40:43.39,Default,,0,0,0,,学生：你在那个数据对象里存储的是什么呢
Dialogue: 0,0:40:43.39,0:40:47.10,Default,,0,0,0,,这里面有这个数据本身 还有它的类型
Dialogue: 0,0:40:47.10,0:40:49.60,Default,,0,0,0,,还有该与该类型对应的运算
Dialogue: 0,0:40:49.69,0:40:53.08,Default,,0,0,0,,或者说那些运算是存储在哪里呢？
Dialogue: 0,0:40:53.60,0:40:54.17,Default,,0,0,0,,教授：好 让我--
Dialogue: 0,0:40:54.98,0:40:56.50,Default,,0,0,0,,恩 这是一个好问题
Dialogue: 0,0:40:56.50,0:41:00.46,Default,,0,0,0,,通过它暗示了实现我们目标的 其它可行方法
Dialogue: 0,0:41:00.75,0:41:02.48,Default,,0,0,0,,当然可能的方法有很多
Dialogue: 0,0:41:04.20,0:41:06.14,Default,,0,0,0,,在这个特定的实现当中
Dialogue: 0,0:41:06.24,0:41:09.72,Default,,0,0,0,,在这个数据对象里放着
Dialogue: 0,0:41:10.44,0:41:13.45,Default,,0,0,0,,就是数据本身 本例中是序对(1, 2)
Dialogue: 0,0:41:14.98,0:41:16.55,Default,,0,0,0,,和一个符号
Dialogue: 0,0:41:16.55,0:41:19.07,Default,,0,0,0,,就是这个符号 单词P-O-L-A-R
Dialogue: 0,0:41:20.60,0:41:22.33,Default,,0,0,0,,这些就是这个数据对象里面的东西
Dialogue: 0,0:41:24.24,0:41:26.69,Default,,0,0,0,,那么这些运算又是存放在哪里的呢？
Dialogue: 0,0:41:26.69,0:41:29.00,Default,,0,0,0,,那些运算在表格里
Dialogue: 0,0:41:29.85,0:41:31.07,Default,,0,0,0,,在这个表格里
Dialogue: 0,0:41:32.30,0:41:36.46,Default,,0,0,0,,所有行和列的名字都是符号
Dialogue: 0,0:41:38.23,0:41:40.08,Default,,0,0,0,,所以当我往里面存什么东西的时候
Dialogue: 0,0:41:40.09,0:41:47.02,Default,,0,0,0,,可以以符号polar或符号magnitude作为关键字
Dialogue: 0,0:41:48.24,0:41:51.31,Default,,0,0,0,,我这样写 可能让你们感到困惑了
Dialogue: 0,0:41:51.31,0:41:52.70,Default,,0,0,0,,因为在这里面放的并不是
Dialogue: 0,0:41:53.16,0:41:54.57,Default,,0,0,0,,当我写下mag-polar的时候
Dialogue: 0,0:41:57.04,0:41:59.23,Default,,0,0,0,,我指的是那个叫mag-polar的过程
Dialogue: 0,0:41:59.85,0:42:01.85,Default,,0,0,0,,可能 我本来应该在这里写上
Dialogue: 0,0:42:02.58,0:42:04.20,Default,,0,0,0,,但是这里空间太小了
Dialogue: 0,0:42:04.20,0:42:05.07,Default,,0,0,0,,我写不下
Dialogue: 0,0:42:05.58,0:42:08.92,Default,,0,0,0,,应该写成lambda(z)
Dialogue: 0,0:42:10.60,0:42:12.75,Default,,0,0,0,,然后调用Martha实现的过程
Dialogue: 0,0:42:14.71,0:42:15.72,Default,,0,0,0,,你也可以从这里看出
Dialogue: 0,0:42:15.74,0:42:17.44,Default,,0,0,0,,我已经暗示了另一种方法
Dialogue: 0,0:42:17.71,0:42:19.82,Default,,0,0,0,,来解决名字冲突的问题
Dialogue: 0,0:42:20.04,0:42:23.15,Default,,0,0,0,,那就是George和Martha根本不用给他们的过程起名字
Dialogue: 0,0:42:23.15,0:42:25.37,Default,,0,0,0,,可以直接把由lambda定义的
Dialogue: 0,0:42:25.39,0:42:28.12,Default,,0,0,0,,由lambda定义的匿名函数放进表格里
Dialogue: 0,0:42:28.66,0:42:31.76,Default,,0,0,0,,你的问题还引出了另一种可能性
Dialogue: 0,0:42:32.35,0:42:34.06,Default,,0,0,0,,也就是
Dialogue: 0,0:42:34.83,0:42:37.92,Default,,0,0,0,,可能我在这个数据对象里存储的
Dialogue: 0,0:42:37.95,0:42:39.48,Default,,0,0,0,,不是符号POLAR
Dialogue: 0,0:42:39.93,0:42:42.35,Default,,0,0,0,,也许是这些运算本身
Dialogue: 0,0:42:43.90,0:42:45.63,Default,,0,0,0,,这是组织系统的另一种方法
Dialogue: 0,0:42:45.66,0:42:46.60,Default,,0,0,0,,叫做“消息传递”
Dialogue: 0,0:42:48.65,0:42:49.92,Default,,0,0,0,,它们都殊途同归
Dialogue: 0,0:42:54.64,0:42:58.04,Default,,0,0,0,,学生：所以说如果Martha和George
Dialogue: 0,0:42:58.04,0:43:01.23,Default,,0,0,0,,用了相同的过程名字也没什么问题
Dialogue: 0,0:43:01.23,0:43:02.56,Default,,0,0,0,,[听不清]
Dialogue: 0,0:43:02.56,0:43:04.68,Default,,0,0,0,,教授：对 你说得很对
Dialogue: 0,0:43:04.80,0:43:07.85,Default,,0,0,0,,看 他们甚至根本不需要给他们的过程命名
Dialogue: 0,0:43:08.04,0:43:09.36,Default,,0,0,0,,George和Martha可以 --
Dialogue: 0,0:43:09.50,0:43:10.62,Default,,0,0,0,,George可以这么来做
Dialogue: 0,0:43:10.83,0:43:15.28,Default,,0,0,0,,与其在rectangular和real-part对应的格子里放
Dialogue: 0,0:43:16.22,0:43:17.98,Default,,0,0,0,,存放real-part-rectangular这个过程
Dialogue: 0,0:43:18.03,0:43:21.15,Default,,0,0,0,,George可以在rectangular和real-part对应的格子里放
Dialogue: 0,0:43:21.24,0:43:23.69,Default,,0,0,0,,放一个lambda(z) 然后什么什么
Dialogue: 0,0:43:24.54,0:43:26.84,Default,,0,0,0,,整个系统会以完全相同的方式工作
Dialogue: 0,0:43:27.33,0:43:29.24,Default,,0,0,0,,学生：我的问题是 就算Martha在
Dialogue: 0,0:43:29.84,0:43:33.60,Default,,0,0,0,,Martha在key1和key2对应的格子里放了real-part过程
Dialogue: 0,0:43:33.95,0:43:37.64,Default,,0,0,0,,George也在key1和key2下放了一个real-part过程
Dialogue: 0,0:43:37.96,0:43:39.60,Default,,0,0,0,,只要两个过程的定义不一样
Dialogue: 0,0:43:39.80,0:43:41.26,Default,,0,0,0,,它们就不会发生任何冲突 对吗？
Dialogue: 0,0:43:41.29,0:43:43.80,Default,,0,0,0,,教授：对的 这完全没有问题
Dialogue: 0,0:43:44.97,0:43:47.13,Default,,0,0,0,,除非你说的是George和Martha在同一个终端上工作
Dialogue: 0,0:43:47.13,0:43:49.20,Default,,0,0,0,,并且他们两个人起的所有名字的含义全部相同
Dialogue: 0,0:43:49.82,0:43:51.23,Default,,0,0,0,,那么同样的real-part就会造成困扰
Dialogue: 0,0:43:51.24,0:43:52.80,Default,,0,0,0,,但是就算是这种情况也有办法解决
Dialogue: 0,0:43:52.80,0:43:54.80,Default,,0,0,0,,从原则上讲你说的完全正确
Dialogue: 0,0:43:54.98,0:43:56.29,Default,,0,0,0,,如果它们的名字不互相冲突的话
Dialogue: 0,0:43:56.29,0:43:58.19,Default,,0,0,0,,被填到表里的是对象本身 而不是它们的名字
Dialogue: 0,0:44:08.20,0:44:09.05,Default,,0,0,0,,好 我们休息一下
Dialogue: 0,0:44:12.91,0:44:20.48,Default,,0,0,0,,[音乐]
Dialogue: 0,0:44:20.96,0:44:23.29,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:44:23.45,0:44:25.29,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:44:57.42,0:45:05.07,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:45:05.47,0:45:09.24,Declare,,0,0,0,,{\an2\fad(500,500)}通用运算符
Dialogue: 0,0:45:12.88,0:45:16.88,Default,,0,0,0,,教授：好的 我们刚刚讲了一个数据导向编程的例子
Dialogue: 0,0:45:17.68,0:45:22.84,Default,,0,0,0,,我们将其用于实现一个复数域上的算术系统
Dialogue: 0,0:45:27.60,0:45:32.48,Default,,0,0,0,,我已经在里面实现了 +c -c 这些运算
Dialogue: 0,0:45:32.88,0:45:37.24,Default,,0,0,0,,*c \c 还有其它的一些过程
Dialogue: 0,0:45:38.23,0:45:45.72,Default,,0,0,0,,这些过程存在于上层 -- 这是关键之处
Dialogue: 0,0:45:45.74,0:45:49.60,Default,,0,0,0,,它们存在于两种不同表示方式的上层
Dialogue: 0,0:45:50.34,0:45:55.44,Default,,0,0,0,,这是一个直角坐标程序包 这里一个极坐标程序包
Dialogue: 0,0:45:58.14,0:45:59.15,Default,,0,0,0,,可能还有其它的东西
Dialogue: 0,0:45:59.15,0:46:02.80,Default,,0,0,0,,关键理念就是 “其它的东西”可以很容易地添加上去
Dialogue: 0,0:46:04.67,0:46:08.35,Default,,0,0,0,,但是这并没有真正体现出这种方法学的威力
Dialogue: 0,0:46:08.90,0:46:10.15,Default,,0,0,0,,我们看看发生了什么
Dialogue: 0,0:46:10.15,0:46:12.33,Default,,0,0,0,,这个方法的威力 只有当你
Dialogue: 0,0:46:12.94,0:46:15.79,Default,,0,0,0,,当你把它嵌入于一些更复杂的系统中时才会显现
Dialogue: 0,0:46:16.17,0:46:17.74,Default,,0,0,0,,我现在要做的就是
Dialogue: 0,0:46:17.87,0:46:20.01,Default,,0,0,0,,把它嵌入一个更复杂的系统中
Dialogue: 0,0:46:20.25,0:46:25.28,Default,,0,0,0,,假设我们已经有了一个通用算术系统
Dialogue: 0,0:46:25.28,0:46:27.24,Default,,0,0,0,,所谓的“通用算术系统”
Dialogue: 0,0:46:27.24,0:46:28.54,Default,,0,0,0,,然后在系统的最顶层
Dialogue: 0,0:46:30.76,0:46:35.92,Default,,0,0,0,,用户可以命令它把两个东西相加 或者相减
Dialogue: 0,0:46:37.45,0:46:41.05,Default,,0,0,0,,或者让两数相乘、相除
Dialogue: 0,0:46:44.14,0:46:46.52,Default,,0,0,0,,然后在它们下面是一个抽象屏障
Dialogue: 0,0:46:47.93,0:46:49.15,Default,,0,0,0,,抽象屏障的下层
Dialogue: 0,0:46:49.50,0:46:52.48,Default,,0,0,0,,是一个复数域算术程序包
Dialogue: 0,0:46:53.02,0:46:54.96,Default,,0,0,0,,然后你可以让它把两个复数相加
Dialogue: 0,0:46:55.04,0:46:58.83,Default,,0,0,0,,或者你还可以把 有理数域算术程序包
Dialogue: 0,0:46:58.88,0:46:59.93,Default,,0,0,0,,给安装进来
Dialogue: 0,0:47:00.19,0:47:01.72,Default,,0,0,0,,可以放进去有理数
Dialogue: 0,0:47:04.76,0:47:06.22,Default,,0,0,0,,然后有理数程序包里面
Dialogue: 0,0:47:07.16,0:47:14.75,Default,,0,0,0,,有我们实现的 +rat、*rat等等的这些过程
Dialogue: 0,0:47:15.39,0:47:17.01,Default,,0,0,0,,或者你还可以加上通常的Lisp算术系统
Dialogue: 0,0:47:17.01,0:47:18.99,Default,,0,0,0,,你可以让它把3和4加起来
Dialogue: 0,0:47:19.42,0:47:20.94,Default,,0,0,0,,那么我们在这个系统里加入通常的算术系统
Dialogue: 0,0:47:28.28,0:47:34.67,Default,,0,0,0,,其中有Lisp自带的 + - * /
Dialogue: 0,0:47:36.67,0:47:39.12,Default,,0,0,0,,总而言之 我们可以想象这个复数系统
Dialogue: 0,0:47:39.44,0:47:44.44,Default,,0,0,0,,存在于一个更加复杂的通用运算系统里面
Dialogue: 0,0:47:47.73,0:47:48.73,Default,,0,0,0,,我们怎么才能做到呢
Dialogue: 0,0:47:49.05,0:47:52.32,Default,,0,0,0,,我们已经有了想法 只要再一次应用它就可以了
Dialogue: 0,0:47:52.78,0:47:54.72,Default,,0,0,0,,我们已经实现了一个有理数程序包
Dialogue: 0,0:47:54.72,0:47:56.89,Default,,0,0,0,,那么我们来看看应该怎么修改它
Dialogue: 0,0:48:01.48,0:48:03.40,Default,,0,0,0,,实际上 在这个层面 它根本就不需要修改
Dialogue: 0,0:48:03.73,0:48:05.88,Default,,0,0,0,,这完全就是我们上次写的那些代码
Dialogue: 0,0:48:07.18,0:48:08.97,Default,,0,0,0,,要把两个有理数相加
Dialogue: 0,0:48:09.85,0:48:10.91,Default,,0,0,0,,回忆一下 我们要用到这个公式
Dialogue: 0,0:48:11.14,0:48:13.37,Default,,0,0,0,,构造一个有理数 它的分子是
Dialogue: 0,0:48:13.98,0:48:17.56,Default,,0,0,0,,x的分子乘以y的分母
Dialogue: 0,0:48:17.93,0:48:21.52,Default,,0,0,0,,加上 x的分母乘以y的分子
Dialogue: 0,0:48:21.52,0:48:23.79,Default,,0,0,0,,而结果的分母是 x的分母乘y的分母
Dialogue: 0,0:48:25.76,0:48:29.07,Default,,0,0,0,,然后是-rat、*rat、/rat这些过程
Dialogue: 0,0:48:30.36,0:48:35.12,Default,,0,0,0,,这就是我们之前写的那个有理数程序包
Dialogue: 0,0:48:36.31,0:48:38.89,Default,,0,0,0,,我们忽略最大公约数的问题 先不去考虑那个
Dialogue: 0,0:48:39.08,0:48:42.59,Default,,0,0,0,,作为这个有理数包的实现人员
Dialogue: 0,0:48:42.80,0:48:45.10,Default,,0,0,0,,怎么把它安装到我们的通用运算系统中呢？
Dialogue: 0,0:48:45.57,0:48:46.22,Default,,0,0,0,,那很简单
Dialogue: 0,0:48:47.29,0:48:51.56,Default,,0,0,0,,我们要做的事只有一件和之前不同
Dialogue: 0,0:48:51.84,0:48:55.71,Default,,0,0,0,,在之前我们说构造一个有理数
Dialogue: 0,0:48:56.27,0:48:59.98,Default,,0,0,0,,就是构造一个由分子分母组成的序对
Dialogue: 0,0:49:00.96,0:49:03.20,Default,,0,0,0,,现在我们不光构造这个序对 还要给它贴上标签
Dialogue: 0,0:49:03.30,0:49:04.56,Default,,0,0,0,,给它加上rational类型
Dialogue: 0,0:49:06.36,0:49:08.09,Default,,0,0,0,,这就是唯一的不同之处
Dialogue: 0,0:49:08.56,0:49:10.09,Default,,0,0,0,,把它变成带类型的数据
Dialogue: 0,0:49:12.38,0:49:14.08,Default,,0,0,0,,现在 我们要把运算放进表格里
Dialogue: 0,0:49:14.36,0:49:18.20,Default,,0,0,0,,我们在rational符号和add运算对应的格子里
Dialogue: 0,0:49:18.92,0:49:20.25,Default,,0,0,0,,放进我们的+rat过程
Dialogue: 0,0:49:21.82,0:49:23.24,Default,,0,0,0,,再次强调 这是一个符号
Dialogue: 0,0:49:23.74,0:49:23.93,Default,,0,0,0,,看到了么？
Dialogue: 0,0:49:24.03,0:49:25.29,Default,,0,0,0,,这是引用 这也是引用
Dialogue: 0,0:49:25.31,0:49:28.01,Default,,0,0,0,,但是实际上放进表里的是+rat过程本身
Dialogue: 0,0:49:29.82,0:49:31.77,Default,,0,0,0,,然后怎么做减法
Dialogue: 0,0:49:31.79,0:49:36.81,Default,,0,0,0,,我们用-rat过程做减法
Dialogue: 0,0:49:38.27,0:49:40.24,Default,,0,0,0,,然后是乘法和除法
Dialogue: 0,0:49:41.09,0:49:43.64,Default,,0,0,0,,这些步骤精准地描述了 我们该怎么做
Dialogue: 0,0:49:44.14,0:49:46.97,Default,,0,0,0,,来兼容这个通用算术系统
Dialogue: 0,0:49:48.51,0:49:49.88,Default,,0,0,0,,那么整个系统怎么工作呢
Dialogue: 0,0:49:51.56,0:49:58.40,Default,,0,0,0,,我们想实现的是通用运算符
Dialogue: 0,0:49:59.34,0:50:02.80,Default,,0,0,0,,为了让add、sub、mul和div变成通用运算符
Dialogue: 0,0:50:03.99,0:50:17.36,Default,,0,0,0,,所以我们要把add过程定义为 (ADD X Y)就是
Dialogue: 0,0:50:18.62,0:50:22.12,Default,,0,0,0,,就是调用operate过程
Dialogue: 0,0:50:26.08,0:50:27.49,Default,,0,0,0,,我们把这个叫做operate-2
Dialogue: 0,0:50:27.49,0:50:30.78,Default,,0,0,0,,这是我们的操作过程 但是要接收两个参数
Dialogue: 0,0:50:31.60,0:50:35.84,Default,,0,0,0,,对它们应用add 把它们加起来
Dialogue: 0,0:50:37.60,0:50:39.76,Default,,0,0,0,,这是和operate类似的一个东西
Dialogue: 0,0:50:40.42,0:50:41.68,Default,,0,0,0,,我们再看看这个代码
Dialogue: 0,0:50:41.68,0:50:42.93,Default,,0,0,0,,它和operate很相似
Dialogue: 0,0:50:45.79,0:50:52.49,Default,,0,0,0,,为了将运算符运用在两个参数arg1和arg2上
Dialogue: 0,0:50:55.04,0:50:56.65,Default,,0,0,0,,首要任务是
Dialogue: 0,0:50:56.83,0:51:00.73,Default,,0,0,0,,检查这两个参数的类型是否相同
Dialogue: 0,0:51:01.90,0:51:02.96,Default,,0,0,0,,所以我们要问
Dialogue: 0,0:51:02.99,0:51:07.77,Default,,0,0,0,,第一个参数的类型和第二个的类型一样吗？
Dialogue: 0,0:51:10.35,0:51:13.36,Default,,0,0,0,,如果不一样
Dialogue: 0,0:51:13.58,0:51:15.63,Default,,0,0,0,,我们就停止运行 然后抛出错误
Dialogue: 0,0:51:15.67,0:51:16.67,Default,,0,0,0,,我们不知道怎么对它们进行运算
Dialogue: 0,0:51:19.14,0:51:20.49,Default,,0,0,0,,如果它们的类型确实是相同的
Dialogue: 0,0:51:20.51,0:51:22.08,Default,,0,0,0,,那就和之前一样了
Dialogue: 0,0:51:22.08,0:51:26.46,Default,,0,0,0,,我们会查询在参数的类型对应的
Dialogue: 0,0:51:26.76,0:51:29.61,Default,,0,0,0,,参数1和参数2是同样的类型 知道一个就可以
Dialogue: 0,0:51:30.42,0:51:32.59,Default,,0,0,0,,我们到表格里去查找对应的过程
Dialogue: 0,0:51:33.64,0:51:35.87,Default,,0,0,0,,如果找到这样一个过程
Dialogue: 0,0:51:37.53,0:51:41.74,Default,,0,0,0,,我们就将其应用在参数1和参数2的内容上
Dialogue: 0,0:51:43.03,0:51:44.76,Default,,0,0,0,,如果是其它情况 就报错
Dialogue: 0,0:51:44.76,0:51:45.72,Default,,0,0,0,,“未定义运算符”
Dialogue: 0,0:51:46.89,0:51:48.16,Default,,0,0,0,,这就是operate-2过程
Dialogue: 0,0:51:51.72,0:51:54.03,Default,,0,0,0,,这就是我们要做的全部事情
Dialogue: 0,0:51:55.16,0:51:57.45,Default,,0,0,0,,我们刚刚才写好了一个复数运算包
Dialogue: 0,0:51:57.64,0:52:01.00,Default,,0,0,0,,那么怎么把它放进这个通用系统里面呢？
Dialogue: 0,0:52:02.14,0:52:02.91,Default,,0,0,0,,方法几乎是一样的
Dialogue: 0,0:52:06.41,0:52:08.59,Default,,0,0,0,,我们构造一个叫做make-complex的过程
Dialogue: 0,0:52:09.95,0:52:12.81,Default,,0,0,0,,它把George和Martha给我们的东西
Dialogue: 0,0:52:13.64,0:52:15.00,Default,,0,0,0,,贴上complex的类型标志
Dialogue: 0,0:52:18.17,0:52:23.87,Default,,0,0,0,,然后我们说 要把复数相加 这个+complex过程
Dialogue: 0,0:52:25.84,0:52:28.78,Default,,0,0,0,,用我们的内部过程 +c
Dialogue: 0,0:52:30.78,0:52:32.24,Default,,0,0,0,,把结果加上类型
Dialogue: 0,0:52:32.24,0:52:33.42,Default,,0,0,0,,让它变成复数类型
Dialogue: 0,0:52:37.68,0:52:42.52,Default,,0,0,0,,那么我们的包里原来有+c和-c这两个过程
Dialogue: 0,0:52:42.68,0:52:44.75,Default,,0,0,0,,用来和George和Martha通信
Dialogue: 0,0:52:45.25,0:52:47.39,Default,,0,0,0,,然后为了与外部通信
Dialogue: 0,0:52:47.40,0:52:53.04,Default,,0,0,0,,我们还有+complex和-complex
Dialogue: 0,0:52:55.92,0:52:56.53,Default,,0,0,0,,等等
Dialogue: 0,0:52:56.53,0:52:59.98,Default,,0,0,0,,它们唯一的不同就在于：后者的返回的是带类型的值
Dialogue: 0,0:53:01.12,0:53:02.41,Default,,0,0,0,,它们可以在这里被查询
Dialogue: 0,0:53:02.85,0:53:05.02,Default,,0,0,0,,而这些是内部过程
Dialogue: 0,0:53:09.25,0:53:10.68,Default,,0,0,0,,我们再来看那个幻灯片
Dialogue: 0,0:53:10.68,0:53:13.04,Default,,0,0,0,,我们还有一件事要做
Dialogue: 0,0:53:13.74,0:53:15.61,Default,,0,0,0,,在定义了+complex之后
Dialogue: 0,0:53:15.68,0:53:20.52,Default,,0,0,0,,我们在complex类型和add符号对应的格子中
Dialogue: 0,0:53:21.31,0:53:22.75,Default,,0,0,0,,填上过程+complex
Dialogue: 0,0:53:23.20,0:53:26.75,Default,,0,0,0,,对于-complex也类似
Dialogue: 0,0:53:27.13,0:53:29.13,Default,,0,0,0,,*complex和/complex亦如此
Dialogue: 0,0:53:31.70,0:53:33.48,Default,,0,0,0,,那我们怎么安装寻常算术呢？
Dialogue: 0,0:53:35.25,0:53:36.12,Default,,0,0,0,,方法还是一样的
Dialogue: 0,0:53:38.16,0:53:41.36,Default,,0,0,0,,我们会写一个叫做make-number的过程
Dialogue: 0,0:53:44.34,0:53:48.11,Default,,0,0,0,,make-number接收一个数 然后给它加上类型
Dialogue: 0,0:53:48.14,0:53:49.29,Default,,0,0,0,,也就是符号number
Dialogue: 0,0:53:50.26,0:53:52.11,Default,,0,0,0,,我们构造一个过程叫做+number
Dialogue: 0,0:53:52.92,0:53:58.75,Default,,0,0,0,,用Lisp自带的加法把两个数加起来
Dialogue: 0,0:53:58.92,0:54:00.78,Default,,0,0,0,,因为我们现在讨论的是寻常算术
Dialogue: 0,0:54:01.31,0:54:03.10,Default,,0,0,0,,给它加上类型 让它变成number类型
Dialogue: 0,0:54:04.51,0:54:08.09,Default,,0,0,0,,然后我们把+number过程放到
Dialogue: 0,0:54:08.59,0:54:11.00,Default,,0,0,0,,表格里number和add对应的的格子中
Dialogue: 0,0:54:12.30,0:54:16.16,Default,,0,0,0,,再用相同的方法把减法 乘法 除法也放进去
Dialogue: 0,0:54:22.67,0:54:26.06,Default,,0,0,0,,我们举一个例子 就看得清楚一点
Dialogue: 0,0:54:26.06,0:54:28.75,Default,,0,0,0,,假设 比如说
Dialogue: 0,0:54:32.28,0:54:34.15,Default,,0,0,0,,我要执行这个运算
Dialogue: 0,0:54:34.15,0:54:38.22,Default,,0,0,0,,好 现在我要执行一个运算
Dialogue: 0,0:54:38.22,0:54:40.46,Default,,0,0,0,,比如说我把两个复数乘起来
Dialogue: 0,0:54:40.93,0:54:48.64,Default,,0,0,0,,把3+4i和2+6i乘起来
Dialogue: 0,0:54:50.17,0:54:52.60,Default,,0,0,0,,这就是我调用mul过程要传入的参数
Dialogue: 0,0:54:52.84,0:54:55.76,Default,,0,0,0,,这里就代表通用运算符mul
Dialogue: 0,0:54:57.17,0:54:57.98,Default,,0,0,0,,那么它怎么工作呢
Dialogue: 0,0:54:58.28,0:55:04.60,Default,,0,0,0,,我们讲3+4i 在整个系统里
Dialogue: 0,0:55:04.83,0:55:06.11,Default,,0,0,0,,处于这样的一个位置
Dialogue: 0,0:55:06.25,0:55:07.52,Default,,0,0,0,,假设它是George那种方法表示的
Dialogue: 0,0:55:08.28,0:55:14.97,Default,,0,0,0,,所以它的内部有一个3和一个4
Dialogue: 0,0:55:18.49,0:55:20.97,Default,,0,0,0,,这上面还贴着George的类型标志
Dialogue: 0,0:55:24.33,0:55:28.32,Default,,0,0,0,,是他构造的rectangular类型
Dialogue: 0,0:55:29.51,0:55:30.57,Default,,0,0,0,,又附加在那上面的
Dialogue: 0,0:55:31.23,0:55:35.79,Default,,0,0,0,,从更上一层的视角来看这一段数据
Dialogue: 0,0:55:36.19,0:55:36.78,Default,,0,0,0,,它又是一个
Dialogue: 0,0:55:37.93,0:55:39.96,Default,,0,0,0,,这整个又是一个带类型的数据
Dialogue: 0,0:55:40.60,0:55:41.80,Default,,0,0,0,,它的类型是complex
Dialogue: 0,0:55:44.82,0:55:47.31,Default,,0,0,0,,那么这就是这个对象
Dialogue: 0,0:55:48.64,0:55:50.24,Default,,0,0,0,,在最高层视角中的样子
Dialogue: 0,0:55:50.68,0:55:53.56,Default,,0,0,0,,那些通用运算符看到的对象 就是这样的
Dialogue: 0,0:55:55.56,0:55:58.72,Default,,0,0,0,,现在 mul过程会过来问
Dialogue: 0,0:55:58.84,0:56:00.40,Default,,0,0,0,,它的类型是什么？
Dialogue: 0,0:56:00.48,0:56:01.48,Default,,0,0,0,,它的类型是complex
Dialogue: 0,0:56:04.27,0:56:06.46,Default,,0,0,0,,然后运行到operate-2 然后说
Dialogue: 0,0:56:06.46,0:56:09.72,Default,,0,0,0,,啊 我想要把表格里的过程
Dialogue: 0,0:56:09.72,0:56:13.04,Default,,0,0,0,,也就是*complex这个过程
Dialogue: 0,0:56:15.08,0:56:17.76,Default,,0,0,0,,应用到 将其类型剥离之后的结果上去
Dialogue: 0,0:56:17.95,0:56:19.28,Default,,0,0,0,,所以它会把类型剥下来
Dialogue: 0,0:56:19.93,0:56:24.24,Default,,0,0,0,,把剩下的东西传递给复数的世界
Dialogue: 0,0:56:26.70,0:56:28.73,Default,,0,0,0,,复数的世界看了看它有的运算操作 然后说
Dialogue: 0,0:56:28.76,0:56:30.56,Default,,0,0,0,,“我得调用*c这个过程”
Dialogue: 0,0:56:31.28,0:56:32.14,Default,,0,0,0,,然后*c过程说
Dialogue: 0,0:56:32.22,0:56:37.20,Default,,0,0,0,,我想知道这个东西的模值是多少
Dialogue: 0,0:56:39.42,0:56:40.16,Default,,0,0,0,,然后它们会说 啊
Dialogue: 0,0:56:40.16,0:56:41.71,Default,,0,0,0,,它是直角坐标表示的 是George的东西
Dialogue: 0,0:56:41.87,0:56:44.41,Default,,0,0,0,,所以它们又剥掉了一个类型
Dialogue: 0,0:56:46.91,0:56:49.80,Default,,0,0,0,,然后把内容交给George 让他提取出它的模值
Dialogue: 0,0:56:52.16,0:56:53.13,Default,,0,0,0,,那么我们看到
Dialogue: 0,0:56:53.44,0:56:56.99,Default,,0,0,0,,这其中有一条由类型构成的链条
Dialogue: 0,0:56:59.32,0:57:01.50,Default,,0,0,0,,这个链条的长度就是你要
Dialogue: 0,0:57:01.53,0:57:03.13,Default,,0,0,0,,在这个表格里上升的层数
Dialogue: 0,0:57:05.09,0:57:05.96,Default,,0,0,0,,类型的作用则是
Dialogue: 0,0:57:05.96,0:57:10.84,Default,,0,0,0,,每当我们在表格中遇到一道垂直屏障时
Dialogue: 0,0:57:11.05,0:57:14.06,Default,,0,0,0,,你不知道该如何抉择时
Dialogue: 0,0:57:14.41,0:57:15.85,Default,,0,0,0,,类型就会给你指路
Dialogue: 0,0:57:17.44,0:57:18.83,Default,,0,0,0,,然后最底层的过程
Dialogue: 0,0:57:18.97,0:57:20.67,Default,,0,0,0,,它们构造数据结构 对数据进行筛选之后
Dialogue: 0,0:57:21.12,0:57:22.81,Default,,0,0,0,,再把类型贴回去
Dialogue: 0,0:57:25.35,0:57:30.75,Default,,0,0,0,,这就是整个系统的总体结构
Dialogue: 0,0:57:33.41,0:57:33.77,Default,,0,0,0,,好
Dialogue: 0,0:57:34.82,0:57:35.68,Default,,0,0,0,,明白了这个之后
Dialogue: 0,0:57:37.56,0:57:39.44,Default,,0,0,0,,我们再让这个系统变得更加复杂
Dialogue: 0,0:57:41.89,0:57:46.54,Default,,0,0,0,,我们这次不光要在系统里添加新的数域
Dialogue: 0,0:57:46.60,0:57:51.15,Default,,0,0,0,,我们也来讨论一下怎么把多项式也加进去
Dialogue: 0,0:57:51.51,0:57:52.97,Default,,0,0,0,,让它能做多项式算术
Dialogue: 0,0:57:53.36,0:58:03.71,Default,,0,0,0,,比如我们可以计算x^15+2x^7+5
Dialogue: 0,0:58:04.48,0:58:05.84,Default,,0,0,0,,像这样的多项式
Dialogue: 0,0:58:06.38,0:58:07.93,Default,,0,0,0,,如果有两个这样的东西
Dialogue: 0,0:58:07.93,0:58:09.48,Default,,0,0,0,,我们可以把它们相加或者相乘
Dialogue: 0,0:58:10.53,0:58:11.79,Default,,0,0,0,,先不管相除的问题
Dialogue: 0,0:58:12.14,0:58:14.67,Default,,0,0,0,,只考虑相加相乘和相减
Dialogue: 0,0:58:15.55,0:58:17.16,Default,,0,0,0,,我们需要做什么
Dialogue: 0,0:58:18.52,0:58:20.76,Default,,0,0,0,,我们先来想想怎么表示一个多项式
Dialogue: 0,0:58:21.83,0:58:23.55,Default,,0,0,0,,它也是一种带类型的数据
Dialogue: 0,0:58:24.73,0:58:27.55,Default,,0,0,0,,这个系统里的一个多项式
Dialogue: 0,0:58:28.54,0:58:31.68,Default,,0,0,0,,应该是带有polynomial类型的对象
Dialogue: 0,0:58:32.00,0:58:34.55,Default,,0,0,0,,接下来它可能要问这个多项式的变量是哪个
Dialogue: 0,0:58:34.55,0:58:37.69,Default,,0,0,0,,比如这是一个以x为变量的多项式
Dialogue: 0,0:58:38.96,0:58:41.39,Default,,0,0,0,,然后 多项式内还有各项的信息
Dialogue: 0,0:58:42.25,0:58:44.16,Default,,0,0,0,,有很多种方法来实现
Dialogue: 0,0:58:44.25,0:58:47.63,Default,,0,0,0,,我们采用的方法是构造一个“项表”
Dialogue: 0,0:58:51.52,0:58:52.24,Default,,0,0,0,,所谓的“项表”
Dialogue: 0,0:58:53.70,0:58:55.61,Default,,0,0,0,,本例中 我们用的是类似这样的东西
Dialogue: 0,0:58:56.36,0:58:59.68,Default,,0,0,0,,我们把它写成一系列 按次数排列的序对
Dialogue: 0,0:58:59.69,0:59:05.80,Default,,0,0,0,,那么这个项表就能表示这个多项式了
Dialogue: 0,0:59:09.42,0:59:10.68,Default,,0,0,0,,它的意义是
Dialogue: 0,0:59:11.48,0:59:19.71,Default,,0,0,0,,这个多项式第一项的次数是15 系数是1
Dialogue: 0,0:59:23.82,0:59:27.50,Default,,0,0,0,,然后下一项的次数是7 系数是2
Dialogue: 0,0:59:27.53,0:59:30.49,Default,,0,0,0,,再下一项是一个常数 它次数是0 系数是5
Dialogue: 0,0:59:31.45,0:59:34.16,Default,,0,0,0,,实际上有很多很多种方法
Dialogue: 0,0:59:34.25,0:59:35.96,Default,,0,0,0,,也有很多很多的取舍
Dialogue: 0,0:59:36.01,0:59:39.10,Default,,0,0,0,,在你认真思考如何实现代数操作程序包时
Dialogue: 0,0:59:39.44,0:59:41.73,Default,,0,0,0,,你该如何表示这些东西
Dialogue: 0,0:59:42.01,0:59:43.68,Default,,0,0,0,,但是我们这种是比较标准的一种
Dialogue: 0,0:59:44.18,0:59:45.55,Default,,0,0,0,,它适用于很多情况
Dialogue: 0,0:59:47.77,0:59:50.99,Default,,0,0,0,,好 那么我们怎么实现我们的多项式算术呢
Dialogue: 0,0:59:53.47,0:59:54.96,Default,,0,0,0,,现在开始着手做这个事情
Dialogue: 0,0:59:57.95,1:00:00.28,Default,,0,0,0,,构造一个多项式 首先要
Dialogue: 0,1:00:00.76,1:00:04.12,Default,,0,0,0,,首先我们得找一个办法来构造多项式
Dialogue: 0,1:00:05.69,1:00:10.28,Default,,0,0,0,,我们可以用一个变量 比如x和一个项表来构造它们
Dialogue: 0,1:00:11.24,1:00:14.09,Default,,0,0,0,,我们要用某种方法把它们包装起来
Dialogue: 0,1:00:14.30,1:00:19.40,Default,,0,0,0,,我们可以用cons把变量和项表组合起来
Dialogue: 0,1:00:19.82,1:00:21.74,Default,,0,0,0,,然后把这个序对加上polynomial的类型标志
Dialogue: 0,1:00:26.27,1:00:27.77,Default,,0,0,0,,那我们怎么处理多项式相加呢？
Dialogue: 0,1:00:29.28,1:00:31.85,Default,,0,0,0,,要相加两个多项式 p1和p2
Dialogue: 0,1:00:32.68,1:00:35.18,Default,,0,0,0,,为了简化问题 假设我们
Dialogue: 0,1:00:35.37,1:00:37.15,Default,,0,0,0,,我们只相加变量相同的两个式子
Dialogue: 0,1:00:37.38,1:00:39.28,Default,,0,0,0,,那么如果它们的变量相同
Dialogue: 0,1:00:39.69,1:00:42.57,Default,,0,0,0,,是否相同交由我们编写的选择函数判断
Dialogue: 0,1:00:42.96,1:00:44.38,Default,,0,0,0,,我们不必在意它的细节
Dialogue: 0,1:00:45.15,1:00:47.04,Default,,0,0,0,,如果两个多项式的变量相同
Dialogue: 0,1:00:48.03,1:00:48.81,Default,,0,0,0,,我们就继续运算
Dialogue: 0,1:00:48.81,1:00:51.26,Default,,0,0,0,,如果它们的变量不相同 我们返回一个错误
Dialogue: 0,1:00:52.35,1:00:54.01,Default,,0,0,0,,“两个多项式的变量不相同”
Dialogue: 0,1:00:55.48,1:00:57.37,Default,,0,0,0,,如果它们的变量确实是相同
Dialogue: 0,1:00:57.60,1:00:59.18,Default,,0,0,0,,我们就要构造一个新的多项式
Dialogue: 0,1:00:59.80,1:01:01.85,Default,,0,0,0,,它的变量即是原式的变量
Dialogue: 0,1:01:03.15,1:01:06.56,Default,,0,0,0,,它的项表则由过程+terms产生
Dialogue: 0,1:01:07.48,1:01:09.80,Default,,0,0,0,,+terms过程会把两个项表加起来
Dialogue: 0,1:01:10.17,1:01:12.01,Default,,0,0,0,,所以我们要把两个多项式的项表合起来
Dialogue: 0,1:01:13.50,1:01:14.51,Default,,0,0,0,,该过程即可返回一个项表
Dialogue: 0,1:01:15.00,1:01:20.01,Default,,0,0,0,,我们将变量和得到的项表构造成新的多项式
Dialogue: 0,1:01:20.68,1:01:21.79,Default,,0,0,0,,这就是+poly过程
Dialogue: 0,1:01:22.55,1:01:27.00,Default,,0,0,0,,然后我们要把这个过程放进表格中polynomial那一栏
Dialogue: 0,1:01:28.24,1:01:30.14,Default,,0,0,0,,用+poly实现add操作
Dialogue: 0,1:01:30.52,1:01:31.75,Default,,0,0,0,,当然实际上没做多少事情
Dialogue: 0,1:01:31.75,1:01:35.31,Default,,0,0,0,,我们只是把所有的工作压到+terms的头上
Dialogue: 0,1:01:35.79,1:01:37.02,Default,,0,0,0,,它会负责把项表相加起来
Dialogue: 0,1:01:37.74,1:01:39.16,Default,,0,0,0,,我们看看这个过程
Dialogue: 0,1:01:39.18,1:01:48.03,Default,,0,0,0,,这是+terms过程的大概结构
Dialogue: 0,1:01:48.90,1:01:51.74,Default,,0,0,0,,L1和L2是两个项表
Dialogue: 0,1:01:52.00,1:01:54.81,Default,,0,0,0,,所谓“项表”即是按每项次数排序的序对
Dialogue: 0,1:01:55.70,1:01:56.95,Default,,0,0,0,,这里有一个大的分情况分析
Dialogue: 0,1:01:59.86,1:02:04.14,Default,,0,0,0,,首先 我们要检查项表是否为空
Dialogue: 0,1:02:05.39,1:02:07.55,Default,,0,0,0,,我们对项表做递归下降处理
Dialogue: 0,1:02:08.16,1:02:11.74,Default,,0,0,0,,最终下降到 L1或L2为空
Dialogue: 0,1:02:12.27,1:02:14.35,Default,,0,0,0,,只要其中有一个为空
Dialogue: 0,1:02:14.52,1:02:15.85,Default,,0,0,0,,我们的答案就是剩下的另一个
Dialogue: 0,1:02:15.85,1:02:19.55,Default,,0,0,0,,就是说如果L1是空表 我们就返回L2
Dialogue: 0,1:02:19.63,1:02:21.71,Default,,0,0,0,,L2是空表的话就返回L1
Dialogue: 0,1:02:23.26,1:02:25.76,Default,,0,0,0,,除此之外还有三种情况
Dialogue: 0,1:02:27.22,1:02:27.98,Default,,0,0,0,,我们要做的是
Dialogue: 0,1:02:29.08,1:02:31.05,Default,,0,0,0,,取表中的第一项
Dialogue: 0,1:02:33.50,1:02:36.04,Default,,0,0,0,,记为t1和t2
Dialogue: 0,1:02:37.66,1:02:39.05,Default,,0,0,0,,我们来分析一下这三种情况
Dialogue: 0,1:02:39.60,1:02:45.68,Default,,0,0,0,,分别是t1的次数大于t2的
Dialogue: 0,1:02:47.23,1:02:50.59,Default,,0,0,0,,小于t2的 或者等于t2的
Dialogue: 0,1:02:53.28,1:02:54.91,Default,,0,0,0,,这就是我们要判断的三种情况
Dialogue: 0,1:02:54.91,1:02:55.84,Default,,0,0,0,,先看看这一种
Dialogue: 0,1:02:58.64,1:03:01.31,Default,,0,0,0,,如果t1的次数比t2的次数要高
Dialogue: 0,1:03:03.40,1:03:04.70,Default,,0,0,0,,就意味着
Dialogue: 0,1:03:06.06,1:03:09.96,Default,,0,0,0,,答案的第一项的次数就是t1的次数
Dialogue: 0,1:03:11.56,1:03:13.80,Default,,0,0,0,,因为高次项不会和任何低次项相加
Dialogue: 0,1:03:14.17,1:03:16.19,Default,,0,0,0,,那么我们只需要把低次的项加起来
Dialogue: 0,1:03:16.76,1:03:18.25,Default,,0,0,0,,我们递归地把
Dialogue: 0,1:03:19.71,1:03:25.07,Default,,0,0,0,,把L1和L2两个项表里剩下的项相加
Dialogue: 0,1:03:27.13,1:03:29.32,Default,,0,0,0,,作为我们的答案中低次项
Dialogue: 0,1:03:30.12,1:03:32.48,Default,,0,0,0,,然后我们把它们和最高次的项连接起来
Dialogue: 0,1:03:33.18,1:03:35.45,Default,,0,0,0,,这里 我用了一对还未定义的过程
Dialogue: 0,1:03:35.47,1:03:37.55,Default,,0,0,0,,比如adjoin-term、rest-terms
Dialogue: 0,1:03:38.48,1:03:40.17,Default,,0,0,0,,还有获取次数的选择函数
Dialogue: 0,1:03:41.15,1:03:42.78,Default,,0,0,0,,但是你可以想象它们是什么样子的
Dialogue: 0,1:03:44.44,1:03:48.76,Default,,0,0,0,,那么如果第一个项表的次数比第二个要高
Dialogue: 0,1:03:48.78,1:03:51.08,Default,,0,0,0,,我们就递归地把所有的低次的项相加
Dialogue: 0,1:03:51.28,1:03:53.42,Default,,0,0,0,,再和最高次项连接起来
Dialogue: 0,1:03:55.54,1:03:56.75,Default,,0,0,0,,其它情况也是一样的
Dialogue: 0,1:03:56.89,1:04:00.28,Default,,0,0,0,,如果第一个多项式次数比较低
Dialogue: 0,1:04:00.54,1:04:08.36,Default,,0,0,0,,我们就把整个第一个多项式和第二个多项式低次的项相加
Dialogue: 0,1:04:08.62,1:04:12.65,Default,,0,0,0,,然后把结果再和最高次项连起来
Dialogue: 0,1:04:14.57,1:04:15.96,Default,,0,0,0,,到现在也没多少复杂的事情
Dialogue: 0,1:04:15.96,1:04:19.40,Default,,0,0,0,,把问题变成 让低次数的项相加
Dialogue: 0,1:04:19.47,1:04:21.96,Default,,0,0,0,,还有最后一种情况是 两个多项式的次数一样
Dialogue: 0,1:04:22.57,1:04:25.18,Default,,0,0,0,,你必须要把它们的系数加起来 因为它们是同类项
Dialogue: 0,1:04:27.24,1:04:30.99,Default,,0,0,0,,我们的应对方法仍然是 递归地把低次项相加
Dialogue: 0,1:04:31.00,1:04:32.83,Default,,0,0,0,,但现在我们需要合并一些项了
Dialogue: 0,1:04:33.46,1:04:36.35,Default,,0,0,0,,我们构造一个项
Dialogue: 0,1:04:37.31,1:04:39.93,Default,,0,0,0,,其次数为我们正在处理的那一项的次数
Dialogue: 0,1:04:40.82,1:04:42.72,Default,,0,0,0,,因为现在t1和t2的次数是相同的
Dialogue: 0,1:04:44.32,1:04:44.99,Default,,0,0,0,,确定好次数了
Dialogue: 0,1:04:45.09,1:04:52.33,Default,,0,0,0,,而它的系数是t1和t2系数之和
Dialogue: 0,1:04:55.79,1:04:59.64,Default,,0,0,0,,这是一个庞大的递归过程
Dialogue: 0,1:04:59.68,1:05:03.61,Default,,0,0,0,,但其中只有一个符号值得玩味
Dialogue: 0,1:05:04.25,1:05:05.69,Default,,0,0,0,,它蕴含了重要的思想
Dialogue: 0,1:05:05.90,1:05:08.50,Default,,0,0,0,,那就是这个ADD过程
Dialogue: 0,1:05:12.39,1:05:14.80,Default,,0,0,0,,说它有趣是因为
Dialogue: 0,1:05:15.42,1:05:17.37,Default,,0,0,0,,有一件好事发生
Dialogue: 0,1:05:18.22,1:05:21.37,Default,,0,0,0,,我们没有把多项式加法
Dialogue: 0,1:05:22.56,1:05:26.46,Default,,0,0,0,,归约为某种加法 而是归约为通用运算符ADD
Dialogue: 0,1:05:28.82,1:05:32.28,Default,,0,0,0,,换句话说 用这种方法实现它之后
Dialogue: 0,1:05:32.89,1:05:34.68,Default,,0,0,0,,我们的系统就不光有
Dialogue: 0,1:05:35.92,1:05:41.66,Default,,0,0,0,,有理数、复数还有寻常算术
Dialogue: 0,1:05:41.85,1:05:43.82,Default,,0,0,0,,我们同时也让它支持多项式运算了
Dialogue: 0,1:05:48.52,1:05:51.13,Default,,0,0,0,,而多项式的系数可以是
Dialogue: 0,1:05:51.24,1:05:52.86,Default,,0,0,0,,这个系统能够相加的任何东西
Dialogue: 0,1:05:53.59,1:05:56.73,Default,,0,0,0,,也就是说多项式的系数
Dialogue: 0,1:05:57.20,1:06:01.20,Default,,0,0,0,,有理数或者复数
Dialogue: 0,1:06:02.76,1:06:06.99,Default,,0,0,0,,复数同时可支持直角坐标形式和极坐标形式
Dialogue: 0,1:06:09.12,1:06:11.39,Default,,0,0,0,,系数还可以是寻常的数字
Dialogue: 0,1:06:18.97,1:06:21.21,Default,,0,0,0,,我想说的是
Dialogue: 0,1:06:22.06,1:06:24.35,Default,,0,0,0,,我们的系统现在可以自动地
Dialogue: 0,1:06:26.60,1:06:31.50,Default,,0,0,0,,处理像这样的式子
Dialogue: 0,1:06:31.53,1:06:39.69,Default,,0,0,0,,比如2/3x^2+5/17x+11/4这样的式子
Dialogue: 0,1:06:40.94,1:06:43.48,Default,,0,0,0,,也可以自动处理像是
Dialogue: 0,1:06:43.82,1:06:52.57,Default,,0,0,0,,(3+2i)x^5+(4+7i)这样的式子
Dialogue: 0,1:06:53.88,1:06:56.21,Default,,0,0,0,,系统可以自动处理这些运算
Dialogue: 0,1:06:56.21,1:06:57.07,Default,,0,0,0,,为什么呢？
Dialogue: 0,1:06:57.82,1:07:01.50,Default,,0,0,0,,仅仅是因为 或者说深层次的原因是
Dialogue: 0,1:07:02.17,1:07:05.93,Default,,0,0,0,,我们把多项式相加归约成了把它们的系数相加
Dialogue: 0,1:07:06.79,1:07:10.22,Default,,0,0,0,,而系数的相加是由通用运算符ADD完成的
Dialogue: 0,1:07:11.08,1:07:12.94,Default,,0,0,0,,它说：“我不管你的数据类型是什么”
Dialogue: 0,1:07:12.96,1:07:14.08,Default,,0,0,0,,“只要我能够处理就行”
Dialogue: 0,1:07:15.23,1:07:18.86,Default,,0,0,0,,于是我们就“免费”获得了处理这些东西的功能
Dialogue: 0,1:07:20.65,1:07:22.04,Default,,0,0,0,,更神奇的是
Dialogue: 0,1:07:24.51,1:07:26.52,Default,,0,0,0,,我们曾把
Dialogue: 0,1:07:27.20,1:07:30.52,Default,,0,0,0,,我们放入表格中 用于处理多项式加法
Dialogue: 0,1:07:31.28,1:07:32.52,Default,,0,0,0,,是用的+poly过程
Dialogue: 0,1:07:34.66,1:07:38.65,Default,,0,0,0,,这就意味着ADD过程也可以处理多项式了
Dialogue: 0,1:07:39.42,1:07:42.11,Default,,0,0,0,,我举个例子
Dialogue: 0,1:07:43.18,1:07:46.19,Default,,0,0,0,,这是一个多项式
Dialogue: 0,1:07:50.56,1:07:52.41,Default,,0,0,0,,我正在写的这个东西
Dialogue: 0,1:07:54.12,1:07:58.46,Default,,0,0,0,,它是一个以y作为变量的多项式
Dialogue: 0,1:08:01.07,1:08:04.69,Default,,0,0,0,,每项的系数是以x作为变量的多项式
Dialogue: 0,1:08:08.61,1:08:11.12,Default,,0,0,0,,你将看到
Dialogue: 0,1:08:11.76,1:08:14.06,Default,,0,0,0,,由于 “ADD过程能够处理多项式”
Dialogue: 0,1:08:14.41,1:08:17.90,Default,,0,0,0,,我们可以说 我们的系统现在不光能运算有理数
Dialogue: 0,1:08:18.27,1:08:20.33,Default,,0,0,0,,复数和一般数字
Dialogue: 0,1:08:20.35,1:08:21.77,Default,,0,0,0,,我们还可以处理多项式
Dialogue: 0,1:08:22.09,1:08:25.39,Default,,0,0,0,,多项式的系数可以是有理数、复数、一般数字
Dialogue: 0,1:08:25.50,1:08:27.52,Default,,0,0,0,,甚至是多项式
Dialogue: 0,1:08:29.15,1:08:30.96,Default,,0,0,0,,作为系数的多项式 其系数还可以是有理数
Dialogue: 0,1:08:31.69,1:08:36.76,Default,,0,0,0,,复数（直角或极坐标形式）或一般数字
Dialogue: 0,1:08:36.94,1:08:41.13,Default,,0,0,0,,甚至还可以是系数为有理数的多项式
Dialogue: 0,1:08:41.80,1:08:43.32,Default,,0,0,0,,系数为复数、一般数字的多项式
Dialogue: 0,1:08:43.67,1:08:45.21,Default,,0,0,0,,以此类推
Dialogue: 0,1:08:45.95,1:08:47.55,Default,,0,0,0,,我们构造出了一座无限延伸的
Dialogue: 0,1:08:48.49,1:08:52.88,Default,,0,0,0,,或者说是递归的类型高塔
Dialogue: 0,1:08:53.88,1:08:57.12,Default,,0,0,0,,这一切都来源于那个小小的符号：A-D-D
Dialogue: 0,1:08:57.61,1:09:00.49,Default,,0,0,0,,来源于在多项式程序里 用“ADD”来代替“+”
Dialogue: 0,1:09:02.27,1:09:03.77,Default,,0,0,0,,换一种方式来理解它就是
Dialogue: 0,1:09:03.95,1:09:07.74,Default,,0,0,0,,多项式也是一种类型的构造函数
Dialogue: 0,1:09:08.74,1:09:11.20,Default,,0,0,0,,也就是说你传递给它一个类型 比如整型
Dialogue: 0,1:09:11.48,1:09:15.74,Default,,0,0,0,,然后它就返回一个以整数作为系数的多项式
Dialogue: 0,1:09:16.27,1:09:17.72,Default,,0,0,0,,过程中很重要的一点是
Dialogue: 0,1:09:18.65,1:09:20.73,Default,,0,0,0,,就是多项式上的运算
Dialogue: 0,1:09:21.28,1:09:23.37,Default,,0,0,0,,归约成了关于系数的运算
Dialogue: 0,1:09:23.39,1:09:24.96,Default,,0,0,0,,很多地方都与这里类似
Dialogue: 0,1:09:25.84,1:09:27.92,Default,,0,0,0,,比如 我们再回头看看有理数
Dialogue: 0,1:09:28.87,1:09:32.65,Default,,0,0,0,,我们之前把有理数看做 一个整数在另一个上面
Dialogue: 0,1:09:32.67,1:09:35.66,Default,,0,0,0,,但这并不是关于有理式的一般性记号
Dialogue: 0,1:09:36.24,1:09:42.03,Default,,0,0,0,,比如我们也可以把3x+7放在上面 x^2+1放在下面
Dialogue: 0,1:09:43.07,1:09:48.86,Default,,0,0,0,,这是一个分子分母都是多项式的广义有理式
Dialogue: 0,1:09:50.31,1:09:52.41,Default,,0,0,0,,有理式相加 和有理数相加一样
Dialogue: 0,1:09:52.44,1:09:55.40,Default,,0,0,0,,分子乘分母 加 分母乘分子 结果作为分子
Dialogue: 0,1:09:55.72,1:09:56.99,Default,,0,0,0,,两个分母相乘 结果作为分母
Dialogue: 0,1:09:57.29,1:09:59.37,Default,,0,0,0,,怎么把它安装到我们的系统中呢？
Dialogue: 0,1:09:59.39,1:10:02.97,Default,,0,0,0,,这是我们原来的有理数算术程序包
Dialogue: 0,1:10:04.25,1:10:08.24,Default,,0,0,0,,为了让这个系统能够
Dialogue: 0,1:10:08.28,1:10:11.58,Default,,0,0,0,,支持广义有理式的运算
Dialogue: 0,1:10:11.85,1:10:16.44,Default,,0,0,0,,我们把特定的加法和乘法过程 都改成通用运算符
Dialogue: 0,1:10:16.48,1:10:19.18,Default,,0,0,0,,所以如果我们把原来那个过程变成这个过程
Dialogue: 0,1:10:19.71,1:10:22.04,Default,,0,0,0,,把+和*换成ADD和MUL
Dialogue: 0,1:10:22.88,1:10:24.48,Default,,0,0,0,,这些是唯一的改动
Dialogue: 0,1:10:24.84,1:10:26.03,Default,,0,0,0,,然后霎时间
Dialogue: 0,1:10:27.52,1:10:31.40,Default,,0,0,0,,我们的整个系统 就知道怎么运算这样的东西了
Dialogue: 0,1:10:33.72,1:10:38.27,Default,,0,0,0,,比如说 这里的这个有理式
Dialogue: 0,1:10:39.18,1:10:44.86,Default,,0,0,0,,它的分子是一个系数是有理数的、关于x的多项式
Dialogue: 0,1:10:47.02,1:10:49.56,Default,,0,0,0,,而这个有理式
Dialogue: 0,1:10:51.10,1:10:54.43,Default,,0,0,0,,它的分子是关于x的多项式
Dialogue: 0,1:10:55.15,1:10:58.19,Default,,0,0,0,,多项式的系数又是有理式
Dialogue: 0,1:10:59.77,1:11:01.53,Default,,0,0,0,,有理式又由复数组成
Dialogue: 0,1:11:03.39,1:11:04.85,Default,,0,0,0,,或者别的像这样的东西
Dialogue: 0,1:11:04.85,1:11:08.68,Default,,0,0,0,,看 只要能够归约成针对各部分的运算
Dialogue: 0,1:11:08.89,1:11:10.00,Default,,0,0,0,,另一个例子是
Dialogue: 0,1:11:10.28,1:11:11.42,Default,,0,0,0,,2*2的矩阵
Dialogue: 0,1:11:12.31,1:11:15.44,Default,,0,0,0,,假如有这样一个矩阵形式的东西
Dialogue: 0,1:11:16.43,1:11:18.33,Default,,0,0,0,,不管它里面是什么
Dialogue: 0,1:11:18.72,1:11:20.14,Default,,0,0,0,,但是如果我对两个这种东西调用ADD
Dialogue: 0,1:11:22.33,1:11:25.18,Default,,0,0,0,,答案就是
Dialogue: 0,1:11:25.18,1:11:28.14,Default,,0,0,0,,把这个和这个相加 而矩阵是怎么相加的
Dialogue: 0,1:11:29.03,1:11:31.11,Default,,0,0,0,,那么我可以用同样的方法实现
Dialogue: 0,1:11:31.11,1:11:31.71,Default,,0,0,0,,如果我这么做了
Dialogue: 0,1:11:31.96,1:11:34.60,Default,,0,0,0,,整个系统就马上可以处理像这样的东西了
Dialogue: 0,1:11:35.29,1:11:39.18,Default,,0,0,0,,比如说一个矩阵 它的元素都是
Dialogue: 0,1:11:39.46,1:11:42.16,Default,,0,0,0,,它的元素是一个有理式
Dialogue: 0,1:11:43.10,1:11:45.15,Default,,0,0,0,,这个有理式的分子分母都是多项式
Dialogue: 0,1:11:47.02,1:11:49.56,Default,,0,0,0,,我们自然而然地获得了这些功能
Dialogue: 0,1:11:51.28,1:11:53.82,Default,,0,0,0,,整个过程中发生了什么？
Dialogue: 0,1:11:53.92,1:11:56.17,Default,,0,0,0,,真正发生的是
Dialogue: 0,1:11:57.68,1:12:02.44,Default,,0,0,0,,我们摆脱了凡事都想插一手的经理
Dialogue: 0,1:12:03.12,1:12:06.19,Default,,0,0,0,,我们构造了一个“控制去中心化”的系统
Dialogue: 0,1:12:14.78,1:12:18.34,Default,,0,0,0,,你进入这个系统的时候 不会有人一边闲逛一边说
Dialogue: 0,1:12:18.35,1:12:22.30,Default,,0,0,0,,我看看官方列表中ADD是否能够处理你
Dialogue: 0,1:12:22.44,1:12:26.22,Default,,0,0,0,,你直接就可以用正确的方法 把你和别的东西加起来
Dialogue: 0,1:12:27.81,1:12:31.03,Default,,0,0,0,,这么做的好处就是 就连这种非常非常
Dialogue: 0,1:12:31.03,1:12:33.87,Default,,0,0,0,,复杂的分层对象也可以被分解后
Dialogue: 0,1:12:33.87,1:12:35.55,Default,,0,0,0,,自动放到正确的地方去处理
Dialogue: 0,1:12:37.00,1:12:37.79,Default,,0,0,0,,有什么问题吗？
Dialogue: 0,1:12:40.38,1:12:42.32,Default,,0,0,0,,学生：你说你“免费”获得了这些功能
Dialogue: 0,1:12:42.35,1:12:45.82,Default,,0,0,0,,但是我在意的是你现在丢掉了
Dialogue: 0,1:12:46.48,1:12:50.91,Default,,0,0,0,,某种上下层之间的清楚界限
Dialogue: 0,1:12:50.91,1:12:52.77,Default,,0,0,0,,或者说 现在你是在用
Dialogue: 0,1:12:52.77,1:12:56.08,Default,,0,0,0,,上层的东西来定义下层的过程
Dialogue: 0,1:12:56.61,1:12:59.45,Default,,0,0,0,,这不是很危险吗？
Dialogue: 0,1:13:00.35,1:13:04.49,Default,,0,0,0,,或者说 结构会变得混乱？
Dialogue: 0,1:13:05.44,1:13:05.95,Default,,0,0,0,,教授：不 我--
Dialogue: 0,1:13:06.41,1:13:07.77,Default,,0,0,0,,你问它的结构是否混乱
Dialogue: 0,1:13:07.77,1:13:08.69,Default,,0,0,0,,这得要看你说的“结构”是指什么
Dialogue: 0,1:13:08.69,1:13:10.17,Default,,0,0,0,,整个过程里我们都在做递归
Dialogue: 0,1:13:11.05,1:13:18.80,Default,,0,0,0,,看 就是说要把这些东西相加就要用到这个过程
Dialogue: 0,1:13:19.15,1:13:21.37,Default,,0,0,0,,它是一种递归结构 并不混乱
Dialogue: 0,1:13:22.70,1:13:24.99,Default,,0,0,0,,所以我不认为它不清楚
Dialogue: 0,1:13:24.99,1:13:28.16,Default,,0,0,0,,学生：那么当你修改乘法或加法运算时
Dialogue: 0,1:13:29.34,1:13:31.38,Default,,0,0,0,,可能会导致
Dialogue: 0,1:13:31.38,1:13:34.27,Default,,0,0,0,,无法预测的灾难性后果
Dialogue: 0,1:13:34.48,1:13:36.44,Default,,0,0,0,,教授：你说得对 但是那要看你的意思是什么
Dialogue: 0,1:13:37.08,1:13:38.47,Default,,0,0,0,,从两个角度来讨论
Dialogue: 0,1:13:39.10,1:13:43.24,Default,,0,0,0,,举个什么例子好呢？
Dialogue: 0,1:13:44.69,1:13:47.50,Default,,0,0,0,,比如说 之前我忽略了GCD运算
Dialogue: 0,1:13:47.77,1:13:50.08,Default,,0,0,0,,我们忽略了它 是为了简化我们的例子
Dialogue: 0,1:13:50.28,1:13:56.92,Default,,0,0,0,,但是如果突然我觉得 这里的+rat
Dialogue: 0,1:13:57.82,1:14:01.69,Default,,0,0,0,,应该把结果约分 然后把这个功能安装到程序里
Dialogue: 0,1:14:03.34,1:14:07.87,Default,,0,0,0,,那么这个功能一旦安装 就立刻可以被所有过程调用
Dialogue: 0,1:14:08.03,1:14:10.08,Default,,0,0,0,,被这个或者那个 所有的这些
Dialogue: 0,1:14:11.56,1:14:13.89,Default,,0,0,0,,这取决于你系统的相干性（耦合度）
Dialogue: 0,1:14:13.89,1:14:17.03,Default,,0,0,0,,确实你可能想设计一个
Dialogue: 0,1:14:17.03,1:14:19.56,Default,,0,0,0,,不这样递归下降的程序
Dialogue: 0,1:14:19.61,1:14:22.97,Default,,0,0,0,,但是我举这个例子的好处 就在于我们通常都是这么做的
Dialogue: 0,1:14:25.44,1:14:27.63,Default,,0,0,0,,学生：是不是有一个问题 我想
Dialogue: 0,1:14:27.63,1:14:32.95,Default,,0,0,0,,就是你会被这个结构捆绑起来
Dialogue: 0,1:14:32.95,1:14:36.33,Default,,0,0,0,,这个递归的结构是实际上被执行了的
Dialogue: 0,1:14:36.33,1:14:40.34,Default,,0,0,0,,而不是仅仅是为了定义类型的需要
Dialogue: 0,1:14:40.34,1:14:41.16,Default,,0,0,0,,被这个事实所束缚
Dialogue: 0,1:14:44.68,1:14:46.12,Default,,0,0,0,,教授：我大概明白你的意思
Dialogue: 0,1:14:46.12,1:14:47.80,Default,,0,0,0,,你是想说在这个系统投入运行之后
Dialogue: 0,1:14:47.82,1:14:50.40,Default,,0,0,0,,这些类型还会变得越来越复杂
Dialogue: 0,1:14:50.40,1:14:50.73,Default,,0,0,0,,你是不是想……
Dialogue: 0,1:14:50.73,1:14:50.99,Default,,0,0,0,,学生：对
Dialogue: 0,1:14:50.99,1:14:51.79,Default,,0,0,0,,在它投入运行之后
Dialogue: 0,1:14:52.09,1:14:54.18,Default,,0,0,0,,学生：而不是作为基本的定义
Dialogue: 0,1:14:54.18,1:14:54.83,Default,,0,0,0,,教授：对
Dialogue: 0,1:14:54.83,1:14:56.70,Default,,0,0,0,,我们的类型结构可以说就是递归的
Dialogue: 0,1:14:57.21,1:15:00.22,Default,,0,0,0,,它并不是一个 可以在系统投入运行之前
Dialogue: 0,1:15:01.58,1:15:04.85,Default,,0,0,0,,就能把要用到的东西全部包括的列表
Dialogue: 0,1:15:04.85,1:15:05.79,Default,,0,0,0,,它是一个不断演进的东西
Dialogue: 0,1:15:06.78,1:15:08.64,Default,,0,0,0,,所以如果你想要定制这个系统
Dialogue: 0,1:15:08.67,1:15:10.96,Default,,0,0,0,,你就不能通过有限的表
Dialogue: 0,1:15:11.00,1:15:13.18,Default,,0,0,0,,你需要用一个递归结构实现它
Dialogue: 0,1:15:13.67,1:15:17.90,Default,,0,0,0,,学生：因为类型的基本结构是相当简单而明了的
Dialogue: 0,1:15:17.90,1:15:18.19,Default,,0,0,0,,教授：对
Dialogue: 0,1:15:20.40,1:15:20.75,Default,,0,0,0,,嗯？
Dialogue: 0,1:15:21.46,1:15:22.87,Default,,0,0,0,,学生：我有一个问题
Dialogue: 0,1:15:22.87,1:15:25.68,Default,,0,0,0,,我明白一旦你的数据结构被设计好之后
Dialogue: 0,1:15:25.71,1:15:28.73,Default,,0,0,0,,它是怎么把complex标志拿掉 把它传递给下层
Dialogue: 0,1:15:28.73,1:15:30.64,Default,,0,0,0,,然后把rect类型拿掉 再传递给下层
Dialogue: 0,1:15:30.64,1:15:33.95,Default,,0,0,0,,但是如果你只是一个用户 并不知道什么rect或者polar类型
Dialogue: 0,1:15:34.25,1:15:36.04,Default,,0,0,0,,你怎么知道如何去设置这个数据结构
Dialogue: 0,1:15:36.09,1:15:38.08,Default,,0,0,0,,让所有东西正常运转呢
Dialogue: 0,1:15:38.09,1:15:41.00,Default,,0,0,0,,如果我只知道左边的这个算式
Dialogue: 0,1:15:41.02,1:15:42.50,Default,,0,0,0,,我只是想把复数加起来或者乘起来
Dialogue: 0,1:15:42.50,1:15:43.64,Default,,0,0,0,,教授：这就是它神奇的地方
Dialogue: 0,1:15:43.64,1:15:45.26,Default,,0,0,0,,如果你是一个用户 直接调用mul就可以了
Dialogue: 0,1:15:47.73,1:15:49.95,Default,,0,0,0,,学生：然后它就能明白我要计算的是复数？
Dialogue: 0,1:15:49.96,1:15:51.23,Default,,0,0,0,,或者我怎么告诉它我想——
Dialogue: 0,1:15:51.26,1:15:53.05,Default,,0,0,0,,教授：只要你给它的是复数它就能明白
Dialogue: 0,1:15:53.05,1:15:56.30,Default,,0,0,0,,作为这个系统的用户
Dialogue: 0,1:15:56.32,1:15:58.14,Default,,0,0,0,,你能使用的是复数的构造函数
Dialogue: 0,1:15:58.37,1:15:59.55,Default,,0,0,0,,学生：那么我需要自己构造复数了？
Dialogue: 0,1:15:59.56,1:16:00.35,Default,,0,0,0,,教授：那么你需要自己构造它们
Dialogue: 0,1:16:00.35,1:16:04.01,Default,,0,0,0,,作为用户 你可能只能够操作命令行
Dialogue: 0,1:16:04.65,1:16:07.56,Default,,0,0,0,,它会给你提供一些合理的方法
Dialogue: 0,1:16:07.56,1:16:08.86,Default,,0,0,0,,来输入复数
Dialogue: 0,1:16:09.31,1:16:11.00,Default,,0,0,0,,让你用你喜欢的格式输入
Dialogue: 0,1:16:11.59,1:16:14.36,Default,,0,0,0,,也可能你根本就不用输入它们
Dialogue: 0,1:16:14.36,1:16:16.17,Default,,0,0,0,,只是别人给你一个复数让你计算
Dialogue: 0,1:16:16.78,1:16:19.82,Default,,0,0,0,,学生：好 那么如果我有一个含有多项式的复数
Dialogue: 0,1:16:19.82,1:16:21.96,Default,,0,0,0,,我就要先构造这个多项式 然后再构造我的复数
Dialogue: 0,1:16:21.96,1:16:23.96,Default,,0,0,0,,教授：如果你是从零开始构造它的话 是这样的
Dialogue: 0,1:16:24.28,1:16:25.71,Default,,0,0,0,,可以说你是在从零开始构造
Dialogue: 0,1:16:25.71,1:16:27.05,Default,,0,0,0,,而你只要有了要计算的东西
Dialogue: 0,1:16:27.28,1:16:30.32,Default,,0,0,0,,可以直接调用mul运算 然后它们就会被乘起来
Dialogue: 0,1:16:32.78,1:16:32.99,Default,,0,0,0,,说吧
Dialogue: 0,1:16:33.27,1:16:35.76,Default,,0,0,0,,学生：我想提一个问题 就是……
Dialogue: 0,1:16:36.45,1:16:40.01,Default,,0,0,0,,比如说我想修改我的复数表示方法
Dialogue: 0,1:16:40.03,1:16:41.44,Default,,0,0,0,,或者复数的某些运算
Dialogue: 0,1:16:41.52,1:16:47.10,Default,,0,0,0,,为了修改一个特定的运算
Dialogue: 0,1:16:47.15,1:16:51.26,Default,,0,0,0,,我得考虑多少代码？
Dialogue: 0,1:16:52.27,1:16:53.49,Default,,0,0,0,,教授：得看你想要修改什么
Dialogue: 0,1:16:53.49,1:16:54.99,Default,,0,0,0,,重点在于你只需要改
Dialogue: 0,1:16:55.39,1:16:56.07,Default,,0,0,0,,你想改的那一部分
Dialogue: 0,1:16:56.07,1:17:00.04,Default,,0,0,0,,想象一下如果Martha决定她
Dialogue: 0,1:17:00.32,1:17:01.23,Default,,0,0,0,,举个不太好的例子
Dialogue: 0,1:17:01.44,1:17:02.91,Default,,0,0,0,,比如把序对中两个数的顺序调换
Dialogue: 0,1:17:04.04,1:17:08.72,Default,,0,0,0,,把模和辐角的顺序反过来
Dialogue: 0,1:17:09.39,1:17:10.80,Default,,0,0,0,,她只做了局部的修改
Dialogue: 0,1:17:10.97,1:17:13.29,Default,,0,0,0,,那么这个改动会准确无误地扩散到整个系统里
Dialogue: 0,1:17:14.79,1:17:18.76,Default,,0,0,0,,或者突然你说 我有另一种方法来表示有理数
Dialogue: 0,1:17:19.70,1:17:23.90,Default,,0,0,0,,我就得不断地在表格中添加运算
Dialogue: 0,1:17:24.82,1:17:27.22,Default,,0,0,0,,那么突然之间所有的多项式
Dialogue: 0,1:17:27.22,1:17:29.10,Default,,0,0,0,,它们的系数和系数的系数 或者什么东西
Dialogue: 0,1:17:29.24,1:17:32.40,Default,,0,0,0,,都自动支持用这种表示方法来表示了
Dialogue: 0,1:17:32.70,1:17:34.67,Default,,0,0,0,,这就是我们这种设计的威力
Dialogue: 0,1:17:36.11,1:17:38.70,Default,,0,0,0,,学生：我提的这个问题可能听起来比较蠢
Dialogue: 0,1:17:38.70,1:17:42.38,Default,,0,0,0,,整个这个系统看起来
Dialogue: 0,1:17:42.54,1:17:45.88,Default,,0,0,0,,非常完美 所有的东西都各就各位
Dialogue: 0,1:17:46.72,1:17:48.67,Default,,0,0,0,,完美得有点出乎意料
Dialogue: 0,1:17:50.93,1:17:52.52,Default,,0,0,0,,我相信 这都是为了教学方便
Dialogue: 0,1:17:52.56,1:17:54.65,Default,,0,0,0,,我怀疑的是首先发明了这种做法的人
Dialogue: 0,1:17:55.10,1:17:55.85,Default,,0,0,0,,我可能说得不对
Dialogue: 0,1:17:56.60,1:17:59.72,Default,,0,0,0,,难道一下子就搞清楚了所有这些东西一起
Dialogue: 0,1:17:59.77,1:18:03.93,Default,,0,0,0,,只要把这些放在一起 你就突然可以对各种对象做各种运算
Dialogue: 0,1:18:04.86,1:18:07.20,Default,,0,0,0,,我觉得他们应该研究了很长时间
Dialogue: 0,1:18:07.93,1:18:10.62,Default,,0,0,0,,不断地推倒重来
Dialogue: 0,1:18:11.80,1:18:14.12,Default,,0,0,0,,然后我觉得 当我们设计一个非常复杂的系统
Dialogue: 0,1:18:14.12,1:18:16.94,Default,,0,0,0,,我们也要面对这样的问题
Dialogue: 0,1:18:17.31,1:18:20.35,Default,,0,0,0,,就是有太多各种各样的部件 我们甚至不知道
Dialogue: 0,1:18:21.08,1:18:24.62,Default,,0,0,0,,我们甚至不知道要对这些部件做什么样的操作
Dialogue: 0,1:18:24.62,1:18:26.54,Default,,0,0,0,,在这种时候我怎么用这种良好的方法组织操作
Dialogue: 0,1:18:26.56,1:18:29.63,Default,,0,0,0,,才能获得这种 不管怎样只要把它们放在一起
Dialogue: 0,1:18:29.63,1:18:31.39,Default,,0,0,0,,所有事情就正常运转 这样的效果呢
Dialogue: 0,1:18:31.70,1:18:34.34,Default,,0,0,0,,教授：很好 这确实是一个非常聪明的问题
Dialogue: 0,1:18:35.10,1:18:39.52,Default,,0,0,0,,要说的一点是我们这种方法论
Dialogue: 0,1:18:39.87,1:18:43.88,Default,,0,0,0,,受到了符号代数的很多启发
Dialogue: 0,1:18:44.59,1:18:45.90,Default,,0,0,0,,符号代数相当繁复
Dialogue: 0,1:18:47.59,1:18:50.71,Default,,0,0,0,,允许你在决定各种运算是什么样子之前
Dialogue: 0,1:18:50.71,1:18:52.89,Default,,0,0,0,,来实现这个系统
Dialogue: 0,1:18:53.31,1:18:57.72,Default,,0,0,0,,所以从某种意义上讲 这是人们在这方面长期探索之后得出的答案
Dialogue: 0,1:18:58.56,1:19:00.75,Default,,0,0,0,,从另一个角度来说 这确实是精心设计的例子
Dialogue: 0,1:19:02.16,1:19:06.24,Default,,0,0,0,,学生：看上去想要设计出这样的系统
Dialogue: 0,1:19:06.24,1:19:09.01,Default,,0,0,0,,一开始先要研究一段时间然后才能变熟练
Dialogue: 0,1:19:09.01,1:19:11.88,Default,,0,0,0,,教授：我给你看看这个东西是多么的勉强
Dialogue: 0,1:19:12.22,1:19:14.13,Default,,0,0,0,,你现在可以写下所有的这些程序
Dialogue: 0,1:19:14.13,1:19:16.25,Default,,0,0,0,,但是我写在这里的这个系统
Dialogue: 0,1:19:17.02,1:19:18.96,Default,,0,0,0,,如果允许我拖堂半小时的话
Dialogue: 0,1:19:19.31,1:19:20.46,Default,,0,0,0,,我会给大家讲
Dialogue: 0,1:19:20.81,1:19:23.02,Default,,0,0,0,,如果我让它做一个错误操作
Dialogue: 0,1:19:23.20,1:19:29.31,Default,,0,0,0,,比如一个愚蠢的命令 用3加上7/2 它就会崩溃
Dialogue: 0,1:19:30.88,1:19:33.42,Default,,0,0,0,,因为程序首先会调用operate-2这个过程
Dialogue: 0,1:19:33.80,1:19:35.95,Default,,0,0,0,,然后operate-2会说 这个是数字类型
Dialogue: 0,1:19:36.18,1:19:37.37,Default,,0,0,0,,那个是有理数类型
Dialogue: 0,1:19:37.56,1:19:38.81,Default,,0,0,0,,我不知道怎么把它们加起来
Dialogue: 0,1:19:41.53,1:19:44.30,Default,,0,0,0,,那么你想让这个系统至少能够
Dialogue: 0,1:19:45.88,1:19:47.34,Default,,0,0,0,,比如说 在做这个操作之前
Dialogue: 0,1:19:48.59,1:19:50.24,Default,,0,0,0,,把3提升为3/1
Dialogue: 0,1:19:50.48,1:19:53.21,Default,,0,0,0,,把它变成一个有理数 然后交给有理数程序包来处理
Dialogue: 0,1:19:54.86,1:19:58.70,Default,,0,0,0,,课堂上我们来不及讲这个问题了
Dialogue: 0,1:19:58.73,1:20:00.88,Default,,0,0,0,,书里面讨论了这个问题
Dialogue: 0,1:20:00.88,1:20:01.95,Default,,0,0,0,,叫做“类型转换”
Dialogue: 0,1:20:03.39,1:20:05.15,Default,,0,0,0,,你想要的是
Dialogue: 0,1:20:05.31,1:20:08.89,Default,,0,0,0,,看 我们小心翼翼地把对象按类型分好类
Dialogue: 0,1:20:08.91,1:20:12.17,Default,,0,0,0,,但是有时你也想让它
Dialogue: 0,1:20:12.40,1:20:17.98,Default,,0,0,0,,知道怎么把一个普通的数字当成有理数
Dialogue: 0,1:20:19.11,1:20:21.29,Default,,0,0,0,,或者把普通的数字当成复数
Dialogue: 0,1:20:21.62,1:20:25.16,Default,,0,0,0,,到那个时候系统就开始变得复杂了
Dialogue: 0,1:20:25.76,1:20:28.12,Default,,0,0,0,,就是你去思考 我应该把这些知识放在哪里的时候
Dialogue: 0,1:20:28.42,1:20:32.19,Default,,0,0,0,,是应该让有理数知道它们是由普通的数字构成的吗？
Dialogue: 0,1:20:33.13,1:20:36.38,Default,,0,0,0,,或者我们举一个更加糟糕的例子
Dialogue: 0,1:20:38.14,1:20:47.48,Default,,0,0,0,,比如说我想要把一个复数加到有理数上去
Dialogue: 0,1:20:49.87,1:20:50.76,Default,,0,0,0,,这个不好
Dialogue: 0,1:20:50.76,1:20:51.58,Default,,0,0,0,,5/7
Dialogue: 0,1:20:53.86,1:20:55.72,Default,,0,0,0,,然后整个系统里必须有人知道
Dialogue: 0,1:20:56.06,1:20:58.16,Default,,0,0,0,,他需要把这个东西变成另一种类型
Dialogue: 0,1:20:58.20,1:21:00.65,Default,,0,0,0,,要把它变成一部分是有理数的复数
Dialogue: 0,1:21:01.54,1:21:02.68,Default,,0,0,0,,那么谁应该去操心这个事情呢
Dialogue: 0,1:21:02.68,1:21:03.95,Default,,0,0,0,,是complex程序包吗？
Dialogue: 0,1:21:03.95,1:21:05.03,Default,,0,0,0,,是rational程序包吗？
Dialogue: 0,1:21:05.24,1:21:06.22,Default,,0,0,0,,还是plus过程要考虑这个问题？
Dialogue: 0,1:21:06.90,1:21:08.52,Default,,0,0,0,,这就是体现复杂性的地方
Dialogue: 0,1:21:08.52,1:21:11.38,Default,,0,0,0,,也是这个问题的特别之处
Dialogue: 0,1:21:11.38,1:21:14.12,Default,,0,0,0,,同时很多的 实际上是所有的这样的“消息传递”的想法
Dialogue: 0,1:21:14.64,1:21:16.54,Default,,0,0,0,,都是被这样的问题启发的
Dialogue: 0,1:21:18.46,1:21:20.89,Default,,0,0,0,,当你真正深入进去
Dialogue: 0,1:21:20.91,1:21:24.76,Default,,0,0,0,,人们发现 代数操作的问题是如此复杂
Dialogue: 0,1:21:25.18,1:21:27.41,Default,,0,0,0,,而那些一直围绕它们工作的人们 确实就处在
Dialogue: 0,1:21:27.41,1:21:28.05,Default,,0,0,0,,你说的那种状态
Dialogue: 0,1:21:28.05,1:21:29.71,Default,,0,0,0,,他们在这些问题里艰难跋涉 时不时陷进泥里
Dialogue: 0,1:21:29.72,1:21:31.37,Default,,0,0,0,,寻找好用的工具 并试着提炼一种通用方法
Dialogue: 0,1:21:34.20,1:21:37.76,Default,,0,0,0,,学生：我想再一次回到这个复杂度的问题上来
Dialogue: 0,1:21:38.41,1:21:44.55,Default,,0,0,0,,在修改底层过程的时候 这个系统
Dialogue: 0,1:21:44.55,1:21:48.32,Default,,0,0,0,,毫无疑问 体现了非常大的灵活性
Dialogue: 0,1:21:49.71,1:21:53.40,Default,,0,0,0,,但是确实 在某种意义上讲
Dialogue: 0,1:21:53.44,1:21:55.26,Default,,0,0,0,,冻结了高层运算
Dialogue: 0,1:21:55.45,1:21:58.51,Default,,0,0,0,,或者至少如果你修改它们 你不知道
Dialogue: 0,1:21:58.51,1:22:02.06,Default,,0,0,0,,改动会体现在哪里 会怎么体现出来
Dialogue: 0,1:22:02.20,1:22:04.22,Default,,0,0,0,,教授：这个问题真是不能再好了
Dialogue: 0,1:22:04.68,1:22:05.87,Default,,0,0,0,,我要做的事情就是
Dialogue: 0,1:22:08.68,1:22:10.84,Default,,0,0,0,,如果我决定添加一个通用操作
Dialogue: 0,1:22:11.45,1:22:13.07,Default,,0,0,0,,比如equality-test
Dialogue: 0,1:22:14.96,1:22:17.15,Default,,0,0,0,,那么系统中的其它人就要查表格
Dialogue: 0,1:22:18.22,1:22:22.54,Default,,0,0,0,,来看他们需不需要支持equality-test
Dialogue: 0,1:22:24.65,1:22:26.84,Default,,0,0,0,,我们可以让它变得更加去中心化
Dialogue: 0,1:22:27.87,1:22:30.70,Default,,0,0,0,,这就是之前我提示了很多次的事情
Dialogue: 0,1:22:31.08,1:22:33.26,Default,,0,0,0,,你不但可以通过给对象添加符号标签来体现类型
Dialogue: 0,1:22:33.40,1:22:38.70,Default,,0,0,0,,而是把每一类对象接受的运算也保存在里面
Dialogue: 0,1:22:40.45,1:22:43.90,Default,,0,0,0,,那么你可以添加一个 比如说最大公约数过程
Dialogue: 0,1:22:44.43,1:22:46.81,Default,,0,0,0,,它只能计算整数
Dialogue: 0,1:22:47.40,1:22:49.21,Default,,0,0,0,,而不是对所有有理数都通用
Dialogue: 0,1:22:51.03,1:22:53.11,Default,,0,0,0,,所以这个系统可能是非常非常碎片化的
Dialogue: 0,1:22:53.11,1:22:55.66,Default,,0,0,0,,取决于你想让哪一部分比较灵活
Dialogue: 0,1:22:56.22,1:22:59.02,Default,,0,0,0,,有一系列的地方让你把这个东西放进去
Dialogue: 0,1:22:59.96,1:23:02.56,Default,,0,0,0,,但是你也指出了这种设计的弱点
Dialogue: 0,1:23:02.60,1:23:06.37,Default,,0,0,0,,就是必须在顶层 对于这些通用运算符有一些约定
Dialogue: 0,1:23:06.37,1:23:07.82,Default,,0,0,0,,或者至少人们要考虑这件事情
Dialogue: 0,1:23:08.39,1:23:10.72,Default,,0,0,0,,或者你可以决定 把这个表格设计得非常稀疏
Dialogue: 0,1:23:10.75,1:23:11.96,Default,,0,0,0,,里面只放很少的一点东西
Dialogue: 0,1:23:14.01,1:23:15.49,Default,,0,0,0,,这个游戏有很多种玩法
Dialogue: 0,1:23:19.78,1:23:20.43,Default,,0,0,0,,谢谢大家
Dialogue: 0,1:23:23.53,1:23:36.56,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:23:23.53,1:23:36.56,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
