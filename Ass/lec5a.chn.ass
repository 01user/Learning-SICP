[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 640
PlayResY: 480

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:01.96,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:01.98,0:00:09.55,title,,0,0,0,,{\fad(600,800)\pos(324,32)}计算机程序的构造和解释
Dialogue: 0,0:00:01.98,0:00:09.55,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}压制&&特效\N邓雄飞\N（Dysprosium）
Dialogue: 0,0:00:01.98,0:00:09.55,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:01.98,0:00:09.55,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}翻译&&时间轴\N杨启钊（windfarer）
Dialogue: 0,0:00:01.98,0:00:09.55,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:09.92,0:00:13.63,Declare,,0,0,0,,{\an2\fad(500,500)}赋值、状态和副作用
Dialogue: 0,0:00:18.31,0:00:22.00,Default,,0,0,0,,教授：到目前为止 我们已经教了很多编程技巧
Dialogue: 0,0:00:22.25,0:00:24.06,Default,,0,0,0,,来编写复杂程序了
Dialogue: 0,0:00:24.76,0:00:29.66,Default,,0,0,0,,并且 到目前为止 关于编程你们学到了很多
Dialogue: 0,0:00:29.66,0:00:31.48,Default,,0,0,0,,你们已经学习了几乎所有的
Dialogue: 0,0:00:31.86,0:00:35.87,Default,,0,0,0,,那些拥有大量经验的人 才能领悟的技巧
Dialogue: 0,0:00:36.41,0:00:40.08,Default,,0,0,0,,例如 数据导向编程就是一个主要的技巧
Dialogue: 0,0:00:40.75,0:00:43.15,Default,,0,0,0,,昨天 你们也学习了一种解释型语言
Dialogue: 0,0:00:45.02,0:00:48.46,Default,,0,0,0,,我们所做的这一切
Dialogue: 0,0:00:48.54,0:00:49.63,Default,,0,0,0,,目前来讲
Dialogue: 0,0:00:49.88,0:00:51.95,Default,,0,0,0,,都是在一种没有赋值语句的计算机语言中完成的
Dialogue: 0,0:00:53.77,0:00:58.17,Default,,0,0,0,,对于你们中用过Basic或者Pascal的人
Dialogue: 0,0:00:58.68,0:01:01.23,Default,,0,0,0,,可能会认为“赋值”是最重要的东西
Dialogue: 0,0:01:01.79,0:01:03.82,Default,,0,0,0,,今天我们将要做一些糟糕的事情
Dialogue: 0,0:01:03.82,0:01:05.45,Default,,0,0,0,,我们要把赋值语句加进来
Dialogue: 0,0:01:07.21,0:01:09.14,Default,,0,0,0,,既然在没有赋值语句的时候 我们都可以很好地完成工作
Dialogue: 0,0:01:09.14,0:01:10.17,Default,,0,0,0,,为什么我们还要把它加进来呢？
Dialogue: 0,0:01:10.99,0:01:12.43,Default,,0,0,0,,为了理解它
Dialogue: 0,0:01:12.46,0:01:15.71,Default,,0,0,0,,我们今天首先要定下一个规则
Dialogue: 0,0:01:16.48,0:01:17.93,Default,,0,0,0,,而我们将一直遵守这个规则
Dialogue: 0,0:01:17.93,0:01:20.80,Default,,0,0,0,,这是我们为语言引入新的特性的唯一原因
Dialogue: 0,0:01:21.53,0:01:23.14,Default,,0,0,0,,是因为我们有一个好的理由
Dialogue: 0,0:01:23.93,0:01:27.28,Default,,0,0,0,,好的理由归结为能力
Dialogue: 0,0:01:27.42,0:01:31.51,Default,,0,0,0,,你现在获得了把问题分解为不同部分的能力
Dialogue: 0,0:01:31.51,0:01:33.44,Default,,0,0,0,,在没有相关能力之前可不行
Dialogue: 0,0:01:34.38,0:01:36.16,Default,,0,0,0,,这让你有用来分解问题的另外方法
Dialogue: 0,0:01:38.30,0:01:39.45,Default,,0,0,0,,我们这就开始
Dialogue: 0,0:01:39.45,0:01:41.88,Default,,0,0,0,,从回顾我们的
Dialogue: 0,0:01:41.88,0:01:47.37,Default,,0,0,0,,现在已经有的这种语言出发
Dialogue: 0,0:01:48.16,0:01:50.44,Default,,0,0,0,,我们之前写的是所谓的函数式程序
Dialogue: 0,0:01:51.21,0:01:52.52,Default,,0,0,0,,函数式程序
Dialogue: 0,0:01:53.04,0:01:57.95,Default,,0,0,0,,是一种对数学事实的编码
Dialogue: 0,0:01:58.88,0:02:00.51,Default,,0,0,0,,例如 当我们看到
Dialogue: 0,0:02:00.51,0:02:04.09,Default,,0,0,0,,像幻灯片上这样阶乘过程时
Dialogue: 0,0:02:05.07,0:02:06.62,Default,,0,0,0,,基本上是两个子句
Dialogue: 0,0:02:06.99,0:02:08.64,Default,,0,0,0,,如果n是1 则结果是1
Dialogue: 0,0:02:08.64,0:02:11.20,Default,,0,0,0,,否则返回n乘以n-1的阶乘
Dialogue: 0,0:02:11.20,0:02:12.33,Default,,0,0,0,,这是n的阶乘
Dialogue: 0,0:02:12.89,0:02:14.27,Default,,0,0,0,,它就是阶乘函数
Dialogue: 0,0:02:14.83,0:02:16.87,Default,,0,0,0,,如果用一些其他的记号
Dialogue: 0,0:02:16.87,0:02:19.32,Default,,0,0,0,,那些你在微积分课堂上学到的晦涩的符号来写
Dialogue: 0,0:02:20.30,0:02:22.11,Default,,0,0,0,,用数理逻辑来写
Dialogue: 0,0:02:22.11,0:02:26.36,Default,,0,0,0,,如果n等于1
Dialogue: 0,0:02:27.13,0:02:29.90,Default,,0,0,0,,那么n的阶乘结果是1 否则
Dialogue: 0,0:02:29.90,0:02:32.56,Default,,0,0,0,,如果n大于1 则n的阶乘就是n * (n-1)!
Dialogue: 0,0:02:32.56,0:02:33.55,Default,,0,0,0,,数学事实
Dialogue: 0,0:02:34.92,0:02:36.70,Default,,0,0,0,,就是我们一直使用的那种语言
Dialogue: 0,0:02:37.00,0:02:39.23,Default,,0,0,0,,无论何时 我们遇到了这样的数学事实
Dialogue: 0,0:02:39.53,0:02:46.65,Default,,0,0,0,,有一种理解它们工作原理的方法
Dialogue: 0,0:02:47.40,0:02:51.12,Default,,0,0,0,,就是这些过程可以由代换演算而来
Dialogue: 0,0:02:51.29,0:02:53.71,Default,,0,0,0,,来看第二张幻灯片
Dialogue: 0,0:02:54.99,0:02:58.81,Default,,0,0,0,,我们理解执行的过程
Dialogue: 0,0:02:58.83,0:03:03.50,Default,,0,0,0,,隐含在表达式的顺序中
Dialogue: 0,0:03:04.04,0:03:07.76,Default,,0,0,0,,也就是你不断地将实际参数
Dialogue: 0,0:03:07.87,0:03:10.88,Default,,0,0,0,,代换到程序体的形式参数中
Dialogue: 0,0:03:12.00,0:03:14.51,Default,,0,0,0,,这些基本上是一系列的等价代换
Dialogue: 0,0:03:14.61,0:03:17.25,Default,,0,0,0,,4的阶乘是4乘以3的阶乘
Dialogue: 0,0:03:17.25,0:03:20.05,Default,,0,0,0,,也就是4乘以3乘以2的阶乘
Dialogue: 0,0:03:20.05,0:03:21.01,Default,,0,0,0,,以此类推
Dialogue: 0,0:03:21.23,0:03:23.87,Default,,0,0,0,,我们总是保持数学事实成立
Dialogue: 0,0:03:25.23,0:03:28.84,Default,,0,0,0,,尽管我们正在讨论数学事实
Dialogue: 0,0:03:28.84,0:03:31.96,Default,,0,0,0,,可能有多种数学事实的组织方式
Dialogue: 0,0:03:31.96,0:03:35.12,Default,,0,0,0,,用来描述一个特定的函数的计算
Dialogue: 0,0:03:36.32,0:03:38.42,Default,,0,0,0,,这个特定的函数的值的计算
Dialogue: 0,0:03:38.42,0:03:40.92,Default,,0,0,0,,所以 让我来看下这里的例子
Dialogue: 0,0:03:41.48,0:03:49.02,Default,,0,0,0,,这有一个计算m与n之和的方法
Dialogue: 0,0:03:49.53,0:03:52.04,Default,,0,0,0,,我们使用一个递归的过程来完成
Dialogue: 0,0:03:52.89,0:03:58.16,Default,,0,0,0,,也就是(1+ (+ (-1+ n) m))
Dialogue: 0,0:04:00.08,0:04:05.62,Default,,0,0,0,,当然 这里也有相应的数理逻辑 解释了这个方法
Dialogue: 0,0:04:06.17,0:04:10.49,Default,,0,0,0,,也就是((n-1)+m)+1
Dialogue: 0,0:04:11.40,0:04:12.22,Default,,0,0,0,,跟之前那个一样
Dialogue: 0,0:04:13.10,0:04:16.40,Default,,0,0,0,,所以这儿并没有什么特殊的魔法
Dialogue: 0,0:04:16.41,0:04:20.01,Default,,0,0,0,,当然 如果我们可以再来看一个相同的迭代过程
Dialogue: 0,0:04:20.19,0:04:24.92,Default,,0,0,0,,计算同样的函数 但是进行逐步迭代的程序
Dialogue: 0,0:04:25.26,0:04:27.56,Default,,0,0,0,,这两个程序将得到同样的结果
Dialogue: 0,0:04:30.08,0:04:34.83,Default,,0,0,0,,我们就可以认为这两个程序在数学上是等效的
Dialogue: 0,0:04:36.65,0:04:39.93,Default,,0,0,0,,你对这些数学事实的排序 决定了具体（计算）过程
Dialogue: 0,0:04:40.30,0:04:43.42,Default,,0,0,0,,我们对于这些数学事实的排序和选择 决定了过程发展的方式
Dialogue: 0,0:04:44.33,0:04:48.60,Default,,0,0,0,,因此我们可以灵活地讨论待计算的函数
Dialogue: 0,0:04:48.60,0:04:50.19,Default,,0,0,0,,以及计算该函数的所用的方法
Dialogue: 0,0:04:50.60,0:04:52.60,Default,,0,0,0,,这并不清晰 我们需要再深入一些
Dialogue: 0,0:04:53.61,0:04:55.50,Default,,0,0,0,,然而 今天我要来讲这个糟糕的东西
Dialogue: 0,0:04:55.50,0:04:58.43,Default,,0,0,0,,我要给大家介绍赋值操作
Dialogue: 0,0:04:58.89,0:05:00.41,Default,,0,0,0,,这是什么？
Dialogue: 0,0:05:02.89,0:05:09.22,Default,,0,0,0,,首先 在编程语言中有另一种语句
Dialogue: 0,0:05:09.22,0:05:10.84,Default,,0,0,0,,这种语句叫做SET!
Dialogue: 0,0:05:12.41,0:05:15.96,Default,,0,0,0,,具有赋值操作的语句
Dialogue: 0,0:05:15.96,0:05:15.98,Default,,0,0,0,,我都会在后面加上一个感叹号\NI'm going to put exclamation points after.\N具有赋值操作的语句\NAnd SET! -- Things that do things like assignment,
Dialogue: 0,0:05:15.98,0:05:17.85,Default,,0,0,0,,我都会在后面加上一个感叹号
Dialogue: 0,0:05:18.51,0:05:20.96,Default,,0,0,0,,这个感叹号代表什么意思呢？
Dialogue: 0,0:05:20.96,0:05:23.01,Default,,0,0,0,,这个感叹号 与问号类似
Dialogue: 0,0:05:23.01,0:05:25.88,Default,,0,0,0,,是我们给名字随意加的符号
Dialogue: 0,0:05:25.88,0:05:27.88,Default,,0,0,0,,它对于系统来说没有意义
Dialogue: 0,0:05:28.08,0:05:30.21,Default,,0,0,0,,它唯一的意义就是告诉我们
Dialogue: 0,0:05:30.40,0:05:34.41,Default,,0,0,0,,注意这里是某种赋值操作
Dialogue: 0,0:05:35.88,0:05:40.06,Default,,0,0,0,,但是我们要给某个变量赋一个值
Dialogue: 0,0:05:43.74,0:05:45.13,Default,,0,0,0,,这意味着
Dialogue: 0,0:05:45.13,0:05:48.28,Default,,0,0,0,,在某个时间点发生了一些事情
Dialogue: 0,0:05:48.65,0:05:49.61,Default,,0,0,0,,这是一个时间点
Dialogue: 0,0:05:49.86,0:05:52.14,Default,,0,0,0,,如果时间以这个方向流动
Dialogue: 0,0:05:53.50,0:05:54.82,Default,,0,0,0,,这是个时间轴
Dialogue: 0,0:05:55.00,0:05:57.82,Default,,0,0,0,,时间在平面上由上到下地流逝
Dialogue: 0,0:05:58.70,0:06:00.92,Default,,0,0,0,,赋值是第一个
Dialogue: 0,0:06:00.92,0:06:04.30,Default,,0,0,0,,使过去和未来之间产生差别的事物
Dialogue: 0,0:06:06.59,0:06:08.72,Default,,0,0,0,,我们之前写的所有程序
Dialogue: 0,0:06:09.18,0:06:10.68,Default,,0,0,0,,都不包含赋值
Dialogue: 0,0:06:10.68,0:06:13.12,Default,,0,0,0,,这些程序以怎样的顺序进行执行都没关系
Dialogue: 0,0:06:14.70,0:06:15.96,Default,,0,0,0,,但是赋值比较特殊
Dialogue: 0,0:06:15.96,0:06:17.69,Default,,0,0,0,,它使时间中产生了一个时间点
Dialogue: 0,0:06:17.96,0:06:24.73,Default,,0,0,0,,因此在SET!出现之前和之后中间有一个时间点
Dialogue: 0,0:06:27.61,0:06:32.70,Default,,0,0,0,,使得在这个时间点之后
Dialogue: 0,0:06:33.60,0:06:43.76,Default,,0,0,0,,变量有了一个值 即VALUE
Dialogue: 0,0:06:49.23,0:06:51.50,Default,,0,0,0,,与这个变量之前的值无关
Dialogue: 0,0:06:52.80,0:06:55.79,Default,,0,0,0,,SET!改变了它的值
Dialogue: 0,0:06:57.69,0:06:58.75,Default,,0,0,0,,在此之前
Dialogue: 0,0:06:58.75,0:07:01.50,Default,,0,0,0,,什么都没有发生改变
Dialogue: 0,0:07:03.21,0:07:04.11,Default,,0,0,0,,举例来说
Dialogue: 0,0:07:04.84,0:07:06.23,Default,,0,0,0,,我们可以想到的一件事是
Dialogue: 0,0:07:06.23,0:07:09.42,Default,,0,0,0,,我们写的一些过程 比如阶乘的程序
Dialogue: 0,0:07:09.64,0:07:12.75,Default,,0,0,0,,事实上与数学中的阶乘函数完全相同
Dialogue: 0,0:07:13.77,0:07:16.44,Default,,0,0,0,,比如说4的阶乘 如果我写FACT(4)
Dialogue: 0,0:07:17.23,0:07:19.15,Default,,0,0,0,,无论它的上下文是怎样的
Dialogue: 0,0:07:19.69,0:07:21.29,Default,,0,0,0,,无论我写几遍
Dialogue: 0,0:07:21.29,0:07:22.35,Default,,0,0,0,,我总能得到同样的结果
Dialogue: 0,0:07:23.29,0:07:24.12,Default,,0,0,0,,结果永远是24
Dialogue: 0,0:07:25.37,0:07:28.92,Default,,0,0,0,,它是参数到到结果的唯一映射
Dialogue: 0,0:07:30.30,0:07:32.65,Default,,0,0,0,,迄今为止 我们之前写的所有程序都是这样的
Dialogue: 0,0:07:33.52,0:07:36.03,Default,,0,0,0,,然而 当引入赋值后 一切就不同了
Dialogue: 0,0:07:36.96,0:07:38.16,Default,,0,0,0,,举个例子
Dialogue: 0,0:07:39.18,0:07:48.52,Default,,0,0,0,,如果我将COUNT定义为1
Dialogue: 0,0:07:50.00,0:07:52.41,Default,,0,0,0,,然后定义一个过程
Dialogue: 0,0:07:55.16,0:07:56.83,Default,,0,0,0,,一个叫做DEMO的简单过程
Dialogue: 0,0:07:59.52,0:08:03.84,Default,,0,0,0,,它接受参数X 并执行下面的操作
Dialogue: 0,0:08:03.84,0:08:09.62,Default,,0,0,0,,首先将X修改为X+1
Dialogue: 0,0:08:09.62,0:08:11.77,Default,,0,0,0,,我的天啊！ 这看起来就像FORTRAN是吧？
Dialogue: 0,0:08:13.16,0:08:14.17,Default,,0,0,0,,只是用了些有趣的语法
Dialogue: 0,0:08:16.80,0:08:21.37,Default,,0,0,0,,然后返回(+ X COUNT)
Dialogue: 0,0:08:22.14,0:08:24.14,Default,,0,0,0,,哦 我刚犯了个错
Dialogue: 0,0:08:24.38,0:08:25.23,Default,,0,0,0,,我的意思是
Dialogue: 0,0:08:25.47,0:08:27.12,Default,,0,0,0,,(SET! COUNT (1+ COUNT))
Dialogue: 0,0:08:30.37,0:08:31.79,Default,,0,0,0,,就是我在这里定义的这个
Dialogue: 0,0:08:34.41,0:08:36.51,Default,,0,0,0,,然后X和COUNT相加
Dialogue: 0,0:08:40.35,0:08:42.06,Default,,0,0,0,,然后就可以试着运行这个过程了
Dialogue: 0,0:08:42.48,0:08:43.20,Default,,0,0,0,,让我们运行它
Dialogue: 0,0:08:43.92,0:08:47.22,Default,,0,0,0,,假设我可以输入
Dialogue: 0,0:08:47.48,0:08:48.68,Default,,0,0,0,,输入(DEMO 3)
Dialogue: 0,0:08:52.19,0:08:53.20,Default,,0,0,0,,这里发生了什么？
Dialogue: 0,0:08:53.74,0:08:55.28,Default,,0,0,0,,发生的第一件事情是
Dialogue: 0,0:08:55.53,0:08:56.89,Default,,0,0,0,,COUNT现在是1
Dialogue: 0,0:08:56.89,0:08:58.40,Default,,0,0,0,,现在 这是一个时间点
Dialogue: 0,0:08:59.12,0:09:00.29,Default,,0,0,0,,我们在讨论时间点
Dialogue: 0,0:09:00.62,0:09:01.74,Default,,0,0,0,,X的值为3
Dialogue: 0,0:09:02.92,0:09:04.03,Default,,0,0,0,,在这个时刻
Dialogue: 0,0:09:04.67,0:09:07.53,Default,,0,0,0,,COUNT增加了 所以COUNT是2
Dialogue: 0,0:09:09.02,0:09:10.44,Default,,0,0,0,,2加3等于5
Dialogue: 0,0:09:10.80,0:09:12.43,Default,,0,0,0,,所以结果是5
Dialogue: 0,0:09:14.48,0:09:21.58,Default,,0,0,0,,然后我再一次 输入(DEMO 3)
Dialogue: 0,0:09:23.60,0:09:24.56,Default,,0,0,0,,结果是什么？
Dialogue: 0,0:09:24.83,0:09:27.40,Default,,0,0,0,,现在COUNT是2 它不再是1了
Dialogue: 0,0:09:28.91,0:09:30.35,Default,,0,0,0,,因为我让COUNT加1了
Dialogue: 0,0:09:30.92,0:09:32.64,Default,,0,0,0,,但现在我执行这个过程
Dialogue: 0,0:09:32.72,0:09:33.66,Default,,0,0,0,,X的值为3
Dialogue: 0,0:09:34.17,0:09:37.40,Default,,0,0,0,,COUNT变为1+COUNT 因此现在是3了
Dialogue: 0,0:09:38.08,0:09:39.62,Default,,0,0,0,,这两个相加是6
Dialogue: 0,0:09:39.62,0:09:40.94,Default,,0,0,0,,所以结果是6
Dialogue: 0,0:09:41.92,0:09:43.03,Default,,0,0,0,,我们可以发现
Dialogue: 0,0:09:43.03,0:09:44.72,Default,,0,0,0,,同样的表达式
Dialogue: 0,0:09:45.08,0:09:46.64,Default,,0,0,0,,因为时间节点的不同
Dialogue: 0,0:09:48.75,0:09:49.96,Default,,0,0,0,,得到了不同的结果
Dialogue: 0,0:09:52.08,0:09:53.74,Default,,0,0,0,,所以DEMO不是函数
Dialogue: 0,0:09:54.17,0:09:56.12,Default,,0,0,0,,或者说它并没有计算一个数学意义上的函数
Dialogue: 0,0:09:59.88,0:10:02.09,Default,,0,0,0,,事实上 你可以知道这是为什么
Dialogue: 0,0:10:02.84,0:10:06.41,Default,,0,0,0,,因为这里是第一处代换模型失效的地方
Dialogue: 0,0:10:07.72,0:10:09.55,Default,,0,0,0,,它给代换模型判了死刑
Dialogue: 0,0:10:11.28,0:10:13.82,Default,,0,0,0,,有些关于引用的一些小问题
Dialogue: 0,0:10:13.85,0:10:17.18,Default,,0,0,0,,哲学家可能注意到 特别是与代换有关时
Dialogue: 0,0:10:17.18,0:10:19.87,Default,,0,0,0,,因为当你在引用中进行代换时
Dialogue: 0,0:10:20.91,0:10:22.12,Default,,0,0,0,,需要考虑你可以得到什么样的推论
Dialogue: 0,0:10:22.34,0:10:23.92,Default,,0,0,0,,如果你能够使用代换的话
Dialogue: 0,0:10:25.08,0:10:25.60,Default,,0,0,0,,但是
Dialogue: 0,0:10:26.06,0:10:28.00,Default,,0,0,0,,在这里代换模型已经失效了
Dialogue: 0,0:10:28.11,0:10:29.40,Default,,0,0,0,,它什么也不能做了
Dialogue: 0,0:10:29.64,0:10:30.57,Default,,0,0,0,,因为
Dialogue: 0,0:10:30.57,0:10:35.85,Default,,0,0,0,,假设我想用代换模型来考虑COUNT的代换
Dialogue: 0,0:10:37.10,0:10:41.16,Default,,0,0,0,,如果我在这里和这里进行代换
Dialogue: 0,0:10:41.69,0:10:42.96,Default,,0,0,0,,它们是不同的
Dialogue: 0,0:10:44.44,0:10:45.96,Default,,0,0,0,,它不再是同一个COUNT了
Dialogue: 0,0:10:46.48,0:10:47.64,Default,,0,0,0,,我得到了错误的结果
Dialogue: 0,0:10:47.97,0:10:50.14,Default,,0,0,0,,代换模型是一个静态的现象
Dialogue: 0,0:10:51.18,0:10:52.56,Default,,0,0,0,,它描述的事实
Dialogue: 0,0:10:53.93,0:10:55.29,Default,,0,0,0,,而不是变动
Dialogue: 0,0:10:55.50,0:10:57.04,Default,,0,0,0,,这里 我们的事实变动了
Dialogue: 0,0:11:00.60,0:11:06.74,Default,,0,0,0,,那么 在我给出任何解释之前
Dialogue: 0,0:11:06.74,0:11:07.79,Default,,0,0,0,,这很糟糕
Dialogue: 0,0:11:07.79,0:11:09.72,Default,,0,0,0,,我们失去了我们的计算模型
Dialogue: 0,0:11:10.28,0:11:10.80,Default,,0,0,0,,并且
Dialogue: 0,0:11:11.48,0:11:13.69,Default,,0,0,0,,很快 我将不得不构建一个新的计算模型
Dialogue: 0,0:11:14.66,0:11:17.87,Default,,0,0,0,,我们现在的讨论 还是从一个不严谨的角度进行的
Dialogue: 0,0:11:18.56,0:11:20.16,Default,,0,0,0,,当然 你们已经看到的是
Dialogue: 0,0:11:20.51,0:11:22.70,Default,,0,0,0,,当我做一些像赋值之类的事情时
Dialogue: 0,0:11:23.12,0:11:24.51,Default,,0,0,0,,我们所需要的模型
Dialogue: 0,0:11:24.51,0:11:26.89,Default,,0,0,0,,与我们之前模型不同
Dialogue: 0,0:11:26.89,0:11:30.93,Default,,0,0,0,,在这个的模型中 像COUNT或X这样的符号
Dialogue: 0,0:11:30.93,0:11:34.07,Default,,0,0,0,,不再关联于它们的值
Dialogue: 0,0:11:34.07,0:11:37.31,Default,,0,0,0,,而是关联于某个储存这些值的地方
Dialogue: 0,0:11:37.68,0:11:39.47,Default,,0,0,0,,我们将花些时间来适应这种思想
Dialogue: 0,0:11:40.20,0:11:42.11,Default,,0,0,0,,这将是一个很糟糕的事情
Dialogue: 0,0:11:42.11,0:11:43.47,Default,,0,0,0,,并且会造成很多麻烦
Dialogue: 0,0:11:44.49,0:11:48.25,Default,,0,0,0,,所以 就像我说的 若非理由周全
Dialogue: 0,0:11:48.25,0:11:50.09,Default,,0,0,0,,不然绝不要发明这种糟糕的东西
Dialogue: 0,0:11:50.37,0:11:52.86,Default,,0,0,0,,否则 就是劳神费力
Dialogue: 0,0:11:53.39,0:11:55.55,Default,,0,0,0,,让我们看看一些可以讨论的东西
Dialogue: 0,0:11:55.88,0:11:58.59,Default,,0,0,0,,假设我们写了函数式版本的阶乘函数
Dialogue: 0,0:11:58.59,0:12:00.48,Default,,0,0,0,,我们以前的就是“函数式”风格
Dialogue: 0,0:12:01.37,0:12:04.60,Default,,0,0,0,,具有迭代计算过程的阶乘函数
Dialogue: 0,0:12:09.59,0:12:13.28,Default,,0,0,0,,N的阶乘
Dialogue: 0,0:12:18.38,0:12:24.35,Default,,0,0,0,,我们要(ITER M I)
Dialogue: 0,0:12:26.12,0:12:33.13,Default,,0,0,0,,就是说如果I大于N
Dialogue: 0,0:12:33.77,0:12:35.51,Default,,0,0,0,,则结果是M
Dialogue: 0,0:12:36.30,0:12:37.39,Default,,0,0,0,,否则
Dialogue: 0,0:12:39.79,0:12:46.82,Default,,0,0,0,,结果是(ITER (* I M))
Dialogue: 0,0:12:46.82,0:12:49.95,Default,,0,0,0,,所以M将是我累积的结果
Dialogue: 0,0:12:51.58,0:12:52.62,Default,,0,0,0,,M就是这个乘积[注：此处教授笔误]
Dialogue: 0,0:12:57.97,0:13:00.17,Default,,0,0,0,,然后我要把COUNT加1
Dialogue: 0,0:13:04.62,0:13:10.97,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,0:13:11.95,0:13:13.04,Default,,0,0,0,,我在这里启动这个内部过程
Dialogue: 0,0:13:17.16,0:13:19.79,Default,,0,0,0,,对于这种代码 我想大家早已驾轻就熟了
Dialogue: 0,0:13:20.86,0:13:25.15,Default,,0,0,0,,这里是一个累积的乘积 和一个计数器
Dialogue: 0,0:13:26.48,0:13:28.46,Default,,0,0,0,,我让它们都从1开始
Dialogue: 0,0:13:28.89,0:13:30.92,Default,,0,0,0,,我将不断让计数器增加
Dialogue: 0,0:13:30.92,0:13:33.12,Default,,0,0,0,,每一轮I变成I+1
Dialogue: 0,0:13:34.56,0:13:37.47,Default,,0,0,0,,这是我们在这个过程中设置时间的唯一方法
Dialogue: 0,0:13:38.48,0:13:40.04,Default,,0,0,0,,这些都是一系列的事实
Dialogue: 0,0:13:40.49,0:13:41.34,Default,,0,0,0,,真实的规则
Dialogue: 0,0:13:42.81,0:13:46.13,Default,,0,0,0,,M将获得一个新的值 就是I乘M
Dialogue: 0,0:13:46.13,0:13:47.82,Default,,0,0,0,,每一轮I乘以M
Dialogue: 0,0:13:48.68,0:13:50.48,Default,,0,0,0,,最终I将大于N
Dialogue: 0,0:13:50.49,0:13:52.06,Default,,0,0,0,,在这种情况下 结果就是M
Dialogue: 0,0:13:52.67,0:13:54.80,Default,,0,0,0,,我给你们讲课的时候 用到了“时间”这个概念
Dialogue: 0,0:13:55.68,0:13:57.45,Default,,0,0,0,,那是因为我知道计算机是怎么工作的
Dialogue: 0,0:13:58.25,0:13:59.24,Default,,0,0,0,,但是我没必要这么做
Dialogue: 0,0:13:59.26,0:14:02.30,Default,,0,0,0,,这完全可以有一个纯数学的解释
Dialogue: 0,0:14:02.30,0:14:03.74,Default,,0,0,0,,因为在这里代换可以工作
Dialogue: 0,0:14:05.10,0:14:08.14,Default,,0,0,0,,但是我们写一个类似的程序
Dialogue: 0,0:14:08.30,0:14:09.95,Default,,0,0,0,,使用相同的算法
Dialogue: 0,0:14:10.73,0:14:12.11,Default,,0,0,0,,但使用了赋值
Dialogue: 0,0:14:15.69,0:14:17.16,Default,,0,0,0,,所以这个叫做函数式版本
Dialogue: 0,0:14:23.72,0:14:25.56,Default,,0,0,0,,我想写个命令式的版本的
Dialogue: 0,0:14:34.48,0:14:35.39,Default,,0,0,0,,N的阶乘
Dialogue: 0,0:14:35.92,0:14:37.74,Default,,0,0,0,,我要创建两个变量
Dialogue: 0,0:14:40.16,0:14:45.53,Default,,0,0,0,,把I的值初始化为1
Dialogue: 0,0:14:46.32,0:14:49.77,Default,,0,0,0,,M也初始化为1
Dialogue: 0,0:14:51.15,0:14:52.19,Default,,0,0,0,,我们创建一个循环
Dialogue: 0,0:14:59.31,0:15:07.27,Default,,0,0,0,,如果I比N大 循环结束
Dialogue: 0,0:15:07.27,0:15:08.87,Default,,0,0,0,,结果是M
Dialogue: 0,0:15:08.87,0:15:10.38,Default,,0,0,0,,也就是我累积的乘积
Dialogue: 0,0:15:10.87,0:15:11.77,Default,,0,0,0,,否则
Dialogue: 0,0:15:15.52,0:15:17.40,Default,,0,0,0,,我接下来要做三件事
Dialogue: 0,0:15:19.26,0:15:27.05,Default,,0,0,0,,我要把M赋值为I*M
Dialogue: 0,0:15:29.36,0:15:35.20,Default,,0,0,0,,把I赋值为I+1
Dialogue: 0,0:15:37.85,0:15:39.31,Default,,0,0,0,,然后继续循环
Dialogue: 0,0:15:40.41,0:15:43.02,Default,,0,0,0,,你们中的FORTRAN程序员应该觉得眼熟
Dialogue: 0,0:15:44.73,0:15:46.64,Default,,0,0,0,,（闭合括号中）
Dialogue: 0,0:15:46.64,0:15:47.88,Default,,0,0,0,,就是这种语法有点陌生
Dialogue: 0,0:15:51.13,0:15:52.27,Default,,0,0,0,,启动循环
Dialogue: 0,0:15:56.10,0:15:57.56,Default,,0,0,0,,程序就写完了
Dialogue: 0,0:15:59.15,0:16:00.52,Default,,0,0,0,,那么 这个程序
Dialogue: 0,0:16:01.31,0:16:02.49,Default,,0,0,0,,我们应该怎么思考它呢？
Dialogue: 0,0:16:02.71,0:16:04.25,Default,,0,0,0,,先来看看这里是什么
Dialogue: 0,0:16:04.84,0:16:07.47,Default,,0,0,0,,这里有两个局部变量 I和M
Dialogue: 0,0:16:07.47,0:16:09.02,Default,,0,0,0,,它们都被初始化为1
Dialogue: 0,0:16:10.72,0:16:13.89,Default,,0,0,0,,在每一次循环里 我检测I是否大于N
Dialogue: 0,0:16:13.89,0:16:15.08,Default,,0,0,0,,就是我们传入的参数
Dialogue: 0,0:16:15.30,0:16:18.14,Default,,0,0,0,,如果成立的话 结果就是M中所累积的乘积
Dialogue: 0,0:16:19.16,0:16:21.21,Default,,0,0,0,,然而 如果循环没有结束
Dialogue: 0,0:16:21.21,0:16:22.89,Default,,0,0,0,,如果我们的工作没有结束
Dialogue: 0,0:16:23.64,0:16:25.55,Default,,0,0,0,,则我们要把乘积
Dialogue: 0,0:16:25.84,0:16:28.38,Default,,0,0,0,,变为i与当前乘积的结果
Dialogue: 0,0:16:29.04,0:16:30.68,Default,,0,0,0,,就是我们在这里做过的事情
Dialogue: 0,0:16:31.42,0:16:32.68,Default,,0,0,0,,除了这里我没有改动
Dialogue: 0,0:16:33.63,0:16:35.77,Default,,0,0,0,,我创建了一个复本
Dialogue: 0,0:16:36.81,0:16:42.04,Default,,0,0,0,,因为代换模型就是你复制过程的体
Dialogue: 0,0:16:43.08,0:16:45.88,Default,,0,0,0,,并用实际参数代换形式参数
Dialogue: 0,0:16:46.72,0:16:48.42,Default,,0,0,0,,这里 我考虑的不是副本
Dialogue: 0,0:16:48.42,0:16:50.52,Default,,0,0,0,,在这里 我已经改变了M的值
Dialogue: 0,0:16:51.80,0:16:55.12,Default,,0,0,0,,我也把I的值变成了I+1
Dialogue: 0,0:16:55.61,0:16:56.96,Default,,0,0,0,,然后继续循环
Dialogue: 0,0:16:58.22,0:17:00.08,Default,,0,0,0,,看起来是一样的程序
Dialogue: 0,0:17:00.96,0:17:02.84,Default,,0,0,0,,在今天引入赋值之后
Dialogue: 0,0:17:02.84,0:17:05.50,Default,,0,0,0,,我们在这里有很多种方式犯错
Dialogue: 0,0:17:06.14,0:17:07.02,Default,,0,0,0,,例如
Dialogue: 0,0:17:07.45,0:17:09.40,Default,,0,0,0,,如果我在赋值的时候
Dialogue: 0,0:17:10.04,0:17:12.14,Default,,0,0,0,,没有小心地写程序
Dialogue: 0,0:17:12.64,0:17:16.08,Default,,0,0,0,,把两个赋值的顺序调换了
Dialogue: 0,0:17:17.10,0:17:18.91,Default,,0,0,0,,程序计算的就不是相同的函数了
Dialogue: 0,0:17:20.33,0:17:22.87,Default,,0,0,0,,我得到了一个时间错误 因为这儿有个依赖关系
Dialogue: 0,0:17:22.87,0:17:27.22,Default,,0,0,0,,因为M依赖于I上一次的值
Dialogue: 0,0:17:27.34,0:17:28.92,Default,,0,0,0,,如果我先改变I的值
Dialogue: 0,0:17:31.31,0:17:33.77,Default,,0,0,0,,就会在乘以M的时候 得到错误的I值
Dialogue: 0,0:17:35.96,0:17:38.38,Default,,0,0,0,,没有赋值的话不会存在这样的BUG
Dialogue: 0,0:17:38.38,0:17:40.59,Default,,0,0,0,,这是由于我们引入了某些包含时间的东西造成的
Dialogue: 0,0:17:43.44,0:17:44.30,Default,,0,0,0,,如我所说的
Dialogue: 0,0:17:45.53,0:17:47.39,Default,,0,0,0,,首先 我们需要一个新的计算模型
Dialogue: 0,0:17:47.39,0:17:50.86,Default,,0,0,0,,然后 需要有一个非常好的理由来支持我们做如此丑陋的事
Dialogue: 0,0:17:52.72,0:17:53.74,Default,,0,0,0,,有什么问题吗？
Dialogue: 0,0:17:58.83,0:18:00.22,Default,,0,0,0,,David 大点儿声说
Dialogue: 0,0:18:00.40,0:18:03.47,Default,,0,0,0,,学生：现在 我们引入了SET!
Dialogue: 0,0:18:03.90,0:18:06.36,Default,,0,0,0,,但是之前我们已经有LET和DEFINE了
Dialogue: 0,0:18:06.89,0:18:09.70,Default,,0,0,0,,我不太清楚它们的区别
Dialogue: 0,0:18:09.70,0:18:13.25,Default,,0,0,0,,DEFINE不能像SET!一样用吗？
Dialogue: 0,0:18:13.98,0:18:14.83,Default,,0,0,0,,请详细讲讲
Dialogue: 0,0:18:14.83,0:18:19.31,Default,,0,0,0,,教授：不 DEFINE用于创建并初始化
Dialogue: 0,0:18:19.31,0:18:21.36,Default,,0,0,0,,为了创建它
Dialogue: 0,0:18:22.08,0:18:24.70,Default,,0,0,0,,你永远也不会见到我在黑板上
Dialogue: 0,0:18:25.60,0:18:26.94,Default,,0,0,0,,在同一行写两个DEFINE
Dialogue: 0,0:18:27.08,0:18:32.08,Default,,0,0,0,,只是为了让某个变量的旧值变成一个新的值
Dialogue: 0,0:18:32.08,0:18:34.51,Default,,0,0,0,,学生：这是一个约定俗成的规矩 还是--
Dialogue: 0,0:18:34.51,0:18:36.35,Default,,0,0,0,,教授：不 这是有意为之的
Dialogue: 0,0:18:36.35,0:18:38.92,Default,,0,0,0,,答案是
Dialogue: 0,0:18:39.69,0:18:40.84,Default,,0,0,0,,举个例子
Dialogue: 0,0:18:40.84,0:18:42.27,Default,,0,0,0,,在一个过程内部
Dialogue: 0,0:18:43.20,0:18:45.92,Default,,0,0,0,,两个DEFINE写在一行里是非法的
Dialogue: 0,0:18:46.68,0:18:48.57,Default,,0,0,0,,对于同一个变量DEFINE两次是非法的
Dialogue: 0,0:18:50.24,0:18:51.74,Default,,0,0,0,,X不能被DEFINE两次
Dialogue: 0,0:18:51.74,0:18:55.20,Default,,0,0,0,,而系统会不会捕获这个错误 就是另一个问题了
Dialogue: 0,0:18:55.93,0:18:57.88,Default,,0,0,0,,但是我定下规矩
Dialogue: 0,0:18:58.12,0:19:00.64,Default,,0,0,0,,任何东西都只能DEFINE一次
Dialogue: 0,0:19:00.73,0:19:02.64,Default,,0,0,0,,确实 在交互式调试中
Dialogue: 0,0:19:03.37,0:19:07.48,Default,,0,0,0,,我们打算让你与计算机交互时可以重新DEFINE一些东西
Dialogue: 0,0:19:08.19,0:19:11.21,Default,,0,0,0,,所以交互式调试时产生的是一个特殊的异常
Dialogue: 0,0:19:11.82,0:19:16.48,Default,,0,0,0,,但是DEFINE的意思是建立某些东西
Dialogue: 0,0:19:18.14,0:19:20.96,Default,,0,0,0,,在那个时间点后 它的值是永远不变的
Dialogue: 0,0:19:22.05,0:19:24.54,Default,,0,0,0,,好像所有的DEFINE都是在最开始完成的
Dialogue: 0,0:19:26.09,0:19:30.92,Default,,0,0,0,,事实上 在Scheme过程中 DEFINE的唯一合法使用地方
Dialogue: 0,0:19:31.02,0:19:33.36,Default,,0,0,0,,就是在LAMBDA表达式的开始
Dialogue: 0,0:19:34.47,0:19:37.66,Default,,0,0,0,,也就是过程体的开始
Dialogue: 0,0:19:40.40,0:19:45.80,Default,,0,0,0,,LET当然与那个不一样
Dialogue: 0,0:19:48.09,0:19:49.55,Default,,0,0,0,,如果你想知道LET发生了什么
Dialogue: 0,0:19:50.17,0:19:52.13,Default,,0,0,0,,LET只会绑定一次
Dialogue: 0,0:19:52.13,0:19:55.82,Default,,0,0,0,,它建立了一个I和M的值分别为1的上下文
Dialogue: 0,0:19:56.83,0:20:00.57,Default,,0,0,0,,这个上下文存在于整个作用域中
Dialogue: 0,0:20:01.31,0:20:02.80,Default,,0,0,0,,也就是这个程序范围
Dialogue: 0,0:20:04.99,0:20:10.12,Default,,0,0,0,,然而 你不会认为LET再次设置了I的值
Dialogue: 0,0:20:11.04,0:20:12.16,Default,,0,0,0,,它没有改变I的值
Dialogue: 0,0:20:12.16,0:20:14.01,Default,,0,0,0,,因为LET的作用 I将永远不会变化
Dialogue: 0,0:20:15.28,0:20:16.81,Default,,0,0,0,,因为LET的作用 I才被创建
Dialogue: 0,0:20:18.51,0:20:19.29,Default,,0,0,0,,实际上
Dialogue: 0,0:20:19.73,0:20:21.42,Default,,0,0,0,,LET是一个非常简单的想法
Dialogue: 0,0:20:22.24,0:20:23.59,Default,,0,0,0,,LET不会做别的事情
Dialogue: 0,0:20:23.59,0:20:31.62,Default,,0,0,0,,LET的语义是……
Dialogue: 0,0:20:31.62,0:20:33.50,Default,,0,0,0,,我把它写得更准确点
Dialogue: 0,0:20:37.16,0:20:43.73,Default,,0,0,0,,表达式 (var1 e1)
Dialogue: 0,0:20:43.73,0:20:47.36,Default,,0,0,0,,还有(var2 e2)
Dialogue: 0,0:20:48.14,0:20:49.74,Default,,0,0,0,,在表达式e3中
Dialogue: 0,0:20:51.60,0:21:05.80,Default,,0,0,0,,与一个以var1和var2为形式参数的过程一样
Dialogue: 0,0:21:06.94,0:21:08.96,Default,,0,0,0,,e3成为过程的体
Dialogue: 0,0:21:10.91,0:21:14.00,Default,,0,0,0,,在这里 var1与e1的值绑定
Dialogue: 0,0:21:14.27,0:21:16.91,Default,,0,0,0,,var2与e2的值绑定
Dialogue: 0,0:21:19.53,0:21:23.26,Default,,0,0,0,,所以实际上 这是一个从代换的角度来看很容易理解的东西
Dialogue: 0,0:21:24.89,0:21:27.95,Default,,0,0,0,,其实就是同一个表达式的两种不同的写法
Dialogue: 0,0:21:31.69,0:21:33.50,Default,,0,0,0,,事实上 系统真正的工作方式
Dialogue: 0,0:21:33.63,0:21:35.82,Default,,0,0,0,,就是在运行之前把代码翻译成这种形式
Dialogue: 0,0:21:37.64,0:21:41.77,Default,,0,0,0,,学生：我还是不清楚是什么造成了LET和DEFINE之间的区别
Dialogue: 0,0:21:41.77,0:21:44.30,Default,,0,0,0,,教授：DEFINE就是个语法糖
Dialogue: 0,0:21:44.62,0:21:49.10,Default,,0,0,0,,本质上来说 是通过LET创建一系列变量 然后给它们一次性赋值
Dialogue: 0,0:21:57.10,0:21:59.74,Default,,0,0,0,,好吧 我们休息一会
Dialogue: 0,0:22:02.52,0:22:12.84,Default,,0,0,0,,[音乐]
Dialogue: 0,0:22:12.84,0:22:17.84,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:22:48.81,0:22:52.67,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:22:52.67,0:22:56.52,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:22:56.52,0:23:00.59,Declare,,0,0,0,,{\an2\fad(500,500)}赋值、状态和副作用
Dialogue: 0,0:23:04.28,0:23:06.11,Default,,0,0,0,,看
Dialogue: 0,0:23:06.44,0:23:09.08,Default,,0,0,0,,现在 我不得不重建计算模型
Dialogue: 0,0:23:09.77,0:23:14.16,Default,,0,0,0,,使得你能够明白那些机制是如何运作的
Dialogue: 0,0:23:14.91,0:23:16.46,Default,,0,0,0,,来完成我们刚才说的那些工作
Dialogue: 0,0:23:17.53,0:23:21.39,Default,,0,0,0,,我刚刚摧毁了你们的代换模型
Dialogue: 0,0:23:22.62,0:23:26.03,Default,,0,0,0,,不幸的是 这个模型比代换模型要复杂得多
Dialogue: 0,0:23:26.62,0:23:27.93,Default,,0,0,0,,这个模型叫环境模型
Dialogue: 0,0:23:29.02,0:23:31.20,Default,,0,0,0,,我即将介绍一些术语
Dialogue: 0,0:23:32.03,0:23:34.51,Default,,0,0,0,,无论如何 你知道这些术语都是很好的
Dialogue: 0,0:23:34.51,0:23:35.74,Default,,0,0,0,,它是关于名字的
Dialogue: 0,0:23:36.51,0:23:39.63,Default,,0,0,0,,我们要给事物的各种名字
Dialogue: 0,0:23:40.00,0:23:41.31,Default,,0,0,0,,和名字的使用途径以名字
Dialogue: 0,0:23:42.48,0:23:47.94,Default,,0,0,0,,如果硬要说的话 这是一个元描述
Dialogue: 0,0:23:48.56,0:23:50.85,Default,,0,0,0,,总之 这里面有一堆糟糕的术语
Dialogue: 0,0:23:50.85,0:23:53.76,Default,,0,0,0,,但我们需要利用它们来理解所谓的“环境模型”
Dialogue: 0,0:23:54.70,0:23:57.53,Default,,0,0,0,,我们可能要做一点无聊的事情了
Dialogue: 0,0:23:58.04,0:24:01.58,Default,,0,0,0,,我们来看第一张张幻灯片
Dialogue: 0,0:24:02.25,0:24:06.97,Default,,0,0,0,,我们看到了术语“约束”的解释
Dialogue: 0,0:24:08.80,0:24:11.00,Default,,0,0,0,,我们会说一个变量V
Dialogue: 0,0:24:11.00,0:24:12.91,Default,,0,0,0,,被约束在表达式E中
Dialogue: 0,0:24:13.41,0:24:21.52,Default,,0,0,0,,如果用一个没有出现在E中的变量W 对变量V统一换名
Dialogue: 0,0:24:21.56,0:24:24.28,Default,,0,0,0,,表达式语义没有发生改变
Dialogue: 0,0:24:25.69,0:24:27.00,Default,,0,0,0,,这个解释很长
Dialogue: 0,0:24:27.37,0:24:29.96,Default,,0,0,0,,在我们在被搞糊涂之前
Dialogue: 0,0:24:29.98,0:24:32.62,Default,,0,0,0,,我应该再多解释下
Dialogue: 0,0:24:33.42,0:24:35.28,Default,,0,0,0,,我们这里讨论的约束变量
Dialogue: 0,0:24:44.16,0:24:45.56,Default,,0,0,0,,你们已经看到它们很多次了
Dialogue: 0,0:24:46.07,0:24:48.17,Default,,0,0,0,,只是你们可能还没意识到
Dialogue: 0,0:24:48.24,0:24:52.24,Default,,0,0,0,,在逻辑学中 你们看到一个逻辑变量
Dialogue: 0,0:24:53.27,0:25:00.11,Default,,0,0,0,,就像微积分课上的 对于任意任何X 存在一个Y 使得P为真
Dialogue: 0,0:25:02.88,0:25:05.82,Default,,0,0,0,,这个变量X 这个变量Y 它们是约束变量
Dialogue: 0,0:25:07.08,0:25:07.92,Default,,0,0,0,,因为
Dialogue: 0,0:25:08.33,0:25:09.98,Default,,0,0,0,,这个表达式的含义
Dialogue: 0,0:25:09.98,0:25:15.61,Default,,0,0,0,,不取决于我用来描述X和Y的具体字母
Dialogue: 0,0:25:16.49,0:25:19.18,Default,,0,0,0,,如果我用W替换X
Dialogue: 0,0:25:19.84,0:25:25.68,Default,,0,0,0,,则可以说对于任意W 存在一个Y使得P为真
Dialogue: 0,0:25:25.98,0:25:27.08,Default,,0,0,0,,它们其实是同一句话
Dialogue: 0,0:25:29.44,0:25:30.34,Default,,0,0,0,,就是这个意思
Dialogue: 0,0:25:30.34,0:25:34.89,Default,,0,0,0,,又或者说 你们看到这样一个积分
Dialogue: 0,0:25:35.40,0:25:42.65,Default,,0,0,0,,对dx/(1+x^2)从0到1积分
Dialogue: 0,0:25:46.03,0:25:47.92,Default,,0,0,0,,这就是你们经常见到的那种东西
Dialogue: 0,0:25:47.92,0:25:50.92,Default,,0,0,0,,这个x是一个约束变量
Dialogue: 0,0:25:52.06,0:25:53.79,Default,,0,0,0,,如果我把它换成t
Dialogue: 0,0:25:54.15,0:25:56.25,Default,,0,0,0,,这个表达式其实没有变化
Dialogue: 0,0:25:58.06,0:26:02.76,Default,,0,0,0,,就是arctan(1)/4之类的
Dialogue: 0,0:26:04.70,0:26:06.01,Default,,0,0,0,,是的 就是arctan(1)
Dialogue: 0,0:26:06.62,0:26:08.76,Default,,0,0,0,,所以约束变量事实上很常见
Dialogue: 0,0:26:09.08,0:26:12.36,Default,,0,0,0,,如果你们接触过一些数学的话
Dialogue: 0,0:26:13.26,0:26:17.47,Default,,0,0,0,,好 让我们来到编程的世界
Dialogue: 0,0:26:19.02,0:26:21.36,Default,,0,0,0,,现在量词不再是
Dialogue: 0,0:26:22.03,0:26:24.06,Default,,0,0,0,,所有、存在和积分
Dialogue: 0,0:26:24.06,0:26:26.43,Default,,0,0,0,,我们有一个符号作为量词 用于约束变量
Dialogue: 0,0:26:27.47,0:26:28.99,Default,,0,0,0,,我们要使用量词LAMBDA
Dialogue: 0,0:26:29.79,0:26:31.80,Default,,0,0,0,,作为约束变量的一个必要的东西
Dialogue: 0,0:26:33.80,0:26:36.12,Default,,0,0,0,,我们有一个极好的例子
Dialogue: 0,0:26:36.59,0:26:44.14,Default,,0,0,0,,对于以Y为参数的过程 做了以下的事情
Dialogue: 0,0:26:44.14,0:26:46.96,Default,,0,0,0,,它调用一个含单个参数X的过程
Dialogue: 0,0:26:47.87,0:26:51.13,Default,,0,0,0,,该过程 将X乘以Y
Dialogue: 0,0:26:52.88,0:26:54.52,Default,,0,0,0,,并应用于3
Dialogue: 0,0:26:58.76,0:27:01.66,Default,,0,0,0,,这个过程中包含两个约束变量
Dialogue: 0,0:27:02.01,0:27:02.92,Default,,0,0,0,,X和Y
Dialogue: 0,0:27:04.83,0:27:07.47,Default,,0,0,0,,这个LAMBDA量词 约束了这个Y
Dialogue: 0,0:27:07.91,0:27:10.78,Default,,0,0,0,,这个LAMBDA量词 约束了这个X
Dialogue: 0,0:27:12.11,0:27:17.05,Default,,0,0,0,,因为 如果我用了一个没有出现在表达式中的任意符号 如W
Dialogue: 0,0:27:17.98,0:27:21.04,Default,,0,0,0,,用W替换表达式中的所有Y
Dialogue: 0,0:27:21.36,0:27:22.75,Default,,0,0,0,,这个表达式仍与原来的相同
Dialogue: 0,0:27:23.66,0:27:24.80,Default,,0,0,0,,是相同的过程
Dialogue: 0,0:27:26.22,0:27:27.41,Default,,0,0,0,,这是一个重要的想法
Dialogue: 0,0:27:27.41,0:27:29.64,Default,,0,0,0,,我们有这种东西的原因
Dialogue: 0,0:27:30.20,0:27:31.41,Default,,0,0,0,,这是一种模块性
Dialogue: 0,0:27:31.41,0:27:32.86,Default,,0,0,0,,如果有两个人写程序
Dialogue: 0,0:27:34.03,0:27:35.26,Default,,0,0,0,,并且他们在合作编程
Dialogue: 0,0:27:35.26,0:27:40.56,Default,,0,0,0,,在他们自己构建的小项目里用什么命名都没有关系
Dialogue: 0,0:27:42.83,0:27:44.67,Default,,0,0,0,,所以 实际上我想告诉你们
Dialogue: 0,0:27:45.44,0:27:46.75,Default,,0,0,0,,例如
Dialogue: 0,0:27:46.84,0:27:51.26,Default,,0,0,0,,这个表达式等于 以Y为参数的过程
Dialogue: 0,0:27:52.35,0:27:59.23,Default,,0,0,0,,使用这个对于一个参数Z的过程 这个过程将Z乘以Y
Dialogue: 0,0:28:01.64,0:28:03.53,Default,,0,0,0,,因为没人关心我在这用什么
Dialogue: 0,0:28:06.36,0:28:07.24,Default,,0,0,0,,这是一个极好的例子
Dialogue: 0,0:28:08.84,0:28:09.85,Default,,0,0,0,,另一方面
Dialogue: 0,0:28:11.07,0:28:14.33,Default,,0,0,0,,我有一些未被约束的变量
Dialogue: 0,0:28:15.23,0:28:15.96,Default,,0,0,0,,举个例子
Dialogue: 0,0:28:20.27,0:28:21.76,Default,,0,0,0,,这个对于一个以X为参数的过程
Dialogue: 0,0:28:22.09,0:28:25.04,Default,,0,0,0,,将X乘以Y
Dialogue: 0,0:28:27.28,0:28:28.16,Default,,0,0,0,,在这个例子中
Dialogue: 0,0:28:29.45,0:28:30.75,Default,,0,0,0,,y没有被约束
Dialogue: 0,0:28:32.46,0:28:34.27,Default,,0,0,0,,假设Y的值是3
Dialogue: 0,0:28:35.26,0:28:36.80,Default,,0,0,0,,Z的值是4
Dialogue: 0,0:28:38.83,0:28:44.27,Default,,0,0,0,,那么这个过程就是把它的参数乘以3
Dialogue: 0,0:28:44.86,0:28:47.39,Default,,0,0,0,,如果我把所有的y都用z来代替
Dialogue: 0,0:28:47.52,0:28:51.96,Default,,0,0,0,,我将得到一个完全不同的过程 它会把参数乘以4
Dialogue: 0,0:28:53.87,0:28:56.40,Default,,0,0,0,,事实上 我们给这类变量取了个名字
Dialogue: 0,0:28:57.76,0:29:04.01,Default,,0,0,0,,我们把表达式E中的变量V叫做自由变量
Dialogue: 0,0:29:04.01,0:29:09.42,Default,,0,0,0,,如果用没有出现在E中的变量W统一替换E中所有的V
Dialogue: 0,0:29:09.58,0:29:11.15,Default,,0,0,0,,使得表达式E的含义发生了改变
Dialogue: 0,0:29:13.26,0:29:13.71,Default,,0,0,0,,所以
Dialogue: 0,0:29:14.49,0:29:22.76,Default,,0,0,0,,所以这就是为什么这个变量Y 是一个自由变量
Dialogue: 0,0:29:29.16,0:29:32.27,Default,,0,0,0,,所以 这个表达式里的自由变量
Dialogue: 0,0:29:33.76,0:29:35.18,Default,,0,0,0,,另一个例子是
Dialogue: 0,0:29:36.17,0:29:39.32,Default,,0,0,0,,对于一个以Y为参数的过程
Dialogue: 0,0:29:40.43,0:29:42.00,Default,,0,0,0,,就像我们之前的那个一样
Dialogue: 0,0:29:42.27,0:29:44.60,Default,,0,0,0,,调用以X为参数的过程
Dialogue: 0,0:29:45.08,0:29:48.54,Default,,0,0,0,,将X与Y相乘--
Dialogue: 0,0:29:51.40,0:29:52.65,Default,,0,0,0,,并应用于3
Dialogue: 0,0:29:57.24,0:30:00.35,Default,,0,0,0,,这个过程中有一个自由变量
Dialogue: 0,0:30:00.92,0:30:01.98,Default,,0,0,0,,也就是这个星号
Dialogue: 0,0:30:05.00,0:30:05.89,Default,,0,0,0,,因为
Dialogue: 0,0:30:05.89,0:30:08.08,Default,,0,0,0,,如果它表示正常意义的乘法
Dialogue: 0,0:30:09.44,0:30:12.78,Default,,0,0,0,,如果我统一地用加号来代替星号
Dialogue: 0,0:30:14.25,0:30:16.38,Default,,0,0,0,,这个表达式的含义就变了
Dialogue: 0,0:30:19.34,0:30:20.76,Default,,0,0,0,,这就是自由变量的意思
Dialogue: 0,0:30:22.68,0:30:24.81,Default,,0,0,0,,现在 你们已经学到了一些逻辑学术语
Dialogue: 0,0:30:25.64,0:30:27.58,Default,,0,0,0,,用它们可以解释名字的用法
Dialogue: 0,0:30:28.94,0:30:31.26,Default,,0,0,0,,我们要需要更进一步深入
Dialogue: 0,0:30:32.96,0:30:33.72,Default,,0,0,0,,再多了解一些
Dialogue: 0,0:30:35.13,0:30:36.22,Default,,0,0,0,,我想给你们讲讲
Dialogue: 0,0:30:36.81,0:30:39.76,Default,,0,0,0,,变量被定义的区域
Dialogue: 0,0:30:42.17,0:30:42.88,Default,,0,0,0,,你瞧
Dialogue: 0,0:30:43.37,0:30:45.69,Default,,0,0,0,,目前为止 我们已经相当不正式了
Dialogue: 0,0:30:46.33,0:30:50.16,Default,,0,0,0,,当然 你们中的一些 或者大部分人可能已经理解得很透彻了
Dialogue: 0,0:30:50.36,0:30:52.84,Default,,0,0,0,,在这里被声明的X
Dialogue: 0,0:30:53.64,0:30:55.18,Default,,0,0,0,,只被定义在这里
Dialogue: 0,0:30:58.28,0:31:00.91,Default,,0,0,0,,这个X 只被定义在这里
Dialogue: 0,0:31:01.61,0:31:04.33,Default,,0,0,0,,这个Y 只被定义在这里
Dialogue: 0,0:31:07.10,0:31:09.16,Default,,0,0,0,,我们给这个概念取了个名字 叫“作用域”
Dialogue: 0,0:31:11.61,0:31:13.58,Default,,0,0,0,,我给你们再讲个术语
Dialogue: 0,0:31:14.70,0:31:15.77,Default,,0,0,0,,这个就比较复杂
Dialogue: 0,0:31:15.96,0:31:17.64,Default,,0,0,0,,如果X是E中的一个约束变量
Dialogue: 0,0:31:18.16,0:31:20.24,Default,,0,0,0,,那么它是约束于一个LAMBDA表达式中
Dialogue: 0,0:31:20.89,0:31:24.91,Default,,0,0,0,,LAMBDA表达式是约束变量的唯一方式
Dialogue: 0,0:31:24.91,0:31:25.96,Default,,0,0,0,,你可能会担心
Dialogue: 0,0:31:26.22,0:31:29.05,Default,,0,0,0,,DEFINE是它的一个例外吗？
Dialogue: 0,0:31:29.64,0:31:32.92,Default,,0,0,0,,事实证明 通过巧妙安排 我们可以避免使用DEFINE
Dialogue: 0,0:31:32.92,0:31:33.96,Default,,0,0,0,,一会我们就能看到了
Dialogue: 0,0:31:34.24,0:31:35.72,Default,,0,0,0,,它一个非常神奇的东西
Dialogue: 0,0:31:36.54,0:31:38.40,Default,,0,0,0,,所以我们完全不需要DEFINE
Dialogue: 0,0:31:38.68,0:31:41.55,Default,,0,0,0,,实际上 唯一能创建名字的东西是LAMBDA
Dialogue: 0,0:31:42.64,0:31:43.40,Default,,0,0,0,,这就是它的职责
Dialogue: 0,0:31:44.30,0:31:46.23,Default,,0,0,0,,多么的令人惊奇
Dialogue: 0,0:31:46.23,0:31:47.87,Default,,0,0,0,,很多东西你只凭借LAMBDA就可以计算
Dialogue: 0,0:31:48.73,0:31:49.58,Default,,0,0,0,,但是 在任何情况下
Dialogue: 0,0:31:51.74,0:31:55.76,Default,,0,0,0,,一个LAMBDA表达式有一个地方来声明变量
Dialogue: 0,0:31:55.76,0:31:57.10,Default,,0,0,0,,我们把它称为形式参数表
Dialogue: 0,0:31:58.94,0:32:00.56,Default,,0,0,0,,或者叫 约束变量表
Dialogue: 0,0:32:01.26,0:32:04.51,Default,,0,0,0,,我们说LAMBDA表达式约束了--这是一个动词
Dialogue: 0,0:32:05.02,0:32:07.34,Default,,0,0,0,,--约束了在约束变量表里声明的变量
Dialogue: 0,0:32:08.59,0:32:12.48,Default,,0,0,0,,另外 表达式中定义变量的那些部分
Dialogue: 0,0:32:13.23,0:32:15.23,Default,,0,0,0,,是被一些声明所声明的
Dialogue: 0,0:32:15.56,0:32:19.26,Default,,0,0,0,,这些部分被叫做变量的作用域
Dialogue: 0,0:32:20.44,0:32:21.92,Default,,0,0,0,,所以 这些是作用域
Dialogue: 0,0:32:22.25,0:32:23.68,Default,,0,0,0,,这是Y的作用域
Dialogue: 0,0:32:27.16,0:32:28.54,Default,,0,0,0,,这是X的作用域--
Dialogue: 0,0:32:33.10,0:32:34.03,Default,,0,0,0,,以此类推
Dialogue: 0,0:32:41.32,0:32:42.08,Default,,0,0,0,,好
Dialogue: 0,0:32:43.93,0:32:45.63,Default,,0,0,0,,现在我们有了足够多的术语
Dialogue: 0,0:32:46.60,0:32:51.76,Default,,0,0,0,,可以开始理解如何建立一个新的计算模型了
Dialogue: 0,0:32:51.96,0:32:53.77,Default,,0,0,0,,因为 这里很重要的一点是
Dialogue: 0,0:32:54.94,0:32:57.00,Default,,0,0,0,,我们摧毁了代换模型
Dialogue: 0,0:32:57.18,0:32:58.38,Default,,0,0,0,,我们现在不得不需要一个模型
Dialogue: 0,0:32:58.62,0:33:02.32,Default,,0,0,0,,来体现表示名字被关联到某些地方
Dialogue: 0,0:33:03.93,0:33:05.34,Default,,0,0,0,,因为 如果我们要改变某个东西
Dialogue: 0,0:33:05.98,0:33:07.47,Default,,0,0,0,,我们就需要一个存它的地方
Dialogue: 0,0:33:09.56,0:33:10.35,Default,,0,0,0,,请想一想
Dialogue: 0,0:33:10.83,0:33:13.31,Default,,0,0,0,,如果一个名字只是关联于一个值
Dialogue: 0,0:33:14.04,0:33:16.36,Default,,0,0,0,,如果我试图改变这个名字的含义
Dialogue: 0,0:33:16.73,0:33:20.32,Default,,0,0,0,,这不怎么明确
Dialogue: 0,0:33:20.32,0:33:24.68,Default,,0,0,0,,因为没有名字可以关联的地方
Dialogue: 0,0:33:24.99,0:33:25.80,Default,,0,0,0,,该怎么解释呢……
Dialogue: 0,0:33:25.92,0:33:29.54,Default,,0,0,0,,也就是名字的所有实例之间没有共享任何东西
Dialogue: 0,0:33:29.87,0:33:31.68,Default,,0,0,0,,也就是说 对于一个名字
Dialogue: 0,0:33:31.68,0:33:32.97,Default,,0,0,0,,是用来让我们找到某些东西的
Dialogue: 0,0:33:34.33,0:33:36.36,Default,,0,0,0,,我们把名字给某个东西 然后你拿到了它
Dialogue: 0,0:33:36.73,0:33:39.06,Default,,0,0,0,,你能得到它 是因为我给了你一个它的引用
Dialogue: 0,0:33:39.06,0:33:40.44,Default,,0,0,0,,我把对它的引用给了你
Dialogue: 0,0:33:41.02,0:33:42.30,Default,,0,0,0,,我们会看到很多相关的例子
Dialogue: 0,0:33:43.61,0:33:45.21,Default,,0,0,0,,让我们继续学习“环境”
Dialogue: 0,0:33:46.19,0:33:48.76,Default,,0,0,0,,我需要用一下头顶上的投影仪
Dialogue: 0,0:33:49.31,0:33:49.98,Default,,0,0,0,,谢谢你
Dialogue: 0,0:33:52.19,0:33:53.02,Default,,0,0,0,,这里
Dialogue: 0,0:33:55.48,0:34:00.40,Default,,0,0,0,,是一堆环境结构
Dialogue: 0,0:34:01.53,0:34:05.76,Default,,0,0,0,,环境就是执行虚拟的代换的一种方法
Dialogue: 0,0:34:06.38,0:34:07.89,Default,,0,0,0,,它代表了一个地方
Dialogue: 0,0:34:07.89,0:34:11.39,Default,,0,0,0,,是存储你的未完成的代换的地方
Dialogue: 0,0:34:13.34,0:34:16.50,Default,,0,0,0,,它是一个积累各种东西的地方
Dialogue: 0,0:34:16.50,0:34:21.13,Default,,0,0,0,,在那里 变量的名字与值关联在一起
Dialogue: 0,0:34:21.79,0:34:22.56,Default,,0,0,0,,使得
Dialogue: 0,0:34:22.75,0:34:25.90,Default,,0,0,0,,当你问某个名字是什么意思的时候
Dialogue: 0,0:34:25.90,0:34:27.40,Default,,0,0,0,,你要在一个环境中寻找答案
Dialogue: 0,0:34:28.08,0:34:29.48,Default,,0,0,0,,所以环境是一个函数
Dialogue: 0,0:34:30.80,0:34:31.48,Default,,0,0,0,,或一张表
Dialogue: 0,0:34:32.22,0:34:33.24,Default,,0,0,0,,或类似的东西
Dialogue: 0,0:34:33.24,0:34:34.89,Default,,0,0,0,,但它是一种结构化的表
Dialogue: 0,0:34:35.76,0:34:37.39,Default,,0,0,0,,它是由框架构成
Dialogue: 0,0:34:41.13,0:34:44.46,Default,,0,0,0,,框架是环境的一部分
Dialogue: 0,0:34:44.89,0:34:46.01,Default,,0,0,0,,它们被链接在一起
Dialogue: 0,0:34:47.07,0:34:48.19,Default,,0,0,0,,以某种很好的方式
Dialogue: 0,0:34:49.00,0:34:52.09,Default,,0,0,0,,用一种叫做父链接之类的东西
Dialogue: 0,0:34:54.03,0:34:55.02,Default,,0,0,0,,这里
Dialogue: 0,0:34:55.64,0:34:57.62,Default,,0,0,0,,有一个环境结构
Dialogue: 0,0:34:57.62,0:35:04.22,Default,,0,0,0,,它由三个环境组成 分别是A B和C
Dialogue: 0,0:35:05.10,0:35:07.63,Default,,0,0,0,,D也是环境 但它和C是一样的
Dialogue: 0,0:35:08.88,0:35:10.17,Default,,0,0,0,,它们共享了同一个环境
Dialogue: 0,0:35:11.45,0:35:13.96,Default,,0,0,0,,那就是赋值的本质所在
Dialogue: 0,0:35:14.40,0:35:16.10,Default,,0,0,0,,如果我改变了一个变量
Dialogue: 0,0:35:16.10,0:35:19.80,Default,,0,0,0,,比如改变这个变量的值
Dialogue: 0,0:35:19.80,0:35:23.50,Default,,0,0,0,,那么它将在所有地方都可见
Dialogue: 0,0:35:23.50,0:35:24.84,Default,,0,0,0,,用x来举例
Dialogue: 0,0:35:24.84,0:35:28.19,Default,,0,0,0,,如果我将X改为4
Dialogue: 0,0:35:28.19,0:35:30.19,Default,,0,0,0,,在其他地方也是可见的
Dialogue: 0,0:35:30.19,0:35:32.19,Default,,0,0,0,,但是我们现在不去关心这个
Dialogue: 0,0:35:32.19,0:35:33.84,Default,,0,0,0,,过一会儿会详细讨论这个问题
Dialogue: 0,0:35:34.56,0:35:35.53,Default,,0,0,0,,这里有什么？
Dialogue: 0,0:35:36.76,0:35:38.84,Default,,0,0,0,,这些叫做框架 这是一个框架
Dialogue: 0,0:35:39.40,0:35:40.38,Default,,0,0,0,,这是一个框架
Dialogue: 0,0:35:40.76,0:35:41.84,Default,,0,0,0,,这也是一个框架
Dialogue: 0,0:35:43.18,0:35:45.20,Default,,0,0,0,,A是一个环境
Dialogue: 0,0:35:45.20,0:35:47.82,Default,,0,0,0,,它由框架II
Dialogue: 0,0:35:48.36,0:35:51.05,Default,,0,0,0,,和框架I组成
Dialogue: 0,0:35:52.52,0:35:54.60,Default,,0,0,0,,在这个环境中
Dialogue: 0,0:35:54.99,0:35:59.68,Default,,0,0,0,,在环境C中 在框架II中
Dialogue: 0,0:36:00.48,0:36:03.26,Default,,0,0,0,,X和Y是被约束的
Dialogue: 0,0:36:04.06,0:36:04.78,Default,,0,0,0,,它们具有值
Dialogue: 0,0:36:05.26,0:36:07.18,Default,,0,0,0,,对不起 是在框架I中
Dialogue: 0,0:36:07.18,0:36:08.28,Default,,0,0,0,,而在框架II中
Dialogue: 0,0:36:09.72,0:36:10.83,Default,,0,0,0,,Z被约束
Dialogue: 0,0:36:10.99,0:36:12.17,Default,,0,0,0,,X被约束
Dialogue: 0,0:36:12.44,0:36:13.69,Default,,0,0,0,,并且Y也是被约束的
Dialogue: 0,0:36:15.24,0:36:17.40,Default,,0,0,0,,但是我们看到的X的值
Dialogue: 0,0:36:17.42,0:36:19.04,Default,,0,0,0,,从这个角度来看
Dialogue: 0,0:36:20.01,0:36:21.74,Default,,0,0,0,,是这个X 它的值是7
Dialogue: 0,0:36:22.36,0:36:24.84,Default,,0,0,0,,而不是这个值为3的X
Dialogue: 0,0:36:24.84,0:36:27.61,Default,,0,0,0,,我们称之为 这个X遮蔽了这个X
Dialogue: 0,0:36:31.05,0:36:32.49,Default,,0,0,0,,从环境III
Dialogue: 0,0:36:33.44,0:36:34.45,Default,,0,0,0,,从框架III
Dialogue: 0,0:36:34.45,0:36:35.73,Default,,0,0,0,,从环境B
Dialogue: 0,0:36:35.73,0:36:37.18,Default,,0,0,0,,它引用了框架III
Dialogue: 0,0:36:37.45,0:36:42.12,Default,,0,0,0,,变量M和Y被约束 X也被约束
Dialogue: 0,0:36:44.84,0:36:46.97,Default,,0,0,0,,这个Y遮蔽了这个Y
Dialogue: 0,0:36:48.65,0:36:51.00,Default,,0,0,0,,从这个角度来看
Dialogue: 0,0:36:51.10,0:36:52.65,Default,,0,0,0,,Y的值是2
Dialogue: 0,0:36:53.45,0:36:55.28,Default,,0,0,0,,从这个角度来看
Dialogue: 0,0:36:55.28,0:36:58.64,Default,,0,0,0,,M的值是1 X的值是3
Dialogue: 0,0:37:02.22,0:37:03.15,Default,,0,0,0,,所以 我们有了一个
Dialogue: 0,0:37:03.15,0:37:05.52,Default,,0,0,0,,由框架构成的非常简单的环境结构
Dialogue: 0,0:37:06.38,0:37:09.80,Default,,0,0,0,,它们与过程的应用相一致
Dialogue: 0,0:37:10.94,0:37:12.17,Default,,0,0,0,,我们马上就会看到
Dialogue: 0,0:37:14.41,0:37:17.60,Default,,0,0,0,,现在要给你们看看我们构建的一些其他的很好的小结构
Dialogue: 0,0:37:20.75,0:37:21.71,Default,,0,0,0,,下一张幻灯片
Dialogue: 0,0:37:22.14,0:37:24.36,Default,,0,0,0,,我们可以看到一个对象
Dialogue: 0,0:37:24.84,0:37:26.54,Default,,0,0,0,,我描绘的是一个过程的图像
Dialogue: 0,0:37:27.93,0:37:28.94,Default,,0,0,0,,这是一个过程
Dialogue: 0,0:37:30.11,0:37:31.90,Default,,0,0,0,,过程由两个部分组成
Dialogue: 0,0:37:33.10,0:37:34.80,Default,,0,0,0,,这有点像CONS
Dialogue: 0,0:37:37.21,0:37:38.38,Default,,0,0,0,,不管怎样 它有两个部分
Dialogue: 0,0:37:40.84,0:37:44.72,Default,,0,0,0,,第一个部分指向一些代码
Dialogue: 0,0:37:45.69,0:37:46.94,Default,,0,0,0,,这些代码将会被执行
Dialogue: 0,0:37:47.42,0:37:50.00,Default,,0,0,0,,你可以把它视作一组指令
Dialogue: 0,0:37:50.68,0:37:52.83,Default,,0,0,0,,第二部分是环境
Dialogue: 0,0:37:53.88,0:37:55.50,Default,,0,0,0,,这就是过程的全部了
Dialogue: 0,0:37:57.16,0:37:58.40,Default,,0,0,0,,我们要用它
Dialogue: 0,0:37:58.71,0:38:05.16,Default,,0,0,0,,来捕获出现在过程中的自由变量的值
Dialogue: 0,0:38:06.17,0:38:08.09,Default,,0,0,0,,如果变量出现在过程中
Dialogue: 0,0:38:08.11,0:38:09.92,Default,,0,0,0,,它不是被约束的就是自由的
Dialogue: 0,0:38:11.10,0:38:11.96,Default,,0,0,0,,如果它是被约束的
Dialogue: 0,0:38:12.57,0:38:14.56,Default,,0,0,0,,则它的值将很容易被找到
Dialogue: 0,0:38:16.11,0:38:18.64,Default,,0,0,0,,它将存在于某个很容易找到的环境中
Dialogue: 0,0:38:18.91,0:38:19.87,Default,,0,0,0,,如果它是自由的
Dialogue: 0,0:38:20.86,0:38:23.02,Default,,0,0,0,,我们就必须在过程中放入一些东西
Dialogue: 0,0:38:23.02,0:38:24.81,Default,,0,0,0,,用来指导我们查询自由变量的值
Dialogue: 0,0:38:27.05,0:38:29.21,Default,,0,0,0,,相关理由目前还不清楚
Dialogue: 0,0:38:29.21,0:38:30.60,Default,,0,0,0,,但很快就要真相大白了
Dialogue: 0,0:38:32.32,0:38:34.97,Default,,0,0,0,,这里有一个对象 它是个复合对象
Dialogue: 0,0:38:35.34,0:38:41.64,Default,,0,0,0,,由一些代码和一个环境结构组成
Dialogue: 0,0:38:42.72,0:38:45.50,Default,,0,0,0,,现在我要告诉你们一些全新的规则
Dialogue: 0,0:38:46.41,0:38:47.47,Default,,0,0,0,,关于执行的规则
Dialogue: 0,0:38:50.54,0:38:52.20,Default,,0,0,0,,仅有的两条规则的第一条是--
Dialogue: 0,0:38:53.20,0:38:55.39,Default,,0,0,0,,这些规则与代换模型规则相对应
Dialogue: 0,0:38:57.26,0:38:59.32,Default,,0,0,0,,第一条规则是用来解决
Dialogue: 0,0:38:59.66,0:39:02.78,Default,,0,0,0,,如何把一个过程 应用到参数上的问题
Dialogue: 0,0:39:05.28,0:39:08.54,Default,,0,0,0,,程序对象被应用于一组参数
Dialogue: 0,0:39:08.96,0:39:10.43,Default,,0,0,0,,是通过构建一个新的框架来完成
Dialogue: 0,0:39:11.31,0:39:15.76,Default,,0,0,0,,那个框架将包含形式参数
Dialogue: 0,0:39:15.83,0:39:19.48,Default,,0,0,0,,到调用中使用的实际参数的映射
Dialogue: 0,0:39:21.42,0:39:22.20,Default,,0,0,0,,如你所知
Dialogue: 0,0:39:22.31,0:39:26.94,Default,,0,0,0,,当我们调用一个过程 如(LAMBDA (X) (* X Y))
Dialogue: 0,0:39:26.94,0:39:29.13,Default,,0,0,0,,然后我们以3为参数调用它
Dialogue: 0,0:39:30.19,0:39:32.75,Default,,0,0,0,,那么我们需要某个从X到3的映射
Dialogue: 0,0:39:34.19,0:39:37.39,Default,,0,0,0,,你可以把它想做是代换的一种
Dialogue: 0,0:39:38.27,0:39:40.30,Default,,0,0,0,,在旧的模型中 用3代换X
Dialogue: 0,0:39:42.00,0:39:44.80,Default,,0,0,0,,所以我要建立一个框架
Dialogue: 0,0:39:45.15,0:39:46.60,Default,,0,0,0,,在框架中包含X等于3的这个信息
Dialogue: 0,0:39:49.12,0:39:49.71,Default,,0,0,0,,现在
Dialogue: 0,0:39:50.33,0:39:53.31,Default,,0,0,0,,过程的体即将被执行
Dialogue: 0,0:39:54.16,0:39:56.44,Default,,0,0,0,,它将在一个环境中执行
Dialogue: 0,0:39:57.80,0:40:08.03,Default,,0,0,0,,这个环境是由我们创建的新框架邻接组合而成
Dialogue: 0,0:40:08.54,0:40:11.69,Default,,0,0,0,,它是我们所应用的过程的一部分
Dialogue: 0,0:40:13.15,0:40:15.77,Default,,0,0,0,,所以 举个例子
Dialogue: 0,0:40:19.20,0:40:24.12,Default,,0,0,0,,假设我有一些环境
Dialogue: 0,0:40:25.15,0:40:27.23,Default,,0,0,0,,画个方框代表它
Dialogue: 0,0:40:27.96,0:40:32.19,Default,,0,0,0,,以及一些过程--我画圆来代表它们 因为这比小三角形好画--
Dialogue: 0,0:40:33.04,0:40:36.36,Default,,0,0,0,,抱歉 是菱形
Dialogue: 0,0:40:37.66,0:40:40.78,Default,,0,0,0,,小块菱形的果冻之类的东西
Dialogue: 0,0:40:42.68,0:40:45.32,Default,,0,0,0,,这有一个使用这个环境的过程
Dialogue: 0,0:40:45.95,0:40:48.16,Default,,0,0,0,,这个过程有一些代码
Dialogue: 0,0:40:48.16,0:40:49.68,Default,,0,0,0,,是一个LAMBDA表达式
Dialogue: 0,0:40:50.12,0:40:51.69,Default,,0,0,0,,约束了X和Y
Dialogue: 0,0:40:53.15,0:40:56.43,Default,,0,0,0,,然后执行了表达式E
Dialogue: 0,0:40:57.93,0:40:58.99,Default,,0,0,0,,这个过程就是这样的
Dialogue: 0,0:40:59.56,0:41:00.57,Default,,0,0,0,,我们叫它P
Dialogue: 0,0:41:01.44,0:41:05.79,Default,,0,0,0,,我希望将这个过程应用于3和4
Dialogue: 0,0:41:06.38,0:41:08.36,Default,,0,0,0,,所以我在这写(P 3 4)
Dialogue: 0,0:41:09.76,0:41:12.17,Default,,0,0,0,,我要做的事情则是 创建一个新的框架
Dialogue: 0,0:41:13.15,0:41:14.12,Default,,0,0,0,,创建一个框架
Dialogue: 0,0:41:15.24,0:41:18.28,Default,,0,0,0,,框架中X等于3
Dialogue: 0,0:41:18.84,0:41:20.51,Default,,0,0,0,,而Y等于4
Dialogue: 0,0:41:21.69,0:41:23.48,Default,,0,0,0,,我要把这个框架
Dialogue: 0,0:41:24.27,0:41:25.37,Default,,0,0,0,,连接到这一个框架上
Dialogue: 0,0:41:27.63,0:41:28.99,Default,,0,0,0,,对于这个环境
Dialogue: 0,0:41:29.68,0:41:30.97,Default,,0,0,0,,我把它叫做B
Dialogue: 0,0:41:31.55,0:41:35.02,Default,,0,0,0,,我会在这个环境中求值E的体
Dialogue: 0,0:41:39.88,0:41:40.33,Default,,0,0,0,,现在
Dialogue: 0,0:41:41.95,0:41:45.04,Default,,0,0,0,,E可能包含了X和Y的引用以及一些别的东西
Dialogue: 0,0:41:46.84,0:41:49.95,Default,,0,0,0,,X和Y的值在这里
Dialogue: 0,0:41:50.70,0:41:52.52,Default,,0,0,0,,其他的变量的值在这里
Dialogue: 0,0:41:55.05,0:41:56.25,Default,,0,0,0,,怎样才能获取这个框架呢？
Dialogue: 0,0:41:57.26,0:41:59.26,Default,,0,0,0,,我们通过过程构建来完成
Dialogue: 0,0:41:59.61,0:42:00.60,Default,,0,0,0,,这就是另一条规则了
Dialogue: 0,0:42:02.03,0:42:04.40,Default,,0,0,0,,请看下一张幻灯片
Dialogue: 0,0:42:05.34,0:42:06.12,Default,,0,0,0,,规则二
Dialogue: 0,0:42:07.80,0:42:09.90,Default,,0,0,0,,当一个LAMBDA表达式被求值时
Dialogue: 0,0:42:09.90,0:42:11.76,Default,,0,0,0,,相对于某个特定的环境--
Dialogue: 0,0:42:14.19,0:42:14.40,Default,,0,0,0,,例如
Dialogue: 0,0:42:15.04,0:42:18.12,Default,,0,0,0,,获取一个过程的方式就是求值一个LAMBDA表达式
Dialogue: 0,0:42:18.19,0:42:19.36,Default,,0,0,0,,这里有一个LAMBDA表达式
Dialogue: 0,0:42:20.04,0:42:21.12,Default,,0,0,0,,通过对它求值
Dialogue: 0,0:42:21.90,0:42:23.96,Default,,0,0,0,,我获得了一个可以应用于3的过程
Dialogue: 0,0:42:25.08,0:42:26.65,Default,,0,0,0,,现在这个LAMBDA表达式
Dialogue: 0,0:42:26.65,0:42:30.38,Default,,0,0,0,,在一个Y已被定义的环境中执行
Dialogue: 0,0:42:31.84,0:42:35.84,Default,,0,0,0,,我希望这个过程的体中包括的Y是自由的
Dialogue: 0,0:42:36.39,0:42:38.36,Default,,0,0,0,,在这里面 Y是自由的
Dialogue: 0,0:42:38.72,0:42:40.38,Default,,0,0,0,,但是在整个的表达式中却是被约束的
Dialogue: 0,0:42:41.36,0:42:42.75,Default,,0,0,0,,而在这里是自由的
Dialogue: 0,0:42:43.32,0:42:46.24,Default,,0,0,0,,我想让这两个Y指称同一个Y
Dialogue: 0,0:42:47.44,0:42:55.13,Default,,0,0,0,,我在Y被创建的环境中求值这个过程的体
Dialogue: 0,0:42:55.32,0:42:58.40,Default,,0,0,0,,就像这个一样 因为那是通过应用完成的
Dialogue: 0,0:42:59.00,0:42:59.63,Default,,0,0,0,,现在
Dialogue: 0,0:43:00.24,0:43:02.60,Default,,0,0,0,,如果我还想查找Y的值
Dialogue: 0,0:43:03.10,0:43:04.09,Default,,0,0,0,,我就必须知道它在哪
Dialogue: 0,0:43:04.54,0:43:06.42,Default,,0,0,0,,因此 这个过程在被创建时
Dialogue: 0,0:43:06.42,0:43:10.06,Default,,0,0,0,,过程的创建 也就是对LAMBDA表达式求值的结果
Dialogue: 0,0:43:10.06,0:43:16.33,Default,,0,0,0,,最好是获取一个指针或记住Y被约束在哪个框架中
Dialogue: 0,0:43:17.92,0:43:19.76,Default,,0,0,0,,这就是这个规则的内容
Dialogue: 0,0:43:22.11,0:43:23.13,Default,,0,0,0,,那么 举个例子
Dialogue: 0,0:43:24.44,0:43:29.32,Default,,0,0,0,,如果我恰好求值了一个LAMBDA表达式
Dialogue: 0,0:43:30.89,0:43:33.32,Default,,0,0,0,,在E中的LAMBDA表达式
Dialogue: 0,0:43:34.04,0:43:40.46,Default,,0,0,0,,在E中求值(LAMBDA (X Y) G)
Dialogue: 0,0:43:41.08,0:43:42.36,Default,,0,0,0,,对其求值
Dialogue: 0,0:43:42.97,0:43:46.17,Default,,0,0,0,,这些事的意义就是我现在构建了一个过程对象
Dialogue: 0,0:43:47.10,0:43:48.28,Default,,0,0,0,,E是某个环境
Dialogue: 0,0:43:48.84,0:43:50.94,Default,,0,0,0,,有个指针指向E
Dialogue: 0,0:43:51.79,0:43:56.68,Default,,0,0,0,,我构建了一个过程对象指向了这个环境
Dialogue: 0,0:43:58.56,0:44:00.11,Default,,0,0,0,,它的代码
Dialogue: 0,0:44:00.54,0:44:03.24,Default,,0,0,0,,是一个LAMBDA表达式 或者是某种中间代码
Dialogue: 0,0:44:06.24,0:44:07.56,Default,,0,0,0,,而这就是一个过程
Dialogue: 0,0:44:12.38,0:44:14.70,Default,,0,0,0,,它为我生成了这个和这个
Dialogue: 0,0:44:14.94,0:44:16.37,Default,,0,0,0,,这个对象
Dialogue: 0,0:44:16.37,0:44:18.12,Default,,0,0,0,,这个环境指针
Dialogue: 0,0:44:18.37,0:44:22.52,Default,,0,0,0,,获取了求值LAMBDA表达式时的环境
Dialogue: 0,0:44:22.62,0:44:24.59,Default,,0,0,0,,定义所使用的环境
Dialogue: 0,0:44:25.58,0:44:27.40,Default,,0,0,0,,创建一个过程时的定义所用的环境
Dialogue: 0,0:44:30.32,0:44:31.47,Default,,0,0,0,,从而创建了过程
Dialogue: 0,0:44:32.89,0:44:36.30,Default,,0,0,0,,所以 它将环境从定义过程的地方取出
Dialogue: 0,0:44:37.42,0:44:38.92,Default,,0,0,0,,将它保存在过程自己内部
Dialogue: 0,0:44:39.60,0:44:40.97,Default,,0,0,0,,之后当过程被调用时
Dialogue: 0,0:44:41.32,0:44:43.47,Default,,0,0,0,,它在被定义时的环境
Dialogue: 0,0:44:43.98,0:44:45.07,Default,,0,0,0,,将由新的框架扩充
Dialogue: 0,0:44:48.72,0:44:52.33,Default,,0,0,0,,这给了我们一个放置有值的变量的地方
Dialogue: 0,0:44:53.04,0:44:53.96,Default,,0,0,0,,举个例子
Dialogue: 0,0:44:53.96,0:44:56.81,Default,,0,0,0,,如果有很多东西指向那这个环境
Dialogue: 0,0:44:57.74,0:45:00.33,Default,,0,0,0,,它们就会共享这个环境
Dialogue: 0,0:45:01.20,0:45:02.52,Default,,0,0,0,,我们很快将会见到
Dialogue: 0,0:45:04.01,0:45:05.34,Default,,0,0,0,,现在你们有了一个新模型
Dialogue: 0,0:45:06.38,0:45:09.92,Default,,0,0,0,,我们用它来理解程序的执行
Dialogue: 0,0:45:11.36,0:45:12.78,Default,,0,0,0,,我觉得现在我应该解答一些问题了
Dialogue: 0,0:45:13.10,0:45:14.96,Default,,0,0,0,,之后我们再继续
Dialogue: 0,0:45:18.19,0:45:19.52,Default,,0,0,0,,学生：这么说是对的吗？
Dialogue: 0,0:45:19.52,0:45:23.96,Default,,0,0,0,,环境就是一些被连接在一起的框架
Dialogue: 0,0:45:23.96,0:45:25.10,Default,,0,0,0,,教授：对
Dialogue: 0,0:45:25.48,0:45:26.64,Default,,0,0,0,,学生：通过它能够访问所有的框架？
Dialogue: 0,0:45:27.71,0:45:31.45,Default,,0,0,0,,教授：是的 环境是一系列被连接在一起的框架
Dialogue: 0,0:45:32.43,0:45:35.47,Default,,0,0,0,,我对它的理解是 它是指向第一个框架的指针
Dialogue: 0,0:45:36.88,0:45:38.72,Default,,0,0,0,,因为一旦你获得了它 你就能拿到所有的框架
Dialogue: 0,0:45:43.96,0:45:44.65,Default,,0,0,0,,还有谁有问题吗？
Dialogue: 0,0:45:45.20,0:45:49.36,Default,,0,0,0,,学生：有可能在两个不同的环境中定义或求值一个过程
Dialogue: 0,0:45:49.36,0:45:53.20,Default,,0,0,0,,使得它有不同的行为 并且有指向两个环境的指针--
Dialogue: 0,0:45:53.20,0:45:55.77,Default,,0,0,0,,教授：噢 是的 同一个过程不会有两个不同环境
Dialogue: 0,0:45:56.90,0:45:59.02,Default,,0,0,0,,同样的代码
Dialogue: 0,0:45:59.02,0:46:00.82,Default,,0,0,0,,比如同样的LAMBDA表达式
Dialogue: 0,0:46:00.82,0:46:03.72,Default,,0,0,0,,再不同的环境下求值可能产生不同的过程
Dialogue: 0,0:46:06.03,0:46:07.18,Default,,0,0,0,,每个过程--
Dialogue: 0,0:46:07.18,0:46:09.95,Default,,0,0,0,,学生：它们的定义有同样的名字 它们的运算--
Dialogue: 0,0:46:09.95,0:46:11.92,Default,,0,0,0,,教授：它们定义是写起来是一样的 使用同样的字母
Dialogue: 0,0:46:12.56,0:46:14.62,Default,,0,0,0,,我能求值那一组字母
Dialogue: 0,0:46:14.93,0:46:18.14,Default,,0,0,0,,或定义的表结构之类的东西
Dialogue: 0,0:46:18.22,0:46:20.41,Default,,0,0,0,,那只是文本表示
Dialogue: 0,0:46:20.91,0:46:24.86,Default,,0,0,0,,我可以在两个不同环境种对它求值 产生两个不同的过程
Dialogue: 0,0:46:25.55,0:46:26.84,Default,,0,0,0,,每一个过程
Dialogue: 0,0:46:27.56,0:46:32.19,Default,,0,0,0,,有它们自己的一组局部变量
Dialogue: 0,0:46:32.34,0:46:33.45,Default,,0,0,0,,我们很快就会看到
Dialogue: 0,0:46:36.70,0:46:37.36,Default,,0,0,0,,还有问题吗？
Dialogue: 0,0:46:42.60,0:46:44.03,Default,,0,0,0,,好 谢谢大家 我们休息一会
Dialogue: 0,0:46:47.98,0:46:57.61,Default,,0,0,0,,[音乐]
Dialogue: 0,0:46:57.61,0:47:02.03,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:47:05.98,0:47:09.69,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:47:09.69,0:47:13.44,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:47:13.47,0:47:18.84,Declare,,0,0,0,,{\an2\fad(500,500)}赋值、状态和副作用
Dialogue: 0,0:47:22.67,0:47:25.69,Default,,0,0,0,,现在 我已经对你们做了一件非常糟糕的事儿
Dialogue: 0,0:47:26.56,0:47:30.54,Default,,0,0,0,,我引入了一个非常复杂的东西
Dialogue: 0,0:47:32.76,0:47:33.42,Default,,0,0,0,,赋值
Dialogue: 0,0:47:34.51,0:47:38.08,Default,,0,0,0,,它摧毁了我们程序中大部分的 有趣的数学特性
Dialogue: 0,0:47:41.07,0:47:42.46,Default,,0,0,0,,我为什么要做这件事呢
Dialogue: 0,0:47:43.18,0:47:45.02,Default,,0,0,0,,这样做可能有什么好处吗？
Dialogue: 0,0:47:46.51,0:47:48.86,Default,,0,0,0,,很明显 这不是一个什么好东西
Dialogue: 0,0:47:49.60,0:47:51.23,Default,,0,0,0,,因此我最好有一个好的理由
Dialogue: 0,0:47:52.83,0:47:54.80,Default,,0,0,0,,让我们来小小地玩一下
Dialogue: 0,0:47:54.80,0:47:58.35,Default,,0,0,0,,首先 我们写些非常有趣的带赋值的程序
Dialogue: 0,0:47:58.81,0:48:00.88,Default,,0,0,0,,来理解它们的特殊之处
Dialogue: 0,0:48:01.42,0:48:02.83,Default,,0,0,0,,这些特殊之处使赋值变得有价值
Dialogue: 0,0:48:04.96,0:48:06.70,Default,,0,0,0,,我们从一个非常简单的程序开始
Dialogue: 0,0:48:07.69,0:48:09.28,Default,,0,0,0,,我把这个程序叫做MAKE-COUNTER
Dialogue: 0,0:48:10.48,0:48:18.19,Default,,0,0,0,,我要把它定义为
Dialogue: 0,0:48:24.17,0:48:28.12,Default,,0,0,0,,接受一个参数N的过程
Dialogue: 0,0:48:29.23,0:48:32.94,Default,,0,0,0,,并且它的返回值是一个没有参数的过程--
Dialogue: 0,0:48:34.36,0:48:36.03,Default,,0,0,0,,一个生成过程的过程--
Dialogue: 0,0:48:36.84,0:48:44.35,Default,,0,0,0,,这个过程把N的值设为N+1
Dialogue: 0,0:48:47.88,0:48:49.77,Default,,0,0,0,,并且返回N的值
Dialogue: 0,0:48:55.37,0:48:57.54,Default,,0,0,0,,现在 我们要研究它的行为
Dialogue: 0,0:48:57.54,0:48:59.02,Default,,0,0,0,,它很有趣
Dialogue: 0,0:48:59.82,0:49:01.45,Default,,0,0,0,,为了研究它的行为
Dialogue: 0,0:49:01.45,0:49:03.08,Default,,0,0,0,,我需要建立一个环境模型
Dialogue: 0,0:49:04.11,0:49:05.98,Default,,0,0,0,,因为我们不能通过其他的方式来理解它
Dialogue: 0,0:49:08.65,0:49:09.63,Default,,0,0,0,,所以我们开始吧
Dialogue: 0,0:49:10.00,0:49:12.86,Default,,0,0,0,,我们从这里开始
Dialogue: 0,0:49:13.24,0:49:15.90,Default,,0,0,0,,假设机器天生就有一个全局环境
Dialogue: 0,0:49:16.13,0:49:17.12,Default,,0,0,0,,我们把它叫做Global
Dialogue: 0,0:49:20.03,0:49:24.25,Default,,0,0,0,,它内部有一堆初始化的东西
Dialogue: 0,0:49:24.44,0:49:25.60,Default,,0,0,0,,我们都知道它里面有什么
Dialogue: 0,0:49:25.72,0:49:30.88,Default,,0,0,0,,这里面有+和*
Dialogue: 0,0:49:32.24,0:49:37.26,Default,,0,0,0,,/ -和CAR
Dialogue: 0,0:49:38.70,0:49:39.74,Default,,0,0,0,,以此类推
Dialogue: 0,0:49:41.45,0:49:42.48,Default,,0,0,0,,有很多东西
Dialogue: 0,0:49:42.88,0:49:43.98,Default,,0,0,0,,我不知道它们是什么
Dialogue: 0,0:49:44.42,0:49:45.55,Default,,0,0,0,,一些乱七八糟的符号
Dialogue: 0,0:49:46.08,0:49:48.88,Default,,0,0,0,,机器一开始就有这些特性
Dialogue: 0,0:49:51.21,0:49:53.23,Default,,0,0,0,,通过在这做定义
Dialogue: 0,0:49:54.68,0:49:55.76,Default,,0,0,0,,我要做的是--
Dialogue: 0,0:49:56.32,0:49:57.31,Default,,0,0,0,,我在干什么呢？
Dialogue: 0,0:49:57.31,0:49:59.58,Default,,0,0,0,,我要把它关联到全局环境上
Dialogue: 0,0:49:59.72,0:50:01.29,Default,,0,0,0,,这是我的环境指针
Dialogue: 0,0:50:03.72,0:50:06.70,Default,,0,0,0,,为了达到那个目的 我要求值这个LAMBDA表达式
Dialogue: 0,0:50:08.35,0:50:10.01,Default,,0,0,0,,这意味着我创建了一个过程对象
Dialogue: 0,0:50:11.50,0:50:13.26,Default,,0,0,0,,所以 我要在这创建一个过程对象
Dialogue: 0,0:50:17.36,0:50:18.68,Default,,0,0,0,,这个过程对象
Dialogue: 0,0:50:18.72,0:50:20.49,Default,,0,0,0,,由于在它被定义的地方
Dialogue: 0,0:50:21.16,0:50:22.35,Default,,0,0,0,,有一个全局的环境
Dialogue: 0,0:50:24.06,0:50:25.79,Default,,0,0,0,,这个过程对象包括了
Dialogue: 0,0:50:28.16,0:50:31.47,Default,,0,0,0,,以N为参数的过程的代码
Dialogue: 0,0:50:31.96,0:50:35.34,Default,,0,0,0,,它返回一个不接受参数的过程
Dialogue: 0,0:50:38.24,0:50:43.28,Default,,0,0,0,,DEFINE是一种改变环境的方法
Dialogue: 0,0:50:44.32,0:50:46.73,Default,,0,0,0,,所以我把MAKE-COUNTER加入全局环境中
Dialogue: 0,0:50:52.28,0:50:55.05,Default,,0,0,0,,这是对于特殊的东西定义的一个特殊的规则
Dialogue: 0,0:50:55.82,0:50:56.94,Default,,0,0,0,,但它其实是
Dialogue: 0,0:50:58.94,0:51:01.96,Default,,0,0,0,,它给了我们一个指针 指向那个过程
Dialogue: 0,0:51:03.82,0:51:06.32,Default,,0,0,0,,所以现在全局环境中也有了MAKE-COUNTER
Dialogue: 0,0:51:09.28,0:51:11.21,Default,,0,0,0,,现在 我们要进行一些操作
Dialogue: 0,0:51:11.87,0:51:13.50,Default,,0,0,0,,我要用它来创建一些计数器
Dialogue: 0,0:51:14.99,0:51:16.20,Default,,0,0,0,,我们来看看计数器是什么
Dialogue: 0,0:51:17.12,0:51:18.51,Default,,0,0,0,,所以我们定义
Dialogue: 0,0:51:23.32,0:51:26.65,Default,,0,0,0,,C1为一个从0开始的计数器
Dialogue: 0,0:51:35.72,0:51:38.38,Default,,0,0,0,,根据模型 我们知道如何做这个了
Dialogue: 0,0:51:39.63,0:51:44.33,Default,,0,0,0,,我需要在全局环境中求值这个表达式
Dialogue: 0,0:51:45.40,0:51:46.27,Default,,0,0,0,,(MAKE-COUNTER 0)
Dialogue: 0,0:51:47.80,0:51:51.10,Default,,0,0,0,,我查找MAKE-COUNTER 发现它是一个过程
Dialogue: 0,0:51:53.61,0:51:55.29,Default,,0,0,0,,我将要应用这个过程
Dialogue: 0,0:51:56.22,0:51:57.74,Default,,0,0,0,,应用这个过程的方式
Dialogue: 0,0:51:58.43,0:51:59.96,Default,,0,0,0,,就是构建一个框架
Dialogue: 0,0:52:01.80,0:52:03.79,Default,,0,0,0,,所以我构建了一个框架
Dialogue: 0,0:52:06.59,0:52:10.44,Default,,0,0,0,,它内部有一个N的值
Dialogue: 0,0:52:11.77,0:52:12.64,Default,,0,0,0,,这个值是0
Dialogue: 0,0:52:14.00,0:52:15.34,Default,,0,0,0,,它的父环境
Dialogue: 0,0:52:15.87,0:52:19.32,Default,,0,0,0,,就是定义MAKE-COUNTER时的环境
Dialogue: 0,0:52:23.93,0:52:28.36,Default,,0,0,0,,所以我已经通过将MAKE-COUNTER应用于0上 而创建了一个环境
Dialogue: 0,0:52:31.45,0:52:34.40,Default,,0,0,0,,现在 我需要求值MAKE-COUNTER的体
Dialogue: 0,0:52:34.41,0:52:37.72,Default,,0,0,0,,就是那个环境中的LAMBDA表达式
Dialogue: 0,0:52:40.64,0:52:42.30,Default,,0,0,0,,求值这个体
Dialogue: 0,0:52:42.76,0:52:44.59,Default,,0,0,0,,它是一个LAMBDA表达式
Dialogue: 0,0:52:46.28,0:52:48.86,Default,,0,0,0,,对LAMBDA表达式求值 意味着创建一个过程对象
Dialogue: 0,0:52:49.56,0:52:51.00,Default,,0,0,0,,所以我将创建一个过程对象
Dialogue: 0,0:52:56.76,0:52:58.29,Default,,0,0,0,,这个过程对象
Dialogue: 0,0:52:58.29,0:53:00.46,Default,,0,0,0,,拥有一个环境
Dialogue: 0,0:53:04.20,0:53:05.88,Default,,0,0,0,,在这个环境中N被定义为0
Dialogue: 0,0:53:07.68,0:53:08.80,Default,,0,0,0,,它有一些代码
Dialogue: 0,0:53:08.83,0:53:11.37,Default,,0,0,0,,这个过程不需要参数
Dialogue: 0,0:53:11.40,0:53:15.28,Default,,0,0,0,,该过程进行一些处理 然后进行赋值
Dialogue: 0,0:53:15.28,0:53:16.73,Default,,0,0,0,,并返回N
Dialogue: 0,0:53:17.88,0:53:18.81,Default,,0,0,0,,这个东西
Dialogue: 0,0:53:19.42,0:53:21.23,Default,,0,0,0,,将成为一个对象
Dialogue: 0,0:53:21.92,0:53:24.67,Default,,0,0,0,,在全局环境中 它的名字是C1
Dialogue: 0,0:53:26.12,0:53:28.33,Default,,0,0,0,,所以我们在这建立一个名字 C1
Dialogue: 0,0:53:28.64,0:53:32.14,Default,,0,0,0,,并且说C1等于这个过程
Dialogue: 0,0:53:35.48,0:53:37.36,Default,,0,0,0,,现在 再来创建另一个计数器
Dialogue: 0,0:53:43.04,0:53:45.13,Default,,0,0,0,,通过MAKE-COUNTER创建c2
Dialogue: 0,0:53:50.94,0:53:52.19,Default,,0,0,0,,让它从10开始
Dialogue: 0,0:53:54.25,0:53:55.90,Default,,0,0,0,,然后我执行同样的步骤
Dialogue: 0,0:53:56.64,0:54:00.40,Default,,0,0,0,,我应用这个MAKE-COUNTER过程
Dialogue: 0,0:54:00.99,0:54:04.52,Default,,0,0,0,,建立另一个框架 其中N等于10
Dialogue: 0,0:54:05.63,0:54:09.18,Default,,0,0,0,,全局环境作为它的父环境
Dialogue: 0,0:54:10.04,0:54:11.80,Default,,0,0,0,,然后我构建一个过程
Dialogue: 0,0:54:13.04,0:54:17.63,Default,,0,0,0,,以这个框架作为它定义的环境
Dialogue: 0,0:54:18.27,0:54:21.66,Default,,0,0,0,,它的代码是
Dialogue: 0,0:54:21.80,0:54:24.38,Default,,0,0,0,,完成一些操作的无参过程
Dialogue: 0,0:54:25.54,0:54:28.60,Default,,0,0,0,,然后进行赋值 等等
Dialogue: 0,0:54:28.60,0:54:31.22,Default,,0,0,0,,然后返回N
Dialogue: 0,0:54:31.45,0:54:34.83,Default,,0,0,0,,这就是C2
Dialogue: 0,0:54:36.88,0:54:39.32,Default,,0,0,0,,好 你们应该发现 某些东西开始变得有趣了
Dialogue: 0,0:54:40.17,0:54:41.92,Default,,0,0,0,,这里有两个N
Dialogue: 0,0:54:42.92,0:54:44.19,Default,,0,0,0,,它们不是同一个N
Dialogue: 0,0:54:46.14,0:54:48.16,Default,,0,0,0,,我每次调用MAKE-COUNTER的时候
Dialogue: 0,0:54:48.64,0:54:50.25,Default,,0,0,0,,我就创建了另一个N的实例
Dialogue: 0,0:54:52.62,0:54:54.40,Default,,0,0,0,,它们彼此独立 没有关联
Dialogue: 0,0:54:57.79,0:55:00.28,Default,,0,0,0,,现在 我们来使用一下这些计数器
Dialogue: 0,0:55:05.92,0:55:15.00,Default,,0,0,0,,如果此时 我调用C1 会发生什么？
Dialogue: 0,0:55:15.84,0:55:17.34,Default,,0,0,0,,我会在这里查找
Dialogue: 0,0:55:17.56,0:55:19.98,Default,,0,0,0,,发现C1是一个过程
Dialogue: 0,0:55:20.64,0:55:22.78,Default,,0,0,0,,我要不带参数地调用这个过程
Dialogue: 0,0:55:23.16,0:55:24.96,Default,,0,0,0,,因为它不需要参数
Dialogue: 0,0:55:24.96,0:55:25.63,Default,,0,0,0,,对吧？
Dialogue: 0,0:55:26.97,0:55:27.84,Default,,0,0,0,,它的体是什么呢？
Dialogue: 0,0:55:27.96,0:55:30.02,Default,,0,0,0,,我得来这里解释 因为我没有给誊过来
Dialogue: 0,0:55:30.02,0:55:32.65,Default,,0,0,0,,这个过程体是将N赋值为N+1
Dialogue: 0,0:55:33.80,0:55:34.89,Default,,0,0,0,,并且返回N
Dialogue: 0,0:55:37.12,0:55:38.12,Default,,0,0,0,,就是把N增大1
Dialogue: 0,0:55:38.97,0:55:41.60,Default,,0,0,0,,它的N指的是这个
Dialogue: 0,0:55:43.08,0:55:44.60,Default,,0,0,0,,所以我把这个n增大1
Dialogue: 0,0:55:45.80,0:55:47.00,Default,,0,0,0,,它变成了1
Dialogue: 0,0:55:48.64,0:55:50.24,Default,,0,0,0,,然后返回了1
Dialogue: 0,0:55:53.13,0:55:56.49,Default,,0,0,0,,之后我调用C2
Dialogue: 0,0:55:58.38,0:55:59.20,Default,,0,0,0,,我会做什么？
Dialogue: 0,0:55:59.23,0:56:03.33,Default,,0,0,0,,C2是相同的过程
Dialogue: 0,0:56:03.33,0:56:04.48,Default,,0,0,0,,但这个N
Dialogue: 0,0:56:05.33,0:56:06.57,Default,,0,0,0,,它变成了11
Dialogue: 0,0:56:10.97,0:56:14.59,Default,,0,0,0,,所以返回值是11
Dialogue: 0,0:56:15.92,0:56:18.32,Default,,0,0,0,,然后我们再来调用一下C1
Dialogue: 0,0:56:20.91,0:56:22.56,Default,,0,0,0,,C1是这个
Dialogue: 0,0:56:23.28,0:56:24.16,Default,,0,0,0,,它是2
Dialogue: 0,0:56:27.24,0:56:28.30,Default,,0,0,0,,所以结果是2
Dialogue: 0,0:56:29.66,0:56:30.75,Default,,0,0,0,,然后调用C2
Dialogue: 0,0:56:33.37,0:56:35.31,Default,,0,0,0,,然后C2通过同样的方法 返回了12
Dialogue: 0,0:56:35.74,0:56:37.55,Default,,0,0,0,,它在这里进行查找
Dialogue: 0,0:56:37.55,0:56:39.28,Default,,0,0,0,,发现了N 并把它加1
Dialogue: 0,0:56:41.64,0:56:43.68,Default,,0,0,0,,我拥有的是可计算的对象
Dialogue: 0,0:56:45.21,0:56:46.86,Default,,0,0,0,,它们是两个计数器
Dialogue: 0,0:56:48.96,0:56:51.02,Default,,0,0,0,,每一个都有各自独立的局部状态
Dialogue: 0,0:56:55.48,0:56:56.62,Default,,0,0,0,,我们再进一步
Dialogue: 0,0:56:56.64,0:56:58.52,Default,,0,0,0,,这是个奇怪的东西
Dialogue: 0,0:57:01.12,0:57:02.22,Default,,0,0,0,,什么是对象？
Dialogue: 0,0:57:04.11,0:57:06.12,Default,,0,0,0,,这个概念并不明确
Dialogue: 0,0:57:07.55,0:57:09.45,Default,,0,0,0,,我们倾向于以对象的角度思考
Dialogue: 0,0:57:11.24,0:57:13.32,Default,,0,0,0,,因为这样思考比较经济
Dialogue: 0,0:57:14.62,0:57:17.28,Default,,0,0,0,,这是一种智力上的经济
Dialogue: 0,0:57:18.57,0:57:19.61,Default,,0,0,0,,我是一个对象
Dialogue: 0,0:57:20.99,0:57:22.30,Default,,0,0,0,,你也是一个对象
Dialogue: 0,0:57:23.55,0:57:25.29,Default,,0,0,0,,但我们不是同一个对象
Dialogue: 0,0:57:27.52,0:57:29.64,Default,,0,0,0,,我可以把世界分为两部分
Dialogue: 0,0:57:29.92,0:57:31.85,Default,,0,0,0,,我和你
Dialogue: 0,0:57:31.92,0:57:33.31,Default,,0,0,0,,以及其它的东西
Dialogue: 0,0:57:34.70,0:57:35.26,Default,,0,0,0,,使得
Dialogue: 0,0:57:35.44,0:57:39.50,Default,,0,0,0,,大多数对于我的讨论
Dialogue: 0,0:57:39.68,0:57:40.89,Default,,0,0,0,,不会影响到你
Dialogue: 0,0:57:41.39,0:57:44.67,Default,,0,0,0,,大多数对于你的讨论不会牵涉到我
Dialogue: 0,0:57:45.66,0:57:46.94,Default,,0,0,0,,我有血压
Dialogue: 0,0:57:47.50,0:57:48.38,Default,,0,0,0,,体温
Dialogue: 0,0:57:49.36,0:57:51.48,Default,,0,0,0,,呼吸频率
Dialogue: 0,0:57:53.34,0:57:54.99,Default,,0,0,0,,血液中有确定的血糖值
Dialogue: 0,0:57:56.11,0:57:59.34,Default,,0,0,0,,数不清的 数以千计的状态变量--上百万实际上
Dialogue: 0,0:57:59.37,0:58:00.65,Default,,0,0,0,,我不知道具体有多少
Dialogue: 0,0:58:00.93,0:58:03.48,Default,,0,0,0,,以物理学观点 我拥有大量的状态变量
Dialogue: 0,0:58:04.91,0:58:07.12,Default,,0,0,0,,如果将我视为一个粒子的话
Dialogue: 0,0:58:09.15,0:58:10.64,Default,,0,0,0,,你也有许许多多这样的变量
Dialogue: 0,0:58:12.68,0:58:14.94,Default,,0,0,0,,我们的大多数变量之间是好无联系的
Dialogue: 0,0:58:17.31,0:58:19.50,Default,,0,0,0,,所以可以计算我的属性
Dialogue: 0,0:58:20.56,0:58:22.83,Default,,0,0,0,,而不用太担心你的属性
Dialogue: 0,0:58:23.82,0:58:25.77,Default,,0,0,0,,如果把我们两个放在一起计算
Dialogue: 0,0:58:25.96,0:58:27.82,Default,,0,0,0,,那么我们需要考虑的状态的数量
Dialogue: 0,0:58:27.82,0:58:30.01,Default,,0,0,0,,就是你与我的状态的数量的乘积
Dialogue: 0,0:58:30.52,0:58:32.11,Default,,0,0,0,,按对象解耦的话 则只需考虑你我状态之和
Dialogue: 0,0:58:32.65,0:58:35.34,Default,,0,0,0,,然而 实际上有一种力量把我们耦合起来
Dialogue: 0,0:58:36.00,0:58:37.95,Default,,0,0,0,,我对你讲话 你的状态就变了
Dialogue: 0,0:58:38.44,0:58:40.09,Default,,0,0,0,,我看着你 我的状态就变了
Dialogue: 0,0:58:41.72,0:58:44.08,Default,,0,0,0,,因此 我的变量中的一小部分
Dialogue: 0,0:58:44.33,0:58:46.07,Default,,0,0,0,,与你的一些变量是耦合的
Dialogue: 0,0:58:46.07,0:58:47.80,Default,,0,0,0,,如果你突然大喊大叫
Dialogue: 0,0:58:47.80,0:58:48.88,Default,,0,0,0,,我的血压就会升高
Dialogue: 0,0:58:54.30,0:58:56.86,Default,,0,0,0,,然而 将世界看作是由独立的变量
Dialogue: 0,0:58:57.17,0:59:01.16,Default,,0,0,0,,和独立的粒子组成的是不恰当的
Dialogue: 0,0:59:02.12,0:59:04.46,Default,,0,0,0,,在像量子力学这样的东西里存在大量的BUG
Dialogue: 0,0:59:05.23,0:59:08.70,Default,,0,0,0,,或者当我们思考像量子力学之类的东西的时候 会在我们的脑海中产生bug
Dialogue: 0,0:59:08.89,0:59:10.97,Default,,0,0,0,,这是由于 当我们思考事物时
Dialogue: 0,0:59:10.97,0:59:12.96,Default,,0,0,0,,会去将事物分解为相互独立的部分来看待
Dialogue: 0,0:59:13.58,0:59:17.32,Default,,0,0,0,,而事实上事物的耦合程度 远远大于在表面所看到的
Dialogue: 0,0:59:18.01,0:59:19.44,Default,,0,0,0,,即便这样 我们仍像那样思考
Dialogue: 0,0:59:19.61,0:59:21.69,Default,,0,0,0,,是因为我们希望高效并且有效的进行计算
Dialogue: 0,0:59:22.19,0:59:23.82,Default,,0,0,0,,我们被培养成以那种方式进行思考
Dialogue: 0,0:59:29.76,0:59:30.51,Default,,0,0,0,,大家看
Dialogue: 0,0:59:31.50,0:59:33.44,Default,,0,0,0,,我们如何才能知道我们是否有对象？
Dialogue: 0,0:59:35.12,0:59:37.34,Default,,0,0,0,,如果我们有对象 应该如何分辨呢？
Dialogue: 0,0:59:37.64,0:59:41.45,Default,,0,0,0,,通过思考一些光学现象
Dialogue: 0,0:59:42.46,0:59:43.13,Default,,0,0,0,,就能解答这个问题
Dialogue: 0,0:59:45.04,0:59:47.69,Default,,0,0,0,,这几截粉笔不完全相同
Dialogue: 0,0:59:47.76,0:59:50.20,Default,,0,0,0,,但假设 只通过观察是无法区分它们的
Dialogue: 0,0:59:52.04,0:59:53.32,Default,,0,0,0,,有一种可能
Dialogue: 0,0:59:53.32,0:59:55.16,Default,,0,0,0,,是这一切都是我们与镜子的游戏
Dialogue: 0,0:59:56.07,0:59:57.60,Default,,0,0,0,,它们真的是同一截粉笔
Dialogue: 0,0:59:59.36,1:00:00.48,Default,,0,0,0,,但你看到了两个
Dialogue: 0,1:00:01.61,1:00:03.87,Default,,0,0,0,,你怎么知道你看到的是一个还是两个呢？
Dialogue: 0,1:00:05.04,1:00:06.70,Default,,0,0,0,,我只知道有一种方法可以确定
Dialogue: 0,1:00:07.37,1:00:08.94,Default,,0,0,0,,抓起其中一个并且改变它
Dialogue: 0,1:00:09.45,1:00:10.67,Default,,0,0,0,,然后看看另一个有没有跟着变化
Dialogue: 0,1:00:14.01,1:00:14.67,Default,,0,0,0,,而另一个没有变化
Dialogue: 0,1:00:15.50,1:00:16.14,Default,,0,0,0,,所以它们是两截不同粉笔
Dialogue: 0,1:00:19.50,1:00:20.16,Default,,0,0,0,,另一方面
Dialogue: 0,1:00:20.17,1:00:22.20,Default,,0,0,0,,事物还有一些其它的类似的纠结属性
Dialogue: 0,1:00:22.57,1:00:24.01,Default,,0,0,0,,例如 我们怎么才知道某个东西是否改变了呢？
Dialogue: 0,1:00:25.00,1:00:27.93,Default,,0,0,0,,我们需要在它改变之前和之后进行观察
Dialogue: 0,1:00:28.65,1:00:30.02,Default,,0,0,0,,改变就是赋值
Dialogue: 0,1:00:30.02,1:00:31.45,Default,,0,0,0,,它是时间中的一个时刻
Dialogue: 0,1:00:32.14,1:00:34.60,Default,,0,0,0,,但是那意味着我们需要知道 我们看到的是否是同一个
Dialogue: 0,1:00:36.51,1:00:38.84,Default,,0,0,0,,所以一些东西非常奇怪
Dialogue: 0,1:00:38.84,1:00:40.38,Default,,0,0,0,,不同寻常并且晦涩难懂
Dialogue: 0,1:00:40.84,1:00:43.52,Default,,0,0,0,,并且我不理解与赋值
Dialogue: 0,1:00:44.45,1:00:46.28,Default,,0,0,0,,变化以及对象有关的问题
Dialogue: 0,1:00:47.29,1:00:48.99,Default,,0,0,0,,这些东西可能变得非常非常糟糕
Dialogue: 0,1:00:51.40,1:00:52.12,Default,,0,0,0,,例如
Dialogue: 0,1:00:53.31,1:00:55.60,Default,,0,0,0,,我 一个特定的人
Dialogue: 0,1:00:56.16,1:00:57.72,Default,,0,0,0,,一个特定的对象
Dialogue: 0,1:00:57.96,1:00:59.31,Default,,0,0,0,,现在 我可以拿出小刀
Dialogue: 0,1:01:00.68,1:01:01.77,Default,,0,0,0,,切下一片我的指甲
Dialogue: 0,1:01:01.89,1:01:04.81,Default,,0,0,0,,一片指甲掉在了桌子上
Dialogue: 0,1:01:05.93,1:01:10.16,Default,,0,0,0,,我相信自己和一秒钟之前的自己 是同一个人
Dialogue: 0,1:01:10.97,1:01:12.81,Default,,0,0,0,,但在物理上并不是分毫不差
Dialogue: 0,1:01:14.46,1:01:15.43,Default,,0,0,0,,我已经改变了
Dialogue: 0,1:01:15.58,1:01:16.65,Default,,0,0,0,,为什么我还是同一个人呢？
Dialogue: 0,1:01:18.11,1:01:19.40,Default,,0,0,0,,什么能认定我的身份呢？
Dialogue: 0,1:01:20.96,1:01:23.50,Default,,0,0,0,,我不知道
Dialogue: 0,1:01:25.05,1:01:27.88,Default,,0,0,0,,除非我有某种特征
Dialogue: 0,1:01:29.71,1:01:33.04,Default,,0,0,0,,我觉得 由于引入赋值和对象
Dialogue: 0,1:01:33.64,1:01:38.28,Default,,0,0,0,,我们不得不去面对这种
Dialogue: 0,1:01:38.41,1:01:42.24,Default,,0,0,0,,困扰了哲学家们上千年的哲学问题
Dialogue: 0,1:01:43.42,1:01:44.99,Default,,0,0,0,,这也是相比之下 为什么数学清晰得多
Dialogue: 0,1:01:45.69,1:01:50.24,Default,,0,0,0,,我将尽我所能地向大家阐述关于动作和身份的理解
Dialogue: 0,1:01:52.44,1:01:55.39,Default,,0,0,0,,我们说动作A 对于对于某个对象X有影响
Dialogue: 0,1:01:55.77,1:01:56.70,Default,,0,0,0,,换句话说
Dialogue: 0,1:01:56.92,1:01:58.41,Default,,0,0,0,,X被A改变
Dialogue: 0,1:01:58.89,1:02:01.66,Default,,0,0,0,,如果某个属性P 在P作用于X之前为真
Dialogue: 0,1:02:01.87,1:02:03.76,Default,,0,0,0,,在A作用于X之后为假
Dialogue: 0,1:02:04.99,1:02:05.63,Default,,0,0,0,,那是个测试
Dialogue: 0,1:02:06.62,1:02:09.66,Default,,0,0,0,,这也意味着 我必须有变动前和变动后的X
Dialogue: 0,1:02:10.91,1:02:12.54,Default,,0,0,0,,或者 换句话说
Dialogue: 0,1:02:12.94,1:02:14.94,Default,,0,0,0,,我们说对任一动作 两个对象X和Y是同一个对象
Dialogue: 0,1:02:14.97,1:02:17.93,Default,,0,0,0,,当且仅当 该动作对X、Y有同样的影响
Dialogue: 0,1:02:19.63,1:02:21.39,Default,,0,0,0,,然而 就像我说的
Dialogue: 0,1:02:21.44,1:02:23.18,Default,,0,0,0,,对象在智力经济上是非常有用的
Dialogue: 0,1:02:24.64,1:02:27.12,Default,,0,0,0,,对于它们来说非常有用的东西之一
Dialogue: 0,1:02:28.27,1:02:29.44,Default,,0,0,0,,就是对于这个世界
Dialogue: 0,1:02:30.78,1:02:34.80,Default,,0,0,0,,我们习惯于把它认为是由带有独立状态的独立对象所构成的
Dialogue: 0,1:02:35.00,1:02:37.28,Default,,0,0,0,,虽然那并不完全正确 但我们喜欢以那样的的方式来思考
Dialogue: 0,1:02:39.68,1:02:42.03,Default,,0,0,0,,当我们要写一个非常复杂的程序
Dialogue: 0,1:02:42.03,1:02:43.26,Default,,0,0,0,,来应对这样一个世界时
Dialogue: 0,1:02:43.98,1:02:46.44,Default,,0,0,0,,如果我们希望这些程序可以被我们理解
Dialogue: 0,1:02:46.91,1:02:48.14,Default,,0,0,0,,并且也是可修改的
Dialogue: 0,1:02:48.73,1:02:51.12,Default,,0,0,0,,那么如果世界改变了 我们只需要稍微改动一下程序
Dialogue: 0,1:02:51.39,1:02:53.70,Default,,0,0,0,,我们希望建立一种联系 一种同构
Dialogue: 0,1:02:53.82,1:02:56.88,Default,,0,0,0,,建立在真实世界的对象与我们脑海中的对象之间
Dialogue: 0,1:02:58.76,1:03:01.44,Default,,0,0,0,,世界的模块化 使我们的程序得以模块化
Dialogue: 0,1:03:02.41,1:03:05.36,Default,,0,0,0,,所以我们发明了面向对象编程
Dialogue: 0,1:03:05.88,1:03:08.36,Default,,0,0,0,,使我们获得那样的力量
Dialogue: 0,1:03:10.06,1:03:10.94,Default,,0,0,0,,但是 它甚至更简单
Dialogue: 0,1:03:10.94,1:03:12.25,Default,,0,0,0,,让我们玩一个小游戏
Dialogue: 0,1:03:12.27,1:03:13.18,Default,,0,0,0,,我想通过这个游戏
Dialogue: 0,1:03:13.39,1:03:15.77,Default,,0,0,0,,给你展示一个更简单的例子
Dialogue: 0,1:03:16.00,1:03:21.74,Default,,0,0,0,,来说明谨慎地使用赋值语句 可以增强模块性
Dialogue: 0,1:03:22.86,1:03:25.35,Default,,0,0,0,,有一件事 我想让你牢牢地铭记
Dialogue: 0,1:03:25.45,1:03:27.44,Default,,0,0,0,,就是不要像在FORTRAN Basic
Dialogue: 0,1:03:27.45,1:03:29.79,Default,,0,0,0,,或者Pascal里一样使用赋值语句
Dialogue: 0,1:03:30.00,1:03:31.71,Default,,0,0,0,,你不那样做 也能达到目的
Dialogue: 0,1:03:34.04,1:03:36.62,Default,,0,0,0,,这不是思考大多数事情的正确方式
Dialogue: 0,1:03:36.97,1:03:38.28,Default,,0,0,0,,有些时候它是必要的
Dialogue: 0,1:03:38.68,1:03:39.69,Default,,0,0,0,,或者可能是必要的
Dialogue: 0,1:03:39.69,1:03:40.97,Default,,0,0,0,,我们一会更深入地去研究
Dialogue: 0,1:03:42.24,1:03:44.22,Default,,0,0,0,,我要给你展示一个有趣的游戏
Dialogue: 0,1:03:47.61,1:03:49.42,Default,,0,0,0,,从前有一个数学家
Dialogue: 0,1:03:49.68,1:03:53.69,Default,,0,0,0,,叫做Cesaro
Dialogue: 0,1:03:54.48,1:03:57.45,Default,,0,0,0,,他发现了一个计算pi的巧妙方法
Dialogue: 0,1:03:58.38,1:04:04.30,Default,,0,0,0,,这个方法是说 如果我有两个随机数
Dialogue: 0,1:04:05.24,1:04:06.94,Default,,0,0,0,,两个随机的整数
Dialogue: 0,1:04:07.74,1:04:09.48,Default,,0,0,0,,计算它们的最大公约数
Dialogue: 0,1:04:10.94,1:04:13.24,Default,,0,0,0,,结果可能是1 或者不是1
Dialogue: 0,1:04:13.84,1:04:15.64,Default,,0,0,0,,如果是1 它们没有公约数
Dialogue: 0,1:04:18.14,1:04:20.68,Default,,0,0,0,,如果它们的最大公约数是1
Dialogue: 0,1:04:21.12,1:04:23.09,Default,,0,0,0,,这两个随机数
Dialogue: 0,1:04:23.09,1:04:26.38,Default,,0,0,0,,两个随机生成的数 最大公约数为1的概率
Dialogue: 0,1:04:26.58,1:04:27.82,Default,,0,0,0,,与pi有关系
Dialogue: 0,1:04:29.32,1:04:30.11,Default,,0,0,0,,事实上
Dialogue: 0,1:04:31.11,1:04:32.33,Default,,0,0,0,,是的 这很奇怪
Dialogue: 0,1:04:32.94,1:04:34.41,Default,,0,0,0,,当然有其他计算pi的方法
Dialogue: 0,1:04:34.41,1:04:38.94,Default,,0,0,0,,像投针法之类的的方法
Dialogue: 0,1:04:40.19,1:04:48.97,Default,,0,0,0,,N1和N2的最大公约数是1的概率为
Dialogue: 0,1:04:49.44,1:04:51.02,Default,,0,0,0,,N1、N2是随机选取的两个数
Dialogue: 0,1:04:51.71,1:04:53.66,Default,,0,0,0,,是6/pi^2
Dialogue: 0,1:04:55.61,1:04:56.83,Default,,0,0,0,,我不准备证明这个
Dialogue: 0,1:04:57.15,1:04:59.64,Default,,0,0,0,,事实上这不难 并且有些有趣
Dialogue: 0,1:05:01.07,1:05:03.05,Default,,0,0,0,,我们要怎样估算这个概率呢？
Dialogue: 0,1:05:03.53,1:05:06.46,Default,,0,0,0,,我们估算概率的方法则是
Dialogue: 0,1:05:07.23,1:05:08.65,Default,,0,0,0,,是做大量的实验
Dialogue: 0,1:05:09.20,1:05:12.01,Default,,0,0,0,,去计算成功的试验
Dialogue: 0,1:05:12.01,1:05:13.58,Default,,0,0,0,,与试验总次数的比率
Dialogue: 0,1:05:16.32,1:05:17.28,Default,,0,0,0,,这种方法叫做蒙特卡洛方法
Dialogue: 0,1:05:18.04,1:05:22.38,Default,,0,0,0,,它也可以用于计算包含大量变量的积分
Dialogue: 0,1:05:22.94,1:05:25.28,Default,,0,0,0,,其中积分的面积是限定的
Dialogue: 0,1:05:26.27,1:05:28.70,Default,,0,0,0,,回到这里
Dialogue: 0,1:05:29.76,1:05:31.72,Default,,0,0,0,,我们来看看这张幻灯片
Dialogue: 0,1:05:33.96,1:05:36.92,Default,,0,0,0,,我们可以用Cesaro的方法来估算pi的值
Dialogue: 0,1:05:37.19,1:05:43.18,Default,,0,0,0,,通过N次试验 取结果的六分之一 开根号
Dialogue: 0,1:05:43.29,1:05:46.46,Default,,0,0,0,,用蒙特卡洛方法
Dialogue: 0,1:05:46.80,1:05:50.38,Default,,0,0,0,,进行了N次Cesaro实验
Dialogue: 0,1:05:51.37,1:05:57.56,Default,,0,0,0,,这个实验是关于两个随机数的最大公约数的--
Dialogue: 0,1:05:58.96,1:06:01.60,Default,,0,0,0,,你可以看到 我已经在这里进行了一些赋值
Dialogue: 0,1:06:01.84,1:06:03.13,Default,,0,0,0,,就像我写的这样
Dialogue: 0,1:06:04.04,1:06:07.49,Default,,0,0,0,,这个在括号中的RAND
Dialogue: 0,1:06:07.49,1:06:09.09,Default,,0,0,0,,这个过程调用
Dialogue: 0,1:06:09.09,1:06:11.39,Default,,0,0,0,,生成了一个与这个RAND不同的值
Dialogue: 0,1:06:11.39,1:06:13.72,Default,,0,0,0,,至少是我写的这样所假设的
Dialogue: 0,1:06:14.62,1:06:16.75,Default,,0,0,0,,这表明这不是一个函数
Dialogue: 0,1:06:18.20,1:06:20.57,Default,,0,0,0,,这里面会有一个不断改变内部状态
Dialogue: 0,1:06:22.27,1:06:28.64,Default,,0,0,0,,如果两个随机数的最大公约数等于1
Dialogue: 0,1:06:28.64,1:06:29.79,Default,,0,0,0,,这就是整个实验过程
Dialogue: 0,1:06:31.48,1:06:35.18,Default,,0,0,0,,那么我有了一个实验方法 用来估算pi的值
Dialogue: 0,1:06:36.51,1:06:39.72,Default,,0,0,0,,我可以轻松地将这个问题分为两个部分
Dialogue: 0,1:06:40.02,1:06:44.70,Default,,0,0,0,,一部分是使用蒙特卡洛方法进行特定的Cesaro实验 就像你刚才看到那个
Dialogue: 0,1:06:44.99,1:06:48.56,Default,,0,0,0,,另一部分就是一般性蒙特卡洛方法的实现
Dialogue: 0,1:06:49.16,1:06:50.27,Default,,0,0,0,,就是这个
Dialogue: 0,1:06:51.04,1:06:55.47,Default,,0,0,0,,如果我想进行N次蒙特卡洛试验
Dialogue: 0,1:06:55.67,1:06:58.36,Default,,0,0,0,,即一个确定的试验次数 和一个确定的实验
Dialogue: 0,1:06:59.31,1:07:00.33,Default,,0,0,0,,我进行实验的方法就是
Dialogue: 0,1:07:00.84,1:07:02.70,Default,,0,0,0,,构建一个迭代过程
Dialogue: 0,1:07:03.31,1:07:07.26,Default,,0,0,0,,这个过程有两个变量 分别是试验的剩余次数和通过次数
Dialogue: 0,1:07:08.35,1:07:09.44,Default,,0,0,0,,也就是实验结果为真的次数
Dialogue: 0,1:07:10.13,1:07:12.21,Default,,0,0,0,,如果剩余次数为0
Dialogue: 0,1:07:12.21,1:07:15.36,Default,,0,0,0,,结果就是通过的次数除以总次数
Dialogue: 0,1:07:16.04,1:07:17.52,Default,,0,0,0,,也就是该概率的估算值
Dialogue: 0,1:07:19.07,1:07:20.04,Default,,0,0,0,,如果剩余次数不是0
Dialogue: 0,1:07:20.04,1:07:22.08,Default,,0,0,0,,如果还有试验要做
Dialogue: 0,1:07:22.08,1:07:23.82,Default,,0,0,0,,那么接下来我们就进行一次试验
Dialogue: 0,1:07:23.85,1:07:27.30,Default,,0,0,0,,我们调用一次没有参数的实验的过程
Dialogue: 0,1:07:27.30,1:07:28.43,Default,,0,0,0,,我们进行这个试验
Dialogue: 0,1:07:29.10,1:07:30.64,Default,,0,0,0,,如果实验结果为真
Dialogue: 0,1:07:30.82,1:07:32.25,Default,,0,0,0,,我们继续循环
Dialogue: 0,1:07:32.62,1:07:35.42,Default,,0,0,0,,试验剩余次数减1
Dialogue: 0,1:07:35.70,1:07:37.48,Default,,0,0,0,,将试验通过次数加1
Dialogue: 0,1:07:38.57,1:07:40.11,Default,,0,0,0,,如果试验的结果为假
Dialogue: 0,1:07:40.41,1:07:42.25,Default,,0,0,0,,我们继续循环
Dialogue: 0,1:07:42.32,1:07:44.38,Default,,0,0,0,,剩余试验次数减1
Dialogue: 0,1:07:44.44,1:07:46.60,Default,,0,0,0,,试验通过次数保持不变
Dialogue: 0,1:07:48.76,1:07:54.59,Default,,0,0,0,,我们以TRIAL为剩余次数 以0为通过次数 开始迭代
Dialogue: 0,1:07:55.42,1:07:57.10,Default,,0,0,0,,多么简洁的小程序啊
Dialogue: 0,1:07:57.74,1:08:00.55,Default,,0,0,0,,我不一定非要进行Cesaro的实验
Dialogue: 0,1:08:00.55,1:08:02.73,Default,,0,0,0,,它可以用来进行很多种蒙特卡洛实验
Dialogue: 0,1:08:03.36,1:08:07.12,Default,,0,0,0,,当然 它依赖于某种随机数生成器的存在
Dialogue: 0,1:08:07.34,1:08:10.99,Default,,0,0,0,,随机数生成器通常是像这种的东西
Dialogue: 0,1:08:13.60,1:08:16.32,Default,,0,0,0,,这是一个随机数生成器--
Dialogue: 0,1:08:17.42,1:08:25.21,Default,,0,0,0,,它实际上就是一个过程 具体行为跟计数器有些相似
Dialogue: 0,1:08:25.61,1:08:27.52,Default,,0,0,0,,它会把X的值更新为
Dialogue: 0,1:08:28.33,1:08:31.82,Default,,0,0,0,,将某个函数应用于X的结果
Dialogue: 0,1:08:32.20,1:08:35.28,Default,,0,0,0,,而这类古怪的函数
Dialogue: 0,1:08:35.39,1:08:40.16,Default,,0,0,0,,你可以在Kunth写的关于编程细节的书中找到
Dialogue: 0,1:08:41.56,1:08:45.75,Default,,0,0,0,,他写的书绝妙而充满了编程细节
Dialogue: 0,1:08:45.75,1:08:48.52,Default,,0,0,0,,虽然我记不住随机数生成器该怎样写
Dialogue: 0,1:08:48.63,1:08:50.62,Default,,0,0,0,,但我可以在书里找出一个来用
Dialogue: 0,1:08:51.64,1:08:54.01,Default,,0,0,0,,最后 我返回了X的值
Dialogue: 0,1:08:54.08,1:08:57.40,Default,,0,0,0,,也就是随机数生成器的内部状态变量
Dialogue: 0,1:08:58.28,1:09:00.75,Default,,0,0,0,,这个状态变量以某种方式被初始化
Dialogue: 0,1:09:01.32,1:09:02.24,Default,,0,0,0,,从而获得了一个值
Dialogue: 0,1:09:03.39,1:09:08.11,Default,,0,0,0,,这个过程被定义在那个变量被约束的上下文中
Dialogue: 0,1:09:10.41,1:09:15.26,Default,,0,0,0,,所以你在这看到的 是一个隐藏的局部状态
Dialogue: 0,1:09:15.87,1:09:20.24,Default,,0,0,0,,这个过程定义在那个上下文中
Dialogue: 0,1:09:21.56,1:09:23.66,Default,,0,0,0,,这样做起来非常容易
Dialogue: 0,1:09:24.88,1:09:25.79,Default,,0,0,0,,而且结果也非常好
Dialogue: 0,1:09:25.99,1:09:27.77,Default,,0,0,0,,设想 我不想用赋值
Dialogue: 0,1:09:29.10,1:09:31.47,Default,,0,0,0,,假设我想写一个不带赋值的程序
Dialogue: 0,1:09:32.73,1:09:33.93,Default,,0,0,0,,我将遇到什么困难？
Dialogue: 0,1:09:35.52,1:09:37.40,Default,,0,0,0,,让我们来看看
Dialogue: 0,1:09:37.82,1:09:41.10,Default,,0,0,0,,我要用一下头顶上的投影仪了
Dialogue: 0,1:09:42.06,1:09:42.70,Default,,0,0,0,,多谢
Dialogue: 0,1:09:43.47,1:09:47.66,Default,,0,0,0,,首先 我们来整体看一下 这是一个很庞大的东西
Dialogue: 0,1:09:48.01,1:09:49.90,Default,,0,0,0,,它告诉你有某些东西出了问题
Dialogue: 0,1:09:50.96,1:09:52.75,Default,,0,0,0,,毕竟有这么大一堆东西呢
Dialogue: 0,1:09:53.42,1:09:54.60,Default,,0,0,0,,庞大而单一
Dialogue: 0,1:09:56.76,1:10:00.12,Default,,0,0,0,,你不需要现在去理解或看这里的文本
Dialogue: 0,1:10:00.12,1:10:01.39,Default,,0,0,0,,就把它们看做一个整体
Dialogue: 0,1:10:01.92,1:10:04.89,Default,,0,0,0,,它不是Cesaro的实验
Dialogue: 0,1:10:04.89,1:10:07.90,Default,,0,0,0,,它不是从蒙特卡洛过程中抽取出来的
Dialogue: 0,1:10:09.87,1:10:11.84,Default,,0,0,0,,它不是分离的 让我们来看看为什么
Dialogue: 0,1:10:14.22,1:10:15.85,Default,,0,0,0,,记住 这里的约束是
Dialogue: 0,1:10:15.85,1:10:17.87,Default,,0,0,0,,每个过程
Dialogue: 0,1:10:18.69,1:10:22.20,Default,,0,0,0,,对于同样的参数 将返回同样的值
Dialogue: 0,1:10:22.97,1:10:24.75,Default,,0,0,0,,每个过程就是一个函数
Dialogue: 0,1:10:26.92,1:10:28.50,Default,,0,0,0,,那是另一种约束
Dialogue: 0,1:10:28.50,1:10:31.21,Default,,0,0,0,,因为当我赋值时 我可以改变一些内部状态变量
Dialogue: 0,1:10:31.74,1:10:34.03,Default,,0,0,0,,所以让我们来看看它是怎么出错的
Dialogue: 0,1:10:35.04,1:10:36.14,Default,,0,0,0,,我们从头开始
Dialogue: 0,1:10:37.50,1:10:41.92,Default,,0,0,0,,估算pi的过程看起来是一样的
Dialogue: 0,1:10:42.66,1:10:45.88,Default,,0,0,0,,我取RAMDOM-GCD-TEST应用于N
Dialogue: 0,1:10:46.35,1:10:50.22,Default,,0,0,0,,的结果分之6的平方根
Dialogue: 0,1:10:50.74,1:10:51.93,Default,,0,0,0,,就是这个
Dialogue: 0,1:10:52.96,1:10:55.20,Default,,0,0,0,,在这里 我们开始看到了一些有趣的东西
Dialogue: 0,1:10:55.20,1:10:57.93,Default,,0,0,0,,对于以TRAILS为参数的RANDOM-GCD-TEST过程
Dialogue: 0,1:10:58.32,1:10:59.98,Default,,0,0,0,,就像我们之前做的一样
Dialogue: 0,1:11:00.46,1:11:04.66,Default,,0,0,0,,是一个以剩余次数
Dialogue: 0,1:11:04.66,1:11:06.80,Default,,0,0,0,,通过次数
Dialogue: 0,1:11:08.27,1:11:09.71,Default,,0,0,0,,另一个变量X为基准的迭代
Dialogue: 0,1:11:10.75,1:11:11.76,Default,,0,0,0,,这个X是什么？
Dialogue: 0,1:11:12.33,1:11:15.20,Default,,0,0,0,,X是随机数发生器的状态
Dialogue: 0,1:11:19.00,1:11:21.16,Default,,0,0,0,,它会在这里被使用
Dialogue: 0,1:11:21.16,1:11:23.79,Default,,0,0,0,,这里的同样的随机更新函数
Dialogue: 0,1:11:23.79,1:11:27.15,Default,,0,0,0,,来自于一个我另外写的随机数发生器
Dialogue: 0,1:11:27.71,1:11:29.32,Default,,0,0,0,,或者从Knuth的书中找一个
Dialogue: 0,1:11:31.56,1:11:33.36,Default,,0,0,0,,X将转化为X1
Dialogue: 0,1:11:33.37,1:11:34.36,Default,,0,0,0,,但我需要两个随机数
Dialogue: 0,1:11:34.81,1:11:36.92,Default,,0,0,0,,X1将被转化为X2
Dialogue: 0,1:11:37.26,1:11:38.44,Default,,0,0,0,,我有两个随机数
Dialogue: 0,1:11:39.50,1:11:42.14,Default,,0,0,0,,然后进行和之前一样的步骤
Dialogue: 0,1:11:42.52,1:11:44.19,Default,,0,0,0,,取X1和X2的最大公约数
Dialogue: 0,1:11:44.22,1:11:47.15,Default,,0,0,0,,如果结果是1 则将X2作为下一个X的值继续循环
Dialogue: 0,1:11:54.78,1:11:55.98,Default,,0,0,0,,这里所发生的
Dialogue: 0,1:11:56.88,1:11:58.70,Default,,0,0,0,,随机数发生器的状态
Dialogue: 0,1:11:58.73,1:12:01.70,Default,,0,0,0,,不再被限制于其内部
Dialogue: 0,1:12:01.80,1:12:02.73,Default,,0,0,0,,它已经暴露了出来
Dialogue: 0,1:12:03.33,1:12:05.50,Default,,0,0,0,,它已经被暴露在
Dialogue: 0,1:12:05.50,1:12:10.08,Default,,0,0,0,,我们的的蒙特卡洛实验的过程中
Dialogue: 0,1:12:10.70,1:12:11.87,Default,,0,0,0,,但比那更糟糕的是
Dialogue: 0,1:12:11.87,1:12:16.24,Default,,0,0,0,,同样的 因为它也被包含在我们的Cesaro实验中
Dialogue: 0,1:12:16.78,1:12:19.48,Default,,0,0,0,,它被暴露了两次 因为Cesaro被调用了两次
Dialogue: 0,1:12:20.86,1:12:22.47,Default,,0,0,0,,每次有不同的值
Dialogue: 0,1:12:22.47,1:12:25.16,Default,,0,0,0,,如果我要进行一个合理的实验的话
Dialogue: 0,1:12:26.32,1:12:28.32,Default,,0,0,0,,所以Cesaro也不能成为函数了
Dialogue: 0,1:12:31.04,1:12:35.69,Default,,0,0,0,,除非我把随机数发生器的种子传给它
Dialogue: 0,1:12:36.52,1:12:39.37,Default,,0,0,0,,所以很不幸 随机数发生器的种子
Dialogue: 0,1:12:39.37,1:12:42.77,Default,,0,0,0,,从随机数发生器中暴露到了Cesaro内部
Dialogue: 0,1:12:42.88,1:12:45.16,Default,,0,0,0,,被暴露在蒙特卡洛实验中
Dialogue: 0,1:12:45.64,1:12:49.12,Default,,0,0,0,,很不幸 这里的蒙特卡洛实验不再是通用的了
Dialogue: 0,1:12:50.25,1:12:51.80,Default,,0,0,0,,这里的蒙特卡洛实验
Dialogue: 0,1:12:52.03,1:12:54.73,Default,,0,0,0,,知道了我在实验中需要多少个随机数
Dialogue: 0,1:12:58.96,1:12:59.74,Default,,0,0,0,,这真的很糟糕
Dialogue: 0,1:13:00.08,1:13:02.54,Default,,0,0,0,,我失去了将问题分解开来的能力
Dialogue: 0,1:13:03.44,1:13:09.12,Default,,0,0,0,,因为我不愿意接受信息的循环
Dialogue: 0,1:13:09.50,1:13:12.43,Default,,0,0,0,,反馈的过程
Dialogue: 0,1:13:12.88,1:13:15.94,Default,,0,0,0,,这之前都是发生在随机数发生器内部
Dialogue: 0,1:13:15.94,1:13:21.21,Default,,0,0,0,,也就是赋值给一个限制在随机数生成器内部的状态变量
Dialogue: 0,1:13:22.92,1:13:25.48,Default,,0,0,0,,所以实际上 随机数发生器是一个对象
Dialogue: 0,1:13:25.92,1:13:27.37,Default,,0,0,0,,它有一个内部状态变量
Dialogue: 0,1:13:28.06,1:13:29.36,Default,,0,0,0,,它不受任何东西影响
Dialogue: 0,1:13:29.37,1:13:31.60,Default,,0,0,0,,但是它会给你某些东西 把它的力量赐予你
Dialogue: 0,1:13:32.80,1:13:34.28,Default,,0,0,0,,那是我们现在缺少的
Dialogue: 0,1:13:38.00,1:13:40.73,Default,,0,0,0,,好 我认为我已经知道了
Dialogue: 0,1:13:40.73,1:13:42.30,Default,,0,0,0,,引入赋值的充分理由
Dialogue: 0,1:13:42.83,1:13:45.24,Default,,0,0,0,,并且一些看起来很圆满
Dialogue: 0,1:13:45.38,1:13:50.70,Default,,0,0,0,,如果赋值是一个好东西
Dialogue: 0,1:13:51.74,1:13:53.04,Default,,0,0,0,,并且赋值是值得的 这不是很好吗？
Dialogue: 0,1:13:53.28,1:13:54.14,Default,,0,0,0,,我不是很确定
Dialogue: 0,1:13:55.34,1:13:57.04,Default,,0,0,0,,Mr. Gilbert和Sullivan说过
Dialogue: 0,1:13:57.04,1:13:58.51,Default,,0,0,0,,事物往往不像表面看到的那样
Dialogue: 0,1:13:58.51,1:14:00.35,Default,,0,0,0,,脱脂牛奶也能装成奶油
Dialogue: 0,1:14:01.87,1:14:03.90,Default,,0,0,0,,谁有什么问题吗？
Dialogue: 0,1:14:16.97,1:14:18.30,Default,,0,0,0,,在座的有哲学家吗？
Dialogue: 0,1:14:20.06,1:14:22.03,Default,,0,0,0,,有人想要讨论有关“对象”的问题吗？
Dialogue: 0,1:14:24.32,1:14:25.50,Default,,0,0,0,,你们已经一头雾水了是吧？
Dialogue: 0,1:14:29.72,1:14:30.72,Default,,0,0,0,,你们还没有完成家庭作业呢
Dialogue: 0,1:14:30.73,1:14:32.00,Default,,0,0,0,,你们需要提一个好问题
Dialogue: 0,1:14:36.35,1:14:37.44,Default,,0,0,0,,好了
Dialogue: 0,1:14:39.97,1:14:42.33,Default,,0,0,0,,感谢你们 我们下课吧
Dialogue: 0,1:14:47.90,1:15:05.69,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:14:47.90,1:15:05.69,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
