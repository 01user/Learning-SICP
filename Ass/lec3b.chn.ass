[Script Info]
; Script generated by Aegisub 3.0.4
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
Collisions: Normal
Last Style Storage: Default
Scroll Position: 583
Active Line: 593
Video Zoom Percent: 0.625
Audio URI: G:\untitled\ref\lec3b_480_muxed2.mp4
Video File: G:\untitled\ref\lec3b_480_muxed2.mp4
Video Aspect Ratio: c1.33333
Video Position: 79137
PlayResX: 640
PlayResY: 480
YCbCr Matrix: TV.601

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:02.32,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:02.57,0:00:06.01,Declare,,0,0,0,,{\an2\fad(500,500)}翻译&&时间轴：邓雄飞（Dysprosium）\N压制&&特效：邓雄飞（Dysprosium）\N校对：邓雄飞（Dysprosium）
Dialogue: 0,0:00:06.06,0:00:08.97,Declare,,0,0,0,,{\an2\fad(500,500)}特别感谢：裘宗燕教授
Dialogue: 0,0:00:11.24,0:00:14.46,Declare,,0,0,0,,{\an2\fad(500,500)}符号化求导系统，引用
Dialogue: 0,0:00:19.10,0:00:23.41,Default,,0,0,0,,教授：嗯 Harold教授讲解了如何构造健壮的系统
Dialogue: 0,0:00:23.80,0:00:26.17,Default,,0,0,0,,关键点就是
Dialogue: 0,0:00:26.81,0:00:30.20,Default,,0,0,0,,我想你们大多还没吃透其中的要点
Dialogue: 0,0:00:30.20,0:00:33.77,Default,,0,0,0,,要点就是 为了让系统具有健壮性
Dialogue: 0,0:00:33.93,0:00:36.48,Default,,0,0,0,,应该让它对小变化不敏感
Dialogue: 0,0:00:36.60,0:00:37.37,Default,,0,0,0,,也就是说
Dialogue: 0,0:00:37.37,0:00:40.90,Default,,0,0,0,,问题中的小改变只会导致解决方案的小改动
Dialogue: 0,0:00:41.32,0:00:42.90,Default,,0,0,0,,系统应该是连续的
Dialogue: 0,0:00:42.90,0:00:45.94,Default,,0,0,0,,在问题空间中 解的空间是连续的
Dialogue: 0,0:00:46.25,0:00:48.76,Default,,0,0,0,,Harold教授给你们解释过
Dialogue: 0,0:00:49.46,0:00:54.78,Default,,0,0,0,,与其在问题分解出的子问题上 求解具体问题
Dialogue: 0,0:00:55.08,0:00:56.78,Default,,0,0,0,,你不如解决一类问题
Dialogue: 0,0:00:56.78,0:01:00.40,Default,,0,0,0,,也就是你想要解决的具体问题的“邻居”
Dialogue: 0,0:01:01.40,0:01:04.76,Default,,0,0,0,,解决之道便是在该层次上构造一门语言
Dialogue: 0,0:01:04.76,0:01:10.33,Default,,0,0,0,,使得我们可以用这门语言来表述这类问题
Dialogue: 0,0:01:11.37,0:01:15.09,Default,,0,0,0,,因此 当着手解决的问题再发生变动时
Dialogue: 0,0:01:15.09,0:01:19.29,Default,,0,0,0,,通常 你只需要在已构造好的解决方案上做出微小改动
Dialogue: 0,0:01:19.29,0:01:22.26,Default,,0,0,0,,因为在你所考虑的层次上
Dialogue: 0,0:01:22.26,0:01:24.26,Default,,0,0,0,,有一门语言可以表达
Dialogue: 0,0:01:24.80,0:01:28.14,Default,,0,0,0,,类似问题的各种解法
Dialogue: 0,0:01:30.04,0:01:33.74,Default,,0,0,0,,呃... 这是一个重要思想的萌芽
Dialogue: 0,0:01:34.40,0:01:38.61,Default,,0,0,0,,该思想的重要性也使得计算机科学比
Dialogue: 0,0:01:38.61,0:01:42.37,Default,,0,0,0,,其它大多数工程学科还要强大
Dialogue: 0,0:01:43.38,0:01:44.73,Default,,0,0,0,,目前为止 我们学习的是
Dialogue: 0,0:01:44.73,0:01:48.78,Default,,0,0,0,,类似于 如何使用语言内置元素
Dialogue: 0,0:01:49.26,0:01:53.36,Default,,0,0,0,,当然 内置元素的力量一部分来源于
Dialogue: 0,0:01:54.12,0:01:56.86,Default,,0,0,0,,像这个一样的过程 我昨天给你们展示过了
Dialogue: 0,0:01:57.37,0:02:02.13,Default,,0,0,0,,这里 是一份求导程序 昨天给你们描述过了
Dialogue: 0,0:02:02.13,0:02:05.92,Default,,0,0,0,,这个过程以一个过程为参数
Dialogue: 0,0:02:06.00,0:02:07.92,Default,,0,0,0,,并返回一个过程
Dialogue: 0,0:02:09.61,0:02:12.65,Default,,0,0,0,,用这样的东西棒极了
Dialogue: 0,0:02:12.65,0:02:14.65,Default,,0,0,0,,你可以像创建PUSH组合子那样构造
Dialogue: 0,0:02:14.65,0:02:16.86,Default,,0,0,0,,可以像上节课看到的哪些奇妙东西那样
Dialogue: 0,0:02:17.68,0:02:20.54,Default,,0,0,0,,现在 我要来打个太极
Dialogue: 0,0:02:21.56,0:02:25.90,Default,,0,0,0,,这个程序混淆了过程和数据
Dialogue: 0,0:02:26.56,0:02:27.81,Default,,0,0,0,,虽然程度不算太重
Dialogue: 0,0:02:28.42,0:02:30.90,Default,,0,0,0,,而我们将要严重地混淆两者
Dialogue: 0,0:02:31.18,0:02:32.44,Default,,0,0,0,,最好的做法就是
Dialogue: 0,0:02:32.44,0:02:37.62,Default,,0,0,0,,参与到过程自身所描述的代数表达式的操作中
Dialogue: 0,0:02:39.73,0:02:45.58,Default,,0,0,0,,所以 这里我不会讨论这张幻灯片上的东西
Dialogue: 0,0:02:45.89,0:02:49.72,Default,,0,0,0,,一个通过操作过程的求导程序
Dialogue: 0,0:02:49.72,0:02:51.94,Default,,0,0,0,,这只是一个数值化方法而已
Dialogue: 0,0:02:51.94,0:02:58.93,Default,,0,0,0,,你们所看到的是 通过数值方法来近似的求导程序
Dialogue: 0,0:02:59.29,0:03:00.44,Default,,0,0,0,,也就是这里的东西了
Dialogue: 0,0:03:00.86,0:03:04.93,Default,,0,0,0,,事实上 我想讨论的是这些东西
Dialogue: 0,0:03:06.05,0:03:11.33,Default,,0,0,0,,这是一份从微积分书中摘录的法则
Dialogue: 0,0:03:12.09,0:03:16.17,Default,,0,0,0,,这对表达式求导的法则
Dialogue: 0,0:03:16.70,0:03:20.58,Default,,0,0,0,,只不过是用代数语言书写的
Dialogue: 0,0:03:21.64,0:03:24.41,Default,,0,0,0,,法则说 常数的导数是0
Dialogue: 0,0:03:25.13,0:03:29.09,Default,,0,0,0,,而代表你所讨论的那个数的变量导数为1
Dialogue: 0,0:03:29.32,0:03:31.93,Default,,0,0,0,,常数乘以函数的导数
Dialogue: 0,0:03:32.09,0:03:34.37,Default,,0,0,0,,其值是常数的值乘以函数导数的值
Dialogue: 0,0:03:34.77,0:03:36.04,Default,,0,0,0,,就是这个意思
Dialogue: 0,0:03:38.05,0:03:41.38,Default,,0,0,0,,这些都是精确的表达式 而非数值近似
Dialogue: 0,0:03:42.96,0:03:44.52,Default,,0,0,0,,我们还能编写程序吗？
Dialogue: 0,0:03:44.52,0:03:52.24,Default,,0,0,0,,事实上 编写处理这些表达式的程序非常容易
Dialogue: 0,0:03:56.38,0:03:59.52,Default,,0,0,0,,让我们仔细地看看这些法则
Dialogue: 0,0:04:01.08,0:04:05.22,Default,,0,0,0,,你们曾经在初等微积分课上学过这些法则了
Dialogue: 0,0:04:05.98,0:04:12.12,Default,,0,0,0,,你们知道 微积分中对多元表达式求导很容易
Dialogue: 0,0:04:12.53,0:04:16.05,Default,,0,0,0,,在微积分课上 你们也知道计算积分不容易
Dialogue: 0,0:04:16.98,0:04:19.37,Default,,0,0,0,,虽然积分和求导相对
Dialogue: 0,0:04:19.52,0:04:21.28,Default,,0,0,0,,它俩互为逆运算
Dialogue: 0,0:04:21.61,0:04:23.30,Default,,0,0,0,,但它们有同样的法则
Dialogue: 0,0:04:24.16,0:04:29.68,Default,,0,0,0,,但这些法则中又有什么特殊的东西
Dialogue: 0,0:04:29.68,0:04:33.65,Default,,0,0,0,,使得求导容易 求积分就困难呢？
Dialogue: 0,0:04:34.85,0:04:36.98,Default,,0,0,0,,我们浅显地想一想
Dialogue: 0,0:04:37.40,0:04:38.38,Default,,0,0,0,,仔细考察法则
Dialogue: 0,0:04:39.36,0:04:43.06,Default,,0,0,0,,对于每条法则来说 你求导数时的方向
Dialogue: 0,0:04:43.06,0:04:44.80,Default,,0,0,0,,这个箭头的方向
Dialogue: 0,0:04:46.68,0:04:49.16,Default,,0,0,0,,法则的左边与你的表达式相匹配
Dialogue: 0,0:04:49.16,0:04:53.05,Default,,0,0,0,,法则的右边就是表达式的导数
Dialogue: 0,0:04:54.02,0:04:55.65,Default,,0,0,0,,箭头是这个方向的
Dialogue: 0,0:04:57.37,0:05:00.45,Default,,0,0,0,,每条法则中
Dialogue: 0,0:05:01.24,0:05:03.72,Default,,0,0,0,,法则右边的表达式
Dialogue: 0,0:05:03.72,0:05:06.56,Default,,0,0,0,,都是求导过程中的子表达式
Dialogue: 0,0:05:06.56,0:05:10.29,Default,,0,0,0,,都是左边式子的合法子表达式
Dialogue: 0,0:05:10.60,0:05:13.25,Default,,0,0,0,,这里 我们发现 和的导数
Dialogue: 0,0:05:13.92,0:05:16.13,Default,,0,0,0,,也就是左边式子的导数
Dialogue: 0,0:05:16.13,0:05:18.38,Default,,0,0,0,,就是两部分导数之和
Dialogue: 0,0:05:20.08,0:05:24.49,Default,,0,0,0,,法则从左至右的方向是“归约规则”
Dialogue: 0,0:05:25.02,0:05:26.61,Default,,0,0,0,,问题变简单了
Dialogue: 0,0:05:27.56,0:05:31.48,Default,,0,0,0,,我把一个复杂的问题 转化成了许多小点儿的问题
Dialogue: 0,0:05:32.44,0:05:35.76,Default,,0,0,0,,然后把结果组合起来 这里用递归可以完美地解决
Dialogue: 0,0:05:36.58,0:05:40.85,Default,,0,0,0,,但如果我从另外的方向来思考
Dialogue: 0,0:05:41.81,0:05:45.13,Default,,0,0,0,,如果我想求积分的话 你会发现有很多问题
Dialogue: 0,0:05:45.24,0:05:49.09,Default,,0,0,0,,就比如 如果我想求一个和的积分
Dialogue: 0,0:05:49.21,0:05:50.81,Default,,0,0,0,,就会匹配多条法则
Dialogue: 0,0:05:50.81,0:05:52.10,Default,,0,0,0,,这条匹配
Dialogue: 0,0:05:52.48,0:05:53.65,Default,,0,0,0,,这条也匹配
Dialogue: 0,0:05:54.81,0:05:57.09,Default,,0,0,0,,我不知道该用哪个——它们之间可能不一样
Dialogue: 0,0:05:57.70,0:06:00.00,Default,,0,0,0,,我得考察两者的不同之处
Dialogue: 0,0:06:00.25,0:06:03.64,Default,,0,0,0,,所以 在这个方向上 表达式变复杂了
Dialogue: 0,0:06:04.53,0:06:06.30,Default,,0,0,0,,当表达式变复杂时
Dialogue: 0,0:06:06.30,0:06:10.56,Default,,0,0,0,,就没法保证我所选的路径一定能终止了
Dialogue: 0,0:06:10.94,0:06:13.46,Default,,0,0,0,,因为唯一的可能是偶然的约分
Dialogue: 0,0:06:14.24,0:06:18.05,Default,,0,0,0,,这也就是为什么 积分是一种复杂的搜索 而难以完成
Dialogue: 0,0:06:19.12,0:06:20.96,Default,,0,0,0,,现在我不想处理这么复杂的东西
Dialogue: 0,0:06:21.49,0:06:23.06,Default,,0,0,0,,我们先来讨论求导数
Dialogue: 0,0:06:24.14,0:06:28.13,Default,,0,0,0,,好吧 我就假设你们都大致了解这些法则了
Dialogue: 0,0:06:28.78,0:06:31.88,Default,,0,0,0,,让我们来看看能不能用程序表达这些法则
Dialogue: 0,0:06:32.22,0:06:33.72,Default,,0,0,0,,这应该很容易
Dialogue: 0,0:06:34.89,0:06:36.21,Default,,0,0,0,,信手拈来
Dialogue: 0,0:06:36.69,0:06:39.29,Default,,0,0,0,,因为 我给你们展示的是“归约规则”
Dialogue: 0,0:06:39.29,0:06:41.29,Default,,0,0,0,,这样用递归来编写会比较合适
Dialogue: 0,0:06:43.08,0:06:45.72,Default,,0,0,0,,当然 对每条法则来说就是一种情况
Dialogue: 0,0:06:46.66,0:06:47.78,Default,,0,0,0,,我们做“分情况分析”
Dialogue: 0,0:06:48.58,0:06:50.36,Default,,0,0,0,,我就这么写了
Dialogue: 0,0:06:52.88,0:06:57.69,Default,,0,0,0,,当然 我得先让大家达成共识 对吧？
Dialogue: 0,0:06:57.69,0:07:00.33,Default,,0,0,0,,你们应该意识到到我可以表示这些代数式
Dialogue: 0,0:07:00.68,0:07:03.88,Default,,0,0,0,,我可以从中抽取式子 也可以将它们组合起来
Dialogue: 0,0:07:04.24,0:07:06.49,Default,,0,0,0,,我们发明了表结构来解决这个问题
Dialogue: 0,0:07:07.52,0:07:09.14,Default,,0,0,0,,但现在我们不必关心
Dialogue: 0,0:07:09.66,0:07:12.45,Default,,0,0,0,,现在 我要编写一个程序来封装这些法则
Dialogue: 0,0:07:12.76,0:07:15.85,Default,,0,0,0,,但它不依赖于代数表达式的表示法
Dialogue: 0,0:07:20.42,0:07:28.84,Default,,0,0,0,,(DERIV EXP VAR)表示表达式EXP关于变量VAR的导数
Dialogue: 0,0:07:30.50,0:07:33.08,Default,,0,0,0,,这和函数的导数是不一样的
Dialogue: 0,0:07:34.82,0:07:38.61,Default,,0,0,0,,那个是我们上节课看到的数值近似
Dialogue: 0,0:07:39.00,0:07:40.82,Default,,0,0,0,,并不能看到函数内部
Dialogue: 0,0:07:40.82,0:07:41.89,Default,,0,0,0,,它只是一个数值
Dialogue: 0,0:07:43.09,0:07:45.18,Default,,0,0,0,,表达式的导数也是一个表达式
Dialogue: 0,0:07:45.74,0:07:47.85,Default,,0,0,0,,因此 这只是一个语法问题
Dialogue: 0,0:07:48.29,0:07:51.62,Default,,0,0,0,,我们今天要做的大多数工作 就是讨论语法
Dialogue: 0,0:07:52.33,0:07:54.12,Default,,0,0,0,,表达式的语法或类似
Dialogue: 0,0:07:54.70,0:07:55.93,Default,,0,0,0,,首先要做“分情况分析”
Dialogue: 0,0:07:57.50,0:08:01.08,Default,,0,0,0,,任何时候我们处理复杂事物 需要递归求解时
Dialogue: 0,0:08:01.08,0:08:02.64,Default,,0,0,0,,我们很可能需要“按情况分析”
Dialogue: 0,0:08:03.62,0:08:05.16,Default,,0,0,0,,通常都是这样开始的
Dialogue: 0,0:08:05.16,0:08:07.40,Default,,0,0,0,,复杂的问题都是用“按情况分析”
Dialogue: 0,0:08:08.08,0:08:09.97,Default,,0,0,0,,那么 有哪些可能（的情况）呢？
Dialogue: 0,0:08:09.97,0:08:12.53,Default,,0,0,0,,第一条法则说 如果你遇到一个常数
Dialogue: 0,0:08:16.50,0:08:17.50,Default,,0,0,0,,这里 我就是在判断
Dialogue: 0,0:08:17.50,0:08:22.22,Default,,0,0,0,,表达式EXP是否为给定变量VAR的常数（常量表达式）
Dialogue: 0,0:08:24.90,0:08:27.08,Default,,0,0,0,,是的话 结果就是0
Dialogue: 0,0:08:27.50,0:08:30.10,Default,,0,0,0,,因为导数表征的是某物的变化率
Dialogue: 0,0:08:31.76,0:08:32.65,Default,,0,0,0,,然而
Dialogue: 0,0:08:32.89,0:08:40.69,Default,,0,0,0,,如果我求导的表达式 与我关心的变量有关
Dialogue: 0,0:08:41.72,0:08:50.42,Default,,0,0,0,,如果判定表达式和变量相同
Dialogue: 0,0:08:51.14,0:08:54.52,Default,,0,0,0,,那么关于变量VAR的表达式EXP的变化率就是1
Dialogue: 0,0:08:55.50,0:08:56.54,Default,,0,0,0,,它俩相同 结果是1
Dialogue: 0,0:08:58.90,0:09:00.77,Default,,0,0,0,,当然 还可能有其它的可能性
Dialogue: 0,0:09:01.33,0:09:03.14,Default,,0,0,0,,比如说 它可能是一个和式
Dialogue: 0,0:09:03.86,0:09:05.88,Default,,0,0,0,,呃 我现在还完全知道该如何表示和式
Dialogue: 0,0:09:06.09,0:09:08.25,Default,,0,0,0,,事实上我可以 只是我还没有告诉你们
Dialogue: 0,0:09:10.34,0:09:11.78,Default,,0,0,0,,如果表达式是和式
Dialogue: 0,0:09:12.48,0:09:14.48,Default,,0,0,0,,我就假想有一种方式可以判别（和式）
Dialogue: 0,0:09:15.30,0:09:19.44,Default,,0,0,0,,这里 我要做一个表达式的类型分派
Dialogue: 0,0:09:20.77,0:09:23.57,Default,,0,0,0,,这是在构建语言时绝对必要的
Dialogue: 0,0:09:24.72,0:09:26.37,Default,,0,0,0,,因为语言由不同的表达式构成
Dialogue: 0,0:09:26.48,0:09:27.54,Default,,0,0,0,,我们马上就将看到
Dialogue: 0,0:09:27.84,0:09:31.02,Default,,0,0,0,,如何用更强大的方法 用语言去构建语言
Dialogue: 0,0:09:32.53,0:09:34.02,Default,,0,0,0,,表达式是和式吗？
Dialogue: 0,0:09:35.45,0:09:38.82,Default,,0,0,0,,如果是的话 很好 我们已经知道和式的求导法则了
Dialogue: 0,0:09:38.82,0:09:41.33,Default,,0,0,0,,即是各部分导数之和
Dialogue: 0,0:09:42.13,0:09:44.32,Default,,0,0,0,,其中一个叫做加数 另一个叫做被加数
Dialogue: 0,0:09:44.32,0:09:46.80,Default,,0,0,0,,黑板上没那么多空间写这么长的名字了
Dialogue: 0,0:09:46.80,0:09:48.40,Default,,0,0,0,,我就姑且把它们叫做 A1和A2
Dialogue: 0,0:09:49.04,0:09:50.37,Default,,0,0,0,,把它们求和
Dialogue: 0,0:09:53.53,0:09:55.68,Default,,0,0,0,,（意义不明）
Dialogue: 0,0:09:57.14,0:10:01.09,Default,,0,0,0,,是叫做被除数和除数一类的么？
Dialogue: 0,0:10:01.65,0:10:08.48,Default,,0,0,0,,将A1的导数...加上
Dialogue: 0,0:10:08.48,0:10:13.29,Default,,0,0,0,,这是关于变量VAR的表达式的加数
Dialogue: 0,0:10:14.84,0:10:22.76,Default,,0,0,0,,与A2的导数相加
Dialogue: 0,0:10:24.12,0:10:28.25,Default,,0,0,0,,这两个参数的和 变量是VAR
Dialogue: 0,0:10:32.36,0:10:34.93,Default,,0,0,0,,我们知道还有一条乘法的求导法则
Dialogue: 0,0:10:35.20,0:10:37.44,Default,,0,0,0,,也就是说 如果表达式是乘式
Dialogue: 0,0:10:43.21,0:10:46.10,Default,,0,0,0,,顺便说下 当你定义过程时 有个好习惯
Dialogue: 0,0:10:46.96,0:10:48.32,Default,,0,0,0,,就是在定义谓词时
Dialogue: 0,0:10:48.85,0:10:50.96,Default,,0,0,0,,将谓词名以问号结尾
Dialogue: 0,0:10:51.08,0:10:52.89,Default,,0,0,0,,问号本身不代表什么
Dialogue: 0,0:10:53.10,0:10:54.50,Default,,0,0,0,,但这是俗成的约定
Dialogue: 0,0:10:54.61,0:10:58.94,Default,,0,0,0,,这是人们之间约定的接口 以方便他人阅读你的脚本
Dialogue: 0,0:11:00.05,0:11:01.96,Default,,0,0,0,,我希望你在写程序的时候
Dialogue: 0,0:11:01.96,0:11:03.73,Default,,0,0,0,,当你定义谓词的时候
Dialogue: 0,0:11:04.01,0:11:05.77,Default,,0,0,0,,就是那些返回TRUE或FALSE的过程
Dialogue: 0,0:11:05.94,0:11:07.84,Default,,0,0,0,,你应该使它们的名字以问号结尾
Dialogue: 0,0:11:08.02,0:11:10.34,Default,,0,0,0,,这对Lisp无异 但对人类友好
Dialogue: 0,0:11:11.62,0:11:13.14,Default,,0,0,0,,我需要求和
Dialogue: 0,0:11:13.14,0:11:17.49,Default,,0,0,0,,因为积的导数就是...
Dialogue: 0,0:11:17.94,0:11:19.64,Default,,0,0,0,,M1*DERIV(M2)
Dialogue: 0,0:11:19.66,0:11:20.70,Default,,0,0,0,,+DERIV(M1)*M2
Dialogue: 0,0:11:23.54,0:11:27.06,Default,,0,0,0,,两者加起来
Dialogue: 0,0:11:29.64,0:11:38.33,Default,,0,0,0,,求积... 呃 就用表达式中的M1来表示（被乘数）好了
Dialogue: 0,0:11:39.85,0:11:48.97,Default,,0,0,0,,表达式中M2关于变量VAR的导数
Dialogue: 0,0:11:51.90,0:12:06.28,Default,,0,0,0,,以及 M1关于变量VAR的导数乘以
Dialogue: 0,0:12:07.10,0:12:11.92,Default,,0,0,0,,M1是这里的被乘数
Dialogue: 0,0:12:13.32,0:12:18.05,Default,,0,0,0,,乘数是表达式中的M2
Dialogue: 0,0:12:20.64,0:12:24.89,Default,,0,0,0,,求积完毕、求和完毕、乘式分析完毕
Dialogue: 0,0:12:24.96,0:12:28.02,Default,,0,0,0,,当然 在这里我可以添加更多的情况
Dialogue: 0,0:12:28.32,0:12:30.82,Default,,0,0,0,,微积分书中的完整法则
Dialogue: 0,0:12:34.80,0:12:39.45,Default,,0,0,0,,我们就是这么来封装这些法则的
Dialogue: 0,0:12:41.53,0:12:43.90,Default,,0,0,0,,如你所见 我们这里用到了大量的“按愿望思维”
Dialogue: 0,0:12:44.54,0:12:47.56,Default,,0,0,0,,我们还没有说这些（表达式）是如何表示的
Dialogue: 0,0:12:48.46,0:12:51.92,Default,,0,0,0,,现在 一旦我将其定为我的一套法则
Dialogue: 0,0:12:52.52,0:12:55.20,Default,,0,0,0,,我想是时候考虑表示法了
Dialogue: 0,0:12:55.66,0:12:56.69,Default,,0,0,0,,我们来拿捏拿捏
Dialogue: 0,0:12:57.96,0:13:00.00,Default,,0,0,0,,首先 我要用到一种“双关”思想
Dialogue: 0,0:13:00.90,0:13:02.12,Default,,0,0,0,,这种“双关”思想非常重要
Dialogue: 0,0:13:02.74,0:13:06.56,Default,,0,0,0,,它是一种强有力思想的关键
Dialogue: 0,0:13:09.62,0:13:14.41,Default,,0,0,0,,如果我想表达诸如和、积、差、商的东西
Dialogue: 0,0:13:15.22,0:13:18.62,Default,,0,0,0,,为什么不用和我程序一样的语言呢？
Dialogue: 0,0:13:20.50,0:13:23.64,Default,,0,0,0,,我程序中 代数表达式是形如
Dialogue: 0,0:13:23.98,0:13:30.45,Default,,0,0,0,,(+ (* A (* X X))
Dialogue: 0,0:13:32.60,0:13:33.80,Default,,0,0,0,,和与之类似的
Dialogue: 0,0:13:34.28,0:13:38.50,Default,,0,0,0,,(* B X)以及C
Dialogue: 0,0:13:38.50,0:13:39.97,Default,,0,0,0,,把它们加起来
Dialogue: 0,0:13:40.77,0:13:44.09,Default,,0,0,0,,现在 我的过程还不能处理多元参数
Dialogue: 0,0:13:44.93,0:13:48.46,Default,,0,0,0,,(+ (* B X) C)
Dialogue: 0,0:13:51.42,0:13:52.44,Default,,0,0,0,,这是表结构
Dialogue: 0,0:13:54.12,0:13:55.74,Default,,0,0,0,,这么做很棒 是因为
Dialogue: 0,0:13:55.90,0:13:58.33,Default,,0,0,0,,是因为这些对象都有一种性质
Dialogue: 0,0:13:58.92,0:14:01.53,Default,,0,0,0,,我知道它们的CAR部分是什么
Dialogue: 0,0:14:01.96,0:14:03.21,Default,,0,0,0,,CAR部分就是运算符
Dialogue: 0,0:14:03.92,0:14:06.38,Default,,0,0,0,,运算数是相继的CDR部分
Dialogue: 0,0:14:07.22,0:14:10.36,Default,,0,0,0,,也就是不断取表CDR部分的CAR部分
Dialogue: 0,0:14:12.48,0:14:13.88,Default,,0,0,0,,这样就使它很方便了
Dialogue: 0,0:14:14.01,0:14:16.40,Default,,0,0,0,,我需要去解析它 但它已经帮我完成了
Dialogue: 0,0:14:17.42,0:14:20.01,Default,,0,0,0,,我利用了Lisp中的内建元素
Dialogue: 0,0:14:22.66,0:14:23.77,Default,,0,0,0,,举个例子
Dialogue: 0,0:14:25.08,0:14:33.97,Default,,0,0,0,,我们用表结构来表示我所暗示的表示法吧！
Dialogue: 0,0:14:35.25,0:14:38.34,Default,,0,0,0,,我需要定义一些东西 这都暗含在这种表示法中
Dialogue: 0,0:14:38.54,0:14:40.90,Default,,0,0,0,,比如如何判定是否为常量
Dialogue: 0,0:14:41.21,0:14:42.30,Default,,0,0,0,,又怎么判断是同一个变量
Dialogue: 0,0:14:42.40,0:14:45.04,Default,,0,0,0,,我们先完成这些吧 都相当简单
Dialogue: 0,0:14:45.78,0:14:47.70,Default,,0,0,0,,这里 我要介绍一些基本过程
Dialogue: 0,0:14:48.60,0:14:50.50,Default,,0,0,0,,因为它们都是与表结构相关的
Dialogue: 0,0:14:51.98,0:14:53.46,Default,,0,0,0,,CONSTANT?谓词定义为
Dialogue: 0,0:15:02.25,0:15:04.29,Default,,0,0,0,,我所谓的常量
Dialogue: 0,0:15:04.29,0:15:07.73,Default,,0,0,0,,表达式关于变量VAR是一个常量
Dialogue: 0,0:15:09.05,0:15:11.60,Default,,0,0,0,,是一些简单的表达式
Dialogue: 0,0:15:11.60,0:15:14.46,Default,,0,0,0,,我无法再细化它 但它也不是我们关心的变量
Dialogue: 0,0:15:16.58,0:15:18.78,Default,,0,0,0,,我无法分解它 但它也不是我们关心的变量
Dialogue: 0,0:15:18.90,0:15:25.12,Default,,0,0,0,,这也并不是说 一些复杂的表达式就不是常量表达式
Dialogue: 0,0:15:25.20,0:15:28.92,Default,,0,0,0,,我只是想用这种方式考察基本常量
Dialogue: 0,0:15:29.74,0:15:33.41,Default,,0,0,0,,因此 这个谓词是几个条件的合取
Dialogue: 0,0:15:34.02,0:15:37.82,Default,,0,0,0,,AND语句允许用户组合返回TRUE或者FALSE的谓词
Dialogue: 0,0:15:38.62,0:15:46.82,Default,,0,0,0,,表达式是原子的么？--原子表达式不可以再被细分
Dialogue: 0,0:15:46.82,0:15:48.53,Default,,0,0,0,,它没有CAR部分和CDR部分
Dialogue: 0,0:15:49.45,0:15:50.21,Default,,0,0,0,,它不是表
Dialogue: 0,0:15:50.76,0:15:52.94,Default,,0,0,0,,系统中内建有特殊测试
Dialogue: 0,0:15:53.97,0:16:04.66,Default,,0,0,0,,并且表达式EXP和变量VAR在EQ?的语义下不相等
Dialogue: 0,0:16:06.82,0:16:13.36,Default,,0,0,0,,我用不能被分解的符号来表示变量
Dialogue: 0,0:16:13.90,0:16:17.22,Default,,0,0,0,,比如'X 'Y 和像这样的
Dialogue: 0,0:16:19.74,0:16:22.37,Default,,0,0,0,,当然 像这样的组合式就可以再被细分
Dialogue: 0,0:16:24.74,0:16:46.40,Default,,0,0,0,,(SAME-VAR? EXP VAR)定义为
Dialogue: 0,0:16:46.40,0:16:48.40,Default,,0,0,0,,实际上 一条原子表达式……
Dialogue: 0,0:16:48.77,0:16:59.61,Default,,0,0,0,,该表达式与讨论变量相同
Dialogue: 0,0:17:07.90,0:17:11.68,Default,,0,0,0,,我不想深入讨论这些过程内部
Dialogue: 0,0:17:12.52,0:17:15.56,Default,,0,0,0,,把这些当作基本过程
Dialogue: 0,0:17:15.77,0:17:17.08,Default,,0,0,0,,这无关紧要
Dialogue: 0,0:17:17.78,0:17:21.74,Default,,0,0,0,,我用的是语言内置的功能
Dialogue: 0,0:17:22.42,0:17:24.04,Default,,0,0,0,,我并不关心这些（具体实现）
Dialogue: 0,0:17:24.42,0:17:26.04,Default,,0,0,0,,现在 我们要如何处理和式呢？
Dialogue: 0,0:17:26.60,0:17:28.80,Default,,0,0,0,,啊哈 好戏就要上演了
Dialogue: 0,0:17:28.98,0:17:33.12,Default,,0,0,0,,和式不是原子的 它以‘+’号打头
Dialogue: 0,0:17:35.16,0:17:36.17,Default,,0,0,0,,就是这个意思
Dialogue: 0,0:17:36.65,0:17:39.77,Default,,0,0,0,,这里 我定义
Dialogue: 0,0:17:45.46,0:17:57.77,Default,,0,0,0,,表达式为和式 当它不是原子表达式
Dialogue: 0,0:18:04.57,0:18:15.45,Default,,0,0,0,,并且它的开头 表达式的CAR部分是个‘+’号
Dialogue: 0,0:18:19.74,0:18:24.04,Default,,0,0,0,,我将要引入一个你们从未见过的东西--这个引号
Dialogue: 0,0:18:25.89,0:18:28.22,Default,,0,0,0,,我这里为什么要用引号呢？
Dialogue: 0,0:18:29.48,0:18:30.52,Default,,0,0,0,,教授：说你的名字
Dialogue: 0,0:18:30.68,0:18:31.41,Default,,0,0,0,,观众：Susanna
Dialogue: 0,0:18:31.41,0:18:32.01,Default,,0,0,0,,教授：大点声儿
Dialogue: 0,0:18:32.01,0:18:32.72,Default,,0,0,0,,观众：Susanna
Dialogue: 0,0:18:33.25,0:18:34.21,Default,,0,0,0,,教授：说“你的名字”
Dialogue: 0,0:18:34.21,0:18:34.85,Default,,0,0,0,,观众：“你的名字”
Dialogue: 0,0:18:34.92,0:18:35.68,Default,,0,0,0,,教授：大点声儿
Dialogue: 0,0:18:35.77,0:18:36.61,Default,,0,0,0,,观众：“你的名字”
Dialogue: 0,0:18:36.82,0:18:37.50,Default,,0,0,0,,教授：对了
Dialogue: 0,0:18:38.28,0:18:44.56,Default,,0,0,0,,在这里我想告诉大家 英语词汇是有歧义的
Dialogue: 0,0:18:45.50,0:18:50.76,Default,,0,0,0,,我可能说 “说你的名字”
Dialogue: 0,0:18:51.97,0:18:57.21,Default,,0,0,0,,我也可能说 “说‘你的名字’”
Dialogue: 0,0:19:00.72,0:19:02.98,Default,,0,0,0,,光从说话上还无法分辨
Dialogue: 0,0:19:03.89,0:19:08.01,Default,,0,0,0,,然而书面上 我们有专门的记号--引号
Dialogue: 0,0:19:08.18,0:19:12.46,Default,,0,0,0,,用来区别这两种可能的意思
Dialogue: 0,0:19:14.00,0:19:15.64,Default,,0,0,0,,具体来说 这里
Dialogue: 0,0:19:16.49,0:19:20.84,Default,,0,0,0,,在Lisp中有用于区别这些语义的记号
Dialogue: 0,0:19:21.34,0:19:24.45,Default,,0,0,0,,如果我只是写下一个加号
Dialogue: 0,0:19:24.64,0:19:28.52,Default,,0,0,0,,我会问系统 表达式的首元素
Dialogue: 0,0:19:29.06,0:19:33.61,Default,,0,0,0,,也就是表达式的运算符 是加运算符（一个过程）么？
Dialogue: 0,0:19:34.65,0:19:35.54,Default,,0,0,0,,我并不知道
Dialogue: 0,0:19:36.22,0:19:38.16,Default,,0,0,0,,我本应该在那里写一个加运算符的
Dialogue: 0,0:19:39.37,0:19:40.44,Default,,0,0,0,,但我无法那样做
Dialogue: 0,0:19:41.34,0:19:45.88,Default,,0,0,0,,而这种方式则是问 这个符号对象是否为
Dialogue: 0,0:19:45.98,0:19:48.14,Default,,0,0,0,,代表加运算符的符号
Dialogue: 0,0:19:49.57,0:19:51.92,Default,,0,0,0,,这才是我想要问和知道的问题
Dialogue: 0,0:19:52.92,0:19:54.45,Default,,0,0,0,,在我们深入讨论之前
Dialogue: 0,0:19:54.45,0:19:57.81,Default,,0,0,0,,我想要指出 “引用”是一个复杂的概念
Dialogue: 0,0:19:58.85,0:20:01.84,Default,,0,0,0,,语言中引入这个概念将会造成许多麻烦
Dialogue: 0,0:20:03.57,0:20:05.04,Default,,0,0,0,,请看下面这张幻灯片
Dialogue: 0,0:20:06.38,0:20:09.49,Default,,0,0,0,,这里这个推论没有问题
Dialogue: 0,0:20:11.62,0:20:17.04,Default,,0,0,0,,这是说 Alyssa聪明而Alyssa是George的妈妈
Dialogue: 0,0:20:17.40,0:20:20.60,Default,,0,0,0,,通过IS建立了一个等式
Dialogue: 0,0:20:22.13,0:20:26.30,Default,,0,0,0,,我们可以从这两个陈述推论出 George妈妈很聪明
Dialogue: 0,0:20:27.32,0:20:33.16,Default,,0,0,0,,这是因为我们总可以在表达式中等价替换
Dialogue: 0,0:20:34.09,0:20:35.16,Default,,0,0,0,,真是这样吗？
Dialogue: 0,0:20:36.52,0:20:40.37,Default,,0,0,0,,这个例子说 “Chicago”有七个字母
Dialogue: 0,0:20:41.12,0:20:44.86,Default,,0,0,0,,引用则是强调我讨论的是单词“Chicago”
Dialogue: 0,0:20:44.86,0:20:46.86,Default,,0,0,0,,而不是单词所代表的意思
Dialogue: 0,0:20:49.82,0:20:52.77,Default,,0,0,0,,这里说 Chicago是Illinois州最大的城市
Dialogue: 0,0:20:54.61,0:20:55.80,Default,,0,0,0,,而（代换的）结果是……
Dialogue: 0,0:20:55.80,0:20:59.09,Default,,0,0,0,,我可能会得到 Illinois州最大的城市有七个字母
Dialogue: 0,0:20:59.32,0:21:01.06,Default,,0,0,0,,这显然是错的
Dialogue: 0,0:21:05.16,0:21:07.17,Default,,0,0,0,,喔！手写笔好使了
Dialogue: 0,0:21:09.29,0:21:12.24,Default,,0,0,0,,所以 一旦我们有了（引用）这样的东西
Dialogue: 0,0:21:12.48,0:21:14.49,Default,,0,0,0,,我们的语言就会变得复杂
Dialogue: 0,0:21:14.49,0:21:18.34,Default,,0,0,0,,因为我们对于语言的一些操作就不再正确
Dialogue: 0,0:21:18.34,0:21:20.76,Default,,0,0,0,,比如通过等价代换来得到正确答案
Dialogue: 0,0:21:21.29,0:21:23.50,Default,,0,0,0,,如果不小心地操作就会出错
Dialogue: 0,0:21:24.49,0:21:27.34,Default,,0,0,0,,在一个引用不透明的上下文中 我们无法进行代换
Dialogue: 0,0:21:27.89,0:21:32.64,Default,,0,0,0,,引用就是引用不透明上下文的典型
Dialogue: 0,0:21:33.17,0:21:35.28,Default,,0,0,0,,如果你知道那是什么意思……你可以成为一位哲学家
Dialogue: 0,0:21:35.42,0:21:37.02,Default,,0,0,0,,或许我们之中就有一位
Dialogue: 0,0:21:37.53,0:21:41.32,Default,,0,0,0,,言归正传 我们继续
Dialogue: 0,0:21:41.32,0:21:44.98,Default,,0,0,0,,现在我们对一个有2000年历史的问题至少有了操作上的理解
Dialogue: 0,0:21:45.26,0:21:48.13,Default,,0,0,0,,关于名称、提及和等等类似的问题
Dialogue: 0,0:21:52.32,0:22:01.60,Default,,0,0,0,,我得定义如何把两个数加起来 (DEFINE (MAKE-SUM A1 A2))
Dialogue: 0,0:22:02.12,0:22:03.62,Default,,0,0,0,,我简单实现一下
Dialogue: 0,0:22:03.62,0:22:11.96,Default,,0,0,0,,'+、A1、A2构成列表
Dialogue: 0,0:22:13.86,0:22:17.37,Default,,0,0,0,,我可以决定如何取出第一个元素
Dialogue: 0,0:22:21.84,0:22:25.32,Default,,0,0,0,,(DEFINE A1 CADR)
Dialogue: 0,0:22:33.88,0:22:35.90,Default,,0,0,0,,这里又给大家介绍了一个基本过程
Dialogue: 0,0:22:36.17,0:22:39.10,Default,,0,0,0,,这个是取出某物CDR部分的CAR部分
Dialogue: 0,0:22:39.80,0:22:44.53,Default,,0,0,0,,大家或许会好奇 这些基本过程为什么叫做CAR和CDR
Dialogue: 0,0:22:44.66,0:22:48.42,Default,,0,0,0,,而且传承了下来 尽管叫做LEFT和RIGHT会好一点
Dialogue: 0,0:22:48.76,0:22:50.44,Default,,0,0,0,,我们本可以那样叫的
Dialogue: 0,0:22:51.28,0:22:56.25,Default,,0,0,0,,呃 其实 这个名字来自于很久以前 当发明Lisp时
Dialogue: 0,0:22:56.36,0:23:00.80,Default,,0,0,0,,我想大概是58年的样子 是在类似于704之类的机子上实现的
Dialogue: 0,0:23:00.80,0:23:05.41,Default,,0,0,0,,这个机器有个地址寄存器和减量寄存器
Dialogue: 0,0:23:05.41,0:23:08.17,Default,,0,0,0,,而这些就是地址寄存器和减量寄存器的值
Dialogue: 0,0:23:08.17,0:23:09.37,Default,,0,0,0,,所以这是历史遗留问题
Dialogue: 0,0:23:09.64,0:23:11.28,Default,,0,0,0,,但是这些名字为什么又延续下来了呢？
Dialogue: 0,0:23:11.74,0:23:14.76,Default,,0,0,0,,这是因为Lisp程序员喜欢用电话交流
Dialogue: 0,0:23:15.68,0:23:19.60,Default,,0,0,0,,要是你有一长串的CAR和CDR序列 你就可能说“CDADDEDR”
Dialogue: 0,0:23:21.01,0:23:22.32,Default,,0,0,0,,这是可以理解的
Dialogue: 0,0:23:22.32,0:23:27.02,Default,,0,0,0,,但是左边的右边的右边的左边就不是那么清楚了
Dialogue: 0,0:23:27.60,0:23:30.02,Default,,0,0,0,,这就是我们为什么有这些黑话
Dialogue: 0,0:23:30.54,0:23:34.14,Default,,0,0,0,,典型的Lisp系统 默认定义到第四层
Dialogue: 0,0:23:38.66,0:23:47.05,Default,,0,0,0,,而定义A2为……当然 如果我们考察这些表达式中的一个
Dialogue: 0,0:23:47.36,0:23:52.14,Default,,0,0,0,,比如(+ 3 5)
Dialogue: 0,0:23:52.58,0:24:10.45,Default,,0,0,0,,这个实际上是一个包含有'+、数3和数5的表
Dialogue: 0,0:24:11.72,0:24:15.18,Default,,0,0,0,,表的CAR部分是'+
Dialogue: 0,0:24:16.13,0:24:18.21,Default,,0,0,0,,CDR部分的CAR部分
Dialogue: 0,0:24:18.21,0:24:20.21,Default,,0,0,0,,也就是先取CDR部分 然后再取CAR部分
Dialogue: 0,0:24:20.21,0:24:22.21,Default,,0,0,0,,这就是我如何取得3的 也就是第一个参数
Dialogue: 0,0:24:22.52,0:24:25.69,Default,,0,0,0,,CDR的CDR部分的CAR部分 就是这个……数5
Dialogue: 0,0:24:28.69,0:24:33.66,Default,,0,0,0,,当然类似地 对于乘式我可以这样定义
Dialogue: 0,0:24:35.22,0:24:36.56,Default,,0,0,0,,我快速地演示一下
Dialogue: 0,0:24:48.97,0:24:50.64,Default,,0,0,0,,(DEFINE (PRODUCT? EXP))
Dialogue: 0,0:24:51.05,0:24:54.69,Default,,0,0,0,,如果它不是原子的 而且
Dialogue: 0,0:25:01.41,0:25:14.14,Default,,0,0,0,,EXP的CAR部分与用于表示乘法的符号'*在 EQ?的语义下相等
Dialogue: 0,0:25:15.64,0:25:32.00,Default,,0,0,0,,(DEFINE (MAKE-PRODUCT M1 M2))
Dialogue: 0,0:25:34.42,0:25:39.30,Default,,0,0,0,,(LIST '* M1 M2)
Dialogue: 0,0:25:40.82,0:25:56.81,Default,,0,0,0,,并定义M1为CADR M2为CADDR
Dialogue: 0,0:26:00.09,0:26:02.38,Default,,0,0,0,,当你说行话的时候 你就上道了
Dialogue: 0,0:26:02.53,0:26:05.53,Default,,0,0,0,,你可以取表的CDR 也可以把它们组合起来
Dialogue: 0,0:26:06.29,0:26:10.10,Default,,0,0,0,,现在 我们有了原理上完整的求导程序了
Dialogue: 0,0:26:10.10,0:26:11.70,Default,,0,0,0,,如果需要的话 你也可以添加更多的规则
Dialogue: 0,0:26:12.21,0:26:13.93,Default,,0,0,0,,它又要怎么用呢？
Dialogue: 0,0:26:14.64,0:26:16.77,Default,,0,0,0,,我先把这个笔迹清了
Dialogue: 0,0:26:17.80,0:26:20.82,Default,,0,0,0,,恩 假设我在这里定义FOO为
Dialogue: 0,0:26:22.16,0:26:30.38,Default,,0,0,0,,定义FOO为A*X^2+B*X+C
Dialogue: 0,0:26:30.54,0:26:32.08,Default,,0,0,0,,跟我们这里看到的是一样的
Dialogue: 0,0:26:32.08,0:26:36.36,Default,,0,0,0,,这里是用更习见的记号书写的代数表达式
Dialogue: 0,0:26:37.84,0:26:41.60,Default,,0,0,0,,那么 表达式FOO关于X的导数 结果在这里
Dialogue: 0,0:26:43.46,0:26:45.26,Default,,0,0,0,,真是乱得一团糟
Dialogue: 0,0:26:46.16,0:26:49.22,Default,,0,0,0,,我期望答案是2*A*X+B
Dialogue: 0,0:26:50.68,0:26:53.44,Default,,0,0,0,,虽然与结果等价 但它并不是我们希望的结果
Dialogue: 0,0:26:54.58,0:26:55.22,Default,,0,0,0,,这是什么呢？
Dialogue: 0,0:26:55.97,0:26:59.96,Default,,0,0,0,,我们最初有什么？
Dialogue: 0,0:27:00.50,0:27:04.30,Default,,0,0,0,,我求X*X的导数
Dialogue: 0,0:27:04.69,0:27:10.53,Default,,0,0,0,,答案是X*1+1*X 这当然没错
Dialogue: 0,0:27:12.73,0:27:15.66,Default,,0,0,0,,这就是乘数的导数乘以被乘数加上乘数乘以被乘数的导数
Dialogue: 0,0:27:17.22,0:27:28.37,Default,,0,0,0,,那就是2X、A*2X就是2AX、0X^2省去 再加上0和这里的一大堆0
Dialogue: 0,0:27:28.96,0:27:30.12,Default,,0,0,0,,答案是对的
Dialogue: 0,0:27:30.12,0:27:35.14,Default,,0,0,0,,当我们还需要用户额外检验一下 真是糟糕投了
Dialogue: 0,0:27:35.56,0:27:37.26,Default,,0,0,0,,我们下一节再考虑这个内容
Dialogue: 0,0:27:37.68,0:27:38.61,Default,,0,0,0,,有疑问吗？
Dialogue: 0,0:27:42.77,0:27:43.45,Default,,0,0,0,,请说
Dialogue: 0,0:27:43.89,0:27:46.69,Default,,0,0,0,,观众：写加号时不加引号
Dialogue: 0,0:27:46.69,0:27:50.82,Default,,0,0,0,,是表示引用加那个过程么？
Dialogue: 0,0:27:50.82,0:27:55.42,Default,,0,0,0,,如果有需要的话 是否能在两个过程之间进行比较
Dialogue: 0,0:27:56.16,0:27:57.08,Default,,0,0,0,,教授：问得好！
Dialogue: 0,0:27:57.45,0:28:02.26,Default,,0,0,0,,如果我这里不用左引号将这个引住
Dialogue: 0,0:28:03.88,0:28:07.13,Default,,0,0,0,,如果我这里不用引号
Dialogue: 0,0:28:07.33,0:28:14.20,Default,,0,0,0,,那么这里我就会引用定义好的加法过程
Dialogue: 0,0:28:15.38,0:28:24.88,Default,,0,0,0,,实际上 我可以比较两个过程是否同一
Dialogue: 0,0:28:24.88,0:28:27.45,Default,,0,0,0,,现在很难从语义上解释
Dialogue: 0,0:28:27.85,0:28:29.37,Default,,0,0,0,,我现在不想考虑这个问题
Dialogue: 0,0:28:29.89,0:28:32.40,Default,,0,0,0,,因为我不知道比较过程需要什么
Dialogue: 0,0:28:32.40,0:28:34.40,Default,,0,0,0,,这样做没有意义是有很多原因的
Dialogue: 0,0:28:35.52,0:28:37.53,Default,,0,0,0,,然而 这些符号我们是可以理解的
Dialogue: 0,0:28:38.54,0:28:40.56,Default,,0,0,0,,这也是我为什么我要将它们引住
Dialogue: 0,0:28:41.16,0:28:43.70,Default,,0,0,0,,我想讨论出现在这些代码中的符号
Dialogue: 0,0:28:46.16,0:28:46.92,Default,,0,0,0,,还有什么问题么？
Dialogue: 0,0:28:48.52,0:28:51.86,Default,,0,0,0,,好吧 休息一下 谢谢大家
Dialogue: 0,0:28:55.12,0:29:00.66,Default,,0,0,0,,[音乐]
Dialogue: 0,0:29:00.68,0:29:04.34,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:29:04.34,0:29:06.68,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:29:12.21,0:29:19.17,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:29:20.09,0:29:24.14,Declare,,0,0,0,,{\an2\fad(500,500)}符号化导数系统、引用
Dialogue: 0,0:29:29.86,0:29:30.92,Default,,0,0,0,,教授：好 我们继续
Dialogue: 0,0:29:31.46,0:29:37.76,Default,,0,0,0,,我们编写了一个貌似可行的代数表达式求导程序
Dialogue: 0,0:29:38.20,0:29:41.56,Default,,0,0,0,,这个程序是不完整的 你需要添加一些规则
Dialogue: 0,0:29:42.13,0:29:47.74,Default,,0,0,0,,你可能需要加强这个系统 使得它能够处理
Dialogue: 0,0:29:47.76,0:29:49.70,Default,,0,0,0,,多元加法和多元乘法
Dialogue: 0,0:29:49.89,0:29:51.38,Default,,0,0,0,,这些都相当简单
Dialogue: 0,0:29:52.73,0:29:56.93,Default,,0,0,0,,但这里面也有一些瑕疵
Dialogue: 0,0:29:57.48,0:30:02.37,Default,,0,0,0,,回到这张幻灯片来
Dialogue: 0,0:30:02.94,0:30:08.60,Default,,0,0,0,,我们发现 得到的表达式相当乱
Dialogue: 0,0:30:08.88,0:30:11.01,Default,,0,0,0,,这个表达式非常糟糕
Dialogue: 0,0:30:11.46,0:30:13.10,Default,,0,0,0,,我们是怎么得到这样的表达式的？
Dialogue: 0,0:30:13.84,0:30:15.50,Default,,0,0,0,,为什么是这样呢？
Dialogue: 0,0:30:16.84,0:30:18.74,Default,,0,0,0,,我们详细地分析一下这个表达式
Dialogue: 0,0:30:18.92,0:30:20.76,Default,,0,0,0,,找出这些片段都是出自哪里
Dialogue: 0,0:30:21.69,0:30:24.56,Default,,0,0,0,,如我们所见 这里的和式
Dialogue: 0,0:30:24.56,0:30:26.56,Default,,0,0,0,,也就是上一小节中给你们提到的
Dialogue: 0,0:30:27.12,0:30:29.09,Default,,0,0,0,,(+ (* X 1) (* 1 X))
Dialogue: 0,0:30:29.58,0:30:31.38,Default,,0,0,0,,是这个乘式的导数
Dialogue: 0,0:30:32.52,0:30:36.41,Default,,0,0,0,,也就是A乘上这个的积 这里A不是X的函数
Dialogue: 0,0:30:36.41,0:30:38.41,Default,,0,0,0,,因此A关于X是一个常数
Dialogue: 0,0:30:39.04,0:30:44.53,Default,,0,0,0,,导数为这个和式 从这里到这里 再到这里
Dialogue: 0,0:30:44.80,0:30:48.89,Default,,0,0,0,,因为这个是乘数乘以被乘数的导数
Dialogue: 0,0:30:49.57,0:30:54.45,Default,,0,0,0,,加上被乘数乘以乘数的导数
Dialogue: 0,0:30:54.66,0:30:59.06,Default,,0,0,0,,我们在黑板上的程序告诉我们确实是这样的
Dialogue: 0,0:31:00.65,0:31:05.36,Default,,0,0,0,,当然 这里B乘以X的积
Dialogue: 0,0:31:05.49,0:31:09.81,Default,,0,0,0,,被化成了 B*1+0*X
Dialogue: 0,0:31:10.81,0:31:16.06,Default,,0,0,0,,因为B不是X的函数
Dialogue: 0,0:31:16.46,0:31:18.56,Default,,0,0,0,,因此B的导数为0
Dialogue: 0,0:31:18.77,0:31:21.48,Default,,0,0,0,,而X对自己求导则为1
Dialogue: 0,0:31:23.06,0:31:28.64,Default,,0,0,0,,这里的加法化成了 这两个导数的和
Dialogue: 0,0:31:29.37,0:31:33.50,Default,,0,0,0,,所以这里 我想告诉你和之前一样的东西
Dialogue: 0,0:31:33.66,0:31:35.89,Default,,0,0,0,,也就是在讲斐波那契数那时候
Dialogue: 0,0:31:37.77,0:31:39.49,Default,,0,0,0,,所谓的 “过程的形状”
Dialogue: 0,0:31:41.38,0:31:46.44,Default,,0,0,0,,就是通过局部的规则向低层次展开
Dialogue: 0,0:31:48.05,0:31:52.57,Default,,0,0,0,,也就是过程代表了一系列用于演进过程局部规则
Dialogue: 0,0:31:53.36,0:32:00.09,Default,,0,0,0,,这里 过程还遗留了一些东西--也就是答案
Dialogue: 0,0:32:00.25,0:32:06.26,Default,,0,0,0,,这是通过遍历表达式的树结构构造出来的
Dialogue: 0,0:32:08.41,0:32:12.61,Default,,0,0,0,,答案中的每个部分对应问题中的某个部分
Dialogue: 0,0:32:14.46,0:32:17.78,Default,,0,0,0,,比如说 现在我们考察FOO的导数
Dialogue: 0,0:32:17.78,0:32:19.65,Default,,0,0,0,,也就是AX^2+BX+C
Dialogue: 0,0:32:19.84,0:32:23.05,Default,,0,0,0,,并另令自变量 比如像这里
Dialogue: 0,0:32:24.14,0:32:27.48,Default,,0,0,0,,我们令A为自变量 求FOO的导数
Dialogue: 0,0:32:28.10,0:32:31.77,Default,,0,0,0,,这都非常相似 实际上 它们是同样的代数表达式
Dialogue: 0,0:32:32.45,0:32:35.24,Default,,0,0,0,,只是它们之中0和1的位置不一样罢了
Dialogue: 0,0:32:36.06,0:32:38.60,Default,,0,0,0,,这是因为在这个树结构的遍历中
Dialogue: 0,0:32:38.97,0:32:43.85,Default,,0,0,0,,只可能是CONSTANT?和SAME-VAR?会因变量的不同
Dialogue: 0,0:32:44.28,0:32:45.81,Default,,0,0,0,,而造成不同结果
Dialogue: 0,0:32:48.26,0:32:52.09,Default,,0,0,0,,回到黑板上来再看看
Dialogue: 0,0:32:52.65,0:32:57.49,Default,,0,0,0,,我们在求和式或乘式的导数时根本没有发挥的余地
Dialogue: 0,0:32:58.08,0:33:04.48,Default,,0,0,0,,真正可以做文章的地方 则是表达式和自变量
Dialogue: 0,0:33:04.80,0:33:10.10,Default,,0,0,0,,以及对于那些短小的表达式 是否为关于自变量的常量
Dialogue: 0,0:33:10.36,0:33:12.41,Default,,0,0,0,,就是这些地方导致了不同的0和1的产生
Dialogue: 0,0:33:12.69,0:33:14.49,Default,,0,0,0,,回过头来看这张幻灯
Dialogue: 0,0:33:15.12,0:33:18.16,Default,,0,0,0,,这里就出现了“0”
Dialogue: 0,0:33:18.37,0:33:22.74,Default,,0,0,0,,这里是求FOO(A)的导数时得到的“1”
Dialogue: 0,0:33:22.96,0:33:24.86,Default,,0,0,0,,我们得到了X^2
Dialogue: 0,0:33:24.96,0:33:32.53,Default,,0,0,0,,这个1是X*X关于X的导数 关于B求导时1变成了0
Dialogue: 0,0:33:32.64,0:33:34.89,Default,,0,0,0,,这里 我们求FOO关于C的导数
Dialogue: 0,0:33:36.78,0:33:39.30,Default,,0,0,0,,但是这些表达式的轮廓是一致的
Dialogue: 0,0:33:40.54,0:33:43.96,Default,,0,0,0,,看看这些轮廓 都是相同的
Dialogue: 0,0:33:50.37,0:33:52.28,Default,,0,0,0,,那么 难道是我们的规则出了问题？
Dialogue: 0,0:33:53.58,0:33:55.02,Default,,0,0,0,,不 这些规则都对
Dialogue: 0,0:33:56.12,0:33:57.77,Default,,0,0,0,,我们曾经遇到过这种问题
Dialogue: 0,0:33:58.06,0:34:03.53,Default,,0,0,0,,你将会发现 这其中缺乏一些非常好的思想
Dialogue: 0,0:34:06.32,0:34:09.74,Default,,0,0,0,,昨天 我们在考察有理数时
Dialogue: 0,0:34:12.12,0:34:14.48,Default,,0,0,0,,想要得到3/4却得到6/8
Dialogue: 0,0:34:14.97,0:34:16.49,Default,,0,0,0,,答案没有化简
Dialogue: 0,0:34:18.09,0:34:20.90,Default,,0,0,0,,当然 当下的问题也非常类似
Dialogue: 0,0:34:21.18,0:34:25.41,Default,,0,0,0,,我想把不相同的表达式通过化简来使相同
Dialogue: 0,0:34:27.57,0:34:31.89,Default,,0,0,0,,当然 有理数加法和乘法的规则依然正确
Dialogue: 0,0:34:33.97,0:34:37.41,Default,,0,0,0,,因此这里 我们依葫芦画瓢
Dialogue: 0,0:34:37.78,0:34:39.89,Default,,0,0,0,,上次能行的办法 这次也没问题
Dialogue: 0,0:34:40.53,0:34:42.05,Default,,0,0,0,,也就是改换一下它的表示
Dialogue: 0,0:34:43.13,0:34:46.44,Default,,0,0,0,,或许在将其表示出来时我们可以进行
Dialogue: 0,0:34:47.88,0:34:49.78,Default,,0,0,0,,一步产生简化表示的步骤
Dialogue: 0,0:34:50.17,0:34:51.73,Default,,0,0,0,,当然啦 这也不是万用万灵
Dialogue: 0,0:34:52.49,0:34:54.14,Default,,0,0,0,,我也不想证明它是万能的
Dialogue: 0,0:34:55.12,0:35:00.44,Default,,0,0,0,,但这也是控制复杂度的一招妙计
Dialogue: 0,0:35:01.46,0:35:03.85,Default,,0,0,0,,我们小心翼翼地解决这些问题
Dialogue: 0,0:35:04.30,0:35:07.20,Default,,0,0,0,,我们所做的 就是把问题划分为几个部分
Dialogue: 0,0:35:07.57,0:35:08.73,Default,,0,0,0,,分别是求导规则
Dialogue: 0,0:35:11.32,0:35:15.80,Default,,0,0,0,,和在这种层面上的一般代数规则
Dialogue: 0,0:35:16.38,0:35:21.22,Default,,0,0,0,,然后就有一道抽象屏障
Dialogue: 0,0:35:22.48,0:35:33.49,Default,,0,0,0,,这里是代数表达式的表示--表结构
Dialogue: 0,0:35:37.33,0:35:42.56,Default,,0,0,0,,在这道屏障中 我定义了接口过程
Dialogue: 0,0:35:43.25,0:35:49.82,Default,,0,0,0,,比如 CONSTANT? SAME-VAR?
Dialogue: 0,0:35:54.60,0:35:58.72,Default,,0,0,0,,又比如 SUM? MAKE-SUM
Dialogue: 0,0:36:02.22,0:36:05.57,Default,,0,0,0,,还有 A1 A2
Dialogue: 0,0:36:06.60,0:36:08.58,Default,,0,0,0,,还有 PRODUCT? 之类的东西
Dialogue: 0,0:36:08.74,0:36:11.90,Default,,0,0,0,,我所需要的、针对各式代数表达式的东西
Dialogue: 0,0:36:12.94,0:36:19.14,Default,,0,0,0,,构筑这些屏障我可以随意地改换表示法
Dialogue: 0,0:36:20.14,0:36:23.20,Default,,0,0,0,,而不用改变在某种表示法下编写的规则
Dialogue: 0,0:36:25.04,0:36:29.08,Default,,0,0,0,,如果我能通过改变表示法来解决问题
Dialogue: 0,0:36:30.38,0:36:34.52,Default,,0,0,0,,那么把问题分解为两个部分则帮了我大忙
Dialogue: 0,0:36:35.65,0:36:37.54,Default,,0,0,0,,好吧 举一个非常简单的例子
Dialogue: 0,0:36:38.82,0:36:40.08,Default,,0,0,0,,我们的问题是什么？
Dialogue: 0,0:36:40.26,0:36:43.61,Default,,0,0,0,,回到这张幻灯片来
Dialogue: 0,0:36:44.50,0:36:47.34,Default,,0,0,0,,看这里 哦 这相当糟糕
Dialogue: 0,0:36:47.62,0:36:51.86,Default,,0,0,0,,这里是一个表达式与“0”的和
Dialogue: 0,0:36:53.14,0:36:56.66,Default,,0,0,0,,毋庸置疑这应该是该表达式本身
Dialogue: 0,0:36:57.21,0:37:01.90,Default,,0,0,0,,为什么这里还会有加号？
Dialogue: 0,0:37:03.38,0:37:04.57,Default,,0,0,0,,这其实可以更智能点
Dialogue: 0,0:37:05.56,0:37:10.08,Default,,0,0,0,,又比如说这里 是某表达式与“1”的积
Dialogue: 0,0:37:11.16,0:37:12.29,Default,,0,0,0,,这和之前一个道理
Dialogue: 0,0:37:12.86,0:37:15.68,Default,,0,0,0,,又像这里 与“0”相乘显然是“0”
Dialogue: 0,0:37:17.86,0:37:19.52,Default,,0,0,0,,因此我们也不用去构造这些式子了
Dialogue: 0,0:37:21.44,0:37:22.62,Default,,0,0,0,,我们为什么不这么做呢？
Dialogue: 0,0:37:23.66,0:37:27.96,Default,,0,0,0,,我们需要去修改表示法 基本上就是那里了
Dialogue: 0,0:37:37.40,0:37:41.84,Default,,0,0,0,,定义 MAKE-SUM 为
Dialogue: 0,0:37:42.05,0:37:43.76,Default,,0,0,0,,呃 现在就不是那么简单了
Dialogue: 0,0:37:44.00,0:37:50.40,Default,,0,0,0,,除非是有必要 否则我不会简单地把加号和式子组合成表
Dialogue: 0,0:37:51.72,0:37:53.05,Default,,0,0,0,,那么 还有哪些可能呢？
Dialogue: 0,0:37:54.56,0:37:58.53,Default,,0,0,0,,如果……这里有一些可能的情况
Dialogue: 0,0:37:59.38,0:38:08.20,Default,,0,0,0,,如果都是数值的话 如果A1是数值的话
Dialogue: 0,0:38:09.05,0:38:10.93,Default,,0,0,0,,这个基本过程我刚刚提到过
Dialogue: 0,0:38:10.93,0:38:13.18,Default,,0,0,0,,也就是用来检测参数是否为数值
Dialogue: 0,0:38:15.38,0:38:23.82,Default,,0,0,0,,并且A2也是数值的话 也就是A2不是符号表达式
Dialogue: 0,0:38:24.45,0:38:26.20,Default,,0,0,0,,那么我们就直接把它们加起来
Dialogue: 0,0:38:26.45,0:38:29.92,Default,,0,0,0,,结果就是A1加上A2的和
Dialogue: 0,0:38:32.32,0:38:33.98,Default,,0,0,0,,我并不是检查它们代表数值
Dialogue: 0,0:38:33.98,0:38:35.98,Default,,0,0,0,,这里所有的符号都代表数值
Dialogue: 0,0:38:37.33,0:38:41.22,Default,,0,0,0,,就比如 我想要考察的是这个东西是否为数值3
Dialogue: 0,0:38:43.40,0:38:44.40,Default,,0,0,0,,另一种情况
Dialogue: 0,0:38:48.77,0:38:59.61,Default,,0,0,0,,假设A1是数值 并且为0
Dialogue: 0,0:39:04.20,0:39:06.38,Default,,0,0,0,,那么答案就是A2
Dialogue: 0,0:39:06.93,0:39:08.68,Default,,0,0,0,,不用再构造什么
Dialogue: 0,0:39:10.98,0:39:23.41,Default,,0,0,0,,如果A2是数值 并且为0
Dialogue: 0,0:39:27.16,0:39:28.90,Default,,0,0,0,,那么答案就是A1
Dialogue: 0,0:39:30.04,0:39:33.65,Default,,0,0,0,,如果没有比这些更好的情况
Dialogue: 0,0:39:34.13,0:39:35.61,Default,,0,0,0,,我就需要构造一个表
Dialogue: 0,0:39:37.86,0:39:42.86,Default,,0,0,0,,构造一个用于表示答案的表
Dialogue: 0,0:39:44.13,0:39:52.33,Default,,0,0,0,,其中有 '+、A1和A2
Dialogue: 0,0:39:58.66,0:40:01.65,Default,,0,0,0,,当然 积的导数也可以类比此法
Dialogue: 0,0:40:03.01,0:40:05.04,Default,,0,0,0,,这里 我就不细讲了
Dialogue: 0,0:40:05.44,0:40:07.24,Default,,0,0,0,,我就直接在黑板上写出结果
Dialogue: 0,0:40:07.65,0:40:09.80,Default,,0,0,0,,这并不是很重要 你们已经了解它的思想了
Dialogue: 0,0:40:10.76,0:40:11.61,Default,,0,0,0,,非常简明
Dialogue: 0,0:40:12.86,0:40:19.89,Default,,0,0,0,,现在 我们来看看用这种方式改造程序后 效果如何
Dialogue: 0,0:40:21.68,0:40:27.88,Default,,0,0,0,,哦 这是修改表达式构造函数后的求导结果
Dialogue: 0,0:40:28.98,0:40:32.21,Default,,0,0,0,,对同样地FOO求导：AX^2+BX+C
Dialogue: 0,0:40:33.28,0:40:40.70,Default,,0,0,0,,我得到了 2AX+B
Dialogue: 0,0:40:40.70,0:40:42.10,Default,,0,0,0,,虽然它并没有化到最简
Dialogue: 0,0:40:42.60,0:40:44.53,Default,,0,0,0,,我应该合并同类项和求和
Dialogue: 0,0:40:45.06,0:40:46.08,Default,,0,0,0,,但这又是另外一回事了
Dialogue: 0,0:40:47.12,0:40:51.86,Default,,0,0,0,,当然啦 完成这个功能的代码就大而复杂了
Dialogue: 0,0:40:52.28,0:40:55.28,Default,,0,0,0,,代数化简 是一项繁复的工作
Dialogue: 0,0:40:56.37,0:41:00.13,Default,,0,0,0,,你们可能听过MIT以前开发的一个非常出名的程序 MAXIMA
Dialogue: 0,0:41:00.42,0:41:03.14,Default,,0,0,0,,它有5000页的LISP代码
Dialogue: 0,0:41:03.92,0:41:06.50,Default,,0,0,0,,大部分是代数化简的操作
Dialogue: 0,0:41:08.08,0:41:12.21,Default,,0,0,0,,这里是FOO的导数
Dialogue: 0,0:41:12.21,0:41:16.86,Default,,0,0,0,,要是我的话 我会在初等微积分课上讲讲“改换主变量”这个东西
Dialogue: 0,0:41:18.38,0:41:22.49,Default,,0,0,0,,以A为自变量 FOO的导数则是X*X
Dialogue: 0,0:41:22.80,0:41:23.80,Default,,0,0,0,,看起来还不差
Dialogue: 0,0:41:24.74,0:41:27.53,Default,,0,0,0,,以B为自变量 FOO的导数则是X本身
Dialogue: 0,0:41:28.06,0:41:30.12,Default,,0,0,0,,以C为自变量 FOO的导数则为“1”
Dialogue: 0,0:41:30.70,0:41:32.04,Default,,0,0,0,,我对这些结果很满意
Dialogue: 0,0:41:34.10,0:41:39.01,Default,,0,0,0,,你所看到的 都是精心设计、仔细规划的例子
Dialogue: 0,0:41:39.56,0:41:42.60,Default,,0,0,0,,用以展示如何操作代数表达式
Dialogue: 0,0:41:42.96,0:41:47.93,Default,,0,0,0,,我们如何不用具体的语法 而用抽象的语法抽象地进行
Dialogue: 0,0:41:49.21,0:41:56.29,Default,,0,0,0,,以及我们如何使用抽象屏障控制构造这些表达式
Dialogue: 0,0:41:57.80,0:42:00.41,Default,,0,0,0,,真正的奥义并不是如此的简单
Dialogue: 0,0:42:01.00,0:42:04.45,Default,,0,0,0,,实际上 真正的奥义在于我在操作这些表达式时
Dialogue: 0,0:42:04.45,0:42:06.72,Default,,0,0,0,,代数表达式和代码表达式--
Dialogue: 0,0:42:06.72,0:42:07.97,Default,,0,0,0,,回过头来看看幻灯片
Dialogue: 0,0:42:08.08,0:42:10.52,Default,,0,0,0,,都是同一种Lisp表达式
Dialogue: 0,0:42:12.02,0:42:12.97,Default,,0,0,0,,这样一语双关 一石二鸟
Dialogue: 0,0:42:13.82,0:42:21.49,Default,,0,0,0,,我用表示代码相同的方法来作为我的表示法
Dialogue: 0,0:42:22.89,0:42:26.52,Default,,0,0,0,,为了要这样做 我得付出点代价
Dialogue: 0,0:42:26.90,0:42:30.34,Default,,0,0,0,,我需要使用类似于“引用”的东西
Dialogue: 0,0:42:30.97,0:42:38.17,Default,,0,0,0,,这是因为 我的语言可以编写讨论语言表达式的表达式
Dialogue: 0,0:42:39.76,0:42:43.22,Default,,0,0,0,,我需要有某种东西指出 这个是我需要讨论的表达式
Dialogue: 0,0:42:43.76,0:42:46.13,Default,,0,0,0,,而不是说 （去求）这个表达式的值
Dialogue: 0,0:42:47.20,0:42:48.44,Default,,0,0,0,,我想要的是前者
Dialogue: 0,0:42:51.34,0:42:55.36,Default,,0,0,0,,引用阻止表达式被求值 其语义为“就是表达式本身”
Dialogue: 0,0:42:57.97,0:43:00.85,Default,,0,0,0,,有了这种能力以后
Dialogue: 0,0:43:01.58,0:43:03.82,Default,,0,0,0,,如果我可以操作语言的表达式
Dialogue: 0,0:43:04.80,0:43:09.00,Default,,0,0,0,,我可以在语言层之上构建更加有力的层次
Dialogue: 0,0:43:09.77,0:43:12.64,Default,,0,0,0,,因为我可以编写不仅仅是内嵌于Lisp的语言
Dialogue: 0,0:43:13.46,0:43:14.80,Default,,0,0,0,,或者是其它的语言
Dialogue: 0,0:43:15.26,0:43:17.76,Default,,0,0,0,,我可以编写一种完全不同的语言
Dialogue: 0,0:43:18.58,0:43:22.24,Default,,0,0,0,,而其实质上则是被Lisp或其它语言所解释
Dialogue: 0,0:43:23.17,0:43:25.46,Default,,0,0,0,,我们以后还会对此有更深入的理解
Dialogue: 0,0:43:26.56,0:43:32.09,Default,,0,0,0,,我现在只是想让你们意识到
Dialogue: 0,0:43:32.36,0:43:34.98,Default,,0,0,0,,我们已经感触到了一种惊人的力量
Dialogue: 0,0:43:36.00,0:43:37.82,Default,,0,0,0,,现在我们有了方天画戟
Dialogue: 0,0:43:38.17,0:43:40.92,Default,,0,0,0,,当我们使用它时 也得万分小心
Dialogue: 0,0:43:42.17,0:43:43.00,Default,,0,0,0,,谢谢大家
Dialogue: 0,0:43:44.10,0:44:00.54,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,0:43:44.10,0:44:00.54,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
