[Script Info]
; Script generated by Aegisub 3.0.4
; http://www.aegisub.org/
Title: CHNENG Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
Collisions: Normal
Video Zoom Percent: 0.65
PlayResX: 640
PlayResY: 480
Scroll Position: 75
Active Line: 0
YCbCr Matrix: TV.601

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:24.34,0:00:29.34,EN,,0,0,0,,PROFESSOR: Well, yesterday we learned a bit about symbolic manipulation,
Dialogue: 0,0:00:29.92,0:00:35.12,EN,,0,0,0,,and we wrote a rather stylized program
Dialogue: 0,0:00:35.15,0:00:38.97,EN,,0,0,0,,to implement a pile of calculus rule from the calculus book.
Dialogue: 0,0:00:39.61,0:00:44.59,EN,,0,0,0,,Here on the transparencies,
Dialogue: 0,0:00:44.96,0:00:48.81,EN,,0,0,0,,we see a bunch of calculus rules from such a book.
Dialogue: 0,0:00:49.47,0:00:54.62,EN,,0,0,0,,And, of course, what we did is sort of translate these rules into the language of the computer.
Dialogue: 0,0:00:55.14,0:00:58.85,EN,,0,0,0,,But, of course, that's a sort of funny strategy.
Dialogue: 0,0:00:59.36,0:01:04.80,EN,,0,0,0,,Why should we have to translate these rules into the language of the computer?
Dialogue: 0,0:01:05.00,0:01:06.27,EN,,0,0,0,,And what do I really mean by that?
Dialogue: 0,0:01:06.62,0:01:11.02,EN,,0,0,0,,These are--the program we wrote yesterday was very stylized.
Dialogue: 0,0:01:11.21,0:01:15.98,EN,,0,0,0,,It was a conditional, a dispatch on the type of the expression
Dialogue: 0,0:01:16.38,0:01:18.48,EN,,0,0,0,,as observed by the rules.
Dialogue: 0,0:01:19.68,0:01:21.55,EN,,0,0,0,,What we see here are rules that say
Dialogue: 0,0:01:21.74,0:01:25.48,EN,,0,0,0,,if the object being the derivative is being taken of,
Dialogue: 0,0:01:25.48,0:01:29.42,EN,,0,0,0,,if that expression is a constant, then do one thing.
Dialogue: 0,0:01:29.42,0:01:31.37,EN,,0,0,0,,If it's a variable, do another thing.
Dialogue: 0,0:01:31.60,0:01:35.56,EN,,0,0,0,,If it's a product of a constant times a variable, do something and so on.
Dialogue: 0,0:01:36.00,0:01:38.96,EN,,0,0,0,,There's sort of a dispatch there on a type.
Dialogue: 0,0:01:41.40,0:01:45.16,EN,,0,0,0,,Well, since it has such a stylized behavior and structure,
Dialogue: 0,0:01:45.95,0:01:49.53,EN,,0,0,0,,is there some other way of writing this program that's more clear?
Dialogue: 0,0:01:50.83,0:01:53.45,EN,,0,0,0,,Well, what's a rule, first of all, What are these rules?
Dialogue: 0,0:01:55.56,0:01:58.50,EN,,0,0,0,,Let's think about that. Rules have parts.
Dialogue: 0,0:01:58.94,0:02:02.35,EN,,0,0,0,,If you look at these rules in detail,
Dialogue: 0,0:02:03.71,0:02:04.99,EN,,0,0,0,,what you see, for example,
Dialogue: 0,0:02:05.12,0:02:09.69,EN,,0,0,0,,is the rule has a left-hand side and a right-hand side.
Dialogue: 0,0:02:10.36,0:02:14.36,EN,,0,0,0,,Each of these rules has a left-hand side and the right-hand side.
Dialogue: 0,0:02:15.15,0:02:20.30,EN,,0,0,0,,The left-hand side is somehow compared with the expression you're trying to take the derivative of.
Dialogue: 0,0:02:21.52,0:02:25.10,EN,,0,0,0,,The right-hand side is the replacement for that expression.
Dialogue: 0,0:02:28.49,0:02:33.10,EN,,0,0,0,,So all rules on this page are something like this.
Dialogue: 0,0:02:36.51,0:02:38.06,EN,,0,0,0,,I have patterns,
Dialogue: 0,0:02:41.48,0:02:48.30,EN,,0,0,0,,and somehow, I have to produce, given a pattern, a skeleton.
Dialogue: 0,0:02:51.88,0:02:52.81,EN,,0,0,0,,This is a rule.
Dialogue: 0,0:02:55.42,0:02:57.13,EN,,0,0,0,,A pattern is something that matches,
Dialogue: 0,0:02:57.88,0:03:03.26,EN,,0,0,0,,and a skeleton is something you substitute into in order to get a new expression.
Dialogue: 0,0:03:06.46,0:03:16.32,EN,,0,0,0,,So what that means is that the pattern is matched against the expression, which is the source expression.
Dialogue: 0,0:03:23.72,0:03:28.51,EN,,0,0,0,,And the result of the application of the rule is to produce a new expression,
Dialogue: 0,0:03:33.61,0:03:34.91,EN,,0,0,0,,which I'll call a target,
Dialogue: 0,0:03:38.12,0:03:39.88,EN,,0,0,0,,by instantiation of a skeleton.
Dialogue: 0,0:03:41.63,0:03:43.02,EN,,0,0,0,,That's called instantiation.
Dialogue: 0,0:03:50.72,0:03:54.73,EN,,0,0,0,,So that is the process by which these rules are described.
Dialogue: 0,0:03:55.69,0:03:57.26,EN,,0,0,0,,What I'd like to do today
Dialogue: 0,0:03:58.73,0:04:01.08,EN,,0,0,0,,is build a language
Dialogue: 0,0:04:02.20,0:04:05.48,EN,,0,0,0,,and a means of interpreting that language, a means of executing that language,
Dialogue: 0,0:04:05.74,0:04:08.43,EN,,0,0,0,,where that language allows us to directly express these rules.
Dialogue: 0,0:04:10.59,0:04:11.58,EN,,0,0,0,,And what we're going to do
Dialogue: 0,0:04:11.58,0:04:17.56,EN,,0,0,0,,instead of bringing the rules to the level of the computer by writing a program that is those rules
Dialogue: 0,0:04:18.38,0:04:21.56,EN,,0,0,0,,in the computer's language--at the moment, in a Lisp--
Dialogue: 0,0:04:22.16,0:04:24.49,EN,,0,0,0,,we're going to bring the computer to the level of us
Dialogue: 0,0:04:25.48,0:04:29.15,EN,,0,0,0,,by writing a way by which the computer can understand rules of this sort.
Dialogue: 0,0:04:30.91,0:04:34.76,EN,,0,0,0,,This is slightly emphasizing the idea that we had last time
Dialogue: 0,0:04:35.44,0:04:39.36,EN,,0,0,0,,that we're trying to make a solution to a class of problems rather than a particular one.
Dialogue: 0,0:04:39.77,0:04:46.72,EN,,0,0,0,,The problem is if I want to write rules for a different piece of mathematics,
Dialogue: 0,0:04:48.24,0:04:51.39,EN,,0,0,0,,say, to simple algebraic simplification or something like that,
Dialogue: 0,0:04:51.98,0:04:55.48,EN,,0,0,0,,or manipulation of trigonometric functions,
Dialogue: 0,0:04:56.09,0:05:01.16,EN,,0,0,0,,I would have to write a different program in using yesterday's method.
Dialogue: 0,0:05:01.16,0:05:05.42,EN,,0,0,0,,Whereas I would like to encapsulate all of the things that are common to both of those programs,
Dialogue: 0,0:05:06.12,0:05:10.17,EN,,0,0,0,,meaning the idea of matching, instantiation, the control structure,
Dialogue: 0,0:05:10.17,0:05:12.46,EN,,0,0,0,,which turns out to be very complicated for such a thing,
Dialogue: 0,0:05:13.16,0:05:18.46,EN,,0,0,0,,I'd like to encapsulate that separately from the rules themselves.
Dialogue: 0,0:05:20.06,0:05:22.60,EN,,0,0,0,,So let's look at, first of all, a representation.
Dialogue: 0,0:05:22.62,0:05:24.09,EN,,0,0,0,,I'd like to use the overhead here.
Dialogue: 0,0:05:24.67,0:05:25.60,EN,,0,0,0,,I'd like-- there it is.
Dialogue: 0,0:05:26.25,0:05:32.27,EN,,0,0,0,,I'd like to look at a representation of the rules of calculus for derivatives
Dialogue: 0,0:05:33.71,0:05:37.15,EN,,0,0,0,,in a sort of simple language that I'm writing right here.
Dialogue: 0,0:05:38.11,0:05:43.29,EN,,0,0,0,,Now, I'm going to avoid--I'm going to avoid worrying about syntax.
Dialogue: 0,0:05:44.28,0:05:49.28,EN,,0,0,0,,We can easily pretty this, and I'm not interested in making-- this is indeed ugly.
Dialogue: 0,0:05:49.30,0:05:56.41,EN,,0,0,0,,This doesn't look like the beautiful text set dx by dt or something that I'd like to write,
Dialogue: 0,0:05:56.76,0:05:58.12,EN,,0,0,0,,but that's not essential.
Dialogue: 0,0:05:58.88,0:06:00.62,EN,,0,0,0,,That's sort of an accidental phenomenon.
Dialogue: 0,0:06:01.00,0:06:04.44,EN,,0,0,0,,Here, we're just worrying about the fact that the structure of the rules
Dialogue: 0,0:06:04.83,0:06:11.70,EN,,0,0,0,,is that there is a left-hand side here, represents the thing I want to match against the derivative expression.
Dialogue: 0,0:06:11.80,0:06:13.56,EN,,0,0,0,,This is the representation I'm going to say
Dialogue: 0,0:06:13.60,0:06:18.32,EN,,0,0,0,,for the derivative of a constant, which we will call c
Dialogue: 0,0:06:18.84,0:06:21.20,EN,,0,0,0,,respect to the variable we will call v.
Dialogue: 0,0:06:23.08,0:06:25.55,EN,,0,0,0,,And what we will get on the right-hand side is 0.
Dialogue: 0,0:06:26.00,0:06:28.06,EN,,0,0,0,,So this represents a rule.
Dialogue: 0,0:06:29.26,0:06:34.04,EN,,0,0,0,,The next rule will be the derivative of a variable, which we will call v
Dialogue: 0,0:06:34.22,0:06:37.74,EN,,0,0,0,,respect to the same variable v, and we get a 1.
Dialogue: 0,0:06:38.60,0:06:42.17,EN,,0,0,0,,However, if we have the derivative of a variable called u
Dialogue: 0,0:06:42.41,0:06:44.84,EN,,0,0,0,,respect to a different variables v,
Dialogue: 0,0:06:45.39,0:06:47.05,EN,,0,0,0,,we will get 0.
Dialogue: 0,0:06:47.84,0:06:52.17,EN,,0,0,0,,I just want you look at these rules a little bit and see how they fit together.
Dialogue: 0,0:06:52.51,0:06:54.30,EN,,0,0,0,,For example, over here,
Dialogue: 0,0:06:54.73,0:07:01.90,EN,,0,0,0,,we're going to have the derivative of the sum of an expression called x1 and an expression called x2.
Dialogue: 0,0:07:01.90,0:07:05.85,EN,,0,0,0,,These things that begin with question marks are called pattern variables
Dialogue: 0,0:07:06.88,0:07:08.62,EN,,0,0,0,,in the language that we're inventing,
Dialogue: 0,0:07:08.93,0:07:14.93,EN,,0,0,0,,and you see we're just making it up, so pattern variables for matching.
Dialogue: 0,0:07:14.93,0:07:20.33,EN,,0,0,0,,And so in this-- here we have the derivative of the sum of the expression which we will call x1.
Dialogue: 0,0:07:20.33,0:07:26.70,EN,,0,0,0,,And the expression we will call x2 with respect to the variable we call v will be-- here is the right-hand side:
Dialogue: 0,0:07:26.70,0:07:32.76,EN,,0,0,0,,the sum of the derivative of  that expression x1 with respect to v-- the right-hand side is the skeleton--
Dialogue: 0,0:07:33.82,0:07:37.10,EN,,0,0,0,,and the derivative of x2 with respect to v.
Dialogue: 0,0:07:37.60,0:07:42.38,EN,,0,0,0,,Colons here will stand for substitution objects.
Dialogue: 0,0:07:43.63,0:07:47.23,EN,,0,0,0,,They're--we'll call them skeleton evaluations.
Dialogue: 0,0:07:48.51,0:07:53.07,EN,,0,0,0,,So let me put up here on the blackboard for a second some syntax
Dialogue: 0,0:07:53.23,0:07:55.56,EN,,0,0,0,,so we'll know what's going on for this rule language.
Dialogue: 0,0:07:56.68,0:07:59.88,EN,,0,0,0,,First of all, we're going to have to worry about the pattern matching.
Dialogue: 0,0:08:06.04,0:08:13.12,EN,,0,0,0,,We're going to have things like a symbol like foo matches exactly itself.
Dialogue: 0,0:08:23.52,0:08:31.34,EN,,0,0,0,,The expression f of a and b will be used to match any list
Dialogue: 0,0:08:36.30,0:08:57.02,EN,,0,0,0,,whose first element is f, whose second element is a, and whose third element is b.
Dialogue: 0,0:08:58.62,0:09:06.99,EN,,0,0,0,,Also, another thing we might have in a pattern is that--a question mark with some variable like x.
Dialogue: 0,0:09:08.57,0:09:18.67,EN,,0,0,0,,And what that means, it says matches anything, which we will call x.
Dialogue: 0,0:09:25.45,0:09:29.98,EN,,0,0,0,,Question mark c x will match only constants.
Dialogue: 0,0:09:31.50,0:09:40.96,EN,,0,0,0,,So this is something which matches a constant called x.
Dialogue: 0,0:09:44.56,0:09:57.07,EN,,0,0,0,,And question mark v x will match a variable, which we call x.
Dialogue: 0,0:10:01.66,0:10:03.80,EN,,0,0,0,,This is sort of the language we're making up now.
Dialogue: 0,0:10:04.19,0:10:09.40,EN,,0,0,0,,If I match two things against each other, then they are compared element by element
Dialogue: 0,0:10:10.25,0:10:15.85,EN,,0,0,0,,But elements in the pattern may contain these syntactic variables,
Dialogue: 0,0:10:17.07,0:10:20.43,EN,,0,0,0,,which will be used to match arbitrary objects.
Dialogue: 0,0:10:22.12,0:10:29.28,EN,,0,0,0,,And we'll get that object as the value in the name x here, for example.
Dialogue: 0,0:10:31.05,0:10:37.55,EN,,0,0,0,,Now, when we make skeletons for instantiation.
Dialogue: 0,0:10:39.50,0:10:41.40,EN,,0,0,0,,Well, then we have things like this.
Dialogue: 0,0:10:42.27,0:10:46.33,EN,,0,0,0,,foo, a symbol, instantiates to itself.
Dialogue: 0,0:10:55.08,0:11:05.92,EN,,0,0,0,,Something which is a list like f of a and b, instantiates to--
Dialogue: 0,0:11:06.36,0:11:14.75,EN,,0,0,0,,well, f instantiates to a  3-list, a list of three elements,
Dialogue: 0,0:11:15.55,0:11:33.37,EN,,0,0,0,,okay, which are the results of instantiating each of f, a, and b.
Dialogue: 0,0:11:36.35,0:11:54.27,EN,,0,0,0,,And x well--we instantiate to the value of x as in the matched pattern.
Dialogue: 0,0:12:03.05,0:12:10.08,EN,,0,0,0,,So going back to the overhead here, we see -- we see that all of those kinds of objects
Dialogue: 0,0:12:10.78,0:12:16.06,EN,,0,0,0,,we see here a pattern variable which matches a constant,
Dialogue: 0,0:12:16.56,0:12:19.02,EN,,0,0,0,,a pattern variable which matches a variable,
Dialogue: 0,0:12:19.39,0:12:21.74,EN,,0,0,0,,a pattern variable which will match anything.
Dialogue: 0,0:12:22.72,0:12:24.92,EN,,0,0,0,,And if we have two instances of the same name,
Dialogue: 0,0:12:25.08,0:12:31.77,EN,,0,0,0,,like this is the derivative of the expression which is a variable only whose name will be v
Dialogue: 0,0:12:32.86,0:12:36.30,EN,,0,0,0,,with respect to some arbitrary expression which we will call v,
Dialogue: 0,0:12:36.41,0:12:38.01,EN,,0,0,0,,since this v appears twice,
Dialogue: 0,0:12:38.65,0:12:41.07,EN,,0,0,0,,we're going to want that to mean they have to be the same.
Dialogue: 0,0:12:42.68,0:12:45.00,EN,,0,0,0,,The only consistent match is that those are the same.
Dialogue: 0,0:12:45.23,0:12:47.23,EN,,0,0,0,,So here, we're making up a language.
Dialogue: 0,0:12:47.60,0:12:50.66,EN,,0,0,0,,And in fact, that's a very nice thing to be doing.
Dialogue: 0,0:12:50.66,0:12:52.60,EN,,0,0,0,,It's so much fun to make up a language.
Dialogue: 0,0:12:52.60,0:12:54.33,EN,,0,0,0,,And you do this all the time.
Dialogue: 0,0:12:54.33,0:12:56.89,EN,,0,0,0,,And the really most powerful design things you ever do
Dialogue: 0,0:12:57.23,0:13:00.20,EN,,0,0,0,,are sort of making up a language to solve problems like this.
Dialogue: 0,0:13:02.06,0:13:05.34,EN,,0,0,0,,Now, here we go back here and look at some of these rules.
Dialogue: 0,0:13:05.80,0:13:07.10,EN,,0,0,0,,Well, there's a whole set of them.
Dialogue: 0,0:13:07.10,0:13:12.43,EN,,0,0,0,,I mean, there's one for addition and one for multiplication, just like we had before.
Dialogue: 0,0:13:12.43,0:13:17.37,EN,,0,0,0,,The derivative of the product of x1 and x2 with respect to v is
Dialogue: 0,0:13:17.68,0:13:26.52,EN,,0,0,0,,the sum of the product of x1 and the derivative x2 with respect to v and the product of the derivative of x1 and x2.
Dialogue: 0,0:13:27.26,0:13:29.10,EN,,0,0,0,,And here we have exponentiation.
Dialogue: 0,0:13:29.24,0:13:32.11,EN,,0,0,0,,And, of course, we run off the end down here. We get as many as we like.
Dialogue: 0,0:13:32.70,0:13:39.10,EN,,0,0,0,,But the whole thing over here, I'm giving this--this list of rules the name "derivative rules."
Dialogue: 0,0:13:40.40,0:13:44.33,EN,,0,0,0,,What would we do with such a thing once we have it?
Dialogue: 0,0:13:45.40,0:13:47.84,EN,,0,0,0,,Well, one of the nicest ideas, first of all,
Dialogue: 0,0:13:48.44,0:13:51.68,EN,,0,0,0,,is I'm going to write for you, and we're going to play with it all day.
Dialogue: 0,0:13:52.28,0:13:57.37,EN,,0,0,0,,What I'm going to write for you is a program called simplifier,
Dialogue: 0,0:13:57.82,0:13:59.47,EN,,0,0,0,,the general-purpose simplifier.
Dialogue: 0,0:14:00.09,0:14:17.10,EN,,0,0,0,,And we're going to say something like define dsimp to be a simplifier of the derivative rules.
Dialogue: 0,0:14:23.74,0:14:28.75,EN,,0,0,0,,And what simplifier is going to do is, given a set of rules, it will produce for me a procedure
Dialogue: 0,0:14:29.32,0:14:34.59,EN,,0,0,0,,which will simplify expressions containing the things that are referred to by these rules.
Dialogue: 0,0:14:37.39,0:14:43.93,EN,,0,0,0,,So here will be a procedure constructed for your purposes to simplify things with derivatives in them
Dialogue: 0,0:14:44.59,0:14:49.56,EN,,0,0,0,,such that, after that, if we're typing at some Lisp system, and we get a prompt,
Dialogue: 0,0:14:49.88,0:15:03.93,EN,,0,0,0,,and we say dsimp, for example, of the derivative of the sum of x and y with respect to x--
Dialogue: 0,0:15:06.99,0:15:10.97,EN,,0,0,0,,note the quote here because I'm talking about the expression which is the derivative--
Dialogue: 0,0:15:13.29,0:15:17.76,EN,,0,0,0,,then I will get back as a result plus 1 0.
Dialogue: 0,0:15:19.96,0:15:24.60,EN,,0,0,0,,Because the derivative of x plus y is the derivative of x plus derivative y.
Dialogue: 0,0:15:24.60,0:15:26.22,EN,,0,0,0,,The derivative of x with respect to x is 1.
Dialogue: 0,0:15:26.38,0:15:27.82,EN,,0,0,0,,The derivative of y with respect to x is 0.
Dialogue: 0,0:15:29.42,0:15:30.46,EN,,0,0,0,,It's not what we're going to get.
Dialogue: 0,0:15:31.18,0:15:34.65,EN,,0,0,0,,I haven't put any simplification at that level-- algebraic simplification--yet.
Dialogue: 0,0:15:36.16,0:15:41.53,EN,,0,0,0,,Of course, once we have such a thing, then we can--then we can look at other rules.
Dialogue: 0,0:15:41.96,0:15:49.36,EN,,0,0,0,,So, for example, we can, if we go to the slide, OK?
Dialogue: 0,0:15:49.36,0:15:54.12,EN,,0,0,0,,Here, for example, are other rules that we might have, algebraic manipulation rules,
Dialogue: 0,0:15:56.00,0:15:58.38,EN,,0,0,0,,ones that would be used for simplifying algebraic expressions.
Dialogue: 0,0:15:59.00,0:16:02.06,EN,,0,0,0,,For example, just looking at some of these,
Dialogue: 0,0:16:03.04,0:16:09.20,EN,,0,0,0,,the left-hand side says any operator applied to a constant e1 and a constant e2
Dialogue: 0,0:16:09.32,0:16:14.51,EN,,0,0,0,,is the result of evaluating that operator on the constants e1 and e2.
Dialogue: 0,0:16:15.88,0:16:21.56,EN,,0,0,0,,Or an operator, applied to e1, any expression e1 and a constant e2,
Dialogue: 0,0:16:21.69,0:16:23.87,EN,,0,0,0,,is going to move the constant forward.
Dialogue: 0,0:16:24.52,0:16:27.68,EN,,0,0,0,,So that'll turn into the operator with e2 followed by e1.
Dialogue: 0,0:16:28.59,0:16:30.11,EN,,0,0,0,,Why I did that, I don't know.
Dialogue: 0,0:16:30.22,0:16:33.16,EN,,0,0,0,,It wouldn't work if I had division, for example.
Dialogue: 0,0:16:33.53,0:16:35.31,EN,,0,0,0,,So there's a bug in the rules, if you like.
Dialogue: 0,0:16:36.67,0:16:40.86,EN,,0,0,0,,So the sum of 0 and e is e.
Dialogue: 0,0:16:42.17,0:16:45.31,EN,,0,0,0,,The product of 1 and any expression e is e.
Dialogue: 0,0:16:46.12,0:16:49.13,EN,,0,0,0,,The product of 0 and any expression e is 0.
Dialogue: 0,0:16:49.33,0:16:52.72,EN,,0,0,0,,Just looking at some more of these rules, we could have arbitrarily complicated ones.
Dialogue: 0,0:16:53.69,0:16:54.81,EN,,0,0,0,,We could have things like
Dialogue: 0,0:16:55.36,0:17:01.69,EN,,0,0,0,,the product of the constant e1 and any constant e2 with e3
Dialogue: 0,0:17:02.35,0:17:11.96,EN,,0,0,0,,is the result of multiplying the result of multiplying now the constants e1 and e2 together and putting e3 there.
Dialogue: 0,0:17:13.36,0:17:16.76,EN,,0,0,0,,So it says combine the constants that I had,
Dialogue: 0,0:17:16.76,0:17:22.70,EN,,0,0,0,,which was if I had a product of e1 and e2 and e3 just multiply--I mean and e1 and e2 are both constants, multiply them.
Dialogue: 0,0:17:23.84,0:17:25.48,EN,,0,0,0,,And you can make up the rules as you like.
Dialogue: 0,0:17:25.79,0:17:26.94,EN,,0,0,0,,There are lots of them here.
Dialogue: 0,0:17:27.42,0:17:31.04,EN,,0,0,0,,There are things as complicated, for example, as--
Dialogue: 0,0:17:31.26,0:17:33.93,EN,,0,0,0,,oh, I suppose down here some distributive law, you see.
Dialogue: 0,0:17:33.93,0:17:38.57,EN,,0,0,0,,The product of any object c and the sum of d and e
Dialogue: 0,0:17:39.02,0:17:43.66,EN,,0,0,0,,gives the result as the same as the sum of the product of c and d and the product of c and e.
Dialogue: 0,0:17:45.31,0:17:48.67,EN,,0,0,0,,Now, what exactly these rules are doesn't very much interest me.
Dialogue: 0,0:17:49.16,0:17:52.97,EN,,0,0,0,,We're going to be writing the language that will allow us to interpret these rules
Dialogue: 0,0:17:55.50,0:17:57.48,EN,,0,0,0,,so that we can, in fact, make up whatever rules we like,
Dialogue: 0,0:17:58.35,0:18:00.14,EN,,0,0,0,,another whole language of programming.
Dialogue: 0,0:18:03.39,0:18:04.04,EN,,0,0,0,,Well, let's see.
Dialogue: 0,0:18:05.18,0:18:06.96,EN,,0,0,0,,I haven't told you how we're going to do this.
Dialogue: 0,0:18:07.53,0:18:10.06,EN,,0,0,0,,And, of course, for a while, we're going to work on that.
Dialogue: 0,0:18:10.89,0:18:15.40,EN,,0,0,0,,But there's a real question of what is--what am I going to do at all at a large scale?
Dialogue: 0,0:18:17.08,0:18:18.22,EN,,0,0,0,,How do these rules work?
Dialogue: 0,0:18:19.00,0:18:25.45,EN,,0,0,0,,How is the simplifier program going to manipulate these rules with your expression to produce a reasonable answer?
Dialogue: 0,0:18:26.22,0:18:29.85,EN,,0,0,0,,Well, first, I'd like to think about these rules as being some sort of deck of them.
Dialogue: 0,0:18:32.52,0:18:34.22,EN,,0,0,0,,So here I have a whole bunch of rules,
Dialogue: 0,0:18:42.09,0:18:44.49,EN,,0,0,0,,Each rule-- here's a rule--
Dialogue: 0,0:18:46.97,0:18:49.24,EN,,0,0,0,,has a pattern and a skeleton.
Dialogue: 0,0:18:49.72,0:18:51.36,EN,,0,0,0,,I'm trying to make up a control structure for this.
Dialogue: 0,0:18:53.37,0:18:56.56,EN,,0,0,0,,Now, what I have is a matcher,
Dialogue: 0,0:19:00.99,0:19:03.76,EN,,0,0,0,,and I have something which is an instantiater.
Dialogue: 0,0:19:09.66,0:19:12.94,EN,,0,0,0,,And I'm going to pass from the matcher to the instantiater
Dialogue: 0,0:19:14.03,0:19:17.47,EN,,0,0,0,,some set of meaning for the pattern variables,
Dialogue: 0,0:19:18.06,0:19:19.42,EN,,0,0,0,,a dictionary, I'll call it.
Dialogue: 0,0:19:20.59,0:19:21.52,EN,,0,0,0,,A dictionary,
Dialogue: 0,0:19:24.92,0:19:27.82,EN,,0,0,0,,which will say x was matched against the following subexpression
Dialogue: 0,0:19:29.04,0:19:31.31,EN,,0,0,0,,and y was matched against another following subexpression.
Dialogue: 0,0:19:32.25,0:19:36.35,EN,,0,0,0,,And from the instantiater, I will be making expressions,and they will go into the matcher.
Dialogue: 0,0:19:37.16,0:19:38.36,EN,,0,0,0,,They will be expressions.
Dialogue: 0,0:19:45.00,0:19:48.41,EN,,0,0,0,,And the patterns of the rules will be fed into the matcher,
Dialogue: 0,0:19:49.24,0:19:54.40,EN,,0,0,0,,and the skeletons from the same rule will be fed into the instantiater.
Dialogue: 0,0:19:55.21,0:19:56.62,EN,,0,0,0,,Now, this is a little complicated
Dialogue: 0,0:19:57.12,0:19:59.53,EN,,0,0,0,,because when you have something like an algebraic expression,
Dialogue: 0,0:20:00.44,0:20:03.60,EN,,0,0,0,,where  some of the rules are intended to be able to allow you to substitute equal for equal.
Dialogue: 0,0:20:04.24,0:20:05.87,EN,,0,0,0,,These are equal transformation rules.
Dialogue: 0,0:20:06.88,0:20:09.29,EN,,0,0,0,,So all subexpressions of the expression should be looked at.
Dialogue: 0,0:20:11.13,0:20:15.82,EN,,0,0,0,,You give it an expression, this thing, and the rules should be cycled around.
Dialogue: 0,0:20:16.03,0:20:19.71,EN,,0,0,0,,First of all, for every subexpression of the expression you feed in,
Dialogue: 0,0:20:20.22,0:20:22.83,EN,,0,0,0,,all of the rules must be tried and looked at.
Dialogue: 0,0:20:24.33,0:20:27.07,EN,,0,0,0,,And if any rule matches, then this process occurs.
Dialogue: 0,0:20:27.30,0:20:30.63,EN,,0,0,0,,The dictionary--the dictionary is to have some values in it.
Dialogue: 0,0:20:30.63,0:20:33.39,EN,,0,0,0,,The instantiater makes a new expression,
Dialogue: 0,0:20:33.90,0:20:39.10,EN,,0,0,0,,which is basically replaces that part of the expression that was matched in your original expression.
Dialogue: 0,0:20:40.84,0:20:44.46,EN,,0,0,0,,And then, then, of course, we're going to recheck that,
Dialogue: 0,0:20:44.75,0:20:48.11,EN,,0,0,0,,going to go around these rules again, seeing if that could be simplified further.
Dialogue: 0,0:20:49.53,0:20:53.71,EN,,0,0,0,,And then, then we're going to do that for every subexpression until the thing no longer changes.
Dialogue: 0,0:20:54.96,0:20:57.50,EN,,0,0,0,,You can think of this as sort of an organic process.
Dialogue: 0,0:20:57.83,0:21:00.20,EN,,0,0,0,,You've got some sort of stew, right?
Dialogue: 0,0:21:00.24,0:21:04.32,EN,,0,0,0,,You've got bacteria or something, or enzymes in some, in some gooey mess.
Dialogue: 0,0:21:05.63,0:21:10.50,EN,,0,0,0,,And there's these--and these enzymes change things.
Dialogue: 0,0:21:10.50,0:21:14.38,EN,,0,0,0,,They attach to your expression, change it, and then they go away.
Dialogue: 0,0:21:15.28,0:21:17.83,EN,,0,0,0,,And they have to match. The key-in-lock phenomenon.
Dialogue: 0,0:21:18.00,0:21:19.73,EN,,0,0,0,,They match, they change it, they go away.
Dialogue: 0,0:21:19.73,0:21:21.68,EN,,0,0,0,,You can imagine it as a parallel process of some sort.
Dialogue: 0,0:21:22.70,0:21:24.97,EN,,0,0,0,,So you stick an expression into this mess,
Dialogue: 0,0:21:25.80,0:21:28.00,EN,,0,0,0,,and after a while, you take it out, and it's been simplified.
Dialogue: 0,0:21:30.44,0:21:32.64,EN,,0,0,0,,And it just keeps changing until it no longer can be changed.
Dialogue: 0,0:21:33.36,0:21:38.33,EN,,0,0,0,,But these enzymes can attach to any part of the, of the expression.
Dialogue: 0,0:21:39.21,0:21:43.76,EN,,0,0,0,,OK, at this point, I'd like to stop and ask for questions.
Dialogue: 0,0:21:44.92,0:21:45.36,EN,,0,0,0,,Yes.
Dialogue: 0,0:21:45.43,0:21:52.76,EN,,0,0,0,,AUDIENCE: This implies that the matching program and the instantiation program are separate programs; is that right? Or is that-- they are.
Dialogue: 0,0:21:52.76,0:21:53.85,EN,,0,0,0,,PROFESSOR: They're separate little pieces.
Dialogue: 0,0:21:54.14,0:21:56.60,EN,,0,0,0,,They fit together in a larger structure.
Dialogue: 0,0:21:57.26,0:21:59.13,EN,,0,0,0,,AUDIENCE: So I'm going through and matching
Dialogue: 0,0:21:59.61,0:22:03.21,EN,,0,0,0,,and passing the information about what I matched to an instantiater,
Dialogue: 0,0:22:03.39,0:22:06.03,EN,,0,0,0,,which makes the changes. And then I pass that back to the matcher?
Dialogue: 0,0:22:06.11,0:22:08.49,EN,,0,0,0,,PROFESSOR: It won't make a change. It will make a new expression,
Dialogue: 0,0:22:09.61,0:22:18.43,EN,,0,0,0,,which has, which has substituted the values of the pattern variable that were matched on the left-hand side for the variables that are mentioned,
Dialogue: 0,0:22:18.99,0:22:23.80,EN,,0,0,0,,the skeleton variables or evaluation variables or whatever I called them, on the right-hand side.
Dialogue: 0,0:22:25.20,0:22:27.08,EN,,0,0,0,,AUDIENCE: And then that's passed back into the matcher?
Dialogue: 0,0:22:27.20,0:22:32.32,EN,,0,0,0,,PROFESSOR: Then this is going to go around again. This is going to go through this mess until it no longer changes.
Dialogue: 0,0:22:33.31,0:22:37.00,EN,,0,0,0,,AUDIENCE: And it seems that there would be a danger of getting into a recursive loop.
Dialogue: 0,0:22:37.20,0:22:42.00,EN,,0,0,0,,Yes, if you do not write your rules nicely, you are-- indeed,
Dialogue: 0,0:22:42.00,0:22:45.53,EN,,0,0,0,,in any programming language you invent, if it's sufficiently powerful to do anything,
Dialogue: 0,0:22:45.72,0:22:48.40,EN,,0,0,0,,you can write programs that will go into infinite loops.
Dialogue: 0,0:22:49.37,0:22:55.07,EN,,0,0,0,,And indeed, writing a program for doing algebraic manipulation so on will produce infinite loops.
Dialogue: 0,0:23:01.05,0:23:01.52,EN,,0,0,0,,Go ahead.
Dialogue: 0,0:23:01.79,0:23:05.90,EN,,0,0,0,,AUDIENCE: Some language designers feel that this feature is so important
Dialogue: 0,0:23:05.93,0:23:12.03,EN,,0,0,0,,that it should become part of the basic language, for example, scheme in this case.
Dialogue: 0,0:23:12.03,0:23:13.96,EN,,0,0,0,,What are your thoughts on--
Dialogue: 0,0:23:13.96,0:23:15.08,EN,,0,0,0,,PROFESSOR: Which language feature?
Dialogue: 0,0:23:15.79,0:23:17.26,EN,,0,0,0,,AUDIENCE: The pattern matching.
Dialogue: 0,0:23:17.26,0:23:22.03,EN,,0,0,0,,It's all application of such rules should be--
Dialogue: 0,0:23:22.03,0:23:23.70,EN,,0,0,0,,PROFESSOR: Oh, you mean like Prolog?
Dialogue: 0,0:23:23.70,0:23:26.60,EN,,0,0,0,,AUDIENCE: Like Prolog, but it becomes a more general--
Dialogue: 0,0:23:26.60,0:23:27.64,EN,,0,0,0,,PROFESSOR: It's possible.
Dialogue: 0,0:23:28.46,0:23:32.30,EN,,0,0,0,,OK, I think my feeling about that is that
Dialogue: 0,0:23:33.16,0:23:36.49,EN,,0,0,0,,I would like to teach you how to do it so you don't depend upon some language designer.
Dialogue: 0,0:23:40.92,0:23:42.75,EN,,0,0,0,,PROFESSOR: You make it yourself. You can roll your own.
Dialogue: 0,0:23:45.28,0:23:45.63,EN,,0,0,0,,Thank you.
Dialogue: 0,0:23:45.63,0:23:50.63,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:23:50.63,0:23:53.13,Declare,,0,0,0,,{\an2\fad(500,500)}The Structure And Interpretation of Computer Programs
Dialogue: 0,0:23:53.13,0:23:55.63,Declare,,0,0,0,,{\an2\fad(500,500)}By: Prof. Harold Abelson && Gerald Jay Sussman
Dialogue: 0,0:24:00.32,0:24:06.76,Declare,,0,0,0,,{\an2\fad(500,500)}The Structure And Interpretation of Computer Programs
Dialogue: 0,0:24:07.07,0:24:10.52,Declare,,0,0,0,,{\an2\fad(500,500)}Pattern-matching: Rule-based Substitution
Dialogue: 0,0:24:14.08,0:24:15.80,EN,,0,0,0,,Well, let's see.
Dialogue: 0,0:24:15.80,0:24:17.21,EN,,0,0,0,,Now we have to tell you how it works.
Dialogue: 0,0:24:20.00,0:24:24.11,EN,,0,0,0,,It conveniently breaks up into various pieces.
Dialogue: 0,0:24:24.80,0:24:26.54,EN,,0,0,0,,I'd like to look now at the matcher.
Dialogue: 0,0:24:28.72,0:24:31.42,EN,,0,0,0,,The matcher has the following basic structure.
Dialogue: 0,0:24:32.86,0:24:45.12,EN,,0,0,0,,It's a box that takes as its input an expression and a pattern,
Dialogue: 0,0:24:52.09,0:24:53.95,EN,,0,0,0,,and it turns out a dictionary.
Dialogue: 0,0:25:01.71,0:25:08.67,EN,,0,0,0,,A dictionary, remember, is a mapping of pattern variables to the values that were found by matching,
Dialogue: 0,0:25:09.15,0:25:11.05,EN,,0,0,0,,and it puts out another dictionary,
Dialogue: 0,0:25:18.24,0:25:25.53,EN,,0,0,0,,which is the result of augmenting this dictionary by what was found in matching this expression against this pattern.
Dialogue: 0,0:25:28.00,0:25:28.83,EN,,0,0,0,,So that's the matcher.
Dialogue: 0,0:25:33.87,0:25:36.54,EN,,0,0,0,,Now, this is a rather complicated program,
Dialogue: 0,0:25:37.20,0:25:41.58,EN,,0,0,0,,and we can look at it on the overhead over here and see,
Dialogue: 0,0:25:41.98,0:25:43.87,EN,,0,0,0,,ha ha, it's very complicated.
Dialogue: 0,0:25:44.43,0:25:45.87,EN,,0,0,0,,I just want you to look at the shape of it.
Dialogue: 0,0:25:46.78,0:25:49.85,EN,,0,0,0,,It's too complicated to look at except in pieces.
Dialogue: 0,0:25:51.72,0:25:59.24,EN,,0,0,0,,However, it's a fairly large, complicated program with a lot of sort of indented structure.
Dialogue: 0,0:26:00.09,0:26:05.28,EN,,0,0,0,,At the largest scale-- you don't try to read those characters, but at the largest scale,
Dialogue: 0,0:26:05.43,0:26:10.36,EN,,0,0,0,,you see that there is a case analysis, which is all these cases lined up.
Dialogue: 0,0:26:12.09,0:26:16.19,EN,,0,0,0,,What we're now going to do is look at this in a bit more detail,
Dialogue: 0,0:26:16.67,0:26:18.60,EN,,0,0,0,,attempting to understand how it works.
Dialogue: 0,0:26:20.08,0:26:22.35,EN,,0,0,0,,Let's go now to the first slide,
Dialogue: 0,0:26:23.55,0:26:27.93,EN,,0,0,0,,showing some of the structure of the matcher at a large scale.
Dialogue: 0,0:26:28.81,0:26:36.33,EN,,0,0,0,,And we see that the matcher, the matcher takes as its input a pattern, an expression, and a dictionary.
Dialogue: 0,0:26:38.57,0:26:40.40,EN,,0,0,0,,And there is a case analysis here,
Dialogue: 0,0:26:41.24,0:26:45.61,EN,,0,0,0,,which is made out of several cases, some of which have been left out over here,
Dialogue: 0,0:26:46.62,0:26:48.62,EN,,0,0,0,,and the general case, which I'd like you to see.
Dialogue: 0,0:26:50.52,0:26:53.28,EN,,0,0,0,,Let's consider this general case. It's a very important pattern.
Dialogue: 0,0:26:56.32,0:27:01.61,EN,,0,0,0,,The problem is that we have to examine two trees simultaneously.
Dialogue: 0,0:27:02.50,0:27:08.03,EN,,0,0,0,,One of the trees is the tree of the expression, and the other is the tree of the pattern.
Dialogue: 0,0:27:08.59,0:27:10.11,EN,,0,0,0,,We have to compare them with each other
Dialogue: 0,0:27:11.37,0:27:16.38,EN,,0,0,0,,so that the subexpressions of the expression are matched against subexpressions of the pattern.
Dialogue: 0,0:27:18.38,0:27:23.44,EN,,0,0,0,,Looking at that in a bit more detail, suppose I had a pattern, a pattern,
Dialogue: 0,0:27:23.93,0:27:31.24,EN,,0,0,0,,which was the sum of the product of a thing which we will call x
Dialogue: 0,0:27:32.44,0:27:35.53,EN,,0,0,0,,and a thing which we will call y,
Dialogue: 0,0:27:39.12,0:27:42.04,EN,,0,0,0,,and the sum of that, and the same thing we call y.
Dialogue: 0,0:27:45.21,0:27:47.53,EN,,0,0,0,,So we're looking for a sum of a product
Dialogue: 0,0:27:48.99,0:27:54.78,EN,,0,0,0,,whose second--whose second argument is the same as the second argument of the sum.
Dialogue: 0,0:27:57.02,0:27:58.84,EN,,0,0,0,,That's a thing you might be looking for.
Dialogue: 0,0:27:59.60,0:28:02.04,EN,,0,0,0,,Well, that, as a pattern, looks like this.
Dialogue: 0,0:28:03.02,0:28:04.01,EN,,0,0,0,,There is a tree,
Dialogue: 0,0:28:04.94,0:28:06.25,EN,,0,0,0,,which consists of a sum,
Dialogue: 0,0:28:08.08,0:28:20.25,EN,,0,0,0,,and a product with a pattern variable question mark x and question mark y,
Dialogue: 0,0:28:21.36,0:28:22.73,EN,,0,0,0,,and question mark y,
Dialogue: 0,0:28:24.92,0:28:26.94,EN,,0,0,0,,just looking at the same, just writing down the list structure in a different way.
Dialogue: 0,0:28:28.75,0:28:31.76,EN,,0,0,0,,Now, suppose we were matching that against an expression which matches it,
Dialogue: 0,0:28:32.49,0:28:39.85,EN,,0,0,0,,the product of 3 and x and, say, x.
Dialogue: 0,0:28:42.41,0:28:43.36,EN,,0,0,0,,That's another tree.
Dialogue: 0,0:28:44.33,0:28:56.06,EN,,0,0,0,,It's the sum of the product of 3 and x and of x.
Dialogue: 0,0:28:59.44,0:29:03.02,EN,,0,0,0,,So what I want to do is traverse these two trees simultaneously.
Dialogue: 0,0:29:04.41,0:29:07.82,EN,,0,0,0,,And what I'd like to do is walk them like this.
Dialogue: 0,0:29:08.67,0:29:12.96,EN,,0,0,0,,I'm going to say are these the same?
Dialogue: 0,0:29:12.96,0:29:14.32,EN,,0,0,0,,This is a complicated object.
Dialogue: 0,0:29:15.21,0:29:17.26,EN,,0,0,0,,Let's look at the left branches.
Dialogue: 0,0:29:17.26,0:29:18.14,EN,,0,0,0,,Well, that could be the car.
Dialogue: 0,0:29:18.56,0:29:21.21,EN,,0,0,0,,How does that look? Oh yes, the plus looks just fine.
Dialogue: 0,0:29:21.68,0:29:24.20,EN,,0,0,0,,But the next thing here is a complicated thing.
Dialogue: 0,0:29:24.20,0:29:24.84,EN,,0,0,0,,Let's look at that.
Dialogue: 0,0:29:25.20,0:29:26.80,EN,,0,0,0,,Oh yes, that's pretty fine, too.
Dialogue: 0,0:29:26.80,0:29:27.79,EN,,0,0,0,,They're both asterisks.
Dialogue: 0,0:29:28.51,0:29:30.24,EN,,0,0,0,,Now, whoops!
Dialogue: 0,0:29:30.40,0:29:33.60,EN,,0,0,0,,My pattern variable, it matches against the 3.
Dialogue: 0,0:29:34.27,0:29:35.92,EN,,0,0,0,,Remember, x equals 3 now.
Dialogue: 0,0:29:36.36,0:29:37.37,EN,,0,0,0,,That's in my dictionary,
Dialogue: 0,0:29:37.56,0:29:40.73,EN,,0,0,0,,and the dictionary's going to follow along with me: x equals three.
Dialogue: 0,0:29:41.45,0:29:45.87,EN,,0,0,0,,Ah yes, x equals 3 and y equals x, different x.
Dialogue: 0,0:29:46.83,0:29:51.20,EN,,0,0,0,,The pattern x is the expression x, the pattern y.
Dialogue: 0,0:29:53.61,0:29:57.76,EN,,0,0,0,,Oh yes, the pattern variable y, I've already got a value for it. It's x.
Dialogue: 0,0:29:58.36,0:30:00.06,EN,,0,0,0,,Is this an x? Oh yeah, sure it is.
Dialogue: 0,0:30:00.06,0:30:00.75,EN,,0,0,0,,That's fine.
Dialogue: 0,0:30:02.03,0:30:02.78,EN,,0,0,0,,Yep, done.
Dialogue: 0,0:30:03.39,0:30:08.09,EN,,0,0,0,,I now have a dictionary, which I've accumulated by making this walk.
Dialogue: 0,0:30:11.42,0:30:14.51,EN,,0,0,0,,Well, now let's look at this general case here and see how that works.
Dialogue: 0,0:30:15.88,0:30:16.51,EN,,0,0,0,,Here we have it.
Dialogue: 0,0:30:17.20,0:30:21.66,EN,,0,0,0,,I take in a pattern variable -- sorry -- a pattern, an expression, and a dictionary.
Dialogue: 0,0:30:22.38,0:30:27.50,EN,,0,0,0,,And now I'm going to do a complicated thing here, which is the general case.
Dialogue: 0,0:30:29.98,0:30:34.80,EN,,0,0,0,,The expression is made out of two parts: a left and a right half, in general.
Dialogue: 0,0:30:35.45,0:30:38.81,EN,,0,0,0,,Anything that's complicated is made out of two pieces in a Lisp system.
Dialogue: 0,0:30:40.03,0:30:41.23,EN,,0,0,0,,Well, now what do we have here?
Dialogue: 0,0:30:41.88,0:30:48.84,EN,,0,0,0,,I'm going to match the car's of the two expressions against each other with respect to the dictionary I already have,
Dialogue: 0,0:30:50.30,0:30:53.12,EN,,0,0,0,,producing a dictionary as its value,
Dialogue: 0,0:30:54.14,0:30:57.26,EN,,0,0,0,,which I will then use for matching the cdr's against each other.
Dialogue: 0,0:30:58.51,0:31:02.09,EN,,0,0,0,,So that's how the dictionary travels, threads the entire structure.
Dialogue: 0,0:31:03.66,0:31:07.53,EN,,0,0,0,,And then the result of that is the dictionary for the match of the car and the cdr,
Dialogue: 0,0:31:10.12,0:31:12.41,EN,,0,0,0,,and that's what's going to be returned as a value.
Dialogue: 0,0:31:13.61,0:31:15.84,EN,,0,0,0,,Now, at any point, a match might fail.
Dialogue: 0,0:31:16.62,0:31:18.20,EN,,0,0,0,,It may be the case, for example,
Dialogue: 0,0:31:18.36,0:31:27.18,EN,,0,0,0,,if we go back and look at an expression that doesn't quite match, like supposing this was a 4.
Dialogue: 0,0:31:29.13,0:31:34.81,EN,,0,0,0,,Well, now these two don't match any more, because the x that had to be  --
Dialogue: 0,0:31:34.93,0:31:37.34,EN,,0,0,0,,sorry, the y that had to be x here
Dialogue: 0,0:31:37.82,0:31:40.12,EN,,0,0,0,,and this y has to be 4.
Dialogue: 0,0:31:40.53,0:31:43.52,EN,,0,0,0,,But x and 4 were not the same object syntactically.
Dialogue: 0,0:31:44.59,0:31:48.81,EN,,0,0,0,,So this wouldn't match, and that would be rejected sometimes, so matches may fail.
Dialogue: 0,0:31:50.19,0:31:56.08,EN,,0,0,0,,Now, of course, because this matcher takes the dictionary from the previous match as input,
Dialogue: 0,0:31:56.52,0:31:58.28,EN,,0,0,0,,it must be able to propagate the failures.
Dialogue: 0,0:31:58.57,0:32:01.04,EN,,0,0,0,,And so that's what the first clause of this conditional does.
Dialogue: 0,0:32:03.61,0:32:08.19,EN,,0,0,0,,It's also true that if it turned out that the pattern was not atomic--
Dialogue: 0,0:32:08.50,0:32:11.45,EN,,0,0,0,,see, if the pattern was atomic, I'd go into this stuff, which we haven't looked at yet.
Dialogue: 0,0:32:12.17,0:32:13.56,EN,,0,0,0,,But if the pattern is not atomic
Dialogue: 0,0:32:15.05,0:32:19.23,EN,,0,0,0,,and the expression is atomic-- it's not made out of pieces--
Dialogue: 0,0:32:20.14,0:32:22.65,EN,,0,0,0,,then that must be a failure, and so we go over here.
Dialogue: 0,0:32:23.64,0:32:30.78,EN,,0,0,0,,If the pattern is not atomic and the pattern is not a pattern variable--I have to remind myself of that-- then we go over here.
Dialogue: 0,0:32:30.96,0:32:32.51,EN,,0,0,0,,So that's way, failures may occur.
Dialogue: 0,0:32:35.26,0:32:39.12,EN,,0,0,0,,OK, so now let's look at the insides of this thing.
Dialogue: 0,0:32:39.84,0:32:42.93,EN,,0,0,0,,Well, the first place to look is what happens if I have an atomic pattern?
Dialogue: 0,0:32:42.93,0:32:43.90,EN,,0,0,0,,That's very simple.
Dialogue: 0,0:32:43.90,0:32:46.50,EN,,0,0,0,,A pattern that's not made out of any pieces: foo.
Dialogue: 0,0:32:47.37,0:32:48.54,EN,,0,0,0,,That's a nice atomic pattern.
Dialogue: 0,0:32:49.16,0:32:51.24,EN,,0,0,0,,Well, here's what we see.
Dialogue: 0,0:32:52.08,0:32:55.82,EN,,0,0,0,,If the pattern is atomic, then if the expression is atomic,
Dialogue: 0,0:32:56.80,0:33:01.85,EN,,0,0,0,,then if they are the same thing, then the dictionary I get is the same one as I had before.
Dialogue: 0,0:33:03.08,0:33:04.00,EN,,0,0,0,,Nothing's changed.
Dialogue: 0,0:33:04.60,0:33:10.33,EN,,0,0,0,,It's just that I matched plus against plus, asterisk against asterisk, x against x.
Dialogue: 0,0:33:11.42,0:33:12.33,EN,,0,0,0,,That's all fine.
Dialogue: 0,0:33:13.07,0:33:16.81,EN,,0,0,0,,However, if the pattern is not the one which is the expression,
Dialogue: 0,0:33:17.32,0:33:21.36,EN,,0,0,0,,if I have two separate atomic objects, then it was matching plus against asterisk,
Dialogue: 0,0:33:22.44,0:33:23.40,EN,,0,0,0,,which case I fail.
Dialogue: 0,0:33:25.60,0:33:34.56,EN,,0,0,0,,Or if it turns out that the pattern is atomic but the expression is complicated, it's not atomic, then I get a failure.
Dialogue: 0,0:33:37.40,0:33:38.24,EN,,0,0,0,,That's very simple.
Dialogue: 0,0:33:38.81,0:33:43.61,EN,,0,0,0,,Now, what about the various kinds of pattern variables?
Dialogue: 0,0:33:44.09,0:33:46.54,EN,,0,0,0,,We had three kinds. I give them the names.
Dialogue: 0,0:33:47.39,0:33:52.03,EN,,0,0,0,,They're arbitrary constants, arbitrary variables, and arbitrary expressions.
Dialogue: 0,0:33:53.82,0:34:00.14,EN,,0,0,0,,A question mark x is an arbitrary expression.
Dialogue: 0,0:34:01.18,0:34:04.54,EN,,0,0,0,,A question mark cx is an arbitrary constant,
Dialogue: 0,0:34:04.73,0:34:07.29,EN,,0,0,0,,and a question mark vx is an arbitrary variable.
Dialogue: 0,0:34:08.96,0:34:09.79,EN,,0,0,0,,Well, what do we do here?
Dialogue: 0,0:34:10.51,0:34:16.94,EN,,0,0,0,,Looking at this, we see that if I have an arbitrary constant, if the pattern is an arbitrary constant,
Dialogue: 0,0:34:17.53,0:34:20.57,EN,,0,0,0,,then it had better be the case that the expression had better be a constant.
Dialogue: 0,0:34:21.48,0:34:23.53,EN,,0,0,0,,If the expression is not a constant, then that match fails.
Dialogue: 0,0:34:23.83,0:34:27.50,EN,,0,0,0,,If it is a constant, however, then I wish to extend the dictionary.
Dialogue: 0,0:34:27.50,0:34:29.69,EN,,0,0,0,,I wish to extend the dictionary
Dialogue: 0,0:34:30.70,0:34:37.76,EN,,0,0,0,,with that pattern being remembered to be that expression using the old dictionary as a starting point.
Dialogue: 0,0:34:41.16,0:34:42.75,EN,,0,0,0,,So really, for arbitrary variables,
Dialogue: 0,0:34:43.72,0:34:47.46,EN,,0,0,0,,I have to check first if the expression is a variable by matching against.
Dialogue: 0,0:34:47.46,0:34:50.09,EN,,0,0,0,,If so, it's worth extending the dictionary
Dialogue: 0,0:34:50.38,0:34:54.65,EN,,0,0,0,,so the pattern is remembered to be matched against that expression, given the original dictionary,
Dialogue: 0,0:34:55.28,0:34:56.70,EN,,0,0,0,,and this makes a new dictionary.
Dialogue: 0,0:34:58.88,0:35:04.16,EN,,0,0,0,,Now, it has to check. There's a sorts of failure inside extend dictionary, which is that--
Dialogue: 0,0:35:04.16,0:35:07.50,EN,,0,0,0,,if one of these pattern variables already has a value
Dialogue: 0,0:35:09.23,0:35:16.17,EN,,0,0,0,,and I'm trying to match the thing against something else which is not equivalent to the one that I've already matched it against once,
Dialogue: 0,0:35:16.43,0:35:18.36,EN,,0,0,0,,then a failure will come flying out of here, too.
Dialogue: 0,0:35:20.16,0:35:21.56,EN,,0,0,0,,And I will see that some time.
Dialogue: 0,0:35:22.91,0:35:29.36,EN,,0,0,0,,And finally, an expression does not have to check anything syntactic about the expression that's being matched,
Dialogue: 0,0:35:30.11,0:35:32.20,EN,,0,0,0,,so all it does is it's an extension of the dictionary.
Dialogue: 0,0:35:34.76,0:35:38.32,EN,,0,0,0,,So you've just seen a complete, very simple matcher.
Dialogue: 0,0:35:39.28,0:35:41.37,EN,,0,0,0,,Now, one of the things that's rather remarkable about this
Dialogue: 0,0:35:41.66,0:35:45.12,EN,,0,0,0,,is people pay an awful lot of money these days for someone to make
Dialogue: 0,0:35:45.46,0:35:47.52,EN,,0,0,0,,a, quote, AI expert system
Dialogue: 0,0:35:48.40,0:35:52.03,EN,,0,0,0,,that has nothing more in it than a matcher and maybe an instantiater like this.
Dialogue: 0,0:35:53.56,0:35:56.94,EN,,0,0,0,,But it's very easy to do, and now, of course, you can start up a little start-up company
Dialogue: 0,0:35:57.42,0:36:01.72,EN,,0,0,0,,and make a couple of megabucks in the next week taking some people for a ride.
Dialogue: 0,0:36:03.79,0:36:08.57,EN,,0,0,0,,I mean, 20 years ago, this was remarkable, this kind of program.
Dialogue: 0,0:36:09.74,0:36:12.81,EN,,0,0,0,,But now, this is sort of easy. You can teach it to freshmen.
Dialogue: 0,0:36:13.63,0:36:15.47,EN,,0,0,0,,Well, now there's an instantiater as well.
Dialogue: 0,0:36:20.22,0:36:23.07,EN,,0,0,0,,The problem is they're all going off and making more money than I do. Alright?
Dialogue: 0,0:36:24.97,0:36:26.59,EN,,0,0,0,,But that's always been true of universities.
Dialogue: 0,0:36:27.10,0:36:39.42,EN,,0,0,0,,As expression, the purpose of the instantiater is to make expressions given a dictionary and a skeleton.
Dialogue: 0,0:36:44.35,0:36:45.69,EN,,0,0,0,,And that's not very hard at all.
Dialogue: 0,0:36:46.60,0:36:53.36,EN,,0,0,0,,We'll see that very simply in the next, the next slide here.
Dialogue: 0,0:36:53.88,0:36:59.29,EN,,0,0,0,,To instantiate a skeleton, given a particular dictionary-- oh, this is easy.
Dialogue: 0,0:36:59.68,0:37:03.29,EN,,0,0,0,,We're going to do a recursive tree walk over the skeleton.
Dialogue: 0,0:37:04.08,0:37:08.33,EN,,0,0,0,,And for everything which is a skeleton variable-- I don't know, call it a skeleton evaluation.
Dialogue: 0,0:37:08.41,0:37:11.42,EN,,0,0,0,,That's the name and the abstract syntax that I give it in this program:
Dialogue: 0,0:37:11.60,0:37:16.46,EN,,0,0,0,,a skeleton evaluation, a thing beginning with a colon in the rules.
Dialogue: 0,0:37:18.25,0:37:24.30,EN,,0,0,0,,For anything of that case, I'm going to look up the answer in the dictionary, and we'll worry about that in a second.
Dialogue: 0,0:37:24.30,0:37:25.61,EN,,0,0,0,,Let's look at this as a whole.
Dialogue: 0,0:37:27.77,0:37:31.80,EN,,0,0,0,,Here, I have-- I'm going to instantiate a skeleton, given a dictionary.
Dialogue: 0,0:37:32.75,0:37:37.15,EN,,0,0,0,,Well, I'm going to define some internal loop right there,
Dialogue: 0,0:37:38.14,0:37:39.85,EN,,0,0,0,,and it's going to do something very simple.
Dialogue: 0,0:37:40.17,0:37:43.50,EN,,0,0,0,,Even if a skeleton--even if a skeleton is simple and atomic,
Dialogue: 0,0:37:44.60,0:37:47.45,EN,,0,0,0,,in which case it's nothing more than giving the skeleton back as an answer,
Dialogue: 0,0:37:48.84,0:37:51.87,EN,,0,0,0,,or in the general case, it's complicated,
Dialogue: 0,0:37:52.60,0:37:59.40,EN,,0,0,0,,in which case I'm going to make up the expression which is the result of instantiating--
Dialogue: 0,0:37:59.40,0:38:04.25,EN,,0,0,0,,calling this loop recursively-- instantiating the car of the skeleton and the cdr.
Dialogue: 0,0:38:04.89,0:38:06.24,EN,,0,0,0,,So here is a recursive tree walk.
Dialogue: 0,0:38:08.41,0:38:14.36,EN,,0,0,0,,However, if it turns out to be a skeleton evaluation, a colon expression in the skeleton,
Dialogue: 0,0:38:14.96,0:38:22.64,EN,,0,0,0,,then what I'm going to do is find the expression that's in the colon-- the CADR in this case.
Dialogue: 0,0:38:22.81,0:38:26.25,EN,,0,0,0,,It's a piece of abstract syntax here, so I can change my representation of rules.
Dialogue: 0,0:38:27.52,0:38:32.73,EN,,0,0,0,,I'm going to evaluate that relative to this dictionary, whatever evaluation means.
Dialogue: 0,0:38:32.90,0:38:34.65,EN,,0,0,0,,We'll find out a lot about that sometime.
Dialogue: 0,0:38:36.12,0:38:38.35,EN,,0,0,0,,And the result of that is my answer.
Dialogue: 0,0:38:39.68,0:38:43.66,EN,,0,0,0,,so. I start up this loop-- here's my initialization-- by calling it with the whole skeleton,
Dialogue: 0,0:38:44.44,0:38:47.04,EN,,0,0,0,,and this will just do a recursive decomposition into pieces.
Dialogue: 0,0:38:49.63,0:38:56.48,EN,,0,0,0,,Now, one more little bit of detail is what happens inside evaluate?
Dialogue: 0,0:38:57.18,0:38:59.07,EN,,0,0,0,,I can't tell you that in great detail.
Dialogue: 0,0:38:59.98,0:39:01.34,EN,,0,0,0,,I'll tell you a little bit of it.
Dialogue: 0,0:39:01.56,0:39:03.74,EN,,0,0,0,,Later, we're going to see--look into this in much more detail.
Dialogue: 0,0:39:05.29,0:39:10.81,EN,,0,0,0,,To evaluate some form, some expression with respect to a dictionary,
Dialogue: 0,0:39:11.90,0:39:14.17,EN,,0,0,0,,if the expression is an atomic object, well,
Dialogue: 0,0:39:15.04,0:39:16.22,EN,,0,0,0,,I'm going to go look it up.
Dialogue: 0,0:39:18.60,0:39:19.87,EN,,0,0,0,,Nothing very exciting there.
Dialogue: 0,0:39:20.57,0:39:23.66,EN,,0,0,0,,Otherwise, I'm going to do something complicated here,
Dialogue: 0,0:39:23.83,0:39:28.28,EN,,0,0,0,,which is I'm going to apply a procedure which is the result of looking up the operator part
Dialogue: 0,0:39:29.44,0:39:31.68,EN,,0,0,0,,in something that we're going to find out about someday.
Dialogue: 0,0:39:32.14,0:39:34.20,EN,,0,0,0,,I want you realize you're seeing magic now.
Dialogue: 0,0:39:34.67,0:39:38.72,EN,,0,0,0,,This magic will become clear very soon, but not today.
Dialogue: 0,0:39:40.00,0:39:46.51,EN,,0,0,0,,Then I'm looking at--looking up all the pieces, all the arguments to that in the dictionary.
Dialogue: 0,0:39:48.56,0:39:50.88,EN,,0,0,0,,So I don't want you to look at this in detail.
Dialogue: 0,0:39:51.44,0:39:53.44,EN,,0,0,0,,I want you to see that there's more going on here,
Dialogue: 0,0:39:54.17,0:39:56.75,EN,,0,0,0,,and we're going to see more about this.
Dialogue: 0,0:39:59.04,0:40:00.88,EN,,0,0,0,,But it's-- the magic is going to stop.
Dialogue: 0,0:40:02.57,0:40:06.96,EN,,0,0,0,,This part has to do with Lisp, and it's the end of that.
Dialogue: 0,0:40:10.25,0:40:13.56,EN,,0,0,0,,OK, so now we know about matching and instantiation.
Dialogue: 0,0:40:15.05,0:40:16.60,EN,,0,0,0,,Are there any questions for this segment?
Dialogue: 0,0:40:28.10,0:40:29.80,EN,,0,0,0,,AUDIENCE: I have a question.
Dialogue: 0,0:40:29.80,0:40:30.43,EN,,0,0,0,,PROFESSOR: Yes.
Dialogue: 0,0:40:30.43,0:40:32.56,EN,,0,0,0,,AUDIENCE: Is it possible to bring up a previous slide?
Dialogue: 0,0:40:33.60,0:40:35.56,EN,,0,0,0,,It's about this define match pattern.
Dialogue: 0,0:40:36.16,0:40:40.76,EN,,0,0,0,,PROFESSOR: Yes. You'd like to see the overall slide define match pattern.
Dialogue: 0,0:40:40.76,0:40:43.06,EN,,0,0,0,,Can somebody put up the -- no, the overhead.
Dialogue: 0,0:40:43.06,0:40:45.16,EN,,0,0,0,,That's the biggest scale one.
Dialogue: 0,0:40:45.31,0:40:46.40,EN,,0,0,0,,What part would you like to see?
Dialogue: 0,0:40:46.76,0:40:49.96,EN,,0,0,0,,AUDIENCE: Well, the top would be fine.
Dialogue: 0,0:40:49.96,0:40:53.76,EN,,0,0,0,,Any of the parts where you're passing failed.
Dialogue: 0,0:40:54.52,0:40:55.21,EN,,0,0,0,,PROFESSOR: Yes.
Dialogue: 0,0:40:55.64,0:40:59.33,EN,,0,0,0,,AUDIENCE: The idea is to pass failed back to the dictionary; is that right?
Dialogue: 0,0:40:59.33,0:41:04.25,EN,,0,0,0,,PROFESSOR: The dictionary is the answer to a match, right?
Dialogue: 0,0:41:05.16,0:41:09.80,EN,,0,0,0,,And it is either some mapping
Dialogue: 0,0:41:11.07,0:41:14.03,EN,,0,0,0,,or there's no match. It doesn't match.
Dialogue: 0,0:41:14.46,0:41:14.97,EN,,0,0,0,,AUDIENCE: Right.
Dialogue: 0,0:41:15.26,0:41:17.83,EN,,0,0,0,,PROFESSOR: So what you're seeing over here is, in fact,
Dialogue: 0,0:41:17.83,0:41:22.60,EN,,0,0,0,,because the fact that a match may have another match pass in the dictionary,
Dialogue: 0,0:41:22.80,0:41:24.65,EN,,0,0,0,,as you see in the general case down here.
Dialogue: 0,0:41:25.12,0:41:27.93,EN,,0,0,0,,Here's the general case where a match passes another match to the dictionary.
Dialogue: 0,0:41:28.14,0:41:34.16,EN,,0,0,0,,When I match the cdr's, I match them in the dictionary that is resulting from matching the car's.
Dialogue: 0,0:41:36.06,0:41:37.08,EN,,0,0,0,,OK, that's what I have here.
Dialogue: 0,0:41:37.29,0:41:40.30,EN,,0,0,0,,So because of that, if the match of the car's fails,
Dialogue: 0,0:41:41.23,0:41:45.44,EN,,0,0,0,,then it may be necessary that the match of the cdr's propagates that failure,
Dialogue: 0,0:41:45.95,0:41:46.96,EN,,0,0,0,,and that's what the first line is.
Dialogue: 0,0:41:48.26,0:41:51.73,EN,,0,0,0,,AUDIENCE: OK, well, I'm still unclear what matches--
Dialogue: 0,0:41:51.73,0:41:54.24,EN,,0,0,0,,what comes out of one instance of the match?
Dialogue: 0,0:41:54.73,0:41:56.00,EN,,0,0,0,,PROFESSOR: One of two possibilities.
Dialogue: 0,0:41:56.33,0:41:59.15,EN,,0,0,0,,Either the symbol failed, which means there is no match.
Dialogue: 0,0:41:59.53,0:41:59.93,EN,,0,0,0,,AUDIENCE: Right.
Dialogue: 0,0:41:59.93,0:42:03.87,EN,,0,0,0,,PROFESSOR: Or some mapping, which is an abstract thing right now,
Dialogue: 0,0:42:04.16,0:42:05.68,EN,,0,0,0,,and you should know about the structure of it,
Dialogue: 0,0:42:06.49,0:42:13.96,EN,,0,0,0,,which relates the pattern variables to their values as picked up in the match.
Dialogue: 0,0:42:14.68,0:42:16.70,EN,,0,0,0,,AUDIENCE: OK, so it is--
Dialogue: 0,0:42:16.80,0:42:18.57,EN,,0,0,0,,PROFESSOR: That's constructed by extend dictionary.
Dialogue: 0,0:42:18.80,0:42:28.54,EN,,0,0,0,,AUDIENCE: So the recursive nature brings about the fact that if ever a failed gets passed out of any calling of match,
Dialogue: 0,0:42:28.68,0:42:30.30,EN,,0,0,0,,then the first condition will pick it up--
Dialogue: 0,0:42:30.40,0:42:33.56,EN,,0,0,0,,PROFESSOR: And just propagate it along without any further ado, right.
Dialogue: 0,0:42:33.56,0:42:34.83,EN,,0,0,0,,AUDIENCE: Oh, right.
Dialogue: 0,0:42:35.50,0:42:37.36,EN,,0,0,0,,PROFESSOR: That's just the fastest way to get that failure out of there.
Dialogue: 0,0:42:42.86,0:42:43.60,EN,,0,0,0,,Yes.
Dialogue: 0,0:42:43.84,0:42:47.23,EN,,0,0,0,,AUDIENCE: If I don't fail, that means that I've matched a pattern,
Dialogue: 0,0:42:47.84,0:42:53.00,EN,,0,0,0,,and I run the procedure extend dict and then pass in the pattern in the expression.
Dialogue: 0,0:42:55.21,0:42:58.43,EN,,0,0,0,,But the substitution will not be made at that point; is that right?
Dialogue: 0,0:42:58.43,0:42:59.03,EN,,0,0,0,,I'm just--
Dialogue: 0,0:42:59.03,0:42:59.46,EN,,0,0,0,,PROFESSOR: No, no.
Dialogue: 0,0:42:59.46,0:43:02.40,EN,,0,0,0,,There's no substitution being there because there's no skeleton to be substituted in.
Dialogue: 0,0:43:02.40,0:43:03.06,EN,,0,0,0,,AUDIENCE: Right. So
Dialogue: 0,0:43:03.06,0:43:07.16,EN,,0,0,0,,PROFESSOR: All you've got there is we're making up the dictionary for later substitution.
Dialogue: 0,0:43:08.25,0:43:12.43,EN,,0,0,0,,AUDIENCE: And what would the dictionary look like? Is it ordered pairs?
Dialogue: 0,0:43:12.72,0:43:15.96,EN,,0,0,0,,PROFESSOR: Ahhhhh, That's--that's not told to you.
Dialogue: 0,0:43:15.96,0:43:16.89,EN,,0,0,0,,We're being abstract.
Dialogue: 0,0:43:17.06,0:43:17.56,EN,,0,0,0,,AUDIENCE: OK.
Dialogue: 0,0:43:17.56,0:43:18.90,EN,,0,0,0,,PROFESSOR: Why do you want to know?
Dialogue: 0,0:43:18.90,0:43:21.64,EN,,0,0,0,,What it is, it's a function. It's a function.
Dialogue: 0,0:43:21.69,0:43:22.33,EN,,0,0,0,,AUDIENCE: Well, the reason I want to know is--
Dialogue: 0,0:43:22.33,0:43:24.17,EN,,0,0,0,,PROFESSOR: A function abstractly is a set of ordered pairs.
Dialogue: 0,0:43:25.12,0:43:28.44,EN,,0,0,0,,It could be implemented as a set of list pairs.
Dialogue: 0,0:43:29.06,0:43:32.43,EN,,0,0,0,,It could be implemented as some fancy table mechanism.
Dialogue: 0,0:43:32.56,0:43:34.16,EN,,0,0,0,,It could be implemented as a function.
Dialogue: 0,0:43:35.80,0:43:37.40,EN,,0,0,0,,And somehow, I'm building up a function.
Dialogue: 0,0:43:39.02,0:43:39.87,EN,,0,0,0,,But I'm not telling you.
Dialogue: 0,0:43:40.84,0:43:43.08,EN,,0,0,0,,That's up to George, who's going to build that later.
Dialogue: 0,0:43:49.56,0:43:52.06,EN,,0,0,0,,I know you really badly want to write concrete things.
Dialogue: 0,0:43:52.36,0:43:54.19,EN,,0,0,0,,I'm not going to let you do that.
Dialogue: 0,0:43:54.43,0:43:59.23,EN,,0,0,0,,AUDIENCE: Well, let me at least ask, what is the important information there that's being passed to extend dict?
Dialogue: 0,0:43:59.74,0:44:02.08,EN,,0,0,0,,I want to pass the pattern I found--
Dialogue: 0,0:44:02.73,0:44:04.83,EN,,0,0,0,,PROFESSOR: Yes. The pattern that's matched against the expression.
Dialogue: 0,0:44:04.83,0:44:09.30,EN,,0,0,0,,You want to have the pattern, which happens to be in those cases pattern variables, right?
Dialogue: 0,0:44:09.85,0:44:12.89,EN,,0,0,0,,All of those three cases for extend dict are pattern variables.
Dialogue: 0,0:44:13.20,0:44:13.50,EN,,0,0,0,,AUDIENCE: Right.
Dialogue: 0,0:44:14.48,0:44:18.75,EN,,0,0,0,,PROFESSOR: So you have a pattern variable that is to be given a value in a dictionary.
Dialogue: 0,0:44:19.45,0:44:22.11,EN,,0,0,0,,PROFESSOR: The value is the expression that it matched against.
Dialogue: 0,0:44:23.31,0:44:29.63,EN,,0,0,0,,The dictionary is the set of things I've already figured out that I have memorized or learned.
Dialogue: 0,0:44:30.54,0:44:34.41,EN,,0,0,0,,And I am going to make a new dictionary, which is extended from the original one
Dialogue: 0,0:44:35.12,0:44:38.35,EN,,0,0,0,,by having that pattern variable have a value with the new dictionary.
Dialogue: 0,0:44:39.98,0:44:43.73,EN,,0,0,0,,AUDIENCE: I guess what I don't understand is why can't the substitution be made right as soon as you find--
Dialogue: 0,0:44:43.73,0:44:44.80,EN,,0,0,0,,PROFESSOR: How do I know what I'm going to substitute?
Dialogue: 0,0:44:44.81,0:44:46.62,EN,,0,0,0,,I don't know anything about this skeleton.
Dialogue: 0,0:44:47.58,0:44:49.66,EN,,0,0,0,,This pattern, this matcher is an independent unit.
Dialogue: 0,0:44:49.66,0:44:51.00,EN,,0,0,0,,AUDIENCE: Oh, I see. OK.
Dialogue: 0,0:44:51.00,0:44:51.50,EN,,0,0,0,,PROFESSOR: Right?
Dialogue: 0,0:44:51.50,0:44:51.90,EN,,0,0,0,,AUDIENCE: Yeah.
Dialogue: 0,0:44:51.90,0:44:57.23,EN,,0,0,0,,PROFESSOR: I take the matcher. I apply the matcher. If it matches, then it was worth doing instantiation.
Dialogue: 0,0:44:58.20,0:44:59.50,EN,,0,0,0,,AUDIENCE: OK, good.
Dialogue: 0,0:45:00.54,0:45:03.88,EN,,0,0,0,,AUDIENCE: Can you just do that answer again using that example on the board?
Dialogue: 0,0:45:04.89,0:45:06.93,EN,,0,0,0,,You know, what you just passed back to the matcher.
Dialogue: 0,0:45:06.93,0:45:08.00,EN,,0,0,0,,PROFESSOR: Oh yes. OK, yes.
Dialogue: 0,0:45:08.26,0:45:09.74,EN,,0,0,0,,You're looking at this example.
Dialogue: 0,0:45:10.67,0:45:15.45,EN,,0,0,0,,At this point when I'm traversing this structure, I get to here: x.
Dialogue: 0,0:45:16.67,0:45:20.54,EN,,0,0,0,,I have some dictionary, presumably an empty dictionary at this point if this is the whole expression.
Dialogue: 0,0:45:21.56,0:45:25.36,EN,,0,0,0,,So I have an empty dictionary, and I've matched x against 3.
Dialogue: 0,0:45:26.62,0:45:33.60,EN,,0,0,0,,So now, after this point,the dictionary contains x is 3, OK?
Dialogue: 0,0:45:33.64,0:45:36.09,EN,,0,0,0,,Now, I continue walking along here. I see y.
Dialogue: 0,0:45:36.89,0:45:39.20,EN,,0,0,0,,Now, this is a particular x, a pattern x.
Dialogue: 0,0:45:39.79,0:45:41.37,EN,,0,0,0,,I see y, a pattern y.
Dialogue: 0,0:45:42.17,0:45:47.74,EN,,0,0,0,,The dictionary says, oh yes, the pattern y is the symbol x
Dialogue: 0,0:45:48.99,0:45:51.20,EN,,0,0,0,,because I've gota match there.
Dialogue: 0,0:45:52.43,0:45:54.52,EN,,0,0,0,,So the dictionary now contains at this point two entries.
Dialogue: 0,0:45:55.45,0:45:59.90,EN,,0,0,0,,The pattern x is 3, and the pattern y is the expression x.
Dialogue: 0,0:46:01.95,0:46:04.11,EN,,0,0,0,,Now, I get that, I can walk along further.
Dialogue: 0,0:46:04.23,0:46:07.45,EN,,0,0,0,,I say, oh, pattern y also wants to be 4.
Dialogue: 0,0:46:08.06,0:46:10.65,EN,,0,0,0,,But that isn't possible, producing a failure.
Dialogue: 0,0:46:14.30,0:46:15.48,EN,,0,0,0,,Thank you. Let's take a break.
Dialogue: 0,0:46:16.76,0:46:25.02,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:46:25.07,0:46:27.45,Declare,,0,0,0,,{\an2\fad(500,500)}The Structure And Interpretation of Computer Programs
Dialogue: 0,0:46:27.47,0:46:30.00,Declare,,0,0,0,,{\an2\fad(500,500)}By: Prof. Harold Abelson && Gerald Jay Sussman
Dialogue: 0,0:46:48.19,0:46:54.75,Declare,,0,0,0,,{\an2\fad(500,500)}The Structure And Interpretation of Computer Programs
Dialogue: 0,0:46:55.20,0:46:58.04,Declare,,0,0,0,,{\an2\fad(500,500)}Pattern-matching: Rule-based Substitution
Dialogue: 0,0:47:02.38,0:47:05.68,EN,,0,0,0,,OK, you're seeing your first very big and hairy program.
Dialogue: 0,0:47:07.34,0:47:09.90,EN,,0,0,0,,Now, of course, one of the goals of this subject
Dialogue: 0,0:47:09.90,0:47:12.97,EN,,0,0,0,,is to get you to be able to read something like this and not be afraid of it.
Dialogue: 0,0:47:13.76,0:47:16.33,EN,,0,0,0,,This one's only about four pages of code.
Dialogue: 0,0:47:17.08,0:47:19.23,EN,,0,0,0,,By the end of the subject, I hope a 50-page program
Dialogue: 0,0:47:20.27,0:47:21.80,EN,,0,0,0,,will not look particularly frightening.
Dialogue: 0,0:47:22.97,0:47:28.20,EN,,0,0,0,,But I don't expect-- and I don't want you to think that I expect you to be getting it as it's coming out.
Dialogue: 0,0:47:29.20,0:47:31.70,EN,,0,0,0,,You're supposed to feel the flavor of this, OK?
Dialogue: 0,0:47:31.70,0:47:34.83,EN,,0,0,0,,And then you're supposed to think about it because it is a big program.
Dialogue: 0,0:47:35.32,0:47:38.92,EN,,0,0,0,,There's a lot of stuff inside this program.
Dialogue: 0,0:47:41.24,0:47:46.03,EN,,0,0,0,,Now, I've told you about the language we're implementing, the pattern match substitution language.
Dialogue: 0,0:47:46.81,0:47:47.64,EN,,0,0,0,,I showed you some rules.
Dialogue: 0,0:47:48.36,0:47:51.24,EN,,0,0,0,,And I've told you about matching and instantiation,
Dialogue: 0,0:47:51.55,0:47:53.32,EN,,0,0,0,,which are the two halves of how a rule works.
Dialogue: 0,0:47:54.24,0:47:56.35,EN,,0,0,0,,Now we have to understand the control structure
Dialogue: 0,0:47:56.86,0:48:00.32,EN,,0,0,0,,by which the rules are applied to the expressions
Dialogue: 0,0:48:01.08,0:48:03.84,EN,,0,0,0,,so as to do algebraic simplification.
Dialogue: 0,0:48:06.92,0:48:09.58,EN,,0,0,0,,Now, that's also a big complicated mess.
Dialogue: 0,0:48:12.09,0:48:19.48,EN,,0,0,0,,The problem is that there is a variety of interlocking, interwoven loops, if you will, involved in this.
Dialogue: 0,0:48:20.24,0:48:26.99,EN,,0,0,0,,For one thing, I have to apply-- I have to examine every subexpression of my expression that I'm trying to simplify.
Dialogue: 0,0:48:29.00,0:48:29.93,EN,,0,0,0,,That we know how to do.
Dialogue: 0,0:48:29.93,0:48:36.24,EN,,0,0,0,,It's a car cdr recursion of some sort, or something like that, and some sort of tree walk.
Dialogue: 0,0:48:37.44,0:48:38.59,EN,,0,0,0,,And that's going to be happening.
Dialogue: 0,0:48:38.84,0:48:42.46,EN,,0,0,0,,Now, for every such place, every node that I get to
Dialogue: 0,0:48:43.47,0:48:48.76,EN,,0,0,0,,in doing my traversal of the expression I'm trying to simplify,
Dialogue: 0,0:48:49.20,0:48:51.07,EN,,0,0,0,,I want to apply all of the rules.
Dialogue: 0,0:48:53.42,0:48:55.08,EN,,0,0,0,,Every rule is going to look at every node.
Dialogue: 0,0:48:56.00,0:48:57.92,EN,,0,0,0,,I'm going to rotate the rules around.
Dialogue: 0,0:49:01.66,0:49:05.48,EN,,0,0,0,,Now, either a rule will or will not match.
Dialogue: 0,0:49:07.50,0:49:10.62,EN,,0,0,0,,If the rule does not match, then it's not very interesting.
Dialogue: 0,0:49:12.28,0:49:19.34,EN,,0,0,0,,If the rule does match, then I'm going to replace that node in the expression by an alternate expression.
Dialogue: 0,0:49:20.08,0:49:22.89,EN,,0,0,0,,I'm actually going to make a new expression, which contains--
Dialogue: 0,0:49:23.55,0:49:28.65,EN,,0,0,0,,everything contains that new value, the result of substituting into the skeleton,
Dialogue: 0,0:49:29.21,0:49:31.92,EN,,0,0,0,,instantiating the skeleton for that rule at this level.
Dialogue: 0,0:49:32.72,0:49:37.37,EN,,0,0,0,,But no one knows whether that thing that I instantiated there is in simplified form.
Dialogue: 0,0:49:38.75,0:49:43.82,EN,,0,0,0,,So we're going to have to simplify that, somehow to call the simplifier on the thing that I just constructed.
Dialogue: 0,0:49:46.12,0:49:50.36,EN,,0,0,0,,And then when that's done, then I sort of can build that into the expression I want as my answer.
Dialogue: 0,0:49:51.80,0:49:57.45,EN,,0,0,0,,Now, there is a basic idea here, which I will call a garbage- in, garbage-out simplifier.
Dialogue: 0,0:50:01.47,0:50:02.75,EN,,0,0,0,,It's a kind of recursive simplifier.
Dialogue: 0,0:50:03.58,0:50:08.84,EN,,0,0,0,,And what happens is the way simplify something is that simple objects like variables are simple.
Dialogue: 0,0:50:10.78,0:50:13.28,EN,,0,0,0,,Compound objects, well, I don't know.
Dialogue: 0,0:50:14.09,0:50:16.56,EN,,0,0,0,,What I'm going to do is I'm going to build up from simple objects,
Dialogue: 0,0:50:16.86,0:50:21.23,EN,,0,0,0,,trying to make simple things by assuming that the pieces they're made out of are simple.
Dialogue: 0,0:50:24.60,0:50:25.61,EN,,0,0,0,,That's what's happening here.
Dialogue: 0,0:50:27.82,0:50:33.12,EN,,0,0,0,,Well, now, if we look at the first slide-- no, overhead, overhead.
Dialogue: 0,0:50:33.88,0:50:37.13,EN,,0,0,0,,If we look at the overhead, we see a very complicated program like we saw before for the matcher,
Dialogue: 0,0:50:37.53,0:50:39.95,EN,,0,0,0,,so complicated that you can't read it like that.
Dialogue: 0,0:50:41.92,0:50:43.61,EN,,0,0,0,,I just want you to get the feel of the shape of it,
Dialogue: 0,0:50:44.44,0:50:50.01,EN,,0,0,0,,and the shape of it is that this program has various subprograms in it.
Dialogue: 0,0:50:52.11,0:50:57.56,EN,,0,0,0,,One of them--this part is the part for traversing the expression,
Dialogue: 0,0:50:58.97,0:51:01.36,EN,,0,0,0,,and this part is the part for trying rules.
Dialogue: 0,0:51:02.52,0:51:05.60,EN,,0,0,0,,Now, of course, we can look at that in some more detail.
Dialogue: 0,0:51:06.89,0:51:11.80,EN,,0,0,0,,Let's look at--let's look at the first transparency, right?
Dialogue: 0,0:51:13.40,0:51:17.36,EN,,0,0,0,,The simplifier is made out of several parts.
Dialogue: 0,0:51:17.96,0:51:22.92,EN,,0,0,0,,Now, remember at the very beginning, the simplifier is the thing which takes a rules-- a set of rules
Dialogue: 0,0:51:23.92,0:51:27.20,EN,,0,0,0,,and produces a program which will simplify it relative to them.
Dialogue: 0,0:51:30.04,0:51:32.60,EN,,0,0,0,,So here we have our simplifier.
Dialogue: 0,0:51:33.48,0:51:34.81,EN,,0,0,0,,It takes a rule set.
Dialogue: 0,0:51:36.16,0:51:38.68,EN,,0,0,0,,And in the context where that rule set is defined,
Dialogue: 0,0:51:39.24,0:51:41.48,EN,,0,0,0,,there are various other definitions that are done here.
Dialogue: 0,0:51:42.33,0:51:46.20,EN,,0,0,0,,And then the result of this simplifier procedure is,
Dialogue: 0,0:51:46.41,0:51:50.80,EN,,0,0,0,,in fact, one of the procedures that was defined. Simplify-exp.
Dialogue: 0,0:51:52.46,0:51:57.71,EN,,0,0,0,,What I'm returning as the value of calling the simplifier on a set of rules
Dialogue: 0,0:51:58.17,0:52:03.21,EN,,0,0,0,,is a procedure the simplify exp procedure, which is defined in that context,
Dialogue: 0,0:52:05.23,0:52:08.83,EN,,0,0,0,,which is a simplification procedure appropriate for using those set of rules.
Dialogue: 0,0:52:15.04,0:52:15.96,EN,,0,0,0,,That's what I have there.
Dialogue: 0,0:52:17.45,0:52:21.79,EN,,0,0,0,,Now, the first two of these procedures, this one and this one,
Dialogue: 0,0:52:22.48,0:52:25.74,EN,,0,0,0,,are together going to be the recursive traversal of an expression.
Dialogue: 0,0:52:26.97,0:52:30.20,EN,,0,0,0,,This one is the general simplification for any expression,
Dialogue: 0,0:52:30.94,0:52:33.23,EN,,0,0,0,,and this is the thing which simplifies a list of parts of an expression.
Dialogue: 0,0:52:35.53,0:52:36.08,EN,,0,0,0,,Nothing more.
Dialogue: 0,0:52:37.04,0:52:39.90,EN,,0,0,0,,For each of those, we're going to do something complicated, which involves trying the rules.
Dialogue: 0,0:52:40.32,0:52:41.71,EN,,0,0,0,,Now, we should look at the various parts.
Dialogue: 0,0:52:45.76,0:52:48.08,EN,,0,0,0,,Well let's look first at the recursive traversal of an expression.
Dialogue: 0,0:52:48.57,0:52:51.68,EN,,0,0,0,,And this is done in a sort of simple way.
Dialogue: 0,0:52:54.28,0:52:57.93,EN,,0,0,0,,This is a little nest of recursive procedures.
Dialogue: 0,0:52:59.42,0:53:01.77,EN,,0,0,0,,And what we have here are two procedures--
Dialogue: 0,0:53:02.59,0:53:05.20,EN,,0,0,0,,one for simplifying an expression,
Dialogue: 0,0:53:06.11,0:53:08.16,EN,,0,0,0,,and one for simplifying parts of an expression.
Dialogue: 0,0:53:09.44,0:53:10.97,EN,,0,0,0,,And the way this works is very simple.
Dialogue: 0,0:53:12.12,0:53:16.86,EN,,0,0,0,,If the expression I'm trying to simplify is a compound expression,
Dialogue: 0,0:53:17.04,0:53:18.32,EN,,0,0,0,,I'm going to simplify all the parts of it.
Dialogue: 0,0:53:19.95,0:53:22.32,EN,,0,0,0,,And that's calling--that procedure, simplify parts,
Dialogue: 0,0:53:22.33,0:53:25.74,EN,,0,0,0,,is going to make up a new expression with all the parts simplified,
Dialogue: 0,0:53:26.00,0:53:28.64,EN,,0,0,0,,which I'm then going to try the rules on over here.
Dialogue: 0,0:53:30.86,0:53:34.22,EN,,0,0,0,,If it turns out that the expression is not compound, if it's simple,
Dialogue: 0,0:53:34.76,0:53:37.13,EN,,0,0,0,,like just a symbol or something like pi,
Dialogue: 0,0:53:38.16,0:53:39.79,EN,,0,0,0,,then in any case, I'm going to try the rules on it
Dialogue: 0,0:53:40.03,0:53:47.56,EN,,0,0,0,,because it might be that I want in my set of rules to expand pi to 3.14159265358979,dot, dot, dot.
Dialogue: 0,0:53:48.46,0:53:49.08,EN,,0,0,0,,But I may not.
Dialogue: 0,0:53:50.11,0:53:51.52,EN,,0,0,0,,But there is no reason not to do it.
Dialogue: 0,0:53:52.75,0:53:57.53,EN,,0,0,0,,Now, if I want to simplify the parts, well, that's easy too.
Dialogue: 0,0:53:58.99,0:54:02.88,EN,,0,0,0,,Either the expression is an empty one, there's no more parts,
Dialogue: 0,0:54:03.71,0:54:05.08,EN,,0,0,0,,in which case I have the empty expression.
Dialogue: 0,0:54:05.72,0:54:10.52,EN,,0,0,0,,Otherwise, I'm going to make a new expression by cons,
Dialogue: 0,0:54:11.21,0:54:14.27,EN,,0,0,0,,which is the result of simplifying the first part of the expression, the car,
Dialogue: 0,0:54:15.42,0:54:17.39,EN,,0,0,0,,and simplifying the rest of the expression, which is the cdr.
Dialogue: 0,0:54:21.08,0:54:23.88,EN,,0,0,0,,Now, the reason why I'm showing you this sort of stuff this way
Dialogue: 0,0:54:24.88,0:54:30.12,EN,,0,0,0,,is because I want you get the feeling for the various patterns that are very important when writing programs.
Dialogue: 0,0:54:32.20,0:54:34.00,EN,,0,0,0,,And this could be written a different way.
Dialogue: 0,0:54:34.00,0:54:36.99,EN,,0,0,0,,There's another way to write simplified expressions so there would be only one of them.
Dialogue: 0,0:54:37.72,0:54:39.63,EN,,0,0,0,,There would only be one little procedure here.
Dialogue: 0,0:54:39.63,0:54:42.36,EN,,0,0,0,,Let me just write that on the blackboard to give you a feeling for that.
Dialogue: 0,0:54:49.71,0:54:51.90,EN,,0,0,0,,This is in another idiom, if you will.
Dialogue: 0,0:54:59.30,0:55:03.13,EN,,0,0,0,,To simplify an expression called exp, what am I going to do?
Dialogue: 0,0:55:03.21,0:55:10.14,EN,,0,0,0,,I'm going to try the rules on the following situation.
Dialogue: 0,0:55:11.12,0:55:15.72,EN,,0,0,0,,If-- on the following expression-- compound, just like we had before.
Dialogue: 0,0:55:21.52,0:55:24.27,EN,,0,0,0,,If the expression is compound, well, what am I going to do?
Dialogue: 0,0:55:24.53,0:55:25.40,EN,,0,0,0,,I'm going to simplify all the parts.
Dialogue: 0,0:55:26.01,0:55:27.80,EN,,0,0,0,,But I already have a cdr recursion,
Dialogue: 0,0:55:30.25,0:55:33.18,EN,,0,0,0,,common pattern of usage, which has been captured as a high-order procedure.
Dialogue: 0,0:55:34.09,0:55:34.46,EN,,0,0,0,,It's called map.
Dialogue: 0,0:55:36.08,0:55:36.88,EN,,0,0,0,,So I'll just write that here.
Dialogue: 0,0:55:37.16,0:55:48.03,EN,,0,0,0,,Map simplify the expression, all the parts of the expression.
Dialogue: 0,0:55:49.00,0:55:54.59,EN,,0,0,0,,This says apply the simplification operation, which is this one, every part of the expression,
Dialogue: 0,0:55:55.34,0:55:57.34,EN,,0,0,0,,and then that cons those up into a list.
Dialogue: 0,0:56:00.92,0:56:04.38,EN,,0,0,0,,It's every element of the list which the expression is assumed to be made out of,
Dialogue: 0,0:56:05.45,0:56:08.23,EN,,0,0,0,,and otherwise, I have the expression.
Dialogue: 0,0:56:09.05,0:56:12.36,EN,,0,0,0,,So I don't need the helper procedure, simplify parts,
Dialogue: 0,0:56:12.64,0:56:13.48,EN,,0,0,0,,because that's really this.
Dialogue: 0,0:56:15.47,0:56:17.05,EN,,0,0,0,,So sometimes, you just write it this way.
Dialogue: 0,0:56:17.84,0:56:18.70,EN,,0,0,0,,It doesn't matter very much.
Dialogue: 0,0:56:21.16,0:56:26.27,EN,,0,0,0,,Well, now let's take a look at-- let's just look at how you try rules.
Dialogue: 0,0:56:27.70,0:56:31.60,EN,,0,0,0,,If you look at this slide, we see this is a complicated mess also.
Dialogue: 0,0:56:33.68,0:56:35.28,EN,,0,0,0,,I'm trying rules on an expression.
Dialogue: 0,0:56:36.36,0:56:39.96,EN,,0,0,0,,It turns out the expression I'm trying it on is some subexpression now of the expression I started with.
Dialogue: 0,0:56:40.43,0:56:43.88,EN,,0,0,0,,Because the thing I just arranged allowed us to try every subexpression.
Dialogue: 0,0:56:46.11,0:56:51.90,EN,,0,0,0,,So now here we're taking in a subexpression of the expression we started with. That's what this is.
Dialogue: 0,0:56:52.49,0:56:57.71,EN,,0,0,0,,And what we're going to define here is a procedure called scan, which is going to try every rule.
Dialogue: 0,0:56:58.72,0:57:00.33,EN,,0,0,0,,And we're going to start it up on the whole set of rules.
Dialogue: 0,0:57:01.92,0:57:07.77,EN,,0,0,0,,This is going to go cdr-ing down the rules, if you will, looking for a rule to apply.
Dialogue: 0,0:57:09.37,0:57:11.96,EN,,0,0,0,,And when it finds one, it'll do the job.
Dialogue: 0,0:57:14.09,0:57:16.41,EN,,0,0,0,,Well, let's take a look at how try rules works.
Dialogue: 0,0:57:17.74,0:57:21.02,EN,,0,0,0,,It's very simple: the scan rules. Scan rules, the way of scanning.
Dialogue: 0,0:57:21.96,0:57:23.26,EN,,0,0,0,,Well, is it so simple?
Dialogue: 0,0:57:23.26,0:57:24.51,EN,,0,0,0,,It's a big program, of course.
Dialogue: 0,0:57:25.55,0:57:28.57,EN,,0,0,0,,We take a bunch of rules, which is a sublist of the list of rules.
Dialogue: 0,0:57:30.75,0:57:35.13,EN,,0,0,0,,We've tried some of them already, and they've not been appropriate, so we get to some here.
Dialogue: 0,0:57:35.87,0:57:36.30,EN,,0,0,0,,next one.
Dialogue: 0,0:57:36.40,0:57:37.63,EN,,0,0,0,,If there are no more rules,
Dialogue: 0,0:57:37.90,0:57:40.84,EN,,0,0,0,,well then, there's nothing I can do with this expression, and it's simplified.
Dialogue: 0,0:57:42.35,0:57:47.26,EN,,0,0,0,,However, if it turns out that there are still rules to be done,
Dialogue: 0,0:57:48.01,0:57:51.58,EN,,0,0,0,,then let's match the pattern of the first rule
Dialogue: 0,0:57:52.20,0:57:55.40,EN,,0,0,0,,against the expression using the empty dictionary to start with
Dialogue: 0,0:57:57.07,0:57:58.84,EN,,0,0,0,,and use that as the dictionary.
Dialogue: 0,0:58:00.32,0:58:03.74,EN,,0,0,0,,If that happens to be a failure, try the rest of the rules.
Dialogue: 0,0:58:06.68,0:58:07.52,EN,,0,0,0,,That's all it says here.
Dialogue: 0,0:58:08.52,0:58:10.33,EN,,0,0,0,,How it says, it says discard that rule.
Dialogue: 0,0:58:11.10,0:58:15.05,EN,,0,0,0,,Otherwise, well, I'm going to get the skeleton of the first rule,
Dialogue: 0,0:58:15.34,0:58:17.40,EN,,0,0,0,,instantiate that relative to the dictionary,
Dialogue: 0,0:58:17.93,0:58:20.80,EN,,0,0,0,,and simplify the result, and that's the expression I want.
Dialogue: 0,0:58:24.20,0:58:25.96,EN,,0,0,0,,So although that was a complicated program,
Dialogue: 0,0:58:26.25,0:58:28.72,EN,,0,0,0,,every complicated program is made out of a lot of simple pieces.
Dialogue: 0,0:58:29.77,0:58:33.12,EN,,0,0,0,,Now, the pattern of recursions here is very complicated.
Dialogue: 0,0:58:34.78,0:58:36.52,EN,,0,0,0,,And one of the most important things is not to think about that.
Dialogue: 0,0:58:38.67,0:58:41.80,EN,,0,0,0,,If you try to think about the actual pattern by which this does something,
Dialogue: 0,0:58:42.06,0:58:42.97,EN,,0,0,0,,you're going to get very confused.
Dialogue: 0,0:58:45.31,0:58:45.71,EN,,0,0,0,,I would.
Dialogue: 0,0:58:47.04,0:58:50.17,EN,,0,0,0,,This is not a matter. you can do this with practice.
Dialogue: 0,0:58:51.52,0:58:52.46,EN,,0,0,0,,These patterns are hard.
Dialogue: 0,0:58:54.17,0:58:55.42,EN,,0,0,0,,But you don't have to think about it.
Dialogue: 0,0:58:55.83,0:58:59.72,EN,,0,0,0,,The key to this-- it's very good programming and very good design--
Dialogue: 0,0:58:59.74,0:59:00.97,EN,,0,0,0,,is to know what not to think about.
Dialogue: 0,0:59:03.05,0:59:06.06,EN,,0,0,0,,The fact is, going back to this slide,
Dialogue: 0,0:59:06.92,0:59:08.01,EN,,0,0,0,,I don't have to think about it
Dialogue: 0,0:59:08.54,0:59:13.83,EN,,0,0,0,,because I have specifications in my mind for what simplify x does.
Dialogue: 0,0:59:14.00,0:59:15.24,EN,,0,0,0,,I don't have to know how it does it.
Dialogue: 0,0:59:17.08,0:59:21.24,EN,,0,0,0,,And it may, in fact, call scan somehow through try rules, which it does.
Dialogue: 0,0:59:22.24,0:59:24.09,EN,,0,0,0,,And somehow, I've got another recursion going on here.
Dialogue: 0,0:59:24.33,0:59:25.69,EN,,0,0,0,,But since I know that simplify exp
Dialogue: 0,0:59:26.84,0:59:30.40,EN,,0,0,0,,is assumed by wishful thinking to produce the simplified result,
Dialogue: 0,0:59:31.61,0:59:32.99,EN,,0,0,0,,then I don't have to think about it anymore.
Dialogue: 0,0:59:33.43,0:59:34.83,EN,,0,0,0,,I've used it.
Dialogue: 0,0:59:35.07,0:59:36.43,EN,,0,0,0,,I've used it in a reasonable way.
Dialogue: 0,0:59:36.43,0:59:37.45,EN,,0,0,0,,I will get a reasonable answer.
Dialogue: 0,0:59:39.95,0:59:42.57,EN,,0,0,0,,And you have to learn how to program that way-- with abandon.
Dialogue: 0,0:59:47.56,0:59:49.05,EN,,0,0,0,,Well, there's very little left of this thing.
Dialogue: 0,0:59:50.40,0:59:54.46,EN,,0,0,0,,All there is left is a few details associated with what a dictionary is.
Dialogue: 0,0:59:55.08,0:59:58.32,EN,,0,0,0,,And those of you who've been itching to know what a dictionary is,
Dialogue: 0,0:59:58.70,1:00:01.82,EN,,0,0,0,,well, I will flip it up and not tell you anything about it.
Dialogue: 0,1:00:04.14,1:00:05.20,EN,,0,0,0,,Dictionaries are easy.
Dialogue: 0,1:00:06.01,1:00:09.84,EN,,0,0,0,,It's represented in terms of something else called an A list,
Dialogue: 0,1:00:10.65,1:00:16.04,EN,,0,0,0,,which is a particular pattern of usage for making tables in lists.
Dialogue: 0,1:00:16.50,1:00:20.17,EN,,0,0,0,,They're easy. They're made out of pairs, as was asked a bit ago.
Dialogue: 0,1:00:21.21,1:00:24.62,EN,,0,0,0,,And there are special procedures for dealing with such things called assq,
Dialogue: 0,1:00:24.94,1:00:26.36,EN,,0,0,0,,and you can find them in manuals.
Dialogue: 0,1:00:27.04,1:00:28.59,EN,,0,0,0,,I'm not terribly excited about it.
Dialogue: 0,1:00:28.83,1:00:31.21,EN,,0,0,0,,The only interesting thing here in extend dictionary
Dialogue: 0,1:00:31.48,1:00:36.94,EN,,0,0,0,,is I have to extend the dictionary with a pattern, a datum, and a dictionary.
Dialogue: 0,1:00:37.42,1:00:42.38,EN,,0,0,0,,I wish that, this pattern is, in fact, at this point a pattern variable.
Dialogue: 0,1:00:43.74,1:00:47.53,EN,,0,0,0,,And what do I want to do? I want to pull out the name of that pattern variable
Dialogue: 0,1:00:48.16,1:00:49.42,EN,,0,0,0,,the pattern variable name,
Dialogue: 0,1:00:50.44,1:00:53.71,EN,,0,0,0,,and I'm going to look up in the dictionary and see if it already has a value.
Dialogue: 0,1:00:53.79,1:00:56.41,EN,,0,0,0,,If not, I'm going to add a new one in.
Dialogue: 0,1:00:56.92,1:00:59.23,EN,,0,0,0,,If it does have one, if it has a value,
Dialogue: 0,1:00:59.60,1:01:03.18,EN,,0,0,0,,then it had better be equal to the one that was already stored away.
Dialogue: 0,1:01:03.88,1:01:06.54,EN,,0,0,0,,And if that's the case, the dictionary is what I expected it to be.
Dialogue: 0,1:01:06.89,1:01:09.15,EN,,0,0,0,,Otherwise, I fail.
Dialogue: 0,1:01:12.08,1:01:12.89,EN,,0,0,0,,So that's easy, too.
Dialogue: 0,1:01:13.66,1:01:16.68,EN,,0,0,0,,If you open up any program, you're going to find inside of it lots of little pieces,
Dialogue: 0,1:01:17.18,1:01:18.30,EN,,0,0,0,,all of which are easy.
Dialogue: 0,1:01:20.04,1:01:21.29,EN,,0,0,0,,So at this point, I suppose,
Dialogue: 0,1:01:21.60,1:01:25.68,EN,,0,0,0,,I've just told you some million-dollar valuable information.
Dialogue: 0,1:01:28.41,1:01:30.96,EN,,0,0,0,,And I suppose at this point we're pretty much done with this program.
Dialogue: 0,1:01:31.85,1:01:32.72,EN,,0,0,0,,I'd like to ask about questions.
Dialogue: 0,1:01:34.27,1:01:38.16,EN,,0,0,0,,AUDIENCE: Yes, can you give me the words that describe the specification for a simplified expression?
Dialogue: 0,1:01:38.72,1:01:39.02,EN,,0,0,0,,PROFESSOR: Sure.
Dialogue: 0,1:01:39.85,1:01:44.33,EN,,0,0,0,,A simplified expression takes an expression and produces a simplified expression.
Dialogue: 0,1:01:45.28,1:01:45.77,EN,,0,0,0,,That's it, OK?
Dialogue: 0,1:01:48.11,1:01:50.27,EN,,0,0,0,,How it does it is very easy.
Dialogue: 0,1:01:51.60,1:01:56.09,EN,,0,0,0,,In compound expressions, all the pieces are simplified, and then the rules are tried on the result.
Dialogue: 0,1:01:56.89,1:01:58.49,EN,,0,0,0,,And for simple expressions, you just try all the rules.
Dialogue: 0,1:01:59.52,1:02:02.11,EN,,0,0,0,,AUDIENCE: So an expression is simplified by virtue of the rules?
Dialogue: 0,1:02:02.76,1:02:03.58,EN,,0,0,0,,PROFESSOR: That's, of course, true.
Dialogue: 0,1:02:03.76,1:02:03.90,EN,,0,0,0,,AUDIENCE: Right.
Dialogue: 0,1:02:04.06,1:02:07.13,EN,,0,0,0,,PROFESSOR: And the way this works is that simplified expression, as you see here,
Dialogue: 0,1:02:08.35,1:02:11.64,EN,,0,0,0,,what it does is it breaks the expression down into the smallest pieces,
Dialogue: 0,1:02:12.60,1:02:17.29,EN,,0,0,0,,simplifies building up from the bottom using the rules to be the simplifier,
Dialogue: 0,1:02:18.30,1:02:22.48,EN,,0,0,0,,to do the manipulations, and constructs a new expression as the result.
Dialogue: 0,1:02:24.28,1:02:29.44,EN,,0,0,0,,Eventually, one of things you see is that the rules themselves, the try rules,
Dialogue: 0,1:02:29.70,1:02:35.50,EN,,0,0,0,,call a simplified expression on the results when it changes something, the results of a match.
Dialogue: 0,1:02:35.80,1:02:40.64,EN,,0,0,0,,I'm sorry, the results of instantiation of a skeleton for a rule that has matched.
Dialogue: 0,1:02:42.00,1:02:47.36,EN,,0,0,0,,So the spec of a simplified expression is that any expression you put into it comes out simplified according to those rules.
Dialogue: 0,1:02:49.84,1:02:50.76,EN,,0,0,0,,Thank you. Let's take a break.

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:06.19,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:06.45,0:00:14.22,title,,0,0,0,,{\fad(600,800)\pos(324,32)}计算机程序的构造和解释
Dialogue: 0,0:00:06.45,0:00:14.22,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}字幕&时间轴\N邓雄飞 & S.Michael
Dialogue: 0,0:00:06.45,0:00:14.22,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}后期&特效\N邓雄飞\N(Dysprosium)
Dialogue: 0,0:00:06.45,0:00:14.22,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:06.45,0:00:14.22,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:14.83,0:00:18.00,Declare,,0,0,0,,{\an2\fad(500,500)}模式匹配：基于规则的代换\N Pattern Matching: Rule-based Substitution
Dialogue: 0,0:00:24.34,0:00:29.34,Default,,0,0,0,,教授：昨天 我们学习了一些符号操作
Dialogue: 0,0:00:29.92,0:00:35.12,Default,,0,0,0,,编写了一个非常典型的程序
Dialogue: 0,0:00:35.15,0:00:38.97,Default,,0,0,0,,来实现教材中的微积分规则
Dialogue: 0,0:00:39.61,0:00:44.59,Default,,0,0,0,,在这张幻灯片上
Dialogue: 0,0:00:44.96,0:00:48.81,Default,,0,0,0,,有一些从书中摘录的微积分规则
Dialogue: 0,0:00:49.47,0:00:54.62,Default,,0,0,0,,我们要把这些规则转化成计算机语言
Dialogue: 0,0:00:55.14,0:00:58.85,Default,,0,0,0,,当然 这种策略很有趣
Dialogue: 0,0:00:59.36,0:01:04.80,Default,,0,0,0,,但是我们为什么要把它们翻译成计算机语言呢？
Dialogue: 0,0:01:05.00,0:01:06.27,Default,,0,0,0,,我的意思是---
Dialogue: 0,0:01:06.62,0:01:11.02,Default,,0,0,0,,我们昨天写的程序非常典型
Dialogue: 0,0:01:11.21,0:01:15.98,Default,,0,0,0,,它是一个按表达式类型做分派的分情况分析语句
Dialogue: 0,0:01:16.38,0:01:18.48,Default,,0,0,0,,规则就是这样的
Dialogue: 0,0:01:19.68,0:01:21.55,Default,,0,0,0,,这里的规则是说:
Dialogue: 0,0:01:21.74,0:01:25.48,Default,,0,0,0,,我们考察的表达式如果是---
Dialogue: 0,0:01:25.48,0:01:29.42,Default,,0,0,0,,如果是常量 就做一些事情
Dialogue: 0,0:01:29.42,0:01:31.37,Default,,0,0,0,,如果是变量 就做另一件事情
Dialogue: 0,0:01:31.60,0:01:35.56,Default,,0,0,0,,如果它是常量乘以变量 就做另外的事 等等
Dialogue: 0,0:01:36.00,0:01:38.96,Default,,0,0,0,,这是一种按类型的分派
Dialogue: 0,0:01:41.40,0:01:45.16,Default,,0,0,0,,那么 既然它有如此典型的行为和结构
Dialogue: 0,0:01:45.95,0:01:49.53,Default,,0,0,0,,有没有其它方式把这个过程写得更加清晰？
Dialogue: 0,0:01:50.83,0:01:53.45,Default,,0,0,0,,首先要解决的是 这些规则是什么?
Dialogue: 0,0:01:55.56,0:01:58.50,Default,,0,0,0,,我们来好好想一下 规则有好几个部分
Dialogue: 0,0:01:58.94,0:02:02.35,Default,,0,0,0,,如果仔细观察这些规则
Dialogue: 0,0:02:03.71,0:02:04.99,Default,,0,0,0,,你就会发现
Dialogue: 0,0:02:05.12,0:02:09.69,Default,,0,0,0,,这些规则都有左右两部分
Dialogue: 0,0:02:10.36,0:02:14.36,Default,,0,0,0,,每一个规则都有左边部分和右边部分
Dialogue: 0,0:02:15.15,0:02:20.30,Default,,0,0,0,,左边部分用来与对被求导表达式做比较
Dialogue: 0,0:02:21.52,0:02:25.10,Default,,0,0,0,,右边部分用于替换原表达式
Dialogue: 0,0:02:28.49,0:02:33.10,Default,,0,0,0,,这张纸上的所有规则都可以描述成这样——
Dialogue: 0,0:02:36.51,0:02:38.06,Default,,0,0,0,,我们有许多模式
Dialogue: 0,0:02:41.48,0:02:48.30,Default,,0,0,0,,有时候 给定一个模式 我们需要为其生成一个骨架
Dialogue: 0,0:02:51.88,0:02:52.81,Default,,0,0,0,,这就是一个规则
Dialogue: 0,0:02:55.42,0:02:57.13,Default,,0,0,0,,模式是用于匹配的部分
Dialogue: 0,0:02:57.88,0:03:03.26,Default,,0,0,0,,将成功匹配的值代换到骨架里 就得到一个新的表达式
Dialogue: 0,0:03:06.46,0:03:16.32,Default,,0,0,0,,我的意思是：模式是用来匹配原表达式的
Dialogue: 0,0:03:23.72,0:03:28.51,Default,,0,0,0,,应用规则会产生一个新的表达式
Dialogue: 0,0:03:33.61,0:03:34.91,Default,,0,0,0,,我们称之为目标
Dialogue: 0,0:03:38.12,0:03:39.88,Default,,0,0,0,,这是通过骨架的实例化实现的
Dialogue: 0,0:03:41.63,0:03:43.02,Default,,0,0,0,,这个叫做实例化
Dialogue: 0,0:03:50.72,0:03:54.73,Default,,0,0,0,,这就是这些规则所描述的过程
Dialogue: 0,0:03:55.69,0:03:57.26,Default,,0,0,0,,今天我想要做的是
Dialogue: 0,0:03:58.73,0:04:01.08,Default,,0,0,0,,构建一种语言
Dialogue: 0,0:04:02.20,0:04:05.48,Default,,0,0,0,,以及它的解释与执行方法
Dialogue: 0,0:04:05.74,0:04:08.43,Default,,0,0,0,,使得这种语言可以直接表述这些规则
Dialogue: 0,0:04:10.59,0:04:11.58,Default,,0,0,0,,我们将要做的是
Dialogue: 0,0:04:11.58,0:04:17.56,Default,,0,0,0,,与其通过将规则翻译为程序 让计算机理解并执行
Dialogue: 0,0:04:18.38,0:04:21.56,Default,,0,0,0,,这里主要指 Lisp 程序
Dialogue: 0,0:04:22.16,0:04:24.49,Default,,0,0,0,,我们不如让计算机理解我们
Dialogue: 0,0:04:25.48,0:04:29.15,Default,,0,0,0,,我们可以写一些程序让计算机理解这些规则
Dialogue: 0,0:04:30.91,0:04:34.76,Default,,0,0,0,,这又稍微强调了上次的主旨
Dialogue: 0,0:04:35.44,0:04:39.36,Default,,0,0,0,,与其解决一个特定问题 不如解决一类问题
Dialogue: 0,0:04:39.77,0:04:46.72,Default,,0,0,0,,如果我为不同的数学运算写规则
Dialogue: 0,0:04:48.24,0:04:51.39,Default,,0,0,0,,比如简单代数的化简
Dialogue: 0,0:04:51.98,0:04:55.48,Default,,0,0,0,,或者三角函数运算
Dialogue: 0,0:04:56.09,0:05:01.16,Default,,0,0,0,,如果按照昨天的方法 我就得重新写个不同的程序
Dialogue: 0,0:05:01.16,0:05:05.42,Default,,0,0,0,,与之相反 我把程序中的共有逻辑给封装起来
Dialogue: 0,0:05:06.12,0:05:10.17,Default,,0,0,0,,也就是匹配、实例化等概念 还有控制结构
Dialogue: 0,0:05:10.17,0:05:12.46,Default,,0,0,0,,这都是非常复杂的事情
Dialogue: 0,0:05:13.16,0:05:18.46,Default,,0,0,0,,我想把它们从规则中分开 并封装
Dialogue: 0,0:05:20.06,0:05:22.60,Default,,0,0,0,,首先让我们看一下表示法
Dialogue: 0,0:05:22.62,0:05:24.09,Default,,0,0,0,,请大家看投影仪上的幻灯片
Dialogue: 0,0:05:24.67,0:05:25.60,Default,,0,0,0,,已经在这里了
Dialogue: 0,0:05:26.25,0:05:32.27,Default,,0,0,0,,我想要把求导的计算规则
Dialogue: 0,0:05:33.71,0:05:37.15,Default,,0,0,0,,表示为我这里写的一种简单语言
Dialogue: 0,0:05:38.11,0:05:43.29,Default,,0,0,0,,我会尽量避免去考虑语法
Dialogue: 0,0:05:44.28,0:05:49.28,Default,,0,0,0,,美化它很容易 虽然这个确实挺丑 但我并不关心
Dialogue: 0,0:05:49.30,0:05:56.41,Default,,0,0,0,,这确实不能像dx/dt那样表示
Dialogue: 0,0:05:56.76,0:05:58.12,Default,,0,0,0,,但这并不重要
Dialogue: 0,0:05:58.88,0:06:00.62,Default,,0,0,0,,这是一个偶然现象
Dialogue: 0,0:06:01.00,0:06:04.44,Default,,0,0,0,,这里 我只关心规则的结构
Dialogue: 0,0:06:04.83,0:06:11.70,Default,,0,0,0,,规则的左边部分代表了我想要匹配的求导表达式
Dialogue: 0,0:06:11.80,0:06:13.56,Default,,0,0,0,,这个表示是说
Dialogue: 0,0:06:13.60,0:06:18.32,Default,,0,0,0,,一个匹配常量的模式变量c
Dialogue: 0,0:06:18.84,0:06:21.20,Default,,0,0,0,,关于匹配任意表达式的模式变量v求导
Dialogue: 0,0:06:23.08,0:06:25.55,Default,,0,0,0,,我们在右边部分得到的是0
Dialogue: 0,0:06:26.00,0:06:28.06,Default,,0,0,0,,这就代表了一个规则
Dialogue: 0,0:06:29.26,0:06:34.04,Default,,0,0,0,,下一条规则是 匹配变量的模式变量v
Dialogue: 0,0:06:34.22,0:06:37.74,Default,,0,0,0,,对同一个模式变量求导 得到的结果是1
Dialogue: 0,0:06:38.60,0:06:42.17,Default,,0,0,0,,然而 如果一个匹配变量的模式变量u
Dialogue: 0,0:06:42.41,0:06:44.84,Default,,0,0,0,,关于另一个模式变量v求导
Dialogue: 0,0:06:45.39,0:06:47.05,Default,,0,0,0,,那么 结果就是0
Dialogue: 0,0:06:47.84,0:06:52.17,Default,,0,0,0,,我想让大家看一下 这些规则是如何组织在一起的
Dialogue: 0,0:06:52.51,0:06:54.30,Default,,0,0,0,,比如说 在这里
Dialogue: 0,0:06:54.73,0:07:01.90,Default,,0,0,0,,我们要求表达式x1、x2之和的导数
Dialogue: 0,0:07:01.90,0:07:05.85,Default,,0,0,0,,在我们创造的这个语言中
Dialogue: 0,0:07:06.88,0:07:08.62,Default,,0,0,0,,以问号开头的叫模式变量
Dialogue: 0,0:07:08.93,0:07:14.93,Default,,0,0,0,,我们就像这样来构建这些用来匹配的模式变量
Dialogue: 0,0:07:14.93,0:07:20.33,Default,,0,0,0,,这里 表达式x1加上表达式x2
Dialogue: 0,0:07:20.33,0:07:26.70,Default,,0,0,0,,对变量v求导的结果等于右边这里的式子
Dialogue: 0,0:07:26.70,0:07:32.76,Default,,0,0,0,,右边的式子是一个骨架 表示表达式X1关于变量v求导
Dialogue: 0,0:07:33.82,0:07:37.10,Default,,0,0,0,,加上表达式X2对变量v求导的和
Dialogue: 0,0:07:37.60,0:07:42.38,Default,,0,0,0,,这里的冒号表示要代换的对象
Dialogue: 0,0:07:43.63,0:07:47.23,Default,,0,0,0,,我们将它们称作“骨架求值”
Dialogue: 0,0:07:48.51,0:07:53.07,Default,,0,0,0,,让我在黑板上写一些语法
Dialogue: 0,0:07:53.23,0:07:55.56,Default,,0,0,0,,这样就能知道 在我们这门规则语言中会发生什么
Dialogue: 0,0:07:56.68,0:07:59.88,Default,,0,0,0,,首先我们要处理模式匹配问题
Dialogue: 0,0:08:06.04,0:08:13.12,Default,,0,0,0,,第一条规则是 形如foo这样的符号与其自身匹配
Dialogue: 0,0:08:23.52,0:08:31.34,Default,,0,0,0,,形如(f a b)的表达式 可以匹配这样的表
Dialogue: 0,0:08:36.30,0:08:57.02,Default,,0,0,0,,表的首元素是f、第二个元素是a、第三个元素是b
Dialogue: 0,0:08:58.62,0:09:06.99,Default,,0,0,0,,另外 模式中可能还有形如(? x)这样的规则
Dialogue: 0,0:09:08.57,0:09:18.67,Default,,0,0,0,,这个规则可以匹配任意表达式 并将其称为x
Dialogue: 0,0:09:25.45,0:09:29.98,Default,,0,0,0,,(?c x) 只匹配常量
Dialogue: 0,0:09:31.50,0:09:40.96,Default,,0,0,0,,并将匹配的常量记作x
Dialogue: 0,0:09:44.56,0:09:57.07,Default,,0,0,0,,(?v x)匹配变量 并将匹配的变量记作x
Dialogue: 0,0:10:01.66,0:10:03.80,Default,,0,0,0,,这就是我们正在构建的语言
Dialogue: 0,0:10:04.19,0:10:09.40,Default,,0,0,0,,两个对象的比较是基于元素与元素间的比较
Dialogue: 0,0:10:10.25,0:10:15.85,Default,,0,0,0,,模式中的元素可以包含这些语法变量、模式变量
Dialogue: 0,0:10:17.07,0:10:20.43,Default,,0,0,0,,它们可以用来匹配任意对象
Dialogue: 0,0:10:22.12,0:10:29.28,Default,,0,0,0,,这样 我就可以用x作为名字取得被匹配对象的值
Dialogue: 0,0:10:31.05,0:10:37.55,Default,,0,0,0,,现在 当我们为实例化准备骨架的时候
Dialogue: 0,0:10:39.50,0:10:41.40,Default,,0,0,0,,我们可能有这样的东西
Dialogue: 0,0:10:42.27,0:10:46.33,Default,,0,0,0,,符号foo实例化为它本身
Dialogue: 0,0:10:55.08,0:11:05.92,Default,,0,0,0,,形如(f a b)这样的表 实例化为
Dialogue: 0,0:11:06.36,0:11:14.75,Default,,0,0,0,,实例化为一个三元素表
Dialogue: 0,0:11:15.55,0:11:33.37,Default,,0,0,0,,其元素分别为f、a、b各自实例化后的结果
Dialogue: 0,0:11:36.35,0:11:54.27,Default,,0,0,0,,(: x) 会被实例化为x的值--也就是被匹配的模式
Dialogue: 0,0:12:03.05,0:12:10.08,Default,,0,0,0,,回头看看这里的幻灯片 我们发现这些都是对象
Dialogue: 0,0:12:10.78,0:12:16.06,Default,,0,0,0,,我们看到 这是一个用来匹配常量的模式变量
Dialogue: 0,0:12:16.56,0:12:19.02,Default,,0,0,0,,这是匹配变量的模式变量
Dialogue: 0,0:12:19.39,0:12:21.74,Default,,0,0,0,,这是匹配任意表达式的模式变量
Dialogue: 0,0:12:22.72,0:12:24.92,Default,,0,0,0,,如果我们有了名字一样的两个实例
Dialogue: 0,0:12:25.08,0:12:31.77,Default,,0,0,0,,想这个是被称作v的单变量表达式
Dialogue: 0,0:12:32.86,0:12:36.30,Default,,0,0,0,,关于一个称作v的任意表达式求导
Dialogue: 0,0:12:36.41,0:12:38.01,Default,,0,0,0,,因为这个v出现了两次
Dialogue: 0,0:12:38.65,0:12:41.07,Default,,0,0,0,,我们想约束它们相同
Dialogue: 0,0:12:42.68,0:12:45.00,Default,,0,0,0,,只有它俩完全一致才算是匹配
Dialogue: 0,0:12:45.23,0:12:47.23,Default,,0,0,0,,所以在这里我们在构建一个语言
Dialogue: 0,0:12:47.60,0:12:50.66,Default,,0,0,0,,事实上 这是一件非常好的事情
Dialogue: 0,0:12:50.66,0:12:52.60,Default,,0,0,0,,构建一个语言非常有趣
Dialogue: 0,0:12:52.60,0:12:54.33,Default,,0,0,0,,并且大家一直在做这些
Dialogue: 0,0:12:54.33,0:12:56.89,Default,,0,0,0,,大家做过的真正强大的设计
Dialogue: 0,0:12:57.23,0:13:00.20,Default,,0,0,0,,是构建一个语言来解决这样的问题
Dialogue: 0,0:13:02.06,0:13:05.34,Default,,0,0,0,,我们回头看看这些规则
Dialogue: 0,0:13:05.80,0:13:07.10,Default,,0,0,0,,这就是它们的全部
Dialogue: 0,0:13:07.10,0:13:12.43,Default,,0,0,0,,我们有加法、乘法 就像我们之前看到的一样
Dialogue: 0,0:13:12.43,0:13:17.37,Default,,0,0,0,,x1+x2 关于变量v的导数等于
Dialogue: 0,0:13:17.68,0:13:26.52,Default,,0,0,0,,x2对v求导乘以x1 加上 x1对v求导乘以x2
Dialogue: 0,0:13:27.26,0:13:29.10,Default,,0,0,0,,这是指数运算的求导规则
Dialogue: 0,0:13:29.24,0:13:32.11,Default,,0,0,0,,虽然这里展示完了所有的规则 但还可以按照我们意愿添加
Dialogue: 0,0:13:32.70,0:13:39.10,Default,,0,0,0,,我们在这里 建立了关于求导的规则列表
Dialogue: 0,0:13:40.40,0:13:44.33,Default,,0,0,0,,一旦我们有了这些 我们应该做什么呢？
Dialogue: 0,0:13:45.40,0:13:47.84,Default,,0,0,0,,恩 我将给你们展示最好的思想之一
Dialogue: 0,0:13:48.44,0:13:51.68,Default,,0,0,0,,然后我们将花一整天来鼓捣它
Dialogue: 0,0:13:52.28,0:13:57.37,Default,,0,0,0,,我将向大家展示一个叫做simplifier的程序
Dialogue: 0,0:13:57.82,0:13:59.47,Default,,0,0,0,,一个通用的化简器
Dialogue: 0,0:14:00.09,0:14:17.10,Default,,0,0,0,,我们将求导规则deriv-rules送入simplifier从而产生dsimp
Dialogue: 0,0:14:23.74,0:14:28.75,Default,,0,0,0,,传给simplifier过程一套规则 它会返回给我们一个过程
Dialogue: 0,0:14:29.32,0:14:34.59,Default,,0,0,0,,它根据这些规则对表达式进行化简
Dialogue: 0,0:14:37.39,0:14:43.93,Default,,0,0,0,,因此 这里会返回一个按照你制定的规则所构造的过程
Dialogue: 0,0:14:44.59,0:14:49.56,Default,,0,0,0,,使得在我们进入 Lisp 系统后 在命令提示符后面
Dialogue: 0,0:14:49.88,0:15:03.93,Default,,0,0,0,,输入 (DSIMP '(dd (+ x y) x))
Dialogue: 0,0:15:06.99,0:15:10.97,Default,,0,0,0,,注意这里的引号 因为我们讨论的是表达式的求导
Dialogue: 0,0:15:13.29,0:15:17.76,Default,,0,0,0,,然后我将得到结果 (+ 1 0)
Dialogue: 0,0:15:19.96,0:15:24.60,Default,,0,0,0,,因为 (x+y)' = x' + y'
Dialogue: 0,0:15:24.60,0:15:26.22,Default,,0,0,0,,x'=1
Dialogue: 0,0:15:26.38,0:15:27.82,Default,,0,0,0,,y'=0（关于x求导）
Dialogue: 0,0:15:29.42,0:15:30.46,Default,,0,0,0,,这不是我想要的
Dialogue: 0,0:15:31.18,0:15:34.65,Default,,0,0,0,,我还没有在这里做代数化简
Dialogue: 0,0:15:36.16,0:15:41.53,Default,,0,0,0,,当然一旦我有了这个东西那么我们可以 -- 我们可以看看其它的规则
Dialogue: 0,0:15:41.96,0:15:49.36,Default,,0,0,0,,比如 我们看这张幻灯片
Dialogue: 0,0:15:49.36,0:15:54.12,Default,,0,0,0,,这里是其它的规则 代数操作规则
Dialogue: 0,0:15:56.00,0:15:58.38,Default,,0,0,0,,它们可以用来化简代数表达式
Dialogue: 0,0:15:59.00,0:16:02.06,Default,,0,0,0,,考察一下这些规则
Dialogue: 0,0:16:03.04,0:16:09.20,Default,,0,0,0,,这条规则的左部分是说 某个运算符应用到常量e1和常量e2上
Dialogue: 0,0:16:09.32,0:16:14.51,Default,,0,0,0,,其结果就是求(op e1 e2)的值
Dialogue: 0,0:16:15.88,0:16:21.56,Default,,0,0,0,,或者 当一个运算符应用在任意表达式e1和常量e2上
Dialogue: 0,0:16:21.69,0:16:23.87,Default,,0,0,0,,化简结果会把常量前置
Dialogue: 0,0:16:24.52,0:16:27.68,Default,,0,0,0,,这就变成了((: op) (: e2) (: e1))
Dialogue: 0,0:16:28.59,0:16:30.11,Default,,0,0,0,,为什么要这么做？我不知道
Dialogue: 0,0:16:30.22,0:16:33.16,Default,,0,0,0,,比如说 如果系统中有除法的话 这就不对
Dialogue: 0,0:16:33.53,0:16:35.31,Default,,0,0,0,,换句话说 规则有漏洞
Dialogue: 0,0:16:36.67,0:16:40.86,Default,,0,0,0,,所以0与任何表达式e的和 等于表达式e
Dialogue: 0,0:16:42.17,0:16:45.31,Default,,0,0,0,,1乘以任何表达式e的结果是表达式e
Dialogue: 0,0:16:46.12,0:16:49.13,Default,,0,0,0,,0乘以任何表达式e的结果是0
Dialogue: 0,0:16:49.33,0:16:52.72,Default,,0,0,0,,我们可以有任意复杂的规则
Dialogue: 0,0:16:53.69,0:16:54.81,Default,,0,0,0,,比如说
Dialogue: 0,0:16:55.36,0:17:01.69,Default,,0,0,0,,常量e1*(常量e2*任意表达式e3)
Dialogue: 0,0:17:02.35,0:17:11.96,Default,,0,0,0,,可以化简为 (e1*e2)*e3
Dialogue: 0,0:17:13.36,0:17:16.76,Default,,0,0,0,,这个规则是说 先把常量组合起来
Dialogue: 0,0:17:16.76,0:17:22.70,Default,,0,0,0,,如果有形如 e1*(e2*e3) 的式子 而且e1 e2都是常量 就先把常量乘起来
Dialogue: 0,0:17:23.84,0:17:25.48,Default,,0,0,0,,你可以根据意愿来构建这些规则
Dialogue: 0,0:17:25.79,0:17:26.94,Default,,0,0,0,,这里还有很多规则
Dialogue: 0,0:17:27.42,0:17:31.04,Default,,0,0,0,,这些规则是很复杂的 比如--
Dialogue: 0,0:17:31.26,0:17:33.93,Default,,0,0,0,,请看 这条规则是分配律
Dialogue: 0,0:17:33.93,0:17:38.57,Default,,0,0,0,,任何表达式c乘以d和e
Dialogue: 0,0:17:39.02,0:17:43.66,Default,,0,0,0,,等于 c与d的积加上c与e的积
Dialogue: 0,0:17:45.31,0:17:48.67,Default,,0,0,0,,我并不关心这些规则具体描述的什么
Dialogue: 0,0:17:49.16,0:17:52.97,Default,,0,0,0,,我们将要构建一种语言 用来解释这些规则
Dialogue: 0,0:17:55.50,0:17:57.48,Default,,0,0,0,,这样我们就可以按我们的意愿编写规则
Dialogue: 0,0:17:58.35,0:18:00.14,Default,,0,0,0,,这是另外一种程序设计语言
Dialogue: 0,0:18:03.39,0:18:04.04,Default,,0,0,0,,来看看
Dialogue: 0,0:18:05.18,0:18:06.96,Default,,0,0,0,,我还没告诉你我们要怎么做
Dialogue: 0,0:18:07.53,0:18:10.06,Default,,0,0,0,,当然我们马上就要讲了
Dialogue: 0,0:18:10.89,0:18:15.40,Default,,0,0,0,,但真正的问题是：宏观地看 我要做什么？
Dialogue: 0,0:18:17.08,0:18:18.22,Default,,0,0,0,,这些规则是如何运作的？
Dialogue: 0,0:18:19.00,0:18:25.45,Default,,0,0,0,,化简程序是如何用这些规则来输入的表达式 并返回一个合理的答案？
Dialogue: 0,0:18:26.22,0:18:29.85,Default,,0,0,0,,首先 我认为我们有一大堆的规则
Dialogue: 0,0:18:32.52,0:18:34.22,Default,,0,0,0,,这里有全部的规则
Dialogue: 0,0:18:42.09,0:18:44.49,Default,,0,0,0,,这里的每一个规则 ---
Dialogue: 0,0:18:46.97,0:18:49.24,Default,,0,0,0,,都有一个模式和一个骨架
Dialogue: 0,0:18:49.72,0:18:51.36,Default,,0,0,0,,我正在努力为它作一个控制结构
Dialogue: 0,0:18:53.37,0:18:56.56,Default,,0,0,0,,我有一个匹配器
Dialogue: 0,0:19:00.99,0:19:03.76,Default,,0,0,0,,还有一个实例化器
Dialogue: 0,0:19:09.66,0:19:12.94,Default,,0,0,0,,我将把一系列模式变量的值
Dialogue: 0,0:19:14.03,0:19:17.47,Default,,0,0,0,,从匹配器中传递到实例化器中
Dialogue: 0,0:19:18.06,0:19:19.42,Default,,0,0,0,,我把传递的东西叫做词典
Dialogue: 0,0:19:20.59,0:19:21.52,Default,,0,0,0,,传递一本词典
Dialogue: 0,0:19:24.92,0:19:27.82,Default,,0,0,0,,里面记载了：x匹配下列子表达式
Dialogue: 0,0:19:29.04,0:19:31.31,Default,,0,0,0,,而y匹配另一个子表达式
Dialogue: 0,0:19:32.25,0:19:36.35,Default,,0,0,0,,我会从实例化器中构造表达式 并送入匹配器
Dialogue: 0,0:19:37.16,0:19:38.36,Default,,0,0,0,,这些是表达式
Dialogue: 0,0:19:45.00,0:19:48.41,Default,,0,0,0,,这些规则的模式将要送进匹配器中
Dialogue: 0,0:19:49.24,0:19:54.40,Default,,0,0,0,,规则对应的骨架将要送进实例化器中
Dialogue: 0,0:19:55.21,0:19:56.62,Default,,0,0,0,,现在变得有点复杂了
Dialogue: 0,0:19:57.12,0:19:59.53,Default,,0,0,0,,因为当我们处理代数表达式时
Dialogue: 0,0:20:00.44,0:20:03.60,Default,,0,0,0,,有一些规则使你能够做等价代换
Dialogue: 0,0:20:04.24,0:20:05.87,Default,,0,0,0,,这些是等价代换规则
Dialogue: 0,0:20:06.88,0:20:09.29,Default,,0,0,0,,所以需要考察表达式的所有子表达式
Dialogue: 0,0:20:11.13,0:20:15.82,Default,,0,0,0,,给定一个表达式 这些规则应该被不断应用
Dialogue: 0,0:20:16.03,0:20:19.71,Default,,0,0,0,,首先 对于传入的表达式的每个子表达式
Dialogue: 0,0:20:20.22,0:20:22.83,Default,,0,0,0,,所有的规则都需要考察一次
Dialogue: 0,0:20:24.33,0:20:27.07,Default,,0,0,0,,如果有规则匹配成功 那么就会执行这个过程
Dialogue: 0,0:20:27.30,0:20:30.63,Default,,0,0,0,,传递一本存储值的词典
Dialogue: 0,0:20:30.63,0:20:33.39,Default,,0,0,0,,实例化器产生一个新的表达式
Dialogue: 0,0:20:33.90,0:20:39.10,Default,,0,0,0,,该表达式基本上只是替换了原表达式中匹配的部分
Dialogue: 0,0:20:40.84,0:20:44.46,Default,,0,0,0,,然后 我们要对它重新检查
Dialogue: 0,0:20:44.75,0:20:48.11,Default,,0,0,0,,重新考察这些规则 看看表达式是否可以更进一步化简
Dialogue: 0,0:20:49.53,0:20:53.71,Default,,0,0,0,,然后每一个子表达式这样做 直到没有任何变化为止
Dialogue: 0,0:20:54.96,0:20:57.50,Default,,0,0,0,,你可以把它想像成一个有机过程
Dialogue: 0,0:20:57.83,0:21:00.20,Default,,0,0,0,,我们有一锅炖汤
Dialogue: 0,0:21:00.24,0:21:04.32,Default,,0,0,0,,粘乎乎的汤里面有细菌 有酶
Dialogue: 0,0:21:05.63,0:21:10.50,Default,,0,0,0,,这些酶改变了汤
Dialogue: 0,0:21:10.50,0:21:14.38,Default,,0,0,0,,它们附着在你的表达式上 改变了它 然后就走了
Dialogue: 0,0:21:15.28,0:21:17.83,Default,,0,0,0,,就像钥匙和锁一样 它们需要配对
Dialogue: 0,0:21:18.00,0:21:19.73,Default,,0,0,0,,匹配 -- 改变 -- 然后离开
Dialogue: 0,0:21:19.73,0:21:21.68,Default,,0,0,0,,你可以将其想像成一种并行过程
Dialogue: 0,0:21:22.70,0:21:24.97,Default,,0,0,0,,所以你把一个表达式放到这锅“浓汤”中
Dialogue: 0,0:21:25.80,0:21:28.00,Default,,0,0,0,,过了会儿把它拿出来 它就被简化了
Dialogue: 0,0:21:30.44,0:21:32.64,Default,,0,0,0,,它会一直变化 直到不能再变化为止
Dialogue: 0,0:21:33.36,0:21:38.33,Default,,0,0,0,,但这些酶可以附着在表达式的任何部分
Dialogue: 0,0:21:39.21,0:21:43.76,Default,,0,0,0,,课先上到这里 有问题么？
Dialogue: 0,0:21:44.92,0:21:45.36,Default,,0,0,0,,请讲
Dialogue: 0,0:21:45.43,0:21:52.76,Default,,0,0,0,,学生：匹配器和实例化器是两个独立的程序 是么?
Dialogue: 0,0:21:52.76,0:21:53.85,Default,,0,0,0,,教授：他们被拆分成很多小片
Dialogue: 0,0:21:54.14,0:21:56.60,Default,,0,0,0,,然后在一个更大的结构中组合起来
Dialogue: 0,0:21:57.26,0:21:59.13,Default,,0,0,0,,学生：先扫描并匹配
Dialogue: 0,0:21:59.61,0:22:03.21,Default,,0,0,0,,并把匹配结果传递给实例化器
Dialogue: 0,0:22:03.39,0:22:06.03,Default,,0,0,0,,实例化器做出更改 并将其返回给匹配器
Dialogue: 0,0:22:06.11,0:22:08.49,Default,,0,0,0,,教授：不是直接更改 而是生成新的表达式
Dialogue: 0,0:22:09.61,0:22:18.43,Default,,0,0,0,,新表达式中的模式变量都被左边式子中所匹配的值所替换
Dialogue: 0,0:22:18.99,0:22:23.80,Default,,0,0,0,,也就是右边式子中的那些骨架变量 或者说求值变量
Dialogue: 0,0:22:25.20,0:22:27.08,Default,,0,0,0,,学生：然后它要回传给匹配器么?
Dialogue: 0,0:22:27.20,0:22:32.32,Default,,0,0,0,,教授：然后要再进行一轮 直到表达式不再变化
Dialogue: 0,0:22:33.31,0:22:37.00,Default,,0,0,0,,学生：感觉这样递归循环似乎有些危险
Dialogue: 0,0:22:37.20,0:22:42.00,Default,,0,0,0,,教授：你说得很对 如果你定义的规则不好--
Dialogue: 0,0:22:42.00,0:22:45.53,Default,,0,0,0,,你发明的任何语言 如果它可以做任何事情
Dialogue: 0,0:22:45.72,0:22:48.40,Default,,0,0,0,,你就可能写出无限循环的程序
Dialogue: 0,0:22:49.37,0:22:55.07,Default,,0,0,0,,确实 诸如代数处理 这样的过程可能会产生无限循环
Dialogue: 0,0:23:01.05,0:23:01.52,Default,,0,0,0,,教授：请讲
Dialogue: 0,0:23:01.79,0:23:05.90,Default,,0,0,0,,学生：一些语言的设计者觉得这个特性非常重要
Dialogue: 0,0:23:05.93,0:23:12.03,Default,,0,0,0,,以至于它应该是语言的一部分 比如Scheme
Dialogue: 0,0:23:12.03,0:23:13.96,Default,,0,0,0,,你的观点是--
Dialogue: 0,0:23:13.96,0:23:15.08,Default,,0,0,0,,老师：语言的什么特性?
Dialogue: 0,0:23:15.79,0:23:17.26,Default,,0,0,0,,学生：模式匹配
Dialogue: 0,0:23:17.26,0:23:22.03,Default,,0,0,0,,所有应用的这些规则应该 ---
Dialogue: 0,0:23:22.03,0:23:23.70,Default,,0,0,0,,教授：你是说像 Prolog 那样？
Dialogue: 0,0:23:23.70,0:23:26.60,Default,,0,0,0,,学生：类似 Prolog 但更加通用的--
Dialogue: 0,0:23:26.60,0:23:27.64,Default,,0,0,0,,教授：这是可行的
Dialogue: 0,0:23:28.46,0:23:32.30,Default,,0,0,0,,好了 我是觉得吧…… 恩……
Dialogue: 0,0:23:33.16,0:23:36.49,Default,,0,0,0,,我可以教你怎么做 这样你就不用依靠语言的设计者
Dialogue: 0,0:23:40.92,0:23:42.75,Default,,0,0,0,,教授：我们可以自己来实现
Dialogue: 0,0:23:45.28,0:23:45.63,Default,,0,0,0,,下课
Dialogue: 0,0:23:45.63,0:23:50.63,Default,,0,0,0,,[音乐]
Dialogue: 0,0:23:50.63,0:23:53.13,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:23:53.13,0:23:55.63,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:24:00.32,0:24:06.76,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:24:07.07,0:24:10.52,Declare,,0,0,0,,{\an2\fad(500,500)}模式匹配：基于规则的代换
Dialogue: 0,0:24:14.08,0:24:15.80,Default,,0,0,0,,好 上课
Dialogue: 0,0:24:15.80,0:24:17.21,Default,,0,0,0,,现在 我得告诉你们它是如何运作的
Dialogue: 0,0:24:20.00,0:24:24.11,Default,,0,0,0,,它很容易分成很多小份
Dialogue: 0,0:24:24.80,0:24:26.54,Default,,0,0,0,,现在 我们先看一下匹配器
Dialogue: 0,0:24:28.72,0:24:31.42,Default,,0,0,0,,匹配器的结构是像下面这样的
Dialogue: 0,0:24:32.86,0:24:45.12,Default,,0,0,0,,它是一个盒子 它的输入是一个表达式和一个模式
Dialogue: 0,0:24:52.09,0:24:53.95,Default,,0,0,0,,还有个输入是一本词典
Dialogue: 0,0:25:01.71,0:25:08.67,Default,,0,0,0,,要记住 词典把模式变量映射到匹配的值上
Dialogue: 0,0:25:09.15,0:25:11.05,Default,,0,0,0,,它的输出是另一本词典
Dialogue: 0,0:25:18.24,0:25:25.53,Default,,0,0,0,,除了旧词典中已有的内容 新词典中还产生的新的匹配
Dialogue: 0,0:25:28.00,0:25:28.83,Default,,0,0,0,,这就是匹配器
Dialogue: 0,0:25:33.87,0:25:36.54,Default,,0,0,0,,这是一个相当复杂的程序
Dialogue: 0,0:25:37.20,0:25:41.58,Default,,0,0,0,,请大家看看这里的投影 请看
Dialogue: 0,0:25:41.98,0:25:43.87,Default,,0,0,0,,哈哈 真是相当复杂
Dialogue: 0,0:25:44.43,0:25:45.87,Default,,0,0,0,,我只想让大家看一下它的轮廓
Dialogue: 0,0:25:46.78,0:25:49.85,Default,,0,0,0,,其实现细节太复杂了
Dialogue: 0,0:25:51.72,0:25:59.24,Default,,0,0,0,,然而 这是一个庞大的程序 它有很多这样的缩进的结构
Dialogue: 0,0:26:00.09,0:26:05.28,Default,,0,0,0,,在最外层 -- 不要去读这些代码  宏观地看
Dialogue: 0,0:26:05.43,0:26:10.36,Default,,0,0,0,,这里有一个分情况分析 而这些就是不同的情况
Dialogue: 0,0:26:12.09,0:26:16.19,Default,,0,0,0,,现在 我们将要深入细节
Dialogue: 0,0:26:16.67,0:26:18.60,Default,,0,0,0,,试图理解它是如何工作的
Dialogue: 0,0:26:20.08,0:26:22.35,Default,,0,0,0,,我们来看第一张幻灯片
Dialogue: 0,0:26:23.55,0:26:27.93,Default,,0,0,0,,它展示了匹配器的宏观结构
Dialogue: 0,0:26:28.81,0:26:36.33,Default,,0,0,0,,我们看到匹配器 它需要的参数有：模式、表达式和词典
Dialogue: 0,0:26:38.57,0:26:40.40,Default,,0,0,0,,这里是一个cond语句
Dialogue: 0,0:26:41.24,0:26:45.61,Default,,0,0,0,,它有许多不同情况 我们省略了一些代码
Dialogue: 0,0:26:46.62,0:26:48.62,Default,,0,0,0,,这个是我想让大家注意的 通用情况
Dialogue: 0,0:26:50.52,0:26:53.28,Default,,0,0,0,,考虑这个通用模式 它是个非常重要的模式
Dialogue: 0,0:26:56.32,0:27:01.61,Default,,0,0,0,,问题是我们需要同时地检查这两棵树
Dialogue: 0,0:27:02.50,0:27:08.03,Default,,0,0,0,,一棵树是表达式 另一棵树是模式
Dialogue: 0,0:27:08.59,0:27:10.11,Default,,0,0,0,,我们需要在它们之间进行匹配
Dialogue: 0,0:27:11.37,0:27:16.38,Default,,0,0,0,,使得表达式的子表达式会与模式的子表达式相匹配
Dialogue: 0,0:27:18.38,0:27:23.44,Default,,0,0,0,,我们深入研究一下 假设我有一个模式
Dialogue: 0,0:27:23.93,0:27:31.24,Default,,0,0,0,,这个是模式是 一个叫做x的表达式 乘以
Dialogue: 0,0:27:32.44,0:27:35.53,Default,,0,0,0,,乘以一个我们叫做y的表达式
Dialogue: 0,0:27:39.12,0:27:42.04,Default,,0,0,0,,再加上 刚才的表达式y 两个y必须是相同的表达式
Dialogue: 0,0:27:45.21,0:27:47.53,Default,,0,0,0,,我们在考察 乘式的和
Dialogue: 0,0:27:48.99,0:27:54.78,Default,,0,0,0,,其中 乘法和加法的第二个参数都是相同的
Dialogue: 0,0:27:57.02,0:27:58.84,Default,,0,0,0,,这是我们想要匹配像这样的表达式
Dialogue: 0,0:27:59.60,0:28:02.04,Default,,0,0,0,,它作为一个模式看起来像这个样子
Dialogue: 0,0:28:03.02,0:28:04.01,Default,,0,0,0,,这是一课树
Dialogue: 0,0:28:04.94,0:28:06.25,Default,,0,0,0,,它包含了一个加号
Dialogue: 0,0:28:08.08,0:28:20.25,Default,,0,0,0,,还有乘号 以及模式变量(? x)和(? y)
Dialogue: 0,0:28:21.36,0:28:22.73,Default,,0,0,0,,还有模式变量(? y)
Dialogue: 0,0:28:24.92,0:28:26.94,Default,,0,0,0,,这只是把表结构换了种写法 两者其实是一样的
Dialogue: 0,0:28:28.75,0:28:31.76,Default,,0,0,0,,我们先演示一个成功的匹配是如何运行的
Dialogue: 0,0:28:32.49,0:28:39.85,Default,,0,0,0,,这个模式匹配表达式 (+ (* 3 x) x)
Dialogue: 0,0:28:42.41,0:28:43.36,Default,,0,0,0,,这是另一棵个树
Dialogue: 0,0:28:44.33,0:28:56.06,Default,,0,0,0,,它是3乘以x的积加上x
Dialogue: 0,0:28:59.44,0:29:03.02,Default,,0,0,0,,所以我要做的是 同时遍历这两棵树
Dialogue: 0,0:29:04.41,0:29:07.82,Default,,0,0,0,,我想这样遍历它们
Dialogue: 0,0:29:08.67,0:29:12.96,Default,,0,0,0,,我会比较它们是否一样
Dialogue: 0,0:29:12.96,0:29:14.32,Default,,0,0,0,,这是一个复合对象
Dialogue: 0,0:29:15.21,0:29:17.26,Default,,0,0,0,,我们先看它的左分支
Dialogue: 0,0:29:17.26,0:29:18.14,Default,,0,0,0,,这可能是car部分
Dialogue: 0,0:29:18.56,0:29:21.21,Default,,0,0,0,,它们匹配吗？恩 两个加号成功匹配
Dialogue: 0,0:29:21.68,0:29:24.20,Default,,0,0,0,,但是下一个对象是复合的
Dialogue: 0,0:29:24.20,0:29:24.84,Default,,0,0,0,,我们看一下它
Dialogue: 0,0:29:25.20,0:29:26.80,Default,,0,0,0,,这个也匹配了
Dialogue: 0,0:29:26.80,0:29:27.79,Default,,0,0,0,,它们都是星号
Dialogue: 0,0:29:28.51,0:29:30.24,Default,,0,0,0,,现在……哦！
Dialogue: 0,0:29:30.40,0:29:33.60,Default,,0,0,0,,这是模式变量 它和3相匹配
Dialogue: 0,0:29:34.27,0:29:35.92,Default,,0,0,0,,记住 现在x等于3
Dialogue: 0,0:29:36.36,0:29:37.37,Default,,0,0,0,,把它记录在词典中
Dialogue: 0,0:29:37.56,0:29:40.73,Default,,0,0,0,,遍历过程中 词典紧随着我们 并告诉我们：x等于3
Dialogue: 0,0:29:41.45,0:29:45.87,Default,,0,0,0,,x等于3 y等于x 但这两个是不同意义上的x
Dialogue: 0,0:29:46.83,0:29:51.20,Default,,0,0,0,,那个是模式变量x 而这个是模式变量y匹配表达式x
Dialogue: 0,0:29:53.61,0:29:57.76,Default,,0,0,0,,这是模式变量y 它已经有值了 并且值是x
Dialogue: 0,0:29:58.36,0:30:00.06,Default,,0,0,0,,这是x么? 当然是
Dialogue: 0,0:30:00.06,0:30:00.75,Default,,0,0,0,,好的
Dialogue: 0,0:30:02.03,0:30:02.78,Default,,0,0,0,,完事儿了
Dialogue: 0,0:30:03.39,0:30:08.09,Default,,0,0,0,,现在 我有一本词典 它在遍历过程中不断积累
Dialogue: 0,0:30:11.42,0:30:14.51,Default,,0,0,0,,现在让我们看看这个一般情况 然后看看它如何工作
Dialogue: 0,0:30:15.88,0:30:16.51,Default,,0,0,0,,这里..
Dialogue: 0,0:30:17.20,0:30:21.66,Default,,0,0,0,,我传入一个模式 一个表达式 和一本词典
Dialogue: 0,0:30:22.38,0:30:27.50,Default,,0,0,0,,这里的情况比较复杂 -- 它是通用情况
Dialogue: 0,0:30:29.98,0:30:34.80,Default,,0,0,0,,一般来说 表达式由两部分组成：左部分和右部分
Dialogue: 0,0:30:35.45,0:30:38.81,Default,,0,0,0,,在Lisp系统中 复合对象都是由两部分组成的
Dialogue: 0,0:30:40.03,0:30:41.23,Default,,0,0,0,,现在我们有什么呢？
Dialogue: 0,0:30:41.88,0:30:48.84,Default,,0,0,0,,我将会用已有的这本词典 继续匹配模式和表达式的car部分
Dialogue: 0,0:30:50.30,0:30:53.12,Default,,0,0,0,,这个匹配过程会产生一本新词典
Dialogue: 0,0:30:54.14,0:30:57.26,Default,,0,0,0,,我将用它来匹配它们的cdr部分
Dialogue: 0,0:30:58.51,0:31:02.09,Default,,0,0,0,,这就是词典是如何在整个结构中遍历、线索的
Dialogue: 0,0:31:03.66,0:31:07.53,Default,,0,0,0,,匹配完car和cdr部分后得到的词典
Dialogue: 0,0:31:10.12,0:31:12.41,Default,,0,0,0,,会作为值返回给上级
Dialogue: 0,0:31:13.61,0:31:15.84,Default,,0,0,0,,匹配可能会在任何一个地方失败
Dialogue: 0,0:31:16.62,0:31:18.20,Default,,0,0,0,,比如说 可能会有这种情况
Dialogue: 0,0:31:18.36,0:31:27.18,Default,,0,0,0,,我们回过头来把这里改成4 这样就不会完全匹配
Dialogue: 0,0:31:29.13,0:31:34.81,Default,,0,0,0,,现在这两个不再匹配了 因为x应该
Dialogue: 0,0:31:34.93,0:31:37.34,Default,,0,0,0,,不好意思 这个y是x
Dialogue: 0,0:31:37.82,0:31:40.12,Default,,0,0,0,,但是这里的y却又是4
Dialogue: 0,0:31:40.53,0:31:43.52,Default,,0,0,0,,语法上来说 x和4显然不相同
Dialogue: 0,0:31:44.59,0:31:48.81,Default,,0,0,0,,所以这个不会匹配成功 它会拒绝 匹配会失败
Dialogue: 0,0:31:50.19,0:31:56.08,Default,,0,0,0,,那么 因为先前产生的词典会作为输入送入匹配器
Dialogue: 0,0:31:56.52,0:31:58.28,Default,,0,0,0,,所以它必须能够传播失败
Dialogue: 0,0:31:58.57,0:32:01.04,Default,,0,0,0,,第一条语句就是用来判断失败的
Dialogue: 0,0:32:03.61,0:32:08.19,Default,,0,0,0,,如果证实出来这个模式不是原子的---
Dialogue: 0,0:32:08.50,0:32:11.45,Default,,0,0,0,,如果模式是原子的 将进入这里 这里我们还没有讨论过
Dialogue: 0,0:32:12.17,0:32:13.56,Default,,0,0,0,,如果模式不是原子的
Dialogue: 0,0:32:15.05,0:32:19.23,Default,,0,0,0,,但表达式是原子--也就是它不由小部分组成
Dialogue: 0,0:32:20.14,0:32:22.65,Default,,0,0,0,,那么匹配必然失败 因此我们返回'failed
Dialogue: 0,0:32:23.64,0:32:30.78,Default,,0,0,0,,整理下思路 如果这个模式既不是原子的又不是模式变量的话 程序会来到这里
Dialogue: 0,0:32:30.96,0:32:32.51,Default,,0,0,0,,这是会使匹配失败的情况
Dialogue: 0,0:32:35.26,0:32:39.12,Default,,0,0,0,,好 让我们看这个里面的东西
Dialogue: 0,0:32:39.84,0:32:42.93,Default,,0,0,0,,首先需要知道 如果用原子模式来进行匹配会发生什么？
Dialogue: 0,0:32:42.93,0:32:43.90,Default,,0,0,0,,这简单
Dialogue: 0,0:32:43.90,0:32:46.50,Default,,0,0,0,,不是由其它模式构成的模式 比如：foo
Dialogue: 0,0:32:47.37,0:32:48.54,Default,,0,0,0,,这是个非常好的原子模式
Dialogue: 0,0:32:49.16,0:32:51.24,Default,,0,0,0,,让我们来看看
Dialogue: 0,0:32:52.08,0:32:55.82,Default,,0,0,0,,如果模式是原子的 而且表达式也原子的话
Dialogue: 0,0:32:56.80,0:33:01.85,Default,,0,0,0,,并且如果它俩是同一个东西 那么词典就跟之前一样
Dialogue: 0,0:33:03.08,0:33:04.00,Default,,0,0,0,,没有变化
Dialogue: 0,0:33:04.60,0:33:10.33,Default,,0,0,0,,就像刚才 +匹配+ *匹配* x匹配x
Dialogue: 0,0:33:11.42,0:33:12.33,Default,,0,0,0,,就是那样
Dialogue: 0,0:33:13.07,0:33:16.81,Default,,0,0,0,,然而 如何模式和表达式并不相同的话
Dialogue: 0,0:33:17.32,0:33:21.36,Default,,0,0,0,,如果这是两个不同的原子对象 比如+和*相匹配
Dialogue: 0,0:33:22.44,0:33:23.40,Default,,0,0,0,,这样就失败了
Dialogue: 0,0:33:25.60,0:33:34.56,Default,,0,0,0,,或者说 如果模式是原子 但表达式是复合 那么匹配失败
Dialogue: 0,0:33:37.40,0:33:38.24,Default,,0,0,0,,这很简单
Dialogue: 0,0:33:38.81,0:33:43.61,Default,,0,0,0,,那么 那些各种各样的模式变量又是怎么处理的呢？
Dialogue: 0,0:33:44.09,0:33:46.54,Default,,0,0,0,,我们有三类被命名了的模式变量
Dialogue: 0,0:33:47.39,0:33:52.03,Default,,0,0,0,,它们分别用于匹配：任意常量 任意变量 任意表达式
Dialogue: 0,0:33:53.82,0:34:00.14,Default,,0,0,0,,(? x) 表示匹配任意表达式
Dialogue: 0,0:34:01.18,0:34:04.54,Default,,0,0,0,,(?c x) 表示匹配任意常量
Dialogue: 0,0:34:04.73,0:34:07.29,Default,,0,0,0,,(?v x) 表示匹配任意变量
Dialogue: 0,0:34:08.96,0:34:09.79,Default,,0,0,0,,好的 我们要做什么呢?
Dialogue: 0,0:34:10.51,0:34:16.94,Default,,0,0,0,,看这里 如果模式表示的是匹配任意常量
Dialogue: 0,0:34:17.53,0:34:20.57,Default,,0,0,0,,那么待匹配的表达式最好是一个常量
Dialogue: 0,0:34:21.48,0:34:23.53,Default,,0,0,0,,不然的话 匹配就会失败
Dialogue: 0,0:34:23.83,0:34:27.50,Default,,0,0,0,,如果是一个常量 那么我就需要扩充词典
Dialogue: 0,0:34:27.50,0:34:29.69,Default,,0,0,0,,扩充词典的方法则是：
Dialogue: 0,0:34:30.70,0:34:37.76,Default,,0,0,0,,在旧词典后 附加一对模式与表达式的配对
Dialogue: 0,0:34:41.16,0:34:42.75,Default,,0,0,0,,因此 如果是匹配任意变量
Dialogue: 0,0:34:43.72,0:34:47.46,Default,,0,0,0,,我得通过匹配来核查表达式是否是变量
Dialogue: 0,0:34:47.46,0:34:50.09,Default,,0,0,0,,如果是的话 我就扩充词典
Dialogue: 0,0:34:50.38,0:34:54.65,Default,,0,0,0,,现在在原有词典基础上 我们又多了一项模式与表达式的匹配
Dialogue: 0,0:34:55.28,0:34:56.70,Default,,0,0,0,,这个过程返回一本新的词典
Dialogue: 0,0:34:58.88,0:35:04.16,Default,,0,0,0,,在这个词典中也有很多失败 因此需要检查
Dialogue: 0,0:35:04.16,0:35:07.50,Default,,0,0,0,,就比如 模式变量已经有一个值了
Dialogue: 0,0:35:09.23,0:35:16.17,Default,,0,0,0,,但我又用它匹配一个跟之前匹配的表达式不相同的表达式的话
Dialogue: 0,0:35:16.43,0:35:18.36,Default,,0,0,0,,那么在这里也会立即产生失败
Dialogue: 0,0:35:20.16,0:35:21.56,Default,,0,0,0,,我们后面再讨论
Dialogue: 0,0:35:22.91,0:35:29.36,Default,,0,0,0,,最后 匹配任意的表达式不需要在语法范畴做什么检查
Dialogue: 0,0:35:30.11,0:35:32.20,Default,,0,0,0,,只用扩充词典就行了
Dialogue: 0,0:35:34.76,0:35:38.32,Default,,0,0,0,,这就是一个完整的简单的匹配器
Dialogue: 0,0:35:39.28,0:35:41.37,Default,,0,0,0,,非常具有讽刺意味的一点是
Dialogue: 0,0:35:41.66,0:35:45.12,Default,,0,0,0,,现在 人们花了大价钱来请一些人编写
Dialogue: 0,0:35:45.46,0:35:47.52,Default,,0,0,0,,所谓的 “人工智能专家系统”
Dialogue: 0,0:35:48.40,0:35:52.03,Default,,0,0,0,,也不过是像这样的一个匹配器和实例化器罢了
Dialogue: 0,0:35:53.56,0:35:56.94,Default,,0,0,0,,这很容易做 现在你也可以创业开个小公司了
Dialogue: 0,0:35:57.42,0:36:01.72,Default,,0,0,0,,然后 第二周忽悠风投给你投个几百万
Dialogue: 0,0:36:03.79,0:36:08.57,Default,,0,0,0,,我是想说 这种程序放在20年前是非凡的
Dialogue: 0,0:36:09.74,0:36:12.81,Default,,0,0,0,,但放到现在 它就是小菜一碟了 大一新生也可以学
Dialogue: 0,0:36:13.63,0:36:15.47,Default,,0,0,0,,这里是一个实例化器
Dialogue: 0,0:36:20.22,0:36:23.07,Default,,0,0,0,,可问题是 他们都去了赚钱了 而且比我的还多
Dialogue: 0,0:36:24.97,0:36:26.59,Default,,0,0,0,,在大学中确实是这样
Dialogue: 0,0:36:27.10,0:36:39.42,Default,,0,0,0,,实例化是用来将给定的表达式、词典和骨架生成新的表达式的
Dialogue: 0,0:36:44.35,0:36:45.69,Default,,0,0,0,,这个不是很难
Dialogue: 0,0:36:46.60,0:36:53.36,Default,,0,0,0,,我们在下一张幻灯片中简单地看下
Dialogue: 0,0:36:53.88,0:36:59.29,Default,,0,0,0,,用一本给定的词典去实例化一个骨架 这很简单
Dialogue: 0,0:36:59.68,0:37:03.29,Default,,0,0,0,,我们要做的 就是对骨架递归地做树遍历
Dialogue: 0,0:37:04.08,0:37:08.33,Default,,0,0,0,,所有的骨架变量---我叫它“骨架求值”
Dialogue: 0,0:37:08.41,0:37:11.42,Default,,0,0,0,,这是我在这个程序中定义的抽象语法
Dialogue: 0,0:37:11.60,0:37:16.46,Default,,0,0,0,,在规则中 以冒号打头的就是骨架求值
Dialogue: 0,0:37:18.25,0:37:24.30,Default,,0,0,0,,在那种情况下 我要在词典中找答案 我们待会儿再讨论
Dialogue: 0,0:37:24.30,0:37:25.61,Default,,0,0,0,,我们看整体
Dialogue: 0,0:37:27.77,0:37:31.80,Default,,0,0,0,,这个过程是用一本字典来实例化一个骨架
Dialogue: 0,0:37:32.75,0:37:37.15,Default,,0,0,0,,我在这里定义一个内部循环
Dialogue: 0,0:37:38.14,0:37:39.85,Default,,0,0,0,,它要做的事情很简单
Dialogue: 0,0:37:40.17,0:37:43.50,Default,,0,0,0,,如果这个骨架是原子的
Dialogue: 0,0:37:44.60,0:37:47.45,Default,,0,0,0,,这种情况 它直接返回一个骨架作为结果
Dialogue: 0,0:37:48.84,0:37:51.87,Default,,0,0,0,,或者在通常情况下它是复合的
Dialogue: 0,0:37:52.60,0:37:59.40,Default,,0,0,0,,这种情况下 我通过一些实例化的结果构造表达式
Dialogue: 0,0:37:59.40,0:38:04.25,Default,,0,0,0,,递归调用这个循环 不断实例化骨架的car和cdr部分
Dialogue: 0,0:38:04.89,0:38:06.24,Default,,0,0,0,,这就是树的递归遍历
Dialogue: 0,0:38:08.41,0:38:14.36,Default,,0,0,0,,如果在骨架中有冒号表达式 那么这就是一个骨架求值
Dialogue: 0,0:38:14.96,0:38:22.64,Default,,0,0,0,,那么要做的事情是：找到冒号引导的表达式 -- 本例中 也就是CADR部分
Dialogue: 0,0:38:22.81,0:38:26.25,Default,,0,0,0,,这些是抽象语法 因此我能改变规则的表示
Dialogue: 0,0:38:27.52,0:38:32.73,Default,,0,0,0,,先不管求值过程如何实现 总之我要用这本词典对表达式求值
Dialogue: 0,0:38:32.90,0:38:34.65,Default,,0,0,0,,我们以后再仔细讨论
Dialogue: 0,0:38:36.12,0:38:38.35,Default,,0,0,0,,求值的结果就是答案
Dialogue: 0,0:38:39.68,0:38:43.66,Default,,0,0,0,,这条初始化语句 通过给它传递整个骨架循环来启动它
Dialogue: 0,0:38:44.44,0:38:47.04,Default,,0,0,0,,这些调用又会被分成小块的递归调用
Dialogue: 0,0:38:49.63,0:38:56.48,Default,,0,0,0,,那么 求值过程里面发生了些什么
Dialogue: 0,0:38:57.18,0:38:59.07,Default,,0,0,0,,我无法详尽地给你们解释
Dialogue: 0,0:38:59.98,0:39:01.34,Default,,0,0,0,,我就大致说一下
Dialogue: 0,0:39:01.56,0:39:03.74,Default,,0,0,0,,之后 我们再深入地讨论
Dialogue: 0,0:39:05.29,0:39:10.81,Default,,0,0,0,,在一本词典的环境下 求值一个表达式
Dialogue: 0,0:39:11.90,0:39:14.17,Default,,0,0,0,,如果表达式是原子的
Dialogue: 0,0:39:15.04,0:39:16.22,Default,,0,0,0,,就在词典中进行查找
Dialogue: 0,0:39:18.60,0:39:19.87,Default,,0,0,0,,这没啥
Dialogue: 0,0:39:20.57,0:39:23.66,Default,,0,0,0,,难点在这里
Dialogue: 0,0:39:23.83,0:39:28.28,Default,,0,0,0,,我将要应用表达式的car部分对应的一个过程
Dialogue: 0,0:39:29.44,0:39:31.68,Default,,0,0,0,,这个过程是在“某个地方”查找得到的--我们以后讨论
Dialogue: 0,0:39:32.14,0:39:34.20,Default,,0,0,0,,我想请大家注意一下 这之中有一些“魔法”
Dialogue: 0,0:39:34.67,0:39:38.72,Default,,0,0,0,,这个魔法将在不久后“施展”出来 但不是在今天
Dialogue: 0,0:39:40.00,0:39:46.51,Default,,0,0,0,,我们在词典中查找表达式剩余部分对应的值
Dialogue: 0,0:39:48.56,0:39:50.88,Default,,0,0,0,,我还不想让你们关注细节
Dialogue: 0,0:39:51.44,0:39:53.44,Default,,0,0,0,,我想让大家意识到这里还有很多代码
Dialogue: 0,0:39:54.17,0:39:56.75,Default,,0,0,0,,我们以后再详细讨论
Dialogue: 0,0:39:59.04,0:40:00.88,Default,,0,0,0,,但是 魔法就到此结束了
Dialogue: 0,0:40:02.57,0:40:06.96,Default,,0,0,0,,这部分利用Lisp的神奇力量 不过也就到此为止了
Dialogue: 0,0:40:10.25,0:40:13.56,Default,,0,0,0,,我们介绍了匹配和实例化
Dialogue: 0,0:40:15.05,0:40:16.60,Default,,0,0,0,,这一节有疑问么?
Dialogue: 0,0:40:28.10,0:40:29.80,Default,,0,0,0,,学生：我有一个问题
Dialogue: 0,0:40:29.80,0:40:30.43,Default,,0,0,0,,教授：请讲
Dialogue: 0,0:40:30.43,0:40:32.56,Default,,0,0,0,,学生：您能切到前张幻灯片上吗？
Dialogue: 0,0:40:33.60,0:40:35.56,Default,,0,0,0,,是关于定义匹配模式的
Dialogue: 0,0:40:36.16,0:40:40.76,Default,,0,0,0,,教授：好的 你想看定义匹配模式的全部的幻灯片
Dialogue: 0,0:40:40.76,0:40:43.06,Default,,0,0,0,,有人能帮我把投影仪---
Dialogue: 0,0:40:43.06,0:40:45.16,Default,,0,0,0,,这是最大的规模
Dialogue: 0,0:40:45.31,0:40:46.40,Default,,0,0,0,,你想看哪一部分？
Dialogue: 0,0:40:46.76,0:40:49.96,Default,,0,0,0,,学生：呃 最上面吧
Dialogue: 0,0:40:49.96,0:40:53.76,Default,,0,0,0,,就是传递失败的那一部分
Dialogue: 0,0:40:54.52,0:40:55.21,Default,,0,0,0,,教授：恩
Dialogue: 0,0:40:55.64,0:40:59.33,Default,,0,0,0,,学生：基本的想法是把错误返回给词典 是么?
Dialogue: 0,0:40:59.33,0:41:04.25,Default,,0,0,0,,教授：所谓的词典 就是所是匹配的答案 对吧？
Dialogue: 0,0:41:05.16,0:41:09.80,Default,,0,0,0,,要么它是一些配对
Dialogue: 0,0:41:11.07,0:41:14.03,Default,,0,0,0,,要么根本就没有配对
Dialogue: 0,0:41:14.46,0:41:14.97,Default,,0,0,0,,学生：对
Dialogue: 0,0:41:15.26,0:41:17.83,Default,,0,0,0,,教授：这里 事实上
Dialogue: 0,0:41:17.83,0:41:22.60,Default,,0,0,0,,因为一个匹配过程会向另一个匹配过程传递词典
Dialogue: 0,0:41:22.80,0:41:24.65,Default,,0,0,0,,可以在这里的一般情况中看到
Dialogue: 0,0:41:25.12,0:41:27.93,Default,,0,0,0,,这是一个匹配过程传递词典到另一个匹配过程
Dialogue: 0,0:41:28.14,0:41:34.16,Default,,0,0,0,,我是用匹配car部分得到的词典来匹配cdr部分的
Dialogue: 0,0:41:36.06,0:41:37.08,Default,,0,0,0,,这里的代码就是这个意思
Dialogue: 0,0:41:37.29,0:41:40.30,Default,,0,0,0,,正因为如此 如果对car部分的匹配失败了
Dialogue: 0,0:41:41.23,0:41:45.44,Default,,0,0,0,,匹配cdr部分的时候就有必要传播失败
Dialogue: 0,0:41:45.95,0:41:46.96,Default,,0,0,0,,第一行就是用于传播失败
Dialogue: 0,0:41:48.26,0:41:51.73,Default,,0,0,0,,学生：好 但我还是不明白匹配 --
Dialogue: 0,0:41:51.73,0:41:54.24,Default,,0,0,0,,从匹配的实例出来的是什么?
Dialogue: 0,0:41:54.73,0:41:56.00,Default,,0,0,0,,教授：有两种可能的情况
Dialogue: 0,0:41:56.33,0:41:59.15,Default,,0,0,0,,一种是符号'failed 意味匹配失败
Dialogue: 0,0:41:59.53,0:41:59.93,Default,,0,0,0,,学生：对
Dialogue: 0,0:41:59.93,0:42:03.87,Default,,0,0,0,,教授：或者是某种映射 -- 现在这还是一个抽象的东西
Dialogue: 0,0:42:04.16,0:42:05.68,Default,,0,0,0,,你需要知道它的结构
Dialogue: 0,0:42:06.49,0:42:13.96,Default,,0,0,0,,它们把匹配过程中 匹配成功的模式变量和值关联起来
Dialogue: 0,0:42:14.68,0:42:16.70,Default,,0,0,0,,学生：好 那么
Dialogue: 0,0:42:16.80,0:42:18.57,Default,,0,0,0,,教授：那是通过扩充词典实现的
Dialogue: 0,0:42:18.80,0:42:28.54,Default,,0,0,0,,学生：所以根据递归性质 如果匹配过程产生并传递了失败
Dialogue: 0,0:42:28.68,0:42:30.30,Default,,0,0,0,,那么第一种情况将捕获它
Dialogue: 0,0:42:30.40,0:42:33.56,Default,,0,0,0,,教授：并且传播它 不做任何其它处理
Dialogue: 0,0:42:33.56,0:42:34.83,Default,,0,0,0,,学生：哦 懂了
Dialogue: 0,0:42:35.50,0:42:37.36,Default,,0,0,0,,教授：这是传出失败最快的方法
Dialogue: 0,0:42:42.86,0:42:43.60,Default,,0,0,0,,请讲
Dialogue: 0,0:42:43.84,0:42:47.23,Default,,0,0,0,,学生：如果没有失败 那意味着我匹配了一个模式
Dialogue: 0,0:42:47.84,0:42:53.00,Default,,0,0,0,,我会扩充词典并且传递表达式中的模式
Dialogue: 0,0:42:55.21,0:42:58.43,Default,,0,0,0,,但是 代换并不是发生在这 对吧？
Dialogue: 0,0:42:58.43,0:42:59.03,Default,,0,0,0,,是吧？
Dialogue: 0,0:42:59.03,0:42:59.46,Default,,0,0,0,,教授：你是对的
Dialogue: 0,0:42:59.46,0:43:02.40,Default,,0,0,0,,这里没有可供代换的骨架 因此不会发生代换
Dialogue: 0,0:43:02.40,0:43:03.06,Default,,0,0,0,,学生：好 那么
Dialogue: 0,0:43:03.06,0:43:07.16,Default,,0,0,0,,教授：我们这里所做的 是为后面的代换准备词典
Dialogue: 0,0:43:08.25,0:43:12.43,Default,,0,0,0,,学生：词典的数据结构是什么呢？是有序对么？
Dialogue: 0,0:43:12.72,0:43:15.96,Default,,0,0,0,,教授：那个 那个还没有告诉你
Dialogue: 0,0:43:15.96,0:43:16.89,Default,,0,0,0,,它还是一个抽象的东西
Dialogue: 0,0:43:17.06,0:43:17.56,Default,,0,0,0,,学生：哦
Dialogue: 0,0:43:17.56,0:43:18.90,Default,,0,0,0,,教授：你为什么要知道呢?
Dialogue: 0,0:43:18.90,0:43:21.64,Default,,0,0,0,,它是一个函数 仅仅是一个函数
Dialogue: 0,0:43:21.69,0:43:22.33,Default,,0,0,0,,学生：我想知道它的原因是--
Dialogue: 0,0:43:22.33,0:43:24.17,Default,,0,0,0,,教授：这个抽象函数表现地像有序对
Dialogue: 0,0:43:25.12,0:43:28.44,Default,,0,0,0,,它可以用一系列的表通过链接来实现
Dialogue: 0,0:43:29.06,0:43:32.43,Default,,0,0,0,,它也可以用一些酷炫的表机制来实现
Dialogue: 0,0:43:32.56,0:43:34.16,Default,,0,0,0,,它也可以实现为一个函数
Dialogue: 0,0:43:35.80,0:43:37.40,Default,,0,0,0,,我可以把它写成一个函数
Dialogue: 0,0:43:39.02,0:43:39.87,Default,,0,0,0,,但我不会告诉你具体细节
Dialogue: 0,0:43:40.84,0:43:43.08,Default,,0,0,0,,这是George的事情 由他来构建这个结构
Dialogue: 0,0:43:49.56,0:43:52.06,Default,,0,0,0,,我知道 你特别想知道它的具体结构
Dialogue: 0,0:43:52.36,0:43:54.19,Default,,0,0,0,,但我不打算让你那么做
Dialogue: 0,0:43:54.43,0:43:59.23,Default,,0,0,0,,学生：恩 最后一个问题 扩充到词典中的重要信息是什么?
Dialogue: 0,0:43:59.74,0:44:02.08,Default,,0,0,0,,我想 可能是匹配发现的模式
Dialogue: 0,0:44:02.73,0:44:04.83,Default,,0,0,0,,教授：是的 那些与表达式相匹配的模式
Dialogue: 0,0:44:04.83,0:44:09.30,Default,,0,0,0,,我们想要得到模式 只不过在本例中这些都是模式变量 对吧？
Dialogue: 0,0:44:09.85,0:44:12.89,Default,,0,0,0,,这三种扩充词典的情况都是模式变量
Dialogue: 0,0:44:13.20,0:44:13.50,Default,,0,0,0,,学生：恩
Dialogue: 0,0:44:14.48,0:44:18.75,Default,,0,0,0,,教授：所以 在词典就有一个模式变量与一个值对应
Dialogue: 0,0:44:19.45,0:44:22.11,Default,,0,0,0,,这个值是所匹配的表达式
Dialogue: 0,0:44:23.31,0:44:29.63,Default,,0,0,0,,词典就是遍历过程中记录下来的所有匹配
Dialogue: 0,0:44:30.54,0:44:34.41,Default,,0,0,0,,我会以原有词典为基础 创建一本新词典
Dialogue: 0,0:44:35.12,0:44:38.35,Default,,0,0,0,,新增的内容就是新发现的匹配
Dialogue: 0,0:44:39.98,0:44:43.73,Default,,0,0,0,,学生：我不理解为什么不能在发现匹配后立即进行代换
Dialogue: 0,0:44:43.73,0:44:44.80,Default,,0,0,0,,教授：哦 那时候还不能代换
Dialogue: 0,0:44:44.81,0:44:46.62,Default,,0,0,0,,因为我不知道骨架啊！
Dialogue: 0,0:44:47.58,0:44:49.66,Default,,0,0,0,,模式和匹配器都是独立的单元
Dialogue: 0,0:44:49.66,0:44:51.00,Default,,0,0,0,,学生：哦 我明白了
Dialogue: 0,0:44:51.00,0:44:51.50,Default,,0,0,0,,教授：懂了吧？
Dialogue: 0,0:44:51.50,0:44:51.90,Default,,0,0,0,,学生：恩
Dialogue: 0,0:44:51.90,0:44:57.23,Default,,0,0,0,,教授：我用这个匹配器进行匹配 如果匹配了就可以实例化
Dialogue: 0,0:44:58.20,0:44:59.50,Default,,0,0,0,,学生：知道了
Dialogue: 0,0:45:00.54,0:45:03.88,Default,,0,0,0,,学生：您可以再求解一次黑板上的例子么
Dialogue: 0,0:45:04.89,0:45:06.93,Default,,0,0,0,,什么东西返回给了匹配器
Dialogue: 0,0:45:06.93,0:45:08.00,Default,,0,0,0,,教授：当然可以
Dialogue: 0,0:45:08.26,0:45:09.74,Default,,0,0,0,,来看这个例子
Dialogue: 0,0:45:10.67,0:45:15.45,Default,,0,0,0,,在这里当我遍历这个结构的时候 我遇到了(? x)
Dialogue: 0,0:45:16.67,0:45:20.54,Default,,0,0,0,,我有一本词典 不过此时假设它是空的
Dialogue: 0,0:45:21.56,0:45:25.36,Default,,0,0,0,,一本空词典 然后我匹配到了x为3
Dialogue: 0,0:45:26.62,0:45:33.60,Default,,0,0,0,,从此以后 词典中就记录了 x与3匹配 对吧
Dialogue: 0,0:45:33.64,0:45:36.09,Default,,0,0,0,,继续遍历 然后遇到(? y)
Dialogue: 0,0:45:36.89,0:45:39.20,Default,,0,0,0,,它是一个特殊的x 这是模式变量x
Dialogue: 0,0:45:39.79,0:45:41.37,Default,,0,0,0,,我看到(? y) 模式变量y
Dialogue: 0,0:45:42.17,0:45:47.74,Default,,0,0,0,,词典说 模式变量y的值是符号x
Dialogue: 0,0:45:48.99,0:45:51.20,Default,,0,0,0,,因为这里已经匹配过了
Dialogue: 0,0:45:52.43,0:45:54.52,Default,,0,0,0,,所以此时 词典中包含两个条目
Dialogue: 0,0:45:55.45,0:45:59.90,Default,,0,0,0,,模式变量x是数字3 模式变量y是表达式x
Dialogue: 0,0:46:01.95,0:46:04.11,Default,,0,0,0,,现在继续进行遍历
Dialogue: 0,0:46:04.23,0:46:07.45,Default,,0,0,0,,这里 模式变量y想要和4匹配
Dialogue: 0,0:46:08.06,0:46:10.65,Default,,0,0,0,,但是这个不可能 产生失败
Dialogue: 0,0:46:14.30,0:46:15.48,Default,,0,0,0,,谢谢 下课
Dialogue: 0,0:46:16.76,0:46:25.02,Default,,0,0,0,,[音乐]
Dialogue: 0,0:46:25.07,0:46:27.45,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:46:27.47,0:46:30.00,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教
Dialogue: 0,0:46:48.19,0:46:54.75,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:46:55.20,0:46:58.04,Declare,,0,0,0,,{\an2\fad(500,500)}模式匹配：基于规则的代换
Dialogue: 0,0:47:02.38,0:47:05.68,Default,,0,0,0,,这是大家首次看到如此庞大而复杂的程序
Dialogue: 0,0:47:07.34,0:47:09.90,Default,,0,0,0,,当然 本项课程的目的之一就在于
Dialogue: 0,0:47:09.90,0:47:12.97,Default,,0,0,0,,是让大家可以读懂这么庞大的程序 而完全不用害怕它
Dialogue: 0,0:47:13.76,0:47:16.33,Default,,0,0,0,,这个程序仅仅只有4页代码而已
Dialogue: 0,0:47:17.08,0:47:19.23,Default,,0,0,0,,课程结业后 我希望就算是50页长的程序
Dialogue: 0,0:47:20.27,0:47:21.80,Default,,0,0,0,,也吓不倒你们
Dialogue: 0,0:47:22.97,0:47:28.20,Default,,0,0,0,,我不是说让你们“左耳朵进 右耳朵出”地读程序
Dialogue: 0,0:47:29.20,0:47:31.70,Default,,0,0,0,,你应该体会这个程序
Dialogue: 0,0:47:31.70,0:47:34.83,Default,,0,0,0,,然后好好思考 因为它是一个很大的程序
Dialogue: 0,0:47:35.32,0:47:38.92,Default,,0,0,0,,在这个程序中有很多东西
Dialogue: 0,0:47:41.24,0:47:46.03,Default,,0,0,0,,我已经介绍了我们正在实现的 -- 基于规则代换的模式匹配语言
Dialogue: 0,0:47:46.81,0:47:47.64,Default,,0,0,0,,给你们看了一些规则
Dialogue: 0,0:47:48.36,0:47:51.24,Default,,0,0,0,,我已经告诉大家匹配和实例化
Dialogue: 0,0:47:51.55,0:47:53.32,Default,,0,0,0,,它们是使规则生效的“阴阳两极”
Dialogue: 0,0:47:54.24,0:47:56.35,Default,,0,0,0,,现在我们需要理解控制结构
Dialogue: 0,0:47:56.86,0:48:00.32,Default,,0,0,0,,就是这些规则是如何被用在表达式上
Dialogue: 0,0:48:01.08,0:48:03.84,Default,,0,0,0,,来指导代数化简的
Dialogue: 0,0:48:06.92,0:48:09.58,Default,,0,0,0,,这也是非常复杂的
Dialogue: 0,0:48:12.09,0:48:19.48,Default,,0,0,0,,其中有很多循环 相互交织 错综复杂
Dialogue: 0,0:48:20.24,0:48:26.99,Default,,0,0,0,,一方面 我不得不检查 待化简表达式的每个子表达式
Dialogue: 0,0:48:29.00,0:48:29.93,Default,,0,0,0,,我们已经讲过了
Dialogue: 0,0:48:29.93,0:48:36.24,Default,,0,0,0,,这是在car、cdr部分做某种树形递归
Dialogue: 0,0:48:37.44,0:48:38.59,Default,,0,0,0,,就是那样
Dialogue: 0,0:48:38.84,0:48:42.46,Default,,0,0,0,,现在 在我每个遍历到的结点上
Dialogue: 0,0:48:43.47,0:48:48.76,Default,,0,0,0,,也就是我想要化简的（子）表达式
Dialogue: 0,0:48:49.20,0:48:51.07,Default,,0,0,0,,我需要应用所有的规则
Dialogue: 0,0:48:53.42,0:48:55.08,Default,,0,0,0,,每个规则都需要检查每个节点
Dialogue: 0,0:48:56.00,0:48:57.92,Default,,0,0,0,,我一直在这些规则中打转（循环）
Dialogue: 0,0:49:01.66,0:49:05.48,Default,,0,0,0,,一个规则可能匹配 也可能不匹配
Dialogue: 0,0:49:07.50,0:49:10.62,Default,,0,0,0,,如果规则不匹配 那我就不关心了
Dialogue: 0,0:49:12.28,0:49:19.34,Default,,0,0,0,,如果规则匹配了 我就在那个结点用另一个表达式替换这个表达式
Dialogue: 0,0:49:20.08,0:49:22.89,Default,,0,0,0,,实际上 我创建了一个新表达式 它包含
Dialogue: 0,0:49:23.55,0:49:28.65,Default,,0,0,0,,它包含了所有的东西 新的值代换入骨架后的结果
Dialogue: 0,0:49:29.21,0:49:31.92,Default,,0,0,0,,也就是 在该层次上 把规则所对应的骨架实例化的结果
Dialogue: 0,0:49:32.72,0:49:37.37,Default,,0,0,0,,但我并不知道我所实例化出来的东西 是否是简化形式
Dialogue: 0,0:49:38.75,0:49:43.82,Default,,0,0,0,,所以我要对我刚刚构建好的东西调用化简器来简化它
Dialogue: 0,0:49:46.12,0:49:50.36,Default,,0,0,0,,完成后 我就可以将其构建进我想要的表达式中作为答案
Dialogue: 0,0:49:51.80,0:49:57.45,Default,,0,0,0,,这里的基本思想是 我们定义一个 “废料进-废料出”的化简器
Dialogue: 0,0:50:01.47,0:50:02.75,Default,,0,0,0,,它是一种递归调用的化简器
Dialogue: 0,0:50:03.58,0:50:08.84,Default,,0,0,0,,化简方法是：基本对象 比如变量就是最简形式的了
Dialogue: 0,0:50:10.78,0:50:13.28,Default,,0,0,0,,复合对象 -- 呃 我也不知道
Dialogue: 0,0:50:14.09,0:50:16.56,Default,,0,0,0,,而我要从简单的对象入手
Dialogue: 0,0:50:16.86,0:50:21.23,Default,,0,0,0,,通过假设它们都是由小块的基本对象组成的
Dialogue: 0,0:50:24.60,0:50:25.61,Default,,0,0,0,,这就是思路
Dialogue: 0,0:50:27.82,0:50:33.12,Default,,0,0,0,,现在如果我们看第一张投影
Dialogue: 0,0:50:33.88,0:50:37.13,Default,,0,0,0,,我们看到一个非常复杂的程序 就像我们之前看到的匹配器一样
Dialogue: 0,0:50:37.53,0:50:39.95,Default,,0,0,0,,它太复杂了 没有必要仔细阅读它
Dialogue: 0,0:50:41.92,0:50:43.61,Default,,0,0,0,,我只想让大家感受一下它的轮廓
Dialogue: 0,0:50:44.44,0:50:50.01,Default,,0,0,0,,也就是这个程序里面有很多子程序
Dialogue: 0,0:50:52.11,0:50:57.56,Default,,0,0,0,,这部分用于遍历表达式
Dialogue: 0,0:50:58.97,0:51:01.36,Default,,0,0,0,,这部分用于尝试规则
Dialogue: 0,0:51:02.52,0:51:05.60,Default,,0,0,0,,当然 我们也可以看看细节
Dialogue: 0,0:51:06.89,0:51:11.80,Default,,0,0,0,,来看第一张幻灯片
Dialogue: 0,0:51:13.40,0:51:17.36,Default,,0,0,0,,化简器由数个部分组成
Dialogue: 0,0:51:17.96,0:51:22.92,Default,,0,0,0,,回想一下 化简器接收一系列的规则
Dialogue: 0,0:51:23.92,0:51:27.20,Default,,0,0,0,,并生成一个使用该规则进行化简的程序
Dialogue: 0,0:51:30.04,0:51:32.60,Default,,0,0,0,,化简器在这里定义
Dialogue: 0,0:51:33.48,0:51:34.81,Default,,0,0,0,,接受一个规则集合
Dialogue: 0,0:51:36.16,0:51:38.68,Default,,0,0,0,,在the-rules被定义的上下文中
Dialogue: 0,0:51:39.24,0:51:41.48,Default,,0,0,0,,还定义了很多其它东西
Dialogue: 0,0:51:42.33,0:51:46.20,Default,,0,0,0,,而simplifier过程的返回结果则是
Dialogue: 0,0:51:46.41,0:51:50.80,Default,,0,0,0,,是一个已经定义好的过程 -- simplify-exp
Dialogue: 0,0:51:52.46,0:51:57.71,Default,,0,0,0,,调用 (simplifier the-rules) 的返回值是
Dialogue: 0,0:51:58.17,0:52:03.21,Default,,0,0,0,,返回值是一个过程 是在该上下文中定义的simplify-exp过程
Dialogue: 0,0:52:05.23,0:52:08.83,Default,,0,0,0,,这是一个利用这些给定规则进行化简的过程
Dialogue: 0,0:52:15.04,0:52:15.96,Default,,0,0,0,,定义就是这样的
Dialogue: 0,0:52:17.45,0:52:21.79,Default,,0,0,0,,这些过程的前两个 这个和这个
Dialogue: 0,0:52:22.48,0:52:25.74,Default,,0,0,0,,它们一起 递归地遍历一个表达式
Dialogue: 0,0:52:26.97,0:52:30.20,Default,,0,0,0,,这个是任何表达式的通用化简方法
Dialogue: 0,0:52:30.94,0:52:33.23,Default,,0,0,0,,而这个过程用于化简表达式的子部分
Dialogue: 0,0:52:35.53,0:52:36.08,Default,,0,0,0,,没别的了
Dialogue: 0,0:52:37.04,0:52:39.90,Default,,0,0,0,,每个过程中 我们会做些复杂操作 包括尝试这些规则
Dialogue: 0,0:52:40.32,0:52:41.71,Default,,0,0,0,,现在 我们看看这些过程
Dialogue: 0,0:52:45.76,0:52:48.08,Default,,0,0,0,,我们先来讨论一下表达式的递归遍历
Dialogue: 0,0:52:48.57,0:52:51.68,Default,,0,0,0,,这是用一种很简单的方法完成的
Dialogue: 0,0:52:54.28,0:52:57.93,Default,,0,0,0,,这是一个小型的、嵌套的递归过程
Dialogue: 0,0:52:59.42,0:53:01.77,Default,,0,0,0,,这里有两个过程 ---
Dialogue: 0,0:53:02.59,0:53:05.20,Default,,0,0,0,,一个是对整个表达式化简
Dialogue: 0,0:53:06.11,0:53:08.16,Default,,0,0,0,,另一个是对表达式的某部分化简
Dialogue: 0,0:53:09.44,0:53:10.97,Default,,0,0,0,,它们的原理都很简单
Dialogue: 0,0:53:12.12,0:53:16.86,Default,,0,0,0,,如果我想要化简的表达式是复合表达式
Dialogue: 0,0:53:17.04,0:53:18.32,Default,,0,0,0,,那么就对每一个部分进行化简
Dialogue: 0,0:53:19.95,0:53:22.32,Default,,0,0,0,,调用simplify-parts这个过程
Dialogue: 0,0:53:22.33,0:53:25.74,Default,,0,0,0,,会构造一个新的表达式 其中各个部分都是化简过的
Dialogue: 0,0:53:26.00,0:53:28.64,Default,,0,0,0,,我会在这里尝试那些应用规则
Dialogue: 0,0:53:30.86,0:53:34.22,Default,,0,0,0,,如果表达式不是复合的 而是一些简单的表达式
Dialogue: 0,0:53:34.76,0:53:37.13,Default,,0,0,0,,比如说是符号 或者'pi
Dialogue: 0,0:53:38.16,0:53:39.79,Default,,0,0,0,,无论如何 我都需要尝试应用这些规则
Dialogue: 0,0:53:40.03,0:53:47.56,Default,,0,0,0,,因为 因为可能有将pi扩展成3.14159265358979....这样的规则
Dialogue: 0,0:53:48.46,0:53:49.08,Default,,0,0,0,,也许我不会这样做
Dialogue: 0,0:53:50.11,0:53:51.52,Default,,0,0,0,,但是没有理由不这样做
Dialogue: 0,0:53:52.75,0:53:57.53,Default,,0,0,0,,现在如果我对表达式的各部分化简 那就很简单了
Dialogue: 0,0:53:58.99,0:54:02.88,Default,,0,0,0,,要么表达式是空的 它没有更多的部分了
Dialogue: 0,0:54:03.71,0:54:05.08,Default,,0,0,0,,这种情况我返回一个空表达式
Dialogue: 0,0:54:05.72,0:54:10.52,Default,,0,0,0,,否则 我用cons构建一个新的表达式
Dialogue: 0,0:54:11.21,0:54:14.27,Default,,0,0,0,,新表达式的car部分是原表达式car的化简结果
Dialogue: 0,0:54:15.42,0:54:17.39,Default,,0,0,0,,然后化简表达式的其它其他部分作为新表达式的cdr部分
Dialogue: 0,0:54:21.08,0:54:23.88,Default,,0,0,0,,我用这种方式向大家展示这些的原因是
Dialogue: 0,0:54:24.88,0:54:30.12,Default,,0,0,0,,我想让大家感受到 这些不同模式在编程时非常重要
Dialogue: 0,0:54:32.20,0:54:34.00,Default,,0,0,0,,这段程序我可以换种写法
Dialogue: 0,0:54:34.00,0:54:36.99,Default,,0,0,0,,还有一种化简表达式的方法
Dialogue: 0,0:54:37.72,0:54:39.63,Default,,0,0,0,,这仅仅是一个小程序
Dialogue: 0,0:54:39.63,0:54:42.36,Default,,0,0,0,,我把它写到黑板上 让大家感受一下
Dialogue: 0,0:54:49.71,0:54:51.90,Default,,0,0,0,,你可以用这种惯用法来写程序
Dialogue: 0,0:54:59.30,0:55:03.13,Default,,0,0,0,,那么 如何化简表达式exp呢？
Dialogue: 0,0:55:03.21,0:55:10.14,Default,,0,0,0,,在以下几种情况下 调用try-rules
Dialogue: 0,0:55:11.12,0:55:15.72,Default,,0,0,0,,就像之前一样 如果表达式是复合的
Dialogue: 0,0:55:21.52,0:55:24.27,Default,,0,0,0,,如果是复合的 我要怎么做呢?
Dialogue: 0,0:55:24.53,0:55:25.40,Default,,0,0,0,,我要化简它的每个部分
Dialogue: 0,0:55:26.01,0:55:27.80,Default,,0,0,0,,但是我已经有对cdr部分递归的过程了
Dialogue: 0,0:55:30.25,0:55:33.18,Default,,0,0,0,,一个被封装成高阶过程的通用模式
Dialogue: 0,0:55:34.09,0:55:34.46,Default,,0,0,0,,也就是map过程
Dialogue: 0,0:55:36.08,0:55:36.88,Default,,0,0,0,,我在这里写出来
Dialogue: 0,0:55:37.16,0:55:48.03,Default,,0,0,0,,(map simplify-exp exp)
Dialogue: 0,0:55:49.00,0:55:54.59,Default,,0,0,0,,这是说 把simplify-exp这个过程应用在表达式的每个部分
Dialogue: 0,0:55:55.34,0:55:57.34,Default,,0,0,0,,然后把结果用cons组合成表
Dialogue: 0,0:56:00.92,0:56:04.38,Default,,0,0,0,,所以表中的每个元素都是化简过的
Dialogue: 0,0:56:05.45,0:56:08.23,Default,,0,0,0,,不是复合表达式的话 就不用化简了
Dialogue: 0,0:56:09.05,0:56:12.36,Default,,0,0,0,,所以不需要再写一个辅助函数来化简各个部分
Dialogue: 0,0:56:12.64,0:56:13.48,Default,,0,0,0,,这句代码就够了
Dialogue: 0,0:56:15.47,0:56:17.05,Default,,0,0,0,,所以有时候可以这样写
Dialogue: 0,0:56:17.84,0:56:18.70,Default,,0,0,0,,这个无关紧要
Dialogue: 0,0:56:21.16,0:56:26.27,Default,,0,0,0,,好现在看一下 -- 如何尝试规则
Dialogue: 0,0:56:27.70,0:56:31.60,Default,,0,0,0,,这里 幻灯片上有一堆复杂的东西
Dialogue: 0,0:56:33.68,0:56:35.28,Default,,0,0,0,,我要尝试对一个表达式施用规则
Dialogue: 0,0:56:36.36,0:56:39.96,Default,,0,0,0,,我现在尝试的表达式是最初表达式的子表达式
Dialogue: 0,0:56:40.43,0:56:43.88,Default,,0,0,0,,这是因为我之前特意安排要求遍历所有子表达式
Dialogue: 0,0:56:46.11,0:56:51.90,Default,,0,0,0,,所以这里的exp 就是最初表达式的子表达式
Dialogue: 0,0:56:52.49,0:56:57.71,Default,,0,0,0,,这里我们定义一个scan的过程 它用来尝试每一个规则
Dialogue: 0,0:56:58.72,0:57:00.33,Default,,0,0,0,,我们会在整个规则中扫描
Dialogue: 0,0:57:01.92,0:57:07.77,Default,,0,0,0,,它会通过不断取cdr部分来遍历整个规则 查找一条规则来施用
Dialogue: 0,0:57:09.37,0:57:11.96,Default,,0,0,0,,当找到一条规则 它的任务就完成了
Dialogue: 0,0:57:14.09,0:57:16.41,Default,,0,0,0,,我们来看一下try-rules是如何工作的
Dialogue: 0,0:57:17.74,0:57:21.02,Default,,0,0,0,,非常简单：就是顺序地扫描规则表
Dialogue: 0,0:57:21.96,0:57:23.26,Default,,0,0,0,,它 真的简单吗？
Dialogue: 0,0:57:23.26,0:57:24.51,Default,,0,0,0,,不 这是个很庞大的程序
Dialogue: 0,0:57:25.55,0:57:28.57,Default,,0,0,0,,接收的参数是一系列的规则--它们是整个规则表的子表
Dialogue: 0,0:57:30.75,0:57:35.13,Default,,0,0,0,,我们已经查找了其中的一些 但它们都不符合 所以试试剩下的
Dialogue: 0,0:57:35.87,0:57:36.30,Default,,0,0,0,,尝试下一条
Dialogue: 0,0:57:36.40,0:57:37.63,Default,,0,0,0,,如果所有规则都尝试完了
Dialogue: 0,0:57:37.90,0:57:40.84,Default,,0,0,0,,那么 我就不能再对这个表达式做什么了 它已经是最简了
Dialogue: 0,0:57:42.35,0:57:47.26,Default,,0,0,0,,然而 如果还有规则需要扫描
Dialogue: 0,0:57:48.01,0:57:51.58,Default,,0,0,0,,那么从一个空的词典开始
Dialogue: 0,0:57:52.20,0:57:55.40,Default,,0,0,0,,用规则表中的第一条规则对表达式进行模式匹配
Dialogue: 0,0:57:57.07,0:57:58.84,Default,,0,0,0,,将得到的结果作为新的词典
Dialogue: 0,0:58:00.32,0:58:03.74,Default,,0,0,0,,如果失败了 就尝试剩余规则
Dialogue: 0,0:58:06.68,0:58:07.52,Default,,0,0,0,,这句代码就是这个意思
Dialogue: 0,0:58:08.52,0:58:10.33,Default,,0,0,0,,也就是说 丢弃那条规则
Dialogue: 0,0:58:11.10,0:58:15.05,Default,,0,0,0,,成功的话 我将取出第一条规则对应的骨架
Dialogue: 0,0:58:15.34,0:58:17.40,Default,,0,0,0,,利用得到的词典 来将其实例化
Dialogue: 0,0:58:17.93,0:58:20.80,Default,,0,0,0,,然后对结果化简 就得到了我想要的表达式
Dialogue: 0,0:58:24.20,0:58:25.96,Default,,0,0,0,,虽然这是一个复杂的程序
Dialogue: 0,0:58:26.25,0:58:28.72,Default,,0,0,0,,但是每个复杂程序都是由许多简单部分组成的
Dialogue: 0,0:58:29.77,0:58:33.12,Default,,0,0,0,,这里的递归模式非常复杂
Dialogue: 0,0:58:34.78,0:58:36.52,Default,,0,0,0,,最重要的事情就是：不要去思考它
Dialogue: 0,0:58:38.67,0:58:41.80,Default,,0,0,0,,如果去思考它的实际行为
Dialogue: 0,0:58:42.06,0:58:42.97,Default,,0,0,0,,大家就会迷惑
Dialogue: 0,0:58:45.31,0:58:45.71,Default,,0,0,0,,就算是我也会
Dialogue: 0,0:58:47.04,0:58:50.17,Default,,0,0,0,,没关系 可以多加练习
Dialogue: 0,0:58:51.52,0:58:52.46,Default,,0,0,0,,这些模式非常难
Dialogue: 0,0:58:54.17,0:58:55.42,Default,,0,0,0,,但是大家不用考虑它
Dialogue: 0,0:58:55.83,0:58:59.72,Default,,0,0,0,,关键点就是 好的编程或设计方法需要
Dialogue: 0,0:58:59.74,0:59:00.97,Default,,0,0,0,,知道什么是不需要考虑的
Dialogue: 0,0:59:03.05,0:59:06.06,Default,,0,0,0,,回到这张幻灯片上
Dialogue: 0,0:59:06.92,0:59:08.01,Default,,0,0,0,,我不需要考虑它
Dialogue: 0,0:59:08.54,0:59:13.83,Default,,0,0,0,,是因为我规定了exp化简后的结果是什么样子
Dialogue: 0,0:59:14.00,0:59:15.24,Default,,0,0,0,,我不需要知道它是如何做的
Dialogue: 0,0:59:17.08,0:59:21.24,Default,,0,0,0,,它也许是像我们这里 又是scan 又是try-rule
Dialogue: 0,0:59:22.24,0:59:24.09,Default,,0,0,0,,又或者在这里调用另一个递归程序
Dialogue: 0,0:59:24.33,0:59:25.69,Default,,0,0,0,,根据“按愿望思维” 因为我知道simplify-exp
Dialogue: 0,0:59:26.84,0:59:30.40,Default,,0,0,0,,它会返回exp化简后的结果
Dialogue: 0,0:59:31.61,0:59:32.99,Default,,0,0,0,,那么我就不需要再考虑它的具体实现了
Dialogue: 0,0:59:33.43,0:59:34.83,Default,,0,0,0,,我直接使用它
Dialogue: 0,0:59:35.07,0:59:36.43,Default,,0,0,0,,我合情合理地使用它
Dialogue: 0,0:59:36.43,0:59:37.45,Default,,0,0,0,,就会得到正确的结果
Dialogue: 0,0:59:39.95,0:59:42.57,Default,,0,0,0,,我们必须学会这种程序设计方法 -- 学会放弃
Dialogue: 0,0:59:47.56,0:59:49.05,Default,,0,0,0,,这里还有一点剩余
Dialogue: 0,0:59:50.40,0:59:54.46,Default,,0,0,0,,这里还有一些词典方面的细节
Dialogue: 0,0:59:55.08,0:59:58.32,Default,,0,0,0,,你们想知道到底词典是什么
Dialogue: 0,0:59:58.70,1:00:01.82,Default,,0,0,0,,但是我会跳过它 无可奉告
Dialogue: 0,1:00:04.14,1:00:05.20,Default,,0,0,0,,词典很简单
Dialogue: 0,1:00:06.01,1:00:09.84,Default,,0,0,0,,它是用一种被称为关联表的东西来表示的
Dialogue: 0,1:00:10.65,1:00:16.04,Default,,0,0,0,,这是一种特殊使用模式 用来在线性表中存放二维表
Dialogue: 0,1:00:16.50,1:00:20.17,Default,,0,0,0,,它们很简单 由序对构成 之前已经有同学问过了
Dialogue: 0,1:00:21.21,1:00:24.62,Default,,0,0,0,,有个特殊的过程叫做assq 用来处理这些东西
Dialogue: 0,1:00:24.94,1:00:26.36,Default,,0,0,0,,手册里面有
Dialogue: 0,1:00:27.04,1:00:28.59,Default,,0,0,0,,这个都无关紧要
Dialogue: 0,1:00:28.83,1:00:31.21,Default,,0,0,0,,重要的是如何扩充词典
Dialogue: 0,1:00:31.48,1:00:36.94,Default,,0,0,0,,要用一个模式、模式对应的数据、一本旧词典来扩充
Dialogue: 0,1:00:37.42,1:00:42.38,Default,,0,0,0,,这个模式pat 实际上是一个模式变量
Dialogue: 0,1:00:43.74,1:00:47.53,Default,,0,0,0,,我要做什么呢？我先从模式中取出模式变量的名字
Dialogue: 0,1:00:48.16,1:00:49.42,Default,,0,0,0,,把它赋给变量name
Dialogue: 0,1:00:50.44,1:00:53.71,Default,,0,0,0,,然后我按照这个名字在词典中查找是否有对应的值
Dialogue: 0,1:00:53.79,1:00:56.41,Default,,0,0,0,,如果没有 就将这对新的模式-值加入到词典中
Dialogue: 0,1:00:56.92,1:00:59.23,Default,,0,0,0,,如果已经存在一个这样名字的词条 并且有值
Dialogue: 0,1:00:59.60,1:01:03.18,Default,,0,0,0,,那dat的值最好跟已经存储的值相等
Dialogue: 0,1:01:03.88,1:01:06.54,Default,,0,0,0,,这是我心目中期待的情况
Dialogue: 0,1:01:06.89,1:01:09.15,Default,,0,0,0,,否则 置失败
Dialogue: 0,1:01:12.08,1:01:12.89,Default,,0,0,0,,所以它也很简单
Dialogue: 0,1:01:13.66,1:01:16.68,Default,,0,0,0,,打开任何一个程序 你会发现它们都是由数个个小部分组成
Dialogue: 0,1:01:17.18,1:01:18.30,Default,,0,0,0,,许多简单的小部分
Dialogue: 0,1:01:20.04,1:01:21.29,Default,,0,0,0,,我想 到目前为止
Dialogue: 0,1:01:21.60,1:01:25.68,Default,,0,0,0,,我已经告诉给你们价值百万的信息了
Dialogue: 0,1:01:28.41,1:01:30.96,Default,,0,0,0,,我想这个程序几乎已经讲完了
Dialogue: 0,1:01:31.85,1:01:32.72,Default,,0,0,0,,有什么问题么？
Dialogue: 0,1:01:34.27,1:01:38.16,Default,,0,0,0,,学生：你描述一下 化简后的表达式的规范么？
Dialogue: 0,1:01:38.72,1:01:39.02,Default,,0,0,0,,教授：好的
Dialogue: 0,1:01:39.85,1:01:44.33,Default,,0,0,0,,simplify-exp接收一个表达式 返回一个化简后的表达式
Dialogue: 0,1:01:45.28,1:01:45.77,Default,,0,0,0,,就是这样了
Dialogue: 0,1:01:48.11,1:01:50.27,Default,,0,0,0,,它的工作方式很简单
Dialogue: 0,1:01:51.60,1:01:56.09,Default,,0,0,0,,对于复合表达式 先化简各部分后 再尝试化简整体
Dialogue: 0,1:01:56.89,1:01:58.49,Default,,0,0,0,,原子表达式 就直接代规则化简
Dialogue: 0,1:01:59.52,1:02:02.11,Default,,0,0,0,,学生：是这些规则把表达式化简了么?
Dialogue: 0,1:02:02.76,1:02:03.58,Default,,0,0,0,,教授：当然
Dialogue: 0,1:02:03.76,1:02:03.90,Default,,0,0,0,,学生：好
Dialogue: 0,1:02:04.06,1:02:07.13,Default,,0,0,0,,教授：它们像你在这里看到的一样化简表达式
Dialogue: 0,1:02:08.35,1:02:11.64,Default,,0,0,0,,它先把表达式划分为小块
Dialogue: 0,1:02:12.60,1:02:17.29,Default,,0,0,0,,在化简器中使用这些规则 自下而上化简并构造表达式
Dialogue: 0,1:02:18.30,1:02:22.48,Default,,0,0,0,,处理它们 构造一个新的表达式作为结果
Dialogue: 0,1:02:24.28,1:02:29.44,Default,,0,0,0,,最后再尝试调用这些规则化简
Dialogue: 0,1:02:29.70,1:02:35.50,Default,,0,0,0,,当匹配的结果发生变化时 -- 就调用simplify-exp化简它
Dialogue: 0,1:02:35.80,1:02:40.64,Default,,0,0,0,,哦 不对是 骨架的实例化结果发生改变时
Dialogue: 0,1:02:42.00,1:02:47.36,Default,,0,0,0,,所以 规范就是 任何传入的表达式通过这些规则生成化简后的表达式
Dialogue: 0,1:02:49.84,1:02:50.76,Default,,0,0,0,,谢谢大家 下课
Dialogue: 0,1:02:53.64,1:03:06.96,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:02:53.64,1:03:06.96,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
