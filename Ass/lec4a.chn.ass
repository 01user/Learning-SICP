[Script Info]
; Script generated by Aegisub 3.0.4
; http://www.aegisub.org/
Title: CHN Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
Collisions: Normal
Video Zoom Percent: 1
PlayResX: 640
PlayResY: 480
Scroll Position: 0
Active Line: 6
YCbCr Matrix: TV.601

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:06.19,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:06.45,0:00:14.22,title,,0,0,0,,{\fad(600,800)\pos(324,32)}计算机程序的构造和解释
Dialogue: 0,0:00:06.45,0:00:14.22,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}字幕&时间轴\N邓雄飞 & S.Michael
Dialogue: 0,0:00:06.45,0:00:14.22,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}后期&特效\N邓雄飞\N(Dysprosium)
Dialogue: 0,0:00:06.45,0:00:14.22,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N邓雄飞
Dialogue: 0,0:00:06.45,0:00:14.22,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:14.83,0:00:18.00,Declare,,0,0,0,,{\an2\fad(500,500)}模式匹配：基于规则的代换
Dialogue: 0,0:00:24.34,0:00:29.34,Default,,0,0,0,,教授：昨天 我们学习了一些符号操作
Dialogue: 0,0:00:29.92,0:00:35.12,Default,,0,0,0,,编写了一个非常典型的程序
Dialogue: 0,0:00:35.15,0:00:38.97,Default,,0,0,0,,来实现教材中的微积分规则
Dialogue: 0,0:00:39.61,0:00:44.59,Default,,0,0,0,,在这张幻灯片上
Dialogue: 0,0:00:44.96,0:00:48.81,Default,,0,0,0,,有一些从书中摘录的微积分规则
Dialogue: 0,0:00:49.47,0:00:54.62,Default,,0,0,0,,我们要把这些规则转化成计算机语言
Dialogue: 0,0:00:55.14,0:00:58.85,Default,,0,0,0,,当然 这种策略很有趣
Dialogue: 0,0:00:59.36,0:01:04.80,Default,,0,0,0,,但是我们为什么要把它们翻译成计算机语言呢？
Dialogue: 0,0:01:05.00,0:01:06.27,Default,,0,0,0,,我的意思是---
Dialogue: 0,0:01:06.62,0:01:11.02,Default,,0,0,0,,我们昨天写的程序非常典型
Dialogue: 0,0:01:11.21,0:01:15.98,Default,,0,0,0,,它是一个按表达式类型做分派的分情况分析语句
Dialogue: 0,0:01:16.38,0:01:18.48,Default,,0,0,0,,规则就是这样的
Dialogue: 0,0:01:19.68,0:01:21.55,Default,,0,0,0,,这里的规则是说:
Dialogue: 0,0:01:21.74,0:01:25.48,Default,,0,0,0,,我们考察的表达式如果是---
Dialogue: 0,0:01:25.48,0:01:29.42,Default,,0,0,0,,如果是常量 就做一些事情
Dialogue: 0,0:01:29.42,0:01:31.37,Default,,0,0,0,,如果是变量 就做另一件事情
Dialogue: 0,0:01:31.60,0:01:35.56,Default,,0,0,0,,如果它是常量乘以变量 就做另外的事 等等
Dialogue: 0,0:01:36.00,0:01:38.96,Default,,0,0,0,,这是一种按类型的分派
Dialogue: 0,0:01:41.40,0:01:45.16,Default,,0,0,0,,那么 既然它有如此典型的行为和结构
Dialogue: 0,0:01:45.95,0:01:49.53,Default,,0,0,0,,有没有其它方式把这个过程写得更加清晰？
Dialogue: 0,0:01:50.83,0:01:53.45,Default,,0,0,0,,首先要解决的是 这些规则是什么?
Dialogue: 0,0:01:55.56,0:01:58.50,Default,,0,0,0,,我们来好好想一下 规则有好几个部分
Dialogue: 0,0:01:58.94,0:02:02.35,Default,,0,0,0,,如果仔细观察这些规则
Dialogue: 0,0:02:03.71,0:02:04.99,Default,,0,0,0,,你就会发现
Dialogue: 0,0:02:05.12,0:02:09.69,Default,,0,0,0,,这些规则都有左右两部分
Dialogue: 0,0:02:10.36,0:02:14.36,Default,,0,0,0,,每一个规则都有左边部分和右边部分
Dialogue: 0,0:02:15.15,0:02:20.30,Default,,0,0,0,,左边部分用来与对被求导表达式做比较
Dialogue: 0,0:02:21.52,0:02:25.10,Default,,0,0,0,,右边部分用于替换原表达式
Dialogue: 0,0:02:28.49,0:02:33.10,Default,,0,0,0,,这张纸上的所有规则都可以描述成这样——
Dialogue: 0,0:02:36.51,0:02:38.06,Default,,0,0,0,,我们有许多模式
Dialogue: 0,0:02:41.48,0:02:48.30,Default,,0,0,0,,有时候 给定一个模式 我们需要为其生成一个骨架
Dialogue: 0,0:02:51.88,0:02:52.81,Default,,0,0,0,,这就是一个规则
Dialogue: 0,0:02:55.42,0:02:57.13,Default,,0,0,0,,模式是用于匹配的部分
Dialogue: 0,0:02:57.88,0:03:03.26,Default,,0,0,0,,将成功匹配的值代换到骨架里 就得到一个新的表达式
Dialogue: 0,0:03:06.46,0:03:16.32,Default,,0,0,0,,我的意思是：模式是用来匹配原表达式的
Dialogue: 0,0:03:23.72,0:03:28.51,Default,,0,0,0,,应用规则会产生一个新的表达式
Dialogue: 0,0:03:33.61,0:03:34.91,Default,,0,0,0,,我们称之为目标
Dialogue: 0,0:03:38.12,0:03:39.88,Default,,0,0,0,,这是通过骨架的实例化实现的
Dialogue: 0,0:03:41.63,0:03:43.02,Default,,0,0,0,,这个叫做实例化
Dialogue: 0,0:03:50.72,0:03:54.73,Default,,0,0,0,,这就是这些规则所描述的过程
Dialogue: 0,0:03:55.69,0:03:57.26,Default,,0,0,0,,今天我想要做的是
Dialogue: 0,0:03:58.73,0:04:01.08,Default,,0,0,0,,构建一种语言
Dialogue: 0,0:04:02.20,0:04:05.48,Default,,0,0,0,,以及它的解释与执行方法
Dialogue: 0,0:04:05.74,0:04:08.43,Default,,0,0,0,,使得这种语言可以直接表述这些规则
Dialogue: 0,0:04:10.59,0:04:11.58,Default,,0,0,0,,我们将要做的是
Dialogue: 0,0:04:11.58,0:04:17.56,Default,,0,0,0,,与其通过将规则翻译为程序 让计算机理解并执行
Dialogue: 0,0:04:18.38,0:04:21.56,Default,,0,0,0,,这里主要指 Lisp 程序
Dialogue: 0,0:04:22.16,0:04:24.49,Default,,0,0,0,,我们不如让计算机理解我们
Dialogue: 0,0:04:25.48,0:04:29.15,Default,,0,0,0,,我们可以写一些程序让计算机理解这些规则
Dialogue: 0,0:04:30.91,0:04:34.76,Default,,0,0,0,,这又稍微强调了上次的主旨
Dialogue: 0,0:04:35.44,0:04:39.36,Default,,0,0,0,,与其解决一个特定问题 不如解决一类问题
Dialogue: 0,0:04:39.77,0:04:46.72,Default,,0,0,0,,如果我为不同的数学运算写规则
Dialogue: 0,0:04:48.24,0:04:51.39,Default,,0,0,0,,比如简单代数的化简
Dialogue: 0,0:04:51.98,0:04:55.48,Default,,0,0,0,,或者三角函数运算
Dialogue: 0,0:04:56.09,0:05:01.16,Default,,0,0,0,,如果按照昨天的方法 我就得重新写个不同的程序
Dialogue: 0,0:05:01.16,0:05:05.42,Default,,0,0,0,,与之相反 我把程序中的共有逻辑给封装起来
Dialogue: 0,0:05:06.12,0:05:10.17,Default,,0,0,0,,也就是匹配、实例化等概念 还有控制结构
Dialogue: 0,0:05:10.17,0:05:12.46,Default,,0,0,0,,这都是非常复杂的事情
Dialogue: 0,0:05:13.16,0:05:18.46,Default,,0,0,0,,我想把它们从规则中分开 并封装
Dialogue: 0,0:05:20.06,0:05:22.60,Default,,0,0,0,,首先让我们看一下表示法
Dialogue: 0,0:05:22.62,0:05:24.09,Default,,0,0,0,,请大家看投影仪上的幻灯片
Dialogue: 0,0:05:24.67,0:05:25.60,Default,,0,0,0,,已经在这里了
Dialogue: 0,0:05:26.25,0:05:32.27,Default,,0,0,0,,我想要把求导的计算规则
Dialogue: 0,0:05:33.71,0:05:37.15,Default,,0,0,0,,表示为我这里写的一种简单语言
Dialogue: 0,0:05:38.11,0:05:43.29,Default,,0,0,0,,我会尽量避免去考虑语法
Dialogue: 0,0:05:44.28,0:05:49.28,Default,,0,0,0,,美化它很容易 虽然这个确实挺丑 但我并不关心
Dialogue: 0,0:05:49.30,0:05:56.41,Default,,0,0,0,,这确实不能像dx/dt那样表示
Dialogue: 0,0:05:56.76,0:05:58.12,Default,,0,0,0,,但这并不重要
Dialogue: 0,0:05:58.88,0:06:00.62,Default,,0,0,0,,这是一个偶然现象
Dialogue: 0,0:06:01.00,0:06:04.44,Default,,0,0,0,,这里 我只关心规则的结构
Dialogue: 0,0:06:04.83,0:06:11.70,Default,,0,0,0,,规则的左边部分代表了我想要匹配的求导表达式
Dialogue: 0,0:06:11.80,0:06:13.56,Default,,0,0,0,,这个表示是说
Dialogue: 0,0:06:13.60,0:06:18.32,Default,,0,0,0,,一个匹配常量的模式变量c
Dialogue: 0,0:06:18.84,0:06:21.20,Default,,0,0,0,,关于匹配任意表达式的模式变量v求导
Dialogue: 0,0:06:23.08,0:06:25.55,Default,,0,0,0,,我们在右边部分得到的是0
Dialogue: 0,0:06:26.00,0:06:28.06,Default,,0,0,0,,这就代表了一个规则
Dialogue: 0,0:06:29.26,0:06:34.04,Default,,0,0,0,,下一条规则是 匹配变量的模式变量v
Dialogue: 0,0:06:34.22,0:06:37.74,Default,,0,0,0,,对同一个模式变量求导 得到的结果是1
Dialogue: 0,0:06:38.60,0:06:42.17,Default,,0,0,0,,然而 如果一个匹配变量的模式变量u
Dialogue: 0,0:06:42.41,0:06:44.84,Default,,0,0,0,,关于另一个模式变量v求导
Dialogue: 0,0:06:45.39,0:06:47.05,Default,,0,0,0,,那么 结果就是0
Dialogue: 0,0:06:47.84,0:06:52.17,Default,,0,0,0,,我想让大家看一下 这些规则是如何组织在一起的
Dialogue: 0,0:06:52.51,0:06:54.30,Default,,0,0,0,,比如说 在这里
Dialogue: 0,0:06:54.73,0:07:01.90,Default,,0,0,0,,我们要求表达式x1、x2之和的导数
Dialogue: 0,0:07:01.90,0:07:05.85,Default,,0,0,0,,在我们创造的这个语言中
Dialogue: 0,0:07:06.88,0:07:08.62,Default,,0,0,0,,以问号开头的叫模式变量
Dialogue: 0,0:07:08.93,0:07:14.93,Default,,0,0,0,,我们就像这样来构建这些用来匹配的模式变量
Dialogue: 0,0:07:14.93,0:07:20.33,Default,,0,0,0,,这里 表达式x1加上表达式x2
Dialogue: 0,0:07:20.33,0:07:26.70,Default,,0,0,0,,对变量v求导的结果等于右边这里的式子
Dialogue: 0,0:07:26.70,0:07:32.76,Default,,0,0,0,,右边的式子是一个骨架 表示表达式X1关于变量v求导
Dialogue: 0,0:07:33.82,0:07:37.10,Default,,0,0,0,,加上表达式X2对变量v求导的和
Dialogue: 0,0:07:37.60,0:07:42.38,Default,,0,0,0,,这里的冒号表示要代换的对象
Dialogue: 0,0:07:43.63,0:07:47.23,Default,,0,0,0,,我们将它们称作“骨架求值”
Dialogue: 0,0:07:48.51,0:07:53.07,Default,,0,0,0,,让我在黑板上写一些语法
Dialogue: 0,0:07:53.23,0:07:55.56,Default,,0,0,0,,这样就能知道 在我们这门规则语言中会发生什么
Dialogue: 0,0:07:56.68,0:07:59.88,Default,,0,0,0,,首先我们要处理模式匹配问题
Dialogue: 0,0:08:06.04,0:08:13.12,Default,,0,0,0,,第一条规则是 形如foo这样的符号与其自身匹配
Dialogue: 0,0:08:23.52,0:08:31.34,Default,,0,0,0,,形如(f a b)的表达式 可以匹配这样的表
Dialogue: 0,0:08:36.30,0:08:57.02,Default,,0,0,0,,表的首元素是f、第二个元素是a、第三个元素是b
Dialogue: 0,0:08:58.62,0:09:06.99,Default,,0,0,0,,另外 模式中可能还有形如(? x)这样的规则
Dialogue: 0,0:09:08.57,0:09:18.67,Default,,0,0,0,,这个规则可以匹配任意表达式 并将其称为x
Dialogue: 0,0:09:25.45,0:09:29.98,Default,,0,0,0,,(?c x) 只匹配常量
Dialogue: 0,0:09:31.50,0:09:40.96,Default,,0,0,0,,并将匹配的常量记作x
Dialogue: 0,0:09:44.56,0:09:57.07,Default,,0,0,0,,(?v x)匹配变量 并将匹配的变量记作x
Dialogue: 0,0:10:01.66,0:10:03.80,Default,,0,0,0,,这就是我们正在构建的语言
Dialogue: 0,0:10:04.19,0:10:09.40,Default,,0,0,0,,两个对象的比较是基于元素与元素间的比较
Dialogue: 0,0:10:10.25,0:10:15.85,Default,,0,0,0,,模式中的元素可以包含这些语法变量、模式变量
Dialogue: 0,0:10:17.07,0:10:20.43,Default,,0,0,0,,它们可以用来匹配任意对象
Dialogue: 0,0:10:22.12,0:10:29.28,Default,,0,0,0,,这样 我就可以用x作为名字取得被匹配对象的值
Dialogue: 0,0:10:31.05,0:10:37.55,Default,,0,0,0,,现在 当我们为实例化准备骨架的时候
Dialogue: 0,0:10:39.50,0:10:41.40,Default,,0,0,0,,我们可能有这样的东西
Dialogue: 0,0:10:42.27,0:10:46.33,Default,,0,0,0,,符号foo实例化为它本身
Dialogue: 0,0:10:55.08,0:11:05.92,Default,,0,0,0,,形如(f a b)这样的表 实例化为
Dialogue: 0,0:11:06.36,0:11:14.75,Default,,0,0,0,,实例化为一个三元素表
Dialogue: 0,0:11:15.55,0:11:33.37,Default,,0,0,0,,其元素分别为f、a、b各自实例化后的结果
Dialogue: 0,0:11:36.35,0:11:54.27,Default,,0,0,0,,(: x) 会被实例化为x的值--也就是被匹配的模式
Dialogue: 0,0:12:03.05,0:12:10.08,Default,,0,0,0,,回头看看这里的幻灯片 我们发现这些都是对象
Dialogue: 0,0:12:10.78,0:12:16.06,Default,,0,0,0,,我们看到 这是一个用来匹配常量的模式变量
Dialogue: 0,0:12:16.56,0:12:19.02,Default,,0,0,0,,这是匹配变量的模式变量
Dialogue: 0,0:12:19.39,0:12:21.74,Default,,0,0,0,,这是匹配任意表达式的模式变量
Dialogue: 0,0:12:22.72,0:12:24.92,Default,,0,0,0,,如果我们有了名字一样的两个实例
Dialogue: 0,0:12:25.08,0:12:31.77,Default,,0,0,0,,想这个是被称作v的单变量表达式
Dialogue: 0,0:12:32.86,0:12:36.30,Default,,0,0,0,,关于一个称作v的任意表达式求导
Dialogue: 0,0:12:36.41,0:12:38.01,Default,,0,0,0,,因为这个v出现了两次
Dialogue: 0,0:12:38.65,0:12:41.07,Default,,0,0,0,,我们想约束它们相同
Dialogue: 0,0:12:42.68,0:12:45.00,Default,,0,0,0,,只有它俩完全一致才算是匹配
Dialogue: 0,0:12:45.23,0:12:47.23,Default,,0,0,0,,所以在这里我们在构建一个语言
Dialogue: 0,0:12:47.60,0:12:50.66,Default,,0,0,0,,事实上 这是一件非常好的事情
Dialogue: 0,0:12:50.66,0:12:52.60,Default,,0,0,0,,构建一个语言非常有趣
Dialogue: 0,0:12:52.60,0:12:54.33,Default,,0,0,0,,并且大家一直在做这些
Dialogue: 0,0:12:54.33,0:12:56.89,Default,,0,0,0,,大家做过的真正强大的设计
Dialogue: 0,0:12:57.23,0:13:00.20,Default,,0,0,0,,是构建一个语言来解决这样的问题
Dialogue: 0,0:13:02.06,0:13:05.34,Default,,0,0,0,,我们回头看看这些规则
Dialogue: 0,0:13:05.80,0:13:07.10,Default,,0,0,0,,这就是它们的全部
Dialogue: 0,0:13:07.10,0:13:12.43,Default,,0,0,0,,我们有加法、乘法 就像我们之前看到的一样
Dialogue: 0,0:13:12.43,0:13:17.37,Default,,0,0,0,,x1+x2 关于变量v的导数等于
Dialogue: 0,0:13:17.68,0:13:26.52,Default,,0,0,0,,x2对v求导乘以x1 加上 x1对v求导乘以x2
Dialogue: 0,0:13:27.26,0:13:29.10,Default,,0,0,0,,这是指数运算的求导规则
Dialogue: 0,0:13:29.24,0:13:32.11,Default,,0,0,0,,虽然这里展示完了所有的规则 但还可以按照我们意愿添加
Dialogue: 0,0:13:32.70,0:13:39.10,Default,,0,0,0,,我们在这里 建立了关于求导的规则列表
Dialogue: 0,0:13:40.40,0:13:44.33,Default,,0,0,0,,一旦我们有了这些 我们应该做什么呢？
Dialogue: 0,0:13:45.40,0:13:47.84,Default,,0,0,0,,恩 我将给你们展示最好的思想之一
Dialogue: 0,0:13:48.44,0:13:51.68,Default,,0,0,0,,然后我们将花一整天来鼓捣它
Dialogue: 0,0:13:52.28,0:13:57.37,Default,,0,0,0,,我将向大家展示一个叫做simplifier的程序
Dialogue: 0,0:13:57.82,0:13:59.47,Default,,0,0,0,,一个通用的化简器
Dialogue: 0,0:14:00.09,0:14:17.10,Default,,0,0,0,,我们将求导规则deriv-rules送入simplifier从而产生dsimp
Dialogue: 0,0:14:23.74,0:14:28.75,Default,,0,0,0,,传给simplifier过程一套规则 它会返回给我们一个过程
Dialogue: 0,0:14:29.32,0:14:34.59,Default,,0,0,0,,它根据这些规则对表达式进行化简
Dialogue: 0,0:14:37.39,0:14:43.93,Default,,0,0,0,,因此 这里会返回一个按照你制定的规则所构造的过程
Dialogue: 0,0:14:44.59,0:14:49.56,Default,,0,0,0,,使得在我们进入 Lisp 系统后 在命令提示符后面
Dialogue: 0,0:14:49.88,0:15:03.93,Default,,0,0,0,,输入 (DSIMP '(dd (+ x y) x))
Dialogue: 0,0:15:06.99,0:15:10.97,Default,,0,0,0,,注意这里的引号 因为我们讨论的是表达式的求导
Dialogue: 0,0:15:13.29,0:15:17.76,Default,,0,0,0,,然后我将得到结果 (+ 1 0)
Dialogue: 0,0:15:19.96,0:15:24.60,Default,,0,0,0,,因为 (x+y)' = x' + y'
Dialogue: 0,0:15:24.60,0:15:26.22,Default,,0,0,0,,x'=1
Dialogue: 0,0:15:26.38,0:15:27.82,Default,,0,0,0,,y'=0（关于x求导）
Dialogue: 0,0:15:29.42,0:15:30.46,Default,,0,0,0,,这不是我想要的
Dialogue: 0,0:15:31.18,0:15:34.65,Default,,0,0,0,,我还没有在这里做代数化简
Dialogue: 0,0:15:36.16,0:15:41.53,Default,,0,0,0,,当然一旦我有了这个东西那么我们可以 -- 我们可以看看其它的规则
Dialogue: 0,0:15:41.96,0:15:49.36,Default,,0,0,0,,比如 我们看这张幻灯片
Dialogue: 0,0:15:49.36,0:15:54.12,Default,,0,0,0,,这里是其它的规则 代数操作规则
Dialogue: 0,0:15:56.00,0:15:58.38,Default,,0,0,0,,它们可以用来化简代数表达式
Dialogue: 0,0:15:59.00,0:16:02.06,Default,,0,0,0,,考察一下这些规则
Dialogue: 0,0:16:03.04,0:16:09.20,Default,,0,0,0,,这条规则的左部分是说 某个运算符应用到常量e1和常量e2上
Dialogue: 0,0:16:09.32,0:16:14.51,Default,,0,0,0,,其结果就是求(op e1 e2)的值
Dialogue: 0,0:16:15.88,0:16:21.56,Default,,0,0,0,,或者 当一个运算符应用在任意表达式e1和常量e2上
Dialogue: 0,0:16:21.69,0:16:23.87,Default,,0,0,0,,化简结果会把常量前置
Dialogue: 0,0:16:24.52,0:16:27.68,Default,,0,0,0,,这就变成了((: op) (: e2) (: e1))
Dialogue: 0,0:16:28.59,0:16:30.11,Default,,0,0,0,,为什么要这么做？我不知道
Dialogue: 0,0:16:30.22,0:16:33.16,Default,,0,0,0,,比如说 如果系统中有除法的话 这就不对
Dialogue: 0,0:16:33.53,0:16:35.31,Default,,0,0,0,,换句话说 规则有漏洞
Dialogue: 0,0:16:36.67,0:16:40.86,Default,,0,0,0,,所以0与任何表达式e的和 等于表达式e
Dialogue: 0,0:16:42.17,0:16:45.31,Default,,0,0,0,,1乘以任何表达式e的结果是表达式e
Dialogue: 0,0:16:46.12,0:16:49.13,Default,,0,0,0,,0乘以任何表达式e的结果是0
Dialogue: 0,0:16:49.33,0:16:52.72,Default,,0,0,0,,我们可以有任意复杂的规则
Dialogue: 0,0:16:53.69,0:16:54.81,Default,,0,0,0,,比如说
Dialogue: 0,0:16:55.36,0:17:01.69,Default,,0,0,0,,常量e1*(常量e2*任意表达式e3)
Dialogue: 0,0:17:02.35,0:17:11.96,Default,,0,0,0,,可以化简为 (e1*e2)*e3
Dialogue: 0,0:17:13.36,0:17:16.76,Default,,0,0,0,,这个规则是说 先把常量组合起来
Dialogue: 0,0:17:16.76,0:17:22.70,Default,,0,0,0,,如果有形如 e1*(e2*e3) 的式子 而且e1 e2都是常量 就先把常量乘起来
Dialogue: 0,0:17:23.84,0:17:25.48,Default,,0,0,0,,你可以根据意愿来构建这些规则
Dialogue: 0,0:17:25.79,0:17:26.94,Default,,0,0,0,,这里还有很多规则
Dialogue: 0,0:17:27.42,0:17:31.04,Default,,0,0,0,,这些规则是很复杂的 比如--
Dialogue: 0,0:17:31.26,0:17:33.93,Default,,0,0,0,,请看 这条规则是分配律
Dialogue: 0,0:17:33.93,0:17:38.57,Default,,0,0,0,,任何表达式c乘以d和e
Dialogue: 0,0:17:39.02,0:17:43.66,Default,,0,0,0,,等于 c与d的积加上c与e的积
Dialogue: 0,0:17:45.31,0:17:48.67,Default,,0,0,0,,我并不关心这些规则具体描述的什么
Dialogue: 0,0:17:49.16,0:17:52.97,Default,,0,0,0,,我们将要构建一种语言 用来解释这些规则
Dialogue: 0,0:17:55.50,0:17:57.48,Default,,0,0,0,,这样我们就可以按我们的意愿编写规则
Dialogue: 0,0:17:58.35,0:18:00.14,Default,,0,0,0,,这是另外一种程序设计语言
Dialogue: 0,0:18:03.39,0:18:04.04,Default,,0,0,0,,来看看
Dialogue: 0,0:18:05.18,0:18:06.96,Default,,0,0,0,,我还没告诉你我们要怎么做
Dialogue: 0,0:18:07.53,0:18:10.06,Default,,0,0,0,,当然我们马上就要讲了
Dialogue: 0,0:18:10.89,0:18:15.40,Default,,0,0,0,,但真正的问题是：宏观地看 我要做什么？
Dialogue: 0,0:18:17.08,0:18:18.22,Default,,0,0,0,,这些规则是如何运作的？
Dialogue: 0,0:18:19.00,0:18:25.45,Default,,0,0,0,,化简程序是如何用这些规则来输入的表达式 并返回一个合理的答案？
Dialogue: 0,0:18:26.22,0:18:29.85,Default,,0,0,0,,首先 我认为我们有一大堆的规则
Dialogue: 0,0:18:32.52,0:18:34.22,Default,,0,0,0,,这里有全部的规则
Dialogue: 0,0:18:42.09,0:18:44.49,Default,,0,0,0,,这里的每一个规则 ---
Dialogue: 0,0:18:46.97,0:18:49.24,Default,,0,0,0,,都有一个模式和一个骨架
Dialogue: 0,0:18:49.72,0:18:51.36,Default,,0,0,0,,我正在努力为它作一个控制结构
Dialogue: 0,0:18:53.37,0:18:56.56,Default,,0,0,0,,我有一个匹配器
Dialogue: 0,0:19:00.99,0:19:03.76,Default,,0,0,0,,还有一个实例化器
Dialogue: 0,0:19:09.66,0:19:12.94,Default,,0,0,0,,我将把一系列模式变量的值
Dialogue: 0,0:19:14.03,0:19:17.47,Default,,0,0,0,,从匹配器中传递到实例化器中
Dialogue: 0,0:19:18.06,0:19:19.42,Default,,0,0,0,,我把传递的东西叫做词典
Dialogue: 0,0:19:20.59,0:19:21.52,Default,,0,0,0,,传递一本词典
Dialogue: 0,0:19:24.92,0:19:27.82,Default,,0,0,0,,里面记载了：x匹配下列子表达式
Dialogue: 0,0:19:29.04,0:19:31.31,Default,,0,0,0,,而y匹配另一个子表达式
Dialogue: 0,0:19:32.25,0:19:36.35,Default,,0,0,0,,我会从实例化器中构造表达式 并送入匹配器
Dialogue: 0,0:19:37.16,0:19:38.36,Default,,0,0,0,,这些是表达式
Dialogue: 0,0:19:45.00,0:19:48.41,Default,,0,0,0,,这些规则的模式将要送进匹配器中
Dialogue: 0,0:19:49.24,0:19:54.40,Default,,0,0,0,,规则对应的骨架将要送进实例化器中
Dialogue: 0,0:19:55.21,0:19:56.62,Default,,0,0,0,,现在变得有点复杂了
Dialogue: 0,0:19:57.12,0:19:59.53,Default,,0,0,0,,因为当我们处理代数表达式时
Dialogue: 0,0:20:00.44,0:20:03.60,Default,,0,0,0,,有一些规则使你能够做等价代换
Dialogue: 0,0:20:04.24,0:20:05.87,Default,,0,0,0,,这些是等价代换规则
Dialogue: 0,0:20:06.88,0:20:09.29,Default,,0,0,0,,所以需要考察表达式的所有子表达式
Dialogue: 0,0:20:11.13,0:20:15.82,Default,,0,0,0,,给定一个表达式 这些规则应该被不断应用
Dialogue: 0,0:20:16.03,0:20:19.71,Default,,0,0,0,,首先 对于传入的表达式的每个子表达式
Dialogue: 0,0:20:20.22,0:20:22.83,Default,,0,0,0,,所有的规则都需要考察一次
Dialogue: 0,0:20:24.33,0:20:27.07,Default,,0,0,0,,如果有规则匹配成功 那么就会执行这个过程
Dialogue: 0,0:20:27.30,0:20:30.63,Default,,0,0,0,,传递一本存储值的词典
Dialogue: 0,0:20:30.63,0:20:33.39,Default,,0,0,0,,实例化器产生一个新的表达式
Dialogue: 0,0:20:33.90,0:20:39.10,Default,,0,0,0,,该表达式基本上只是替换了原表达式中匹配的部分
Dialogue: 0,0:20:40.84,0:20:44.46,Default,,0,0,0,,然后 我们要对它重新检查
Dialogue: 0,0:20:44.75,0:20:48.11,Default,,0,0,0,,重新考察这些规则 看看表达式是否可以更进一步化简
Dialogue: 0,0:20:49.53,0:20:53.71,Default,,0,0,0,,然后每一个子表达式这样做 直到没有任何变化为止
Dialogue: 0,0:20:54.96,0:20:57.50,Default,,0,0,0,,你可以把它想像成一个有机过程
Dialogue: 0,0:20:57.83,0:21:00.20,Default,,0,0,0,,我们有一锅炖汤
Dialogue: 0,0:21:00.24,0:21:04.32,Default,,0,0,0,,粘乎乎的汤里面有细菌 有酶
Dialogue: 0,0:21:05.63,0:21:10.50,Default,,0,0,0,,这些酶改变了汤
Dialogue: 0,0:21:10.50,0:21:14.38,Default,,0,0,0,,它们附着在你的表达式上 改变了它 然后就走了
Dialogue: 0,0:21:15.28,0:21:17.83,Default,,0,0,0,,就像钥匙和锁一样 它们需要配对
Dialogue: 0,0:21:18.00,0:21:19.73,Default,,0,0,0,,匹配 -- 改变 -- 然后离开
Dialogue: 0,0:21:19.73,0:21:21.68,Default,,0,0,0,,你可以将其想像成一种并行过程
Dialogue: 0,0:21:22.70,0:21:24.97,Default,,0,0,0,,所以你把一个表达式放到这锅“浓汤”中
Dialogue: 0,0:21:25.80,0:21:28.00,Default,,0,0,0,,过了会儿把它拿出来 它就被简化了
Dialogue: 0,0:21:30.44,0:21:32.64,Default,,0,0,0,,它会一直变化 直到不能再变化为止
Dialogue: 0,0:21:33.36,0:21:38.33,Default,,0,0,0,,但这些酶可以附着在表达式的任何部分
Dialogue: 0,0:21:39.21,0:21:43.76,Default,,0,0,0,,课先上到这里 有问题么？
Dialogue: 0,0:21:44.92,0:21:45.36,Default,,0,0,0,,请讲
Dialogue: 0,0:21:45.43,0:21:52.76,Default,,0,0,0,,学生：匹配器和实例化器是两个独立的程序 是么?
Dialogue: 0,0:21:52.76,0:21:53.85,Default,,0,0,0,,教授：他们被拆分成很多小片
Dialogue: 0,0:21:54.14,0:21:56.60,Default,,0,0,0,,然后在一个更大的结构中组合起来
Dialogue: 0,0:21:57.26,0:21:59.13,Default,,0,0,0,,学生：先扫描并匹配
Dialogue: 0,0:21:59.61,0:22:03.21,Default,,0,0,0,,并把匹配结果传递给实例化器
Dialogue: 0,0:22:03.39,0:22:06.03,Default,,0,0,0,,实例化器做出更改 并将其返回给匹配器
Dialogue: 0,0:22:06.11,0:22:08.49,Default,,0,0,0,,教授：不是直接更改 而是生成新的表达式
Dialogue: 0,0:22:09.61,0:22:18.43,Default,,0,0,0,,新表达式中的模式变量都被左边式子中所匹配的值所替换
Dialogue: 0,0:22:18.99,0:22:23.80,Default,,0,0,0,,也就是右边式子中的那些骨架变量 或者说求值变量
Dialogue: 0,0:22:25.20,0:22:27.08,Default,,0,0,0,,学生：然后它要回传给匹配器么?
Dialogue: 0,0:22:27.20,0:22:32.32,Default,,0,0,0,,教授：然后要再进行一轮 直到表达式不再变化
Dialogue: 0,0:22:33.31,0:22:37.00,Default,,0,0,0,,学生：感觉这样递归循环似乎有些危险
Dialogue: 0,0:22:37.20,0:22:42.00,Default,,0,0,0,,教授：你说得很对 如果你定义的规则不好--
Dialogue: 0,0:22:42.00,0:22:45.53,Default,,0,0,0,,你发明的任何语言 如果它可以做任何事情
Dialogue: 0,0:22:45.72,0:22:48.40,Default,,0,0,0,,你就可能写出无限循环的程序
Dialogue: 0,0:22:49.37,0:22:55.07,Default,,0,0,0,,确实 诸如代数处理 这样的过程可能会产生无限循环
Dialogue: 0,0:23:01.05,0:23:01.52,Default,,0,0,0,,教授：请讲
Dialogue: 0,0:23:01.79,0:23:05.90,Default,,0,0,0,,学生：一些语言的设计者觉得这个特性非常重要
Dialogue: 0,0:23:05.93,0:23:12.03,Default,,0,0,0,,以至于它应该是语言的一部分 比如Scheme
Dialogue: 0,0:23:12.03,0:23:13.96,Default,,0,0,0,,你的观点是--
Dialogue: 0,0:23:13.96,0:23:15.08,Default,,0,0,0,,老师：语言的什么特性?
Dialogue: 0,0:23:15.79,0:23:17.26,Default,,0,0,0,,学生：模式匹配
Dialogue: 0,0:23:17.26,0:23:22.03,Default,,0,0,0,,所有应用的这些规则应该 ---
Dialogue: 0,0:23:22.03,0:23:23.70,Default,,0,0,0,,教授：你是说像 Prolog 那样？
Dialogue: 0,0:23:23.70,0:23:26.60,Default,,0,0,0,,学生：类似 Prolog 但更加通用的--
Dialogue: 0,0:23:26.60,0:23:27.64,Default,,0,0,0,,教授：这是可行的
Dialogue: 0,0:23:28.46,0:23:32.30,Default,,0,0,0,,好了 我是觉得吧…… 恩……
Dialogue: 0,0:23:33.16,0:23:36.49,Default,,0,0,0,,我可以教你怎么做 这样你就不用依靠语言的设计者
Dialogue: 0,0:23:40.92,0:23:42.75,Default,,0,0,0,,教授：我们可以自己来实现
Dialogue: 0,0:23:45.28,0:23:45.63,Default,,0,0,0,,下课
Dialogue: 0,0:23:45.63,0:23:50.63,Default,,0,0,0,,[音乐]
Dialogue: 0,0:23:50.63,0:23:53.13,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:23:53.13,0:23:55.63,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:24:00.32,0:24:06.76,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:24:07.07,0:24:10.52,Declare,,0,0,0,,{\an2\fad(500,500)}模式匹配：基于规则的代换
Dialogue: 0,0:24:14.08,0:24:15.80,Default,,0,0,0,,好 上课
Dialogue: 0,0:24:15.80,0:24:17.21,Default,,0,0,0,,现在 我得告诉你们它是如何运作的
Dialogue: 0,0:24:20.00,0:24:24.11,Default,,0,0,0,,它很容易分成很多小份
Dialogue: 0,0:24:24.80,0:24:26.54,Default,,0,0,0,,现在 我们先看一下匹配器
Dialogue: 0,0:24:28.72,0:24:31.42,Default,,0,0,0,,匹配器的结构是像下面这样的
Dialogue: 0,0:24:32.86,0:24:45.12,Default,,0,0,0,,它是一个盒子 它的输入是一个表达式和一个模式
Dialogue: 0,0:24:52.09,0:24:53.95,Default,,0,0,0,,还有个输入是一本词典
Dialogue: 0,0:25:01.71,0:25:08.67,Default,,0,0,0,,要记住 词典把模式变量映射到匹配的值上
Dialogue: 0,0:25:09.15,0:25:11.05,Default,,0,0,0,,它的输出是另一本词典
Dialogue: 0,0:25:18.24,0:25:25.53,Default,,0,0,0,,除了旧词典中已有的内容 新词典中还产生的新的匹配
Dialogue: 0,0:25:28.00,0:25:28.83,Default,,0,0,0,,这就是匹配器
Dialogue: 0,0:25:33.87,0:25:36.54,Default,,0,0,0,,这是一个相当复杂的程序
Dialogue: 0,0:25:37.20,0:25:41.58,Default,,0,0,0,,请大家看看这里的投影 请看
Dialogue: 0,0:25:41.98,0:25:43.87,Default,,0,0,0,,哈哈 真是相当复杂
Dialogue: 0,0:25:44.43,0:25:45.87,Default,,0,0,0,,我只想让大家看一下它的轮廓
Dialogue: 0,0:25:46.78,0:25:49.85,Default,,0,0,0,,其实现细节太复杂了
Dialogue: 0,0:25:51.72,0:25:59.24,Default,,0,0,0,,然而 这是一个庞大的程序 它有很多这样的缩进的结构
Dialogue: 0,0:26:00.09,0:26:05.28,Default,,0,0,0,,在最外层 -- 不要去读这些代码  宏观地看
Dialogue: 0,0:26:05.43,0:26:10.36,Default,,0,0,0,,这里有一个分情况分析 而这些就是不同的情况
Dialogue: 0,0:26:12.09,0:26:16.19,Default,,0,0,0,,现在 我们将要深入细节
Dialogue: 0,0:26:16.67,0:26:18.60,Default,,0,0,0,,试图理解它是如何工作的
Dialogue: 0,0:26:20.08,0:26:22.35,Default,,0,0,0,,我们来看第一张幻灯片
Dialogue: 0,0:26:23.55,0:26:27.93,Default,,0,0,0,,它展示了匹配器的宏观结构
Dialogue: 0,0:26:28.81,0:26:36.33,Default,,0,0,0,,我们看到匹配器 它需要的参数有：模式、表达式和词典
Dialogue: 0,0:26:38.57,0:26:40.40,Default,,0,0,0,,这里是一个cond语句
Dialogue: 0,0:26:41.24,0:26:45.61,Default,,0,0,0,,它有许多不同情况 我们省略了一些代码
Dialogue: 0,0:26:46.62,0:26:48.62,Default,,0,0,0,,这个是我想让大家注意的 通用情况
Dialogue: 0,0:26:50.52,0:26:53.28,Default,,0,0,0,,考虑这个通用模式 它是个非常重要的模式
Dialogue: 0,0:26:56.32,0:27:01.61,Default,,0,0,0,,问题是我们需要同时地检查这两棵树
Dialogue: 0,0:27:02.50,0:27:08.03,Default,,0,0,0,,一棵树是表达式 另一棵树是模式
Dialogue: 0,0:27:08.59,0:27:10.11,Default,,0,0,0,,我们需要在它们之间进行匹配
Dialogue: 0,0:27:11.37,0:27:16.38,Default,,0,0,0,,使得表达式的子表达式会与模式的子表达式相匹配
Dialogue: 0,0:27:18.38,0:27:23.44,Default,,0,0,0,,我们深入研究一下 假设我有一个模式
Dialogue: 0,0:27:23.93,0:27:31.24,Default,,0,0,0,,这个是模式是 一个叫做x的表达式 乘以
Dialogue: 0,0:27:32.44,0:27:35.53,Default,,0,0,0,,乘以一个我们叫做y的表达式
Dialogue: 0,0:27:39.12,0:27:42.04,Default,,0,0,0,,再加上 刚才的表达式y 两个y必须是相同的表达式
Dialogue: 0,0:27:45.21,0:27:47.53,Default,,0,0,0,,我们在考察 乘式的和
Dialogue: 0,0:27:48.99,0:27:54.78,Default,,0,0,0,,其中 乘法和加法的第二个参数都是相同的
Dialogue: 0,0:27:57.02,0:27:58.84,Default,,0,0,0,,这是我们想要匹配像这样的表达式
Dialogue: 0,0:27:59.60,0:28:02.04,Default,,0,0,0,,它作为一个模式看起来像这个样子
Dialogue: 0,0:28:03.02,0:28:04.01,Default,,0,0,0,,这是一课树
Dialogue: 0,0:28:04.94,0:28:06.25,Default,,0,0,0,,它包含了一个加号
Dialogue: 0,0:28:08.08,0:28:20.25,Default,,0,0,0,,还有乘号 以及模式变量(? x)和(? y)
Dialogue: 0,0:28:21.36,0:28:22.73,Default,,0,0,0,,还有模式变量(? y)
Dialogue: 0,0:28:24.92,0:28:26.94,Default,,0,0,0,,这只是把表结构换了种写法 两者其实是一样的
Dialogue: 0,0:28:28.75,0:28:31.76,Default,,0,0,0,,我们先演示一个成功的匹配是如何运行的
Dialogue: 0,0:28:32.49,0:28:39.85,Default,,0,0,0,,这个模式匹配表达式 (+ (* 3 x) x)
Dialogue: 0,0:28:42.41,0:28:43.36,Default,,0,0,0,,这是另一棵个树
Dialogue: 0,0:28:44.33,0:28:56.06,Default,,0,0,0,,它是3乘以x的积加上x
Dialogue: 0,0:28:59.44,0:29:03.02,Default,,0,0,0,,所以我要做的是 同时遍历这两棵树
Dialogue: 0,0:29:04.41,0:29:07.82,Default,,0,0,0,,我想这样遍历它们
Dialogue: 0,0:29:08.67,0:29:12.96,Default,,0,0,0,,我会比较它们是否一样
Dialogue: 0,0:29:12.96,0:29:14.32,Default,,0,0,0,,这是一个复合对象
Dialogue: 0,0:29:15.21,0:29:17.26,Default,,0,0,0,,我们先看它的左分支
Dialogue: 0,0:29:17.26,0:29:18.14,Default,,0,0,0,,这可能是car部分
Dialogue: 0,0:29:18.56,0:29:21.21,Default,,0,0,0,,它们匹配吗？恩 两个加号成功匹配
Dialogue: 0,0:29:21.68,0:29:24.20,Default,,0,0,0,,但是下一个对象是复合的
Dialogue: 0,0:29:24.20,0:29:24.84,Default,,0,0,0,,我们看一下它
Dialogue: 0,0:29:25.20,0:29:26.80,Default,,0,0,0,,这个也匹配了
Dialogue: 0,0:29:26.80,0:29:27.79,Default,,0,0,0,,它们都是星号
Dialogue: 0,0:29:28.51,0:29:30.24,Default,,0,0,0,,现在……哦！
Dialogue: 0,0:29:30.40,0:29:33.60,Default,,0,0,0,,这是模式变量 它和3相匹配
Dialogue: 0,0:29:34.27,0:29:35.92,Default,,0,0,0,,记住 现在x等于3
Dialogue: 0,0:29:36.36,0:29:37.37,Default,,0,0,0,,把它记录在词典中
Dialogue: 0,0:29:37.56,0:29:40.73,Default,,0,0,0,,遍历过程中 词典紧随着我们 并告诉我们：x等于3
Dialogue: 0,0:29:41.45,0:29:45.87,Default,,0,0,0,,x等于3 y等于x 但这两个是不同意义上的x
Dialogue: 0,0:29:46.83,0:29:51.20,Default,,0,0,0,,那个是模式变量x 而这个是模式变量y匹配表达式x
Dialogue: 0,0:29:53.61,0:29:57.76,Default,,0,0,0,,这是模式变量y 它已经有值了 并且值是x
Dialogue: 0,0:29:58.36,0:30:00.06,Default,,0,0,0,,这是x么? 当然是
Dialogue: 0,0:30:00.06,0:30:00.75,Default,,0,0,0,,好的
Dialogue: 0,0:30:02.03,0:30:02.78,Default,,0,0,0,,完事儿了
Dialogue: 0,0:30:03.39,0:30:08.09,Default,,0,0,0,,现在 我有一本词典 它在遍历过程中不断积累
Dialogue: 0,0:30:11.42,0:30:14.51,Default,,0,0,0,,现在让我们看看这个一般情况 然后看看它如何工作
Dialogue: 0,0:30:15.88,0:30:16.51,Default,,0,0,0,,这里..
Dialogue: 0,0:30:17.20,0:30:21.66,Default,,0,0,0,,我传入一个模式 一个表达式 和一本词典
Dialogue: 0,0:30:22.38,0:30:27.50,Default,,0,0,0,,这里的情况比较复杂 -- 它是通用情况
Dialogue: 0,0:30:29.98,0:30:34.80,Default,,0,0,0,,一般来说 表达式由两部分组成：左部分和右部分
Dialogue: 0,0:30:35.45,0:30:38.81,Default,,0,0,0,,在Lisp系统中 复合对象都是由两部分组成的
Dialogue: 0,0:30:40.03,0:30:41.23,Default,,0,0,0,,现在我们有什么呢？
Dialogue: 0,0:30:41.88,0:30:48.84,Default,,0,0,0,,我将会用已有的这本词典 继续匹配模式和表达式的car部分
Dialogue: 0,0:30:50.30,0:30:53.12,Default,,0,0,0,,这个匹配过程会产生一本新词典
Dialogue: 0,0:30:54.14,0:30:57.26,Default,,0,0,0,,我将用它来匹配它们的cdr部分
Dialogue: 0,0:30:58.51,0:31:02.09,Default,,0,0,0,,这就是词典是如何在整个结构中遍历、线索的
Dialogue: 0,0:31:03.66,0:31:07.53,Default,,0,0,0,,匹配完car和cdr部分后得到的词典
Dialogue: 0,0:31:10.12,0:31:12.41,Default,,0,0,0,,会作为值返回给上级
Dialogue: 0,0:31:13.61,0:31:15.84,Default,,0,0,0,,匹配可能会在任何一个地方失败
Dialogue: 0,0:31:16.62,0:31:18.20,Default,,0,0,0,,比如说 可能会有这种情况
Dialogue: 0,0:31:18.36,0:31:27.18,Default,,0,0,0,,我们回过头来把这里改成4 这样就不会完全匹配
Dialogue: 0,0:31:29.13,0:31:34.81,Default,,0,0,0,,现在这两个不再匹配了 因为x应该
Dialogue: 0,0:31:34.93,0:31:37.34,Default,,0,0,0,,不好意思 这个y是x
Dialogue: 0,0:31:37.82,0:31:40.12,Default,,0,0,0,,但是这里的y却又是4
Dialogue: 0,0:31:40.53,0:31:43.52,Default,,0,0,0,,语法上来说 x和4显然不相同
Dialogue: 0,0:31:44.59,0:31:48.81,Default,,0,0,0,,所以这个不会匹配成功 它会拒绝 匹配会失败
Dialogue: 0,0:31:50.19,0:31:56.08,Default,,0,0,0,,那么 因为先前产生的词典会作为输入送入匹配器
Dialogue: 0,0:31:56.52,0:31:58.28,Default,,0,0,0,,所以它必须能够传播失败
Dialogue: 0,0:31:58.57,0:32:01.04,Default,,0,0,0,,第一条语句就是用来判断失败的
Dialogue: 0,0:32:03.61,0:32:08.19,Default,,0,0,0,,如果证实出来这个模式不是原子的---
Dialogue: 0,0:32:08.50,0:32:11.45,Default,,0,0,0,,如果模式是原子的 将进入这里 这里我们还没有讨论过
Dialogue: 0,0:32:12.17,0:32:13.56,Default,,0,0,0,,如果模式不是原子的
Dialogue: 0,0:32:15.05,0:32:19.23,Default,,0,0,0,,但表达式是原子--也就是它不由小部分组成
Dialogue: 0,0:32:20.14,0:32:22.65,Default,,0,0,0,,那么匹配必然失败 因此我们返回'failed
Dialogue: 0,0:32:23.64,0:32:30.78,Default,,0,0,0,,整理下思路 如果这个模式既不是原子的又不是模式变量的话 程序会来到这里
Dialogue: 0,0:32:30.96,0:32:32.51,Default,,0,0,0,,这是会使匹配失败的情况
Dialogue: 0,0:32:35.26,0:32:39.12,Default,,0,0,0,,好 让我们看这个里面的东西
Dialogue: 0,0:32:39.84,0:32:42.93,Default,,0,0,0,,首先需要知道 如果用原子模式来进行匹配会发生什么？
Dialogue: 0,0:32:42.93,0:32:43.90,Default,,0,0,0,,这简单
Dialogue: 0,0:32:43.90,0:32:46.50,Default,,0,0,0,,不是由其它模式构成的模式 比如：foo
Dialogue: 0,0:32:47.37,0:32:48.54,Default,,0,0,0,,这是个非常好的原子模式
Dialogue: 0,0:32:49.16,0:32:51.24,Default,,0,0,0,,让我们来看看
Dialogue: 0,0:32:52.08,0:32:55.82,Default,,0,0,0,,如果模式是原子的 而且表达式也原子的话
Dialogue: 0,0:32:56.80,0:33:01.85,Default,,0,0,0,,并且如果它俩是同一个东西 那么词典就跟之前一样
Dialogue: 0,0:33:03.08,0:33:04.00,Default,,0,0,0,,没有变化
Dialogue: 0,0:33:04.60,0:33:10.33,Default,,0,0,0,,就像刚才 +匹配+ *匹配* x匹配x
Dialogue: 0,0:33:11.42,0:33:12.33,Default,,0,0,0,,就是那样
Dialogue: 0,0:33:13.07,0:33:16.81,Default,,0,0,0,,然而 如何模式和表达式并不相同的话
Dialogue: 0,0:33:17.32,0:33:21.36,Default,,0,0,0,,如果这是两个不同的原子对象 比如+和*相匹配
Dialogue: 0,0:33:22.44,0:33:23.40,Default,,0,0,0,,这样就失败了
Dialogue: 0,0:33:25.60,0:33:34.56,Default,,0,0,0,,或者说 如果模式是原子 但表达式是复合 那么匹配失败
Dialogue: 0,0:33:37.40,0:33:38.24,Default,,0,0,0,,这很简单
Dialogue: 0,0:33:38.81,0:33:43.61,Default,,0,0,0,,那么 那些各种各样的模式变量又是怎么处理的呢？
Dialogue: 0,0:33:44.09,0:33:46.54,Default,,0,0,0,,我们有三类被命名了的模式变量
Dialogue: 0,0:33:47.39,0:33:52.03,Default,,0,0,0,,它们分别用于匹配：任意常量 任意变量 任意表达式
Dialogue: 0,0:33:53.82,0:34:00.14,Default,,0,0,0,,(? x) 表示匹配任意表达式
Dialogue: 0,0:34:01.18,0:34:04.54,Default,,0,0,0,,(?c x) 表示匹配任意常量
Dialogue: 0,0:34:04.73,0:34:07.29,Default,,0,0,0,,(?v x) 表示匹配任意变量
Dialogue: 0,0:34:08.96,0:34:09.79,Default,,0,0,0,,好的 我们要做什么呢?
Dialogue: 0,0:34:10.51,0:34:16.94,Default,,0,0,0,,看这里 如果模式表示的是匹配任意常量
Dialogue: 0,0:34:17.53,0:34:20.57,Default,,0,0,0,,那么待匹配的表达式最好是一个常量
Dialogue: 0,0:34:21.48,0:34:23.53,Default,,0,0,0,,不然的话 匹配就会失败
Dialogue: 0,0:34:23.83,0:34:27.50,Default,,0,0,0,,如果是一个常量 那么我就需要扩充词典
Dialogue: 0,0:34:27.50,0:34:29.69,Default,,0,0,0,,扩充词典的方法则是：
Dialogue: 0,0:34:30.70,0:34:37.76,Default,,0,0,0,,在旧词典后 附加一对模式与表达式的配对
Dialogue: 0,0:34:41.16,0:34:42.75,Default,,0,0,0,,因此 如果是匹配任意变量
Dialogue: 0,0:34:43.72,0:34:47.46,Default,,0,0,0,,我得通过匹配来核查表达式是否是变量
Dialogue: 0,0:34:47.46,0:34:50.09,Default,,0,0,0,,如果是的话 我就扩充词典
Dialogue: 0,0:34:50.38,0:34:54.65,Default,,0,0,0,,现在在原有词典基础上 我们又多了一项模式与表达式的匹配
Dialogue: 0,0:34:55.28,0:34:56.70,Default,,0,0,0,,这个过程返回一本新的词典
Dialogue: 0,0:34:58.88,0:35:04.16,Default,,0,0,0,,在这个词典中也有很多失败 因此需要检查
Dialogue: 0,0:35:04.16,0:35:07.50,Default,,0,0,0,,就比如 模式变量已经有一个值了
Dialogue: 0,0:35:09.23,0:35:16.17,Default,,0,0,0,,但我又用它匹配一个跟之前匹配的表达式不相同的表达式的话
Dialogue: 0,0:35:16.43,0:35:18.36,Default,,0,0,0,,那么在这里也会立即产生失败
Dialogue: 0,0:35:20.16,0:35:21.56,Default,,0,0,0,,我们后面再讨论
Dialogue: 0,0:35:22.91,0:35:29.36,Default,,0,0,0,,最后 匹配任意的表达式不需要在语法范畴做什么检查
Dialogue: 0,0:35:30.11,0:35:32.20,Default,,0,0,0,,只用扩充词典就行了
Dialogue: 0,0:35:34.76,0:35:38.32,Default,,0,0,0,,这就是一个完整的简单的匹配器
Dialogue: 0,0:35:39.28,0:35:41.37,Default,,0,0,0,,非常具有讽刺意味的一点是
Dialogue: 0,0:35:41.66,0:35:45.12,Default,,0,0,0,,现在 人们花了大价钱来请一些人编写
Dialogue: 0,0:35:45.46,0:35:47.52,Default,,0,0,0,,所谓的 “人工智能专家系统”
Dialogue: 0,0:35:48.40,0:35:52.03,Default,,0,0,0,,也不过是像这样的一个匹配器和实例化器罢了
Dialogue: 0,0:35:53.56,0:35:56.94,Default,,0,0,0,,这很容易做 现在你也可以创业开个小公司了
Dialogue: 0,0:35:57.42,0:36:01.72,Default,,0,0,0,,然后 第二周忽悠风投给你投个几百万
Dialogue: 0,0:36:03.79,0:36:08.57,Default,,0,0,0,,我是想说 这种程序放在20年前是非凡的
Dialogue: 0,0:36:09.74,0:36:12.81,Default,,0,0,0,,但放到现在 它就是小菜一碟了 大一新生也可以学
Dialogue: 0,0:36:13.63,0:36:15.47,Default,,0,0,0,,这里是一个实例化器
Dialogue: 0,0:36:20.22,0:36:23.07,Default,,0,0,0,,可问题是 他们都去了赚钱了 而且比我的还多
Dialogue: 0,0:36:24.97,0:36:26.59,Default,,0,0,0,,在大学中确实是这样
Dialogue: 0,0:36:27.10,0:36:39.42,Default,,0,0,0,,实例化是用来将给定的表达式、词典和骨架生成新的表达式的
Dialogue: 0,0:36:44.35,0:36:45.69,Default,,0,0,0,,这个不是很难
Dialogue: 0,0:36:46.60,0:36:53.36,Default,,0,0,0,,我们在下一张幻灯片中简单地看下
Dialogue: 0,0:36:53.88,0:36:59.29,Default,,0,0,0,,用一本给定的词典去实例化一个骨架 这很简单
Dialogue: 0,0:36:59.68,0:37:03.29,Default,,0,0,0,,我们要做的 就是对骨架递归地做树遍历
Dialogue: 0,0:37:04.08,0:37:08.33,Default,,0,0,0,,所有的骨架变量---我叫它“骨架求值”
Dialogue: 0,0:37:08.41,0:37:11.42,Default,,0,0,0,,这是我在这个程序中定义的抽象语法
Dialogue: 0,0:37:11.60,0:37:16.46,Default,,0,0,0,,在规则中 以冒号打头的就是骨架求值
Dialogue: 0,0:37:18.25,0:37:24.30,Default,,0,0,0,,在那种情况下 我要在词典中找答案 我们待会儿再讨论
Dialogue: 0,0:37:24.30,0:37:25.61,Default,,0,0,0,,我们看整体
Dialogue: 0,0:37:27.77,0:37:31.80,Default,,0,0,0,,这个过程是用一本字典来实例化一个骨架
Dialogue: 0,0:37:32.75,0:37:37.15,Default,,0,0,0,,我在这里定义一个内部循环
Dialogue: 0,0:37:38.14,0:37:39.85,Default,,0,0,0,,它要做的事情很简单
Dialogue: 0,0:37:40.17,0:37:43.50,Default,,0,0,0,,如果这个骨架是原子的
Dialogue: 0,0:37:44.60,0:37:47.45,Default,,0,0,0,,这种情况 它直接返回一个骨架作为结果
Dialogue: 0,0:37:48.84,0:37:51.87,Default,,0,0,0,,或者在通常情况下它是复合的
Dialogue: 0,0:37:52.60,0:37:59.40,Default,,0,0,0,,这种情况下 我通过一些实例化的结果构造表达式
Dialogue: 0,0:37:59.40,0:38:04.25,Default,,0,0,0,,递归调用这个循环 不断实例化骨架的car和cdr部分
Dialogue: 0,0:38:04.89,0:38:06.24,Default,,0,0,0,,这就是树的递归遍历
Dialogue: 0,0:38:08.41,0:38:14.36,Default,,0,0,0,,如果在骨架中有冒号表达式 那么这就是一个骨架求值
Dialogue: 0,0:38:14.96,0:38:22.64,Default,,0,0,0,,那么要做的事情是：找到冒号引导的表达式 -- 本例中 也就是CADR部分
Dialogue: 0,0:38:22.81,0:38:26.25,Default,,0,0,0,,这些是抽象语法 因此我能改变规则的表示
Dialogue: 0,0:38:27.52,0:38:32.73,Default,,0,0,0,,先不管求值过程如何实现 总之我要用这本词典对表达式求值
Dialogue: 0,0:38:32.90,0:38:34.65,Default,,0,0,0,,我们以后再仔细讨论
Dialogue: 0,0:38:36.12,0:38:38.35,Default,,0,0,0,,求值的结果就是答案
Dialogue: 0,0:38:39.68,0:38:43.66,Default,,0,0,0,,这条初始化语句 通过给它传递整个骨架循环来启动它
Dialogue: 0,0:38:44.44,0:38:47.04,Default,,0,0,0,,这些调用又会被分成小块的递归调用
Dialogue: 0,0:38:49.63,0:38:56.48,Default,,0,0,0,,那么 求值过程里面发生了些什么
Dialogue: 0,0:38:57.18,0:38:59.07,Default,,0,0,0,,我无法详尽地给你们解释
Dialogue: 0,0:38:59.98,0:39:01.34,Default,,0,0,0,,我就大致说一下
Dialogue: 0,0:39:01.56,0:39:03.74,Default,,0,0,0,,之后 我们再深入地讨论
Dialogue: 0,0:39:05.29,0:39:10.81,Default,,0,0,0,,在一本词典的环境下 求值一个表达式
Dialogue: 0,0:39:11.90,0:39:14.17,Default,,0,0,0,,如果表达式是原子的
Dialogue: 0,0:39:15.04,0:39:16.22,Default,,0,0,0,,就在词典中进行查找
Dialogue: 0,0:39:18.60,0:39:19.87,Default,,0,0,0,,这没啥
Dialogue: 0,0:39:20.57,0:39:23.66,Default,,0,0,0,,难点在这里
Dialogue: 0,0:39:23.83,0:39:28.28,Default,,0,0,0,,我将要应用表达式的car部分对应的一个过程
Dialogue: 0,0:39:29.44,0:39:31.68,Default,,0,0,0,,这个过程是在“某个地方”查找得到的--我们以后讨论
Dialogue: 0,0:39:32.14,0:39:34.20,Default,,0,0,0,,我想请大家注意一下 这之中有一些“魔法”
Dialogue: 0,0:39:34.67,0:39:38.72,Default,,0,0,0,,这个魔法将在不久后“施展”出来 但不是在今天
Dialogue: 0,0:39:40.00,0:39:46.51,Default,,0,0,0,,我们在词典中查找表达式剩余部分对应的值
Dialogue: 0,0:39:48.56,0:39:50.88,Default,,0,0,0,,我还不想让你们关注细节
Dialogue: 0,0:39:51.44,0:39:53.44,Default,,0,0,0,,我想让大家意识到这里还有很多代码
Dialogue: 0,0:39:54.17,0:39:56.75,Default,,0,0,0,,我们以后再详细讨论
Dialogue: 0,0:39:59.04,0:40:00.88,Default,,0,0,0,,但是 魔法就到此结束了
Dialogue: 0,0:40:02.57,0:40:06.96,Default,,0,0,0,,这部分利用Lisp的神奇力量 不过也就到此为止了
Dialogue: 0,0:40:10.25,0:40:13.56,Default,,0,0,0,,我们介绍了匹配和实例化
Dialogue: 0,0:40:15.05,0:40:16.60,Default,,0,0,0,,这一节有疑问么?
Dialogue: 0,0:40:28.10,0:40:29.80,Default,,0,0,0,,学生：我有一个问题
Dialogue: 0,0:40:29.80,0:40:30.43,Default,,0,0,0,,教授：请讲
Dialogue: 0,0:40:30.43,0:40:32.56,Default,,0,0,0,,学生：您能切到前张幻灯片上吗？
Dialogue: 0,0:40:33.60,0:40:35.56,Default,,0,0,0,,是关于定义匹配模式的
Dialogue: 0,0:40:36.16,0:40:40.76,Default,,0,0,0,,教授：好的 你想看定义匹配模式的全部的幻灯片
Dialogue: 0,0:40:40.76,0:40:43.06,Default,,0,0,0,,有人能帮我把投影仪---
Dialogue: 0,0:40:43.06,0:40:45.16,Default,,0,0,0,,这是最大的规模
Dialogue: 0,0:40:45.31,0:40:46.40,Default,,0,0,0,,你想看哪一部分？
Dialogue: 0,0:40:46.76,0:40:49.96,Default,,0,0,0,,学生：呃 最上面吧
Dialogue: 0,0:40:49.96,0:40:53.76,Default,,0,0,0,,就是传递失败的那一部分
Dialogue: 0,0:40:54.52,0:40:55.21,Default,,0,0,0,,教授：恩
Dialogue: 0,0:40:55.64,0:40:59.33,Default,,0,0,0,,学生：基本的想法是把错误返回给词典 是么?
Dialogue: 0,0:40:59.33,0:41:04.25,Default,,0,0,0,,教授：所谓的词典 就是所是匹配的答案 对吧？
Dialogue: 0,0:41:05.16,0:41:09.80,Default,,0,0,0,,要么它是一些配对
Dialogue: 0,0:41:11.07,0:41:14.03,Default,,0,0,0,,要么根本就没有配对
Dialogue: 0,0:41:14.46,0:41:14.97,Default,,0,0,0,,学生：对
Dialogue: 0,0:41:15.26,0:41:17.83,Default,,0,0,0,,教授：这里 事实上
Dialogue: 0,0:41:17.83,0:41:22.60,Default,,0,0,0,,因为一个匹配过程会向另一个匹配过程传递词典
Dialogue: 0,0:41:22.80,0:41:24.65,Default,,0,0,0,,可以在这里的一般情况中看到
Dialogue: 0,0:41:25.12,0:41:27.93,Default,,0,0,0,,这是一个匹配过程传递词典到另一个匹配过程
Dialogue: 0,0:41:28.14,0:41:34.16,Default,,0,0,0,,我是用匹配car部分得到的词典来匹配cdr部分的
Dialogue: 0,0:41:36.06,0:41:37.08,Default,,0,0,0,,这里的代码就是这个意思
Dialogue: 0,0:41:37.29,0:41:40.30,Default,,0,0,0,,正因为如此 如果对car部分的匹配失败了
Dialogue: 0,0:41:41.23,0:41:45.44,Default,,0,0,0,,匹配cdr部分的时候就有必要传播失败
Dialogue: 0,0:41:45.95,0:41:46.96,Default,,0,0,0,,第一行就是用于传播失败
Dialogue: 0,0:41:48.26,0:41:51.73,Default,,0,0,0,,学生：好 但我还是不明白匹配 --
Dialogue: 0,0:41:51.73,0:41:54.24,Default,,0,0,0,,从匹配的实例出来的是什么?
Dialogue: 0,0:41:54.73,0:41:56.00,Default,,0,0,0,,教授：有两种可能的情况
Dialogue: 0,0:41:56.33,0:41:59.15,Default,,0,0,0,,一种是符号'failed 意味匹配失败
Dialogue: 0,0:41:59.53,0:41:59.93,Default,,0,0,0,,学生：对
Dialogue: 0,0:41:59.93,0:42:03.87,Default,,0,0,0,,教授：或者是某种映射 -- 现在这还是一个抽象的东西
Dialogue: 0,0:42:04.16,0:42:05.68,Default,,0,0,0,,你需要知道它的结构
Dialogue: 0,0:42:06.49,0:42:13.96,Default,,0,0,0,,它们把匹配过程中 匹配成功的模式变量和值关联起来
Dialogue: 0,0:42:14.68,0:42:16.70,Default,,0,0,0,,学生：好 那么
Dialogue: 0,0:42:16.80,0:42:18.57,Default,,0,0,0,,教授：那是通过扩充词典实现的
Dialogue: 0,0:42:18.80,0:42:28.54,Default,,0,0,0,,学生：所以根据递归性质 如果匹配过程产生并传递了失败
Dialogue: 0,0:42:28.68,0:42:30.30,Default,,0,0,0,,那么第一种情况将捕获它
Dialogue: 0,0:42:30.40,0:42:33.56,Default,,0,0,0,,教授：并且传播它 不做任何其它处理
Dialogue: 0,0:42:33.56,0:42:34.83,Default,,0,0,0,,学生：哦 懂了
Dialogue: 0,0:42:35.50,0:42:37.36,Default,,0,0,0,,教授：这是传出失败最快的方法
Dialogue: 0,0:42:42.86,0:42:43.60,Default,,0,0,0,,请讲
Dialogue: 0,0:42:43.84,0:42:47.23,Default,,0,0,0,,学生：如果没有失败 那意味着我匹配了一个模式
Dialogue: 0,0:42:47.84,0:42:53.00,Default,,0,0,0,,我会扩充词典并且传递表达式中的模式
Dialogue: 0,0:42:55.21,0:42:58.43,Default,,0,0,0,,但是 代换并不是发生在这 对吧？
Dialogue: 0,0:42:58.43,0:42:59.03,Default,,0,0,0,,是吧？
Dialogue: 0,0:42:59.03,0:42:59.46,Default,,0,0,0,,教授：你是对的
Dialogue: 0,0:42:59.46,0:43:02.40,Default,,0,0,0,,这里没有可供代换的骨架 因此不会发生代换
Dialogue: 0,0:43:02.40,0:43:03.06,Default,,0,0,0,,学生：好 那么
Dialogue: 0,0:43:03.06,0:43:07.16,Default,,0,0,0,,教授：我们这里所做的 是为后面的代换准备词典
Dialogue: 0,0:43:08.25,0:43:12.43,Default,,0,0,0,,学生：词典的数据结构是什么呢？是有序对么？
Dialogue: 0,0:43:12.72,0:43:15.96,Default,,0,0,0,,教授：那个 那个还没有告诉你
Dialogue: 0,0:43:15.96,0:43:16.89,Default,,0,0,0,,它还是一个抽象的东西
Dialogue: 0,0:43:17.06,0:43:17.56,Default,,0,0,0,,学生：哦
Dialogue: 0,0:43:17.56,0:43:18.90,Default,,0,0,0,,教授：你为什么要知道呢?
Dialogue: 0,0:43:18.90,0:43:21.64,Default,,0,0,0,,它是一个函数 仅仅是一个函数
Dialogue: 0,0:43:21.69,0:43:22.33,Default,,0,0,0,,学生：我想知道它的原因是--
Dialogue: 0,0:43:22.33,0:43:24.17,Default,,0,0,0,,教授：这个抽象函数表现地像有序对
Dialogue: 0,0:43:25.12,0:43:28.44,Default,,0,0,0,,它可以用一系列的表通过链接来实现
Dialogue: 0,0:43:29.06,0:43:32.43,Default,,0,0,0,,它也可以用一些酷炫的表机制来实现
Dialogue: 0,0:43:32.56,0:43:34.16,Default,,0,0,0,,它也可以实现为一个函数
Dialogue: 0,0:43:35.80,0:43:37.40,Default,,0,0,0,,我可以把它写成一个函数
Dialogue: 0,0:43:39.02,0:43:39.87,Default,,0,0,0,,但我不会告诉你具体细节
Dialogue: 0,0:43:40.84,0:43:43.08,Default,,0,0,0,,这是George的事情 由他来构建这个结构
Dialogue: 0,0:43:49.56,0:43:52.06,Default,,0,0,0,,我知道 你特别想知道它的具体结构
Dialogue: 0,0:43:52.36,0:43:54.19,Default,,0,0,0,,但我不打算让你那么做
Dialogue: 0,0:43:54.43,0:43:59.23,Default,,0,0,0,,学生：恩 最后一个问题 扩充到词典中的重要信息是什么?
Dialogue: 0,0:43:59.74,0:44:02.08,Default,,0,0,0,,我想 可能是匹配发现的模式
Dialogue: 0,0:44:02.73,0:44:04.83,Default,,0,0,0,,教授：是的 那些与表达式相匹配的模式
Dialogue: 0,0:44:04.83,0:44:09.30,Default,,0,0,0,,我们想要得到模式 只不过在本例中这些都是模式变量 对吧？
Dialogue: 0,0:44:09.85,0:44:12.89,Default,,0,0,0,,这三种扩充词典的情况都是模式变量
Dialogue: 0,0:44:13.20,0:44:13.50,Default,,0,0,0,,学生：恩
Dialogue: 0,0:44:14.48,0:44:18.75,Default,,0,0,0,,教授：所以 在词典就有一个模式变量与一个值对应
Dialogue: 0,0:44:19.45,0:44:22.11,Default,,0,0,0,,这个值是所匹配的表达式
Dialogue: 0,0:44:23.31,0:44:29.63,Default,,0,0,0,,词典就是遍历过程中记录下来的所有匹配
Dialogue: 0,0:44:30.54,0:44:34.41,Default,,0,0,0,,我会以原有词典为基础 创建一本新词典
Dialogue: 0,0:44:35.12,0:44:38.35,Default,,0,0,0,,新增的内容就是新发现的匹配
Dialogue: 0,0:44:39.98,0:44:43.73,Default,,0,0,0,,学生：我不理解为什么不能在发现匹配后立即进行代换
Dialogue: 0,0:44:43.73,0:44:44.80,Default,,0,0,0,,教授：哦 那时候还不能代换
Dialogue: 0,0:44:44.81,0:44:46.62,Default,,0,0,0,,因为我不知道骨架啊！
Dialogue: 0,0:44:47.58,0:44:49.66,Default,,0,0,0,,模式和匹配器都是独立的单元
Dialogue: 0,0:44:49.66,0:44:51.00,Default,,0,0,0,,学生：哦 我明白了
Dialogue: 0,0:44:51.00,0:44:51.50,Default,,0,0,0,,教授：懂了吧？
Dialogue: 0,0:44:51.50,0:44:51.90,Default,,0,0,0,,学生：恩
Dialogue: 0,0:44:51.90,0:44:57.23,Default,,0,0,0,,教授：我用这个匹配器进行匹配 如果匹配了就可以实例化
Dialogue: 0,0:44:58.20,0:44:59.50,Default,,0,0,0,,学生：知道了
Dialogue: 0,0:45:00.54,0:45:03.88,Default,,0,0,0,,学生：您可以再求解一次黑板上的例子么
Dialogue: 0,0:45:04.89,0:45:06.93,Default,,0,0,0,,什么东西返回给了匹配器
Dialogue: 0,0:45:06.93,0:45:08.00,Default,,0,0,0,,教授：当然可以
Dialogue: 0,0:45:08.26,0:45:09.74,Default,,0,0,0,,来看这个例子
Dialogue: 0,0:45:10.67,0:45:15.45,Default,,0,0,0,,在这里当我遍历这个结构的时候 我遇到了(? x)
Dialogue: 0,0:45:16.67,0:45:20.54,Default,,0,0,0,,我有一本词典 不过此时假设它是空的
Dialogue: 0,0:45:21.56,0:45:25.36,Default,,0,0,0,,一本空词典 然后我匹配到了x为3
Dialogue: 0,0:45:26.62,0:45:33.60,Default,,0,0,0,,从此以后 词典中就记录了 x与3匹配 对吧
Dialogue: 0,0:45:33.64,0:45:36.09,Default,,0,0,0,,继续遍历 然后遇到(? y)
Dialogue: 0,0:45:36.89,0:45:39.20,Default,,0,0,0,,它是一个特殊的x 这是模式变量x
Dialogue: 0,0:45:39.79,0:45:41.37,Default,,0,0,0,,我看到(? y) 模式变量y
Dialogue: 0,0:45:42.17,0:45:47.74,Default,,0,0,0,,词典说 模式变量y的值是符号x
Dialogue: 0,0:45:48.99,0:45:51.20,Default,,0,0,0,,因为这里已经匹配过了
Dialogue: 0,0:45:52.43,0:45:54.52,Default,,0,0,0,,所以此时 词典中包含两个条目
Dialogue: 0,0:45:55.45,0:45:59.90,Default,,0,0,0,,模式变量x是数字3 模式变量y是表达式x
Dialogue: 0,0:46:01.95,0:46:04.11,Default,,0,0,0,,现在继续进行遍历
Dialogue: 0,0:46:04.23,0:46:07.45,Default,,0,0,0,,这里 模式变量y想要和4匹配
Dialogue: 0,0:46:08.06,0:46:10.65,Default,,0,0,0,,但是这个不可能 产生失败
Dialogue: 0,0:46:14.30,0:46:15.48,Default,,0,0,0,,谢谢 下课
Dialogue: 0,0:46:16.76,0:46:25.02,Default,,0,0,0,,[音乐]
Dialogue: 0,0:46:25.07,0:46:27.45,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:46:27.47,0:46:30.00,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教
Dialogue: 0,0:46:48.19,0:46:54.75,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:46:55.20,0:46:58.04,Declare,,0,0,0,,{\an2\fad(500,500)}模式匹配：基于规则的代换
Dialogue: 0,0:47:02.38,0:47:05.68,Default,,0,0,0,,这是大家首次看到如此庞大而复杂的程序
Dialogue: 0,0:47:07.34,0:47:09.90,Default,,0,0,0,,当然 本项课程的目的之一就在于
Dialogue: 0,0:47:09.90,0:47:12.97,Default,,0,0,0,,是让大家可以读懂这么庞大的程序 而完全不用害怕它
Dialogue: 0,0:47:13.76,0:47:16.33,Default,,0,0,0,,这个程序仅仅只有4页代码而已
Dialogue: 0,0:47:17.08,0:47:19.23,Default,,0,0,0,,课程结业后 我希望就算是50页长的程序
Dialogue: 0,0:47:20.27,0:47:21.80,Default,,0,0,0,,也吓不倒你们
Dialogue: 0,0:47:22.97,0:47:28.20,Default,,0,0,0,,我不是说让你们“左耳朵进 右耳朵出”地读程序
Dialogue: 0,0:47:29.20,0:47:31.70,Default,,0,0,0,,你应该体会这个程序
Dialogue: 0,0:47:31.70,0:47:34.83,Default,,0,0,0,,然后好好思考 因为它是一个很大的程序
Dialogue: 0,0:47:35.32,0:47:38.92,Default,,0,0,0,,在这个程序中有很多东西
Dialogue: 0,0:47:41.24,0:47:46.03,Default,,0,0,0,,我已经介绍了我们正在实现的 -- 基于规则代换的模式匹配语言
Dialogue: 0,0:47:46.81,0:47:47.64,Default,,0,0,0,,给你们看了一些规则
Dialogue: 0,0:47:48.36,0:47:51.24,Default,,0,0,0,,我已经告诉大家匹配和实例化
Dialogue: 0,0:47:51.55,0:47:53.32,Default,,0,0,0,,它们是使规则生效的“阴阳两极”
Dialogue: 0,0:47:54.24,0:47:56.35,Default,,0,0,0,,现在我们需要理解控制结构
Dialogue: 0,0:47:56.86,0:48:00.32,Default,,0,0,0,,就是这些规则是如何被用在表达式上
Dialogue: 0,0:48:01.08,0:48:03.84,Default,,0,0,0,,来指导代数化简的
Dialogue: 0,0:48:06.92,0:48:09.58,Default,,0,0,0,,这也是非常复杂的
Dialogue: 0,0:48:12.09,0:48:19.48,Default,,0,0,0,,其中有很多循环 相互交织 错综复杂
Dialogue: 0,0:48:20.24,0:48:26.99,Default,,0,0,0,,一方面 我不得不检查 待化简表达式的每个子表达式
Dialogue: 0,0:48:29.00,0:48:29.93,Default,,0,0,0,,我们已经讲过了
Dialogue: 0,0:48:29.93,0:48:36.24,Default,,0,0,0,,这是在car、cdr部分做某种树形递归
Dialogue: 0,0:48:37.44,0:48:38.59,Default,,0,0,0,,就是那样
Dialogue: 0,0:48:38.84,0:48:42.46,Default,,0,0,0,,现在 在我每个遍历到的结点上
Dialogue: 0,0:48:43.47,0:48:48.76,Default,,0,0,0,,也就是我想要化简的（子）表达式
Dialogue: 0,0:48:49.20,0:48:51.07,Default,,0,0,0,,我需要应用所有的规则
Dialogue: 0,0:48:53.42,0:48:55.08,Default,,0,0,0,,每个规则都需要检查每个节点
Dialogue: 0,0:48:56.00,0:48:57.92,Default,,0,0,0,,我一直在这些规则中打转（循环）
Dialogue: 0,0:49:01.66,0:49:05.48,Default,,0,0,0,,一个规则可能匹配 也可能不匹配
Dialogue: 0,0:49:07.50,0:49:10.62,Default,,0,0,0,,如果规则不匹配 那我就不关心了
Dialogue: 0,0:49:12.28,0:49:19.34,Default,,0,0,0,,如果规则匹配了 我就在那个结点用另一个表达式替换这个表达式
Dialogue: 0,0:49:20.08,0:49:22.89,Default,,0,0,0,,实际上 我创建了一个新表达式 它包含
Dialogue: 0,0:49:23.55,0:49:28.65,Default,,0,0,0,,它包含了所有的东西 新的值代换入骨架后的结果
Dialogue: 0,0:49:29.21,0:49:31.92,Default,,0,0,0,,也就是 在该层次上 把规则所对应的骨架实例化的结果
Dialogue: 0,0:49:32.72,0:49:37.37,Default,,0,0,0,,但我并不知道我所实例化出来的东西 是否是简化形式
Dialogue: 0,0:49:38.75,0:49:43.82,Default,,0,0,0,,所以我要对我刚刚构建好的东西调用化简器来简化它
Dialogue: 0,0:49:46.12,0:49:50.36,Default,,0,0,0,,完成后 我就可以将其构建进我想要的表达式中作为答案
Dialogue: 0,0:49:51.80,0:49:57.45,Default,,0,0,0,,这里的基本思想是 我们定义一个 “废料进-废料出”的化简器
Dialogue: 0,0:50:01.47,0:50:02.75,Default,,0,0,0,,它是一种递归调用的化简器
Dialogue: 0,0:50:03.58,0:50:08.84,Default,,0,0,0,,化简方法是：基本对象 比如变量就是最简形式的了
Dialogue: 0,0:50:10.78,0:50:13.28,Default,,0,0,0,,复合对象 -- 呃 我也不知道
Dialogue: 0,0:50:14.09,0:50:16.56,Default,,0,0,0,,而我要从简单的对象入手
Dialogue: 0,0:50:16.86,0:50:21.23,Default,,0,0,0,,通过假设它们都是由小块的基本对象组成的
Dialogue: 0,0:50:24.60,0:50:25.61,Default,,0,0,0,,这就是思路
Dialogue: 0,0:50:27.82,0:50:33.12,Default,,0,0,0,,现在如果我们看第一张投影
Dialogue: 0,0:50:33.88,0:50:37.13,Default,,0,0,0,,我们看到一个非常复杂的程序 就像我们之前看到的匹配器一样
Dialogue: 0,0:50:37.53,0:50:39.95,Default,,0,0,0,,它太复杂了 没有必要仔细阅读它
Dialogue: 0,0:50:41.92,0:50:43.61,Default,,0,0,0,,我只想让大家感受一下它的轮廓
Dialogue: 0,0:50:44.44,0:50:50.01,Default,,0,0,0,,也就是这个程序里面有很多子程序
Dialogue: 0,0:50:52.11,0:50:57.56,Default,,0,0,0,,这部分用于遍历表达式
Dialogue: 0,0:50:58.97,0:51:01.36,Default,,0,0,0,,这部分用于尝试规则
Dialogue: 0,0:51:02.52,0:51:05.60,Default,,0,0,0,,当然 我们也可以看看细节
Dialogue: 0,0:51:06.89,0:51:11.80,Default,,0,0,0,,来看第一张幻灯片
Dialogue: 0,0:51:13.40,0:51:17.36,Default,,0,0,0,,化简器由数个部分组成
Dialogue: 0,0:51:17.96,0:51:22.92,Default,,0,0,0,,回想一下 化简器接收一系列的规则
Dialogue: 0,0:51:23.92,0:51:27.20,Default,,0,0,0,,并生成一个使用该规则进行化简的程序
Dialogue: 0,0:51:30.04,0:51:32.60,Default,,0,0,0,,化简器在这里定义
Dialogue: 0,0:51:33.48,0:51:34.81,Default,,0,0,0,,接受一个规则集合
Dialogue: 0,0:51:36.16,0:51:38.68,Default,,0,0,0,,在the-rules被定义的上下文中
Dialogue: 0,0:51:39.24,0:51:41.48,Default,,0,0,0,,还定义了很多其它东西
Dialogue: 0,0:51:42.33,0:51:46.20,Default,,0,0,0,,而simplifier过程的返回结果则是
Dialogue: 0,0:51:46.41,0:51:50.80,Default,,0,0,0,,是一个已经定义好的过程 -- simplify-exp
Dialogue: 0,0:51:52.46,0:51:57.71,Default,,0,0,0,,调用 (simplifier the-rules) 的返回值是
Dialogue: 0,0:51:58.17,0:52:03.21,Default,,0,0,0,,返回值是一个过程 是在该上下文中定义的simplify-exp过程
Dialogue: 0,0:52:05.23,0:52:08.83,Default,,0,0,0,,这是一个利用这些给定规则进行化简的过程
Dialogue: 0,0:52:15.04,0:52:15.96,Default,,0,0,0,,定义就是这样的
Dialogue: 0,0:52:17.45,0:52:21.79,Default,,0,0,0,,这些过程的前两个 这个和这个
Dialogue: 0,0:52:22.48,0:52:25.74,Default,,0,0,0,,它们一起 递归地遍历一个表达式
Dialogue: 0,0:52:26.97,0:52:30.20,Default,,0,0,0,,这个是任何表达式的通用化简方法
Dialogue: 0,0:52:30.94,0:52:33.23,Default,,0,0,0,,而这个过程用于化简表达式的子部分
Dialogue: 0,0:52:35.53,0:52:36.08,Default,,0,0,0,,没别的了
Dialogue: 0,0:52:37.04,0:52:39.90,Default,,0,0,0,,每个过程中 我们会做些复杂操作 包括尝试这些规则
Dialogue: 0,0:52:40.32,0:52:41.71,Default,,0,0,0,,现在 我们看看这些过程
Dialogue: 0,0:52:45.76,0:52:48.08,Default,,0,0,0,,我们先来讨论一下表达式的递归遍历
Dialogue: 0,0:52:48.57,0:52:51.68,Default,,0,0,0,,这是用一种很简单的方法完成的
Dialogue: 0,0:52:54.28,0:52:57.93,Default,,0,0,0,,这是一个小型的、嵌套的递归过程
Dialogue: 0,0:52:59.42,0:53:01.77,Default,,0,0,0,,这里有两个过程 ---
Dialogue: 0,0:53:02.59,0:53:05.20,Default,,0,0,0,,一个是对整个表达式化简
Dialogue: 0,0:53:06.11,0:53:08.16,Default,,0,0,0,,另一个是对表达式的某部分化简
Dialogue: 0,0:53:09.44,0:53:10.97,Default,,0,0,0,,它们的原理都很简单
Dialogue: 0,0:53:12.12,0:53:16.86,Default,,0,0,0,,如果我想要化简的表达式是复合表达式
Dialogue: 0,0:53:17.04,0:53:18.32,Default,,0,0,0,,那么就对每一个部分进行化简
Dialogue: 0,0:53:19.95,0:53:22.32,Default,,0,0,0,,调用simplify-parts这个过程
Dialogue: 0,0:53:22.33,0:53:25.74,Default,,0,0,0,,会构造一个新的表达式 其中各个部分都是化简过的
Dialogue: 0,0:53:26.00,0:53:28.64,Default,,0,0,0,,我会在这里尝试那些应用规则
Dialogue: 0,0:53:30.86,0:53:34.22,Default,,0,0,0,,如果表达式不是复合的 而是一些简单的表达式
Dialogue: 0,0:53:34.76,0:53:37.13,Default,,0,0,0,,比如说是符号 或者'pi
Dialogue: 0,0:53:38.16,0:53:39.79,Default,,0,0,0,,无论如何 我都需要尝试应用这些规则
Dialogue: 0,0:53:40.03,0:53:47.56,Default,,0,0,0,,因为 因为可能有将pi扩展成3.14159265358979....这样的规则
Dialogue: 0,0:53:48.46,0:53:49.08,Default,,0,0,0,,也许我不会这样做
Dialogue: 0,0:53:50.11,0:53:51.52,Default,,0,0,0,,但是没有理由不这样做
Dialogue: 0,0:53:52.75,0:53:57.53,Default,,0,0,0,,现在如果我对表达式的各部分化简 那就很简单了
Dialogue: 0,0:53:58.99,0:54:02.88,Default,,0,0,0,,要么表达式是空的 它没有更多的部分了
Dialogue: 0,0:54:03.71,0:54:05.08,Default,,0,0,0,,这种情况我返回一个空表达式
Dialogue: 0,0:54:05.72,0:54:10.52,Default,,0,0,0,,否则 我用cons构建一个新的表达式
Dialogue: 0,0:54:11.21,0:54:14.27,Default,,0,0,0,,新表达式的car部分是原表达式car的化简结果
Dialogue: 0,0:54:15.42,0:54:17.39,Default,,0,0,0,,然后化简表达式的其它其他部分作为新表达式的cdr部分
Dialogue: 0,0:54:21.08,0:54:23.88,Default,,0,0,0,,我用这种方式向大家展示这些的原因是
Dialogue: 0,0:54:24.88,0:54:30.12,Default,,0,0,0,,我想让大家感受到 这些不同模式在编程时非常重要
Dialogue: 0,0:54:32.20,0:54:34.00,Default,,0,0,0,,这段程序我可以换种写法
Dialogue: 0,0:54:34.00,0:54:36.99,Default,,0,0,0,,还有一种化简表达式的方法
Dialogue: 0,0:54:37.72,0:54:39.63,Default,,0,0,0,,这仅仅是一个小程序
Dialogue: 0,0:54:39.63,0:54:42.36,Default,,0,0,0,,我把它写到黑板上 让大家感受一下
Dialogue: 0,0:54:49.71,0:54:51.90,Default,,0,0,0,,你可以用这种惯用法来写程序
Dialogue: 0,0:54:59.30,0:55:03.13,Default,,0,0,0,,那么 如何化简表达式exp呢？
Dialogue: 0,0:55:03.21,0:55:10.14,Default,,0,0,0,,在以下几种情况下 调用try-rules
Dialogue: 0,0:55:11.12,0:55:15.72,Default,,0,0,0,,就像之前一样 如果表达式是复合的
Dialogue: 0,0:55:21.52,0:55:24.27,Default,,0,0,0,,如果是复合的 我要怎么做呢?
Dialogue: 0,0:55:24.53,0:55:25.40,Default,,0,0,0,,我要化简它的每个部分
Dialogue: 0,0:55:26.01,0:55:27.80,Default,,0,0,0,,但是我已经有对cdr部分递归的过程了
Dialogue: 0,0:55:30.25,0:55:33.18,Default,,0,0,0,,一个被封装成高阶过程的通用模式
Dialogue: 0,0:55:34.09,0:55:34.46,Default,,0,0,0,,也就是map过程
Dialogue: 0,0:55:36.08,0:55:36.88,Default,,0,0,0,,我在这里写出来
Dialogue: 0,0:55:37.16,0:55:48.03,Default,,0,0,0,,(map simplify-exp exp)
Dialogue: 0,0:55:49.00,0:55:54.59,Default,,0,0,0,,这是说 把simplify-exp这个过程应用在表达式的每个部分
Dialogue: 0,0:55:55.34,0:55:57.34,Default,,0,0,0,,然后把结果用cons组合成表
Dialogue: 0,0:56:00.92,0:56:04.38,Default,,0,0,0,,所以表中的每个元素都是化简过的
Dialogue: 0,0:56:05.45,0:56:08.23,Default,,0,0,0,,不是复合表达式的话 就不用化简了
Dialogue: 0,0:56:09.05,0:56:12.36,Default,,0,0,0,,所以不需要再写一个辅助函数来化简各个部分
Dialogue: 0,0:56:12.64,0:56:13.48,Default,,0,0,0,,这句代码就够了
Dialogue: 0,0:56:15.47,0:56:17.05,Default,,0,0,0,,所以有时候可以这样写
Dialogue: 0,0:56:17.84,0:56:18.70,Default,,0,0,0,,这个无关紧要
Dialogue: 0,0:56:21.16,0:56:26.27,Default,,0,0,0,,好现在看一下 -- 如何尝试规则
Dialogue: 0,0:56:27.70,0:56:31.60,Default,,0,0,0,,这里 幻灯片上有一堆复杂的东西
Dialogue: 0,0:56:33.68,0:56:35.28,Default,,0,0,0,,我要尝试对一个表达式施用规则
Dialogue: 0,0:56:36.36,0:56:39.96,Default,,0,0,0,,我现在尝试的表达式是最初表达式的子表达式
Dialogue: 0,0:56:40.43,0:56:43.88,Default,,0,0,0,,这是因为我之前特意安排要求遍历所有子表达式
Dialogue: 0,0:56:46.11,0:56:51.90,Default,,0,0,0,,所以这里的exp 就是最初表达式的子表达式
Dialogue: 0,0:56:52.49,0:56:57.71,Default,,0,0,0,,这里我们定义一个scan的过程 它用来尝试每一个规则
Dialogue: 0,0:56:58.72,0:57:00.33,Default,,0,0,0,,我们会在整个规则中扫描
Dialogue: 0,0:57:01.92,0:57:07.77,Default,,0,0,0,,它会通过不断取cdr部分来遍历整个规则 查找一条规则来施用
Dialogue: 0,0:57:09.37,0:57:11.96,Default,,0,0,0,,当找到一条规则 它的任务就完成了
Dialogue: 0,0:57:14.09,0:57:16.41,Default,,0,0,0,,我们来看一下try-rules是如何工作的
Dialogue: 0,0:57:17.74,0:57:21.02,Default,,0,0,0,,非常简单：就是顺序地扫描规则表
Dialogue: 0,0:57:21.96,0:57:23.26,Default,,0,0,0,,它 真的简单吗？
Dialogue: 0,0:57:23.26,0:57:24.51,Default,,0,0,0,,不 这是个很庞大的程序
Dialogue: 0,0:57:25.55,0:57:28.57,Default,,0,0,0,,接收的参数是一系列的规则--它们是整个规则表的子表
Dialogue: 0,0:57:30.75,0:57:35.13,Default,,0,0,0,,我们已经查找了其中的一些 但它们都不符合 所以试试剩下的
Dialogue: 0,0:57:35.87,0:57:36.30,Default,,0,0,0,,尝试下一条
Dialogue: 0,0:57:36.40,0:57:37.63,Default,,0,0,0,,如果所有规则都尝试完了
Dialogue: 0,0:57:37.90,0:57:40.84,Default,,0,0,0,,那么 我就不能再对这个表达式做什么了 它已经是最简了
Dialogue: 0,0:57:42.35,0:57:47.26,Default,,0,0,0,,然而 如果还有规则需要扫描
Dialogue: 0,0:57:48.01,0:57:51.58,Default,,0,0,0,,那么从一个空的词典开始
Dialogue: 0,0:57:52.20,0:57:55.40,Default,,0,0,0,,用规则表中的第一条规则对表达式进行模式匹配
Dialogue: 0,0:57:57.07,0:57:58.84,Default,,0,0,0,,将得到的结果作为新的词典
Dialogue: 0,0:58:00.32,0:58:03.74,Default,,0,0,0,,如果失败了 就尝试剩余规则
Dialogue: 0,0:58:06.68,0:58:07.52,Default,,0,0,0,,这句代码就是这个意思
Dialogue: 0,0:58:08.52,0:58:10.33,Default,,0,0,0,,也就是说 丢弃那条规则
Dialogue: 0,0:58:11.10,0:58:15.05,Default,,0,0,0,,成功的话 我将取出第一条规则对应的骨架
Dialogue: 0,0:58:15.34,0:58:17.40,Default,,0,0,0,,利用得到的词典 来将其实例化
Dialogue: 0,0:58:17.93,0:58:20.80,Default,,0,0,0,,然后对结果化简 就得到了我想要的表达式
Dialogue: 0,0:58:24.20,0:58:25.96,Default,,0,0,0,,虽然这是一个复杂的程序
Dialogue: 0,0:58:26.25,0:58:28.72,Default,,0,0,0,,但是每个复杂程序都是由许多简单部分组成的
Dialogue: 0,0:58:29.77,0:58:33.12,Default,,0,0,0,,这里的递归模式非常复杂
Dialogue: 0,0:58:34.78,0:58:36.52,Default,,0,0,0,,最重要的事情就是：不要去思考它
Dialogue: 0,0:58:38.67,0:58:41.80,Default,,0,0,0,,如果去思考它的实际行为
Dialogue: 0,0:58:42.06,0:58:42.97,Default,,0,0,0,,大家就会迷惑
Dialogue: 0,0:58:45.31,0:58:45.71,Default,,0,0,0,,就算是我也会
Dialogue: 0,0:58:47.04,0:58:50.17,Default,,0,0,0,,没关系 可以多加练习
Dialogue: 0,0:58:51.52,0:58:52.46,Default,,0,0,0,,这些模式非常难
Dialogue: 0,0:58:54.17,0:58:55.42,Default,,0,0,0,,但是大家不用考虑它
Dialogue: 0,0:58:55.83,0:58:59.72,Default,,0,0,0,,关键点就是 好的编程或设计方法需要
Dialogue: 0,0:58:59.74,0:59:00.97,Default,,0,0,0,,知道什么是不需要考虑的
Dialogue: 0,0:59:03.05,0:59:06.06,Default,,0,0,0,,回到这张幻灯片上
Dialogue: 0,0:59:06.92,0:59:08.01,Default,,0,0,0,,我不需要考虑它
Dialogue: 0,0:59:08.54,0:59:13.83,Default,,0,0,0,,是因为我规定了exp化简后的结果是什么样子
Dialogue: 0,0:59:14.00,0:59:15.24,Default,,0,0,0,,我不需要知道它是如何做的
Dialogue: 0,0:59:17.08,0:59:21.24,Default,,0,0,0,,它也许是像我们这里 又是scan 又是try-rule
Dialogue: 0,0:59:22.24,0:59:24.09,Default,,0,0,0,,又或者在这里调用另一个递归程序
Dialogue: 0,0:59:24.33,0:59:25.69,Default,,0,0,0,,根据“按愿望思维” 因为我知道simplify-exp
Dialogue: 0,0:59:26.84,0:59:30.40,Default,,0,0,0,,它会返回exp化简后的结果
Dialogue: 0,0:59:31.61,0:59:32.99,Default,,0,0,0,,那么我就不需要再考虑它的具体实现了
Dialogue: 0,0:59:33.43,0:59:34.83,Default,,0,0,0,,我直接使用它
Dialogue: 0,0:59:35.07,0:59:36.43,Default,,0,0,0,,我合情合理地使用它
Dialogue: 0,0:59:36.43,0:59:37.45,Default,,0,0,0,,就会得到正确的结果
Dialogue: 0,0:59:39.95,0:59:42.57,Default,,0,0,0,,我们必须学会这种程序设计方法 -- 学会放弃
Dialogue: 0,0:59:47.56,0:59:49.05,Default,,0,0,0,,这里还有一点剩余
Dialogue: 0,0:59:50.40,0:59:54.46,Default,,0,0,0,,这里还有一些词典方面的细节
Dialogue: 0,0:59:55.08,0:59:58.32,Default,,0,0,0,,你们想知道到底词典是什么
Dialogue: 0,0:59:58.70,1:00:01.82,Default,,0,0,0,,但是我会跳过它 无可奉告
Dialogue: 0,1:00:04.14,1:00:05.20,Default,,0,0,0,,词典很简单
Dialogue: 0,1:00:06.01,1:00:09.84,Default,,0,0,0,,它是用一种被称为关联表的东西来表示的
Dialogue: 0,1:00:10.65,1:00:16.04,Default,,0,0,0,,这是一种特殊使用模式 用来在线性表中存放二维表
Dialogue: 0,1:00:16.50,1:00:20.17,Default,,0,0,0,,它们很简单 由序对构成 之前已经有同学问过了
Dialogue: 0,1:00:21.21,1:00:24.62,Default,,0,0,0,,有个特殊的过程叫做assq 用来处理这些东西
Dialogue: 0,1:00:24.94,1:00:26.36,Default,,0,0,0,,手册里面有
Dialogue: 0,1:00:27.04,1:00:28.59,Default,,0,0,0,,这个都无关紧要
Dialogue: 0,1:00:28.83,1:00:31.21,Default,,0,0,0,,重要的是如何扩充词典
Dialogue: 0,1:00:31.48,1:00:36.94,Default,,0,0,0,,要用一个模式、模式对应的数据、一本旧词典来扩充
Dialogue: 0,1:00:37.42,1:00:42.38,Default,,0,0,0,,这个模式pat 实际上是一个模式变量
Dialogue: 0,1:00:43.74,1:00:47.53,Default,,0,0,0,,我要做什么呢？我先从模式中取出模式变量的名字
Dialogue: 0,1:00:48.16,1:00:49.42,Default,,0,0,0,,把它赋给变量name
Dialogue: 0,1:00:50.44,1:00:53.71,Default,,0,0,0,,然后我按照这个名字在词典中查找是否有对应的值
Dialogue: 0,1:00:53.79,1:00:56.41,Default,,0,0,0,,如果没有 就将这对新的模式-值加入到词典中
Dialogue: 0,1:00:56.92,1:00:59.23,Default,,0,0,0,,如果已经存在一个这样名字的词条 并且有值
Dialogue: 0,1:00:59.60,1:01:03.18,Default,,0,0,0,,那dat的值最好跟已经存储的值相等
Dialogue: 0,1:01:03.88,1:01:06.54,Default,,0,0,0,,这是我心目中期待的情况
Dialogue: 0,1:01:06.89,1:01:09.15,Default,,0,0,0,,否则 置失败
Dialogue: 0,1:01:12.08,1:01:12.89,Default,,0,0,0,,所以它也很简单
Dialogue: 0,1:01:13.66,1:01:16.68,Default,,0,0,0,,打开任何一个程序 你会发现它们都是由数个个小部分组成
Dialogue: 0,1:01:17.18,1:01:18.30,Default,,0,0,0,,许多简单的小部分
Dialogue: 0,1:01:20.04,1:01:21.29,Default,,0,0,0,,我想 到目前为止
Dialogue: 0,1:01:21.60,1:01:25.68,Default,,0,0,0,,我已经告诉给你们价值百万的信息了
Dialogue: 0,1:01:28.41,1:01:30.96,Default,,0,0,0,,我想这个程序几乎已经讲完了
Dialogue: 0,1:01:31.85,1:01:32.72,Default,,0,0,0,,有什么问题么？
Dialogue: 0,1:01:34.27,1:01:38.16,Default,,0,0,0,,学生：你描述一下 化简后的表达式的规范么？
Dialogue: 0,1:01:38.72,1:01:39.02,Default,,0,0,0,,教授：好的
Dialogue: 0,1:01:39.85,1:01:44.33,Default,,0,0,0,,simplify-exp接收一个表达式 返回一个化简后的表达式
Dialogue: 0,1:01:45.28,1:01:45.77,Default,,0,0,0,,就是这样了
Dialogue: 0,1:01:48.11,1:01:50.27,Default,,0,0,0,,它的工作方式很简单
Dialogue: 0,1:01:51.60,1:01:56.09,Default,,0,0,0,,对于复合表达式 先化简各部分后 再尝试化简整体
Dialogue: 0,1:01:56.89,1:01:58.49,Default,,0,0,0,,原子表达式 就直接代规则化简
Dialogue: 0,1:01:59.52,1:02:02.11,Default,,0,0,0,,学生：是这些规则把表达式化简了么?
Dialogue: 0,1:02:02.76,1:02:03.58,Default,,0,0,0,,教授：当然
Dialogue: 0,1:02:03.76,1:02:03.90,Default,,0,0,0,,学生：好
Dialogue: 0,1:02:04.06,1:02:07.13,Default,,0,0,0,,教授：它们像你在这里看到的一样化简表达式
Dialogue: 0,1:02:08.35,1:02:11.64,Default,,0,0,0,,它先把表达式划分为小块
Dialogue: 0,1:02:12.60,1:02:17.29,Default,,0,0,0,,在化简器中使用这些规则 自下而上化简并构造表达式
Dialogue: 0,1:02:18.30,1:02:22.48,Default,,0,0,0,,处理它们 构造一个新的表达式作为结果
Dialogue: 0,1:02:24.28,1:02:29.44,Default,,0,0,0,,最后再尝试调用这些规则化简
Dialogue: 0,1:02:29.70,1:02:35.50,Default,,0,0,0,,当匹配的结果发生变化时 -- 就调用simplify-exp化简它
Dialogue: 0,1:02:35.80,1:02:40.64,Default,,0,0,0,,哦 不对是 骨架的实例化结果发生改变时
Dialogue: 0,1:02:42.00,1:02:47.36,Default,,0,0,0,,所以 规范就是 任何传入的表达式通过这些规则生成化简后的表达式
Dialogue: 0,1:02:49.84,1:02:50.76,Default,,0,0,0,,谢谢大家 下课
Dialogue: 0,1:02:53.64,1:03:06.96,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:02:53.64,1:03:06.96,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/DeathKing/Learning-SICP
