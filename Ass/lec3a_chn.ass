[Script Info]
; Script generated by Aegisub 3.0.4
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
Collisions: Normal
Audio URI: G:\untitled\ref\lec3a_480_muxed.mp4
Video Zoom Percent: 0.625
Scroll Position: 0
Active Line: 336
Video File: G:\untitled\ref\lec3a_480_muxed.mp4
Video Aspect Ratio: c1.33333
Video Position: 51395
PlayResX: 640
PlayResY: 480
YCbCr Matrix: TV.601

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:03.12,Declare,,0,0,0,,{\an2\fad(500,500)}Learning-SICP学习小组\N倾情制作
Dialogue: 0,0:00:04.40,0:00:08.02,Declare,,0,0,0,,{\an2\fad(500,500)}翻译&&时间轴：邓雄飞（Dysprosium）、Savior Michael\N压制&&特效：邓雄飞（Dysprosium）\N校对：邓雄飞（Dysprosium）
Dialogue: 0,0:00:08.06,0:00:12.16,Declare,,0,0,0,,{\an2\fad(500,500)}特别感谢：裘宗燕教授
Dialogue: 0,0:00:12.37,0:00:16.32,Declare,,0,0,0,,{\an2\fad(500,500)}Henderson-Escher的例子
Dialogue: 0,0:00:20.94,0:00:23.86,Default,,0,0,0,,上节课我们讨论了复合数据
Dialogue: 0,0:00:24.94,0:00:29.74,Default,,0,0,0,,其中有两个关键点
Dialogue: 0,0:00:29.74,0:00:32.48,Default,,0,0,0,,首先 有一种数据抽象的方法学
Dialogue: 0,0:00:32.94,0:00:39.10,Default,,0,0,0,,其要点是将数据的使用
Dialogue: 0,0:00:40.06,0:00:41.50,Default,,0,0,0,,和表示分离开来
Dialogue: 0,0:00:41.55,0:00:45.20,Default,,0,0,0,,比如说 我们可以与一个叫做George的人“签订契约”
Dialogue: 0,0:00:45.20,0:00:47.48,Default,,0,0,0,,让他负责数据的表示
Dialogue: 0,0:00:47.48,0:00:49.36,Default,,0,0,0,,而当我们使用这些数据的时候
Dialogue: 0,0:00:49.36,0:00:51.36,Default,,0,0,0,,不需要替George操心他是如何完成数据表示的工作的
Dialogue: 0,0:00:51.98,0:00:58.44,Default,,0,0,0,,其次 Lisp中有一种特殊的方式把对象连接在一起
Dialogue: 0,0:00:58.94,0:01:00.52,Default,,0,0,0,,就是构成“序对”
Dialogue: 0,0:01:00.52,0:01:03.54,Default,,0,0,0,,这是通过CONS CAR CDR实现的
Dialogue: 0,0:01:03.54,0:01:07.16,Default,,0,0,0,,而CONS CAR CDR本身是如何实现的 这不重要
Dialogue: 0,0:01:07.16,0:01:10.02,Default,,0,0,0,,George的任务就是如何构建这些东西
Dialogue: 0,0:01:10.02,0:01:11.16,Default,,0,0,0,,可以将它们实现为基本过程
Dialogue: 0,0:01:11.16,0:01:13.80,Default,,0,0,0,,也可以利用一些奇怪的过程来实现
Dialogue: 0,0:01:13.80,0:01:15.22,Default,,0,0,0,,但是我们不用操心这些
Dialogue: 0,0:01:16.02,0:01:19.66,Default,,0,0,0,,举个例子 我们来看下有理数算术
Dialogue: 0,0:01:19.66,0:01:21.50,Default,,0,0,0,,看下向量
Dialogue: 0,0:01:21.50,0:01:24.18,Default,,0,0,0,,我们简单回顾一下向量
Dialogue: 0,0:01:24.18,0:01:27.64,Default,,0,0,0,,这里有个对两个向量求和的操作
Dialogue: 0,0:01:27.64,0:01:33.32,Default,,0,0,0,,我们想要把向量v1和v2相加
Dialogue: 0,0:01:34.46,0:01:40.84,Default,,0,0,0,,它们的和也是一个向量 其坐标是两个向量的坐标的和
Dialogue: 0,0:01:41.28,0:01:45.66,Default,,0,0,0,,所以 定义(+VECT V1 V2)为
Dialogue: 0,0:01:45.66,0:01:51.72,Default,,0,0,0,,我创建一个向量 其X坐标是两向量X坐标的和
Dialogue: 0,0:01:52.10,0:01:54.82,Default,,0,0,0,,而Y坐标是两向量Y坐标的和
Dialogue: 0,0:01:56.06,0:02:04.10,Default,,0,0,0,,类似地 我们也可以定义一个缩放向量的操作
Dialogue: 0,0:02:04.94,0:02:12.66,Default,,0,0,0,,这里的SCALE过程是用数字S乘以向量V
Dialogue: 0,0:02:13.08,0:02:16.14,Default,,0,0,0,,向量V从这里到这里
Dialogue: 0,0:02:16.32,0:02:20.22,Default,,0,0,0,,我放大V 得到了与原来同向但更长的向量
Dialogue: 0,0:02:21.56,0:02:24.26,Default,,0,0,0,,为了缩放向量 我需要通过缩放坐标来实现
Dialogue: 0,0:02:24.26,0:02:30.22,Default,,0,0,0,,所以我构建了一个向量 它的X坐标是原向量X坐标的S倍
Dialogue: 0,0:02:30.56,0:02:33.54,Default,,0,0,0,,同时 它的Y坐标是原来向量Y坐标的S倍
Dialogue: 0,0:02:33.54,0:02:40.28,Default,,0,0,0,,上述两个操作都是利用了向量的表示来实现的
Dialogue: 0,0:02:40.28,0:02:45.02,Default,,0,0,0,,而这种向量的表示 我们则可以用序对来实现
Dialogue: 0,0:02:45.34,0:02:51.28,Default,,0,0,0,,因此George需要为我们提供MAKE-VECTOR、XCOR和YCOR
Dialogue: 0,0:02:53.02,0:02:57.98,Default,,0,0,0,,他可以使用CONS CAR CDR来实现
Dialogue: 0,0:02:58.88,0:03:06.78,Default,,0,0,0,,但是注意 我这里用了一个略微不同的方式
Dialogue: 0,0:03:08.04,0:03:11.00,Default,,0,0,0,,这个过程我们之前看过 其中我讲过
Dialogue: 0,0:03:11.14,0:03:16.22,Default,,0,0,0,,(MAKE-VECTOR X Y)也就是(CONS X Y)
Dialogue: 0,0:03:16.22,0:03:17.98,Default,,0,0,0,,而我这里简单定义MAKE-VECTOR为CONS
Dialogue: 0,0:03:17.98,0:03:20.48,Default,,0,0,0,,这就与之前有些不同了
Dialogue: 0,0:03:20.48,0:03:26.22,Default,,0,0,0,,之前我们我们把MAKE-VECTOR定义为需要两个参数的过程
Dialogue: 0,0:03:26.22,0:03:28.04,Default,,0,0,0,,效果是(CONS X Y)
Dialogue: 0,0:03:28.04,0:03:34.12,Default,,0,0,0,,这里 我就把MAKE-VECTOR定义为CONS
Dialogue: 0,0:03:35.18,0:03:39.66,Default,,0,0,0,,这跟我们之前使用的方式基本上是一样的
Dialogue: 0,0:03:39.66,0:03:46.58,Default,,0,0,0,,大家要习惯于“过程也是对象 而且你可以给他们命名”这种想法
Dialogue: 0,0:03:48.70,0:03:51.80,Default,,0,0,0,,这些就是向量的表示方法了
Dialogue: 0,0:03:51.80,0:03:55.68,Default,,0,0,0,,如果仅仅是那样 那就太无趣了
Dialogue: 0,0:03:57.02,0:04:02.16,Default,,0,0,0,,要记住 要点是我们不仅可以通过使用CONS将数字组合成序对
Dialogue: 0,0:04:02.16,0:04:04.16,Default,,0,0,0,,也可以组合任何东西
Dialogue: 0,0:04:05.20,0:04:11.60,Default,,0,0,0,,例如 如果我想表示一个线段
Dialogue: 0,0:04:11.60,0:04:15.64,Default,,0,0,0,,一个以某个向量为起点的线段
Dialogue: 0,0:04:16.06,0:04:28.30,Default,,0,0,0,,比如从向量(2,3)所代表的起点到向量(5,1)所代表的终点的线段
Dialogue: 0,0:04:28.30,0:04:31.82,Default,,0,0,0,,如果我们想表示这条线段
Dialogue: 0,0:04:33.26,0:04:36.20,Default,,0,0,0,,那么我们可以构建一个序对的序对
Dialogue: 0,0:04:40.72,0:04:42.94,Default,,0,0,0,,这样我们就可以表示一条线段了
Dialogue: 0,0:04:42.94,0:04:47.34,Default,,0,0,0,,我们可以编写一个使用CONS构造线段的构造函数
Dialogue: 0,0:04:47.98,0:04:51.60,Default,,0,0,0,,以及 析取出线段起点、终点的选择函数
Dialogue: 0,0:04:55.24,0:04:59.76,Default,,0,0,0,,那么如果我们剥开抽象层一探究竟
Dialogue: 0,0:04:59.88,0:05:02.10,Default,,0,0,0,,就会发现线段不过是 序对组成的序对
Dialogue: 0,0:05:04.66,0:05:06.22,Default,,0,0,0,,它还是一个序对
Dialogue: 0,0:05:06.22,0:05:08.22,Default,,0,0,0,,这里有个线段
Dialogue: 0,0:05:10.00,0:05:16.72,Default,,0,0,0,,它的CAR部分是个序对 CDR部分也是个序对
Dialogue: 0,0:05:18.32,0:05:25.54,Default,,0,0,0,,它的CAR部分是由2和3构成的序对
Dialogue: 0,0:05:26.02,0:05:28.08,Default,,0,0,0,,CDR部分则由5和1构成的序对
Dialogue: 0,0:05:28.16,0:05:29.24,Default,,0,0,0,,这里我再提醒大家一下
Dialogue: 0,0:05:29.32,0:05:33.46,Default,,0,0,0,,好多人认为如果我箭头向下画的话
Dialogue: 0,0:05:33.80,0:05:36.90,Default,,0,0,0,,会有其它的含意
Dialogue: 0,0:05:36.98,0:05:38.28,Default,,0,0,0,,这是不对的
Dialogue: 0,0:05:38.58,0:05:43.90,Default,,0,0,0,,箭头指示的是对象间如何连接 它指向水平或竖直方向都是无关紧要的
Dialogue: 0,0:05:47.48,0:05:52.18,Default,,0,0,0,,还要提醒一下 序对是具有闭包性质的
Dialogue: 0,0:05:52.94,0:06:05.62,Default,,0,0,0,,闭包性质使我们可以构建更复杂的东西 而不仅仅是简单的序对
Dialogue: 0,0:06:06.64,0:06:15.24,Default,,0,0,0,,在这里我要特别指出 在我们用CONS构建出来的序对的基础上
Dialogue: 0,0:06:16.44,0:06:22.64,Default,,0,0,0,,我们也可以进一步用CONS来构造更复杂的对象
Dialogue: 0,0:06:23.28,0:06:31.98,Default,,0,0,0,,或者用数学家的话说 Lisp中的数据对象在CONS运算下是封闭的
Dialogue: 0,0:06:33.82,0:06:36.34,Default,,0,0,0,,这个性质使我们能够构造更加复杂的数据对象
Dialogue: 0,0:06:36.34,0:06:38.04,Default,,0,0,0,,这个似乎是显然的 但是要记住
Dialogue: 0,0:06:39.06,0:06:42.46,Default,,0,0,0,,人们使用的编程语言中有很多东西并不是封闭的
Dialogue: 0,0:06:42.46,0:06:48.06,Default,,0,0,0,,举例来说 Basic和Fortran中的构造数组操作 就不是封闭的
Dialogue: 0,0:06:48.08,0:06:51.94,Default,,0,0,0,,因为 虽然你可以用数字、字符或字符串等来构造数组
Dialogue: 0,0:06:52.04,0:06:54.18,Default,,0,0,0,,但是你不能创建数组的数组
Dialogue: 0,0:06:54.64,0:06:56.68,Default,,0,0,0,,当考察某种组合的方法时
Dialogue: 0,0:06:57.60,0:07:02.78,Default,,0,0,0,,你应该考察该组合方法是否封闭
Dialogue: 0,0:07:05.06,0:07:08.26,Default,,0,0,0,,不管怎样 因为我们可以构造序对的序对
Dialogue: 0,0:07:08.86,0:07:12.78,Default,,0,0,0,,我们就可以用序对将数据以各种各样的方式组合起来
Dialogue: 0,0:07:14.02,0:07:18.26,Default,,0,0,0,,比如我想要组合四个数 —— 1 2 3 4
Dialogue: 0,0:07:18.26,0:07:19.82,Default,,0,0,0,,我有很多方法
Dialogue: 0,0:07:20.74,0:07:26.12,Default,,0,0,0,,比如 像构造线段那样 我可以构造一个序对
Dialogue: 0,0:07:29.02,0:07:36.88,Default,,0,0,0,,它是((1 2) (3 4)) 对吧？
Dialogue: 0,0:07:36.88,0:07:40.06,Default,,0,0,0,,或者如果我喜欢 我可以像这样做
Dialogue: 0,0:07:40.06,0:07:45.52,Default,,0,0,0,,我构造一个序对 它的CAR部分也是一个序对
Dialogue: 0,0:07:46.44,0:07:53.20,Default,,0,0,0,,这个序对的CAR部分为1 而CDR部分为由2、3构成的序对
Dialogue: 0,0:07:53.26,0:07:55.08,Default,,0,0,0,,最后 我把4放在这里
Dialogue: 0,0:07:56.92,0:08:02.16,Default,,0,0,0,,所以你可以看到 组合对象的方式有很多种
Dialogue: 0,0:08:02.16,0:08:07.74,Default,,0,0,0,,因此就有必要建立一些统一的约定
Dialogue: 0,0:08:07.74,0:08:11.58,Default,,0,0,0,,使我们能够用某种的通用的方式处理数据
Dialogue: 0,0:08:11.58,0:08:14.00,Default,,0,0,0,,而不用总是针对具体问题做一些生硬的选择
Dialogue: 0,0:08:15.94,0:08:19.04,Default,,0,0,0,,Lisp里面就有这样一种约定
Dialogue: 0,0:08:20.74,0:08:25.82,Default,,0,0,0,,这个约定将一系列的东西表示成一个序对组成的链
Dialogue: 0,0:08:26.78,0:08:28.18,Default,,0,0,0,,而这样一个数据序列就叫做一个“表”
Dialogue: 0,0:08:34.72,0:08:40.50,Default,,0,0,0,,表本质上就是Lisp用来表示序列数据的一个约定而已
Dialogue: 0,0:08:40.70,0:08:47.38,Default,,0,0,0,,我可以使用序对的序列来表示序列 1 2 3 4
Dialogue: 0,0:08:48.26,0:08:54.68,Default,,0,0,0,,我把1放在这里 它的CDR指向另一个序对
Dialogue: 0,0:08:59.20,0:09:01.40,Default,,0,0,0,,这个序对的CAR部分是序列中的下一个数
Dialogue: 0,0:09:01.52,0:09:03.42,Default,,0,0,0,,并且它的CDR指向了另一个序对
Dialogue: 0,0:09:05.44,0:09:07.30,Default,,0,0,0,,它的CAR部分是序列的再下一个数
Dialogue: 0,0:09:07.36,0:09:08.44,Default,,0,0,0,,这个是3
Dialogue: 0,0:09:08.44,0:09:09.74,Default,,0,0,0,,以此类推
Dialogue: 0,0:09:09.74,0:09:13.22,Default,,0,0,0,,所以 序列中的每一个元素都对应着一个序对
Dialogue: 0,0:09:15.82,0:09:18.32,Default,,0,0,0,,而当这个序列中没有其它元素时，我用一个特殊的标记
Dialogue: 0,0:09:20.72,0:09:22.74,Default,,0,0,0,,来表示列表中没有元素了
Dialogue: 0,0:09:24.14,0:09:34.64,Default,,0,0,0,,好 这就是将序列中的元素组合起来的一种约定方式
Dialogue: 0,0:09:34.64,0:09:37.98,Default,,0,0,0,,而它其实就是一堆序对
Dialogue: 0,0:09:39.40,0:09:44.80,Default,,0,0,0,,每个序对中的CAR部分就是我们想要组合到一起的元素
Dialogue: 0,0:09:46.00,0:09:48.46,Default,,0,0,0,,这些序对的CDR部分则指向下一个序对
Dialogue: 0,0:09:50.02,0:09:56.04,Default,,0,0,0,,现在 如果我想要构造它 我需要向Lisp中输入
Dialogue: 0,0:09:56.62,0:09:58.76,Default,,0,0,0,,我会像这样来构造
Dialogue: 0,0:09:59.22,0:10:15.28,Default,,0,0,0,,(CONS 1 (CONS 2 (CONS 3 (CONS 4 NIL))))
Dialogue: 0,0:10:15.28,0:10:20.00,Default,,0,0,0,,NIL是序列末尾标志的名字
Dialogue: 0,0:10:20.80,0:10:23.24,Default,,0,0,0,,它是一个特殊的名字 标识以达到表的末尾
Dialogue: 0,0:10:26.24,0:10:30.26,Default,,0,0,0,,好 这就是如何构造一个表
Dialogue: 0,0:10:37.54,0:10:41.40,Default,,0,0,0,,如果每次构造一个表时 都要输入像
Dialogue: 0,0:10:41.45,0:10:45.18,Default,,0,0,0,,(CONS 1 (CONS 2 (CONS 3...的话 将会非常费力
Dialogue: 0,0:10:45.18,0:10:50.10,Default,,0,0,0,,因此Lisp提供了一种叫做LIST的操作
Dialogue: 0,0:10:53.70,0:10:57.72,Default,,0,0,0,,LIST其实是这种嵌套CONS的缩写
Dialogue: 0,0:10:58.96,0:11:06.32,Default,,0,0,0,,它可以让我用(LIST 1 2 3 4)来构造表
Dialogue: 0,0:11:07.78,0:11:11.74,Default,,0,0,0,,这只是另外一种方式v一个语法糖
Dialogue: 0,0:11:11.94,0:11:14.76,Default,,0,0,0,,用来简便地书写嵌套的CONS
Dialogue: 0,0:11:14.76,0:11:17.84,Default,,0,0,0,,(CONS (CONS (CONS (CONS NIL))))
Dialogue: 0,0:11:18.48,0:11:39.78,Default,,0,0,0,,举例来说 我将构造一个表(1 2 3 4) 并把它叫做1-TO-4
Dialogue: 0,0:11:47.96,0:11:53.02,Default,,0,0,0,,注意使用这种简便写法的结果
Dialogue: 0,0:11:53.80,0:11:56.92,Default,,0,0,0,,首先 如果我有这个表(1 2 3 4)
Dialogue: 0,0:11:57.36,0:12:02.64,Default,,0,0,0,,表的CAR把部分就是这个表的第一个元素 对吧？
Dialogue: 0,0:12:04.06,0:12:05.28,Default,,0,0,0,,那么 如何获得元素2呢？
Dialogue: 0,0:12:05.28,0:12:23.94,Default,,0,0,0,,2应该是1-TO-4的CDR部分的CAR部分
Dialogue: 0,0:12:23.98,0:12:29.48,Default,,0,0,0,,它的CDR是这个
Dialogue: 0,0:12:29.82,0:12:31.68,Default,,0,0,0,,而它的CAR部分是2
Dialogue: 0,0:12:32.58,0:12:47.42,Default,,0,0,0,,同理 1-TO-4的CDR的CDR的CAR部分
Dialogue: 0,0:12:47.42,0:12:51.36,Default,,0,0,0,,是3 以此类推
Dialogue: 0,0:12:52.68,0:12:55.84,Default,,0,0,0,,我们来看下屏幕
Dialogue: 0,0:12:57.50,0:13:11.18,Default,,0,0,0,,我定义一个表(1 2 3 4) 命名为1-TO-4
Dialogue: 0,0:13:13.78,0:13:21.28,Default,,0,0,0,,我这样写 计算机返回定义完成 这个就是1-TO-4的定义
Dialogue: 0,0:13:22.30,0:13:36.74,Default,,0,0,0,,我问 比如 1-TO-4的CDR的CDR的CAR
Dialogue: 0,0:13:38.34,0:13:42.42,Default,,0,0,0,,嗯 它是3
Dialogue: 0,0:13:44.08,0:13:50.08,Default,,0,0,0,,或者我问 1-TO-4是什么
Dialogue: 0,0:13:51.26,0:13:57.22,Default,,0,0,0,,Lisp输出的是用括号包围的 (1 2 3 4)
Dialogue: 0,0:13:57.22,0:14:02.12,Default,,0,0,0,,用括号将表中的元素包围起来的这种记号
Dialogue: 0,0:14:02.12,0:14:08.90,Default,,0,0,0,,通常用来打印输出表示序列的序对链
Dialogue: 0,0:14:08.90,0:14:17.14,Default,,0,0,0,,又比如 我问1-TO-4的CDR部分是什么
Dialogue: 0,0:14:19.30,0:14:21.12,Default,,0,0,0,,结果是表的剩余部分
Dialogue: 0,0:14:21.32,0:14:26.96,Default,,0,0,0,,这是原表首元素所指向的序对 新序列从2开始
Dialogue: 0,0:14:28.52,0:14:37.74,Default,,0,0,0,,比如 1-TO-4的CDR的CDR部分是什么
Dialogue: 0,0:14:43.24,0:14:44.68,Default,,0,0,0,,返回(3 4)
Dialogue: 0,0:14:44.82,0:14:59.66,Default,,0,0,0,,或者 1-TO-4的CDR的CDR的CDR的CDR部分是什么
Dialogue: 0,0:15:04.74,0:15:10.46,Default,,0,0,0,,我们看一下表的尾指针 Lisp返回()
Dialogue: 0,0:15:10.96,0:15:13.48,Default,,0,0,0,,你们可以认为这是一个空表
Dialogue: 0,0:15:14.12,0:15:21.38,Default,,0,0,0,,我求取 1-TO-4的CDR的CDR的CDR部分
Dialogue: 0,0:15:21.42,0:15:25.20,Default,,0,0,0,,这就只剩下表尾指针本身
Dialogue: 0,0:15:25.20,0:15:27.20,Default,,0,0,0,,它的输出是()
Dialogue: 0,0:15:34.14,0:15:39.98,Default,,0,0,0,,好了 这是处理表的一种常见方式
Dialogue: 0,0:15:41.50,0:15:43.44,Default,,0,0,0,,也就是不断地取CDR部分
Dialogue: 0,0:15:43.44,0:15:45.00,Default,,0,0,0,,这个叫做表的CDRING
Dialogue: 0,0:15:46.64,0:15:49.78,Default,,0,0,0,,当然手写这些CDR非常费劲
Dialogue: 0,0:15:49.78,0:15:52.24,Default,,0,0,0,,我们没必要这么做 我们编写程序来这么做
Dialogue: 0,0:15:52.96,0:15:59.10,Default,,0,0,0,,事实上 Lisp中非常普遍的事情是写一些过程
Dialogue: 0,0:15:59.85,0:16:06.54,Default,,0,0,0,,表中所有元素进行某种操作 得到的是由结果构成的表
Dialogue: 0,0:16:07.42,0:16:11.92,Default,,0,0,0,,比如 我写一个SCALE-LIST的过程
Dialogue: 0,0:16:16.80,0:16:25.24,Default,,0,0,0,,我要用SCALE-LIST将表1-TO-4放大10倍
Dialogue: 0,0:16:26.66,0:16:35.32,Default,,0,0,0,,那么它应该返回表(10 20 30 40)
Dialogue: 0,0:16:38.25,0:16:40.25,Default,,0,0,0,,没错 它返回一个表
Dialogue: 0,0:16:44.49,0:16:49.30,Default,,0,0,0,,我们可以猜想到这当中采用了某种递归策略
Dialogue: 0,0:16:49.30,0:16:51.30,Default,,0,0,0,,我应该如何编写这个过程呢？
Dialogue: 0,0:16:52.52,0:16:59.80,Default,,0,0,0,,如果要构建一个每个元素都乘以10的列表
Dialogue: 0,0:17:00.44,0:17:04.84,Default,,0,0,0,,需要做的是—假设已经得到了结果表的剩余元素
Dialogue: 0,0:17:05.86,0:17:08.42,Default,,0,0,0,,也就是表的CDR部分
Dialogue: 0,0:17:08.42,0:17:14.16,Default,,0,0,0,,这个子表中的每个元素都是原来元素乘以10
Dialogue: 0,0:17:16.06,0:17:19.68,Default,,0,0,0,,这是SCALE-LIST对表CDR部分作用的结果
Dialogue: 0,0:17:20.12,0:17:23.82,Default,,0,0,0,,我需要做的 就只有用表的CAR部分乘以10
Dialogue: 0,0:17:24.89,0:17:27.24,Default,,0,0,0,,然后用CONS将它和剩余部分连接起来 并返回这个列表
Dialogue: 0,0:17:29.02,0:17:33.09,Default,,0,0,0,,类似地 为了缩放子表 我得先缩放子表的CDR部分
Dialogue: 0,0:17:33.30,0:17:36.20,Default,,0,0,0,,并将其与2*10连接起来
Dialogue: 0,0:17:36.42,0:17:41.16,Default,,0,0,0,,最终 当我处理到表尾时 这里就只剩表尾指针了
Dialogue: 0,0:17:41.72,0:17:45.28,Default,,0,0,0,,它叫做NIL 我就直接返回表尾指针
Dialogue: 0,0:17:45.54,0:17:47.68,Default,,0,0,0,,所以这就是这个过程的递归策略
Dialogue: 0,0:17:47.68,0:17:50.52,Default,,0,0,0,,这个过程就是这样
Dialogue: 0,0:17:50.96,0:17:55.04,Default,,0,0,0,,这个例子就是对表做CDRING操作的通用策略
Dialogue: 0,0:17:55.66,0:17:58.24,Default,,0,0,0,,也就是所谓的“通过CONS组合结果”
Dialogue: 0,0:17:58.24,0:18:06.04,Default,,0,0,0,,那么 对表L缩放S倍 我该如何做呢？
Dialogue: 0,0:18:06.04,0:18:10.40,Default,,0,0,0,,首先得做判断 Lisp中有个叫NULL?的谓词
Dialogue: 0,0:18:10.40,0:18:13.22,Default,,0,0,0,,NULL?判断对象是否为表尾
Dialogue: 0,0:18:13.90,0:18:17.16,Default,,0,0,0,,或者说 对象是否为空表
Dialogue: 0,0:18:18.17,0:18:23.00,Default,,0,0,0,,任何情况下 当我处理到表尾时 我就将其返回
Dialogue: 0,0:18:23.65,0:18:24.60,Default,,0,0,0,,简单地返回NIL
Dialogue: 0,0:18:24.94,0:18:35.14,Default,,0,0,0,,否则 我就用CONS把列表中的第一个元素经过操作（缩放）后的结果
Dialogue: 0,0:18:35.54,0:18:39.29,Default,,0,0,0,,就是说 取L的CAR部分 然后用它乘以S
Dialogue: 0,0:18:40.36,0:18:46.34,Default,,0,0,0,,然后我就用CONS将这个结果 与用递归形式缩放后的表的剩下部分 连接在一起
Dialogue: 0,0:18:49.98,0:18:52.18,Default,,0,0,0,,再说一次 总体的思想是
Dialogue: 0,0:18:52.22,0:18:56.09,Default,,0,0,0,,你要用递归的方式处理表中的剩余元素 即表的CDR部分
Dialogue: 0,0:18:56.48,0:19:01.16,Default,,0,0,0,,然后你用CONS将那部分的结果 与经过处理后的表的第一个元素连接在一起
Dialogue: 0,0:19:01.16,0:19:05.18,Default,,0,0,0,,当你处理到结尾的时候 返回表尾标志NIL
Dialogue: 0,0:19:07.34,0:19:11.36,Default,,0,0,0,,这就是对一个表里的数据做某种操作的通用模式
Dialogue: 0,0:19:14.05,0:19:19.52,Default,,0,0,0,,现在 你们应该清楚知道这样一个事实
Dialogue: 0,0:19:19.53,0:19:22.62,Default,,0,0,0,,也就是我不必额外为这种基本模式额外编写过程
Dialogue: 0,0:19:22.62,0:19:24.90,Default,,0,0,0,,我要做的事情就是写一个过程
Dialogue: 0,0:19:24.90,0:19:26.32,Default,,0,0,0,,这是这个基本模式
Dialogue: 0,0:19:26.80,0:19:30.30,Default,,0,0,0,,对表中的元素执行操作 并以表的形式返回结果
Dialogue: 0,0:19:30.68,0:19:32.30,Default,,0,0,0,,好了 我们定义一些高阶过程
Dialogue: 0,0:19:32.32,0:19:35.18,Default,,0,0,0,,我们定义一个叫MAP的高阶过程 来完成这些操作
Dialogue: 0,0:19:36.73,0:19:43.17,Default,,0,0,0,,MAP以表L和过程P为参数
Dialogue: 0,0:19:44.92,0:19:51.08,Default,,0,0,0,,并返回对表L中每个元素应用过程P后得到的新表
Dialogue: 0,0:19:51.81,0:19:55.40,Default,,0,0,0,,这个新表里的元素是(P E1) (P E2) ...  到(P En)
Dialogue: 0,0:19:55.64,0:20:01.54,Default,,0,0,0,,所以我指的就是对一个表做这样一种变换：将P应用到表的每一个元素上
Dialogue: 0,0:20:02.52,0:20:07.08,Default,,0,0,0,,你们看到的这些过程正是我提到的通用策略
Dialogue: 0,0:20:07.08,0:20:09.08,Default,,0,0,0,,我们用它写乘以10的过程
Dialogue: 0,0:20:09.08,0:20:11.64,Default,,0,0,0,,如果表是空的 则返回NIL
Dialogue: 0,0:20:11.86,0:20:16.60,Default,,0,0,0,,否则 对表的首元素应用P
Dialogue: 0,0:20:17.14,0:20:18.74,Default,,0,0,0,,将P应用于L的CAR部分
Dialogue: 0,0:20:19.30,0:20:25.40,Default,,0,0,0,,然后连接它和将P应用于表CDR部分中的剩余元素得到的子表连接起来
Dialogue: 0,0:20:25.61,0:20:28.84,Default,,0,0,0,,这就是一个通用过程——MAP
Dialogue: 0,0:20:29.86,0:20:39.04,Default,,0,0,0,,我们可以用MAP来定义SCALE-LIST
Dialogue: 0,0:20:39.04,0:20:41.04,Default,,0,0,0,,我给你们展示一下
Dialogue: 0,0:20:43.46,0:20:52.50,Default,,0,0,0,,SCALE-LIST就是对表MAP一个特定的过程
Dialogue: 0,0:20:52.50,0:20:55.54,Default,,0,0,0,,这个过程需要一个参数 返回给定参数乘以S的结果
Dialogue: 0,0:20:58.96,0:21:01.90,Default,,0,0,0,,所以我思考缩放表这个过程的正确方式应该是
Dialogue: 0,0:21:02.12,0:21:07.40,Default,,0,0,0,,将这种递归实质实现为通用策略 而不是一个具体针对的过程
Dialogue: 0,0:21:07.40,0:21:11.28,Default,,0,0,0,,当然 这样做的意义之一是 是你会开始发现共性
Dialogue: 0,0:21:12.16,0:21:15.02,Default,,0,0,0,,我们正在掌握使用通用模式
Dialogue: 0,0:21:15.96,0:21:31.18,Default,,0,0,0,,比如 (MAP SQUARE 1-TO-4) 返回(1 4 9 16)
Dialogue: 0,0:21:32.48,0:21:37.17,Default,,0,0,0,,对这个表做映射
Dialogue: 0,0:21:37.57,0:21:46.32,Default,,0,0,0,,用(LAMBDA (X) (+ X 10))映射表1-TO-4
Dialogue: 0,0:21:49.68,0:21:52.86,Default,,0,0,0,,我让表的每个元素都加了10
Dialogue: 0,0:21:53.34,0:21:58.17,Default,,0,0,0,,也就是得到了(11 12 13 14)
Dialogue: 0,0:22:00.56,0:22:05.76,Default,,0,0,0,,我们看到对表中每个元素做操作是一种非常普遍的想法
Dialogue: 0,0:22:08.66,0:22:12.22,Default,,0,0,0,,而大家需要思考如何编写MAP的迭代版本
Dialogue: 0,0:22:12.22,0:22:16.04,Default,,0,0,0,,我碰巧写的是一个递归版本
Dialogue: 0,0:22:16.36,0:22:19.10,Default,,0,0,0,,但是我们也可以很容易地把它改成迭代过程
Dialogue: 0,0:22:19.10,0:22:23.16,Default,,0,0,0,,有趣的是 一旦你开始用MAP来思考
Dialogue: 0,0:22:24.02,0:22:29.00,Default,,0,0,0,,比如 一旦把缩放看作是一种MAP 就不用关心是迭代还是递归实现
Dialogue: 0,0:22:29.00,0:22:31.82,Default,,0,0,0,,你只会关心 啊 这里有这样一种数据集合 有这样一个表
Dialogue: 0,0:22:32.22,0:22:34.52,Default,,0,0,0,,我要做的是转化表中的每个元素
Dialogue: 0,0:22:34.56,0:22:38.36,Default,,0,0,0,,而不去考虑特别的控制流程或顺序
Dialogue: 0,0:22:38.88,0:22:41.09,Default,,0,0,0,,这是个非常非常重要的想法
Dialogue: 0,0:22:42.36,0:22:46.48,Default,,0,0,0,,我猜这个想法来自APL语言
Dialogue: 0,0:22:46.48,0:22:49.10,Default,,0,0,0,,它是APL中非常重要的思想
Dialogue: 0,0:22:49.12,0:22:51.13,Default,,0,0,0,,即不要去考虑控制结构
Dialogue: 0,0:22:51.41,0:22:53.92,Default,,0,0,0,,而是关注于策略操作
Dialogue: 0,0:22:55.01,0:23:00.01,Default,,0,0,0,,在本课程进行到一半的时候 我们将讨论一种叫做流处理的东西
Dialogue: 0,0:23:00.26,0:23:02.64,Default,,0,0,0,,那时我们将看到这种观点的真正威力
Dialogue: 0,0:23:02.64,0:23:05.30,Default,,0,0,0,,这是一种很聪明的思想
Dialogue: 0,0:23:05.30,0:23:08.70,Default,,0,0,0,,我们可以在以后看到更多应用
Dialogue: 0,0:23:09.36,0:23:16.84,Default,,0,0,0,,还有一些非常有用也非常像MAP的过程
Dialogue: 0,0:23:17.56,0:23:22.54,Default,,0,0,0,,MAP是将某个过程应用于表中每个元素
Dialogue: 0,0:23:22.98,0:23:25.62,Default,,0,0,0,,并返回相应结果构成的表
Dialogue: 0,0:23:25.98,0:23:28.69,Default,,0,0,0,,还有一种与此非常非常相似的操作
Dialogue: 0,0:23:29.32,0:23:35.86,Default,,0,0,0,,也就是给定一个列表和操作 依次将其应用于表中每个元素
Dialogue: 0,0:23:36.29,0:23:39.40,Default,,0,0,0,,而不会建立由结果构成的表 只是为了完成操作
Dialogue: 0,0:23:40.02,0:23:45.10,Default,,0,0,0,,这个过程非常像MAP
Dialogue: 0,0:23:45.10,0:23:46.02,Default,,0,0,0,,它就是FOR-EACH
Dialogue: 0,0:23:46.74,0:23:49.48,Default,,0,0,0,,它接受一个过程和一个表
Dialogue: 0,0:23:49.62,0:23:53.86,Default,,0,0,0,,它实际上是对表中每个元素执行此操作
Dialogue: 0,0:23:55.16,0:23:58.53,Default,,0,0,0,,通常是这样 如果表非空
Dialogue: 0,0:23:59.74,0:24:01.12,Default,,0,0,0,,也就是不为NIL
Dialogue: 0,0:24:01.90,0:24:06.25,Default,,0,0,0,,我将这个过程应用于表的第一个元素
Dialogue: 0,0:24:07.68,0:24:11.66,Default,,0,0,0,,然后对表中其余元素做同样的事情
Dialogue: 0,0:24:12.44,0:24:15.25,Default,,0,0,0,,我将FOR-EACH也应用于表的CDR部分
Dialogue: 0,0:24:15.88,0:24:18.73,Default,,0,0,0,,我对表的首元素进行处理 然后对表其余部分进行处理
Dialogue: 0,0:24:19.32,0:24:23.92,Default,,0,0,0,,当然 以此类推 递归地调用 又会对表其余部分的其余部分做处理
Dialogue: 0,0:24:23.92,0:24:28.12,Default,,0,0,0,,最终 过程结束时 我应该告知系统
Dialogue: 0,0:24:28.16,0:24:32.40,Default,,0,0,0,,所以就返回“DONE” 所以这非常像MAP
Dialogue: 0,0:24:32.80,0:24:35.12,Default,,0,0,0,,它们之间只是返回值不同
Dialogue: 0,0:24:35.48,0:24:39.90,Default,,0,0,0,,比如说 如果我有一个可以在屏幕上打印对象的过程
Dialogue: 0,0:24:40.56,0:24:45.81,Default,,0,0,0,,如果我想打印表中的所有元素 可以调用(FOR-EACH PRINT LIST)
Dialogue: 0,0:24:46.78,0:24:51.33,Default,,0,0,0,,如果我有一系列图表构成的表 想把它们输出在屏幕上
Dialogue: 0,0:24:51.62,0:24:54.86,Default,,0,0,0,,我可以对这个调用(FOR-EACH DISPLAY FIGURES)
Dialogue: 0,0:24:58.18,0:24:59.32,Default,,0,0,0,,有问题么？
Dialogue: 0,0:25:00.62,0:25:04.26,Default,,0,0,0,,学生：除非你明确地指定
Dialogue: 0,0:25:04.30,0:25:07.54,Default,,0,0,0,,Lisp会创建一个你正在处理的对象的新拷贝 是这样么？
Dialogue: 0,0:25:07.54,0:25:09.18,Default,,0,0,0,,教授：对
Dialogue: 0,0:25:09.93,0:25:10.94,Default,,0,0,0,,就是这样
Dialogue: 0,0:25:10.94,0:25:15.14,Default,,0,0,0,,FOR-EACH不创建新列表 它只是对列表的每一个元素进行处理
Dialogue: 0,0:25:15.14,0:25:17.29,Default,,0,0,0,,所以如果你有一堆事情等着做
Dialogue: 0,0:25:18.02,0:25:21.56,Default,,0,0,0,,并且你并不关心这些值 比如打印 绘图
Dialogue: 0,0:25:21.89,0:25:24.60,Default,,0,0,0,,或者在终端中响铃等等
Dialogue: 0,0:25:24.60,0:25:27.64,Default,,0,0,0,,FOR-EACH对表中每个元素做这些事
Dialogue: 0,0:25:28.21,0:25:32.42,Default,,0,0,0,,而MAP其实构建了一个新集合 这个集合也许是你想要用的
Dialogue: 0,0:25:32.42,0:25:34.16,Default,,0,0,0,,这就是它们之间的微妙关系
Dialogue: 0,0:25:34.16,0:25:36.30,Default,,0,0,0,,学生：你能否用FOR-EACH来构造MAP
Dialogue: 0,0:25:36.32,0:25:40.16,Default,,0,0,0,,其中你用类似CONS的操作将表又构造出来了？
Dialogue: 0,0:25:40.18,0:25:44.46,Default,,0,0,0,,教授：某种程度上 我也许可以
Dialogue: 0,0:25:44.46,0:25:49.98,Default,,0,0,0,,我不知道如何随手写出它 但是我可以给一些思路
Dialogue: 0,0:25:50.48,0:25:54.73,Default,,0,0,0,,学生：根据昨天的课程 我认为MAP和FOR-EACH的关键区别在于
Dialogue: 0,0:25:54.73,0:26:00.62,Default,,0,0,0,,它们之中一个是递归的 而另一个不是
Dialogue: 0,0:26:01.24,0:26:03.86,Default,,0,0,0,,教授：是的 关于MAP和FOR-EACH和递归
Dialogue: 0,0:26:03.86,0:26:05.48,Default,,0,0,0,,这个观点很好
Dialogue: 0,0:26:05.48,0:26:13.08,Default,,0,0,0,,我写的MAP过程恰巧是一个递归过程
Dialogue: 0,0:26:13.82,0:26:17.06,Default,,0,0,0,,这是因为 你需要得到处理完表的剩余部分后的值
Dialogue: 0,0:26:17.08,0:26:20.96,Default,,0,0,0,,使其与表的开头部分相连
Dialogue: 0,0:26:21.73,0:26:24.53,Default,,0,0,0,,但是FOR-EACH不需要等待返回值
Dialogue: 0,0:26:24.84,0:26:26.66,Default,,0,0,0,,所以它变成了一个迭代的过程
Dialogue: 0,0:26:26.66,0:26:27.72,Default,,0,0,0,,这不是本质
Dialogue: 0,0:26:27.72,0:26:31.80,Default,,0,0,0,,我可以用迭代的方式定义MAP过程
Dialogue: 0,0:26:31.82,0:26:32.82,Default,,0,0,0,,只是我没那么做
Dialogue: 0,0:26:34.24,0:26:42.90,Default,,0,0,0,,学生：将FOR-EACH用在一个列表的列表上的话 我想这是可行的吧？
Dialogue: 0,0:26:42.90,0:26:48.10,Default,,0,0,0,,它会对这些内部列表的元素进行处理么？
Dialogue: 0,0:26:48.70,0:26:50.40,Default,,0,0,0,,教授：问题是 如果我调用
Dialogue: 0,0:26:50.40,0:26:52.28,Default,,0,0,0,,FOR-EACH或者MAP
Dialogue: 0,0:26:52.81,0:26:55.28,Default,,0,0,0,,参数是一个嵌套有一个表的表
Dialogue: 0,0:26:56.69,0:27:00.60,Default,,0,0,0,,虽然我们还没有讲过这个 但是那是可行的
Dialogue: 0,0:27:01.02,0:27:06.56,Default,,0,0,0,,答案是肯定的 不过我俩对“可行”的定义可能有些不同
Dialogue: 0,0:27:06.86,0:27:10.65,Default,,0,0,0,,来看一下 如果我给你一个表
Dialogue: 0,0:27:12.80,0:27:14.20,Default,,0,0,0,,而在个箭头所指的
Dialogue: 0,0:27:16.06,0:27:21.46,Default,,0,0,0,,不是一个数 而是一个表 或者序对 或者是其它东西
Dialogue: 0,0:27:21.96,0:27:24.54,Default,,0,0,0,,FOR-EACH对表中的每个元素做处理
Dialogue: 0,0:27:24.54,0:27:26.96,Default,,0,0,0,,它会不断地处理表CDR部分
Dialogue: 0,0:27:26.96,0:27:27.20,Default,,0,0,0,,学生：嗯
Dialogue: 0,0:27:27.20,0:27:31.06,Default,,0,0,0,,教授：对FOR-EACH来说 表中的第一个元素就是这个箭头所指的东西
Dialogue: 0,0:27:31.06,0:27:31.65,Default,,0,0,0,,学生：唔
Dialogue: 0,0:27:31.65,0:27:33.94,Default,,0,0,0,,教授：这对于你要完成的任务而言 也许是对的 也许不是
Dialogue: 0,0:27:33.94,0:27:35.57,Default,,0,0,0,,学生：所以不能进入子表中
Dialogue: 0,0:27:35.57,0:27:36.91,Default,,0,0,0,,教授：绝对不能
Dialogue: 0,0:27:36.91,0:27:38.51,Default,,0,0,0,,当然我也可以那样写程序
Dialogue: 0,0:27:38.51,0:27:42.97,Default,,0,0,0,,你所说的是另一种公共模式 叫做树递归
Dialogue: 0,0:27:43.01,0:27:47.94,Default,,0,0,0,,当你给它一个表 它会不断向深度递归 直到遇到所谓的“树叶”
Dialogue: 0,0:27:47.94,0:27:51.05,Default,,0,0,0,,你可以写出来这个过程 但是它既不是FOR-EACH也不是MAP
Dialogue: 0,0:27:52.42,0:27:55.05,Default,,0,0,0,,FOR-EACH和MAP都很简单
Dialogue: 0,0:27:55.77,0:27:56.89,Default,,0,0,0,,好 还有问题么？
Dialogue: 0,0:27:57.68,0:27:58.57,Default,,0,0,0,,好的 大家休息一下吧
Dialogue: 0,0:27:59.11,0:28:10.99,Default,,0,0,0,,[音乐]
Dialogue: 0,0:28:11.46,0:28:14.29,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:28:14.32,0:28:17.52,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:28:27.38,0:28:34.22,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:28:34.86,0:28:38.58,Declare,,0,0,0,,{\an2\fad(500,500)}Henderson-Escher的例子
Dialogue: 0,0:28:41.94,0:28:48.65,Default,,0,0,0,,教授：我将在本节课余下的时间中 讨论一个实例
Dialogue: 0,0:28:50.04,0:28:53.92,Default,,0,0,0,,这个实例 可以充分地总结我们所学的所有东西
Dialogue: 0,0:28:54.74,0:28:56.29,Default,,0,0,0,,比如 表结构
Dialogue: 0,0:28:57.17,0:28:59.48,Default,,0,0,0,,以及抽象的技术
Dialogue: 0,0:28:59.54,0:29:00.82,Default,,0,0,0,,数据的表示
Dialogue: 0,0:29:01.60,0:29:04.60,Default,,0,0,0,,和用高阶过程描绘共性
Dialogue: 0,0:29:04.60,0:29:09.80,Default,,0,0,0,,也会介绍目前为止还没怎么谈论过的
Dialogue: 0,0:29:09.85,0:29:13.46,Default,,0,0,0,,也就是这门课的第三大主题
Dialogue: 0,0:29:13.96,0:29:15.53,Default,,0,0,0,,元语言抽象
Dialogue: 0,0:29:15.54,0:29:21.90,Default,,0,0,0,,这种在工程设计中控制复杂度的思想
Dialogue: 0,0:29:22.86,0:29:25.80,Default,,0,0,0,,也就是建立一个合适而强大的语言
Dialogue: 0,0:29:28.17,0:29:34.74,Default,,0,0,0,,你们或许记得 我说过在这门课程中 你们将要学到的最重要的事情是
Dialogue: 0,0:29:34.74,0:29:41.17,Default,,0,0,0,,当我们考察一门语言时 关心的是它的基本元素
Dialogue: 0,0:29:42.98,0:29:46.69,Default,,0,0,0,,关心它的组合手段
Dialogue: 0,0:29:49.72,0:29:52.80,Default,,0,0,0,,关心那些让你能够构建更大东西的东西
Dialogue: 0,0:29:53.61,0:29:55.24,Default,,0,0,0,,以及 抽象的方式
Dialogue: 0,0:30:00.97,0:30:05.16,Default,,0,0,0,,如何取用这些你构造出来的“大东西”
Dialogue: 0,0:30:05.56,0:30:07.97,Default,,0,0,0,,并将它们放入“黑盒”中
Dialogue: 0,0:30:08.45,0:30:11.71,Default,,0,0,0,,然后用它们来构建更复杂的东西
Dialogue: 0,0:30:13.53,0:30:18.72,Default,,0,0,0,,我将要介绍的一种语言 就是元语言抽象的一个例子
Dialogue: 0,0:30:18.73,0:30:22.70,Default,,0,0,0,,那是我朋友Peter Handerson发明的
Dialogue: 0,0:30:28.24,0:30:31.74,Default,,0,0,0,,他来自苏格兰的Stirling大学
Dialogue: 0,0:30:32.78,0:30:40.98,Default,,0,0,0,,这个语言是用来画这样的图
Dialogue: 0,0:30:41.86,0:30:46.66,Default,,0,0,0,,这是埃舍尔的木版画 《方形极限》
Dialogue: 0,0:30:49.33,0:30:57.94,Default,,0,0,0,,正如大家所见 这里面有着很复杂的...图像的递归
Dialogue: 0,0:30:58.84,0:31:01.46,Default,,0,0,0,,其中中间的鱼形图案以自相似的方式
Dialogue: 0,0:31:01.70,0:31:04.56,Default,,0,0,0,,不断地以更小的形式出现在原来的团案旁边
Dialogue: 0,0:31:08.49,0:31:12.80,Default,,0,0,0,,总之 Peter Hendersion的语言是用来表述这类图形
Dialogue: 0,0:31:13.37,0:31:18.28,Default,,0,0,0,,并且设计类似的图形 将它画在显示器上
Dialogue: 0,0:31:20.24,0:31:27.48,Default,,0,0,0,,这个例子还展示了另外一个主题
Dialogue: 0,0:31:28.09,0:31:32.02,Default,,0,0,0,,这也是我跟Gerry教授多次强调的
Dialogue: 0,0:31:32.02,0:31:36.17,Default,,0,0,0,,也就是过程跟数据之间没有本质的区别
Dialogue: 0,0:31:37.26,0:31:42.40,Default,,0,0,0,,不管如何 我希望今早课程结束后
Dialogue: 0,0:31:42.58,0:31:47.60,Default,,0,0,0,,你们能将过程和数据当作一回事儿
Dialogue: 0,0:31:47.96,0:31:49.58,Default,,0,0,0,,即使现在你们还将它们区别对待
Dialogue: 0,0:31:50.80,0:31:55.28,Default,,0,0,0,,那么 先让我们看一下Peter的语言
Dialogue: 0,0:31:55.28,0:31:57.26,Default,,0,0,0,,我先告诉你们基本元素是什么
Dialogue: 0,0:31:58.29,0:32:00.92,Default,,0,0,0,,这个语言非常简单 因为它的基本元素只有一个
Dialogue: 0,0:32:03.33,0:32:06.30,Default,,0,0,0,,这个基本元素不是大家想象的那样
Dialogue: 0,0:32:07.08,0:32:09.18,Default,,0,0,0,,它唯一的基本元素叫做"图像"
Dialogue: 0,0:32:09.70,0:32:12.11,Default,,0,0,0,,但此“图像”非彼“图像”
Dialogue: 0,0:32:12.11,0:32:14.17,Default,,0,0,0,,具体地来说
Dialogue: 0,0:32:14.17,0:32:15.17,Default,,0,0,0,,这是George的图像
Dialogue: 0,0:32:19.01,0:32:20.37,Default,,0,0,0,,我们的想法是
Dialogue: 0,0:32:22.33,0:32:24.57,Default,,0,0,0,,在这个语言中的图像是这样一个东西
Dialogue: 0,0:32:24.89,0:32:31.46,Default,,0,0,0,,它能在你指定的一个矩形里画出一个缩放好图像
Dialogue: 0,0:32:33.00,0:32:34.42,Default,,0,0,0,,这里大家看到的强调线
Dialogue: 0,0:32:34.42,0:32:37.70,Default,,0,0,0,,是这个矩形的轮廓 但不是图像的一部分
Dialogue: 0,0:32:40.49,0:32:47.17,Default,,0,0,0,,但是一旦指定一个矩形区域 图像会以以填充的方式绘制满区域
Dialogue: 0,0:32:47.17,0:32:52.16,Default,,0,0,0,,比如 这个是George 在这里 这个也是George
Dialogue: 0,0:32:53.21,0:32:56.65,Default,,0,0,0,,它是同一个图像 只是缩放程度不同
Dialogue: 0,0:32:57.40,0:32:59.28,Default,,0,0,0,,这是“胖”George的版本
Dialogue: 0,0:33:00.01,0:33:03.44,Default,,0,0,0,,这个也是George
Dialogue: 0,0:33:03.81,0:33:05.14,Default,,0,0,0,,这是同一个图形
Dialogue: 0,0:33:05.14,0:33:09.57,Default,,0,0,0,,这个语言中 这三个都是同一个图像
Dialogue: 0,0:33:09.58,0:33:13.04,Default,,0,0,0,,仅仅是给了不同的矩形区域让它来填充
Dialogue: 0,0:33:16.08,0:33:20.65,Default,,0,0,0,,这就是基本元素
Dialogue: 0,0:33:21.44,0:33:25.25,Default,,0,0,0,,现在 我们来讨论元素组合和操作
Dialogue: 0,0:33:25.90,0:33:30.17,Default,,0,0,0,,比如 这里有一个叫做旋转的操作
Dialogue: 0,0:33:31.09,0:33:33.66,Default,,0,0,0,,如果我有一个图像 “旋转”操作就是
Dialogue: 0,0:33:35.37,0:33:39.93,Default,,0,0,0,,先假定有一个里面有个“A”的矩形
Dialogue: 0,0:33:41.84,0:33:45.73,Default,,0,0,0,,而旋转90度的操作则会
Dialogue: 0,0:33:47.02,0:33:50.65,Default,,0,0,0,,在一个给定的矩形内 绘制同样的图像
Dialogue: 0,0:33:50.65,0:33:53.88,Default,,0,0,0,,但是 会缩放图像以适应矩形
Dialogue: 0,0:33:56.11,0:33:58.34,Default,,0,0,0,,这个就是旋转90度
Dialogue: 0,0:33:58.34,0:34:03.20,Default,,0,0,0,,另一个操作是“翻转” 可以水平翻转也可以竖直翻转
Dialogue: 0,0:34:04.77,0:34:06.00,Default,,0,0,0,,就是这些操作了
Dialogue: 0,0:34:06.01,0:34:10.40,Default,,0,0,0,,或者你可以把它们认为是组合一个元素的各种方式
Dialogue: 0,0:34:10.89,0:34:12.42,Default,,0,0,0,,我可以把它们混合起来
Dialogue: 0,0:34:13.44,0:34:15.54,Default,,0,0,0,,我们有一种叫BESIDE的操作
Dialogue: 0,0:34:16.46,0:34:24.78,Default,,0,0,0,,它做的事情是 给定两个图像A、B --
Dialogue: 0,0:34:29.02,0:34:33.25,Default,,0,0,0,,这里图像是指能在指定的矩形中画一个图案的东西 --
Dialogue: 0,0:34:34.05,0:34:36.51,Default,,0,0,0,,BESIDE将会做的事情
Dialogue: 0,0:34:37.85,0:34:44.08,Default,,0,0,0,,类似于调用(BESIDE A B S) 其中S是一个数
Dialogue: 0,0:34:45.34,0:34:48.08,Default,,0,0,0,,是一个在0到1之间的数
Dialogue: 0,0:34:50.51,0:34:52.57,Default,,0,0,0,,BESIDE绘制像这样的图像
Dialogue: 0,0:34:52.57,0:34:56.71,Default,,0,0,0,,以给定的矩形为基础 但会将基底缩放S
Dialogue: 0,0:34:56.71,0:34:58.71,Default,,0,0,0,,这里S是0.5
Dialogue: 0,0:35:00.18,0:35:07.17,Default,,0,0,0,,在这里 它会在这里画第一个图案
Dialogue: 0,0:35:07.81,0:35:12.65,Default,,0,0,0,,在这里画第二个图案
Dialogue: 0,0:35:13.82,0:35:16.44,Default,,0,0,0,,又比如说 我另设一个S的值
Dialogue: 0,0:35:16.81,0:35:23.02,Default,,0,0,0,,比如调用(BESIDE A B 0.25)
Dialogue: 0,0:35:25.94,0:35:29.09,Default,,0,0,0,,效果相同 只不过A更瘦了
Dialogue: 0,0:35:34.05,0:35:36.28,Default,,0,0,0,,而B是这样的
Dialogue: 0,0:35:37.82,0:35:40.29,Default,,0,0,0,,这就是组合手段之一：BESIDE
Dialogue: 0,0:35:40.68,0:35:46.05,Default,,0,0,0,,类似地 ABOVE方法在竖直方向上做这种操作
Dialogue: 0,0:35:47.84,0:35:48.89,Default,,0,0,0,,我们来看一下
Dialogue: 0,0:35:50.74,0:35:56.00,Default,,0,0,0,,这是George和他的"弟弟"
Dialogue: 0,0:35:56.72,0:36:07.05,Default,,0,0,0,,这是通过将George放在一旁
Dialogue: 0,0:36:10.36,0:36:14.42,Default,,0,0,0,,George与空图像的上下组合放在另一旁
Dialogue: 0,0:36:14.52,0:36:16.14,Default,,0,0,0,,这样做的意图很明显
Dialogue: 0,0:36:16.14,0:36:19.14,Default,,0,0,0,,空图像放在了另一个George的上面
Dialogue: 0,0:36:19.14,0:36:21.14,Default,,0,0,0,,合成的图像又放在了George的旁边
Dialogue: 0,0:36:28.96,0:36:30.34,Default,,0,0,0,,这个是图像P
Dialogue: 0,0:36:31.10,0:36:39.04,Default,,0,0,0,,像之前一样 是George和翻转后George的BESIDE组合
Dialogue: 0,0:36:40.53,0:36:42.08,Default,,0,0,0,,这里 我们做的是水平翻转
Dialogue: 0,0:36:42.37,0:36:44.80,Default,,0,0,0,,然后整体旋转180度
Dialogue: 0,0:36:45.80,0:36:50.82,Default,,0,0,0,,然后调用BESIDE让它们组合在一起 系数是0.5
Dialogue: 0,0:36:52.56,0:36:53.90,Default,,0,0,0,,这样 我创建了图像P
Dialogue: 0,0:36:55.90,0:36:57.88,Default,,0,0,0,,然后使用图像P
Dialogue: 0,0:36:59.21,0:37:04.96,Default,,0,0,0,,与它的翻转图像做ABOVE操作 形成图像Q
Dialogue: 0,0:37:09.20,0:37:13.26,Default,,0,0,0,,请注意 我们是如何快速地增加复杂度
Dialogue: 0,0:37:14.36,0:37:21.05,Default,,0,0,0,,转瞬之间 我们使用George组合得到了Q 这说明了什么？
Dialogue: 0,0:37:22.05,0:37:24.55,Default,,0,0,0,,为什么我们可以做得如此迅速呢?
Dialogue: 0,0:37:25.85,0:37:28.02,Default,,0,0,0,,答案是闭包性质
Dialogue: 0,0:37:28.69,0:37:32.98,Default,,0,0,0,,这是因为 当我将两个图像做BESIDE操作后
Dialogue: 0,0:37:34.30,0:37:35.29,Default,,0,0,0,,得到的也是图像
Dialogue: 0,0:37:35.33,0:37:37.78,Default,,0,0,0,,我可以继续执行 ROTATE FLIP 或者 ABOVE操作
Dialogue: 0,0:37:39.17,0:37:40.88,Default,,0,0,0,,而操作的结果P
Dialogue: 0,0:37:40.89,0:37:44.88,Default,,0,0,0,,BESIDE FLIP ROTATE操作的结果也是一个图像
Dialogue: 0,0:37:45.22,0:37:50.20,Default,,0,0,0,,在这种组合方法下 图像的世界是封闭的
Dialogue: 0,0:37:50.77,0:37:52.24,Default,,0,0,0,,所以 任何时候我都可以
Dialogue: 0,0:37:52.48,0:37:55.17,Default,,0,0,0,,以一个东西为基本元素 去构造别的东西
Dialogue: 0,0:37:56.33,0:37:58.52,Default,,0,0,0,,这个例子比表和线段更直观
Dialogue: 0,0:37:58.54,0:38:03.28,Default,,0,0,0,,它揭示了 我们如和用封闭的操作 快速增加复杂度
Dialogue: 0,0:38:07.48,0:38:12.02,Default,,0,0,0,,在构建更多东西之前
Dialogue: 0,0:38:12.04,0:38:14.77,Default,,0,0,0,,我们先来看看这个语言是如何实现的
Dialogue: 0,0:38:16.91,0:38:21.50,Default,,0,0,0,,其中基本的一个元素
Dialogue: 0,0:38:21.93,0:38:24.52,Default,,0,0,0,,是一个称作“矩形”的东西
Dialogue: 0,0:38:26.09,0:38:28.28,Default,,0,0,0,,所谓的矩形就是
Dialogue: 0,0:38:28.28,0:38:33.68,Default,,0,0,0,,它有一个原点
Dialogue: 0,0:38:36.45,0:38:40.18,Default,,0,0,0,,原点是一个向量 用以说明矩形是从哪开始
Dialogue: 0,0:38:40.18,0:38:42.29,Default,,0,0,0,,至于其它的向量
Dialogue: 0,0:38:43.66,0:38:46.33,Default,,0,0,0,,我们称其为矩形的水平分量
Dialogue: 0,0:38:55.76,0:38:59.25,Default,,0,0,0,,还有就是矩形的竖直分量
Dialogue: 0,0:39:00.49,0:39:02.68,Default,,0,0,0,,这就是构成矩形的三个基本元素
Dialogue: 0,0:39:02.68,0:39:04.51,Default,,0,0,0,,两个向量用作
Dialogue: 0,0:39:04.93,0:39:09.97,Default,,0,0,0,,计算左上角和右下角的顶点坐标
Dialogue: 0,0:39:09.97,0:39:12.37,Default,,0,0,0,,这三个向量确定了一个矩形
Dialogue: 0,0:39:16.00,0:39:18.93,Default,,0,0,0,,为了构建矩形 我们假设
Dialogue: 0,0:39:19.77,0:39:22.06,Default,,0,0,0,,假设有个“构建矩形”的构造函数
Dialogue: 0,0:39:23.01,0:39:24.26,Default,,0,0,0,,也就是MAKE-RECT
Dialogue: 0,0:39:27.56,0:39:35.17,Default,,0,0,0,,以及选择函数 HORIZ、VERT 和 ORIGIN
Dialogue: 0,0:39:37.58,0:39:39.65,Default,,0,0,0,,用于取得对应的矩形属性
Dialogue: 0,0:39:39.65,0:39:42.54,Default,,0,0,0,,我们知道有很多方法可以实现它
Dialogue: 0,0:39:42.54,0:39:47.62,Default,,0,0,0,,可以用序对或者表 或者其它东西
Dialogue: 0,0:39:47.62,0:39:51.40,Default,,0,0,0,,但是 这些东西的实现是George的事
Dialogue: 0,0:39:51.40,0:39:53.17,Default,,0,0,0,,这是一个数据表示的问题
Dialogue: 0,0:39:53.17,0:39:55.47,Default,,0,0,0,,现在我们假设已经有了这些矩形了
Dialogue: 0,0:39:59.05,0:40:05.08,Default,,0,0,0,,好的 现在来看我们接下来要做的事情
Dialogue: 0,0:40:05.08,0:40:08.22,Default,,0,0,0,,我们需要关心如何取用图像
Dialogue: 0,0:40:09.33,0:40:12.97,Default,,0,0,0,,将它缩放以适应你给定的矩形
Dialogue: 0,0:40:13.60,0:40:16.60,Default,,0,0,0,,我们要来安排这些事
Dialogue: 0,0:40:16.60,0:40:18.60,Default,,0,0,0,,来完成图像的缩放
Dialogue: 0,0:40:22.22,0:40:23.65,Default,,0,0,0,,有哪些思路呢？
Dialogue: 0,0:40:23.65,0:40:27.08,Default,,0,0,0,,一种想法是：无论何时给定一个矩形
Dialogue: 0,0:40:35.68,0:40:38.68,Default,,0,0,0,,无论何时给定一个矩形 也就是说
Dialogue: 0,0:40:39.25,0:40:45.77,Default,,0,0,0,,这在某种意义上是把正方形转换成矩形
Dialogue: 0,0:40:45.77,0:40:46.54,Default,,0,0,0,,也就是说
Dialogue: 0,0:40:46.54,0:40:48.53,Default,,0,0,0,,我所谓的正方形
Dialogue: 0,0:40:49.04,0:40:59.04,Default,,0,0,0,,它的坐标是(0,0)、(1,0)和(1,1)
Dialogue: 0,0:41:01.40,0:41:05.72,Default,,0,0,0,,我们有一些显而易见的缩放变换
Dialogue: 0,0:41:06.12,0:41:10.22,Default,,0,0,0,,可以把这个映射成这个 把这个映射成这个
Dialogue: 0,0:41:10.24,0:41:12.08,Default,,0,0,0,,并且 把所有的东西统一地拉伸
Dialogue: 0,0:41:12.17,0:41:18.25,Default,,0,0,0,,我们将这样的一条的线段
Dialogue: 0,0:41:19.73,0:41:24.20,Default,,0,0,0,,将它最终映射到像那样的一条线段
Dialogue: 0,0:41:26.20,0:41:32.68,Default,,0,0,0,,而点(X,Y)变成了这里的另外一个点
Dialogue: 0,0:41:32.68,0:41:39.37,Default,,0,0,0,,这个不紧要 会点向量运算 就能写出变换公式
Dialogue: 0,0:41:39.37,0:41:43.18,Default,,0,0,0,,初始点(X,Y)将会变换到的点的坐标是
Dialogue: 0,0:41:43.58,0:41:50.74,Default,,0,0,0,,以矩形原点为基础做向量加法
Dialogue: 0,0:41:51.16,0:41:55.48,Default,,0,0,0,,加上 初始点X坐标 一个介于0和1之间的值
Dialogue: 0,0:41:55.98,0:42:01.84,Default,,0,0,0,,并乘上矩形的水平向量
Dialogue: 0,0:42:07.62,0:42:11.00,Default,,0,0,0,,再加上初始点的Y坐标 也是一个介于0和1的值
Dialogue: 0,0:42:11.38,0:42:16.28,Default,,0,0,0,,并乘上矩形的竖直向量
Dialogue: 0,0:42:16.74,0:42:19.31,Default,,0,0,0,,这是简单的线性代数
Dialogue: 0,0:42:19.31,0:42:23.48,Default,,0,0,0,,这个就是正确的变换公式
Dialogue: 0,0:42:23.69,0:42:28.18,Default,,0,0,0,,它将方形中的物件转化到对应矩形中
Dialogue: 0,0:42:31.34,0:42:34.02,Default,,0,0,0,,现在 我们把它看作是一个过程
Dialogue: 0,0:42:35.16,0:42:36.29,Default,,0,0,0,,我们想要得到的是
Dialogue: 0,0:42:37.80,0:42:40.82,Default,,0,0,0,,由一个单位正方形到特定矩形的
Dialogue: 0,0:42:41.01,0:42:42.52,Default,,0,0,0,,特定变换过程
Dialogue: 0,0:42:43.80,0:42:45.22,Default,,0,0,0,,这个过程具体是这样的
Dialogue: 0,0:42:45.22,0:42:47.22,Default,,0,0,0,,我叫它COORD-MAP
Dialogue: 0,0:42:47.77,0:42:52.00,Default,,0,0,0,,COORD-MAP以一个矩形作为参数
Dialogue: 0,0:42:53.60,0:42:57.85,Default,,0,0,0,,它返回一个以点为参数的过程
Dialogue: 0,0:43:00.45,0:43:06.82,Default,,0,0,0,,每个矩形 都对应一个变换点(X, Y)坐标的过程
Dialogue: 0,0:43:06.82,0:43:08.02,Default,,0,0,0,,是怎么得到的呢？
Dialogue: 0,0:43:08.02,0:43:10.92,Default,,0,0,0,,就如黑板上的Lisp代码所示
Dialogue: 0,0:43:10.92,0:43:16.01,Default,,0,0,0,,我让矩形的原点加上——
Dialogue: 0,0:43:20.22,0:43:25.02,Default,,0,0,0,,首先是 矩形水平部分
Dialogue: 0,0:43:25.02,0:43:27.68,Default,,0,0,0,,按照点POINT的X坐标缩放
Dialogue: 0,0:43:29.65,0:43:32.62,Default,,0,0,0,,然后是 矩形竖直部分
Dialogue: 0,0:43:33.51,0:43:37.14,Default,,0,0,0,,按照点POINT的Y坐标缩放
Dialogue: 0,0:43:37.14,0:43:39.14,Default,,0,0,0,,然后把它们三个加到一起
Dialogue: 0,0:43:40.13,0:43:41.34,Default,,0,0,0,,这个过程就是这样
Dialogue: 0,0:43:41.34,0:43:44.54,Default,,0,0,0,,这就是我将要应用在点POINT上的过程
Dialogue: 0,0:43:46.54,0:43:52.17,Default,,0,0,0,,这个过程由每个矩形自己生成
Dialogue: 0,0:43:52.17,0:43:57.25,Default,,0,0,0,,每个矩形对应了一个定义在点集上的过程 COORD-MAP
Dialogue: 0,0:44:06.66,0:44:10.42,Default,,0,0,0,,比如说 这里的George
Dialogue: 0,0:44:11.36,0:44:16.34,Default,,0,0,0,,最初的George 可能是我在单位正方形中通过线段绘制的
Dialogue: 0,0:44:19.50,0:44:21.96,Default,,0,0,0,,而当我把它应用到一个新的矩形中
Dialogue: 0,0:44:24.14,0:44:28.17,Default,,0,0,0,,我将会在新矩形中画出组成George的那些线段来
Dialogue: 0,0:44:28.17,0:44:29.88,Default,,0,0,0,,我是怎么做的呢？
Dialogue: 0,0:44:30.68,0:44:36.94,Default,,0,0,0,,我枚举原始George中的每条线段
Dialogue: 0,0:44:38.64,0:44:40.58,Default,,0,0,0,,我对每条线段的终点
Dialogue: 0,0:44:40.88,0:44:44.45,Default,,0,0,0,,应用目标矩形对应的COORD-MAP过程
Dialogue: 0,0:44:44.45,0:44:46.06,Default,,0,0,0,,比如下面的这个矩形
Dialogue: 0,0:44:46.66,0:44:50.88,Default,,0,0,0,,这个胖George 有它对应的COORD-MAP
Dialogue: 0,0:44:51.25,0:44:53.69,Default,,0,0,0,,如果我要绘制这个图像
Dialogue: 0,0:44:55.38,0:44:57.92,Default,,0,0,0,,需要做的就是对这里的每条线段 比如这条
Dialogue: 0,0:44:59.29,0:45:05.34,Default,,0,0,0,,用COORD-MAP变换这个点 同时变换这个点
Dialogue: 0,0:45:05.34,0:45:07.09,Default,,0,0,0,,我就得到了这两个点
Dialogue: 0,0:45:07.38,0:45:08.94,Default,,0,0,0,,就可以将在两点之间画线
Dialogue: 0,0:45:09.71,0:45:11.52,Default,,0,0,0,,这就是核心思路
Dialogue: 0,0:45:12.66,0:45:14.78,Default,,0,0,0,,那么如果我给一个不同的矩形 比如这个
Dialogue: 0,0:45:14.80,0:45:15.76,Default,,0,0,0,,得到的是不同的COORD-MAP
Dialogue: 0,0:45:15.79,0:45:17.84,Default,,0,0,0,,因此我得到这些线段的不同图像
Dialogue: 0,0:45:19.28,0:45:22.14,Default,,0,0,0,,基本图像又该如何表示呢？
Dialogue: 0,0:45:22.14,0:45:26.52,Default,,0,0,0,,可以用线段组成的表来表示
Dialogue: 0,0:45:27.61,0:45:32.20,Default,,0,0,0,,这是用于构建我所谓的“基本图像”的过程
Dialogue: 0,0:45:33.48,0:45:37.17,Default,,0,0,0,,意思是 没有用BESIDE ROTATE等操作
Dialogue: 0,0:45:37.52,0:45:39.60,Default,,0,0,0,,它以由线段组成的表为参数
Dialogue: 0,0:45:42.94,0:45:44.04,Default,,0,0,0,,代码具体行为如下
Dialogue: 0,0:45:44.04,0:45:45.58,Default,,0,0,0,,图像会是什么样子呢？
Dialogue: 0,0:45:45.58,0:45:49.44,Default,,0,0,0,,首先 它是一个根据矩形定义的过程
Dialogue: 0,0:45:51.70,0:45:53.00,Default,,0,0,0,,这个过程做什么呢？
Dialogue: 0,0:45:53.00,0:45:56.56,Default,,0,0,0,,对于由线段组成的表中每个元素
Dialogue: 0,0:45:57.66,0:46:03.38,Default,,0,0,0,,表中的每条线段S
Dialogue: 0,0:46:05.89,0:46:07.30,Default,,0,0,0,,都绘制了一条线
Dialogue: 0,0:46:07.30,0:46:08.82,Default,,0,0,0,,它画什么样的线段呢？
Dialogue: 0,0:46:10.60,0:46:12.84,Default,,0,0,0,,先得到线段的起点
Dialogue: 0,0:46:15.22,0:46:17.94,Default,,0,0,0,,用对应的COORD-MAP对其做变换
Dialogue: 0,0:46:19.54,0:46:21.76,Default,,0,0,0,,这是我们想要的第一个点
Dialogue: 0,0:46:21.76,0:46:26.32,Default,,0,0,0,,然后对线段终点做COORD-MAP操作
Dialogue: 0,0:46:26.69,0:46:27.92,Default,,0,0,0,,并将两点连线
Dialogue: 0,0:46:27.92,0:46:30.84,Default,,0,0,0,,我们假设在屏幕上绘制线段是基本操作
Dialogue: 0,0:46:31.09,0:46:33.22,Default,,0,0,0,,已经在系统中实现了
Dialogue: 0,0:46:33.96,0:46:37.10,Default,,0,0,0,,通过COORD-MAP变换了线段终点
Dialogue: 0,0:46:37.13,0:46:38.20,Default,,0,0,0,,再把起点和终点连线
Dialogue: 0,0:46:39.61,0:46:44.12,Default,,0,0,0,,对表中每一条线段S都执行这样的操作
Dialogue: 0,0:46:45.96,0:46:51.40,Default,,0,0,0,,请注意 图像就是一个以矩形为参数的过程
Dialogue: 0,0:46:51.40,0:46:55.65,Default,,0,0,0,,所以当你给图像一个矩形时 它就像这样绘制线段
Dialogue: 0,0:46:57.17,0:47:01.10,Default,,0,0,0,,那好 我应该如何使用它呢？
Dialogue: 0,0:47:01.22,0:47:04.08,Default,,0,0,0,,我来说得具体一点
Dialogue: 0,0:47:05.60,0:47:24.22,Default,,0,0,0,,就比如说 (DEFINE R (MAKE-RECT ...))
Dialogue: 0,0:47:24.50,0:47:28.66,Default,,0,0,0,,这里需要用MAKE-VECTOR来构造一些向量
Dialogue: 0,0:47:29.84,0:47:46.18,Default,,0,0,0,,然后定义G为 (DEFINE G (MAKE-PICT ...))
Dialogue: 0,0:47:46.68,0:47:55.28,Default,,0,0,0,,我要在这里使用MAKE-SEGMENT来构建线段组成的表
Dialogue: 0,0:47:55.28,0:47:58.70,Default,,0,0,0,,MAKE-SEGMENT由向量构成 向量由点构成
Dialogue: 0,0:47:59.50,0:48:04.60,Default,,0,0,0,,如果我想在一个矩形中呈现图像G
Dialogue: 0,0:48:04.65,0:48:11.72,Default,,0,0,0,,注意 图像是一个过程 它接受一个矩形作为参数
Dialogue: 0,0:48:12.06,0:48:16.37,Default,,0,0,0,,所以 如果我调用(G R)
Dialogue: 0,0:48:17.96,0:48:23.25,Default,,0,0,0,,那么无论G是什么 都会在矩形R中绘制出来
Dialogue: 0,0:48:23.62,0:48:25.62,Default,,0,0,0,,这就是我们如何使用它
Dialogue: 0,0:48:26.86,0:48:36.29,Default,,0,0,0,,[音乐]
Dialogue: 0,0:48:36.29,0:48:39.78,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:48:39.82,0:48:43.54,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:48:51.28,0:48:55.45,Declare,,0,0,0,,{\an2\fad(500,500)}《计算机程序的构造和解释》
Dialogue: 0,0:48:55.50,0:48:58.73,Declare,,0,0,0,,{\an2\fad(500,500)}讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
Dialogue: 0,0:48:59.34,0:49:03.02,Declare,,0,0,0,,{\an2\fad(500,500)}Henderson-Escher的例子
Dialogue: 0,0:49:07.72,0:49:12.48,Default,,0,0,0,,教授：为什么我说这个例子很好呢？
Dialogue: 0,0:49:12.48,0:49:13.74,Default,,0,0,0,,也许你们不这么认为
Dialogue: 0,0:49:13.74,0:49:15.42,Default,,0,0,0,,你们可能觉得它很奇怪
Dialogue: 0,0:49:15.42,0:49:20.92,Default,,0,0,0,,用来矩形做复杂变换的过程来表示图像 确实奇怪
Dialogue: 0,0:49:20.92,0:49:22.72,Default,,0,0,0,,那么 它好在哪里呢？
Dialogue: 0,0:49:25.36,0:49:26.69,Default,,0,0,0,,原因就是
Dialogue: 0,0:49:27.22,0:49:30.40,Default,,0,0,0,,一旦你按这种方法实现了基本元素
Dialogue: 0,0:49:30.97,0:49:35.20,Default,,0,0,0,,组合的手段就是构造Lisp过程
Dialogue: 0,0:49:35.98,0:49:37.48,Default,,0,0,0,,我给你们演示一下
Dialogue: 0,0:49:37.48,0:49:39.02,Default,,0,0,0,,假设我想实现BESIDE
Dialogue: 0,0:49:41.56,0:49:47.36,Default,,0,0,0,,我要做的是 假设有个叫P1的图像
Dialogue: 0,0:49:47.36,0:49:50.62,Default,,0,0,0,,一定要记得：图像本质上是一个过程
Dialogue: 0,0:49:50.62,0:49:54.82,Default,,0,0,0,,当你传递给它一个矩形
Dialogue: 0,0:49:56.52,0:50:01.46,Default,,0,0,0,,它会在你给定的矩形中绘制图形
Dialogue: 0,0:50:03.46,0:50:09.26,Default,,0,0,0,,假设P2是另一个图像 你传递给它一个矩形
Dialogue: 0,0:50:09.74,0:50:12.44,Default,,0,0,0,,无论给它什么矩形 它都会绘制一些图案
Dialogue: 0,0:50:14.84,0:50:26.60,Default,,0,0,0,,现在 我想实现(BESIDE P1 P2 A) A是缩放因子
Dialogue: 0,0:50:27.04,0:50:28.38,Default,,0,0,0,,会得到什么呢？
Dialogue: 0,0:50:28.38,0:50:29.34,Default,,0,0,0,,我们会得到一个图像
Dialogue: 0,0:50:29.92,0:50:33.88,Default,,0,0,0,,也就是说你传给它一个矩形 它就会在其中绘图
Dialogue: 0,0:50:34.77,0:50:37.18,Default,,0,0,0,,如果我们在一个矩形中执行BESIDE操作
Dialogue: 0,0:50:38.58,0:50:40.12,Default,,0,0,0,,比如这个矩形
Dialogue: 0,0:50:41.50,0:50:42.74,Default,,0,0,0,,要做什么呢？
Dialogue: 0,0:50:42.76,0:50:46.36,Default,,0,0,0,,一部分比例是A 另一部分是1-A
Dialogue: 0,0:50:49.29,0:50:51.57,Default,,0,0,0,,一部分比例是A 另一部分是1-A
Dialogue: 0,0:50:52.65,0:50:55.12,Default,,0,0,0,,现在 我们就有了两个矩形
Dialogue: 0,0:51:02.34,0:51:06.54,Default,,0,0,0,,然后先让P1在这个矩形中绘制
Dialogue: 0,0:51:07.36,0:51:11.64,Default,,0,0,0,,然后让P2在这个矩形中绘制
Dialogue: 0,0:51:13.28,0:51:16.88,Default,,0,0,0,,BESIDE仅仅需要计算出这些矩形来
Dialogue: 0,0:51:17.36,0:51:23.97,Default,,0,0,0,,由于矩形是由原点、水平向量和竖直向量组成
Dialogue: 0,0:51:23.98,0:51:25.94,Default,,0,0,0,,BESIDE操作需要计算出这些要素
Dialogue: 0,0:51:27.37,0:51:32.29,Default,,0,0,0,,所以对第一个矩形来说 原点变成了矩形的原点
Dialogue: 0,0:51:33.64,0:51:37.80,Default,,0,0,0,,竖直向量与原矩形相同 不发生变化
Dialogue: 0,0:51:38.89,0:51:46.60,Default,,0,0,0,,水平向量是原始矩形的水平向量缩放A倍得到的
Dialogue: 0,0:51:47.49,0:51:48.90,Default,,0,0,0,,这就是第一个矩形
Dialogue: 0,0:51:49.46,0:51:52.69,Default,,0,0,0,,第二个矩形的原点是
Dialogue: 0,0:51:54.06,0:51:59.65,Default,,0,0,0,,原矩形的原点加上矩形的水平向量缩放A倍
Dialogue: 0,0:52:01.20,0:52:03.40,Default,,0,0,0,,第二个矩形的水平向量是
Dialogue: 0,0:52:03.77,0:52:06.04,Default,,0,0,0,,除去前一个矩形水平向量所余下的部分
Dialogue: 0,0:52:06.34,0:52:11.66,Default,,0,0,0,,也就是(1-A)*H H是原矩形的水平向量
Dialogue: 0,0:52:12.05,0:52:13.77,Default,,0,0,0,,它的竖直向量还是V
Dialogue: 0,0:52:15.48,0:52:17.98,Default,,0,0,0,,基本上 BESIDE就是构造这两个矩形
Dialogue: 0,0:52:18.00,0:52:20.57,Default,,0,0,0,,但重要的是 一旦构造好这些矩形
Dialogue: 0,0:52:20.93,0:52:24.58,Default,,0,0,0,,它就能让P1、P2在正确的位置绘制
Dialogue: 0,0:52:24.62,0:52:26.18,Default,,0,0,0,,这就是BESIDE需要做的全部工作
Dialogue: 0,0:52:27.80,0:52:29.30,Default,,0,0,0,,我们看一下代码
Dialogue: 0,0:52:34.33,0:52:35.13,Default,,0,0,0,,这是BESIDE
Dialogue: 0,0:52:39.64,0:52:46.44,Default,,0,0,0,,(BESIDE P1 P2 A) A是缩放比例
Dialogue: 0,0:52:47.84,0:52:53.64,Default,,0,0,0,,因为该过程返回图像 所以结果是一个以矩形为参数的过程
Dialogue: 0,0:52:55.49,0:52:56.56,Default,,0,0,0,,它做什么呢？
Dialogue: 0,0:52:56.76,0:53:02.32,Default,,0,0,0,,它让P1在某个矩形中绘制 P2在另一个矩形中绘制
Dialogue: 0,0:53:03.21,0:53:04.46,Default,,0,0,0,,现在这些矩形又是什么呢?
Dialogue: 0,0:53:04.46,0:53:05.48,Default,,0,0,0,,就在这里计算
Dialogue: 0,0:53:05.48,0:53:06.54,Default,,0,0,0,,它创建了一个矩形
Dialogue: 0,0:53:07.52,0:53:10.40,Default,,0,0,0,,用的是我刚才在黑板上写的几何公式 这是矩形的原点
Dialogue: 0,0:53:10.40,0:53:11.84,Default,,0,0,0,,矩形的水平向量
Dialogue: 0,0:53:11.84,0:53:13.44,Default,,0,0,0,,还有矩形的竖直向量
Dialogue: 0,0:53:13.97,0:53:14.81,Default,,0,0,0,,对于P2
Dialogue: 0,0:53:15.50,0:53:19.78,Default,,0,0,0,,矩形需要不同的原点 水平向量和竖直向量
Dialogue: 0,0:53:19.78,0:53:20.70,Default,,0,0,0,,但重要的是
Dialogue: 0,0:53:21.21,0:53:27.18,Default,,0,0,0,,BESIDE只是将这两个矩形分别传递给了P1和P2而已
Dialogue: 0,0:53:27.74,0:53:29.42,Default,,0,0,0,,这就是BESIDE所需要做的
Dialogue: 0,0:53:30.84,0:53:35.62,Default,,0,0,0,,好 ROTATE也很类似
Dialogue: 0,0:53:36.96,0:53:42.00,Default,,0,0,0,,假设我有一个图像A
Dialogue: 0,0:53:42.97,0:53:46.12,Default,,0,0,0,,我想让它旋转90度
Dialogue: 0,0:53:46.37,0:53:51.92,Default,,0,0,0,,这意味着 给定这个矩形
Dialogue: 0,0:53:53.94,0:53:58.44,Default,,0,0,0,,它有原点、水平向量和竖直向量
Dialogue: 0,0:53:58.78,0:54:03.18,Default,,0,0,0,,现在假设已经有了这样的矩形
Dialogue: 0,0:54:03.74,0:54:09.12,Default,,0,0,0,,这个矩形的原点、水平向量和竖直向量在这里
Dialogue: 0,0:54:09.60,0:54:12.46,Default,,0,0,0,,然后在矩形里各自绘制自己
Dialogue: 0,0:54:13.26,0:54:15.04,Default,,0,0,0,,我们来看看代码
Dialogue: 0,0:54:17.02,0:54:19.85,Default,,0,0,0,,那么 ROTATE90过程
Dialogue: 0,0:54:20.61,0:54:22.96,Default,,0,0,0,,返回的也是一个以矩形为参数的过程
Dialogue: 0,0:54:23.25,0:54:26.12,Default,,0,0,0,,它就是将图像绘制在一个特定矩形中
Dialogue: 0,0:54:27.21,0:54:30.66,Default,,0,0,0,,这个几何公式就是这个矩形的变换规则
Dialogue: 0,0:54:30.66,0:54:33.84,Default,,0,0,0,,这句代码让矩形看起来像向侧面的
Dialogue: 0,0:54:33.86,0:54:36.52,Default,,0,0,0,,原点在别的地方 竖直向量在别的地方
Dialogue: 0,0:54:37.13,0:54:39.74,Default,,0,0,0,,水平向量在别的地方 竖直向量在别的地方
Dialogue: 0,0:54:46.76,0:54:49.90,Default,,0,0,0,,再次注意 这里的关键是
Dialogue: 0,0:54:50.53,0:55:00.97,Default,,0,0,0,,关键是使用过程来表示图像 使其自动地具有闭包性质
Dialogue: 0,0:55:01.74,0:55:05.22,Default,,0,0,0,,这是因为 实际上 BESIDE只是接受并使用P1
Dialogue: 0,0:55:05.22,0:55:09.40,Default,,0,0,0,,BESIDE并不关心它是一个基本图像还是一些线段
Dialogue: 0,0:55:09.61,0:55:12.69,Default,,0,0,0,,或者P1还是ABOVE、BESIDE、ROTATE等操作的结果
Dialogue: 0,0:55:12.72,0:55:16.08,Default,,0,0,0,,关于P1 BESIDE需要知道的就是
Dialogue: 0,0:55:16.29,0:55:19.73,Default,,0,0,0,,给P1传递一个矩形 就会导致某物的绘制
Dialogue: 0,0:55:21.04,0:55:25.98,Default,,0,0,0,,在这个层面上 BESIDE并不关心P1是如何完成绘制
Dialogue: 0,0:55:27.73,0:55:32.25,Default,,0,0,0,,我们使用过程来表示图像 以保持它的闭包性质
Dialogue: 0,0:55:35.64,0:55:40.81,Default,,0,0,0,,将图像实现为过程 使得组合的方法变得
Dialogue: 0,0:55:41.18,0:55:43.93,Default,,0,0,0,,变得简单而优雅
Dialogue: 0,0:55:45.92,0:55:48.22,Default,,0,0,0,,但这并不是点睛之笔
Dialogue: 0,0:55:49.28,0:55:53.52,Default,,0,0,0,,点睛之笔来自于这门语言中抽象的方法
Dialogue: 0,0:55:54.70,0:55:56.24,Default,,0,0,0,,我们做了些什么？
Dialogue: 0,0:55:56.24,0:56:03.72,Default,,0,0,0,,我们把组合的方法实现为了过程
Dialogue: 0,0:56:05.85,0:56:09.38,Default,,0,0,0,,这也就意味着 当我们对这个语言进行抽象时
Dialogue: 0,0:56:10.17,0:56:15.69,Default,,0,0,0,,Lisp提供的 操作过程的一切方法
Dialogue: 0,0:56:16.33,0:56:21.45,Default,,0,0,0,,都可以自动地在这个图像语言中使用
Dialogue: 0,0:56:21.92,0:56:29.74,Default,,0,0,0,,与其用术语“这个语言以Lisp实现” — 虽然确实如此
Dialogue: 0,0:56:29.76,0:56:32.58,Default,,0,0,0,,我想描述为“这个语言嵌入于Lisp”
Dialogue: 0,0:56:37.64,0:56:42.08,Default,,0,0,0,,也就是说 通过像这样将语言嵌入
Dialogue: 0,0:56:42.90,0:56:48.86,Default,,0,0,0,,可以以扩展的形式 自动地获得Lisp的所有力量
Dialogue: 0,0:56:50.06,0:56:51.68,Default,,0,0,0,,这又是什么意思呢？
Dialogue: 0,0:56:51.97,0:57:02.94,Default,,0,0,0,,举个例子 假设我想用A B C D四副图像做东西
Dialogue: 0,0:57:03.76,0:57:07.06,Default,,0,0,0,,让它们呈现像这样的格局
Dialogue: 0,0:57:12.50,0:57:16.96,Default,,0,0,0,,可以将其称为FOUR-PICT格局
Dialogue: 0,0:57:16.96,0:57:17.70,Default,,0,0,0,,我该如何做呢？
Dialogue: 0,0:57:17.70,0:57:18.68,Default,,0,0,0,,我可以很容易的做到这些
Dialogue: 0,0:57:18.68,0:57:23.33,Default,,0,0,0,,写个过程 让B和D做ABOVE
Dialogue: 0,0:57:24.13,0:57:25.85,Default,,0,0,0,,A和C做ABOVE
Dialogue: 0,0:57:26.09,0:57:27.70,Default,,0,0,0,,得到的结果做BESIDE
Dialogue: 0,0:57:28.24,0:57:31.82,Default,,0,0,0,,我自然地拥有Lisp组合过程的能力
Dialogue: 0,0:57:32.92,0:57:35.82,Default,,0,0,0,,这不需要我为图像语言做些特殊处理
Dialogue: 0,0:57:35.82,0:57:39.92,Default,,0,0,0,,事实上 这些组合本身就是过程
Dialogue: 0,0:57:40.96,0:57:44.18,Default,,0,0,0,,假设我想做一些更复杂的事情
Dialogue: 0,0:57:44.18,0:57:46.50,Default,,0,0,0,,我想为这里的每一个传递一个参数
Dialogue: 0,0:57:46.52,0:57:50.08,Default,,0,0,0,,我可以独立地做旋转90度的操作
Dialogue: 0,0:57:50.41,0:57:52.64,Default,,0,0,0,,这只需要我在这个过程中加入一个参数
Dialogue: 0,0:57:53.17,0:57:54.56,Default,,0,0,0,,它自然而然就有了这样的功能
Dialogue: 0,0:57:54.80,0:57:57.84,Default,,0,0,0,,它自动地嵌入进去了
Dialogue: 0,0:57:58.16,0:58:05.36,Default,,0,0,0,,甚至 假设我想使用递归
Dialogue: 0,0:58:06.16,0:58:10.78,Default,,0,0,0,,我们看一下图像递归组合的方法
Dialogue: 0,0:58:10.78,0:58:14.64,Default,,0,0,0,,定义--看看你们能理解这个不
Dialogue: 0,0:58:14.69,0:58:18.97,Default,,0,0,0,,(DEFINE (RIGHT-PUSH PICT N A))
Dialogue: 0,0:58:22.84,0:58:29.80,Default,,0,0,0,,RIGHT-PUSH需要图片P 整数N和缩放因数A
Dialogue: 0,0:58:31.46,0:58:41.22,Default,,0,0,0,,定义是：如果N为0 那么返回图像P
Dialogue: 0,0:58:42.20,0:58:54.02,Default,,0,0,0,,否则 就-- 哦 这里是P
Dialogue: 0,0:58:55.88,0:59:00.21,Default,,0,0,0,,否则 我用图形P做BESIDE操作
Dialogue: 0,0:59:00.92,0:59:18.30,Default,,0,0,0,,BESIDE的另一个操作数是(RIGHT-PUSH P (- N 1) A)的结果
Dialogue: 0,0:59:24.72,0:59:31.12,Default,,0,0,0,,如果N为0 就返回P 否则就对P进行A倍缩放
Dialogue: 0,0:59:31.12,0:59:32.80,Default,,0,0,0,,抱歉 我这里代码没对齐
Dialogue: 0,0:59:33.66,0:59:38.50,Default,,0,0,0,,递归地调用(RIGHT-PUSH P (- N 1) A) 将结果用BESIDE连接
Dialogue: 0,0:59:38.50,0:59:42.00,Default,,0,0,0,,这就是一种递归组合方法
Dialogue: 0,0:59:43.78,0:59:44.76,Default,,0,0,0,,调用的结果会是怎样的？
Dialogue: 0,0:59:44.76,0:59:45.90,Default,,0,0,0,,我们来看看
Dialogue: 0,0:59:46.04,0:59:56.04,Default,,0,0,0,,这是(RIGHT-PUSH GEORGE 2 0.75)的结果
Dialogue: 0,0:59:59.26,1:00:00.72,Default,,0,0,0,,这个是从什么地方来的呢？
Dialogue: 0,1:00:00.72,1:00:02.34,Default,,0,0,0,,我是如何想象出这些递归来的呢？
Dialogue: 0,1:00:02.34,1:00:05.24,Default,,0,0,0,,答案是无意识的 绝对是无意识的
Dialogue: 0,1:00:05.24,1:00:09.80,Default,,0,0,0,,由于它们都是过程 而嵌入的目标系统中允许定义递归过程
Dialogue: 0,1:00:10.36,1:00:11.68,Default,,0,0,0,,我不必自己去做
Dialogue: 0,1:00:13.56,1:00:16.42,Default,,0,0,0,,当然 我们可以模仿这个方法做些更复杂的事
Dialogue: 0,1:00:16.42,1:00:18.21,Default,,0,0,0,,我可以定义做UP-PUSH的过程
Dialogue: 0,1:00:18.42,1:00:22.60,Default,,0,0,0,,对 它可以递归地把图片放在原来的上面
Dialogue: 0,1:00:22.60,1:00:26.54,Default,,0,0,0,,我也可以用这种策略来做些其它事
Dialogue: 0,1:00:26.56,1:00:28.85,Default,,0,0,0,,给定一个图像
Dialogue: 0,1:00:29.78,1:00:37.16,Default,,0,0,0,,然后递归地把它放在原图片的旁边和上面
Dialogue: 0,1:00:37.57,1:00:38.92,Default,,0,0,0,,这里再放一些别的
Dialogue: 0,1:00:39.52,1:00:41.82,Default,,0,0,0,,然后我把同样递归的图像放在这里
Dialogue: 0,1:00:42.36,1:00:44.20,Default,,0,0,0,,我可以用这个来终止
Dialogue: 0,1:00:45.40,1:00:52.50,Default,,0,0,0,,这个过程比RIGHT-PUSH复杂一点 但也不算太多
Dialogue: 0,1:00:53.64,1:00:58.14,Default,,0,0,0,,在BESIDE的基础上 我多加了一个ABOVE操作
Dialogue: 0,1:01:01.12,1:01:06.78,Default,,0,0,0,,如果我把它应用于四张放在一起的图像上
Dialogue: 0,1:01:07.53,1:01:08.65,Default,,0,0,0,,这样做当然没问题
Dialogue: 0,1:01:09.01,1:01:14.17,Default,,0,0,0,,我把它应用于我们之前定义的Q上
Dialogue: 0,1:01:15.97,1:01:18.73,Default,,0,0,0,,我得到的是这个玩意儿
Dialogue: 0,1:01:20.14,1:01:25.26,Default,,0,0,0,,"图像Q的方形极限" 做了两次
Dialogue: 0,1:01:28.18,1:01:32.25,Default,,0,0,0,,好 现在我们将其与Escher的"方形极限"对比一下
Dialogue: 0,1:01:32.88,1:01:34.53,Default,,0,0,0,,可以看到 这都是基于同样的思想
Dialogue: 0,1:01:34.74,1:01:36.94,Default,,0,0,0,,当然 Escher的图像更加漂亮一些
Dialogue: 0,1:01:36.94,1:01:44.04,Default,,0,0,0,,如果我们回过头审视George
Dialogue: 0,1:01:44.38,1:01:47.37,Default,,0,0,0,,我最开始用的是非常随意的设计
Dialogue: 0,1:01:47.42,1:01:49.26,Default,,0,0,0,,用了George的图像 做了一些操作
Dialogue: 0,1:01:51.22,1:01:53.14,Default,,0,0,0,,我们再看看Escher的图片
Dialogue: 0,1:01:54.08,1:01:56.14,Default,,0,0,0,,Escher的图片不是随意设计的
Dialogue: 0,1:01:56.14,1:01:57.66,Default,,0,0,0,,这个图案非常精妙
Dialogue: 0,1:01:57.89,1:02:00.20,Default,,0,0,0,,当我们把鱼身
Dialogue: 0,1:02:01.82,1:02:04.97,Default,,0,0,0,,把鱼身旋转并放缩 就会优美地变成下一条鱼
Dialogue: 0,1:02:07.40,1:02:11.48,Default,,0,0,0,,当然我没有刻意处理过George
Dialogue: 0,1:02:12.12,1:02:13.90,Default,,0,0,0,,就图像George来说
Dialogue: 0,1:02:15.41,1:02:18.64,Default,,0,0,0,,也有一些地方匹配 但不够好 比较随意
Dialogue: 0,1:02:18.64,1:02:21.53,Default,,0,0,0,,顺便说下 一个好的程序
Dialogue: 0,1:02:22.30,1:02:27.54,Default,,0,0,0,,应该有个过程 能接受像这里George一样的基本图像
Dialogue: 0,1:02:27.86,1:02:29.62,Default,,0,0,0,,然后调整其中的线段终点
Dialogue: 0,1:02:29.86,1:02:31.20,Default,,0,0,0,,这样可以得到一个好看的图像
Dialogue: 0,1:02:32.13,1:02:34.06,Default,,0,0,0,,在做“方形极限”应该注意这些
Dialogue: 0,1:02:34.68,1:02:36.30,Default,,0,0,0,,这是一个非常值得思考的事情
Dialogue: 0,1:02:38.08,1:02:39.72,Default,,0,0,0,,同时 我还可以进行组合
Dialogue: 0,1:02:39.72,1:02:41.04,Default,,0,0,0,,我们还可以使用递归过程
Dialogue: 0,1:02:41.04,1:02:43.48,Default,,0,0,0,,我们可以自然而然地做任何事情
Dialogue: 0,1:02:44.60,1:02:48.52,Default,,0,0,0,,重点在于 在语言中实际实现另一个语言
Dialogue: 0,1:02:48.69,1:02:50.44,Default,,0,0,0,,在语言中嵌入另一个语言的差异
Dialogue: 0,1:02:50.44,1:02:53.72,Default,,0,0,0,,这可以让你不丢失原有语言的能力 而Lisp强大之处在于
Dialogue: 0,1:02:54.76,1:02:57.62,Default,,0,0,0,,Lisp是一个强悍的语言 可以处理任何特定问题
Dialogue: 0,1:02:57.62,1:03:02.10,Default,,0,0,0,,把你想要的语言嵌入到Lisp中才是真的好
Dialogue: 0,1:03:02.10,1:03:05.44,Default,,0,0,0,,这才是这种设计方法的真正力量
Dialogue: 0,1:03:05.69,1:03:06.82,Default,,0,0,0,,我们可以深入一下
Dialogue: 0,1:03:06.82,1:03:08.81,Default,,0,0,0,,在Lisp中我们还可以做些其它的事
Dialogue: 0,1:03:09.21,1:03:17.52,Default,,0,0,0,,就是将通用方法抽象成高阶过程
Dialogue: 0,1:03:19.09,1:03:22.57,Default,,0,0,0,,在我画那些图像时 你们可能已经发现
Dialogue: 0,1:03:23.78,1:03:26.61,Default,,0,0,0,,RIGHT-PUSH和类似的过程 就是一直在上面放东西
Dialogue: 0,1:03:26.93,1:03:33.82,Default,,0,0,0,,而这个CORNER-PUSH则是一种一般性思想的泛化
Dialogue: 0,1:03:34.72,1:03:37.20,Default,,0,0,0,,为了演示并让大家熟悉
Dialogue: 0,1:03:37.98,1:03:40.65,Default,,0,0,0,,使用廊腰缦回的高阶过程
Dialogue: 0,1:03:41.12,1:03:47.24,Default,,0,0,0,,我给大家示范一下“递归地重复某种组合方法”的一般性思想
Dialogue: 0,1:03:48.30,1:03:50.70,Default,,0,0,0,,这个例子可以说明一切
Dialogue: 0,1:03:51.22,1:04:00.70,Default,,0,0,0,,我们可以定义一个依赖于具体组合方式的PUSH过程
Dialogue: 0,1:04:01.49,1:04:04.88,Default,,0,0,0,,COMB的取值可以是BESIDE或ABOVE等
Dialogue: 0,1:04:06.18,1:04:07.06,Default,,0,0,0,,过程的体是什么呢？
Dialogue: 0,1:04:07.06,1:04:12.06,Default,,0,0,0,,它返回一个过程 想一想BESIDE实际上是什么
Dialogue: 0,1:04:13.22,1:04:15.18,Default,,0,0,0,,它接受一个图像
Dialogue: 0,1:04:15.96,1:04:18.08,Default,,0,0,0,,哦  它接受两个图像和一个缩放因数
Dialogue: 0,1:04:18.62,1:04:24.28,Default,,0,0,0,,利用这个过程 定义一个接受层数、图像和缩放因数的过程
Dialogue: 0,1:04:24.28,1:04:25.45,Default,,0,0,0,,我称之为RIGHT-PUSH
Dialogue: 0,1:04:26.16,1:04:33.66,Default,,0,0,0,,这个过程接受 图像PICT 层数N和缩放因数A
Dialogue: 0,1:04:36.16,1:04:39.12,Default,,0,0,0,,我要做一些重复操作
Dialogue: 0,1:04:39.45,1:04:46.62,Default,,0,0,0,,我会重复应用一个接受一个图像P的过程
Dialogue: 0,1:04:48.40,1:04:50.69,Default,,0,0,0,,并把组合的方式应用在
Dialogue: 0,1:04:51.20,1:04:59.08,Default,,0,0,0,,应用在图像PICT和在这里接受的图像P以及缩放因数A
Dialogue: 0,1:05:02.26,1:05:07.28,Default,,0,0,0,,我要重复应用这个过程N次
Dialogue: 0,1:05:12.04,1:05:16.20,Default,,0,0,0,,我则是把这整个过程应用在原图片PICT上
Dialogue: 0,1:05:19.56,1:05:24.48,Default,,0,0,0,,虽然之前没提过 这里的REPEATED也是一个高阶过程
Dialogue: 0,1:05:24.53,1:05:28.34,Default,,0,0,0,,它接受一个过程P和一个数字N
Dialogue: 0,1:05:29.54,1:05:34.29,Default,,0,0,0,,它返回另一个过程：将给定的过程P重复应用N次的过程
Dialogue: 0,1:05:36.04,1:05:39.30,Default,,0,0,0,,可能有些人已经在练习中编写过REPEATED了
Dialogue: 0,1:05:39.70,1:05:43.01,Default,,0,0,0,,如果还没做的话 这是理解和练习高阶过程的好机会
Dialogue: 0,1:05:43.84,1:05:46.90,Default,,0,0,0,,无论如何 我将把REPEATED过程的结果应用到PICT上
Dialogue: 0,1:05:49.46,1:05:52.38,Default,,0,0,0,,定义好PUSH后 这就
Dialogue: 0,1:05:53.12,1:05:57.73,Default,,0,0,0,,这就是从BESIDE、RIGHT-PUSH中总结出来的一般性思想
Dialogue: 0,1:05:59.01,1:06:13.17,Default,,0,0,0,,现在 我就可以把RIGHT-PUSH定义为 用BESIDE来做PUSH操作
Dialogue: 0,1:06:17.65,1:06:20.32,Default,,0,0,0,,我也可以把UP-PUSH定义为 用ABOVE来做PUSH操作
Dialogue: 0,1:06:20.34,1:06:25.48,Default,,0,0,0,,类似地 CORNER-PUSH就是用BESIDE和ABOVE的适当组合做PUSH操作
Dialogue: 0,1:06:25.49,1:06:26.70,Default,,0,0,0,,我可以用任何东西做PUSH操作
Dialogue: 0,1:06:28.26,1:06:34.76,Default,,0,0,0,,嗯 如果你还不太理解LAMBDA的话 可以参考这个例子
Dialogue: 0,1:06:38.98,1:06:41.00,Default,,0,0,0,,我们可以从这个例子中学到很多东西
Dialogue: 0,1:06:42.18,1:06:49.80,Default,,0,0,0,,我主要想要介绍的是在一个语言中嵌入另一个语言
Dialogue: 0,1:06:50.66,1:06:55.62,Default,,0,0,0,,这样 母体语言--本例中是Lisp--的所有能力
Dialogue: 0,1:06:55.92,1:07:00.28,Default,,0,0,0,,可以作为你所构建语言的一种扩展而取得
Dialogue: 0,1:07:00.98,1:07:04.00,Default,,0,0,0,,这个例子很好地展示了这点
Dialogue: 0,1:07:08.14,1:07:10.94,Default,,0,0,0,,另外 当我们回过头去思考
Dialogue: 0,1:07:10.94,1:07:12.28,Default,,0,0,0,,什么是过程 什么是数据
Dialogue: 0,1:07:12.28,1:07:16.20,Default,,0,0,0,,在这里 天啊 发生了什么
Dialogue: 0,1:07:16.20,1:07:19.66,Default,,0,0,0,,在这里 这是一个过程 它接受一个图像和一个参数
Dialogue: 0,1:07:19.66,1:07:20.36,Default,,0,0,0,,但是 什么是图像呢？
Dialogue: 0,1:07:20.36,1:07:23.82,Default,,0,0,0,,请回想 图像本身 就是一个以矩形为参数的过程
Dialogue: 0,1:07:23.82,1:07:25.82,Default,,0,0,0,,这个矩形是某种抽象
Dialogue: 0,1:07:26.09,1:07:28.13,Default,,0,0,0,,我希望你们现在能彻底明白
Dialogue: 0,1:07:29.14,1:07:33.74,Default,,0,0,0,,系统中什么是过程 什么是数据
Dialogue: 0,1:07:33.74,1:07:34.78,Default,,0,0,0,,我们发现 它们没有任何区别
Dialogue: 0,1:07:35.49,1:07:36.44,Default,,0,0,0,,真的没有区别
Dialogue: 0,1:07:37.93,1:07:41.42,Default,,0,0,0,,你可以认为图像有时候是过程 有时候是数据
Dialogue: 0,1:07:41.84,1:07:44.90,Default,,0,0,0,,但是 这只是让你容易理解的一种方法
Dialogue: 0,1:07:44.90,1:07:47.30,Default,,0,0,0,,这有一定道理 也没有道理
Dialogue: 0,1:07:49.92,1:08:02.20,Default,,0,0,0,,关于系统的结构 一种更普遍的观点将其视作创建一种语言
Dialogue: 0,1:08:02.52,1:08:06.74,Default,,0,0,0,,将工程设计过程看作是创建一门语言
Dialogue: 0,1:08:07.84,1:08:13.97,Default,,0,0,0,,准确来说 是创建各种层次的语言
Dialogue: 0,1:08:14.77,1:08:20.01,Default,,0,0,0,,众所周知 有一种方法学 或者叫做“神话学”
Dialogue: 0,1:08:20.74,1:08:24.90,Default,,0,0,0,,姑且叫做软件“工程”
Dialogue: 0,1:08:25.21,1:08:28.04,Default,,0,0,0,,它声称 你要先计算出你的任务
Dialogue: 0,1:08:28.04,1:08:30.04,Default,,0,0,0,,精确且正确地计算出你的任务
Dialogue: 0,1:08:30.40,1:08:32.20,Default,,0,0,0,,一但你搞清楚要做的东西
Dialogue: 0,1:08:32.22,1:08:34.54,Default,,0,0,0,,你把它划分为三个子任务
Dialogue: 0,1:08:34.54,1:08:35.76,Default,,0,0,0,,然后你开始继续做--
Dialogue: 0,1:08:35.97,1:08:38.94,Default,,0,0,0,,你开始处理这个子任务 然后你明确它是什么
Dialogue: 0,1:08:38.94,1:08:43.04,Default,,0,0,0,,这个子问题就分裂成三个子任务 你把它们处理完
Dialogue: 0,1:08:43.04,1:08:47.32,Default,,0,0,0,,然后你先处理这两个任务
Dialogue: 0,1:08:47.32,1:08:51.10,Default,,0,0,0,,解决完子任务后 你后退到这里 处理第二个子任务
Dialogue: 0,1:08:51.10,1:08:53.40,Default,,0,0,0,,然后把它详细地实现出来
Dialogue: 0,1:08:53.40,1:08:57.64,Default,,0,0,0,,结束之后-- 你完成了这个美丽的大厦
Dialogue: 0,1:08:57.64,1:09:00.25,Default,,0,0,0,,你最后得到了一棵非凡的树
Dialogue: 0,1:09:00.89,1:09:08.24,Default,,0,0,0,,你把任务划分为子任务 子任务再划分为子任务
Dialogue: 0,1:09:09.88,1:09:15.02,Default,,0,0,0,,树中的每个结点都被严谨而准确地定义
Dialogue: 0,1:09:15.26,1:09:18.66,Default,,0,0,0,,为奇妙而精美的任务 以构建整栋大厦
Dialogue: 0,1:09:18.96,1:09:21.14,Default,,0,0,0,,这个就是所谓的“神话学”
Dialogue: 0,1:09:21.14,1:09:25.92,Default,,0,0,0,,只有计算机科学家才可能相信你构建的复杂系统像这个样子
Dialogue: 0,1:09:27.48,1:09:32.80,Default,,0,0,0,,好了 我们用Henderson的例子来做对比
Dialogue: 0,1:09:32.80,1:09:34.30,Default,,0,0,0,,它的结构不是那样
Dialogue: 0,1:09:35.26,1:09:39.33,Default,,0,0,0,,事实是：这里有一个语言的层次序列
Dialogue: 0,1:09:41.06,1:09:42.05,Default,,0,0,0,,它是什么？
Dialogue: 0,1:09:42.18,1:09:48.76,Default,,0,0,0,,这里有一层 允许我们构建基本图像
Dialogue: 0,1:09:51.69,1:09:56.24,Default,,0,0,0,,这个语言描述基本图像
Dialogue: 0,1:09:56.32,1:09:57.84,Default,,0,0,0,,我们并没有做过多地讨论
Dialogue: 0,1:09:58.22,1:09:59.58,Default,,0,0,0,,我们讨论了如何构造George
Dialogue: 0,1:09:59.61,1:10:04.88,Default,,0,0,0,,这个语言是在单位正方形中讨论点、线和向量
Dialogue: 0,1:10:06.42,1:10:11.29,Default,,0,0,0,,而在这之上
Dialogue: 0,1:10:11.97,1:10:14.10,Default,,0,0,0,,这是讨论基本图像的语言
Dialogue: 0,1:10:17.08,1:10:20.36,Default,,0,0,0,,讨论在特定单位正方形中线段的构造
Dialogue: 0,1:10:21.40,1:10:23.80,Default,,0,0,0,,在这个上面是另一个完整的语言
Dialogue: 0,1:10:24.05,1:10:30.86,Default,,0,0,0,,关于几何组合子的语言
Dialogue: 0,1:10:32.66,1:10:36.62,Default,,0,0,0,,关于几何物件的位置
Dialogue: 0,1:10:38.77,1:10:46.50,Default,,0,0,0,,讨论像ABOVE、BESIDE、RIGHT-PUSH和ROTATE这样的东西
Dialogue: 0,1:10:48.04,1:10:55.70,Default,,0,0,0,,这些事情恰巧与我们在这个语言中谈论的事情有关
Dialogue: 0,1:10:58.57,1:11:00.93,Default,,0,0,0,,再细化一点 我们发现在这之上
Dialogue: 0,1:11:02.61,1:11:15.10,Default,,0,0,0,,还有一门语言 描述组合的模式
Dialogue: 0,1:11:21.25,1:11:22.44,Default,,0,0,0,,比如说PUSH
Dialogue: 0,1:11:24.45,1:11:27.88,Default,,0,0,0,,也就是用一个放缩因子重复地做一件事儿
Dialogue: 0,1:11:28.38,1:11:31.28,Default,,0,0,0,,我们在那门语言中讨论的问题
Dialogue: 0,1:11:31.50,1:11:34.34,Default,,0,0,0,,正是我这里构建的东西
Dialogue: 0,1:11:36.30,1:11:42.76,Default,,0,0,0,,我们在每一层上所讨论的对象
Dialogue: 0,1:11:44.68,1:11:47.00,Default,,0,0,0,,都是前一个层次所建立的
Dialogue: 0,1:11:48.08,1:11:52.06,Default,,0,0,0,,这个和这个有什么区别呢？
Dialogue: 0,1:11:53.34,1:11:54.18,Default,,0,0,0,,这是因为
Dialogue: 0,1:11:56.14,1:12:01.73,Default,,0,0,0,,实际上在这里 树的每一个结点 每一次分解
Dialogue: 0,1:12:02.14,1:12:05.25,Default,,0,0,0,,都是旨在分成确定的任务
Dialogue: 0,1:12:07.50,1:12:08.88,Default,,0,0,0,,而在另一个方案中
Dialogue: 0,1:12:09.21,1:12:14.80,Default,,0,0,0,,你在每个层级上的完完全全的语言层面的能力
Dialogue: 0,1:12:16.00,1:12:18.08,Default,,0,0,0,,这里的每一个层次
Dialogue: 0,1:12:20.24,1:12:22.72,Default,,0,0,0,,都不是被设计为完成一个特定任务
Dialogue: 0,1:12:23.14,1:12:26.17,Default,,0,0,0,,它被设计为讨论整个事情
Dialogue: 0,1:12:27.62,1:12:30.78,Default,,0,0,0,,这样设计导致的结果是：
Dialogue: 0,1:12:31.14,1:12:35.58,Default,,0,0,0,,用这种设计方法更加健壮
Dialogue: 0,1:12:36.61,1:12:38.20,Default,,0,0,0,,我所谓的“健壮”是指
Dialogue: 0,1:12:38.44,1:12:41.24,Default,,0,0,0,,当你在描述中做一些改变
Dialogue: 0,1:12:42.70,1:12:48.04,Default,,0,0,0,,我们可以做出相应的改变
Dialogue: 0,1:12:49.22,1:12:52.60,Default,,0,0,0,,用上一层语言实现的方法改变即可
Dialogue: 0,1:12:54.29,1:12:56.58,Default,,0,0,0,,因为你让每个层次都是完全的
Dialogue: 0,1:12:56.62,1:12:59.66,Default,,0,0,0,,所以你不需要讨论像BESIDE这样的特定操作
Dialogue: 0,1:12:59.94,1:13:03.78,Default,,0,0,0,,你为表达这类事物创造了完备的词汇
Dialogue: 0,1:13:04.77,1:13:07.02,Default,,0,0,0,,所以当你轻微修改规格指标时
Dialogue: 0,1:13:07.02,1:13:11.38,Default,,0,0,0,,这种方法论可以捕捉并适应那些变化
Dialogue: 0,1:13:12.69,1:13:15.02,Default,,0,0,0,,然而这种设计却不够健壮
Dialogue: 0,1:13:15.02,1:13:17.08,Default,,0,0,0,,因为 如果我在这里改变一下
Dialogue: 0,1:13:17.53,1:13:21.69,Default,,0,0,0,,那可能会影响我划分这些东西的方式 严重地影响
Dialogue: 0,1:13:23.20,1:13:29.74,Default,,0,0,0,,分解观点的最大不同在于 按层次还是严格继承分解
Dialogue: 0,1:13:30.52,1:13:33.02,Default,,0,0,0,,不只是如此 当你有多个层次的语言时
Dialogue: 0,1:13:33.50,1:13:35.92,Default,,0,0,0,,你就有了不同的词汇储备
Dialogue: 0,1:13:36.45,1:13:38.74,Default,,0,0,0,,用于讨论不同层次上的设计
Dialogue: 0,1:13:38.74,1:13:40.92,Default,,0,0,0,,我们再回过头来看看George
Dialogue: 0,1:13:41.90,1:13:44.08,Default,,0,0,0,,如果我想改变图像George
Dialogue: 0,1:13:45.85,1:13:48.68,Default,,0,0,0,,我立马得到了一种不同的方式来描述变化
Dialogue: 0,1:13:48.68,1:13:56.08,Default,,0,0,0,,比如 我想在基本设计的层面上 移动某些向量的终点
Dialogue: 0,1:13:57.76,1:14:00.76,Default,,0,0,0,,我会在最底层讨论这个改变
Dialogue: 0,1:14:01.00,1:14:02.50,Default,,0,0,0,,我会另外指定终点位置
Dialogue: 0,1:14:03.34,1:14:07.98,Default,,0,0,0,,我也可以说 我想在这个小的重复元素上做文章
Dialogue: 0,1:14:09.10,1:14:10.94,Default,,0,0,0,,我可能想做些其它操作
Dialogue: 0,1:14:10.94,1:14:13.84,Default,,0,0,0,,我想在BESIDE中使用一个缩放因数
Dialogue: 0,1:14:13.84,1:14:19.34,Default,,0,0,0,,这个改变我会在更高的层次上讨论：在组合子的层次
Dialogue: 0,1:14:19.34,1:14:25.05,Default,,0,0,0,,我也可以改变图像的基本组合模式
Dialogue: 0,1:14:26.49,1:14:30.48,Default,,0,0,0,,做一些递归地分解 可能不会让它们填充满角落
Dialogue: 0,1:14:31.16,1:14:34.18,Default,,0,0,0,,而这样的一个变化 我会在最高层次讨论
Dialogue: 0,1:14:34.18,1:14:36.37,Default,,0,0,0,,正是因为我按这种结构组织系统
Dialogue: 0,1:14:36.52,1:14:39.62,Default,,0,0,0,,我有所有的词汇 可以用不同的方式描述变化
Dialogue: 0,1:14:39.65,1:14:42.48,Default,,0,0,0,,而且可以灵活地决定哪个更合适
Dialogue: 0,1:14:44.74,1:14:51.05,Default,,0,0,0,,这就是Lisp中不同于软件工程方法论的最大要点
Dialogue: 0,1:14:51.25,1:14:55.45,Default,,0,0,0,,它来自于这样一个观点：真正的设计过程
Dialogue: 0,1:14:56.12,1:14:59.62,Default,,0,0,0,,与其说是在设计程序 不如说是在设计语言
Dialogue: 0,1:14:59.62,1:15:01.09,Default,,0,0,0,,而这就是Lisp的力量
Dialogue: 0,1:15:02.21,1:15:03.61,Default,,0,0,0,,谢谢大家 下课
Dialogue: 0,1:15:05.69,1:15:23.37,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:15:05.69,1:15:23.37,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/FoOTOo/Learning-SICP
