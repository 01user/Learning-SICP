[Script Info]
; Script generated by Aegisub 3.0.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
Collisions: Normal
PlayResX: 640
PlayResY: 480
Scroll Position: 1037
Active Line: 1035
Audio URI: lec1a_Rerip_remux.mp4
Video Zoom Percent: 0.875
Video File: lec1a_Rerip_remux.mp4
Video Aspect Ratio: c1.33333
Video Position: 1302
Last Style Storage: Default
YCbCr Matrix: TV.601

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,雅黑宋体,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1
Style: Declare,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: staff,微软雅黑,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,2,5,10,10,10,1
Style: title,微软雅黑,35,&H001D64D9,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0,1,5,10,10,10,1
Style: EN,Calisto MT,21,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1,0,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:14.71,0:00:17.89,EN,,0,0,0,,I'd like to welcome you to this course on computer science.
Dialogue: 0,0:00:28.40,0:00:29.85,EN,,0,0,0,,Actually, that's a terrible way to start.
Dialogue: 0,0:00:29.85,0:00:32.34,EN,,0,0,0,,Computer science is a terrible name for this business.
Dialogue: 0,0:00:32.83,0:00:34.30,EN,,0,0,0,,First of all, it's not a science.
Dialogue: 0,0:00:35.92,0:00:39.81,EN,,0,0,0,,It might be engineering or it might be art,
Dialogue: 0,0:00:40.09,0:00:42.91,EN,,0,0,0,,but we'll actually see that computer so-called science
Dialogue: 0,0:00:42.93,0:00:44.97,EN,,0,0,0,,actually has a lot in common with magic,
Dialogue: 0,0:00:45.01,0:00:46.35,EN,,0,0,0,,and we'll see that in this course.
Dialogue: 0,0:00:47.28,0:00:48.22,EN,,0,0,0,,So it's not a science.
Dialogue: 0,0:00:48.23,0:00:52.30,EN,,0,0,0,,It's also not really very much about computers.
Dialogue: 0,0:00:53.39,0:00:55.47,EN,,0,0,0,,And it's not about computers in the same sense
Dialogue: 0,0:00:55.47,0:01:00.05,EN,,0,0,0,,that physics is not really about particle accelerators,
Dialogue: 0,0:01:00.80,0:01:05.58,EN,,0,0,0,,and biology is not really about microscopes and petri dishes.
Dialogue: 0,0:01:06.46,0:01:10.25,EN,,0,0,0,,And it's not about computers in the same sense
Dialogue: 0,0:01:10.31,0:01:14.88,EN,,0,0,0,,that geometry is not really about using surveying instruments.
Dialogue: 0,0:01:16.48,0:01:19.01,EN,,0,0,0,,In fact, there's a lot of commonality
Dialogue: 0,0:01:19.33,0:01:21.45,EN,,0,0,0,,between computer science and geometry.
Dialogue: 0,0:01:21.45,0:01:22.66,EN,,0,0,0,,Geometry, first of all,
Dialogue: 0,0:01:23.02,0:01:24.98,EN,,0,0,0,,is another subject with a lousy name.
Dialogue: 0,0:01:25.58,0:01:27.85,EN,,0,0,0,,The name comes from Gaia, meaning the Earth,
Dialogue: 0,0:01:27.90,0:01:29.09,EN,,0,0,0,,and metron, meaning to measure.
Dialogue: 0,0:01:29.82,0:01:33.39,EN,,0,0,0,,Geometry originally meant measuring the Earth or surveying.
Dialogue: 0,0:01:34.37,0:01:36.89,EN,,0,0,0,,And the reason for that was that, thousands of years ago,
Dialogue: 0,0:01:37.69,0:01:41.69,EN,,0,0,0,,the Egyptian priesthood developed the rudiments of geometry
Dialogue: 0,0:01:42.59,0:01:46.33,EN,,0,0,0,,in order to figure out how to restore the boundaries of fields
Dialogue: 0,0:01:46.35,0:01:48.69,EN,,0,0,0,,that were destroyed in the annual flooding of the Nile.
Dialogue: 0,0:01:49.47,0:01:50.65,EN,,0,0,0,,And to the Egyptians who did that,
Dialogue: 0,0:01:50.65,0:01:53.93,EN,,0,0,0,,geometry really was the use of surveying instruments.
Dialogue: 0,0:01:55.63,0:01:58.55,EN,,0,0,0,,Now, the reason that we think computer science is about computers
Dialogue: 0,0:01:58.57,0:02:02.49,EN,,0,0,0,,is pretty much the same reason that the Egyptians thought geometry
Dialogue: 0,0:02:02.51,0:02:04.10,EN,,0,0,0,,was about surveying instruments.
Dialogue: 0,0:02:04.59,0:02:07.37,EN,,0,0,0,,And that is, when some field is just getting started
Dialogue: 0,0:02:07.39,0:02:09.86,EN,,0,0,0,,and you don't really understand it very well,
Dialogue: 0,0:02:11.10,0:02:16.64,EN,,0,0,0,,it's very easy to confuse the essence of what you're doing with the tools that you use.
Dialogue: 0,0:02:17.65,0:02:20.30,EN,,0,0,0,,And indeed, on some absolute scale of things,
Dialogue: 0,0:02:20.30,0:02:24.82,EN,,0,0,0,,we probably know less about the essence of computer science
Dialogue: 0,0:02:24.83,0:02:27.49,EN,,0,0,0,,than the ancient Egyptians really knew about geometry.
Dialogue: 0,0:02:30.25,0:02:32.64,EN,,0,0,0,,Well, what do I mean by the essence of computer science?
Dialogue: 0,0:02:32.65,0:02:34.41,EN,,0,0,0,,What do I mean by the essence of geometry?
Dialogue: 0,0:02:34.41,0:02:36.45,EN,,0,0,0,,See, it's certainly true that these Egyptians went off
Dialogue: 0,0:02:36.46,0:02:37.67,EN,,0,0,0,,and used surveying instruments,
Dialogue: 0,0:02:37.69,0:02:41.55,EN,,0,0,0,,but when we look back on them after a couple of thousand years,
Dialogue: 0,0:02:41.57,0:02:41.85,EN,,0,0,0,,we say,
Dialogue: 0,0:02:41.87,0:02:43.64,EN,,0,0,0,,gee, what they were doing,
Dialogue: 0,0:02:43.71,0:02:45.48,EN,,0,0,0,,the important stuff they were doing,
Dialogue: 0,0:02:45.62,0:02:50.45,EN,,0,0,0,,was to begin to formalize notions about space and time,
Dialogue: 0,0:02:51.58,0:02:57.53,EN,,0,0,0,,to start a way of talking about mathematical truths formally.
Dialogue: 0,0:02:58.01,0:02:59.61,EN,,0,0,0,,That led to the axiomatic method.
Dialogue: 0,0:02:59.61,0:03:02.53,EN,,0,0,0,,That led to sort of all of modern mathematics,
Dialogue: 0,0:03:04.16,0:03:06.90,EN,,0,0,0,,figuring out a way to talk precisely about
Dialogue: 0,0:03:07.25,0:03:10.19,EN,,0,0,0,,so-called declarative knowledge, what is true.
Dialogue: 0,0:03:12.45,0:03:16.25,EN,,0,0,0,,Well, similarly, I think in the future people will look back and say,
Dialogue: 0,0:03:16.27,0:03:19.36,EN,,0,0,0,,yes, those primitives in the 20th century were fiddling around
Dialogue: 0,0:03:19.36,0:03:21.20,EN,,0,0,0,,with these gadgets called computers,
Dialogue: 0,0:03:21.77,0:03:26.25,EN,,0,0,0,,but really what they were doing is starting to learn
Dialogue: 0,0:03:26.25,0:03:32.55,EN,,0,0,0,,how to formalize intuitions about process,
Dialogue: 0,0:03:32.64,0:03:34.13,EN,,0,0,0,,how to do things,
Dialogue: 0,0:03:39.02,0:03:51.25,EN,,0,0,0,,starting to develop a way to talk precisely about how-to knowledge,
Dialogue: 0,0:03:51.76,0:03:56.03,EN,,0,0,0,,as opposed to geometry that talks about what is true.
Dialogue: 0,0:03:56.53,0:03:58.57,EN,,0,0,0,,Let me give you an example of that.
Dialogue: 0,0:04:02.30,0:04:02.69,EN,,0,0,0,,Let's take a look
Dialogue: 0,0:04:02.70,0:04:09.82,EN,,0,0,0,,Here is a piece of mathematics that says what a square root is.
Dialogue: 0,0:04:10.09,0:04:14.35,EN,,0,0,0,,The square root of X is the number Y,
Dialogue: 0,0:04:15.98,0:04:20.38,EN,,0,0,0,,such that Y squared is equal to X and Y is greater than 0.
Dialogue: 0,0:04:20.43,0:04:22.50,EN,,0,0,0,,Now, that's a fine piece of mathematics,
Dialogue: 0,0:04:22.88,0:04:25.25,EN,,0,0,0,,but just telling you what a square root is
Dialogue: 0,0:04:25.63,0:04:30.29,EN,,0,0,0,,doesn't really say anything about how you might go out and find one.
Dialogue: 0,0:04:31.42,0:04:35.90,EN,,0,0,0,,So let's contrast that with a piece of imperative knowledge,
Dialogue: 0,0:04:37.13,0:04:39.92,EN,,0,0,0,,how you might go out and find a square root.
Dialogue: 0,0:04:39.95,0:04:45.74,EN,,0,0,0,,This, in fact, also comes from Egypt, not ancient, ancient Egypt.
Dialogue: 0,0:04:45.76,0:04:48.88,EN,,0,0,0,,This is an algorithm due to Heron of Alexandria,
Dialogue: 0,0:04:49.90,0:04:52.77,EN,,0,0,0,,called how to find a square root by successive averaging.
Dialogue: 0,0:04:52.89,0:04:55.13,EN,,0,0,0,,And what it says is that,
Dialogue: 0,0:04:55.15,0:04:58.06,EN,,0,0,0,,in order to find a square root,
Dialogue: 0,0:05:03.34,0:05:08.33,EN,,0,0,0,,you make a guess, you improve that guess --
Dialogue: 0,0:05:10.19,0:05:11.44,EN,,0,0,0,,and the way you improve the guess
Dialogue: 0,0:05:11.45,0:05:13.95,EN,,0,0,0,,is to average the guess and X over the guess,
Dialogue: 0,0:05:14.41,0:05:15.60,EN,,0,0,0,,and we'll talk a little bit later about
Dialogue: 0,0:05:15.61,0:05:17.12,EN,,0,0,0,,why that's a reasonable thing--
Dialogue: 0,0:05:17.14,0:05:19.37,EN,,0,0,0,,and you keep improving the guess until it's good enough.
Dialogue: 0,0:05:19.73,0:05:20.85,EN,,0,0,0,,That's a method.
Dialogue: 0,0:05:20.99,0:05:24.65,EN,,0,0,0,,That's how to do something as opposed to
Dialogue: 0,0:05:24.72,0:05:27.33,EN,,0,0,0,,declarative knowledge that says what you're looking for.
Dialogue: 0,0:05:28.05,0:05:29.76,EN,,0,0,0,,That's a process.
Dialogue: 0,0:05:34.40,0:05:38.25,EN,,0,0,0,,Well, what's a process in general?
Dialogue: 0,0:05:39.01,0:05:40.14,EN,,0,0,0,,It's kind of hard to say.
Dialogue: 0,0:05:40.16,0:05:43.72,EN,,0,0,0,,You can think of it as like a magical spirit
Dialogue: 0,0:05:44.77,0:05:47.33,EN,,0,0,0,,that sort of lives in the computer and does something.
Dialogue: 0,0:05:48.01,0:05:54.11,EN,,0,0,0,,And the thing that directs a process is
Dialogue: 0,0:05:54.13,0:05:57.98,EN,,0,0,0,,a pattern of rules called a procedure.
Dialogue: 0,0:06:01.98,0:06:04.73,EN,,0,0,0,,So procedures are the spells, if you like,
Dialogue: 0,0:06:05.23,0:06:09.40,EN,,0,0,0,,that control these magical spirits that are the processes.
Dialogue: 0,0:06:10.75,0:06:12.75,EN,,0,0,0,,I guess you know everyone needs a magical language,
Dialogue: 0,0:06:12.77,0:06:14.55,EN,,0,0,0,,and sorcerers, real sorcerers,
Dialogue: 0,0:06:14.57,0:06:18.59,EN,,0,0,0,,use ancient Arcadian or Sumerian or Babylonian or whatever.
Dialogue: 0,0:06:18.62,0:06:20.09,EN,,0,0,0,,We're going to conjure our spirits
Dialogue: 0,0:06:20.13,0:06:22.71,EN,,0,0,0,,in a magical language called Lisp,
Dialogue: 0,0:06:24.37,0:06:28.01,EN,,0,0,0,,which is a language designed for talking about,
Dialogue: 0,0:06:28.57,0:06:31.84,EN,,0,0,0,,for casting the spells that are procedures to direct the processes.
Dialogue: 0,0:06:31.87,0:06:33.91,EN,,0,0,0,,Now, it's very easy to learn Lisp.
Dialogue: 0,0:06:33.97,0:06:35.98,EN,,0,0,0,,In fact, in a few minutes, I'm going to teach you,
Dialogue: 0,0:06:36.00,0:06:37.16,EN,,0,0,0,,essentially, all of Lisp.
Dialogue: 0,0:06:37.37,0:06:38.96,EN,,0,0,0,,I'm going to teach you, essentially, all of the rules.
Dialogue: 0,0:06:40.77,0:06:43.65,EN,,0,0,0,,And you shouldn't find that particularly surprising.
Dialogue: 0,0:06:43.69,0:06:45.87,EN,,0,0,0,,That's sort of like saying it's very easy
Dialogue: 0,0:06:45.90,0:06:47.01,EN,,0,0,0,,to learn the rules of chess.
Dialogue: 0,0:06:47.04,0:06:48.13,EN,,0,0,0,,And indeed, in a few minutes,
Dialogue: 0,0:06:48.17,0:06:49.70,EN,,0,0,0,,you can tell somebody the rules of chess.
Dialogue: 0,0:06:50.81,0:06:52.24,EN,,0,0,0,,But of course, that's very different from
Dialogue: 0,0:06:52.25,0:06:55.37,EN,,0,0,0,,saying you understand the implications of those rules
Dialogue: 0,0:06:55.42,0:06:58.05,EN,,0,0,0,,and how to use those rules to become a masterful chess player.
Dialogue: 0,0:06:58.49,0:06:59.82,EN,,0,0,0,,Well, Lisp is the same way.
Dialogue: 0,0:07:00.41,0:07:02.18,EN,,0,0,0,,We're going to state the rules in a few minutes,
Dialogue: 0,0:07:02.36,0:07:03.55,EN,,0,0,0,,and it'll be very easy to see.
Dialogue: 0,0:07:03.62,0:07:07.09,EN,,0,0,0,,But what's really hard is going to be the implications of those rules,
Dialogue: 0,0:07:07.32,0:07:10.46,EN,,0,0,0,,how you exploit those rules to be a master programmer.
Dialogue: 0,0:07:12.06,0:07:15.29,EN,,0,0,0,,And the implications of those rules are going to take us the,
Dialogue: 0,0:07:15.31,0:07:18.56,EN,,0,0,0,,well, the whole rest of the subject and, of course, way beyond.
Dialogue: 0,0:07:21.45,0:07:23.11,EN,,0,0,0,,OK, so in computer science,
Dialogue: 0,0:07:24.49,0:07:26.19,EN,,0,0,0,,we're in the business of
Dialogue: 0,0:07:26.21,0:07:30.58,EN,,0,0,0,,formalizing this sort of how-to imperative knowledge,
Dialogue: 0,0:07:30.62,0:07:32.10,EN,,0,0,0,,how to do stuff.
Dialogue: 0,0:07:33.37,0:07:35.39,EN,,0,0,0,,And the real issues of computer science are, of course,
Dialogue: 0,0:07:35.41,0:07:38.36,EN,,0,0,0,,not telling people how to do square roots.
Dialogue: 0,0:07:39.09,0:07:40.06,EN,,0,0,0,,Because if that was all it was,
Dialogue: 0,0:07:40.09,0:07:41.34,EN,,0,0,0,,there wouldn't be no big deal.
Dialogue: 0,0:07:41.57,0:07:44.05,EN,,0,0,0,,The real problems come when we try to
Dialogue: 0,0:07:44.08,0:07:46.16,EN,,0,0,0,,build very, very large systems,
Dialogue: 0,0:07:46.61,0:07:49.53,EN,,0,0,0,,computer programs that are thousands of pages long,
Dialogue: 0,0:07:49.58,0:07:53.98,EN,,0,0,0,,so long that nobody can really hold them in their heads all at once.
Dialogue: 0,0:07:54.73,0:07:58.81,EN,,0,0,0,,And the only reason that that's possible is because
Dialogue: 0,0:07:58.86,0:08:18.97,EN,,0,0,0,,there are techniques for controlling the complexity of these large systems.
Dialogue: 0,0:08:20.30,0:08:22.69,EN,,0,0,0,,And these techniques that are controlling complexity
Dialogue: 0,0:08:22.72,0:08:24.17,EN,,0,0,0,,are what this course is really about.
Dialogue: 0,0:08:24.65,0:08:25.47,EN,,0,0,0,,And in some sense,
Dialogue: 0,0:08:25.50,0:08:27.47,EN,,0,0,0,,that's really what computer science is about.
Dialogue: 0,0:08:29.63,0:08:31.89,EN,,0,0,0,,Now, that may seem like a very strange thing to say.
Dialogue: 0,0:08:31.92,0:08:35.61,EN,,0,0,0,,Because after all, a lot of people besides computer scientists
Dialogue: 0,0:08:35.65,0:08:37.82,EN,,0,0,0,,deal with controlling complexity.
Dialogue: 0,0:08:37.84,0:08:41.02,EN,,0,0,0,,A large airliner is an extremely complex system,
Dialogue: 0,0:08:41.82,0:08:43.79,EN,,0,0,0,,and the aeronautical engineers who design that
Dialogue: 0,0:08:44.05,0:08:46.13,EN,,0,0,0,,are dealing with immense complexity.
Dialogue: 0,0:08:47.09,0:08:50.19,EN,,0,0,0,,But there's a difference between that kind of complexity
Dialogue: 0,0:08:50.75,0:08:52.60,EN,,0,0,0,,and what we deal with in computer science.
Dialogue: 0,0:08:55.18,0:08:57.73,EN,,0,0,0,,And that is that computer science,
Dialogue: 0,0:08:57.79,0:09:00.09,EN,,0,0,0,,in some sense, isn't real.
Dialogue: 0,0:09:02.69,0:09:06.62,EN,,0,0,0,,You see, when an engineer is designing a physical system,
Dialogue: 0,0:09:07.14,0:09:08.49,EN,,0,0,0,,that's made out of real parts.
Dialogue: 0,0:09:09.40,0:09:11.18,EN,,0,0,0,,The engineers who worry about that
Dialogue: 0,0:09:11.85,0:09:16.65,EN,,0,0,0,,have to address problems of tolerance and approximation and noise in the system.
Dialogue: 0,0:09:16.67,0:09:19.02,EN,,0,0,0,,So for example, as an electrical engineer,
Dialogue: 0,0:09:19.09,0:09:21.71,EN,,0,0,0,,I can go off and easily build a one-stage amplifier
Dialogue: 0,0:09:21.73,0:09:23.03,EN,,0,0,0,,or a two-stage amplifier,
Dialogue: 0,0:09:23.41,0:09:25.39,EN,,0,0,0,,and I can imagine cascading a lot of them
Dialogue: 0,0:09:25.45,0:09:26.91,EN,,0,0,0,,to build a million-stage amplifier.
Dialogue: 0,0:09:26.99,0:09:28.75,EN,,0,0,0,,But it's ridiculous to build such a thing,
Dialogue: 0,0:09:28.98,0:09:32.15,EN,,0,0,0,,because long before the millionth stage,
Dialogue: 0,0:09:32.16,0:09:34.56,EN,,0,0,0,,the thermal noise in those components way at the beginning
Dialogue: 0,0:09:34.57,0:09:36.80,EN,,0,0,0,,is going to get amplified and make the whole thing meaningless.
Dialogue: 0,0:09:39.10,0:09:43.12,EN,,0,0,0,,Computer science deals with idealized components.
Dialogue: 0,0:09:44.12,0:09:47.63,EN,,0,0,0,,We know as much as we want about these little program
Dialogue: 0,0:09:47.65,0:09:49.56,EN,,0,0,0,,and data pieces that we're fitting things together.
Dialogue: 0,0:09:51.90,0:09:53.20,EN,,0,0,0,,We don't have to worry about tolerance.
Dialogue: 0,0:09:53.21,0:09:56.99,EN,,0,0,0,,And that means that, in building a large program,
Dialogue: 0,0:09:58.13,0:10:00.03,EN,,0,0,0,,there's not all that much difference
Dialogue: 0,0:10:00.35,0:10:04.18,EN,,0,0,0,,between what I can build and what I can imagine,
Dialogue: 0,0:10:05.53,0:10:07.60,EN,,0,0,0,,because the parts are these abstract entities
Dialogue: 0,0:10:07.63,0:10:10.32,EN,,0,0,0,,that I know as much as I want.
Dialogue: 0,0:10:10.33,0:10:12.39,EN,,0,0,0,,I know about them as precisely as I'd like.
Dialogue: 0,0:10:13.45,0:10:15.50,EN,,0,0,0,,So as opposed to other kinds of engineering,
Dialogue: 0,0:10:15.66,0:10:17.42,EN,,0,0,0,,where the constraints on what you can build
Dialogue: 0,0:10:17.44,0:10:18.90,EN,,0,0,0,,are the constraints of physical systems,
Dialogue: 0,0:10:18.94,0:10:21.02,EN,,0,0,0,,the constraints of physics and noise and approximation,
Dialogue: 0,0:10:21.21,0:10:25.60,EN,,0,0,0,,the constraints imposed in building large software systems
Dialogue: 0,0:10:25.64,0:10:27.58,EN,,0,0,0,,are the limitations of our own minds.
Dialogue: 0,0:10:29.12,0:10:29.98,EN,,0,0,0,,So in that sense,
Dialogue: 0,0:10:30.00,0:10:33.67,EN,,0,0,0,,computer science is like an abstract form of engineering.
Dialogue: 0,0:10:33.80,0:10:35.73,EN,,0,0,0,,It's the kind of engineering where you ignore
Dialogue: 0,0:10:35.76,0:10:38.02,EN,,0,0,0,,the constraints that are imposed by reality.
Dialogue: 0,0:10:41.97,0:10:46.15,EN,,0,0,0,,Well, what are some of these techniques?
Dialogue: 0,0:10:46.28,0:10:48.39,EN,,0,0,0,,They're not special to computer science.
Dialogue: 0,0:10:50.39,0:10:52.55,EN,,0,0,0,,First technique, which is used in all of engineering,
Dialogue: 0,0:10:53.36,0:10:58.91,EN,,0,0,0,,is a kind of abstraction called black-box abstraction.
Dialogue: 0,0:11:07.71,0:11:12.58,EN,,0,0,0,,Take something and build a box about it.
Dialogue: 0,0:11:14.37,0:11:20.09,EN,,0,0,0,,Let's see, for example, if we looked at that square root method,
Dialogue: 0,0:11:22.64,0:11:28.53,EN,,0,0,0,,I might want to take that and build a box.
Dialogue: 0,0:11:29.89,0:11:37.52,EN,,0,0,0,,That sort of says, to find the square root of X.
Dialogue: 0,0:11:38.86,0:11:41.27,EN,,0,0,0,,And that might be a whole complicated set of rules.
Dialogue: 0,0:11:42.64,0:11:46.69,EN,,0,0,0,,And that might end up being a kind of thing where I can put in,
Dialogue: 0,0:11:46.81,0:11:50.06,EN,,0,0,0,,say, 36 and say, what's the square root of 36?
Dialogue: 0,0:11:50.25,0:11:51.46,EN,,0,0,0,,And out comes 6.
Dialogue: 0,0:11:53.89,0:11:56.22,EN,,0,0,0,,And the important thing is that
Dialogue: 0,0:11:56.24,0:12:00.03,EN,,0,0,0,,I'd like to design that so that
Dialogue: 0,0:12:00.06,0:12:04.08,EN,,0,0,0,,if George comes along and would like to compute,
Dialogue: 0,0:12:05.10,0:12:09.37,EN,,0,0,0,,say, the square root of A plus the square root of B,
Dialogue: 0,0:12:11.34,0:12:14.38,EN,,0,0,0,,he can take this thing and use it as a module
Dialogue: 0,0:12:14.43,0:12:15.74,EN,,0,0,0,,without having to look inside
Dialogue: 0,0:12:15.77,0:12:17.31,EN,,0,0,0,,and build something that looks like this,
Dialogue: 0,0:12:18.45,0:12:24.20,EN,,0,0,0,,like an A and a B and a square root box and another square root box
Dialogue: 0,0:12:24.53,0:12:33.87,EN,,0,0,0,,and then something that adds that would put out the answer.
Dialogue: 0,0:12:33.96,0:12:38.15,EN,,0,0,0,,And you can see, just from the fact that I want to do that,
Dialogue: 0,0:12:38.92,0:12:40.42,EN,,0,0,0,,is from George's point of view,
Dialogue: 0,0:12:40.51,0:12:43.10,EN,,0,0,0,,the internals of what's in here should not be important.
Dialogue: 0,0:12:44.19,0:12:47.25,EN,,0,0,0,,So for instance, it shouldn't matter that, when I wrote this,
Dialogue: 0,0:12:47.27,0:12:50.43,EN,,0,0,0,,I said I want to find the square root of X.
Dialogue: 0,0:12:50.61,0:12:52.27,EN,,0,0,0,,I could have said the square root of Y,
Dialogue: 0,0:12:52.72,0:12:55.62,EN,,0,0,0,,or the square root of A, or anything at all
Dialogue: 0,0:12:56.70,0:13:02.35,EN,,0,0,0,,That's the fundamental notion of putting something in a box
Dialogue: 0,0:13:03.53,0:13:06.44,EN,,0,0,0,,using black-box abstraction to suppress detail.
Dialogue: 0,0:13:07.60,0:13:10.99,EN,,0,0,0,,And the reason for that is you want to go off and build bigger boxes.
Dialogue: 0,0:13:12.05,0:13:14.57,EN,,0,0,0,,Now, there's another reason for doing black-box abstraction
Dialogue: 0,0:13:14.59,0:13:18.41,EN,,0,0,0,,other than you want to suppress detail for building bigger boxes.
Dialogue: 0,0:13:18.48,0:13:25.02,EN,,0,0,0,,Sometimes you want to say that your way of doing something,
Dialogue: 0,0:13:25.04,0:13:26.88,EN,,0,0,0,,your how-to method,
Dialogue: 0,0:13:28.44,0:13:30.79,EN,,0,0,0,,is an instance of a more general thing,
Dialogue: 0,0:13:31.16,0:13:34.57,EN,,0,0,0,,and you'd like your language to be able to express that generality.
Dialogue: 0,0:13:35.57,0:13:37.93,EN,,0,0,0,,Let me show you another example
Dialogue: 0,0:13:37.97,0:13:38.86,EN,,0,0,0,,sticking with square roots.
Dialogue: 0,0:13:38.89,0:13:42.16,EN,,0,0,0,,Let's go back and take another look at that slide
Dialogue: 0,0:13:42.19,0:13:43.75,EN,,0,0,0,,with the square root algorithm on it.
Dialogue: 0,0:13:44.16,0:13:45.62,EN,,0,0,0,,Remember what that says.
Dialogue: 0,0:13:45.79,0:13:49.82,EN,,0,0,0,,That says, in order to do something, I make a guess,
Dialogue: 0,0:13:50.62,0:13:54.84,EN,,0,0,0,,and I improve that guess, and I sort of keep improving that guess.
Dialogue: 0,0:13:55.66,0:14:00.14,EN,,0,0,0,,So there's the general strategy of, I'm looking for something,
Dialogue: 0,0:14:01.15,0:14:04.00,EN,,0,0,0,,and the way I find it is that I keep improving it.
Dialogue: 0,0:14:04.16,0:14:10.25,EN,,0,0,0,,Now, that's a particular case of another kind of strategy
Dialogue: 0,0:14:10.97,0:14:13.23,EN,,0,0,0,,for finding a fixed point of something.
Dialogue: 0,0:14:14.57,0:14:16.59,EN,,0,0,0,,So you have a fixed point of a function.
Dialogue: 0,0:14:17.13,0:14:26.03,EN,,0,0,0,,A fixed point of a function is something, is a value.
Dialogue: 0,0:14:26.13,0:14:31.79,EN,,0,0,0,,A fixed point of a function F is a value Y, such that F of Y equals Y.
Dialogue: 0,0:14:32.97,0:14:40.89,EN,,0,0,0,,And the way I might do that is start with a guess.
Dialogue: 0,0:14:42.00,0:14:45.85,EN,,0,0,0,,And then if I want something that doesn't change when I keep applying F,
Dialogue: 0,0:14:45.96,0:14:49.45,EN,,0,0,0,,is I'll keep applying F over and over until that result doesn't change very much.
Dialogue: 0,0:14:50.05,0:14:51.93,EN,,0,0,0,,So there's a general strategy.
Dialogue: 0,0:14:52.24,0:14:56.17,EN,,0,0,0,,And then, for example, to compute the square root of X,
Dialogue: 0,0:14:56.24,0:15:03.45,EN,,0,0,0,,I can try and find a fixed point of the function which takes Y to the average of X/Y.
Dialogue: 0,0:15:03.55,0:15:07.52,EN,,0,0,0,,And the idea that is that if I really had Y equal to the square root of X,
Dialogue: 0,0:15:08.01,0:15:11.80,EN,,0,0,0,,then Y and X/Y would be the same value.
Dialogue: 0,0:15:12.00,0:15:13.90,EN,,0,0,0,,They'd both be the square root of X,
Dialogue: 0,0:15:14.86,0:15:18.85,EN,,0,0,0,,because X over the square root of X is the square root of X.
Dialogue: 0,0:15:19.09,0:15:21.84,EN,,0,0,0,,And so the average if Y were equal to the square of X,
Dialogue: 0,0:15:22.25,0:15:25.21,EN,,0,0,0,,then the average wouldn't change.
Dialogue: 0,0:15:25.98,0:15:28.93,EN,,0,0,0,,So the square root of X is a fixed point of that particular function.
Dialogue: 0,0:15:30.09,0:15:33.85,EN,,0,0,0,,Now, what I'd like to have, I'd like to express
Dialogue: 0,0:15:33.98,0:15:36.42,EN,,0,0,0,,the general strategy for finding fixed points.
Dialogue: 0,0:15:36.57,0:15:40.13,EN,,0,0,0,,So what I might imagine doing, is to find,
Dialogue: 0,0:15:41.02,0:15:46.45,EN,,0,0,0,,is to be able to use my language to define a box that says "fixed point,"
Dialogue: 0,0:15:49.58,0:15:52.19,EN,,0,0,0,,just like I could make a box that says "square root."
Dialogue: 0,0:15:52.21,0:15:55.18,EN,,0,0,0,,And I'd like to be able to express this in my language.
Dialogue: 0,0:15:56.08,0:16:01.37,EN,,0,0,0,,So I'd like to express not only the imperative how-to knowledge
Dialogue: 0,0:16:01.42,0:16:03.21,EN,,0,0,0,,of a particular thing like square root,
Dialogue: 0,0:16:03.58,0:16:05.60,EN,,0,0,0,,but I'd like to be able to express the imperative knowledge
Dialogue: 0,0:16:05.66,0:16:08.27,EN,,0,0,0,,of how to do a general thing like how to find fixed point.
Dialogue: 0,0:16:09.82,0:16:12.25,EN,,0,0,0,,And in fact, let's go back and look at that slide again.
Dialogue: 0,0:16:15.02,0:16:23.28,EN,,0,0,0,,See, not only is this a piece of imperative knowledge,
Dialogue: 0,0:16:23.33,0:16:25.32,EN,,0,0,0,,how to find a fixed point,
Dialogue: 0,0:16:26.25,0:16:27.39,EN,,0,0,0,,but over here on the bottom,
Dialogue: 0,0:16:27.42,0:16:30.32,EN,,0,0,0,,there's another piece of imperative knowledge which says,
Dialogue: 0,0:16:30.41,0:16:35.85,EN,,0,0,0,,one way to compute square root is to apply this general fixed point method.
Dialogue: 0,0:16:36.17,0:16:38.89,EN,,0,0,0,,So I'd like to also be able to express that imperative knowledge.
Dialogue: 0,0:16:39.74,0:16:40.70,EN,,0,0,0,,What would that look like?
Dialogue: 0,0:16:40.73,0:16:44.90,EN,,0,0,0,,That would say, this fixed point box is such that
Dialogue: 0,0:16:45.76,0:16:58.21,EN,,0,0,0,,if I input to it the function that takes Y to the average of Y and X/Y,
Dialogue: 0,0:16:59.77,0:17:06.23,EN,,0,0,0,,then what should come out of that fixed point box is a method for finding square roots.
Dialogue: 0,0:17:08.91,0:17:10.24,EN,,0,0,0,,So in these boxes we're building,
Dialogue: 0,0:17:10.27,0:17:15.07,EN,,0,0,0,,we're not only building boxes that you input numbers and output numbers,
Dialogue: 0,0:17:16.40,0:17:18.54,EN,,0,0,0,,we're going to be building in boxes that,
Dialogue: 0,0:17:18.67,0:17:21.34,EN,,0,0,0,,in effect, compute methods like finding square root.
Dialogue: 0,0:17:22.22,0:17:25.85,EN,,0,0,0,,And my take is their inputs functions,
Dialogue: 0,0:17:26.49,0:17:29.29,EN,,0,0,0,,like Y goes to the average of Y and X/Y.
Dialogue: 0,0:17:29.71,0:17:31.49,EN,,0,0,0,,The reason we want to do that,
Dialogue: 0,0:17:32.21,0:17:35.60,EN,,0,0,0,,the reason this is a procedure, will end up being a procedure,
Dialogue: 0,0:17:35.63,0:17:38.61,EN,,0,0,0,,as we'll see, whose value is another procedure,
Dialogue: 0,0:17:39.31,0:17:41.10,EN,,0,0,0,,the reason we want to do that is because
Dialogue: 0,0:17:41.52,0:17:46.27,EN,,0,0,0,,procedures are going to be our ways of talking about imperative knowledge.
Dialogue: 0,0:17:48.00,0:17:49.93,EN,,0,0,0,,And the way to make that very powerful is
Dialogue: 0,0:17:49.93,0:17:52.13,EN,,0,0,0,,to be able to talk about other kinds of knowledge.
Dialogue: 0,0:17:53.42,0:17:56.52,EN,,0,0,0,,So here is a procedure that, in effect, talks about another procedure,
Dialogue: 0,0:17:57.10,0:18:00.34,EN,,0,0,0,,a general strategy that itself talks about general strategies.
Dialogue: 0,0:18:03.57,0:18:08.24,EN,,0,0,0,,Well, our first topic in this course--
Dialogue: 0,0:18:08.25,0:18:09.69,EN,,0,0,0,,there'll be three major topics--
Dialogue: 0,0:18:09.74,0:18:10.94,EN,,0,0,0,,will be black-box abstraction.
Dialogue: 0,0:18:10.97,0:18:13.31,EN,,0,0,0,,Let's look at that in a little bit more detail.
Dialogue: 0,0:18:15.12,0:18:24.04,EN,,0,0,0,,What we're going to do is we will start out talking about
Dialogue: 0,0:18:24.08,0:18:26.72,EN,,0,0,0,,how Lisp is built up out of primitive objects.
Dialogue: 0,0:18:27.36,0:18:29.20,EN,,0,0,0,,What does the language supply with us?
Dialogue: 0,0:18:29.49,0:18:33.58,EN,,0,0,0,,And we'll see that there are primitive procedures and primitive data.
Dialogue: 0,0:18:36.16,0:18:37.04,EN,,0,0,0,,Then we're going to see,
Dialogue: 0,0:18:37.05,0:18:38.77,EN,,0,0,0,,how do you take those primitives and
Dialogue: 0,0:18:38.81,0:18:40.76,EN,,0,0,0,,combine them to make more complicated things,
Dialogue: 0,0:18:41.45,0:18:42.92,EN,,0,0,0,,means of combination?
Dialogue: 0,0:18:43.20,0:18:46.30,EN,,0,0,0,,And what we'll see is that there are ways of putting things together,
Dialogue: 0,0:18:46.45,0:18:50.48,EN,,0,0,0,,putting primitive procedures together to make more complicated procedures.
Dialogue: 0,0:18:50.96,0:18:54.43,EN,,0,0,0,,And we'll see how to put primitive data together to make compound data.
Dialogue: 0,0:18:56.21,0:18:59.34,EN,,0,0,0,,Then we'll say, well, having made those compounds things,
Dialogue: 0,0:18:59.79,0:19:01.29,EN,,0,0,0,,how do you abstract them?
Dialogue: 0,0:19:02.91,0:19:04.97,EN,,0,0,0,,How do you put those black boxes around them
Dialogue: 0,0:19:05.04,0:19:07.73,EN,,0,0,0,,so you can use them as components in more complex things?
Dialogue: 0,0:19:08.16,0:19:10.93,EN,,0,0,0,,And we'll see that's done by defining procedures and
Dialogue: 0,0:19:11.52,0:19:14.79,EN,,0,0,0,,a technique for dealing with compound data called data abstraction.
Dialogue: 0,0:19:15.61,0:19:17.36,EN,,0,0,0,,And then, what's maybe the most important thing,
Dialogue: 0,0:19:17.92,0:19:21.49,EN,,0,0,0,,is going from just the rules to how does an expert work?
Dialogue: 0,0:19:21.61,0:19:27.12,EN,,0,0,0,,How do you express common patterns of doing things, like saying, well,
Dialogue: 0,0:19:27.15,0:19:28.64,EN,,0,0,0,,there's a general method of fixed point and
Dialogue: 0,0:19:28.69,0:19:30.87,EN,,0,0,0,,square root is a particular case of that?
Dialogue: 0,0:19:31.90,0:19:34.41,EN,,0,0,0,,And we're going to use--
Dialogue: 0,0:19:34.59,0:19:35.63,EN,,0,0,0,,I've already hinted at it--
Dialogue: 0,0:19:35.66,0:19:37.30,EN,,0,0,0,,something called higher-order procedures,
Dialogue: 0,0:19:37.34,0:19:42.05,EN,,0,0,0,,namely procedures whose inputs and outputs are themselves procedures.
Dialogue: 0,0:19:42.96,0:19:44.86,EN,,0,0,0,,And then we'll also see something very interesting.
Dialogue: 0,0:19:44.86,0:19:48.49,EN,,0,0,0,,We'll see, as we go further and further on and become more abstract,
Dialogue: 0,0:19:48.80,0:19:50.31,EN,,0,0,0,,there'll be very--
Dialogue: 0,0:19:50.43,0:19:53.61,EN,,0,0,0,,well, the line between what we consider to be data and
Dialogue: 0,0:19:53.63,0:19:57.80,EN,,0,0,0,,what we consider to be procedures is going to blur at an incredible rate.
Dialogue: 0,0:20:02.89,0:20:07.12,EN,,0,0,0,,Well, that's our first subject, black-box abstraction.
Dialogue: 0,0:20:07.12,0:20:08.62,EN,,0,0,0,,Let's look at the second topic.
Dialogue: 0,0:20:11.10,0:20:13.88,EN,,0,0,0,,I can introduce it like this.
Dialogue: 0,0:20:13.89,0:20:18.09,EN,,0,0,0,,See, suppose I want to express the idea--
Dialogue: 0,0:20:19.42,0:20:22.51,EN,,0,0,0,,remember, we're talking about ideas--
Dialogue: 0,0:20:22.91,0:20:25.53,EN,,0,0,0,,suppose I want to express the idea that
Dialogue: 0,0:20:26.41,0:20:35.12,EN,,0,0,0,,I can take something and multiply it by the sum of two other things.
Dialogue: 0,0:20:36.09,0:20:37.93,EN,,0,0,0,,So for example, I might say,
Dialogue: 0,0:20:38.11,0:20:41.52,EN,,0,0,0,,if I had 1 and 3 and multiply that by 2, I get 8.
Dialogue: 0,0:20:42.03,0:20:45.11,EN,,0,0,0,,But I'm talking about the general idea of what's called linear combination,
Dialogue: 0,0:20:45.44,0:20:47.98,EN,,0,0,0,,that you can add two things and multiply them by something else.
Dialogue: 0,0:20:49.28,0:20:51.01,EN,,0,0,0,,It's very easy when I think about it for numbers,
Dialogue: 0,0:20:51.05,0:20:55.41,EN,,0,0,0,,but suppose I also want to use that same idea to think about,
Dialogue: 0,0:20:56.08,0:20:58.58,EN,,0,0,0,,I could add two vectors, a1 and a2,
Dialogue: 0,0:20:59.89,0:21:03.26,EN,,0,0,0,,and then scale them by some factor x and get another vector.
Dialogue: 0,0:21:03.33,0:21:09.75,EN,,0,0,0,,Or I might say, I want to think about a1 and a2 as being polynomials,
Dialogue: 0,0:21:11.07,0:21:13.90,EN,,0,0,0,,and I might want to add those two polynomials and
Dialogue: 0,0:21:13.92,0:21:16.86,EN,,0,0,0,,then multiply them by 2 to get a more complicated one.
Dialogue: 0,0:21:20.16,0:21:23.83,EN,,0,0,0,,Or a1 and a2 might be electrical signals,
Dialogue: 0,0:21:24.56,0:21:27.77,EN,,0,0,0,,and I might want to think about summing those two electrical signals and
Dialogue: 0,0:21:27.81,0:21:30.27,EN,,0,0,0,,then putting the whole thing through an amplifier,
Dialogue: 0,0:21:30.28,0:21:33.03,EN,,0,0,0,,multiplying it by some factor of 2 or something.
Dialogue: 0,0:21:33.82,0:21:36.93,EN,,0,0,0,,The idea is I want to think about the general notion of that.
Dialogue: 0,0:21:38.32,0:21:45.42,EN,,0,0,0,,Now, if our language is going to be good language for expressing those kind of general ideas,
Dialogue: 0,0:21:47.07,0:21:49.31,EN,,0,0,0,,if I really, really can do that,
Dialogue: 0,0:21:50.65,0:21:52.09,EN,,0,0,0,,I'd like to be able to say
Dialogue: 0,0:21:54.99,0:22:00.41,EN,,0,0,0,,I'm going to multiply by x the sum of a1 and a2,
Dialogue: 0,0:22:02.80,0:22:05.07,EN,,0,0,0,,and I'd like that to express the general idea of
Dialogue: 0,0:22:06.03,0:22:09.23,EN,,0,0,0,,all different kinds of things that a1 and a2 could be.
Dialogue: 0,0:22:10.03,0:22:11.58,EN,,0,0,0,,Now, if you think about that, there's a problem,
Dialogue: 0,0:22:11.58,0:22:16.17,EN,,0,0,0,,because after all, the actual primitive operations
Dialogue: 0,0:22:16.21,0:22:18.33,EN,,0,0,0,,that go on in the machine are obviously going to be different
Dialogue: 0,0:22:18.38,0:22:22.98,EN,,0,0,0,,if I'm adding two numbers than if I'm adding two polynomials,
Dialogue: 0,0:22:23.29,0:22:27.49,EN,,0,0,0,,or if I'm adding the representation of two electrical signals or wave forms.
Dialogue: 0,0:22:27.89,0:22:32.53,EN,,0,0,0,,Somewhere, there has to be the knowledge of the kinds of various things
Dialogue: 0,0:22:32.87,0:22:34.25,EN,,0,0,0,,that you can add and the ways of adding them.
Dialogue: 0,0:22:37.09,0:22:38.64,EN,,0,0,0,,Now, to construct such a system,
Dialogue: 0,0:22:38.78,0:22:40.67,EN,,0,0,0,,the question is, where do I put that knowledge?
Dialogue: 0,0:22:41.20,0:22:44.41,EN,,0,0,0,,How do I think about the different kinds of choices I have?
Dialogue: 0,0:22:44.56,0:22:48.42,EN,,0,0,0,,And if tomorrow George comes up with a new kind of object
Dialogue: 0,0:22:48.45,0:22:50.32,EN,,0,0,0,,that might be added and multiplied,
Dialogue: 0,0:22:51.01,0:22:53.32,EN,,0,0,0,,how do I add George's new object to the system
Dialogue: 0,0:22:53.52,0:22:55.68,EN,,0,0,0,,without screwing up everything that was already there?
Dialogue: 0,0:22:57.81,0:23:00.54,EN,,0,0,0,,Well, that's going to be the second big topic,
Dialogue: 0,0:23:00.57,0:23:03.16,EN,,0,0,0,,the way of controlling that kind of complexity.
Dialogue: 0,0:23:03.84,0:23:08.43,EN,,0,0,0,,And the way you do that is by establishing conventional interfaces,
Dialogue: 0,0:23:17.44,0:23:20.21,EN,,0,0,0,,agreed upon ways of plugging things together.
Dialogue: 0,0:23:20.25,0:23:22.04,EN,,0,0,0,,Just like in electrical engineering,
Dialogue: 0,0:23:22.94,0:23:25.39,EN,,0,0,0,,people have standard impedances for connectors,
Dialogue: 0,0:23:26.16,0:23:28.62,EN,,0,0,0,,and then you know if you build something with one of those standard impedances,
Dialogue: 0,0:23:28.67,0:23:30.40,EN,,0,0,0,,you can plug it together with something else.
Dialogue: 0,0:23:32.78,0:23:35.68,EN,,0,0,0,,So that's going to be our second large topic, conventional interfaces.
Dialogue: 0,0:23:35.73,0:23:40.94,EN,,0,0,0,,What we're going to see is, first, we're going to talk about the problem of generic operations,
Dialogue: 0,0:23:40.97,0:23:42.22,EN,,0,0,0,,which is the one I alluded to,
Dialogue: 0,0:23:42.59,0:23:47.28,EN,,0,0,0,,things like "plus" that have to work with all different kinds of data.
Dialogue: 0,0:23:52.61,0:23:54.57,EN,,0,0,0,,So we talk about generic operations.
Dialogue: 0,0:23:54.61,0:23:56.99,EN,,0,0,0,,Then we're going to talk about really large-scale structures.
Dialogue: 0,0:23:58.32,0:24:00.83,EN,,0,0,0,,How do you put together very large programs
Dialogue: 0,0:24:01.02,0:24:04.89,EN,,0,0,0,,that model the kinds of complex systems in the real world that you'd like to model?
Dialogue: 0,0:24:05.53,0:24:06.53,EN,,0,0,0,,And what we're going to see is that
Dialogue: 0,0:24:06.57,0:24:11.81,EN,,0,0,0,,there are two very important metaphors for putting together such systems.
Dialogue: 0,0:24:11.85,0:24:13.90,EN,,0,0,0,,One is called object-oriented programming,
Dialogue: 0,0:24:14.09,0:24:18.94,EN,,0,0,0,,where you sort of think of your system as a kind of society
Dialogue: 0,0:24:19.37,0:24:22.36,EN,,0,0,0,,full of little things that interact by sending information between them.
Dialogue: 0,0:24:23.44,0:24:27.81,EN,,0,0,0,,And then the second one is operations on aggregates, called streams,
Dialogue: 0,0:24:27.98,0:24:31.50,EN,,0,0,0,,where you think of a large system put together kind of
Dialogue: 0,0:24:31.50,0:24:35.29,EN,,0,0,0,,like a signal processing engineer puts together a large electrical system.
Dialogue: 0,0:24:38.93,0:24:40.49,EN,,0,0,0,,That's going to be our second topic.
Dialogue: 0,0:24:43.37,0:24:45.93,EN,,0,0,0,,Now, the third thing we're going to come to,
Dialogue: 0,0:24:45.95,0:24:49.70,EN,,0,0,0,,the third basic technique for controlling complexity,
Dialogue: 0,0:24:49.74,0:24:50.94,EN,,0,0,0,,is making new languages.
Dialogue: 0,0:24:51.69,0:24:55.42,EN,,0,0,0,,Because sometimes, when you're sort of overwhelmed by the complexity of a design,
Dialogue: 0,0:24:55.47,0:24:59.69,EN,,0,0,0,,the way that you control that complexity is to pick a new design language.
Dialogue: 0,0:25:01.41,0:25:05.60,EN,,0,0,0,,And the purpose of the new design language will be to highlight different aspects of the system.
Dialogue: 0,0:25:05.79,0:25:09.36,EN,,0,0,0,,It will suppress some kinds of details and emphasize other kinds of details.
Dialogue: 0,0:25:12.99,0:25:15.93,EN,,0,0,0,,This is going to be the most magical part of the course.
Dialogue: 0,0:25:16.03,0:25:21.20,EN,,0,0,0,,We're going to start out by actually looking at the technology for building new computer languages.
Dialogue: 0,0:25:21.82,0:25:26.30,EN,,0,0,0,,The first thing we're going to do is actually build in Lisp.
Dialogue: 0,0:25:29.23,0:25:34.02,EN,,0,0,0,,We're going to express in Lisp the process of interpreting Lisp itself.
Dialogue: 0,0:25:34.29,0:25:36.94,EN,,0,0,0,,And that's going to be a very sort of self-circular thing.
Dialogue: 0,0:25:36.96,0:25:39.92,EN,,0,0,0,,There's a little mystical symbol that has to do with that.
Dialogue: 0,0:25:40.97,0:25:46.38,EN,,0,0,0,,The process of interpreting Lisp is sort of a giant wheel of two processes,
Dialogue: 0,0:25:46.57,0:25:47.71,EN,,0,0,0,,apply and eval,
Dialogue: 0,0:25:47.89,0:25:50.87,EN,,0,0,0,,which sort of constantly reduce expressions to each other.
Dialogue: 0,0:25:52.54,0:25:54.24,EN,,0,0,0,,Then we're going to see all sorts of other magical things.
Dialogue: 0,0:25:54.25,0:25:56.85,EN,,0,0,0,,Here's another magical symbol.
Dialogue: 0,0:25:57.12,0:26:01.52,EN,,0,0,0,,This is sort of the Y operator,
Dialogue: 0,0:26:01.55,0:26:06.45,EN,,0,0,0,,which is, in some sense, the expression of infinity inside our procedural language.
Dialogue: 0,0:26:06.51,0:26:07.44,EN,,0,0,0,,We'll take a look at that.
Dialogue: 0,0:26:08.40,0:26:13.73,EN,,0,0,0,,In any case, this section of the course is called Metalinguistic Abstraction,
Dialogue: 0,0:26:16.17,0:26:26.23,EN,,0,0,0,,abstracting by talking about how you construct new languages.
Dialogue: 0,0:26:30.22,0:26:35.71,EN,,0,0,0,,As I said, we're going to start out by looking at the process of interpretation.
Dialogue: 0,0:26:35.74,0:26:42.12,EN,,0,0,0,,We're going to look at this apply-eval loop, and build Lisp.
Dialogue: 0,0:26:42.16,0:26:44.17,EN,,0,0,0,,Then, just to show you that this is very general,
Dialogue: 0,0:26:44.37,0:26:48.26,EN,,0,0,0,,we're going to use exactly the same technology to build a very different kind of language,
Dialogue: 0,0:26:48.53,0:26:50.31,EN,,0,0,0,,a so-called logic programming language,
Dialogue: 0,0:26:50.53,0:26:54.83,EN,,0,0,0,,where you don't really talk about procedures at all that have inputs and outputs.
Dialogue: 0,0:26:54.86,0:26:57.25,EN,,0,0,0,,What you do is talk about relations between things.
Dialogue: 0,0:26:57.31,0:27:03.92,EN,,0,0,0,,And then finally, we're going to talk about how you implement these things very concretely
Dialogue: 0,0:27:03.95,0:27:05.60,EN,,0,0,0,,on the very simplest kind of machines.
Dialogue: 0,0:27:05.65,0:27:08.39,EN,,0,0,0,,We'll see something like this.
Dialogue: 0,0:27:09.13,0:27:12.14,EN,,0,0,0,,This is a picture of a chip,
Dialogue: 0,0:27:12.16,0:27:17.47,EN,,0,0,0,,which is the Lisp interpreter that we will be talking about then in hardware.
Dialogue: 0,0:27:20.88,0:27:23.79,EN,,0,0,0,,Well, there's an outline of the course, three big topics.
Dialogue: 0,0:27:24.88,0:27:29.41,EN,,0,0,0,,Black-box abstraction, conventional interfaces, metalinguistic abstraction.
Dialogue: 0,0:27:31.58,0:27:33.57,EN,,0,0,0,,Now, let's take a break now and then we'll get started.
Dialogue: 0,0:27:52.19,0:28:03.42,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:28:03.92,0:28:06.84,EN,,0,0,0,,Let's actually start in learning Lisp now.
Dialogue: 0,0:28:08.06,0:28:10.75,EN,,0,0,0,,Actually, we'll start out by learning something much more important,
Dialogue: 0,0:28:10.80,0:28:14.33,EN,,0,0,0,,maybe the very most important thing in this course, which is not Lisp,
Dialogue: 0,0:28:14.38,0:28:18.41,EN,,0,0,0,,in particular, of course, but rather a general framework
Dialogue: 0,0:28:18.62,0:28:21.89,EN,,0,0,0,,for thinking about languages that I already alluded to.
Dialogue: 0,0:28:22.12,0:28:25.10,EN,,0,0,0,,When somebody tells you they're going to show you a language,
Dialogue: 0,0:28:25.13,0:28:26.16,EN,,0,0,0,,what you should say is,
Dialogue: 0,0:28:26.19,0:28:32.87,EN,,0,0,0,,what I'd like you to tell me is what are the primitive elements?
Dialogue: 0,0:28:37.50,0:28:38.78,EN,,0,0,0,,What does the language come with?
Dialogue: 0,0:28:38.96,0:28:43.53,EN,,0,0,0,,Then, what are the ways you put those together?
Dialogue: 0,0:28:43.68,0:28:47.42,EN,,0,0,0,,What are the means of combination?
Dialogue: 0,0:28:50.17,0:28:54.18,EN,,0,0,0,,What are the things that allow you to take these primitive elements
Dialogue: 0,0:28:54.37,0:28:56.51,EN,,0,0,0,,and build bigger things out of them?
Dialogue: 0,0:28:58.01,0:28:59.61,EN,,0,0,0,,What are the ways of putting things together?
Dialogue: 0,0:29:01.39,0:29:05.69,EN,,0,0,0,,And then, what are the means of abstraction?
Dialogue: 0,0:29:08.35,0:29:16.85,EN,,0,0,0,,How do we take those complicated things and draw those boxes around them?
Dialogue: 0,0:29:16.88,0:29:19.66,EN,,0,0,0,,How do we name them so that we can now use them
Dialogue: 0,0:29:19.68,0:29:23.85,EN,,0,0,0,,as if they were primitive elements in making still more complex things?
Dialogue: 0,0:29:23.89,0:29:25.66,EN,,0,0,0,,And so on, and so on, and so on.
Dialogue: 0,0:29:26.89,0:29:28.08,EN,,0,0,0,,So when someone says to you, gee,
Dialogue: 0,0:29:28.09,0:29:29.55,EN,,0,0,0,,I have a great new computer language,
Dialogue: 0,0:29:30.86,0:29:34.70,EN,,0,0,0,,you don't say, how many characters does it take to invert a matrix?
Dialogue: 0,0:29:35.73,0:29:36.88,EN,,0,0,0,,It's irrelevant.
Dialogue: 0,0:29:37.39,0:29:42.30,EN,,0,0,0,,What you say is, if the language did not come with matrices built in
Dialogue: 0,0:29:42.33,0:29:43.37,EN,,0,0,0,,or with something else built in,
Dialogue: 0,0:29:43.37,0:29:46.03,EN,,0,0,0,,how could I then build that thing?
Dialogue: 0,0:29:46.05,0:29:48.47,EN,,0,0,0,,What are the means of combination which would allow me to do that?
Dialogue: 0,0:29:48.62,0:29:50.71,EN,,0,0,0,,And then, what are the means of abstraction
Dialogue: 0,0:29:51.68,0:29:54.21,EN,,0,0,0,,which allow me then to use those as elements
Dialogue: 0,0:29:54.22,0:29:56.52,EN,,0,0,0,,in making more complicated things yet?
Dialogue: 0,0:29:58.75,0:30:04.61,EN,,0,0,0,,Well, we're going to see that Lisp has some primitive data and some primitive procedures.
Dialogue: 0,0:30:05.25,0:30:07.50,EN,,0,0,0,,In fact, let's really start.
Dialogue: 0,0:30:07.55,0:30:14.89,EN,,0,0,0,,And here's a piece of primitive data in Lisp, number 3.
Dialogue: 0,0:30:16.27,0:30:19.87,EN,,0,0,0,,Actually, if I'm being very pedantic, that's not the number 3.
Dialogue: 0,0:30:19.93,0:30:25.57,EN,,0,0,0,,That's some symbol that represents Plato's concept of the number 3.
Dialogue: 0,0:30:26.67,0:30:28.93,EN,,0,0,0,,And here's another.
Dialogue: 0,0:30:30.48,0:30:36.06,EN,,0,0,0,,Here's some more primitive data in Lisp, 17.4.
Dialogue: 0,0:30:36.08,0:30:39.42,EN,,0,0,0,,Or actually, some representation of 17.4.
Dialogue: 0,0:30:40.99,0:30:44.48,EN,,0,0,0,,And here's another one, 5.
Dialogue: 0,0:30:46.86,0:30:52.21,EN,,0,0,0,,Here's another primitive object that's built in Lisp, addition.
Dialogue: 0,0:30:52.25,0:30:55.68,EN,,0,0,0,,Actually, to use the same kind of pedantic--
Dialogue: 0,0:30:55.71,0:31:00.47,EN,,0,0,0,,this is a name for the primitive method of adding things.
Dialogue: 0,0:31:00.53,0:31:02.53,EN,,0,0,0,,Just like this is a name for Plato's number 3,
Dialogue: 0,0:31:02.61,0:31:09.32,EN,,0,0,0,,this is a name for Plato's concept of how you add things.
Dialogue: 0,0:31:10.32,0:31:11.98,EN,,0,0,0,,So those are some primitive elements.
Dialogue: 0,0:31:12.14,0:31:13.76,EN,,0,0,0,,I can put them together.
Dialogue: 0,0:31:14.14,0:31:18.29,EN,,0,0,0,,I can say, gee, what's the sum of 3 and 17.4 and 5?
Dialogue: 0,0:31:18.69,0:31:21.31,EN,,0,0,0,,And the way I do that is to say,
Dialogue: 0,0:31:21.33,0:31:27.71,EN,,0,0,0,,let's apply the sum operator to these three numbers.
Dialogue: 0,0:31:27.74,0:31:31.15,EN,,0,0,0,,And I should get, what? 8, 17. 25.4.
Dialogue: 0,0:31:34.43,0:31:38.05,EN,,0,0,0,,So I should be able to ask Lisp what the value of this is,
Dialogue: 0,0:31:38.94,0:31:40.77,EN,,0,0,0,,and it will return 25.4.
Dialogue: 0,0:31:43.58,0:31:44.83,EN,,0,0,0,,Let's introduce some names.
Dialogue: 0,0:31:44.88,0:31:51.47,EN,,0,0,0,,This thing that I typed is called a combination.
Dialogue: 0,0:31:56.88,0:32:01.94,EN,,0,0,0,,And a combination consists, in general, of applying an operator--
Dialogue: 0,0:32:03.39,0:32:04.72,EN,,0,0,0,,so this is an operator--
Dialogue: 0,0:32:09.71,0:32:12.05,EN,,0,0,0,,to some operands.
Dialogue: 0,0:32:13.25,0:32:14.54,EN,,0,0,0,,These are the operands.
Dialogue: 0,0:32:21.89,0:32:23.79,EN,,0,0,0,,And of course, I can make more complex things.
Dialogue: 0,0:32:23.82,0:32:28.56,EN,,0,0,0,,The reason I can get complexity out of this is because the operands themselves,
Dialogue: 0,0:32:29.52,0:32:31.09,EN,,0,0,0,,in general, can be combinations.
Dialogue: 0,0:32:31.15,0:32:44.47,EN,,0,0,0,,So for instance, I could say, what is the sum of 3 and the product of 5 and 6 and 8 and 2?
Dialogue: 0,0:32:45.66,0:32:52.16,EN,,0,0,0,,And I should get-- let's see-- 30, 40, 43.
Dialogue: 0,0:32:52.73,0:32:54.81,EN,,0,0,0,,So Lisp should tell me that that's 43.
Dialogue: 0,0:32:56.56,0:33:02.80,EN,,0,0,0,,Forming combinations is the basic needs of combination that we'll be looking at.
Dialogue: 0,0:33:04.65,0:33:09.22,EN,,0,0,0,,And then, well, you see some syntax here.
Dialogue: 0,0:33:10.56,0:33:13.04,EN,,0,0,0,,Lisp uses what's called prefix notation,
Dialogue: 0,0:33:16.22,0:33:25.21,EN,,0,0,0,,which means that the operator is written to the left of the operands.
Dialogue: 0,0:33:25.47,0:33:26.48,EN,,0,0,0,,It's just a convention.
Dialogue: 0,0:33:27.66,0:33:29.77,EN,,0,0,0,,And notice, it's fully parenthesized.
Dialogue: 0,0:33:30.08,0:33:32.32,EN,,0,0,0,,And the parentheses make it completely unambiguous.
Dialogue: 0,0:33:32.32,0:33:36.99,EN,,0,0,0,,So by looking at this, I can see that there's the operator,
Dialogue: 0,0:33:37.01,0:33:40.99,EN,,0,0,0,,and there are 1, 2, 3, 4 operands.
Dialogue: 0,0:33:42.38,0:33:47.97,EN,,0,0,0,,And I can see that the second operand here is itself some combination
Dialogue: 0,0:33:48.88,0:33:51.55,EN,,0,0,0,,that has one operator and two operands.
Dialogue: 0,0:33:52.43,0:33:54.27,EN,,0,0,0,,Parentheses in Lisp are a little bit,
Dialogue: 0,0:33:54.61,0:33:57.71,EN,,0,0,0,,or are very unlike parentheses in conventional mathematics.
Dialogue: 0,0:33:57.77,0:34:00.11,EN,,0,0,0,,In mathematics, we sort of use them to mean grouping,
Dialogue: 0,0:34:01.21,0:34:03.75,EN,,0,0,0,,and it sort of doesn't hurt if sometimes you leave out parentheses
Dialogue: 0,0:34:03.77,0:34:05.56,EN,,0,0,0,,if people understand that that's a group.
Dialogue: 0,0:34:05.76,0:34:08.51,EN,,0,0,0,,And in general, it doesn't hurt if you put in extra parentheses,
Dialogue: 0,0:34:08.86,0:34:10.94,EN,,0,0,0,,because that maybe makes the grouping more distinct.
Dialogue: 0,0:34:10.96,0:34:11.77,EN,,0,0,0,,Lisp is not like that.
Dialogue: 0,0:34:13.12,0:34:15.37,EN,,0,0,0,,In Lisp, you cannot leave out parentheses,
Dialogue: 0,0:34:16.38,0:34:18.56,EN,,0,0,0,,and you cannot put in extra parentheses,
Dialogue: 0,0:34:19.33,0:34:21.28,EN,,0,0,0,,because putting in parentheses always means,
Dialogue: 0,0:34:21.37,0:34:27.05,EN,,0,0,0,,exactly and precisely, this is a combination which has meaning,
Dialogue: 0,0:34:27.09,0:34:28.81,EN,,0,0,0,,applying operators to operands.
Dialogue: 0,0:34:29.04,0:34:32.62,EN,,0,0,0,,And if I left this out, if I left those parentheses out,
Dialogue: 0,0:34:32.65,0:34:33.96,EN,,0,0,0,,it would mean something else.
Dialogue: 0,0:34:35.41,0:34:37.25,EN,,0,0,0,,In fact, the way to think about this,
Dialogue: 0,0:34:37.41,0:34:41.65,EN,,0,0,0,,is really what I'm doing when I write something like this is writing a tree.
Dialogue: 0,0:34:42.37,0:34:47.30,EN,,0,0,0,,So this combination is a tree that has a plus and
Dialogue: 0,0:34:47.37,0:34:54.46,EN,,0,0,0,,then a 3 and then a something else and an 8 and a 2.
Dialogue: 0,0:34:54.48,0:34:56.35,EN,,0,0,0,,And then this something else here is
Dialogue: 0,0:34:56.35,0:35:03.22,EN,,0,0,0,,itself a little subtree that has a star and a 5 and a 6.
Dialogue: 0,0:35:03.95,0:35:05.53,EN,,0,0,0,,And the way to think of that is, really,
Dialogue: 0,0:35:05.55,0:35:09.00,EN,,0,0,0,,what's going on are we're writing these trees,
Dialogue: 0,0:35:09.21,0:35:15.10,EN,,0,0,0,,and parentheses are just a way to write this two-dimensional structure
Dialogue: 0,0:35:15.79,0:35:17.34,EN,,0,0,0,,as a linear character string.
Dialogue: 0,0:35:19.23,0:35:23.81,EN,,0,0,0,,Because at least when Lisp first started and people had teletypes or punch cards or whatever,
Dialogue: 0,0:35:24.17,0:35:25.60,EN,,0,0,0,,this was more convenient.
Dialogue: 0,0:35:25.97,0:35:30.52,EN,,0,0,0,,Maybe if Lisp started today, the syntax of Lisp would look like that.
Dialogue: 0,0:35:31.76,0:35:35.07,EN,,0,0,0,,Well, let's look at what that actually looks like on the computer.
Dialogue: 0,0:35:36.29,0:35:39.37,EN,,0,0,0,,Here I have a Lisp interaction set up.
Dialogue: 0,0:35:39.41,0:35:40.43,EN,,0,0,0,,There's a editor.
Dialogue: 0,0:35:41.13,0:35:44.86,EN,,0,0,0,,And on the top, I'm going to type some values and ask Lisp what they are.
Dialogue: 0,0:35:45.12,0:35:46.75,EN,,0,0,0,,So for instance, I can say to Lisp,
Dialogue: 0,0:35:46.83,0:35:48.53,EN,,0,0,0,,what's the value of that symbol?
Dialogue: 0,0:35:49.44,0:35:50.50,EN,,0,0,0,,That's 3.
Dialogue: 0,0:35:50.57,0:35:52.20,EN,,0,0,0,,And I ask Lisp to evaluate it.
Dialogue: 0,0:35:52.32,0:35:54.77,EN,,0,0,0,,And there you see Lisp has returned on the bottom,
Dialogue: 0,0:35:55.39,0:35:56.84,EN,,0,0,0,,and said, oh yeah, that's 3.
Dialogue: 0,0:35:57.58,0:36:04.96,EN,,0,0,0,,Or I can say, what's the sum of 3 and 4 and 8?
Dialogue: 0,0:36:06.45,0:36:08.05,EN,,0,0,0,,What's that combination?
Dialogue: 0,0:36:08.93,0:36:10.66,EN,,0,0,0,,And ask Lisp to evaluate it.
Dialogue: 0,0:36:14.49,0:36:15.68,EN,,0,0,0,,That's 15.
Dialogue: 0,0:36:16.57,0:36:18.80,EN,,0,0,0,,Or I can type in something more complicated.
Dialogue: 0,0:36:19.25,0:36:34.14,EN,,0,0,0,,I can say, what's the sum of the product of 3 and the sum of 7 and 19.5?
Dialogue: 0,0:36:35.21,0:36:38.00,EN,,0,0,0,,And you'll notice here that Lisp has something built in
Dialogue: 0,0:36:38.01,0:36:39.76,EN,,0,0,0,,that helps me keep track of all these parentheses.
Dialogue: 0,0:36:39.77,0:36:42.13,EN,,0,0,0,,Watch as I type the next closed parentheses,
Dialogue: 0,0:36:42.21,0:36:45.01,EN,,0,0,0,,which is going to close the combination starting with the star.
Dialogue: 0,0:36:45.52,0:36:47.30,EN,,0,0,0,,The opening one will flash.
Dialogue: 0,0:36:47.76,0:36:49.69,EN,,0,0,0,,Here, I'll rub those out and do it again.
Dialogue: 0,0:36:50.14,0:36:52.70,EN,,0,0,0,,Type close, and you see that closes the plus.
Dialogue: 0,0:36:53.58,0:36:56.41,EN,,0,0,0,,Close again, that closes the star.
Dialogue: 0,0:36:57.90,0:37:00.76,EN,,0,0,0,,Now I'm back to the sum, and maybe I'm going to add that all to 4.
Dialogue: 0,0:37:01.66,0:37:02.69,EN,,0,0,0,,That closes the plus.
Dialogue: 0,0:37:02.73,0:37:07.07,EN,,0,0,0,,Now I have a complete combination, and I can ask Lisp for the value of that.
Dialogue: 0,0:37:07.26,0:37:11.66,EN,,0,0,0,,That kind of paren balancing is something that's built into
Dialogue: 0,0:37:11.76,0:37:13.29,EN,,0,0,0,,a lot of Lisp systems to help you keep track,
Dialogue: 0,0:37:13.36,0:37:16.55,EN,,0,0,0,,because it is kind of hard just by hand doing all these parentheses.
Dialogue: 0,0:37:16.81,0:37:21.20,EN,,0,0,0,,There's another kind of convention for keeping track of parentheses.
Dialogue: 0,0:37:21.25,0:37:23.68,EN,,0,0,0,,Let me write another complicated combination.
Dialogue: 0,0:37:24.77,0:37:34.00,EN,,0,0,0,,Let's take the sum of the product of 3 and 5 and add that to something.
Dialogue: 0,0:37:34.03,0:37:35.23,EN,,0,0,0,,And now what I'm going to do is
Dialogue: 0,0:37:35.28,0:37:39.85,EN,,0,0,0,,I'm going to indent so that the operands are written vertically.
Dialogue: 0,0:37:40.30,0:37:45.65,EN,,0,0,0,,Which the sum of that and the product of 47 and--
Dialogue: 0,0:37:47.02,0:37:54.59,EN,,0,0,0,,let's say the product of 47 with a difference of 20 and 6.8.
Dialogue: 0,0:37:54.62,0:37:57.09,EN,,0,0,0,,That means subtract 6.8 from 20.
Dialogue: 0,0:37:58.97,0:38:00.19,EN,,0,0,0,,And then you see the parentheses close.
Dialogue: 0,0:38:00.22,0:38:03.47,EN,,0,0,0,,Close the minus. Close the star.
Dialogue: 0,0:38:03.76,0:38:05.42,EN,,0,0,0,,And now let's get another operator.
Dialogue: 0,0:38:05.44,0:38:09.49,EN,,0,0,0,,You see the Lisp editor here is indenting to the right position automatically
Dialogue: 0,0:38:10.40,0:38:11.50,EN,,0,0,0,,to help me keep track.
Dialogue: 0,0:38:12.61,0:38:14.09,EN,,0,0,0,,I'll do that again.
Dialogue: 0,0:38:14.13,0:38:15.89,EN,,0,0,0,,I'll close that last parentheses again.
Dialogue: 0,0:38:16.25,0:38:17.71,EN,,0,0,0,,You see it balances the plus.
Dialogue: 0,0:38:20.40,0:38:22.64,EN,,0,0,0,,Now I can say, what's the value of that?
Dialogue: 0,0:38:23.87,0:38:29.28,EN,,0,0,0,,So those two things, indenting to the right level,
Dialogue: 0,0:38:29.31,0:38:30.86,EN,,0,0,0,,which is called pretty printing,
Dialogue: 0,0:38:31.55,0:38:33.58,EN,,0,0,0,,and flashing parentheses,
Dialogue: 0,0:38:33.89,0:38:37.73,EN,,0,0,0,,are two things that a lot of Lisp systems have built in to help you keep track.
Dialogue: 0,0:38:37.76,0:38:39.01,EN,,0,0,0,,And you should learn how to use them.
Dialogue: 0,0:38:41.52,0:38:43.17,EN,,0,0,0,,Ok, those are the primitives.
Dialogue: 0,0:38:44.73,0:38:46.31,EN,,0,0,0,,There's a means of combination.
Dialogue: 0,0:38:46.33,0:38:47.93,EN,,0,0,0,,Now let's go up to the means of abstraction.
Dialogue: 0,0:38:49.44,0:38:53.84,EN,,0,0,0,,I'd like to be able to take the idea that I do some combination like this,
Dialogue: 0,0:38:53.85,0:38:55.77,EN,,0,0,0,,and abstract it and give it a simple name,
Dialogue: 0,0:38:55.81,0:38:57.26,EN,,0,0,0,,so I can use that as an element.
Dialogue: 0,0:38:57.31,0:38:59.92,EN,,0,0,0,,And I do that in Lisp with "define."
Dialogue: 0,0:39:01.17,0:39:02.43,EN,,0,0,0,,So I can say, for example,
Dialogue: 0,0:39:02.73,0:39:15.05,EN,,0,0,0,,define A to be the product of 5 and 5.
Dialogue: 0,0:39:18.40,0:39:22.35,EN,,0,0,0,,And now I could say, for example, to Lisp,
Dialogue: 0,0:39:22.38,0:39:26.01,EN,,0,0,0,,what is the product of A and A?
Dialogue: 0,0:39:27.18,0:39:29.81,EN,,0,0,0,,And this should be 25, and this should be 625.
Dialogue: 0,0:39:31.97,0:39:36.01,EN,,0,0,0,,And then, crucial thing, I can now use A--
Dialogue: 0,0:39:36.21,0:39:37.92,EN,,0,0,0,,here I've used it in a combination--
Dialogue: 0,0:39:38.41,0:39:43.55,EN,,0,0,0,,but I could use that in other more complicated things that I name in turn.
Dialogue: 0,0:39:43.58,0:39:50.93,EN,,0,0,0,,So I could say, define B to be the sum of,
Dialogue: 0,0:39:50.97,0:39:57.45,EN,,0,0,0,,we'll say, A and the product of 5 and A.
Dialogue: 0,0:39:59.44,0:40:00.72,EN,,0,0,0,,And then close the plus.
Dialogue: 0,0:40:03.45,0:40:05.85,EN,,0,0,0,,Let's take a look at that on the computer and see how that looks.
Dialogue: 0,0:40:07.28,0:40:10.68,EN,,0,0,0,,So I'll just type what I wrote on the board.
Dialogue: 0,0:40:10.83,0:40:21.73,EN,,0,0,0,,I could say, define A to be the product of 5 and 5.
Dialogue: 0,0:40:23.74,0:40:25.38,EN,,0,0,0,,And I'll tell that to Lisp.
Dialogue: 0,0:40:25.52,0:40:28.94,EN,,0,0,0,,And notice what Lisp responded there with was an A in the bottom.
Dialogue: 0,0:40:29.09,0:40:31.38,EN,,0,0,0,,In general, when you type in a definition in Lisp,
Dialogue: 0,0:40:31.50,0:40:35.02,EN,,0,0,0,,it responds with the symbol being defined.
Dialogue: 0,0:40:35.63,0:40:39.66,EN,,0,0,0,,Now I could say to Lisp, what is the product of A and A?
Dialogue: 0,0:40:42.81,0:40:44.33,EN,,0,0,0,,And it says that's 625.
Dialogue: 0,0:40:46.05,0:41:00.34,EN,,0,0,0,,I can define B to be the sum of A and the product of 5 and A.
Dialogue: 0,0:41:00.48,0:41:05.70,EN,,0,0,0,,Close a paren closes the star.  Close the plus. Close the "define."
Dialogue: 0,0:41:07.63,0:41:10.37,EN,,0,0,0,,Lisp says, OK, B, there on the bottom.
Dialogue: 0,0:41:11.04,0:41:13.24,EN,,0,0,0,,And now I can say to Lisp, what's the value of B?
Dialogue: 0,0:41:17.18,0:41:18.88,EN,,0,0,0,,And I can say something more complicated,
Dialogue: 0,0:41:18.93,0:41:26.69,EN,,0,0,0,,like what's the sum of A and the quotient of B and 5?
Dialogue: 0,0:41:26.73,0:41:30.25,EN,,0,0,0,,That slash is divide, another primitive operator.
Dialogue: 0,0:41:30.38,0:41:32.78,EN,,0,0,0,,I've divided B by 5, added it to A.
Dialogue: 0,0:41:33.65,0:41:35.23,EN,,0,0,0,,Lisp says, OK, that's 55.
Dialogue: 0,0:41:36.57,0:41:37.92,EN,,0,0,0,,So there's what it looks like.
Dialogue: 0,0:41:39.82,0:41:43.40,EN,,0,0,0,,There's the basic means of defining something.
Dialogue: 0,0:41:43.44,0:41:49.02,EN,,0,0,0,,It's the simplest kind of naming, but it's not really very powerful.
Dialogue: 0,0:41:50.06,0:41:51.60,EN,,0,0,0,,See, what I'd really like to name--
Dialogue: 0,0:41:51.84,0:41:53.37,EN,,0,0,0,,remember, we're talking about general methods--
Dialogue: 0,0:41:53.57,0:41:57.68,EN,,0,0,0,,I'd like to name, oh, the general idea that, for example,
Dialogue: 0,0:41:58.11,0:42:17.53,EN,,0,0,0,,I could multiply 5 by 5, or 6 by 6, or 1,001 by 1,001, 1,001.7 by 1,001.7.
Dialogue: 0,0:42:17.76,0:42:24.16,EN,,0,0,0,,I'd like to be able to name the general idea of multiplying something by itself.
Dialogue: 0,0:42:28.48,0:42:30.11,EN,,0,0,0,,Well, you know what that is. That's called squaring.
Dialogue: 0,0:42:31.69,0:42:35.63,EN,,0,0,0,,And the way I can do that in Lisp is I can say,
Dialogue: 0,0:42:37.97,0:42:56.25,EN,,0,0,0,,define to square something x, multiply x by itself.
Dialogue: 0,0:42:57.87,0:43:01.12,EN,,0,0,0,,And then having done that, I could say to Lisp,
Dialogue: 0,0:43:01.12,0:43:05.49,EN,,0,0,0,,for example, what's the square of 10?
Dialogue: 0,0:43:06.67,0:43:07.87,EN,,0,0,0,,And Lisp will say 100.
Dialogue: 0,0:43:10.70,0:43:14.24,EN,,0,0,0,,So now let's actually look at that a little more closely.
Dialogue: 0,0:43:15.29,0:43:16.88,EN,,0,0,0,,Right, there's the definition of square.
Dialogue: 0,0:43:17.50,0:43:22.55,EN,,0,0,0,,To square something, multiply it by itself.
Dialogue: 0,0:43:23.69,0:43:25.34,EN,,0,0,0,,You see this x here.
Dialogue: 0,0:43:26.29,0:43:27.81,EN,,0,0,0,,That x is kind of a pronoun,
Dialogue: 0,0:43:27.87,0:43:29.53,EN,,0,0,0,,which is the something that I'm going to square.
Dialogue: 0,0:43:31.49,0:43:37.41,EN,,0,0,0,,And what I do with it is I multiply x, I multiply it by itself.
Dialogue: 0,0:43:42.22,0:43:48.27,EN,,0,0,0,,OK. So there's the notation for defining a procedure.
Dialogue: 0,0:43:48.29,0:43:50.29,EN,,0,0,0,,Actually, this is a little bit confusing,
Dialogue: 0,0:43:50.81,0:43:53.97,EN,,0,0,0,,because this is sort of how I might use square.
Dialogue: 0,0:43:54.00,0:43:56.80,EN,,0,0,0,,And I say square root of x or square root of 10,
Dialogue: 0,0:43:57.55,0:44:00.81,EN,,0,0,0,,but it's not making it very clear that I'm actually naming something.
Dialogue: 0,0:44:03.10,0:44:04.91,EN,,0,0,0,,So let me write this definition in another way
Dialogue: 0,0:44:05.74,0:44:08.21,EN,,0,0,0,,that makes it a little bit more clear that I'm naming something.
Dialogue: 0,0:44:08.54,0:44:29.39,EN,,0,0,0,,I'll say, "define" square to be lambda of x times xx.
Dialogue: 0,0:44:36.56,0:44:42.05,EN,,0,0,0,,Here, I'm naming something square, just like over here, I'm naming something A.
Dialogue: 0,0:44:43.23,0:44:44.72,EN,,0,0,0,,The thing that I'm naming square--
Dialogue: 0,0:44:44.75,0:44:48.39,EN,,0,0,0,,here, the thing I named A was the value of this combination.
Dialogue: 0,0:44:49.29,0:44:52.41,EN,,0,0,0,,Here, the thing that I'm naming square is this thing
Dialogue: 0,0:44:52.43,0:44:53.44,EN,,0,0,0,,that begins with lambda,
Dialogue: 0,0:44:53.45,0:44:56.77,EN,,0,0,0,,and lambda is Lisp's way of saying make a procedure.
Dialogue: 0,0:45:00.24,0:45:02.91,EN,,0,0,0,,Let's look at that more closely on the slide.
Dialogue: 0,0:45:04.27,0:45:05.81,EN,,0,0,0,,The way I read that definition is to say,
Dialogue: 0,0:45:05.85,0:45:10.33,EN,,0,0,0,,I define square to be make a procedure--
Dialogue: 0,0:45:12.78,0:45:13.97,EN,,0,0,0,,that's what the lambda is--
Dialogue: 0,0:45:14.06,0:45:17.49,EN,,0,0,0,,make a procedure with an argument named x.
Dialogue: 0,0:45:19.26,0:45:24.09,EN,,0,0,0,,And what it does is return the results of multiplying x by itself.
Dialogue: 0,0:45:24.97,0:45:33.12,EN,,0,0,0,,Now, in general, we're going to be using this top form of defining,
Dialogue: 0,0:45:33.41,0:45:35.20,EN,,0,0,0,,just because it's a little bit more convenient.
Dialogue: 0,0:45:35.21,0:45:38.67,EN,,0,0,0,,But don't lose sight of the fact that it's really this.
Dialogue: 0,0:45:38.86,0:45:41.41,EN,,0,0,0,,In fact, as far as the Lisp interpreter's concerned,
Dialogue: 0,0:45:41.61,0:45:45.55,EN,,0,0,0,,there's no difference between typing this to it and typing this to it.
Dialogue: 0,0:45:46.51,0:45:53.29,EN,,0,0,0,,And there's a word for that, sort of syntactic sugar.
Dialogue: 0,0:45:54.41,0:45:55.80,EN,,0,0,0,,What syntactic sugar means,
Dialogue: 0,0:45:56.35,0:46:00.83,EN,,0,0,0,,it's having somewhat more convenient surface forms for typing something.
Dialogue: 0,0:46:01.12,0:46:06.11,EN,,0,0,0,,So this is just really syntactic sugar for this underlying Greek thing with the lambda.
Dialogue: 0,0:46:07.31,0:46:10.62,EN,,0,0,0,,And the reason you should remember that is don't forget that,
Dialogue: 0,0:46:10.80,0:46:13.87,EN,,0,0,0,,when I write something like this, I'm really naming something.
Dialogue: 0,0:46:14.46,0:46:16.22,EN,,0,0,0,,I'm naming something square,
Dialogue: 0,0:46:16.24,0:46:19.90,EN,,0,0,0,,and the something that I'm naming square is a procedure that's getting constructed.
Dialogue: 0,0:46:21.20,0:46:23.90,EN,,0,0,0,,Well, let's look at that on the computer, too.
Dialogue: 0,0:46:24.78,0:46:35.95,EN,,0,0,0,,So I'll come and I'll say, define square of x to be times xx.
Dialogue: 0,0:46:49.65,0:46:52.32,EN,,0,0,0,,Now I'll tell Lisp that.
Dialogue: 0,0:46:53.49,0:46:53.92,EN,,0,0,0,,It says "square."
Dialogue: 0,0:46:53.93,0:46:56.29,EN,,0,0,0,,See, I've named something "square."
Dialogue: 0,0:46:56.45,0:47:02.88,EN,,0,0,0,,Now, having done that, I can ask Lisp for, what's the square of 1,001?
Dialogue: 0,0:47:05.26,0:47:17.69,EN,,0,0,0,,Or in general, I could say, what's the square of the sum of 5 and 7?
Dialogue: 0,0:47:22.81,0:47:24.95,EN,,0,0,0,,The square of 12's 144.
Dialogue: 0,0:47:25.07,0:47:28.86,EN,,0,0,0,,Or I can use square itself as an element in some combination.
Dialogue: 0,0:47:28.88,0:47:37.50,EN,,0,0,0,,I can say, what's the sum of the square of 3 and the square of 4?
Dialogue: 0,0:47:42.53,0:47:44.09,EN,,0,0,0,,9 and 16 is 25.
Dialogue: 0,0:47:44.91,0:47:50.54,EN,,0,0,0,,Or I can use square as an element in some much more complicated thing.
Dialogue: 0,0:47:50.59,0:48:00.51,EN,,0,0,0,,I can say, what's the square of, the sqare of, the square of 1,001?
Dialogue: 0,0:48:07.89,0:48:10.63,EN,,0,0,0,,And there's the square of the square of the square of 1,001.
Dialogue: 0,0:48:11.20,0:48:15.45,EN,,0,0,0,,Or I can say to Lisp, what is square itself?
Dialogue: 0,0:48:15.68,0:48:17.16,EN,,0,0,0,,What's the value of that?
Dialogue: 0,0:48:17.44,0:48:22.14,EN,,0,0,0,,And Lisp returns some conventional way of telling me that that's a procedure.
Dialogue: 0,0:48:22.27,0:48:23.98,EN,,0,0,0,,It says, "compound procedure square."
Dialogue: 0,0:48:24.25,0:48:27.92,EN,,0,0,0,,Remember, the value of square is this procedure,
Dialogue: 0,0:48:29.15,0:48:30.89,EN,,0,0,0,,and the thing with the stars and the brackets
Dialogue: 0,0:48:31.10,0:48:34.78,EN,,0,0,0,,are just Lisp's conventional way of describing that.
Dialogue: 0,0:48:36.11,0:48:41.33,EN,,0,0,0,,Let's look at two more examples of defining.
Dialogue: 0,0:48:44.91,0:48:46.91,EN,,0,0,0,,Here are two more procedures.
Dialogue: 0,0:48:47.36,0:48:52.84,EN,,0,0,0,,I can define the average of x and y to be the sum of x and y divided by 2.
Dialogue: 0,0:48:54.67,0:49:01.49,EN,,0,0,0,,Or having had average and mean square, having had average and square,
Dialogue: 0,0:49:01.65,0:49:04.71,EN,,0,0,0,,I can use that to talk about the mean square of something,
Dialogue: 0,0:49:04.91,0:49:09.26,EN,,0,0,0,,which is the average of the square of x and the square of y.
Dialogue: 0,0:49:10.97,0:49:13.63,EN,,0,0,0,,So for example, having done that, I could say,
Dialogue: 0,0:49:13.66,0:49:24.88,EN,,0,0,0,,what's the mean square of 2 and 3?
Dialogue: 0,0:49:25.23,0:49:30.24,EN,,0,0,0,,And I should get the average of 4 and 9, which is 6.5.
Dialogue: 0,0:49:32.85,0:49:36.64,EN,,0,0,0,,The key thing here is that, having defined square,
Dialogue: 0,0:49:36.64,0:49:38.67,EN,,0,0,0,,I can use it as if it were primitive.
Dialogue: 0,0:49:41.41,0:49:43.07,EN,,0,0,0,,So if we look here on the slide,
Dialogue: 0,0:49:44.65,0:49:45.74,EN,,0,0,0,,if I look at mean square,
Dialogue: 0,0:49:47.29,0:49:52.56,EN,,0,0,0,,the person defining mean square doesn't have to know, at this point,
Dialogue: 0,0:49:52.61,0:49:55.76,EN,,0,0,0,,whether square was something built into the language
Dialogue: 0,0:49:56.94,0:49:58.93,EN,,0,0,0,,or whether it was a procedure that was defined.
Dialogue: 0,0:49:59.73,0:50:01.28,EN,,0,0,0,,And that's a key thing in Lisp,
Dialogue: 0,0:50:02.30,0:50:07.52,EN,,0,0,0,,that you do not make arbitrary distinctions between things
Dialogue: 0,0:50:07.53,0:50:11.82,EN,,0,0,0,,that happen to be primitive in the language and things that happen to be built in.
Dialogue: 0,0:50:12.83,0:50:14.73,EN,,0,0,0,,A person using that shouldn't even have to know.
Dialogue: 0,0:50:14.93,0:50:18.51,EN,,0,0,0,,So the things you construct get used with all the power and flexibility
Dialogue: 0,0:50:18.51,0:50:19.53,EN,,0,0,0,,as if they were primitives.
Dialogue: 0,0:50:19.57,0:50:22.57,EN,,0,0,0,,In fact, you can drive that home by looking on the computer one more time.
Dialogue: 0,0:50:24.75,0:50:26.30,EN,,0,0,0,,We talked about plus.
Dialogue: 0,0:50:26.72,0:50:30.09,EN,,0,0,0,,And in fact, if I come here on the computer screen and say,
Dialogue: 0,0:50:30.11,0:50:32.33,EN,,0,0,0,,what is the value of plus?
Dialogue: 0,0:50:34.40,0:50:37.20,EN,,0,0,0,,Notice what Lisp types out. On the bottom there, it typed out,
Dialogue: 0,0:50:37.25,0:50:38.81,EN,,0,0,0,,"compound procedure plus."
Dialogue: 0,0:50:39.89,0:50:42.29,EN,,0,0,0,,Because, in this system,
Dialogue: 0,0:50:42.33,0:50:45.49,EN,,0,0,0,,it turns out that the addition operator is itself a compound procedure.
Dialogue: 0,0:50:45.97,0:50:47.97,EN,,0,0,0,,And if I didn't just type that in, you'd never know that,
Dialogue: 0,0:50:48.06,0:50:49.68,EN,,0,0,0,,and it wouldn't make any difference anyway.
Dialogue: 0,0:50:49.84,0:50:50.51,EN,,0,0,0,,We don't care.
Dialogue: 0,0:50:50.56,0:50:53.39,EN,,0,0,0,,It's below the level of the abstraction that we're dealing with.
Dialogue: 0,0:50:54.17,0:50:59.11,EN,,0,0,0,,So the key thing is you cannot tell, should not be able to tell, in general,
Dialogue: 0,0:50:59.17,0:51:03.82,EN,,0,0,0,,the difference between things that are built in and things that are compound.
Dialogue: 0,0:51:03.84,0:51:04.38,EN,,0,0,0,,Why is that?
Dialogue: 0,0:51:04.38,0:51:08.07,EN,,0,0,0,,Because the things that are compound have an abstraction wrapper wrapped around them.
Dialogue: 0,0:51:09.05,0:51:11.61,EN,,0,0,0,,We've seen almost all the elements of Lisp now.
Dialogue: 0,0:51:12.67,0:51:14.53,EN,,0,0,0,,There's only one more we have to look at,
Dialogue: 0,0:51:14.57,0:51:16.53,EN,,0,0,0,,and that is how to make a case analysis.
Dialogue: 0,0:51:16.59,0:51:17.70,EN,,0,0,0,,Let me show you what I mean.
Dialogue: 0,0:51:18.96,0:51:24.08,EN,,0,0,0,,We might want to think about the mathematical definition of the absolute value functions.
Dialogue: 0,0:51:24.11,0:51:30.03,EN,,0,0,0,,I might say the absolute value of x is the function
Dialogue: 0,0:51:30.16,0:51:37.24,EN,,0,0,0,,which has the property that it's negative of x. For x less than 0,
Dialogue: 0,0:51:37.92,0:51:41.13,EN,,0,0,0,,it's 0 for x equal to 0.
Dialogue: 0,0:51:42.64,0:51:46.62,EN,,0,0,0,,And it's x for x greater than 0.
Dialogue: 0,0:51:49.15,0:51:51.90,EN,,0,0,0,,And Lisp has a way of making case analyses.
Dialogue: 0,0:51:52.11,0:51:53.85,EN,,0,0,0,,Let me define for you absolute value.
Dialogue: 0,0:51:55.55,0:52:02.41,EN,,0,0,0,,Say define the absolute value of x is conditional.
Dialogue: 0,0:52:03.02,0:52:05.67,EN,,0,0,0,,This means case analysis, COND.
Dialogue: 0,0:52:09.23,0:52:19.09,EN,,0,0,0,,If x is less than 0, the answer is negate x.
Dialogue: 0,0:52:22.99,0:52:24.88,EN,,0,0,0,,What I've written here is a clause.
Dialogue: 0,0:52:24.99,0:52:35.54,EN,,0,0,0,,This whole thing is a conditional clause, and it has two parts.
Dialogue: 0,0:52:36.35,0:52:44.70,EN,,0,0,0,,This part here is a predicate or a condition.
Dialogue: 0,0:52:44.83,0:52:45.90,EN,,0,0,0,,That's a condition.
Dialogue: 0,0:52:46.11,0:52:48.29,EN,,0,0,0,,And the condition is expressed by something called a predicate,
Dialogue: 0,0:52:48.33,0:52:51.05,EN,,0,0,0,,and a predicate in Lisp is some sort of thing
Dialogue: 0,0:52:51.37,0:52:52.87,EN,,0,0,0,,that returns either true or false.
Dialogue: 0,0:52:53.53,0:52:56.13,EN,,0,0,0,,And you see Lisp has a primitive procedure, less-than,
Dialogue: 0,0:52:57.29,0:52:59.08,EN,,0,0,0,,that tests whether something is true or false.
Dialogue: 0,0:53:00.54,0:53:06.32,EN,,0,0,0,,And the other part of a clause is an action or a thing to do,
Dialogue: 0,0:53:06.93,0:53:08.14,EN,,0,0,0,,in the case where that's true.
Dialogue: 0,0:53:08.17,0:53:09.81,EN,,0,0,0,,And here, what I'm doing is negating x.
Dialogue: 0,0:53:10.08,0:53:14.41,EN,,0,0,0,,The negation operator, the minus sign in Lisp is a little bit funny.
Dialogue: 0,0:53:14.56,0:53:18.43,EN,,0,0,0,,If there's two or more arguments,
Dialogue: 0,0:53:18.58,0:53:22.49,EN,,0,0,0,,if there's two arguments it subtracts the second one from the first, and we saw that.
Dialogue: 0,0:53:22.53,0:53:24.13,EN,,0,0,0,,And if there's one argument, it negates it.
Dialogue: 0,0:53:25.13,0:53:27.87,EN,,0,0,0,,So this corresponds to that.
Dialogue: 0,0:53:27.87,0:53:29.69,EN,,0,0,0,,And then there's another COND clause.
Dialogue: 0,0:53:30.64,0:53:35.87,EN,,0,0,0,,It says, in the case where x is equal to 0, the answer is 0.
Dialogue: 0,0:53:37.95,0:53:44.75,EN,,0,0,0,,And in the case where x is greater than 0, the answer is x.
Dialogue: 0,0:53:45.33,0:53:49.38,EN,,0,0,0,,Close that clause. Close the COND. Close the definition.
Dialogue: 0,0:53:49.57,0:53:51.29,EN,,0,0,0,,And there's the definition of absolute value.
Dialogue: 0,0:53:51.31,0:53:53.66,EN,,0,0,0,,And you see it's the case analysis that looks very much
Dialogue: 0,0:53:53.66,0:53:56.04,EN,,0,0,0,,like the case analysis you use in mathematics.
Dialogue: 0,0:53:58.14,0:54:03.07,EN,,0,0,0,,There's a somewhat different way of writing a restricted case analysis.
Dialogue: 0,0:54:03.07,0:54:06.24,EN,,0,0,0,,Often, you have a case analysis where you only have one case,
Dialogue: 0,0:54:06.93,0:54:08.07,EN,,0,0,0,,where you test something,
Dialogue: 0,0:54:08.33,0:54:10.75,EN,,0,0,0,,and then depending on whether it's true or false, you do something.
Dialogue: 0,0:54:11.01,0:54:15.90,EN,,0,0,0,,And here's another definition of absolute value
Dialogue: 0,0:54:16.00,0:54:17.19,EN,,0,0,0,,which looks almost the same,
Dialogue: 0,0:54:17.66,0:54:22.56,EN,,0,0,0,,which says, if x is less than 0, the result is negate x.
Dialogue: 0,0:54:24.41,0:54:25.97,EN,,0,0,0,,Otherwise, the answer is x.
Dialogue: 0,0:54:26.05,0:54:27.25,EN,,0,0,0,,And we'll be using "if" a lot.
Dialogue: 0,0:54:27.29,0:54:29.13,EN,,0,0,0,,But again, the thing to remember is that
Dialogue: 0,0:54:29.13,0:54:32.70,EN,,0,0,0,,this form of absolute value that you're looking at here,
Dialogue: 0,0:54:34.30,0:54:36.98,EN,,0,0,0,,and then this one over here that I wrote on the board,
Dialogue: 0,0:54:37.52,0:54:38.80,EN,,0,0,0,,are essentially the same.
Dialogue: 0,0:54:39.09,0:54:42.26,EN,,0,0,0,,And "if" and COND are-- well, whichever way you like it.
Dialogue: 0,0:54:42.30,0:54:44.45,EN,,0,0,0,,You can think of COND as syntactic sugar for "if",
Dialogue: 0,0:54:44.99,0:54:47.36,EN,,0,0,0,,or you can think of "if" as syntactic sugar for COND,
Dialogue: 0,0:54:47.39,0:54:48.65,EN,,0,0,0,,and it doesn't make any difference.
Dialogue: 0,0:54:49.21,0:54:51.35,EN,,0,0,0,,The person implementing a Lisp system will pick one
Dialogue: 0,0:54:51.39,0:54:52.97,EN,,0,0,0,,and implement the other in terms of that.
Dialogue: 0,0:54:53.15,0:54:54.67,EN,,0,0,0,,And it doesn't matter which one you pick.
Dialogue: 0,0:55:02.27,0:55:05.36,EN,,0,0,0,,Why don't we break now, and then take some questions.
Dialogue: 0,0:55:05.69,0:55:10.08,EN,,0,0,0,,How come sometimes when I write define,
Dialogue: 0,0:55:11.09,0:55:14.75,EN,,0,0,0,,I put an open paren here and say,
Dialogue: 0,0:55:14.81,0:55:16.45,EN,,0,0,0,,define open paren something or other,
Dialogue: 0,0:55:16.86,0:55:20.81,EN,,0,0,0,,and sometimes when I write this, I don't put an open paren?
Dialogue: 0,0:55:22.06,0:55:27.23,EN,,0,0,0,,The answer is, this particular form of "define",
Dialogue: 0,0:55:27.26,0:55:29.41,EN,,0,0,0,,where you say define some expression,
Dialogue: 0,0:55:29.47,0:55:32.13,EN,,0,0,0,,is this very special thing for defining procedures.
Dialogue: 0,0:55:33.61,0:55:40.21,EN,,0,0,0,,But again, what it really means is I'm defining this symbol, square, to be that.
Dialogue: 0,0:55:41.45,0:55:45.98,EN,,0,0,0,,So the way you should think about it is what "define" does is you write "define",
Dialogue: 0,0:55:47.15,0:55:50.06,EN,,0,0,0,,and the second thing you write is the symbol here-- no open paren--
Dialogue: 0,0:55:50.17,0:55:51.49,EN,,0,0,0,,the symbol you're defining
Dialogue: 0,0:55:52.08,0:55:53.70,EN,,0,0,0,,and what you're defining it to be.
Dialogue: 0,0:55:54.65,0:55:57.55,EN,,0,0,0,,That's like here and like here.
Dialogue: 0,0:55:57.61,0:56:00.29,EN,,0,0,0,,That's sort of the basic way you use "define."
Dialogue: 0,0:56:01.12,0:56:03.65,EN,,0,0,0,,And then, there's this special syntactic trick
Dialogue: 0,0:56:04.29,0:56:07.04,EN,,0,0,0,,which allows you to define procedures that look like this.
Dialogue: 0,0:56:08.17,0:56:11.49,EN,,0,0,0,,So the difference is, it's whether or not you're defining a procedure.
Dialogue: 0,0:56:12.91,0:56:37.60,EN,,0,0,0,,[JESU, JOY OF MAN'S DESIRING]
Dialogue: 0,0:56:38.05,0:56:41.98,EN,,0,0,0,,Well, believe it or not, you actually now know enough Lisp
Dialogue: 0,0:56:42.78,0:56:45.42,EN,,0,0,0,,to write essentially any numerical procedure
Dialogue: 0,0:56:46.25,0:56:49.63,EN,,0,0,0,,that you'd write in a language like FORTRAN or Basic or whatever,
Dialogue: 0,0:56:49.66,0:56:51.01,EN,,0,0,0,,or, essentially, any other language.
Dialogue: 0,0:56:52.05,0:56:54.76,EN,,0,0,0,,And you're probably saying, that's not believable,
Dialogue: 0,0:56:54.81,0:56:56.65,EN,,0,0,0,,because you know that these languages have things
Dialogue: 0,0:56:56.65,0:57:00.22,EN,,0,0,0,,like "for statements", and "do until while" or something.
Dialogue: 0,0:57:00.99,0:57:04.59,EN,,0,0,0,,But we don't really need any of that.
Dialogue: 0,0:57:05.05,0:57:07.13,EN,,0,0,0,,In fact, we're not going to use any of that in this course.
Dialogue: 0,0:57:08.25,0:57:10.16,EN,,0,0,0,,Let me show you.
Dialogue: 0,0:57:10.25,0:57:13.61,EN,,0,0,0,,Again, looking back at square root,
Dialogue: 0,0:57:13.65,0:57:19.03,EN,,0,0,0,,let's go back to this square root algorithm of Heron of Alexandria.
Dialogue: 0,0:57:19.09,0:57:19.97,EN,,0,0,0,,Remember what that said.
Dialogue: 0,0:57:20.06,0:57:23.67,EN,,0,0,0,,It said, to find an approximation to the square root of X,
Dialogue: 0,0:57:25.07,0:57:26.16,EN,,0,0,0,,you make a guess,
Dialogue: 0,0:57:27.45,0:57:31.88,EN,,0,0,0,,you improve that guess by averaging the guess and X over the guess.
Dialogue: 0,0:57:32.94,0:57:36.06,EN,,0,0,0,,You keep improving that until the guess is good enough.
Dialogue: 0,0:57:36.72,0:57:38.43,EN,,0,0,0,,I already alluded to the idea.
Dialogue: 0,0:57:38.56,0:57:42.24,EN,,0,0,0,,The idea is that, if the initial guess that you took
Dialogue: 0,0:57:43.04,0:57:46.91,EN,,0,0,0,,was actually equal to the square root of X,
Dialogue: 0,0:57:47.15,0:57:50.06,EN,,0,0,0,,then G here would be equal to X/G.
Dialogue: 0,0:57:52.89,0:57:55.33,EN,,0,0,0,,So if you hit the square root, averaging them wouldn't change it.
Dialogue: 0,0:57:55.69,0:57:59.62,EN,,0,0,0,,If the G that you picked was larger than the square root of X,
Dialogue: 0,0:58:00.38,0:58:02.94,EN,,0,0,0,,then X/G will be smaller than the square root of X,
Dialogue: 0,0:58:03.21,0:58:05.37,EN,,0,0,0,,so that when you average G and X/G,
Dialogue: 0,0:58:05.63,0:58:07.57,EN,,0,0,0,,you get something in between.
Dialogue: 0,0:58:08.96,0:58:12.95,EN,,0,0,0,,So if you pick a G that's too small, your answer will be too large.
Dialogue: 0,0:58:13.12,0:58:14.81,EN,,0,0,0,,If you pick a G that's too large,
Dialogue: 0,0:58:16.32,0:58:18.06,EN,,0,0,0,,if your G is larger than the square root of X
Dialogue: 0,0:58:18.08,0:58:20.35,EN,,0,0,0,,and X/G will be smaller than the square root of X.
Dialogue: 0,0:58:21.23,0:58:23.65,EN,,0,0,0,,So averaging always gives you something in between.
Dialogue: 0,0:58:24.53,0:58:28.13,EN,,0,0,0,,And then, it's not quite trivial, but it's possible to show that,
Dialogue: 0,0:58:28.17,0:58:31.76,EN,,0,0,0,,in fact, if G misses the square root of X by a little bit,
Dialogue: 0,0:58:31.81,0:58:37.99,EN,,0,0,0,,the average of G and X/G will actually keep getting closer to the square root of X.
Dialogue: 0,0:58:38.03,0:58:38.99,EN,,0,0,0,,So if you keep doing this enough,
Dialogue: 0,0:58:39.42,0:58:41.18,EN,,0,0,0,,you'll eventually get as close as you want.
Dialogue: 0,0:58:41.71,0:58:42.85,EN,,0,0,0,,And then there's another fact,
Dialogue: 0,0:58:43.02,0:58:47.65,EN,,0,0,0,,that you can always start out this process by using 1 as an initial guess.
Dialogue: 0,0:58:49.23,0:58:51.35,EN,,0,0,0,,And it'll always converge to the square root of X.
Dialogue: 0,0:58:52.24,0:58:56.77,EN,,0,0,0,,So that's this method of successive averaging due to Heron of Alexandria.
Dialogue: 0,0:58:56.81,0:58:59.21,EN,,0,0,0,,Let's write it in Lisp.
Dialogue: 0,0:59:00.57,0:59:02.61,EN,,0,0,0,,Well, the central idea is,
Dialogue: 0,0:59:02.65,0:59:07.19,EN,,0,0,0,,what does it mean to try a guess for the square root of X?
Dialogue: 0,0:59:08.30,0:59:09.37,EN,,0,0,0,,Let's write that.
Dialogue: 0,0:59:09.79,0:59:25.02,EN,,0,0,0,,So we'll say, define to try a guess for the square root of X,
Dialogue: 0,0:59:26.45,0:59:28.24,EN,,0,0,0,,what do we do? We'll say,
Dialogue: 0,0:59:28.29,0:59:45.26,EN,,0,0,0,,if the guess is good enough to be a guess for the square root of X,
Dialogue: 0,0:59:46.54,0:59:49.52,EN,,0,0,0,,then, as an answer, we'll take the guess.
Dialogue: 0,0:59:51.61,0:59:57.01,EN,,0,0,0,,Otherwise, we will try the improved guess.
Dialogue: 0,0:59:58.19,1:00:04.24,EN,,0,0,0,,We'll improve that guess for the square root of X,
Dialogue: 0,1:00:05.26,1:00:09.33,EN,,0,0,0,,and we'll try that as a guess for the square root of X.
Dialogue: 0,1:00:09.36,1:00:12.96,EN,,0,0,0,,Close the "try." Close the "if." Close the "define."
Dialogue: 0,1:00:13.31,1:00:14.81,EN,,0,0,0,,So that's how we try a guess.
Dialogue: 0,1:00:15.85,1:00:17.60,EN,,0,0,0,,And then, the next part of the process said,
Dialogue: 0,1:00:17.73,1:00:21.90,EN,,0,0,0,,in order to compute square roots, we'll say,
Dialogue: 0,1:00:21.93,1:00:30.17,EN,,0,0,0,,define to compute the square root of X,
Dialogue: 0,1:00:30.80,1:00:35.79,EN,,0,0,0,,we will try 1 as a guess for the square root of X.
Dialogue: 0,1:00:37.42,1:00:39.59,EN,,0,0,0,,Well, we have to define a couple more things.
Dialogue: 0,1:00:40.08,1:00:43.36,EN,,0,0,0,,We have to say, how is a guess good enough?
Dialogue: 0,1:00:43.84,1:00:45.29,EN,,0,0,0,,And how do we improve a guess?
Dialogue: 0,1:00:45.85,1:00:47.10,EN,,0,0,0,,So let's look at that.
Dialogue: 0,1:00:47.39,1:00:54.24,EN,,0,0,0,,The algorithm to improve a guess for the square root of X,
Dialogue: 0,1:00:54.64,1:00:57.18,EN,,0,0,0,,we average-- that was the algorithm--
Dialogue: 0,1:00:57.18,1:01:02.16,EN,,0,0,0,,we average the guess with the quotient of dividing X by the guess.
Dialogue: 0,1:01:02.99,1:01:04.57,EN,,0,0,0,,That's how we improve a guess.
Dialogue: 0,1:01:05.85,1:01:08.80,EN,,0,0,0,,And to tell whether a guess is good enough, well, we have to decide something.
Dialogue: 0,1:01:08.86,1:01:11.36,EN,,0,0,0,,This is supposed to be a guess for the square root of X,
Dialogue: 0,1:01:11.37,1:01:14.03,EN,,0,0,0,,so one possible thing you can do is say,
Dialogue: 0,1:01:14.06,1:01:16.07,EN,,0,0,0,,when you take that guess and square it,
Dialogue: 0,1:01:16.64,1:01:18.41,EN,,0,0,0,,do you get something very close to X?
Dialogue: 0,1:01:18.59,1:01:21.10,EN,,0,0,0,,So one way to say that is to say,
Dialogue: 0,1:01:21.12,1:01:24.31,EN,,0,0,0,,I square the guess, subtract X from that,
Dialogue: 0,1:01:25.15,1:01:27.15,EN,,0,0,0,,and see if the absolute value of that
Dialogue: 0,1:01:27.20,1:01:32.05,EN,,0,0,0,,whole thing is less than some small number, which depends on my purposes.
Dialogue: 0,1:01:34.70,1:01:41.42,EN,,0,0,0,,So there's a complete procedure for how to compute the square root of X.
Dialogue: 0,1:01:41.47,1:01:43.53,EN,,0,0,0,,Let's look at the structure of that a little bit.
Dialogue: 0,1:01:47.84,1:01:49.12,EN,,0,0,0,,I have the whole thing.
Dialogue: 0,1:01:49.15,1:01:55.44,EN,,0,0,0,,I have the notion of how to compute a square root.
Dialogue: 0,1:01:55.53,1:01:56.88,EN,,0,0,0,,That's some kind of module.
Dialogue: 0,1:01:57.05,1:01:58.46,EN,,0,0,0,,That's some kind of black box.
Dialogue: 0,1:01:58.72,1:02:08.02,EN,,0,0,0,,It's defined in terms of how to try a guess for the square root of X.
Dialogue: 0,1:02:09.31,1:02:14.10,EN,,0,0,0,,"Try" is defined in terms of, well,
Dialogue: 0,1:02:14.61,1:02:18.03,EN,,0,0,0,,telling whether something is good enough and telling how to improve something.
Dialogue: 0,1:02:18.73,1:02:19.68,EN,,0,0,0,,So good enough.
Dialogue: 0,1:02:19.89,1:02:28.85,EN,,0,0,0,,"Try" is defined in terms of "good enough" and "improve".
Dialogue: 0,1:02:30.96,1:02:32.56,EN,,0,0,0,,And let's see what else I fill in.
Dialogue: 0,1:02:32.71,1:02:34.29,EN,,0,0,0,,Well, I'll go down this tree.
Dialogue: 0,1:02:34.73,1:02:38.49,EN,,0,0,0,,"Good enough" was defined in terms of absolute value, and square.
Dialogue: 0,1:02:40.97,1:02:44.13,EN,,0,0,0,,And improve was defined in terms of something called averaging
Dialogue: 0,1:02:45.17,1:02:46.70,EN,,0,0,0,,and then some other primitive operator.
Dialogue: 0,1:02:46.72,1:02:48.88,EN,,0,0,0,,Square root's defined in terms of "try".
Dialogue: 0,1:02:48.88,1:02:53.31,EN,,0,0,0,,"Try" is defined in terms of "good enough" and "improve",
Dialogue: 0,1:02:54.01,1:02:55.39,EN,,0,0,0,,but also "try" itself.
Dialogue: 0,1:02:55.58,1:03:00.86,EN,,0,0,0,,So "try" is also defined in terms of how to try itself.
Dialogue: 0,1:03:02.75,1:03:04.72,EN,,0,0,0,,Well, that may give you some problems.
Dialogue: 0,1:03:04.72,1:03:08.16,EN,,0,0,0,,Your high school geometry teacher probably told you
Dialogue: 0,1:03:08.67,1:03:12.57,EN,,0,0,0,,that it's naughty to try and define things in terms of themselves,
Dialogue: 0,1:03:12.88,1:03:13.92,EN,,0,0,0,,because it doesn't make sense.
Dialogue: 0,1:03:13.92,1:03:14.72,EN,,0,0,0,,But that's false.
Dialogue: 0,1:03:16.03,1:03:19.68,EN,,0,0,0,,Sometimes it makes perfect sense to define things in terms of themselves.
Dialogue: 0,1:03:20.16,1:03:24.38,EN,,0,0,0,,And this is the case. And we can look at that.
Dialogue: 0,1:03:24.38,1:03:26.89,EN,,0,0,0,,We could write down what this means, and say,
Dialogue: 0,1:03:26.91,1:03:30.33,EN,,0,0,0,,suppose I asked Lisp what the square root of 2 is.
Dialogue: 0,1:03:32.65,1:03:34.67,EN,,0,0,0,,What's the square root of 2 mean?
Dialogue: 0,1:03:35.79,1:03:43.61,EN,,0,0,0,,Well, that means I try 1 as a guess for the square root of 2.
Dialogue: 0,1:03:46.97,1:03:50.92,EN,,0,0,0,,Now I look. I say, gee, is 1 a good enough guess for the square root of 2?
Dialogue: 0,1:03:51.65,1:03:53.69,EN,,0,0,0,,And that depends on the test that "good enough" does.
Dialogue: 0,1:03:54.61,1:03:56.56,EN,,0,0,0,,And in this case, "good enough" will say,
Dialogue: 0,1:03:56.65,1:03:59.05,EN,,0,0,0,,no, 1 is not a good enough guess for the square root of 2.
Dialogue: 0,1:03:59.79,1:04:08.22,EN,,0,0,0,,So that will reduce to saying, I have to try an improved--
Dialogue: 0,1:04:08.64,1:04:12.63,EN,,0,0,0,,improve 1 as a guess for the square root of 2,
Dialogue: 0,1:04:15.15,1:04:17.46,EN,,0,0,0,,and try that as a guess for the square root of 2.
Dialogue: 0,1:04:19.13,1:04:22.07,EN,,0,0,0,,Improving 1 as a guess for the square root of 2
Dialogue: 0,1:04:22.09,1:04:25.08,EN,,0,0,0,,means I average 1 and 2 divided by 1.
Dialogue: 0,1:04:27.10,1:04:29.10,EN,,0,0,0,,So this is going to be average.
Dialogue: 0,1:04:29.58,1:04:39.44,EN,,0,0,0,,This piece here will be the average of 1 and the quotient of 2 by 1.
Dialogue: 0,1:04:40.83,1:04:42.75,EN,,0,0,0,,That's this piece here.
Dialogue: 0,1:04:43.85,1:04:46.72,EN,,0,0,0,,And I'm gonna try... And this is 1.5.
Dialogue: 0,1:04:49.07,1:04:54.40,EN,,0,0,0,,So this square root of 2 reduces to trying 1 for the square root of 2,
Dialogue: 0,1:04:54.56,1:05:04.83,EN,,0,0,0,,which reduces to trying 1.5 as a guess for the square root of 2.
Dialogue: 0,1:05:06.03,1:05:08.06,EN,,0,0,0,,So that makes sense.
Dialogue: 0,1:05:08.11,1:05:09.52,EN,,0,0,0,,Let's look at the rest of the process.
Dialogue: 0,1:05:09.73,1:05:15.00,EN,,0,0,0,,If I try 1.5, that reduces.
Dialogue: 0,1:05:15.01,1:05:19.05,EN,,0,0,0,,1.5 turns out to be not good enough as a guess for the square root of 2.
Dialogue: 0,1:05:20.22,1:05:22.00,EN,,0,0,0,,So that reduces to trying the average of
Dialogue: 0,1:05:22.01,1:05:26.17,EN,,0,0,0,,1.5 and 2 divided by 1.5 as a guess for the square root of 2.
Dialogue: 0,1:05:28.29,1:05:30.37,EN,,0,0,0,,That average turns out to be 1.333.
Dialogue: 0,1:05:31.18,1:05:35.24,EN,,0,0,0,,So this whole thing reduces to trying 1.333 as a guess for the square root of 2.
Dialogue: 0,1:05:35.28,1:05:36.06,EN,,0,0,0,,And then so on.
Dialogue: 0,1:05:38.01,1:05:41.66,EN,,0,0,0,,That reduces to another called a "good enough", 1.4 something or other.
Dialogue: 0,1:05:41.73,1:05:44.47,EN,,0,0,0,,And then it keeps going until the process finally stops
Dialogue: 0,1:05:44.85,1:05:47.92,EN,,0,0,0,,with something that "good enough" thinks is good enough, which,
Dialogue: 0,1:05:47.97,1:05:51.28,EN,,0,0,0,,in this case, is 1.4142 something or other.
Dialogue: 0,1:05:52.51,1:05:56.05,EN,,0,0,0,,So the process makes perfect sense.
Dialogue: 0,1:05:59.93,1:06:03.10,EN,,0,0,0,,This, by the way, is called a recursive definition.
Dialogue: 0,1:06:14.40,1:06:20.96,EN,,0,0,0,,And the ability to make recursive definitions is a source of incredible power.
Dialogue: 0,1:06:21.95,1:06:23.05,EN,,0,0,0,,And as you can already see I've hinted at,
Dialogue: 0,1:06:23.09,1:06:27.21,EN,,0,0,0,,it's the thing that effectively allows you to do these infinite computations
Dialogue: 0,1:06:27.25,1:06:28.83,EN,,0,0,0,,that go on until something is true,
Dialogue: 0,1:06:29.73,1:06:33.66,EN,,0,0,0,,without having any other constricts other than the ability to call a procedure.
Dialogue: 0,1:06:35.97,1:06:37.47,EN,,0,0,0,,Well, let's see, there's one more thing.
Dialogue: 0,1:06:37.71,1:06:44.21,EN,,0,0,0,,Let me show you a variant of this definition of square root here on the slide.
Dialogue: 0,1:06:44.43,1:06:48.16,EN,,0,0,0,,Here's sort of the same thing.
Dialogue: 0,1:06:48.40,1:06:51.49,EN,,0,0,0,,What I've done here is packaged the definitions of
Dialogue: 0,1:06:51.52,1:06:56.16,EN,,0,0,0,,"improve" and "good enough" and "try" inside "square root".
Dialogue: 0,1:06:56.75,1:07:00.99,EN,,0,0,0,,So, in effect, what I've done is I've built a square root box.
Dialogue: 0,1:07:01.81,1:07:08.53,EN,,0,0,0,,So I've built a box that's the square root procedure that someone can use.
Dialogue: 0,1:07:08.57,1:07:11.47,EN,,0,0,0,,They might put in 36 and get out 6.
Dialogue: 0,1:07:11.81,1:07:13.83,EN,,0,0,0,,And then, packaged inside this box
Dialogue: 0,1:07:14.16,1:07:23.85,EN,,0,0,0,,are the definitions of "try" and "good enough" and "improve."
Dialogue: 0,1:07:26.78,1:07:28.35,EN,,0,0,0,,So they're hidden inside this box.
Dialogue: 0,1:07:28.40,1:07:30.76,EN,,0,0,0,,And the reason for doing that is that,
Dialogue: 0,1:07:31.18,1:07:32.85,EN,,0,0,0,,if someone's using this square root,
Dialogue: 0,1:07:33.21,1:07:34.73,EN,,0,0,0,,if George is using this square root,
Dialogue: 0,1:07:34.75,1:07:37.36,EN,,0,0,0,,George probably doesn't care very much that,
Dialogue: 0,1:07:38.29,1:07:40.03,EN,,0,0,0,,when I implemented square root,
Dialogue: 0,1:07:40.21,1:07:44.45,EN,,0,0,0,,I had things inside there called "try" and "good enough" and "improve".
Dialogue: 0,1:07:46.40,1:07:49.33,EN,,0,0,0,,And in fact, Harry might have a cube root procedure
Dialogue: 0,1:07:49.37,1:07:50.96,EN,,0,0,0,,that has "try" and "good enough" and "improve".
Dialogue: 0,1:07:51.44,1:07:53.34,EN,,0,0,0,,And in order to not get the whole system confused,
Dialogue: 0,1:07:53.36,1:07:57.66,EN,,0,0,0,,it'd be good for Harry to package his internal procedures inside his cube root procedure.
Dialogue: 0,1:07:58.40,1:08:00.06,EN,,0,0,0,,Well, this is called block structure,
Dialogue: 0,1:08:00.32,1:08:08.96,EN,,0,0,0,,this particular way of packaging internals inside of a definition.
Dialogue: 0,1:08:09.97,1:08:12.96,EN,,0,0,0,,And let's go back and look at the slide again.
Dialogue: 0,1:08:13.12,1:08:18.57,EN,,0,0,0,,The way to read this kind of procedure is to say, to define "square root",
Dialogue: 0,1:08:19.87,1:08:21.84,EN,,0,0,0,,well, inside that definition,
Dialogue: 0,1:08:22.13,1:08:25.49,EN,,0,0,0,,I'll have the definition of an "improve" and
Dialogue: 0,1:08:25.56,1:08:28.88,EN,,0,0,0,,the definition of "good enough" and the definition of "try."
Dialogue: 0,1:08:29.73,1:08:32.38,EN,,0,0,0,,And then, subject to those definitions,
Dialogue: 0,1:08:32.48,1:08:35.07,EN,,0,0,0,,the way I do square root is to try 1.
Dialogue: 0,1:08:36.08,1:08:39.33,EN,,0,0,0,,And notice here, I don't have to say 1 as a guess for the square root of X,
Dialogue: 0,1:08:39.87,1:08:42.32,EN,,0,0,0,,because since it's all inside the square root,
Dialogue: 0,1:08:42.84,1:08:44.65,EN,,0,0,0,,it sort of has this X known.
Dialogue: 0,1:08:54.06,1:08:56.37,EN,,0,0,0,,Let me summarize.
Dialogue: 0,1:08:56.49,1:08:59.49,EN,,0,0,0,,We started out with the idea that
Dialogue: 0,1:08:59.51,1:09:03.18,EN,,0,0,0,,what we're going to be doing is expressing imperative knowledge.
Dialogue: 0,1:09:04.99,1:09:09.74,EN,,0,0,0,,And in fact, here's a slide that summarizes the way we looked at Lisp.
Dialogue: 0,1:09:09.74,1:09:15.12,EN,,0,0,0,,We started out by looking at some primitive elements in addition and multiplication,
Dialogue: 0,1:09:15.85,1:09:19.50,EN,,0,0,0,,some predicates for testing whether something is less-than or something's equal.
Dialogue: 0,1:09:19.52,1:09:22.99,EN,,0,0,0,,And in fact, we saw really sneakily in the system we're actually using,
Dialogue: 0,1:09:23.02,1:09:25.85,EN,,0,0,0,,these aren't actually primitives, but it doesn't matter.
Dialogue: 0,1:09:26.62,1:09:28.59,EN,,0,0,0,,What matters is we're going to use them as if they're primitives.
Dialogue: 0,1:09:28.61,1:09:29.81,EN,,0,0,0,,We're not going to look inside.
Dialogue: 0,1:09:30.29,1:09:33.15,EN,,0,0,0,,We also have some primitive data and some numbers.
Dialogue: 0,1:09:34.62,1:09:37.66,EN,,0,0,0,,We saw some means of composition, means of combination,
Dialogue: 0,1:09:37.74,1:09:41.37,EN,,0,0,0,,the basic one being composing functions and
Dialogue: 0,1:09:41.41,1:09:43.76,EN,,0,0,0,,building combinations with operators and operands.
Dialogue: 0,1:09:44.81,1:09:48.43,EN,,0,0,0,,And there were some other things, like COND and "if" and "define".
Dialogue: 0,1:09:51.29,1:09:53.69,EN,,0,0,0,,But the main thing about "define," in particular,
Dialogue: 0,1:09:53.87,1:09:55.71,EN,,0,0,0,,was that it was the means of abstraction.
Dialogue: 0,1:09:55.73,1:09:57.70,EN,,0,0,0,,It was the way that we name things.
Dialogue: 0,1:09:57.79,1:10:00.30,EN,,0,0,0,,You can also see from this slide not only where we've been,
Dialogue: 0,1:10:01.57,1:10:06.28,EN,,0,0,0,,At some point, we'll have to talk about how you combine primitive data to get compound data,
Dialogue: 0,1:10:06.56,1:10:12.03,EN,,0,0,0,,and how you abstract data so you can use large globs of data
Dialogue: 0,1:10:12.06,1:10:13.07,EN,,0,0,0,,as if they were primitive.
Dialogue: 0,1:10:13.90,1:10:15.87,EN,,0,0,0,,So that's where we're going.
Dialogue: 0,1:10:16.38,1:10:22.05,EN,,0,0,0,,But before we do that, for the next couple of lectures we're going to be talking about,
Dialogue: 0,1:10:23.26,1:10:26.76,EN,,0,0,0,,first of all, how it is that you make a link
Dialogue: 0,1:10:26.88,1:10:30.77,EN,,0,0,0,,between these procedures we write and the processes that happen in the machine.
Dialogue: 0,1:10:32.14,1:10:35.98,EN,,0,0,0,,And then, how it is that you start using the power of Lisp
Dialogue: 0,1:10:36.38,1:10:39.77,EN,,0,0,0,,to talk not only about these individual little computations,
Dialogue: 0,1:10:40.08,1:10:44.15,EN,,0,0,0,,but about general conventional methods of doing things.
Dialogue: 0,1:10:44.81,1:10:46.17,EN,,0,0,0,,OK, are there any questions?
Dialogue: 0,1:10:46.75,1:10:52.27,EN,,0,0,0,,AUDIENCE: Yes. If we defined A using parentheses instead of as we did,
Dialogue: 0,1:10:52.32,1:10:53.50,EN,,0,0,0,,what would be the difference?
Dialogue: 0,1:10:53.60,1:10:56.88,EN,,0,0,0,,PROFESSOR: If I wrote this, if I wrote that,
Dialogue: 0,1:10:57.53,1:11:02.13,EN,,0,0,0,,what I would be doing is defining a procedure named A.
Dialogue: 0,1:11:03.21,1:11:06.85,EN,,0,0,0,,In this case, a procedure of no arguments, which,
Dialogue: 0,1:11:06.85,1:11:09.61,EN,,0,0,0,,when I ran it, would give me back 5 times 5.
Dialogue: 0,1:11:11.07,1:11:12.29,EN,,0,0,0,,AUDIENCE: Right. I mean, you come up with the same thing,
Dialogue: 0,1:11:12.32,1:11:13.92,EN,,0,0,0,,except for you really got a different--
Dialogue: 0,1:11:14.05,1:11:16.63,EN,,0,0,0,,PROFESSOR: Right. And the difference would be, in the old one--
Dialogue: 0,1:11:17.02,1:11:18.35,EN,,0,0,0,,Let me be a little bit clearer here.
Dialogue: 0,1:11:19.13,1:11:23.44,EN,,0,0,0,,Let's call this A, like here.
Dialogue: 0,1:11:24.13,1:11:27.76,EN,,0,0,0,,And pretend here, just for contrast, I wrote,
Dialogue: 0,1:11:27.79,1:11:37.56,EN,,0,0,0,,define D to be the product of 5 and 5.
Dialogue: 0,1:11:40.22,1:11:41.57,EN,,0,0,0,,And the difference between those,
Dialogue: 0,1:11:41.96,1:11:44.24,EN,,0,0,0,,let's think about interactions with the Lisp interpreter.
Dialogue: 0,1:11:45.74,1:11:49.13,EN,,0,0,0,,I could type in A and Lisp would return 25.
Dialogue: 0,1:11:52.83,1:11:57.81,EN,,0,0,0,,I could type in D, if I just typed in D,
Dialogue: 0,1:11:58.49,1:12:05.55,EN,,0,0,0,,Lisp would return compound procedure D,
Dialogue: 0,1:12:07.12,1:12:09.13,EN,,0,0,0,,because that's what it is. It's a procedure.
Dialogue: 0,1:12:09.69,1:12:12.59,EN,,0,0,0,,I could run D. I could say, what's the value of running D?
Dialogue: 0,1:12:12.59,1:12:15.23,EN,,0,0,0,,Here is a combination with no operands.
Dialogue: 0,1:12:16.45,1:12:19.07,EN,,0,0,0,,I see there are no operands. I didn't put any after D.
Dialogue: 0,1:12:19.39,1:12:21.34,EN,,0,0,0,,And it would say, oh, that's 25.
Dialogue: 0,1:12:23.01,1:12:29.52,EN,,0,0,0,,Or I could say, just for completeness, if I typed in, what's the value of running A?
Dialogue: 0,1:12:29.54,1:12:30.57,EN,,0,0,0,,I get an error.
Dialogue: 0,1:12:31.79,1:12:35.29,EN,,0,0,0,,The error would be the same one as over there.
Dialogue: 0,1:12:35.33,1:12:40.51,EN,,0,0,0,,It'd be the error would say, sorry, 25, which is the value of A,
Dialogue: 0,1:12:40.56,1:12:43.24,EN,,0,0,0,,is not an operator that I can apply to something.
Dialogue: 0,0:00:00.01,0:00:03.77,Declare,,0,0,0,,{\fad(200,200)}哈尔滨工业大学 IBM技术中心
Dialogue: 0,0:00:00.01,0:00:03.77,Declare,,0,0,0,,{\fad(200,200)\an2}倾情制作
Dialogue: 0,0:00:04.08,0:00:11.36,title,,0,0,0,,{\fad(600,800)\pos(324,32)}计算机程序的构造和解释
Dialogue: 0,0:00:04.08,0:00:11.05,staff,,0,0,0,,{\fad(600,800)\pos(534.666,404)}字幕&时间轴\N邓雄飞\N(Dysprosium)
Dialogue: 0,0:00:04.08,0:00:11.05,staff,,0,0,0,,{\fad(600,800)\pos(110.666,403.334)}后期&特效\N蔡钟毓\N(JohnTitor)
Dialogue: 0,0:00:04.08,0:00:11.06,staff,,0,0,0,,{\fad(600,800)\pos(574.667,277.333)}校对\N匿名
Dialogue: 0,0:00:04.08,0:00:11.06,staff,,0,0,0,,{\fad(600,800)\pos(89.334,273.333)}特别感谢\N裘宗燕教授
Dialogue: 0,0:00:14.71,0:00:17.89,Default,,0,0,0,,欢迎大家来一起学习这门计算机科学的基础课程
Dialogue: 0,0:00:28.40,0:00:29.85,Default,,0,0,0,,事实上 以这样的方式来表述并不恰当
Dialogue: 0,0:00:29.85,0:00:32.34,Default,,0,0,0,,于此来说 计算机科学是个糟糕的名字
Dialogue: 0,0:00:32.83,0:00:34.30,Default,,0,0,0,,首先 它不算是一门科学
Dialogue: 0,0:00:35.92,0:00:39.47,Default,,0,0,0,,它更应该被称为工程或者是艺术
Dialogue: 0,0:00:40.09,0:00:42.91,Default,,0,0,0,,但我们实际上会发现 这个所谓的计算机科学
Dialogue: 0,0:00:42.93,0:00:44.97,Default,,0,0,0,,却与魔法一样的有众多神奇之处
Dialogue: 0,0:00:45.01,0:00:46.35,Default,,0,0,0,,这些将会在课程中一一体现
Dialogue: 0,0:00:47.28,0:00:48.22,Default,,0,0,0,,所以 不能称其为一门科学
Dialogue: 0,0:00:49.09,0:00:52.30,Default,,0,0,0,,这门学科和“计算机”也并非紧密相关
Dialogue: 0,0:00:53.39,0:00:55.47,Default,,0,0,0,,类似的 就像我们说
Dialogue: 0,0:00:55.47,0:01:00.05,Default,,0,0,0,,物理学中并不仅仅有关粒子加速器
Dialogue: 0,0:01:00.80,0:01:05.58,Default,,0,0,0,,生物学中并不全然是显微镜和培养皿一样
Dialogue: 0,0:01:06.46,0:01:10.25,Default,,0,0,0,,同理
Dialogue: 0,0:01:10.31,0:01:14.88,Default,,0,0,0,,几何学中也并不全是介绍如何使用测量仪器
Dialogue: 0,0:01:16.48,0:01:19.01,Default,,0,0,0,,事实上 计算机科学和几何学
Dialogue: 0,0:01:19.33,0:01:21.45,Default,,0,0,0,,有很多共性
Dialogue: 0,0:01:21.45,0:01:22.66,Default,,0,0,0,,首先 几何学
Dialogue: 0,0:01:23.02,0:01:24.98,Default,,0,0,0,,只是另一个有个糟糕名字的学科
Dialogue: 0,0:01:25.58,0:01:27.85,Default,,0,0,0,,这个名字来自于Gaia 意为土地
Dialogue: 0,0:01:27.90,0:01:29.09,Default,,0,0,0,,以及metron 意为测量
Dialogue: 0,0:01:29.82,0:01:33.39,Default,,0,0,0,,几何学最初意为测地或者勘探
Dialogue: 0,0:01:34.37,0:01:36.89,Default,,0,0,0,,这是因为数千年前的埃及祭司
Dialogue: 0,0:01:37.69,0:01:41.69,Default,,0,0,0,,为了计算如何去修复年年被尼罗河的洪水
Dialogue: 0,0:01:42.59,0:01:46.33,Default,,0,0,0,,所毁坏的牧田边界
Dialogue: 0,0:01:46.35,0:01:48.69,Default,,0,0,0,,而建立了几何学基础
Dialogue: 0,0:01:49.47,0:01:50.65,Default,,0,0,0,,而对出于这个目的的埃及人来说
Dialogue: 0,0:01:50.65,0:01:53.93,Default,,0,0,0,,几何学的确是掌握对测量仪器的使用
Dialogue: 0,0:01:55.63,0:01:58.55,Default,,0,0,0,,现在 我们以为计算机科学就是介绍计算机的使用
Dialogue: 0,0:01:58.57,0:02:02.49,Default,,0,0,0,,就正如埃及人认为
Dialogue: 0,0:02:02.51,0:02:04.10,Default,,0,0,0,,几何学是介绍如何使用测量仪器的
Dialogue: 0,0:02:04.59,0:02:07.37,Default,,0,0,0,,换句话说 任何一门学科起步的时候
Dialogue: 0,0:02:07.39,0:02:09.86,Default,,0,0,0,,你都对它了解不深
Dialogue: 0,0:02:11.10,0:02:16.64,Default,,0,0,0,,这很容易使你混淆所做的事与所用之物
Dialogue: 0,0:02:17.65,0:02:20.30,Default,,0,0,0,,确实 就绝对规模来说
Dialogue: 0,0:02:20.30,0:02:24.82,Default,,0,0,0,,我们对计算机科学的实质的了解
Dialogue: 0,0:02:24.83,0:02:27.49,Default,,0,0,0,,比埃及人对几何学的了解还少
Dialogue: 0,0:02:30.25,0:02:32.64,Default,,0,0,0,,那么 我所谓的计算机科学的本质是什么呢
Dialogue: 0,0:02:32.65,0:02:34.41,Default,,0,0,0,,我所谓的几何学本质又是什么呢
Dialogue: 0,0:02:34.41,0:02:36.45,Default,,0,0,0,,看 可以确认的是 古埃及人确实使用测量仪器
Dialogue: 0,0:02:36.46,0:02:37.67,Default,,0,0,0,,并且已经消失多年
Dialogue: 0,0:02:37.69,0:02:41.55,Default,,0,0,0,,但当我们在几千年后回过头来重新审视这段历史
Dialogue: 0,0:02:41.57,0:02:41.85,Default,,0,0,0,,我们会说
Dialogue: 0,0:02:41.87,0:02:43.64,Default,,0,0,0,,天啊 看他们在做什么
Dialogue: 0,0:02:43.71,0:02:45.48,Default,,0,0,0,,他们的工作是多么的重要
Dialogue: 0,0:02:45.62,0:02:50.45,Default,,0,0,0,,已经开始对时间和空间进行形式化表述
Dialogue: 0,0:02:51.58,0:02:57.53,Default,,0,0,0,,并归纳出一套讨论数学真理的形式化方法
Dialogue: 0,0:02:58.01,0:02:59.61,Default,,0,0,0,,这直接导致了公理化方法
Dialogue: 0,0:02:59.61,0:03:02.53,Default,,0,0,0,,以及各种现代数学的产生
Dialogue: 0,0:03:04.16,0:03:06.90,Default,,0,0,0,,同时也指明了一种精确讨论
Dialogue: 0,0:03:07.25,0:03:10.19,Default,,0,0,0,,所谓的描述真理的陈述性知识的方法
Dialogue: 0,0:03:12.45,0:03:16.25,Default,,0,0,0,,与此相似的 我认为未来人们会回过头来审视并说
Dialogue: 0,0:03:16.27,0:03:19.36,Default,,0,0,0,,啊 这些20世纪的原始人
Dialogue: 0,0:03:19.36,0:03:21.20,Default,,0,0,0,,不务正业地玩弄着叫计算机的小玩意
Dialogue: 0,0:03:21.77,0:03:26.25,Default,,0,0,0,,但它们真正在做的是开始学习
Dialogue: 0,0:03:26.25,0:03:32.55,Default,,0,0,0,,如何去对计算过程进行形式化表述
Dialogue: 0,0:03:32.64,0:03:34.13,Default,,0,0,0,,如何去解决问题
Dialogue: 0,0:03:39.02,0:03:51.25,Default,,0,0,0,,并结合两者发展一套对问题处理过程精确表述的方法
Dialogue: 0,0:03:51.76,0:03:56.03,Default,,0,0,0,,这与讨论真理的几何学形成了对照
Dialogue: 0,0:03:56.53,0:03:58.57,Default,,0,0,0,,让我给你们举个例子吧
Dialogue: 0,0:04:02.30,0:04:02.69,Default,,0,0,0,,来瞧瞧
Dialogue: 0,0:04:02.70,0:04:09.82,Default,,0,0,0,,数学中是这样来定义平方根的:
Dialogue: 0,0:04:10.09,0:04:14.35,Default,,0,0,0,,定义X的平方根Y是这样一个数
Dialogue: 0,0:04:15.98,0:04:20.38,Default,,0,0,0,,Y的平方等于X 且Y大于等于0
Dialogue: 0,0:04:20.43,0:04:22.50,Default,,0,0,0,,这是一个很好的定义
Dialogue: 0,0:04:22.88,0:04:25.25,Default,,0,0,0,,但它只告诉了你平方根是什么
Dialogue: 0,0:04:25.63,0:04:30.29,Default,,0,0,0,,却没有告诉你如何去求取一个平方根
Dialogue: 0,0:04:31.42,0:04:35.90,Default,,0,0,0,,那么我们将其与一条指令性知识做比较
Dialogue: 0,0:04:37.13,0:04:39.92,Default,,0,0,0,,你如何去求取一个平方根
Dialogue: 0,0:04:39.95,0:04:45.74,Default,,0,0,0,,事实上 这来自于埃及 不太久远的埃及
Dialogue: 0,0:04:45.76,0:04:48.88,Default,,0,0,0,,亚历山大的Heron提出的一个算法
Dialogue: 0,0:04:49.90,0:04:52.77,Default,,0,0,0,,称作连续取均值求平方根法
Dialogue: 0,0:04:52.89,0:04:55.13,Default,,0,0,0,,这个算法是说
Dialogue: 0,0:04:55.15,0:04:58.06,Default,,0,0,0,,为了算出平方根
Dialogue: 0,0:05:03.34,0:05:08.33,Default,,0,0,0,,首先你应该给出一个猜测值guess 并不断改进
Dialogue: 0,0:05:10.19,0:05:11.44,Default,,0,0,0,,改进的方法是通过
Dialogue: 0,0:05:11.45,0:05:13.95,Default,,0,0,0,,不断求猜测值guess与X/guess的平均值
Dialogue: 0,0:05:14.41,0:05:15.60,Default,,0,0,0,,我们稍后将会讨论
Dialogue: 0,0:05:15.61,0:05:17.12,Default,,0,0,0,,为什么这是合理的
Dialogue: 0,0:05:17.14,0:05:19.37,Default,,0,0,0,,通过不断改进 直到它足够精确
Dialogue: 0,0:05:19.73,0:05:20.85,Default,,0,0,0,,这就是实现方法
Dialogue: 0,0:05:20.99,0:05:24.65,Default,,0,0,0,,这也是如何完成一项工作与
Dialogue: 0,0:05:24.72,0:05:27.33,Default,,0,0,0,,其对应的陈述性知识的对照
Dialogue: 0,0:05:28.05,0:05:29.76,Default,,0,0,0,,这就是一个过程
Dialogue: 0,0:05:34.40,0:05:38.25,Default,,0,0,0,,那么 通常来说什么是过程呢？
Dialogue: 0,0:05:39.01,0:05:40.14,Default,,0,0,0,,这定义起来非常困难
Dialogue: 0,0:05:40.16,0:05:43.72,Default,,0,0,0,,你可以将它象征性地看成一个活在计算机内
Dialogue: 0,0:05:44.77,0:05:47.33,Default,,0,0,0,,并且可以完成一些操作的精灵
Dialogue: 0,0:05:48.01,0:05:54.11,Default,,0,0,0,,一些被称为程序的规则模式
Dialogue: 0,0:05:54.13,0:05:57.98,Default,,0,0,0,,指导着这类过程的进行
Dialogue: 0,0:06:01.98,0:06:04.73,Default,,0,0,0,,程序可以被认为是符咒
Dialogue: 0,0:06:05.23,0:06:09.40,Default,,0,0,0,,使用程序来控制这些精灵完成一些操作就叫做过程
Dialogue: 0,0:06:10.75,0:06:12.75,Default,,0,0,0,,你们知道人人都需要一门魔法语言
Dialogue: 0,0:06:12.77,0:06:14.55,Default,,0,0,0,,那些魔术师 真正的魔术师 用远古的阿卡狄亚语
Dialogue: 0,0:06:14.57,0:06:18.59,Default,,0,0,0,,或者苏美尔语 或者巴比伦语 或者其它的
Dialogue: 0,0:06:18.62,0:06:20.09,Default,,0,0,0,,而我们将用一门叫Lisp的魔法语言
Dialogue: 0,0:06:20.13,0:06:22.71,Default,,0,0,0,,来召唤出我们的精灵
Dialogue: 0,0:06:24.37,0:06:28.01,Default,,0,0,0,,这门语言是被设计用来
Dialogue: 0,0:06:28.57,0:06:31.84,Default,,0,0,0,,编写如咒语版的程序 来指导过程的进行
Dialogue: 0,0:06:31.87,0:06:33.91,Default,,0,0,0,,学习Lisp非常容易
Dialogue: 0,0:06:33.97,0:06:35.98,Default,,0,0,0,,事实上 我会在几分钟内教会你
Dialogue: 0,0:06:36.00,0:06:37.16,Default,,0,0,0,,整个Lisp
Dialogue: 0,0:06:37.37,0:06:38.96,Default,,0,0,0,,及其所有的规则
Dialogue: 0,0:06:40.77,0:06:43.65,Default,,0,0,0,,你不必感到很惊讶
Dialogue: 0,0:06:43.69,0:06:45.87,Default,,0,0,0,,这就像你在学习象棋时
Dialogue: 0,0:06:45.90,0:06:47.01,Default,,0,0,0,,认为象棋的规则十分简单一样
Dialogue: 0,0:06:47.04,0:06:48.13,Default,,0,0,0,,事实也如此 几分钟内
Dialogue: 0,0:06:48.17,0:06:49.70,Default,,0,0,0,,你可以与任何人谈论象棋的规则
Dialogue: 0,0:06:50.81,0:06:52.24,Default,,0,0,0,,但是 这全然不等同于说
Dialogue: 0,0:06:52.25,0:06:55.37,Default,,0,0,0,,你所知道这些规则所蕴含的东西
Dialogue: 0,0:06:55.42,0:06:58.05,Default,,0,0,0,,以及如何利用这些规则去成为象棋大师
Dialogue: 0,0:06:58.49,0:06:59.82,Default,,0,0,0,,Lisp也是如此
Dialogue: 0,0:07:00.41,0:07:02.18,Default,,0,0,0,,我将在几分钟内道清规则
Dialogue: 0,0:07:02.36,0:07:03.55,Default,,0,0,0,,这说起来非常容易
Dialogue: 0,0:07:03.62,0:07:07.09,Default,,0,0,0,,但真正困难的是如何运用这些规则
Dialogue: 0,0:07:07.32,0:07:10.46,Default,,0,0,0,,以及你如何利用这些规则成为编程大师
Dialogue: 0,0:07:12.06,0:07:15.29,Default,,0,0,0,,这些规则的应用将占据我们
Dialogue: 0,0:07:15.31,0:07:18.56,Default,,0,0,0,,余下的课程 甚至更多
Dialogue: 0,0:07:21.45,0:07:23.11,Default,,0,0,0,,所以 在计算机科学中
Dialogue: 0,0:07:24.49,0:07:26.19,Default,,0,0,0,,我们的任务则是
Dialogue: 0,0:07:26.21,0:07:30.58,Default,,0,0,0,,形式化这种如有关“怎么做”的指令性知识
Dialogue: 0,0:07:30.62,0:07:32.10,Default,,0,0,0,,并将之付诸实际
Dialogue: 0,0:07:33.37,0:07:35.39,Default,,0,0,0,,这也便是计算机科学的真正的议题
Dialogue: 0,0:07:35.41,0:07:38.36,Default,,0,0,0,,当然 并不是告诉人们如何去求平方根
Dialogue: 0,0:07:39.09,0:07:40.06,Default,,0,0,0,,因为如果那是计算机科学的全部的的话
Dialogue: 0,0:07:40.09,0:07:41.34,Default,,0,0,0,,就不会有什么大问题了
Dialogue: 0,0:07:41.57,0:07:44.05,Default,,0,0,0,,真正的问题来自于当我们尝试
Dialogue: 0,0:07:44.08,0:07:46.16,Default,,0,0,0,,构建非常非常大的系统时
Dialogue: 0,0:07:46.61,0:07:49.53,Default,,0,0,0,,程序可能会长达数千页
Dialogue: 0,0:07:49.58,0:07:53.98,Default,,0,0,0,,长得没有人能马上将其装入脑中
Dialogue: 0,0:07:54.73,0:07:58.81,Default,,0,0,0,,而使这些得以实现则是因为
Dialogue: 0,0:07:58.86,0:08:18.97,Default,,0,0,0,,我们有在大系统中控制复杂度的技术
Dialogue: 0,0:08:20.30,0:08:22.69,Default,,0,0,0,,这些控制复杂度的技术
Dialogue: 0,0:08:22.72,0:08:24.17,Default,,0,0,0,,正是我们课程所讨论的
Dialogue: 0,0:08:24.65,0:08:25.47,Default,,0,0,0,,从某种意义上来说
Dialogue: 0,0:08:25.50,0:08:27.47,Default,,0,0,0,,这也正是计算机科学的关键所在
Dialogue: 0,0:08:29.63,0:08:31.89,Default,,0,0,0,,这样说听起来或许很奇怪
Dialogue: 0,0:08:31.92,0:08:35.61,Default,,0,0,0,,毕竟 除了计算机科学家外
Dialogue: 0,0:08:35.65,0:08:37.82,Default,,0,0,0,,仍然有很多人在做复杂度控制相关的工作
Dialogue: 0,0:08:37.84,0:08:41.02,Default,,0,0,0,,一个航班就是一个非常复杂的系统
Dialogue: 0,0:08:41.82,0:08:43.79,Default,,0,0,0,,设计它的航空工程师
Dialogue: 0,0:08:44.05,0:08:46.13,Default,,0,0,0,,便在处理这个巨大的复杂度
Dialogue: 0,0:08:47.09,0:08:50.19,Default,,0,0,0,,但这种复杂度又与
Dialogue: 0,0:08:50.75,0:08:52.60,Default,,0,0,0,,计算机科学中的（复杂度）有别
Dialogue: 0,0:08:55.18,0:08:57.73,Default,,0,0,0,,从某种意义上来说
Dialogue: 0,0:08:57.79,0:09:00.09,Default,,0,0,0,,因为计算机科学不是“现实”的
Dialogue: 0,0:09:02.69,0:09:06.62,Default,,0,0,0,,例如 当一名工程师设计物理系统时
Dialogue: 0,0:09:07.14,0:09:08.49,Default,,0,0,0,,这些都是由实在的物理部件构成
Dialogue: 0,0:09:09.40,0:09:11.18,Default,,0,0,0,,负责的该工作的工程师
Dialogue: 0,0:09:11.85,0:09:16.65,Default,,0,0,0,,就得对付系统中的公差、近似值以及噪声
Dialogue: 0,0:09:16.67,0:09:19.02,Default,,0,0,0,,譬如说 作为一名电气工程师
Dialogue: 0,0:09:19.09,0:09:21.71,Default,,0,0,0,,可以很容易的做一个单极放大器
Dialogue: 0,0:09:21.73,0:09:23.03,Default,,0,0,0,,或者是一个双极放大器
Dialogue: 0,0:09:23.41,0:09:25.39,Default,,0,0,0,,也可想象将其大量串联
Dialogue: 0,0:09:25.45,0:09:26.91,Default,,0,0,0,,来建造一个百万极的放大器
Dialogue: 0,0:09:26.99,0:09:28.75,Default,,0,0,0,,但这样做是不可行的
Dialogue: 0,0:09:28.98,0:09:32.15,Default,,0,0,0,,因为在远没到百万数量级的时候
Dialogue: 0,0:09:32.16,0:09:34.56,Default,,0,0,0,,这种组合方法打从头产生的热噪声
Dialogue: 0,0:09:34.57,0:09:36.80,Default,,0,0,0,,会慢慢增强 并使得我们的幸苦付之一炬
Dialogue: 0,0:09:39.10,0:09:43.12,Default,,0,0,0,,计算机科学处理的是理想化组件
Dialogue: 0,0:09:44.12,0:09:47.63,Default,,0,0,0,,我们对将要结合在一起的
Dialogue: 0,0:09:47.65,0:09:49.56,Default,,0,0,0,,程序和数据了如指掌
Dialogue: 0,0:09:51.90,0:09:53.20,Default,,0,0,0,,我们不需要去关心公差
Dialogue: 0,0:09:53.21,0:09:56.99,Default,,0,0,0,,也就是说 在构建大系统时
Dialogue: 0,0:09:58.13,0:10:00.03,Default,,0,0,0,,在我理想和现实之间
Dialogue: 0,0:10:00.35,0:10:04.18,Default,,0,0,0,,并不没有太大的不同
Dialogue: 0,0:10:05.53,0:10:07.60,Default,,0,0,0,,因为这些部分都是抽象单元
Dialogue: 0,0:10:07.63,0:10:10.32,Default,,0,0,0,,可以随心所欲的组合
Dialogue: 0,0:10:10.33,0:10:12.39,Default,,0,0,0,,可以据目前所知而自由构建
Dialogue: 0,0:10:13.45,0:10:15.50,Default,,0,0,0,,就是与其它的工程不同之处
Dialogue: 0,0:10:15.66,0:10:17.42,Default,,0,0,0,,（在其它的工程中）对你所构建系统的约束
Dialogue: 0,0:10:17.44,0:10:18.90,Default,,0,0,0,,来自于物理系统以及
Dialogue: 0,0:10:18.94,0:10:21.02,Default,,0,0,0,,物理定律 噪声 近似值等
Dialogue: 0,0:10:21.21,0:10:25.60,Default,,0,0,0,,而建立大型软件系统时所施加的约束
Dialogue: 0,0:10:25.64,0:10:27.58,Default,,0,0,0,,就是对我们大脑的限制
Dialogue: 0,0:10:29.12,0:10:29.98,Default,,0,0,0,,从这个角度来看
Dialogue: 0,0:10:30.00,0:10:33.67,Default,,0,0,0,,计算机科学就像是工程中的一种抽象形式
Dialogue: 0,0:10:33.80,0:10:35.73,Default,,0,0,0,,在这种工程中 我们忽略
Dialogue: 0,0:10:35.76,0:10:38.02,Default,,0,0,0,,现实所施加的约束
Dialogue: 0,0:10:41.97,0:10:46.15,Default,,0,0,0,,那么 这其中有哪些技术呢
Dialogue: 0,0:10:46.28,0:10:48.39,Default,,0,0,0,,计算机科学中并没有特别的技术
Dialogue: 0,0:10:50.39,0:10:52.55,Default,,0,0,0,,第一个技术是在很多工程中都使用的
Dialogue: 0,0:10:53.36,0:10:58.91,Default,,0,0,0,,被称为“黑盒抽象”的方法
Dialogue: 0,0:11:07.71,0:11:12.58,Default,,0,0,0,,即将一些东西组合并封装起来
Dialogue: 0,0:11:14.37,0:11:20.09,Default,,0,0,0,,以之前我们提到的求取平方根的方法为例
Dialogue: 0,0:11:22.64,0:11:28.53,Default,,0,0,0,,我将这些操作视为一个“盒子”
Dialogue: 0,0:11:29.89,0:11:37.52,Default,,0,0,0,,也就是说 为了找到X的平方根
Dialogue: 0,0:11:38.86,0:11:41.27,Default,,0,0,0,,或许会有一系列的复杂规则
Dialogue: 0,0:11:42.64,0:11:46.69,Default,,0,0,0,,我们将规则封装 输入数据即可获得结果
Dialogue: 0,0:11:46.81,0:11:50.06,Default,,0,0,0,,比如说 输入36 然后说36的平方根是多少呢
Dialogue: 0,0:11:50.25,0:11:51.46,Default,,0,0,0,,则给出结果 6
Dialogue: 0,0:11:53.89,0:11:56.22,Default,,0,0,0,,重点是
Dialogue: 0,0:11:56.24,0:12:00.03,Default,,0,0,0,,通过这样的设计
Dialogue: 0,0:12:00.06,0:12:04.08,Default,,0,0,0,,可以方便他人的使用
Dialogue: 0,0:12:05.10,0:12:09.37,Default,,0,0,0,,例如Goerge想计算A的平方根加上B的平方根
Dialogue: 0,0:12:11.34,0:12:14.38,Default,,0,0,0,,他无需了解“盒子”内部的构成
Dialogue: 0,0:12:14.43,0:12:15.74,Default,,0,0,0,,而直接可以以模块的形式使用它
Dialogue: 0,0:12:15.77,0:12:17.31,Default,,0,0,0,,也可以利用它去构建新的“盒子”
Dialogue: 0,0:12:18.45,0:12:24.20,Default,,0,0,0,,例如构建一个 A和B以及一个平方根和或者另一个平方根盒子
Dialogue: 0,0:12:24.53,0:12:33.87,Default,,0,0,0,,然后将这些结果加在一起并输出答案
Dialogue: 0,0:12:33.96,0:12:38.15,Default,,0,0,0,,如你所见 就我想实现的功能的层面来看
Dialogue: 0,0:12:38.92,0:12:40.42,Default,,0,0,0,,对于George来说
Dialogue: 0,0:12:40.51,0:12:43.10,Default,,0,0,0,,盒子内部是什么样并不重要
Dialogue: 0,0:12:44.19,0:12:47.25,Default,,0,0,0,,例如 以下这些说法都没什么问题
Dialogue: 0,0:12:47.27,0:12:50.43,Default,,0,0,0,,我说求X的平方根
Dialogue: 0,0:12:50.61,0:12:52.27,Default,,0,0,0,,也可以说计算Y的平方根
Dialogue: 0,0:12:52.72,0:12:55.62,Default,,0,0,0,,或者其它任何数的平方根
Dialogue: 0,0:12:56.70,0:13:02.35,Default,,0,0,0,,黑盒抽象的基本规则是
Dialogue: 0,0:13:03.53,0:13:06.44,Default,,0,0,0,,将处理过程放入盒子里以隐藏细节
Dialogue: 0,0:13:07.60,0:13:10.99,Default,,0,0,0,,这样做的原因则是你可以脱身去构建更大的盒子
Dialogue: 0,0:13:12.05,0:13:14.57,Default,,0,0,0,,现在 除了隐藏细节外
Dialogue: 0,0:13:14.59,0:13:18.41,Default,,0,0,0,,使用黑盒抽象还有另外一个原因
Dialogue: 0,0:13:18.48,0:13:25.02,Default,,0,0,0,,有的时候 你想要用你的方法去完成一件事
Dialogue: 0,0:13:25.04,0:13:26.88,Default,,0,0,0,,你的方法
Dialogue: 0,0:13:28.44,0:13:30.79,Default,,0,0,0,,就是一个通法的具体实例
Dialogue: 0,0:13:31.16,0:13:34.57,Default,,0,0,0,,同时 你也希望你的表述方式能够具有普遍性
Dialogue: 0,0:13:35.57,0:13:37.93,Default,,0,0,0,,我们接着用实例来说明
Dialogue: 0,0:13:37.97,0:13:38.86,Default,,0,0,0,,继续刚才关于平方根的讨论
Dialogue: 0,0:13:38.89,0:13:42.16,Default,,0,0,0,,让我们回过头再来看看
Dialogue: 0,0:13:42.19,0:13:43.75,Default,,0,0,0,,求平方根的算法
Dialogue: 0,0:13:44.16,0:13:45.62,Default,,0,0,0,,想一想之前是怎么说的
Dialogue: 0,0:13:45.79,0:13:49.82,Default,,0,0,0,,为了求解 首先要作出猜测
Dialogue: 0,0:13:50.62,0:13:54.84,Default,,0,0,0,,然后基于这个猜测 做出持续不断的改进
Dialogue: 0,0:13:55.66,0:14:00.14,Default,,0,0,0,,因此就存在一个找到某个到结果的通用方法
Dialogue: 0,0:14:01.15,0:14:04.00,Default,,0,0,0,,就是持续不断地改进结果
Dialogue: 0,0:14:04.16,0:14:10.25,Default,,0,0,0,,求取不动点的方法有很多
Dialogue: 0,0:14:10.97,0:14:13.23,Default,,0,0,0,,这种方法只是其中的一个特例
Dialogue: 0,0:14:14.57,0:14:16.59,Default,,0,0,0,,每个函数都有一个不动点
Dialogue: 0,0:14:17.13,0:14:26.03,Default,,0,0,0,,函数的不动点是一个值
Dialogue: 0,0:14:26.13,0:14:31.79,Default,,0,0,0,,F的不动点Y满足F(Y)=Y
Dialogue: 0,0:14:32.97,0:14:40.89,Default,,0,0,0,,首先要做是做出一个猜测
Dialogue: 0,0:14:42.00,0:14:45.85,Default,,0,0,0,,在迭代函数F时不会改变的东西则是我们所求的结果
Dialogue: 0,0:14:45.96,0:14:49.45,Default,,0,0,0,,我会不断迭代函数F直到结果不会有很大改变
Dialogue: 0,0:14:50.05,0:14:51.93,Default,,0,0,0,,这就是一个通法
Dialogue: 0,0:14:52.24,0:14:56.17,Default,,0,0,0,,因此 为了计算X的平方根
Dialogue: 0,0:14:56.24,0:15:03.45,Default,,0,0,0,,我可以试着找到Y与X/Y的平均值函数的不动点
Dialogue: 0,0:15:03.55,0:15:07.52,Default,,0,0,0,,因为如果我真有一个等于X平方根的Y
Dialogue: 0,0:15:08.01,0:15:11.80,Default,,0,0,0,,那么Y和X/Y应为同一值
Dialogue: 0,0:15:12.00,0:15:13.90,Default,,0,0,0,,它们俩都是X的平方根
Dialogue: 0,0:15:14.86,0:15:18.85,Default,,0,0,0,,因为X除根号X得根号X
Dialogue: 0,0:15:19.09,0:15:21.84,Default,,0,0,0,,如果平均值Y等于X的平方根
Dialogue: 0,0:15:22.25,0:15:25.21,Default,,0,0,0,,那么这个平均值就不会改变
Dialogue: 0,0:15:25.98,0:15:28.93,Default,,0,0,0,,因此X的平方根即是某一特定函数的不动点
Dialogue: 0,0:15:30.09,0:15:33.85,Default,,0,0,0,,现在 我将要描述
Dialogue: 0,0:15:33.98,0:15:36.42,Default,,0,0,0,,寻找不动点的通法
Dialogue: 0,0:15:36.57,0:15:40.13,Default,,0,0,0,,我所希望做的就是
Dialogue: 0,0:15:41.02,0:15:46.45,Default,,0,0,0,,用我自己的语言定义一个可以获得不动点的“盒子”
Dialogue: 0,0:15:49.58,0:15:52.19,Default,,0,0,0,,正如我可以定义一个输出平方根的盒子一样
Dialogue: 0,0:15:52.21,0:15:55.18,Default,,0,0,0,,我想要用自己的语言来表述
Dialogue: 0,0:15:56.08,0:16:01.37,Default,,0,0,0,,因此 对于这种“怎么做”的指令性知识
Dialogue: 0,0:16:01.42,0:16:03.21,Default,,0,0,0,,我不仅是想表达具体应该如何求平方根
Dialogue: 0,0:16:03.58,0:16:05.60,Default,,0,0,0,,我也希望能够表述更加通用问题
Dialogue: 0,0:16:05.66,0:16:08.27,Default,,0,0,0,,例如 怎么求取不动点
Dialogue: 0,0:16:09.82,0:16:12.25,Default,,0,0,0,,让我们再回过头来看看之前的幻灯片
Dialogue: 0,0:16:15.02,0:16:23.28,Default,,0,0,0,,不但如何去求取一个不动点
Dialogue: 0,0:16:23.33,0:16:25.32,Default,,0,0,0,,是一种指令性知识
Dialogue: 0,0:16:26.25,0:16:27.39,Default,,0,0,0,,在这下面 这里
Dialogue: 0,0:16:27.42,0:16:30.32,Default,,0,0,0,,这儿还有另一种指令性知识 说的是
Dialogue: 0,0:16:30.41,0:16:35.85,Default,,0,0,0,,计算平方根的一种方法就是应用找不动点的方法
Dialogue: 0,0:16:36.17,0:16:38.89,Default,,0,0,0,,如果 也想要表述这种指令性知识
Dialogue: 0,0:16:39.74,0:16:40.70,Default,,0,0,0,,那结果会是什么样呢？
Dialogue: 0,0:16:40.73,0:16:44.90,Default,,0,0,0,,这个不动点盒子可能会是这样
Dialogue: 0,0:16:45.76,0:16:58.21,Default,,0,0,0,,如果我输入一个函数 该函数从Y映射到Y和X/Y的平均值
Dialogue: 0,0:16:59.77,0:17:06.23,Default,,0,0,0,,然后我们将会得到求不动点的盒子就是求平方根的一个方法
Dialogue: 0,0:17:08.91,0:17:10.24,Default,,0,0,0,,因此在这些我们构建的盒子中
Dialogue: 0,0:17:10.27,0:17:15.07,Default,,0,0,0,,输入和输出都不局限于数字
Dialogue: 0,0:17:16.40,0:17:18.54,Default,,0,0,0,,我们将要构建能够
Dialogue: 0,0:17:18.67,0:17:21.34,Default,,0,0,0,,找到平方根计算方法的盒子
Dialogue: 0,0:17:22.22,0:17:25.85,Default,,0,0,0,,我输入的是一个函数
Dialogue: 0,0:17:26.49,0:17:29.29,Default,,0,0,0,,比如Y映射到Y和X/Y的平均值的函数
Dialogue: 0,0:17:29.71,0:17:31.49,Default,,0,0,0,,我们之所以采用这种方式是希望
Dialogue: 0,0:17:32.21,0:17:35.60,Default,,0,0,0,,输入是一个过程 输出也是一个过程
Dialogue: 0,0:17:35.63,0:17:38.61,Default,,0,0,0,,如我们所见 一个过程输出了另一个过程
Dialogue: 0,0:17:39.31,0:17:41.10,Default,,0,0,0,,之所以这样做是因为
Dialogue: 0,0:17:41.52,0:17:46.27,Default,,0,0,0,,我们将通过程序来讨论指令性知识
Dialogue: 0,0:17:48.00,0:17:49.93,Default,,0,0,0,,这种处理方式很强大
Dialogue: 0,0:17:49.93,0:17:52.13,Default,,0,0,0,,我们将可以基于此来讨论其它类型的知识
Dialogue: 0,0:17:53.42,0:17:56.52,Default,,0,0,0,,实际上 我们讨论的是一种生成过程的过程
Dialogue: 0,0:17:57.10,0:18:00.34,Default,,0,0,0,,一种生成通法的通法
Dialogue: 0,0:18:03.57,0:18:08.24,Default,,0,0,0,,那么 我们将主要讨论三个主题的内容
Dialogue: 0,0:18:08.25,0:18:09.69,Default,,0,0,0,,而首个主题则是
Dialogue: 0,0:18:09.74,0:18:10.94,Default,,0,0,0,,黑盒抽象
Dialogue: 0,0:18:10.97,0:18:13.31,Default,,0,0,0,,让我们稍稍深入一点
Dialogue: 0,0:18:15.12,0:18:24.04,Default,,0,0,0,,我们将讨论
Dialogue: 0,0:18:24.08,0:18:26.72,Default,,0,0,0,,Lisp是如何通过基本对象建立起来的
Dialogue: 0,0:18:27.36,0:18:29.20,Default,,0,0,0,,以及Lisp的构成
Dialogue: 0,0:18:29.49,0:18:33.58,Default,,0,0,0,,接下来 将会涉及到一些基本过程和基础数据
Dialogue: 0,0:18:36.16,0:18:37.04,Default,,0,0,0,,然后我们将会看到
Dialogue: 0,0:18:37.05,0:18:38.77,Default,,0,0,0,,我们如何使用这些基本对象
Dialogue: 0,0:18:38.81,0:18:40.76,Default,,0,0,0,,并把它们组合起来构建更复杂的东西
Dialogue: 0,0:18:41.45,0:18:42.92,Default,,0,0,0,,及相应的组合方法
Dialogue: 0,0:18:43.20,0:18:46.30,Default,,0,0,0,,后续将讨论各种进行组合的方法以及
Dialogue: 0,0:18:46.45,0:18:50.48,Default,,0,0,0,,如何用基本过程来构建更复杂的过程
Dialogue: 0,0:18:50.96,0:18:54.43,Default,,0,0,0,,同时 我们也将看到如何将基本数据组合成复合数据
Dialogue: 0,0:18:56.21,0:18:59.34,Default,,0,0,0,,然后我们将会介绍如何对复合数据
Dialogue: 0,0:18:59.79,0:19:01.29,Default,,0,0,0,,如何将它们抽象出来
Dialogue: 0,0:19:02.91,0:19:04.97,Default,,0,0,0,,如何用黑盒对它们进行封装
Dialogue: 0,0:19:05.04,0:19:07.73,Default,,0,0,0,,使得你可以将它们作为组件用于更复杂的东西
Dialogue: 0,0:19:08.16,0:19:10.93,Default,,0,0,0,,我们会发现这些都是通过定义程序
Dialogue: 0,0:19:11.52,0:19:14.79,Default,,0,0,0,,以及一种处理复合数据的数据抽象技术完成的
Dialogue: 0,0:19:15.61,0:19:17.36,Default,,0,0,0,,最重要的是
Dialogue: 0,0:19:17.92,0:19:21.49,Default,,0,0,0,,我们可以从中了解到专家是如何工作的
Dialogue: 0,0:19:21.61,0:19:27.12,Default,,0,0,0,,对于找不动点的方法来讲
Dialogue: 0,0:19:27.15,0:19:28.64,Default,,0,0,0,,找平方根的方式是它的一个特例
Dialogue: 0,0:19:28.69,0:19:30.87,Default,,0,0,0,,你如何表述完成工作中所存在的通用模式呢？
Dialogue: 0,0:19:31.90,0:19:34.41,Default,,0,0,0,,我们将会使用
Dialogue: 0,0:19:34.59,0:19:35.63,Default,,0,0,0,,之前已经提到过的
Dialogue: 0,0:19:35.66,0:19:37.30,Default,,0,0,0,,某种叫做高阶过程的东西
Dialogue: 0,0:19:37.34,0:19:42.05,Default,,0,0,0,,也就是说 它的输入、输出和它本身都是过程
Dialogue: 0,0:19:42.96,0:19:44.86,Default,,0,0,0,,我们将会看到一些有趣的东西
Dialogue: 0,0:19:44.86,0:19:48.49,Default,,0,0,0,,随着学习的深入 将会越发抽象
Dialogue: 0,0:19:48.80,0:19:50.31,Default,,0,0,0,,那么将会发现
Dialogue: 0,0:19:50.43,0:19:53.61,Default,,0,0,0,,我们认为是数据和我们认为是过程之间的
Dialogue: 0,0:19:53.63,0:19:57.80,Default,,0,0,0,,分界线将变得模糊到难以置信的程度
Dialogue: 0,0:20:02.89,0:20:07.12,Default,,0,0,0,,这便是我们的第一个主题 黑盒抽象
Dialogue: 0,0:20:07.12,0:20:08.62,Default,,0,0,0,,让我们来看看第二个主题
Dialogue: 0,0:20:11.10,0:20:13.88,Default,,0,0,0,,这样说吧
Dialogue: 0,0:20:13.89,0:20:18.09,Default,,0,0,0,,假设我想表达某个想法
Dialogue: 0,0:20:19.42,0:20:22.51,Default,,0,0,0,,请注意 我们讨论的是想法
Dialogue: 0,0:20:22.91,0:20:25.53,Default,,0,0,0,,比如说
Dialogue: 0,0:20:26.41,0:20:35.12,Default,,0,0,0,,我想将某个元素与另两个元素之和相乘
Dialogue: 0,0:20:36.09,0:20:37.93,Default,,0,0,0,,举例来说
Dialogue: 0,0:20:38.11,0:20:41.52,Default,,0,0,0,,我用1和3（之和）乘2 得8
Dialogue: 0,0:20:42.03,0:20:45.11,Default,,0,0,0,,但我这里想讨论的是关于线性组合的基本想法
Dialogue: 0,0:20:45.44,0:20:47.98,Default,,0,0,0,,是说你可以将两个元素的和乘以另一个元素
Dialogue: 0,0:20:49.28,0:20:51.01,Default,,0,0,0,,在数集内思考这个问题是很容易的
Dialogue: 0,0:20:51.05,0:20:55.41,Default,,0,0,0,,但假设我想将这个想法应用于
Dialogue: 0,0:20:56.08,0:20:58.58,Default,,0,0,0,,对两向量a1和a2相加
Dialogue: 0,0:20:59.89,0:21:03.26,Default,,0,0,0,,乘以某一因子x然后得到另一向量
Dialogue: 0,0:21:03.33,0:21:09.75,Default,,0,0,0,,我甚至可以说 若a1和a2皆为多项式
Dialogue: 0,0:21:11.07,0:21:13.90,Default,,0,0,0,,我想对这两个多项式求和
Dialogue: 0,0:21:13.92,0:21:16.86,Default,,0,0,0,,然后乘以2得到一个多项式
Dialogue: 0,0:21:20.16,0:21:23.83,Default,,0,0,0,,同理 a1或a2也可以是电信号
Dialogue: 0,0:21:24.56,0:21:27.77,Default,,0,0,0,,我想将二个信号加和
Dialogue: 0,0:21:27.81,0:21:30.27,Default,,0,0,0,,并将结果放入一个放大器
Dialogue: 0,0:21:30.28,0:21:33.03,Default,,0,0,0,,用一个类似于2的因子乘以它们
Dialogue: 0,0:21:33.82,0:21:36.93,Default,,0,0,0,,这种想法的基本点是 我希望用一个通用记号表示它们
Dialogue: 0,0:21:38.32,0:21:45.42,Default,,0,0,0,,假如我们的语言可以很好的表述这类想法
Dialogue: 0,0:21:47.07,0:21:49.31,Default,,0,0,0,,如果真可以这样的话
Dialogue: 0,0:21:50.65,0:21:52.09,Default,,0,0,0,,我将会以这样的方式表述
Dialogue: 0,0:21:54.99,0:22:00.41,Default,,0,0,0,,用x乘以a1和a2的和
Dialogue: 0,0:22:02.80,0:22:05.07,Default,,0,0,0,,更进一步 我希望做更抽象更基本的表述
Dialogue: 0,0:22:06.03,0:22:09.23,Default,,0,0,0,,使其可以适应各个不同类型的a1和a2
Dialogue: 0,0:22:10.03,0:22:11.58,Default,,0,0,0,,现在回过头来想想 似乎有点问题
Dialogue: 0,0:22:11.58,0:22:16.17,Default,,0,0,0,,毕竟 对两个数字和两个多项式进行加和运算
Dialogue: 0,0:22:16.21,0:22:18.33,Default,,0,0,0,,所用的基本操作
Dialogue: 0,0:22:18.38,0:22:22.98,Default,,0,0,0,,在机器内部显然是不同的
Dialogue: 0,0:22:23.29,0:22:27.49,Default,,0,0,0,,对两个电信号或声波加和也有同样的问题
Dialogue: 0,0:22:27.89,0:22:32.53,Default,,0,0,0,,无论怎样 对不同类型的元素进行求和运算
Dialogue: 0,0:22:32.87,0:22:34.25,Default,,0,0,0,,总是需要使用不同的方法
Dialogue: 0,0:22:37.09,0:22:38.64,Default,,0,0,0,,现在 为了构建这样一个系统
Dialogue: 0,0:22:38.78,0:22:40.67,Default,,0,0,0,,我们将如何使用这些知识呢？
Dialogue: 0,0:22:41.20,0:22:44.41,Default,,0,0,0,,如何在各种方法中进行选择？
Dialogue: 0,0:22:44.56,0:22:48.42,Default,,0,0,0,,而如果明天George又想出了一种新类型的对象
Dialogue: 0,0:22:48.45,0:22:50.32,Default,,0,0,0,,并将它用于加和以及乘积
Dialogue: 0,0:22:51.01,0:22:53.32,Default,,0,0,0,,我又该如何把这个新类型引入到系统中
Dialogue: 0,0:22:53.52,0:22:55.68,Default,,0,0,0,,而且能够做到不把已有的系统弄得一团糟？
Dialogue: 0,0:22:57.81,0:23:00.54,Default,,0,0,0,,这便是我们的第二大主题
Dialogue: 0,0:23:00.57,0:23:03.16,Default,,0,0,0,,控制复杂度的方法
Dialogue: 0,0:23:03.84,0:23:08.43,Default,,0,0,0,,我们实现的方法是按照约定来实现相应的接口
Dialogue: 0,0:23:17.44,0:23:20.21,Default,,0,0,0,,并以此将各部分组合起来
Dialogue: 0,0:23:20.25,0:23:22.04,Default,,0,0,0,,就如同电气工程中
Dialogue: 0,0:23:22.94,0:23:25.39,Default,,0,0,0,,人们为连接器规定标准阻抗
Dialogue: 0,0:23:26.16,0:23:28.62,Default,,0,0,0,,如果用符合这个标准的东西来构建系统
Dialogue: 0,0:23:28.67,0:23:30.40,Default,,0,0,0,,你就知道你可以把各个部件组合在一起
Dialogue: 0,0:23:32.78,0:23:35.68,Default,,0,0,0,,这就是我们将要讨论的第二个主题：约定接口
Dialogue: 0,0:23:35.73,0:23:40.94,Default,,0,0,0,,如我之前提到的
Dialogue: 0,0:23:40.97,0:23:42.22,Default,,0,0,0,,接下来我们将讨论通用操作中的问题
Dialogue: 0,0:23:42.59,0:23:47.28,Default,,0,0,0,,例如对各种不同类型数据进行均适用的加法操作
Dialogue: 0,0:23:52.61,0:23:54.57,Default,,0,0,0,,随后则会讨论通用操作
Dialogue: 0,0:23:54.61,0:23:56.99,Default,,0,0,0,,然后我们将讨论大型架构问题
Dialogue: 0,0:23:58.32,0:24:00.83,Default,,0,0,0,,如果通过对现实世界的复杂系统建模
Dialogue: 0,0:24:01.02,0:24:04.89,Default,,0,0,0,,来构建大型程序
Dialogue: 0,0:24:05.53,0:24:06.53,Default,,0,0,0,,我们将看到 在构建这样的系统时
Dialogue: 0,0:24:06.57,0:24:11.81,Default,,0,0,0,,有两种非常重要的方法
Dialogue: 0,0:24:11.85,0:24:13.90,Default,,0,0,0,,其一是面向对象编程
Dialogue: 0,0:24:14.09,0:24:18.94,Default,,0,0,0,,在这种模式中 你把你的系统想象成一个社区
Dialogue: 0,0:24:19.37,0:24:22.36,Default,,0,0,0,,社区中的各个部分都是通过相互间传递消息联系起来的
Dialogue: 0,0:24:23.44,0:24:27.81,Default,,0,0,0,,其二是关于聚集的操作 称作“流”
Dialogue: 0,0:24:27.98,0:24:31.50,Default,,0,0,0,,使用这种方式构建大型系统
Dialogue: 0,0:24:31.50,0:24:35.29,Default,,0,0,0,,类似于电气工程师构造大型电气系统
Dialogue: 0,0:24:38.93,0:24:40.49,Default,,0,0,0,,这就是我们的第二个话题
Dialogue: 0,0:24:43.37,0:24:45.93,Default,,0,0,0,,现在 我们将要讨论第三个话题
Dialogue: 0,0:24:45.95,0:24:49.70,Default,,0,0,0,,控制复杂度的第三个技术
Dialogue: 0,0:24:49.74,0:24:50.94,Default,,0,0,0,,便是定义新的语言
Dialogue: 0,0:24:51.69,0:24:55.42,Default,,0,0,0,,因为有时 当你有点受不了设计的复杂度时
Dialogue: 0,0:24:55.47,0:24:59.69,Default,,0,0,0,,你可以通过定义一门新的语言来控制系统复杂度
Dialogue: 0,0:25:01.41,0:25:05.60,Default,,0,0,0,,新语言的设计意图是为了强调系统的某个方面
Dialogue: 0,0:25:05.79,0:25:09.36,Default,,0,0,0,,它一方面隐藏了部分细节 另一方面则但强调一些其他的细节
Dialogue: 0,0:25:12.99,0:25:15.93,Default,,0,0,0,,这部分将是课程中最神奇的部分
Dialogue: 0,0:25:16.03,0:25:21.20,Default,,0,0,0,,我们将开始于构建新的计算机语言
Dialogue: 0,0:25:21.82,0:25:26.30,Default,,0,0,0,,实际上我们首先要完成的工作已经内建于Lisp之中了
Dialogue: 0,0:25:29.23,0:25:34.02,Default,,0,0,0,,我们将展现如何用Lisp来解释Lisp
Dialogue: 0,0:25:34.29,0:25:36.94,Default,,0,0,0,,这是一个非常类似于自循环的过程
Dialogue: 0,0:25:36.96,0:25:39.92,Default,,0,0,0,,这与（Lisp中）一个神奇的符号有关
Dialogue: 0,0:25:40.97,0:25:46.38,Default,,0,0,0,,解释Lisp的步骤是
Dialogue: 0,0:25:46.57,0:25:47.71,Default,,0,0,0,,应用和求值——这两大步骤的轮转
Dialogue: 0,0:25:47.89,0:25:50.87,Default,,0,0,0,,这两者不断地互相交替进行
Dialogue: 0,0:25:52.54,0:25:54.24,Default,,0,0,0,,接下来 我们将看到其余神奇的东西
Dialogue: 0,0:25:54.25,0:25:56.85,Default,,0,0,0,,譬如另一种魔法符号
Dialogue: 0,0:25:57.12,0:26:01.52,Default,,0,0,0,,一种叫做Y运算符的东西
Dialogue: 0,0:26:01.55,0:26:06.45,Default,,0,0,0,,某种意义上 它在过程式语言中用于 表达无限
Dialogue: 0,0:26:06.51,0:26:07.44,Default,,0,0,0,,我们也会谈论到它
Dialogue: 0,0:26:08.40,0:26:13.73,Default,,0,0,0,,总之 这部分课程被称作“元语言抽象”
Dialogue: 0,0:26:16.17,0:26:26.23,Default,,0,0,0,,主要讨论如何构建一门新语言
Dialogue: 0,0:26:30.22,0:26:35.71,Default,,0,0,0,,如我所言 我们将从了解解释的过程开始
Dialogue: 0,0:26:35.74,0:26:42.12,Default,,0,0,0,,随后则一起讨论应用-求值循环和构建Lisp
Dialogue: 0,0:26:42.16,0:26:44.17,Default,,0,0,0,,你将发现这种方法具有相当的普遍性
Dialogue: 0,0:26:44.37,0:26:48.26,Default,,0,0,0,,我们将用同样的技术去构建一门全完不同的语言
Dialogue: 0,0:26:48.53,0:26:50.31,Default,,0,0,0,,一种所谓的逻辑编程语言
Dialogue: 0,0:26:50.53,0:26:54.83,Default,,0,0,0,,一种无关具有输入和输出的过程
Dialogue: 0,0:26:54.86,0:26:57.25,Default,,0,0,0,,而仅关注元素之间关系的语言
Dialogue: 0,0:26:57.31,0:27:03.92,Default,,0,0,0,,最终 我们将讨论如何将这些东西
Dialogue: 0,0:27:03.95,0:27:05.60,Default,,0,0,0,,实实在在的实现在简单的机器上
Dialogue: 0,0:27:05.65,0:27:08.39,Default,,0,0,0,,比如说这个
Dialogue: 0,0:27:09.13,0:27:12.14,Default,,0,0,0,,如图所示的芯片
Dialogue: 0,0:27:12.16,0:27:17.47,Default,,0,0,0,,就是我们在硬件部分谈及的Lisp解释器
Dialogue: 0,0:27:20.88,0:27:23.79,Default,,0,0,0,,这三大主题就是本课的提纲
Dialogue: 0,0:27:24.88,0:27:29.41,Default,,0,0,0,,黑盒抽象 约定接口 元语言抽象
Dialogue: 0,0:27:31.58,0:27:33.57,Default,,0,0,0,,好 先休息一会儿 然后正式开始
Dialogue: 0,0:27:52.19,0:28:03.42,Default,,0,0,0,,[音乐]
Dialogue: 0,0:28:03.92,0:28:06.84,Default,,0,0,0,,现在让我们正式开始学习Lisp
Dialogue: 0,0:28:08.06,0:28:10.75,Default,,0,0,0,,事实上 我们将开始学习一些非常重要的内容
Dialogue: 0,0:28:10.80,0:28:14.33,Default,,0,0,0,,在这门课程中最重要的 不是Lisp本身
Dialogue: 0,0:28:14.38,0:28:18.41,Default,,0,0,0,,而是一种的通用框架体系
Dialogue: 0,0:28:18.62,0:28:21.89,Default,,0,0,0,,我们用它来组织我之前提到的语言
Dialogue: 0,0:28:22.12,0:28:25.10,Default,,0,0,0,,当有人要向你展示一门新语言
Dialogue: 0,0:28:25.13,0:28:26.16,Default,,0,0,0,,你应该问他
Dialogue: 0,0:28:26.19,0:28:32.87,Default,,0,0,0,,（构成语言的）基本元素有哪些？
Dialogue: 0,0:28:37.50,0:28:38.78,Default,,0,0,0,,这门语言使用哪些基本元素？
Dialogue: 0,0:28:38.96,0:28:43.53,Default,,0,0,0,,你是如何将这些元素组合在一起的？
Dialogue: 0,0:28:43.68,0:28:47.42,Default,,0,0,0,,组合的方法是什么？
Dialogue: 0,0:28:50.17,0:28:54.18,Default,,0,0,0,,允许你将这些基本元素整合在一起
Dialogue: 0,0:28:54.37,0:28:56.51,Default,,0,0,0,,以构建更大的对象的又是什么？
Dialogue: 0,0:28:58.01,0:28:59.61,Default,,0,0,0,,把东西构建在一起的方法是什么？
Dialogue: 0,0:29:01.39,0:29:05.69,Default,,0,0,0,,以及 抽象的方法是什么？
Dialogue: 0,0:29:08.35,0:29:16.85,Default,,0,0,0,,我们如何利用这些元素并把它们封装成盒子？
Dialogue: 0,0:29:16.88,0:29:19.66,Default,,0,0,0,,我们如何为它们命名使得我们可以
Dialogue: 0,0:29:19.68,0:29:23.85,Default,,0,0,0,,把它们当作基本元素来用于构建更复杂的东西？
Dialogue: 0,0:29:23.89,0:29:25.66,Default,,0,0,0,,等等 等等 等等
Dialogue: 0,0:29:26.89,0:29:28.08,Default,,0,0,0,,因此 当有人告诉你
Dialogue: 0,0:29:28.09,0:29:29.55,Default,,0,0,0,,嘿 我发明了一种新的计算机语言
Dialogue: 0,0:29:30.86,0:29:34.70,Default,,0,0,0,,你不应该问 用你的语言编写求逆矩阵需要多少代码
Dialogue: 0,0:29:35.73,0:29:36.88,Default,,0,0,0,,这是风马牛不相及的
Dialogue: 0,0:29:37.39,0:29:42.30,Default,,0,0,0,,如果该语言没有内建了矩阵或者类似的东西
Dialogue: 0,0:29:42.33,0:29:43.37,Default,,0,0,0,,那你就应该问他
Dialogue: 0,0:29:43.37,0:29:46.03,Default,,0,0,0,,应该如何构建矩阵？
Dialogue: 0,0:29:46.05,0:29:48.47,Default,,0,0,0,,如何通过组合来构建？
Dialogue: 0,0:29:48.62,0:29:50.71,Default,,0,0,0,,如何对其进行抽象
Dialogue: 0,0:29:51.68,0:29:54.21,Default,,0,0,0,,把它作为基本元素
Dialogue: 0,0:29:54.22,0:29:56.52,Default,,0,0,0,,来构建更复杂的东西？
Dialogue: 0,0:29:58.75,0:30:04.61,Default,,0,0,0,,我们将了解到Lisp的一些基本数据和基本过程
Dialogue: 0,0:30:05.25,0:30:07.50,Default,,0,0,0,,好吧 这次是真的开始了
Dialogue: 0,0:30:07.55,0:30:14.89,Default,,0,0,0,,这里有一个Lisp的基本数据 数字3
Dialogue: 0,0:30:16.27,0:30:19.87,Default,,0,0,0,,事实上 如果打破沙锅问到底的话 这不是数字3
Dialogue: 0,0:30:19.93,0:30:25.57,Default,,0,0,0,,这只是一个符号 用以代表柏拉图观念下的数字3的
Dialogue: 0,0:30:26.67,0:30:28.93,Default,,0,0,0,,这又是另一个
Dialogue: 0,0:30:30.48,0:30:36.06,Default,,0,0,0,,这个是Lisp中又一个基本数据 17.4
Dialogue: 0,0:30:36.08,0:30:39.42,Default,,0,0,0,,又或者说 代表17.4
Dialogue: 0,0:30:40.99,0:30:44.48,Default,,0,0,0,,这儿还有一个5
Dialogue: 0,0:30:46.86,0:30:52.21,Default,,0,0,0,,然后这儿又有一个内建于Lisp的基本对象“+”
Dialogue: 0,0:30:52.25,0:30:55.68,Default,,0,0,0,,如果又要继续深究的话
Dialogue: 0,0:30:55.71,0:31:00.47,Default,,0,0,0,,这只是一个名字 代表对元素进行加和的基本方法而已
Dialogue: 0,0:31:00.53,0:31:02.53,Default,,0,0,0,,就像这个是柏拉图式的3
Dialogue: 0,0:31:02.61,0:31:09.32,Default,,0,0,0,,这也只是一个代表柏拉图观念下的将某些元素加和起来
Dialogue: 0,0:31:10.32,0:31:11.98,Default,,0,0,0,,这些都是基本元素
Dialogue: 0,0:31:12.14,0:31:13.76,Default,,0,0,0,,我可以将它们放在一起
Dialogue: 0,0:31:14.14,0:31:18.29,Default,,0,0,0,,我可以说 3加17.4加5的和是多少
Dialogue: 0,0:31:18.69,0:31:21.31,Default,,0,0,0,,这等同于说
Dialogue: 0,0:31:21.33,0:31:27.71,Default,,0,0,0,,让我们把求和运算符应用于这三个数
Dialogue: 0,0:31:27.74,0:31:31.15,Default,,0,0,0,,我可以得到什么呢 是8 是17 还是25.4
Dialogue: 0,0:31:34.43,0:31:38.05,Default,,0,0,0,,因此 我可以问Lisp这个的值是多少
Dialogue: 0,0:31:38.94,0:31:40.77,Default,,0,0,0,,（表达式）返回25.4
Dialogue: 0,0:31:43.58,0:31:44.83,Default,,0,0,0,,介绍一些术语吧
Dialogue: 0,0:31:44.88,0:31:51.47,Default,,0,0,0,,我所写的这些东西就叫做组合式
Dialogue: 0,0:31:56.88,0:32:01.94,Default,,0,0,0,,通常 一个组合式是由运算符
Dialogue: 0,0:32:03.39,0:32:04.72,Default,,0,0,0,,这些就是运算符
Dialogue: 0,0:32:09.71,0:32:12.05,Default,,0,0,0,,和应用该运算符的运算对象组成
Dialogue: 0,0:32:13.25,0:32:14.54,Default,,0,0,0,,这些是运算对象
Dialogue: 0,0:32:21.89,0:32:23.79,Default,,0,0,0,,当然 我可以完成更复杂的事
Dialogue: 0,0:32:23.82,0:32:28.56,Default,,0,0,0,,我可以使之更复杂是因为 这些运算对象
Dialogue: 0,0:32:29.52,0:32:31.09,Default,,0,0,0,,通常来说 也可以是组合式
Dialogue: 0,0:32:31.15,0:32:44.47,Default,,0,0,0,,比如 3加上5乘以6乘以8乘以2的积的和是多少
Dialogue: 0,0:32:45.66,0:32:52.16,Default,,0,0,0,,而我应该得到 我算一下 30 40 43
Dialogue: 0,0:32:52.73,0:32:54.81,Default,,0,0,0,,因此Lisp会返回这个表达式的值是43
Dialogue: 0,0:32:56.56,0:33:02.80,Default,,0,0,0,,后续我们将看到构造组合式是组合的基本需求
Dialogue: 0,0:33:04.65,0:33:09.22,Default,,0,0,0,,你所看到的这些语法
Dialogue: 0,0:33:10.56,0:33:13.04,Default,,0,0,0,,就是Lisp用的所谓的前缀表示法
Dialogue: 0,0:33:16.22,0:33:25.21,Default,,0,0,0,,意即操作符在操作数的左端
Dialogue: 0,0:33:25.47,0:33:26.48,Default,,0,0,0,,这只是个约定
Dialogue: 0,0:33:27.66,0:33:29.77,Default,,0,0,0,,注意 这些都被括起来了
Dialogue: 0,0:33:30.08,0:33:32.32,Default,,0,0,0,,这些括号使得它们区别开来
Dialogue: 0,0:33:32.32,0:33:36.99,Default,,0,0,0,,因此只要看看这个 我就可以知道这个是运算符
Dialogue: 0,0:33:37.01,0:33:40.99,Default,,0,0,0,,以及这有1个 2个 3个 4个运算对象
Dialogue: 0,0:33:42.38,0:33:47.97,Default,,0,0,0,,而且我也可以发现第二个运算对象是个组合式
Dialogue: 0,0:33:48.88,0:33:51.55,Default,,0,0,0,,该组合式有一个运算符和两个运算对象
Dialogue: 0,0:33:52.43,0:33:54.27,Default,,0,0,0,,Lisp中的括号 有点或者非常不同于
Dialogue: 0,0:33:54.61,0:33:57.71,Default,,0,0,0,,通常数学中的括号
Dialogue: 0,0:33:57.77,0:34:00.11,Default,,0,0,0,,数学中 我们常将其用于分组
Dialogue: 0,0:34:01.21,0:34:03.75,Default,,0,0,0,,如果有时你忘了闭合括号 但其他人能理解你的意图
Dialogue: 0,0:34:03.77,0:34:05.56,Default,,0,0,0,,这也无关紧要
Dialogue: 0,0:34:05.76,0:34:08.51,Default,,0,0,0,,通常的 你多加了括号也无所谓
Dialogue: 0,0:34:08.86,0:34:10.94,Default,,0,0,0,,因为这样只会使得分组更加明确
Dialogue: 0,0:34:10.96,0:34:11.77,Default,,0,0,0,,Lisp可不像这样
Dialogue: 0,0:34:13.12,0:34:15.37,Default,,0,0,0,,Lisp中你既不能不闭合括号
Dialogue: 0,0:34:16.38,0:34:18.56,Default,,0,0,0,,亦不能添加多余的括号
Dialogue: 0,0:34:19.33,0:34:21.28,Default,,0,0,0,,因为加括号总是意味着
Dialogue: 0,0:34:21.37,0:34:27.05,Default,,0,0,0,,确切的来说 所括之物是一个组合式
Dialogue: 0,0:34:27.09,0:34:28.81,Default,,0,0,0,,表示将运算符应用于运算对象
Dialogue: 0,0:34:29.04,0:34:32.62,Default,,0,0,0,,如果我不闭合这个括号
Dialogue: 0,0:34:32.65,0:34:33.96,Default,,0,0,0,,这个就变成其它的意思了
Dialogue: 0,0:34:35.41,0:34:37.25,Default,,0,0,0,,事实上 我们可以这么来理解这个问题
Dialogue: 0,0:34:37.41,0:34:41.65,Default,,0,0,0,,把我写的这些东西想作一个树
Dialogue: 0,0:34:42.37,0:34:47.30,Default,,0,0,0,,这个组合式实际上是一个树 树具有一个“+”
Dialogue: 0,0:34:47.37,0:34:54.46,Default,,0,0,0,,以及 一个3和一些其它的东西和一个8 还有一个2
Dialogue: 0,0:34:54.48,0:34:56.35,Default,,0,0,0,,而这里的其它的东西
Dialogue: 0,0:34:56.35,0:35:03.22,Default,,0,0,0,,它本身是一个有一个“*”一个5和一个6的子树
Dialogue: 0,0:35:03.95,0:35:05.53,Default,,0,0,0,,我们可以这样认为
Dialogue: 0,0:35:05.55,0:35:09.00,Default,,0,0,0,,我们只是在构建这些树而已
Dialogue: 0,0:35:09.21,0:35:15.10,Default,,0,0,0,,括号只是将这种二维结构写作线性字符串
Dialogue: 0,0:35:15.79,0:35:17.34,Default,,0,0,0,,的一种方法罢了
Dialogue: 0,0:35:19.23,0:35:23.81,Default,,0,0,0,,因为至少在Lisp发明时 人们还在用电传打字机或者打孔卡
Dialogue: 0,0:35:24.17,0:35:25.60,Default,,0,0,0,,这种记法方便多了
Dialogue: 0,0:35:25.97,0:35:30.52,Default,,0,0,0,,如果Lisp是在当下被发明的 语法可能会像树那样
Dialogue: 0,0:35:31.76,0:35:35.07,Default,,0,0,0,,那么 让我们看看在计算机里面它究竟是什么样
Dialogue: 0,0:35:36.29,0:35:39.37,Default,,0,0,0,,这里有个Lisp解释套件
Dialogue: 0,0:35:39.41,0:35:40.43,Default,,0,0,0,,这是个编辑器
Dialogue: 0,0:35:41.13,0:35:44.86,Default,,0,0,0,,我将要在上方写一些表达式并让Lisp对其求值
Dialogue: 0,0:35:45.12,0:35:46.75,Default,,0,0,0,,比如 我可以问Lisp
Dialogue: 0,0:35:46.83,0:35:48.53,Default,,0,0,0,,这个符号的值是多少
Dialogue: 0,0:35:49.44,0:35:50.50,Default,,0,0,0,,我键入3
Dialogue: 0,0:35:50.57,0:35:52.20,Default,,0,0,0,,然后叫Lisp对其求值
Dialogue: 0,0:35:52.32,0:35:54.77,Default,,0,0,0,,然后你就会看到Lisp在下面返回了一些信息
Dialogue: 0,0:35:55.39,0:35:56.84,Default,,0,0,0,,这个值就是3
Dialogue: 0,0:35:57.58,0:36:04.96,Default,,0,0,0,,我也可以问 3加上4加上8的和是多少
Dialogue: 0,0:36:06.45,0:36:08.05,Default,,0,0,0,,键入这个组合式
Dialogue: 0,0:36:08.93,0:36:10.66,Default,,0,0,0,,让Lisp对其求值
Dialogue: 0,0:36:14.49,0:36:15.68,Default,,0,0,0,,返回15
Dialogue: 0,0:36:16.57,0:36:18.80,Default,,0,0,0,,我可以键入一些更复杂的东西
Dialogue: 0,0:36:19.25,0:36:34.14,Default,,0,0,0,,将3乘以7加19.5的和的乘积求和得多少
Dialogue: 0,0:36:35.21,0:36:38.00,Default,,0,0,0,,你会发现Lisp内建了一些功能
Dialogue: 0,0:36:38.01,0:36:39.76,Default,,0,0,0,,帮你跟踪这些括号
Dialogue: 0,0:36:39.77,0:36:42.13,Default,,0,0,0,,看我键入下一个右圆括号
Dialogue: 0,0:36:42.21,0:36:45.01,Default,,0,0,0,,用于闭合以“*”开头的那个组合式
Dialogue: 0,0:36:45.52,0:36:47.30,Default,,0,0,0,,开头的那个左括号会闪一下
Dialogue: 0,0:36:47.76,0:36:49.69,Default,,0,0,0,,我把这些括号擦去 再示范一次
Dialogue: 0,0:36:50.14,0:36:52.70,Default,,0,0,0,,键入右括号 闭合了“+”组合式
Dialogue: 0,0:36:53.58,0:36:56.41,Default,,0,0,0,,再键入右括号 闭合了“*”组合式
Dialogue: 0,0:36:57.90,0:37:00.76,Default,,0,0,0,,现在我又回到了加 我将它们与4相加
Dialogue: 0,0:37:01.66,0:37:02.69,Default,,0,0,0,,闭合了“+”组合式
Dialogue: 0,0:37:02.73,0:37:07.07,Default,,0,0,0,,现在我补全了组合式 然后我问Lisp它们的值是多少
Dialogue: 0,0:37:07.26,0:37:11.66,Default,,0,0,0,,这种内建于各种Lisp系统的
Dialogue: 0,0:37:11.76,0:37:13.29,Default,,0,0,0,,括号匹配工具帮你跟进（括号匹配）
Dialogue: 0,0:37:13.36,0:37:16.55,Default,,0,0,0,,因为手工闭合这些括号太辛苦了
Dialogue: 0,0:37:16.81,0:37:21.20,Default,,0,0,0,,这又是另外一种保持括号跟进的约定
Dialogue: 0,0:37:21.25,0:37:23.68,Default,,0,0,0,,我另外写一个复杂的组合式
Dialogue: 0,0:37:24.77,0:37:34.00,Default,,0,0,0,,将3和5的积与某个元素求和
Dialogue: 0,0:37:34.03,0:37:35.23,Default,,0,0,0,,现在我将要缩进
Dialogue: 0,0:37:35.28,0:37:39.85,Default,,0,0,0,,使得这些运算对象都是垂直书写的
Dialogue: 0,0:37:40.30,0:37:45.65,Default,,0,0,0,,将这些加上47乘以
Dialogue: 0,0:37:47.02,0:37:54.59,Default,,0,0,0,,恩…… 47乘以20和6.8的差
Dialogue: 0,0:37:54.62,0:37:57.09,Default,,0,0,0,,意即从20中减去6.8
Dialogue: 0,0:37:58.97,0:38:00.19,Default,,0,0,0,,然后 这个括号闭合了
Dialogue: 0,0:38:00.22,0:38:03.47,Default,,0,0,0,,闭合“-” 闭合“*”
Dialogue: 0,0:38:03.76,0:38:05.42,Default,,0,0,0,,现在 我们再写一个运算符
Dialogue: 0,0:38:05.44,0:38:09.49,Default,,0,0,0,,Lisp编辑器自动缩进到正确的位置
Dialogue: 0,0:38:10.40,0:38:11.50,Default,,0,0,0,,来帮助我保持跟进
Dialogue: 0,0:38:12.61,0:38:14.09,Default,,0,0,0,,我再示范一次
Dialogue: 0,0:38:14.13,0:38:15.89,Default,,0,0,0,,这样就又闭合了最后一个括号
Dialogue: 0,0:38:16.25,0:38:17.71,Default,,0,0,0,,它匹配了这个“+”（的括号）
Dialogue: 0,0:38:20.40,0:38:22.64,Default,,0,0,0,,现在我想问 这个的值是多少
Dialogue: 0,0:38:23.87,0:38:29.28,Default,,0,0,0,,因此 这两件事 缩进到正确的位置
Dialogue: 0,0:38:29.31,0:38:30.86,Default,,0,0,0,,也就是所谓的美观的输出
Dialogue: 0,0:38:31.55,0:38:33.58,Default,,0,0,0,,以及闭合提示
Dialogue: 0,0:38:33.89,0:38:37.73,Default,,0,0,0,,是许多Lisp系统所内建用于帮你保持跟进的工具
Dialogue: 0,0:38:37.76,0:38:39.01,Default,,0,0,0,,你应该学习如何使用它们
Dialogue: 0,0:38:41.52,0:38:43.17,Default,,0,0,0,,好 这些都是基本的内容
Dialogue: 0,0:38:44.73,0:38:46.31,Default,,0,0,0,,这就是一种组合的方法
Dialogue: 0,0:38:46.33,0:38:47.93,Default,,0,0,0,,现在让我们来看看抽象的方法
Dialogue: 0,0:38:49.44,0:38:53.84,Default,,0,0,0,,我希望我能够写一些像这样的组合式
Dialogue: 0,0:38:53.85,0:38:55.77,Default,,0,0,0,,将它抽象化并给它命名
Dialogue: 0,0:38:55.81,0:38:57.26,Default,,0,0,0,,使得我可以将其作为一个（我们语言的）元素
Dialogue: 0,0:38:57.31,0:38:59.92,Default,,0,0,0,,在Lisp中 我可以用“define”来实现
Dialogue: 0,0:39:01.17,0:39:02.43,Default,,0,0,0,,比如说
Dialogue: 0,0:39:02.73,0:39:15.05,Default,,0,0,0,,定义A为5乘以5
Dialogue: 0,0:39:18.40,0:39:22.35,Default,,0,0,0,,现在我可以问Lisp
Dialogue: 0,0:39:22.38,0:39:26.01,Default,,0,0,0,,A和A的乘积是多少
Dialogue: 0,0:39:27.18,0:39:29.81,Default,,0,0,0,,这个是25所以这个就是625
Dialogue: 0,0:39:31.97,0:39:36.01,Default,,0,0,0,,但更重要的则是 我现在可以使用A
Dialogue: 0,0:39:36.21,0:39:37.92,Default,,0,0,0,,我已经在这个组合式里面用过了
Dialogue: 0,0:39:38.41,0:39:43.55,Default,,0,0,0,,但我也可以在更复杂的组合式里面使用它
Dialogue: 0,0:39:43.58,0:39:50.93,Default,,0,0,0,,我也可以说 定义B为
Dialogue: 0,0:39:50.97,0:39:57.45,Default,,0,0,0,,A与5乘以A的积的和
Dialogue: 0,0:39:59.44,0:40:00.72,Default,,0,0,0,,闭合“+”
Dialogue: 0,0:40:03.45,0:40:05.85,Default,,0,0,0,,让我们来看看它在计算机中是怎样的吧
Dialogue: 0,0:40:07.28,0:40:10.68,Default,,0,0,0,,我就像黑板上写的那样键入就可以了
Dialogue: 0,0:40:10.83,0:40:21.73,Default,,0,0,0,,我告诉Lisp
Dialogue: 0,0:40:23.74,0:40:25.38,Default,,0,0,0,,定义A为5乘以5的积
Dialogue: 0,0:40:25.52,0:40:28.94,Default,,0,0,0,,注意Lisp在下方回应了一个A
Dialogue: 0,0:40:29.09,0:40:31.38,Default,,0,0,0,,通常来说 你如果在Lisp中键入了一个定义
Dialogue: 0,0:40:31.50,0:40:35.02,Default,,0,0,0,,它返回被定义的符号
Dialogue: 0,0:40:35.63,0:40:39.66,Default,,0,0,0,,现在我问Lisp A乘以A的积是多少
Dialogue: 0,0:40:42.81,0:40:44.33,Default,,0,0,0,,Lisp返回625
Dialogue: 0,0:40:46.05,0:41:00.34,Default,,0,0,0,,我也可以定义B为A加上5乘以A的积的和
Dialogue: 0,0:41:00.48,0:41:05.70,Default,,0,0,0,,闭合“*” 闭合“+” 闭合“define”
Dialogue: 0,0:41:07.63,0:41:10.37,Default,,0,0,0,,Lisp在下方正常返回B
Dialogue: 0,0:41:11.04,0:41:13.24,Default,,0,0,0,,现在我可以问Lisp B的值是多少
Dialogue: 0,0:41:17.18,0:41:18.88,Default,,0,0,0,,我也可以问一些更复杂的事
Dialogue: 0,0:41:18.93,0:41:26.69,Default,,0,0,0,,比如A加上B除以5的商的和是多少
Dialogue: 0,0:41:26.73,0:41:30.25,Default,,0,0,0,,这个“/”是另一个基本运算符 代表除
Dialogue: 0,0:41:30.38,0:41:32.78,Default,,0,0,0,,我让B除以5 并加在A上
Dialogue: 0,0:41:33.65,0:41:35.23,Default,,0,0,0,,Lisp正常返回55
Dialogue: 0,0:41:36.57,0:41:37.92,Default,,0,0,0,,就像这样
Dialogue: 0,0:41:39.82,0:41:43.40,Default,,0,0,0,,这是定义东西的基本方法
Dialogue: 0,0:41:43.44,0:41:49.02,Default,,0,0,0,,这是最简单的命名方法 但并不是很强大
Dialogue: 0,0:41:50.06,0:41:51.60,Default,,0,0,0,,注意我们讨论的是通用方法
Dialogue: 0,0:41:51.84,0:41:53.37,Default,,0,0,0,,因此我真正想定义的是
Dialogue: 0,0:41:53.57,0:41:57.68,Default,,0,0,0,,一种通用方法 可以
Dialogue: 0,0:41:58.11,0:42:17.53,Default,,0,0,0,,得到 5乘5 6乘6 1001乘1001 1001.7乘1001.7
Dialogue: 0,0:42:17.76,0:42:24.16,Default,,0,0,0,,我想给一个数与其自身相乘这种想法一个名字
Dialogue: 0,0:42:28.48,0:42:30.11,Default,,0,0,0,,你应该知道 这叫做平方
Dialogue: 0,0:42:31.69,0:42:35.63,Default,,0,0,0,,而在Lisp中我应该这样实现
Dialogue: 0,0:42:37.97,0:42:56.25,Default,,0,0,0,,定义 square某个叫x的东西 为 将x乘以x自己
Dialogue: 0,0:42:57.87,0:43:01.12,Default,,0,0,0,,定义完毕后 我可以问Lisp
Dialogue: 0,0:43:01.12,0:43:05.49,Default,,0,0,0,,比如 10的平方是多少
Dialogue: 0,0:43:06.67,0:43:07.87,Default,,0,0,0,,Lisp返回100
Dialogue: 0,0:43:10.70,0:43:14.24,Default,,0,0,0,,让我们深入讨论一下
Dialogue: 0,0:43:15.29,0:43:16.88,Default,,0,0,0,,这儿是square的定义
Dialogue: 0,0:43:17.50,0:43:22.55,Default,,0,0,0,,square某个元素 即是将该元素进行自乘
Dialogue: 0,0:43:23.69,0:43:25.34,Default,,0,0,0,,这里的x
Dialogue: 0,0:43:26.29,0:43:27.81,Default,,0,0,0,,应该算是一种代词
Dialogue: 0,0:43:27.87,0:43:29.53,Default,,0,0,0,,指代了我要做平方的元素
Dialogue: 0,0:43:31.49,0:43:37.41,Default,,0,0,0,,实际上我将其乘以x 即是乘以它自己
Dialogue: 0,0:43:42.22,0:43:48.27,Default,,0,0,0,,这些就是定义一个过程的记法
Dialogue: 0,0:43:48.29,0:43:50.29,Default,,0,0,0,,这样说可能把你搞糊涂了
Dialogue: 0,0:43:50.81,0:43:53.97,Default,,0,0,0,,因为这就像我在用square一样
Dialogue: 0,0:43:54.00,0:43:56.80,Default,,0,0,0,,但如果我说x的平方根或者10的平方根
Dialogue: 0,0:43:57.55,0:44:00.81,Default,,0,0,0,,并没有说清楚我对什么做了定义
Dialogue: 0,0:44:03.10,0:44:04.91,Default,,0,0,0,,所以让我换个方式来进行定义
Dialogue: 0,0:44:05.74,0:44:08.21,Default,,0,0,0,,这样可以清楚的看到定义的具体内容
Dialogue: 0,0:44:08.54,0:44:29.39,Default,,0,0,0,,我定义“square”为“(lambda (x) (* x x))”
Dialogue: 0,0:44:36.56,0:44:42.05,Default,,0,0,0,,这里 我定义square就像我某命名为A一样
Dialogue: 0,0:44:43.23,0:44:44.72,Default,,0,0,0,,我定义square
Dialogue: 0,0:44:44.75,0:44:48.39,Default,,0,0,0,,这里 我把这个组合式的值命名为A
Dialogue: 0,0:44:49.29,0:44:52.41,Default,,0,0,0,,在这里 我把这个东西命名为square
Dialogue: 0,0:44:52.43,0:44:53.44,Default,,0,0,0,,以lambda开头
Dialogue: 0,0:44:53.45,0:44:56.77,Default,,0,0,0,,lambda在Lisp中用以构建一个过程
Dialogue: 0,0:45:00.24,0:45:02.91,Default,,0,0,0,,请仔细看一下幻灯片上的内容
Dialogue: 0,0:45:04.27,0:45:05.81,Default,,0,0,0,,这个定义读作
Dialogue: 0,0:45:05.85,0:45:10.33,Default,,0,0,0,,将square定义为
Dialogue: 0,0:45:12.78,0:45:13.97,Default,,0,0,0,,一个由lambda构造的
Dialogue: 0,0:45:14.06,0:45:17.49,Default,,0,0,0,,一个有带有参数x的过程
Dialogue: 0,0:45:19.26,0:45:24.09,Default,,0,0,0,,而该过程返回将x自乘的结果
Dialogue: 0,0:45:24.97,0:45:33.12,Default,,0,0,0,,一般来讲 这是最佳的定义方式
Dialogue: 0,0:45:33.41,0:45:35.20,Default,,0,0,0,,因为这个更加方便一点
Dialogue: 0,0:45:35.21,0:45:38.67,Default,,0,0,0,,但是也别忘了它实质上也是这个
Dialogue: 0,0:45:38.86,0:45:41.41,Default,,0,0,0,,事实上 就Lisp解释器而言
Dialogue: 0,0:45:41.61,0:45:45.55,Default,,0,0,0,,这两种方法没有区别
Dialogue: 0,0:45:46.51,0:45:53.29,Default,,0,0,0,,换句话说 这只是一种语法糖
Dialogue: 0,0:45:54.41,0:45:55.80,Default,,0,0,0,,语法糖的意思就是
Dialogue: 0,0:45:56.35,0:46:00.83,Default,,0,0,0,,这种形式输入更方便一些
Dialogue: 0,0:46:01.12,0:46:06.11,Default,,0,0,0,,这只是这下面的有lambda的表达式的语法糖而已
Dialogue: 0,0:46:07.31,0:46:10.62,Default,,0,0,0,,你应该记住
Dialogue: 0,0:46:10.80,0:46:13.87,Default,,0,0,0,,当我这样写的时候 其实是在对某个东西进行命名
Dialogue: 0,0:46:14.46,0:46:16.22,Default,,0,0,0,,我将其命名为square
Dialogue: 0,0:46:16.24,0:46:19.90,Default,,0,0,0,,square代表一个构建好的过程
Dialogue: 0,0:46:21.20,0:46:23.90,Default,,0,0,0,,让我们看看在计算机里面又是 怎样的吧
Dialogue: 0,0:46:24.78,0:46:35.95,Default,,0,0,0,,定义“(square x)”为x乘以x的积
Dialogue: 0,0:46:49.65,0:46:52.32,Default,,0,0,0,,将它送入Lisp
Dialogue: 0,0:46:53.49,0:46:53.92,Default,,0,0,0,,返回square
Dialogue: 0,0:46:53.93,0:46:56.29,Default,,0,0,0,,现在 我已经将某个东西命名为square了
Dialogue: 0,0:46:56.45,0:47:02.88,Default,,0,0,0,,完毕后 我就可以问Lisp 1001的平方是多少
Dialogue: 0,0:47:05.26,0:47:17.69,Default,,0,0,0,,或者更通常的来说 我可以问 5加上7的和的平方是多少
Dialogue: 0,0:47:22.81,0:47:24.95,Default,,0,0,0,,12的平方是144
Dialogue: 0,0:47:25.07,0:47:28.86,Default,,0,0,0,,在某些组合式中我亦可把square当作一个元素
Dialogue: 0,0:47:28.88,0:47:37.50,Default,,0,0,0,,3的平方加上4的平方的和是多少
Dialogue: 0,0:47:42.53,0:47:44.09,Default,,0,0,0,,9加上16得25
Dialogue: 0,0:47:44.91,0:47:50.54,Default,,0,0,0,,我可以将square作为元素用于更复杂的式子
Dialogue: 0,0:47:50.59,0:48:00.51,Default,,0,0,0,,比如 1001的平方点的平方的平方是多少
Dialogue: 0,0:48:07.89,0:48:10.63,Default,,0,0,0,,这就是1001点的平方的平方的平方
Dialogue: 0,0:48:11.20,0:48:15.45,Default,,0,0,0,,我也可以问Lisp square本身是什么
Dialogue: 0,0:48:15.68,0:48:17.16,Default,,0,0,0,,它的值是是什么
Dialogue: 0,0:48:17.44,0:48:22.14,Default,,0,0,0,,Lisp用一种约定的方法告诉我这是一个过程
Dialogue: 0,0:48:22.27,0:48:23.98,Default,,0,0,0,,它返回 复合过程square
Dialogue: 0,0:48:24.25,0:48:27.92,Default,,0,0,0,,记住 square的值是一个过程
Dialogue: 0,0:48:29.15,0:48:30.89,Default,,0,0,0,,而那些用星号和括号的记法
Dialogue: 0,0:48:31.10,0:48:34.78,Default,,0,0,0,,只是Lisp用来描述这个过程的约定
Dialogue: 0,0:48:36.11,0:48:41.33,Default,,0,0,0,,让我们再看两个关于define的例子
Dialogue: 0,0:48:44.91,0:48:46.91,Default,,0,0,0,,这有两个过程
Dialogue: 0,0:48:47.36,0:48:52.84,Default,,0,0,0,,定义x和y的平均值为x加上y的和除以2的商
Dialogue: 0,0:48:54.67,0:49:01.49,Default,,0,0,0,,以及定义好平方和平均值后 我可以定义均方
Dialogue: 0,0:49:01.65,0:49:04.71,Default,,0,0,0,,我可以用它们来讨论某元素的均方
Dialogue: 0,0:49:04.91,0:49:09.26,Default,,0,0,0,,即x的平方与y的平方的平均值
Dialogue: 0,0:49:10.97,0:49:13.63,Default,,0,0,0,,当定义好它们后 我可以问
Dialogue: 0,0:49:13.66,0:49:24.88,Default,,0,0,0,,2和3的均方是多少
Dialogue: 0,0:49:25.23,0:49:30.24,Default,,0,0,0,,我将会得到 4和9的平均值 即6.5
Dialogue: 0,0:49:32.85,0:49:36.64,Default,,0,0,0,,关键点在于 定义了square后
Dialogue: 0,0:49:36.64,0:49:38.67,Default,,0,0,0,,我可以把它当作一个基本元素来使用
Dialogue: 0,0:49:41.41,0:49:43.07,Default,,0,0,0,,因此在这里
Dialogue: 0,0:49:44.65,0:49:45.74,Default,,0,0,0,,我在讨论均方的时候
Dialogue: 0,0:49:47.29,0:49:52.56,Default,,0,0,0,,从这点来说 定义均方的人没有必要知道
Dialogue: 0,0:49:52.61,0:49:55.76,Default,,0,0,0,,究竟square是由语言内建支持
Dialogue: 0,0:49:56.94,0:49:58.93,Default,,0,0,0,,还是自定义的过程
Dialogue: 0,0:49:59.73,0:50:01.28,Default,,0,0,0,,这是Lisp的关键之一
Dialogue: 0,0:50:02.30,0:50:07.52,Default,,0,0,0,,你无法准确区别
Dialogue: 0,0:50:07.53,0:50:11.82,Default,,0,0,0,,哪些是语言的基本对象 哪些是语言的内建支持
Dialogue: 0,0:50:12.83,0:50:14.73,Default,,0,0,0,,用户使用时则无需关心这些
Dialogue: 0,0:50:14.93,0:50:18.51,Default,,0,0,0,,你自己构建的东西看起来就像是语言自带的基本对象
Dialogue: 0,0:50:18.51,0:50:19.53,Default,,0,0,0,,具有同样的能力和灵活性
Dialogue: 0,0:50:19.57,0:50:22.57,Default,,0,0,0,,大家可以在课后上机做做测试
Dialogue: 0,0:50:24.75,0:50:26.30,Default,,0,0,0,,我们接下来讨论一下“+”吧
Dialogue: 0,0:50:26.72,0:50:30.09,Default,,0,0,0,,好的 让我们在计算机中看看
Dialogue: 0,0:50:30.11,0:50:32.33,Default,,0,0,0,,“+”的值是什么
Dialogue: 0,0:50:34.40,0:50:37.20,Default,,0,0,0,,注意Lisp在下面的输出
Dialogue: 0,0:50:37.25,0:50:38.81,Default,,0,0,0,,复合过程“+”
Dialogue: 0,0:50:39.89,0:50:42.29,Default,,0,0,0,,因为在此系统中
Dialogue: 0,0:50:42.33,0:50:45.49,Default,,0,0,0,,“+”运算符是一个复合过程
Dialogue: 0,0:50:45.97,0:50:47.97,Default,,0,0,0,,但如果我不输入进去做下测试 你永远不会知道
Dialogue: 0,0:50:48.06,0:50:49.68,Default,,0,0,0,,所以这没什么不同
Dialogue: 0,0:50:49.84,0:50:50.51,Default,,0,0,0,,我们并不关心这些
Dialogue: 0,0:50:50.56,0:50:53.39,Default,,0,0,0,,它比我们日常处理的问题更加抽象一些
Dialogue: 0,0:50:54.17,0:50:59.11,Default,,0,0,0,,其关键点在于你无法分辨出
Dialogue: 0,0:50:59.17,0:51:03.82,Default,,0,0,0,,内建元素与复合元素之间的不同
Dialogue: 0,0:51:03.84,0:51:04.38,Default,,0,0,0,,为什么会这样呢？
Dialogue: 0,0:51:04.38,0:51:08.07,Default,,0,0,0,,因为复合元素经过了一次抽象封装 (以致于无法分辨)
Dialogue: 0,0:51:09.05,0:51:11.61,Default,,0,0,0,,我们已经介绍了Lisp的大多数元素了
Dialogue: 0,0:51:12.67,0:51:14.53,Default,,0,0,0,,还有一个需要进行讨论的
Dialogue: 0,0:51:14.57,0:51:16.53,Default,,0,0,0,,就是如何进行分情况分析
Dialogue: 0,0:51:16.59,0:51:17.70,Default,,0,0,0,,举个例子
Dialogue: 0,0:51:18.96,0:51:24.08,Default,,0,0,0,,让我们考虑绝对值函数的数学定义
Dialogue: 0,0:51:24.11,0:51:30.03,Default,,0,0,0,,我或许会说x的绝对值这样是一个函数
Dialogue: 0,0:51:30.16,0:51:37.24,Default,,0,0,0,,若x小于0 则为-x
Dialogue: 0,0:51:37.92,0:51:41.13,Default,,0,0,0,,若x等于0 则为0
Dialogue: 0,0:51:42.64,0:51:46.62,Default,,0,0,0,,若x大于0 则就是x
Dialogue: 0,0:51:49.15,0:51:51.90,Default,,0,0,0,,而Lisp则有一套分情况分析方法
Dialogue: 0,0:51:52.11,0:51:53.85,Default,,0,0,0,,以绝对值定义为例 我给大家说明一下
Dialogue: 0,0:51:55.55,0:52:02.41,Default,,0,0,0,,定义绝对值为 x是有多种情况的
Dialogue: 0,0:52:03.02,0:52:05.67,Default,,0,0,0,,这就是分情况分析
Dialogue: 0,0:52:09.23,0:52:19.09,Default,,0,0,0,,如果x小于0 则结果为-x
Dialogue: 0,0:52:22.99,0:52:24.88,Default,,0,0,0,,我这里写的是一个子句
Dialogue: 0,0:52:24.99,0:52:35.54,Default,,0,0,0,,这整个是一个由两部分组成的条件表达式
Dialogue: 0,0:52:36.35,0:52:44.70,Default,,0,0,0,,这个部分叫做谓词或者条件
Dialogue: 0,0:52:44.83,0:52:45.90,Default,,0,0,0,,这就是一种情况（条件）
Dialogue: 0,0:52:46.11,0:52:48.29,Default,,0,0,0,,用以表达条件的东西叫做谓词
Dialogue: 0,0:52:48.33,0:52:51.05,Default,,0,0,0,,Lisp中的谓词是一种
Dialogue: 0,0:52:51.37,0:52:52.87,Default,,0,0,0,,可以返回true或者false的东西
Dialogue: 0,0:52:53.53,0:52:56.13,Default,,0,0,0,,比如说“小于”是Lisp中的一个基本过程
Dialogue: 0,0:52:57.29,0:52:59.08,Default,,0,0,0,,它返回true或者false
Dialogue: 0,0:53:00.54,0:53:06.32,Default,,0,0,0,,子句其余部分为一个动作或者需要做的事
Dialogue: 0,0:53:06.93,0:53:08.14,Default,,0,0,0,,本例中为true
Dialogue: 0,0:53:08.17,0:53:09.81,Default,,0,0,0,,在这里 我则是取x的相反数
Dialogue: 0,0:53:10.08,0:53:14.41,Default,,0,0,0,,有趣的是 Lisp中减运算符符与相反数运算符相同
Dialogue: 0,0:53:14.56,0:53:18.43,Default,,0,0,0,,如果有两个及两个以上的参数
Dialogue: 0,0:53:18.58,0:53:22.49,Default,,0,0,0,,正如我们看到的 假设刚好有两个参数 就从第一个中减去第二个
Dialogue: 0,0:53:22.53,0:53:24.13,Default,,0,0,0,,如果只有一个参数 则取其相反数
Dialogue: 0,0:53:25.13,0:53:27.87,Default,,0,0,0,,这与前面相符合
Dialogue: 0,0:53:27.87,0:53:29.69,Default,,0,0,0,,这又是一个COND子句
Dialogue: 0,0:53:30.64,0:53:35.87,Default,,0,0,0,,这是说 在x等于0的时候 结果为0
Dialogue: 0,0:53:37.95,0:53:44.75,Default,,0,0,0,,在x大于0的时候 结果为x
Dialogue: 0,0:53:45.33,0:53:49.38,Default,,0,0,0,,闭合子句 闭合COND 闭合define
Dialogue: 0,0:53:49.57,0:53:51.29,Default,,0,0,0,,这就是绝对值的定义
Dialogue: 0,0:53:51.31,0:53:53.66,Default,,0,0,0,,你会发现分情况分析
Dialogue: 0,0:53:53.66,0:53:56.04,Default,,0,0,0,,与数学中所用的非常相似
Dialogue: 0,0:53:58.14,0:54:03.07,Default,,0,0,0,,当然还有一些不常用的受限的分情况分析方法
Dialogue: 0,0:54:03.07,0:54:06.24,Default,,0,0,0,,很多时候 你在进行分情况分析时只有一种情况
Dialogue: 0,0:54:06.93,0:54:08.07,Default,,0,0,0,,你首先进行测试
Dialogue: 0,0:54:08.33,0:54:10.75,Default,,0,0,0,,然后根据返回的为true或false来决定如何处理
Dialogue: 0,0:54:11.01,0:54:15.90,Default,,0,0,0,,这是另外一种定义绝对值的方法
Dialogue: 0,0:54:16.00,0:54:17.19,Default,,0,0,0,,但看起来是几乎一样的
Dialogue: 0,0:54:17.66,0:54:22.56,Default,,0,0,0,,像这样 如果x小于0 结果则为x的相反数
Dialogue: 0,0:54:24.41,0:54:25.97,Default,,0,0,0,,否则 结果即为x
Dialogue: 0,0:54:26.05,0:54:27.25,Default,,0,0,0,,我们将会大量的使用“if”
Dialogue: 0,0:54:27.29,0:54:29.13,Default,,0,0,0,,再次声明
Dialogue: 0,0:54:29.13,0:54:32.70,Default,,0,0,0,,你们在这里看到的绝对值形式
Dialogue: 0,0:54:34.30,0:54:36.98,Default,,0,0,0,,和我在黑板上写的那种
Dialogue: 0,0:54:37.52,0:54:38.80,Default,,0,0,0,,本质上是一样的
Dialogue: 0,0:54:39.09,0:54:42.26,Default,,0,0,0,,而“if”和“COND”则是——
Dialogue: 0,0:54:42.30,0:54:44.45,Default,,0,0,0,,你可以把“COND”当做“if”的语法糖
Dialogue: 0,0:54:44.99,0:54:47.36,Default,,0,0,0,,或者“if”是“COND”的语法糖
Dialogue: 0,0:54:47.39,0:54:48.65,Default,,0,0,0,,这没什么区别
Dialogue: 0,0:54:49.21,0:54:51.35,Default,,0,0,0,,Lisp系统的设计者会从中会选择一个
Dialogue: 0,0:54:51.39,0:54:52.97,Default,,0,0,0,,然后依照这个来实现另外一个
Dialogue: 0,0:54:53.15,0:54:54.67,Default,,0,0,0,,你首先实现哪一个都无所谓
Dialogue: 0,0:55:02.27,0:55:05.36,Default,,0,0,0,,让我们停下来 解决几点疑问
Dialogue: 0,0:55:05.69,0:55:10.08,Default,,0,0,0,,为什么我有时用define时
Dialogue: 0,0:55:11.09,0:55:14.75,Default,,0,0,0,,我在这里使用了一个左括号
Dialogue: 0,0:55:14.81,0:55:16.45,Default,,0,0,0,,输入 define (XXX
Dialogue: 0,0:55:16.86,0:55:20.81,Default,,0,0,0,,而有时我这样写时却没加左括号
Dialogue: 0,0:55:22.06,0:55:27.23,Default,,0,0,0,,是因为你所见的
Dialogue: 0,0:55:27.26,0:55:29.41,Default,,0,0,0,,这种“define”表达式
Dialogue: 0,0:55:29.47,0:55:32.13,Default,,0,0,0,,对于定义过程来讲是非常特殊
Dialogue: 0,0:55:33.61,0:55:40.21,Default,,0,0,0,,再次强调 这实际上是说我定义这个叫square的符号为这个
Dialogue: 0,0:55:41.45,0:55:45.98,Default,,0,0,0,,你所知道的则是 你先写一个“define”
Dialogue: 0,0:55:47.15,0:55:50.06,Default,,0,0,0,,然后你再写一个符号 没有左括号
Dialogue: 0,0:55:50.17,0:55:51.49,Default,,0,0,0,,这是你将要定义的符号
Dialogue: 0,0:55:52.08,0:55:53.70,Default,,0,0,0,,这又是你要将其定义为什么
Dialogue: 0,0:55:54.65,0:55:57.55,Default,,0,0,0,,就像这儿和这儿
Dialogue: 0,0:55:57.61,0:56:00.29,Default,,0,0,0,,这是“define”的基本使用方法
Dialogue: 0,0:56:01.12,0:56:03.65,Default,,0,0,0,,然而 这种特殊的语法技巧
Dialogue: 0,0:56:04.29,0:56:07.04,Default,,0,0,0,,使得你可以定义像这样的过程
Dialogue: 0,0:56:08.17,0:56:11.49,Default,,0,0,0,,因此区别就在于你是否定义了一个过程
Dialogue: 0,0:56:12.91,0:56:37.60,Default,,0,0,0,,[音乐]
Dialogue: 0,0:56:38.05,0:56:41.98,Default,,0,0,0,,信不信由你 你们已经学了足够多的Lisp的知识了
Dialogue: 0,0:56:42.78,0:56:45.42,Default,,0,0,0,,现在你基本上可以编写
Dialogue: 0,0:56:46.25,0:56:49.63,Default,,0,0,0,,FORTRAN、Basic或者其它语言中一样的
Dialogue: 0,0:56:49.66,0:56:51.01,Default,,0,0,0,,数值计算过程了
Dialogue: 0,0:56:52.05,0:56:54.76,Default,,0,0,0,,或许你会说 这不可能
Dialogue: 0,0:56:54.81,0:56:56.65,Default,,0,0,0,,因为你知道这些语言有
Dialogue: 0,0:56:56.65,0:57:00.22,Default,,0,0,0,,像“for”语句和“do-until-whil”语句的东西
Dialogue: 0,0:57:00.99,0:57:04.59,Default,,0,0,0,,实际上这些我们一点也用不着
Dialogue: 0,0:57:05.05,0:57:07.13,Default,,0,0,0,,本课中我们一点也不会使用这些东西
Dialogue: 0,0:57:08.25,0:57:10.16,Default,,0,0,0,,我给你们来个下马威
Dialogue: 0,0:57:10.25,0:57:13.61,Default,,0,0,0,,回过头来看看平方根
Dialogue: 0,0:57:13.65,0:57:19.03,Default,,0,0,0,,让我们看看亚历山大的Heron提出的平方根算法
Dialogue: 0,0:57:19.09,0:57:19.97,Default,,0,0,0,,想想它是怎么说的
Dialogue: 0,0:57:20.06,0:57:23.67,Default,,0,0,0,,算法说 为了找到X的平方根的近似值
Dialogue: 0,0:57:25.07,0:57:26.16,Default,,0,0,0,,你做出猜测
Dialogue: 0,0:57:27.45,0:57:31.88,Default,,0,0,0,,然后通过取guess和X/guess的平均数来改进猜测
Dialogue: 0,0:57:32.94,0:57:36.06,Default,,0,0,0,,你不断改进猜测 直到这个猜测足够好
Dialogue: 0,0:57:36.72,0:57:38.43,Default,,0,0,0,,我已经提到过这种想法
Dialogue: 0,0:57:38.56,0:57:42.24,Default,,0,0,0,,这种想法是说 如果你最初采用的猜测
Dialogue: 0,0:57:43.04,0:57:46.91,Default,,0,0,0,,真真切切的等于X的平方根
Dialogue: 0,0:57:47.15,0:57:50.06,Default,,0,0,0,,那么G就会等于X/G
Dialogue: 0,0:57:52.89,0:57:55.33,Default,,0,0,0,,如果你算出平方根 对其取平均数并不会改变它
Dialogue: 0,0:57:55.69,0:57:59.62,Default,,0,0,0,,如果你所采用的G比X的平方根大
Dialogue: 0,0:58:00.38,0:58:02.94,Default,,0,0,0,,那么X/G就会比X的平方根小
Dialogue: 0,0:58:03.21,0:58:05.37,Default,,0,0,0,,因此当你取G与X/G的平均值时
Dialogue: 0,0:58:05.63,0:58:07.57,Default,,0,0,0,,就得到了两者之间的某数
Dialogue: 0,0:58:08.96,0:58:12.95,Default,,0,0,0,,同理 若你采用的G过小 答案则会过大
Dialogue: 0,0:58:13.12,0:58:14.81,Default,,0,0,0,,如果你采用了一个太大的G
Dialogue: 0,0:58:16.32,0:58:18.06,Default,,0,0,0,,如果你的G比X的平方根还要大的话
Dialogue: 0,0:58:18.08,0:58:20.35,Default,,0,0,0,,X/G就会比X的平方根还要小
Dialogue: 0,0:58:21.23,0:58:23.65,Default,,0,0,0,,因此取平均值使得你总可以得到两者间的某数
Dialogue: 0,0:58:24.53,0:58:28.13,Default,,0,0,0,,这不是毫无意义的 它表明
Dialogue: 0,0:58:28.17,0:58:31.76,Default,,0,0,0,,事实上 如果G只差X的平方根一点的话
Dialogue: 0,0:58:31.81,0:58:37.99,Default,,0,0,0,,G和X/G的平均值就会慢慢的向X的平方根靠近
Dialogue: 0,0:58:38.03,0:58:38.99,Default,,0,0,0,,只要你不断的这样做
Dialogue: 0,0:58:39.42,0:58:41.18,Default,,0,0,0,,最终就可以不断地靠近
Dialogue: 0,0:58:41.71,0:58:42.85,Default,,0,0,0,,另外一个事实则是
Dialogue: 0,0:58:43.02,0:58:47.65,Default,,0,0,0,,你总可以使用1作为一个初始猜测值来开始计算
Dialogue: 0,0:58:49.23,0:58:51.35,Default,,0,0,0,,它总是朝X的平方根聚拢
Dialogue: 0,0:58:52.24,0:58:56.77,Default,,0,0,0,,这就是亚历山大的Heron的连续求平均值法
Dialogue: 0,0:58:56.81,0:58:59.21,Default,,0,0,0,,让我们在Lisp中实现
Dialogue: 0,0:59:00.57,0:59:02.61,Default,,0,0,0,,中心思想是
Dialogue: 0,0:59:02.65,0:59:07.19,Default,,0,0,0,,尝试将guess作为X的平方根的一个猜想意味着什么
Dialogue: 0,0:59:08.30,0:59:09.37,Default,,0,0,0,,我来编码
Dialogue: 0,0:59:09.79,0:59:25.02,Default,,0,0,0,,定义（try guess x）
Dialogue: 0,0:59:26.45,0:59:28.24,Default,,0,0,0,,我们该如何做 我们会说
Dialogue: 0,0:59:28.29,0:59:45.26,Default,,0,0,0,,如果猜测精确到可以作为X的平方根
Dialogue: 0,0:59:46.54,0:59:49.52,Default,,0,0,0,,那么我们就可以将这个猜测作为答案
Dialogue: 0,0:59:51.61,0:59:57.01,Default,,0,0,0,,否则 我们就会尝试改进猜测
Dialogue: 0,0:59:58.19,1:00:04.24,Default,,0,0,0,,我们将通过改进这个猜测来作为X的平方根
Dialogue: 0,1:00:05.26,1:00:09.33,Default,,0,0,0,,并尝试是否为X平方根
Dialogue: 0,1:00:09.36,1:00:12.96,Default,,0,0,0,,闭合try 闭合if 闭合define
Dialogue: 0,1:00:13.31,1:00:14.81,Default,,0,0,0,,这就是我们如何尝试一个猜测
Dialogue: 0,1:00:15.85,1:00:17.60,Default,,0,0,0,,然后 这个过程的下一步是说
Dialogue: 0,1:00:17.73,1:00:21.90,Default,,0,0,0,,为了计算平方根
Dialogue: 0,1:00:21.93,1:00:30.17,Default,,0,0,0,,定义计算X的平方根为
Dialogue: 0,1:00:30.80,1:00:35.79,Default,,0,0,0,,从1作为X的平方根的一个猜测开始尝试
Dialogue: 0,1:00:37.42,1:00:39.59,Default,,0,0,0,,我们必须定义一些其它的东西
Dialogue: 0,1:00:40.08,1:00:43.36,Default,,0,0,0,,我们必须说明 一个猜测如何才叫“足够好”
Dialogue: 0,1:00:43.84,1:00:45.29,Default,,0,0,0,,我们又该如何改进这个猜测
Dialogue: 0,1:00:45.85,1:00:47.10,Default,,0,0,0,,那么让我们来看看
Dialogue: 0,1:00:47.39,1:00:54.24,Default,,0,0,0,,而改进一个X的平方根的一个猜测的算法则是
Dialogue: 0,1:00:54.64,1:00:57.18,Default,,0,0,0,,取平均数
Dialogue: 0,1:00:57.18,1:01:02.16,Default,,0,0,0,,我们取guess和X/guess的平均数
Dialogue: 0,1:01:02.99,1:01:04.57,Default,,0,0,0,,这就是我们如何改进一个猜测
Dialogue: 0,1:01:05.85,1:01:08.80,Default,,0,0,0,,为了确定一个猜测是否足够精确 我们需要做一下规定
Dialogue: 0,1:01:08.86,1:01:11.36,Default,,0,0,0,,假设这个是X的平方根的一个猜测
Dialogue: 0,1:01:11.37,1:01:14.03,Default,,0,0,0,,你可能做的一件事就是
Dialogue: 0,1:01:14.06,1:01:16.07,Default,,0,0,0,,当你采用这个猜测并将其平方
Dialogue: 0,1:01:16.64,1:01:18.41,Default,,0,0,0,,你会得到一个非常接近于X的数
Dialogue: 0,1:01:18.59,1:01:21.10,Default,,0,0,0,,而表达这个想法的一种方式是
Dialogue: 0,1:01:21.12,1:01:24.31,Default,,0,0,0,,我们用X减去guess的平方
Dialogue: 0,1:01:25.15,1:01:27.15,Default,,0,0,0,,并且确认所得结果的绝对值是否
Dialogue: 0,1:01:27.20,1:01:32.05,Default,,0,0,0,,比一个由你规定的很小的数还要小
Dialogue: 0,1:01:34.70,1:01:41.42,Default,,0,0,0,,因此 我们就有了计算X的平方根的一整套过程
Dialogue: 0,1:01:41.47,1:01:43.53,Default,,0,0,0,,我们再来深入观察一下这个结构
Dialogue: 0,1:01:47.84,1:01:49.12,Default,,0,0,0,,我搞定了整件事
Dialogue: 0,1:01:49.15,1:01:55.44,Default,,0,0,0,,我有一个用于计算X的平方根的记号
Dialogue: 0,1:01:55.53,1:01:56.88,Default,,0,0,0,,这是一种模块
Dialogue: 0,1:01:57.05,1:01:58.46,Default,,0,0,0,,也是一种黑盒
Dialogue: 0,1:01:58.72,1:02:08.02,Default,,0,0,0,,它的定义依赖于如何尝试将一个猜测值作为X的平方根
Dialogue: 0,1:02:09.31,1:02:14.10,Default,,0,0,0,,定义try是用来
Dialogue: 0,1:02:14.61,1:02:18.03,Default,,0,0,0,,确认某数是否足够精确以及如何去改进该数
Dialogue: 0,1:02:18.73,1:02:19.68,Default,,0,0,0,,这是good-enogh?
Dialogue: 0,1:02:19.89,1:02:28.85,Default,,0,0,0,,try的定义依赖于good-enough?和improve
Dialogue: 0,1:02:30.96,1:02:32.56,Default,,0,0,0,,让我们来看看我填入了些什么
Dialogue: 0,1:02:32.71,1:02:34.29,Default,,0,0,0,,如果我向下拓展这棵树
Dialogue: 0,1:02:34.73,1:02:38.49,Default,,0,0,0,,good-enough?的定义依赖于abs和square
Dialogue: 0,1:02:40.97,1:02:44.13,Default,,0,0,0,,而improve的定义依赖于averaging
Dialogue: 0,1:02:45.17,1:02:46.70,Default,,0,0,0,,而其它的都是一些基本运算符
Dialogue: 0,1:02:46.72,1:02:48.88,Default,,0,0,0,,平方根的定义依赖于try
Dialogue: 0,1:02:48.88,1:02:53.31,Default,,0,0,0,,try的定义依赖于good-enough?和improve
Dialogue: 0,1:02:54.01,1:02:55.39,Default,,0,0,0,,甚至依赖于try本身
Dialogue: 0,1:02:55.58,1:03:00.86,Default,,0,0,0,,因此try也按照它如何应用于自身而进行定义
Dialogue: 0,1:03:02.75,1:03:04.72,Default,,0,0,0,,额 这可能会使你有点糊涂
Dialogue: 0,1:03:04.72,1:03:08.16,Default,,0,0,0,,你的高中几何老师或许告诉过你
Dialogue: 0,1:03:08.67,1:03:12.57,Default,,0,0,0,,用一个东西自己去定义自己是很不对的
Dialogue: 0,1:03:12.88,1:03:13.92,Default,,0,0,0,,因为这根本行不通
Dialogue: 0,1:03:13.92,1:03:14.72,Default,,0,0,0,,这（种说法）是错的
Dialogue: 0,1:03:16.03,1:03:19.68,Default,,0,0,0,,有时候用一个东西自己来定义自己非常有意义
Dialogue: 0,1:03:20.16,1:03:24.38,Default,,0,0,0,,我们来看看这个例子
Dialogue: 0,1:03:24.38,1:03:26.89,Default,,0,0,0,,假设我问Lisp：2的平方根是多少
Dialogue: 0,1:03:26.91,1:03:30.33,Default,,0,0,0,,我们可以写出它究竟是什么意思
Dialogue: 0,1:03:32.65,1:03:34.67,Default,,0,0,0,,2的平方根是什么意思
Dialogue: 0,1:03:35.79,1:03:43.61,Default,,0,0,0,,意思就是我将用1作为2的平方根的一个猜测
Dialogue: 0,1:03:46.97,1:03:50.92,Default,,0,0,0,,然后我考虑 对于2的平方根来说 1是一个足够好的猜测么
Dialogue: 0,1:03:51.65,1:03:53.69,Default,,0,0,0,,这取决于good-enough?是如何判断的
Dialogue: 0,1:03:54.61,1:03:56.56,Default,,0,0,0,,本例中 good-enough?会说
Dialogue: 0,1:03:56.65,1:03:59.05,Default,,0,0,0,,不 对于2的平方根来说 1不是一个足够好的猜测
Dialogue: 0,1:03:59.79,1:04:08.22,Default,,0,0,0,,因此我会继续说 我试试一个改进值
Dialogue: 0,1:04:08.64,1:04:12.63,Default,,0,0,0,,改进猜测值1
Dialogue: 0,1:04:15.15,1:04:17.46,Default,,0,0,0,,然后将其作为2的平方根的一个猜测
Dialogue: 0,1:04:19.13,1:04:22.07,Default,,0,0,0,,改进猜测值1用作2的平方根
Dialogue: 0,1:04:22.09,1:04:25.08,Default,,0,0,0,,也就是说我取1和2/1的平均值
Dialogue: 0,1:04:27.10,1:04:29.10,Default,,0,0,0,,因此我们将取平均数
Dialogue: 0,1:04:29.58,1:04:39.44,Default,,0,0,0,,这段代码将会取1和2/1的平均数
Dialogue: 0,1:04:40.83,1:04:42.75,Default,,0,0,0,,那么这段代码
Dialogue: 0,1:04:43.85,1:04:46.72,Default,,0,0,0,,我算算 结果是1.5
Dialogue: 0,1:04:49.07,1:04:54.40,Default,,0,0,0,,因此这个(sqrt 2)还原到(try 1 2)
Dialogue: 0,1:04:54.56,1:05:04.83,Default,,0,0,0,,然后还原到(try 1.5 2)
Dialogue: 0,1:05:06.03,1:05:08.06,Default,,0,0,0,,因此这行得通
Dialogue: 0,1:05:08.11,1:05:09.52,Default,,0,0,0,,让我们看下剩下的步骤
Dialogue: 0,1:05:09.73,1:05:15.00,Default,,0,0,0,,如果我尝试1.5 则会还原到
Dialogue: 0,1:05:15.01,1:05:19.05,Default,,0,0,0,,1.5作为2的平方根的猜测 并不是足够好
Dialogue: 0,1:05:20.22,1:05:22.00,Default,,0,0,0,,然后又还原到
Dialogue: 0,1:05:22.01,1:05:26.17,Default,,0,0,0,,(try (average 1.5 (/ 2 1.5)))
Dialogue: 0,1:05:28.29,1:05:30.37,Default,,0,0,0,,平均值是1.333
Dialogue: 0,1:05:31.18,1:05:35.24,Default,,0,0,0,,然后整个事又还原到(try 1.3333 2)
Dialogue: 0,1:05:35.28,1:05:36.06,Default,,0,0,0,,如此进行下去
Dialogue: 0,1:05:38.01,1:05:41.66,Default,,0,0,0,,然后又还原到(good-enough? 1.4)或者其它的
Dialogue: 0,1:05:41.73,1:05:44.47,Default,,0,0,0,,然后这个（步骤）会持续进行到
Dialogue: 0,1:05:44.85,1:05:47.92,Default,,0,0,0,,good-enough?认为足够好了才停止
Dialogue: 0,1:05:47.97,1:05:51.28,Default,,0,0,0,,本例中 是1.4242或者其它的东西
Dialogue: 0,1:05:52.51,1:05:56.05,Default,,0,0,0,,因此这个这个过程运行得非常完美
Dialogue: 0,1:05:59.93,1:06:03.10,Default,,0,0,0,,这种定义方法叫做“递归定义”
Dialogue: 0,1:06:14.40,1:06:20.96,Default,,0,0,0,,进行递归定义将会给你带来无穷威力
Dialogue: 0,1:06:21.95,1:06:23.05,Default,,0,0,0,,之前我已提到过
Dialogue: 0,1:06:23.09,1:06:27.21,Default,,0,0,0,,递归定义可以在不增加任何负担的前提下
Dialogue: 0,1:06:27.25,1:06:28.83,Default,,0,0,0,,仅仅通过调用过程 在达到条件之前
Dialogue: 0,1:06:29.73,1:06:33.66,Default,,0,0,0,,完成无限次的计算
Dialogue: 0,1:06:35.97,1:06:37.47,Default,,0,0,0,,还有一点要说明的
Dialogue: 0,1:06:37.71,1:06:44.21,Default,,0,0,0,,我再在这里给你们演示另外一种平方根的定义方法
Dialogue: 0,1:06:44.43,1:06:48.16,Default,,0,0,0,,这两种方法看起来像是一样的
Dialogue: 0,1:06:48.40,1:06:51.49,Default,,0,0,0,,在这儿 我把improve、good-enough?、try的定义
Dialogue: 0,1:06:51.52,1:06:56.16,Default,,0,0,0,,全都封装在了sqrt里面
Dialogue: 0,1:06:56.75,1:07:00.99,Default,,0,0,0,,因此实际上 我们构建了一个平方根盒子
Dialogue: 0,1:07:01.81,1:07:08.53,Default,,0,0,0,,我构建了一个其它人可以使用的平方根盒子
Dialogue: 0,1:07:08.57,1:07:11.47,Default,,0,0,0,,它们输入36 然后（盒子）输出6
Dialogue: 0,1:07:11.81,1:07:13.83,Default,,0,0,0,,但是 盒子里面封装的过程
Dialogue: 0,1:07:14.16,1:07:23.85,Default,,0,0,0,,就是try、good-enough?和improve的定义
Dialogue: 0,1:07:26.78,1:07:28.35,Default,,0,0,0,,它们都隐藏在盒子里面
Dialogue: 0,1:07:28.40,1:07:30.76,Default,,0,0,0,,这样做是因为
Dialogue: 0,1:07:31.18,1:07:32.85,Default,,0,0,0,,如果有人正在使用这个平方根
Dialogue: 0,1:07:33.21,1:07:34.73,Default,,0,0,0,,如果George正在使用这个平方根
Dialogue: 0,1:07:34.75,1:07:37.36,Default,,0,0,0,,George并不会关心
Dialogue: 0,1:07:38.29,1:07:40.03,Default,,0,0,0,,当我在实现平方根时
Dialogue: 0,1:07:40.21,1:07:44.45,Default,,0,0,0,,我定义了盒子内的那些try、good-enough?和improve过程
Dialogue: 0,1:07:46.40,1:07:49.33,Default,,0,0,0,,事实上 Harry可能会实现一个也具有
Dialogue: 0,1:07:49.37,1:07:50.96,Default,,0,0,0,,try、good-enough?和improve的立方根盒子
Dialogue: 0,1:07:51.44,1:07:53.34,Default,,0,0,0,,因此 为了不让整个系统变得混乱
Dialogue: 0,1:07:53.36,1:07:57.66,Default,,0,0,0,,Harry最好把这些内部过程封装在它的立方根过程里
Dialogue: 0,1:07:58.40,1:08:00.06,Default,,0,0,0,,这个叫做块结构
Dialogue: 0,1:08:00.32,1:08:08.96,Default,,0,0,0,,这是把东西打包到定义内部的一种方法
Dialogue: 0,1:08:09.97,1:08:12.96,Default,,0,0,0,,让我们回过头来再看看
Dialogue: 0,1:08:13.12,1:08:18.57,Default,,0,0,0,,这种过程的定义读作 定义“sqrt”为
Dialogue: 0,1:08:19.87,1:08:21.84,Default,,0,0,0,,那么 在其内部
Dialogue: 0,1:08:22.13,1:08:25.49,Default,,0,0,0,,我们已有improve的定义
Dialogue: 0,1:08:25.56,1:08:28.88,Default,,0,0,0,,我们已有good-enough?和try的定义
Dialogue: 0,1:08:29.73,1:08:32.38,Default,,0,0,0,,以及这些定义的实体
Dialogue: 0,1:08:32.48,1:08:35.07,Default,,0,0,0,,我求平方根的定义实体是从1开始尝试
Dialogue: 0,1:08:36.08,1:08:39.33,Default,,0,0,0,,注意这里 我不必将X当做参数传递
Dialogue: 0,1:08:39.87,1:08:42.32,Default,,0,0,0,,因为它们都在平方根内部
Dialogue: 0,1:08:42.84,1:08:44.65,Default,,0,0,0,,它相当于已知这个X了
Dialogue: 0,1:08:54.06,1:08:56.37,Default,,0,0,0,,我来总结下
Dialogue: 0,1:08:56.49,1:08:59.49,Default,,0,0,0,,我们从表述指令性知识
Dialogue: 0,1:08:59.51,1:09:03.18,Default,,0,0,0,,开始学习
Dialogue: 0,1:09:04.99,1:09:09.74,Default,,0,0,0,,这张幻灯片总结了一些关于Lisp的知识
Dialogue: 0,1:09:09.74,1:09:15.12,Default,,0,0,0,,我们从基本元素如“+”和“*”开始
Dialogue: 0,1:09:15.85,1:09:19.50,Default,,0,0,0,,一些用于测试某物小于或等于的谓词
Dialogue: 0,1:09:19.52,1:09:22.99,Default,,0,0,0,,事实上 我们正在使用的系统掩盖了很多细节
Dialogue: 0,1:09:23.02,1:09:25.85,Default,,0,0,0,,这些并不是系统的基本元素 但这无所谓
Dialogue: 0,1:09:26.62,1:09:28.59,Default,,0,0,0,,重要的是我们会把它们当作是基本元素
Dialogue: 0,1:09:28.61,1:09:29.81,Default,,0,0,0,,我们不会去研究系统的内部
Dialogue: 0,1:09:30.29,1:09:33.15,Default,,0,0,0,,我们也有一些基本数据和一些数
Dialogue: 0,1:09:34.62,1:09:37.66,Default,,0,0,0,,我们学习了合成的手段 组合的手段
Dialogue: 0,1:09:37.74,1:09:41.37,Default,,0,0,0,,用运算符和运算对象合成函数
Dialogue: 0,1:09:41.41,1:09:43.76,Default,,0,0,0,,和构建组合式的基本方法
Dialogue: 0,1:09:44.81,1:09:48.43,Default,,0,0,0,,还有一些像是“COND”、“if”和“define”的东西
Dialogue: 0,1:09:51.29,1:09:53.69,Default,,0,0,0,,具体来说 关于“define”的重点则是
Dialogue: 0,1:09:53.87,1:09:55.71,Default,,0,0,0,,它是一种进行抽象的方法
Dialogue: 0,1:09:55.73,1:09:57.70,Default,,0,0,0,,它是我们为某物命名的方法
Dialogue: 0,1:09:57.79,1:10:00.30,Default,,0,0,0,,我们之前提到过  从这里也可以看出来
Dialogue: 0,1:10:01.57,1:10:06.28,Default,,0,0,0,,有时候 我们需要研究如何通过组合基本数据来得到复合数据
Dialogue: 0,1:10:06.56,1:10:12.03,Default,,0,0,0,,以及如何抽象数据 使得你可以在一个更大的环境中
Dialogue: 0,1:10:12.06,1:10:13.07,Default,,0,0,0,,将其当作基本数据使用
Dialogue: 0,1:10:13.90,1:10:15.87,Default,,0,0,0,,这也是我们的目的所在
Dialogue: 0,1:10:16.38,1:10:22.05,Default,,0,0,0,,在我们讨论这个问题之前 下节课我们首先将会讨论
Dialogue: 0,1:10:23.26,1:10:26.76,Default,,0,0,0,,我们编写的过程与机器内部
Dialogue: 0,1:10:26.88,1:10:30.77,Default,,0,0,0,,进程之间的联系
Dialogue: 0,1:10:32.14,1:10:35.98,Default,,0,0,0,,接着 我们将跳出小规模的计算问题
Dialogue: 0,1:10:36.38,1:10:39.77,Default,,0,0,0,,来学习如何发挥Lisp的威力
Dialogue: 0,1:10:40.08,1:10:44.15,Default,,0,0,0,,来解决更加通用的计算问题
Dialogue: 0,1:10:44.81,1:10:46.17,Default,,0,0,0,,好了 大家还有什么问题么
Dialogue: 0,1:10:46.75,1:10:52.27,Default,,0,0,0,,学生：在定义A时 如果我们用一个括号将A括起来
Dialogue: 0,1:10:52.32,1:10:53.50,Default,,0,0,0,,会与不使用括号不同么？
Dialogue: 0,1:10:53.60,1:10:56.88,Default,,0,0,0,,教授：如果我这样写
Dialogue: 0,1:10:57.53,1:11:02.13,Default,,0,0,0,,我则会是定义一个过程并命名为A
Dialogue: 0,1:11:03.21,1:11:06.85,Default,,0,0,0,,本例中 这个过程没有参数
Dialogue: 0,1:11:06.85,1:11:09.61,Default,,0,0,0,,而当我运行它 则会返回5乘以5
Dialogue: 0,1:11:11.07,1:11:12.29,Default,,0,0,0,,学生：它们俩完成了相同的事
Dialogue: 0,1:11:12.32,1:11:13.92,Default,,0,0,0,,但本质上是否相同？
Dialogue: 0,1:11:14.05,1:11:16.63,Default,,0,0,0,,教授：好 的确会有不同 之前的那一个
Dialogue: 0,1:11:17.02,1:11:18.35,Default,,0,0,0,,我还是在这里写清楚一点吧
Dialogue: 0,1:11:19.13,1:11:23.44,Default,,0,0,0,,我们还是把这个叫做A
Dialogue: 0,1:11:24.13,1:11:27.76,Default,,0,0,0,,作为对比 我们假装这里有一个
Dialogue: 0,1:11:27.79,1:11:37.56,Default,,0,0,0,,我定义D为5乘以5
Dialogue: 0,1:11:40.22,1:11:41.57,Default,,0,0,0,,这两者的区别则是
Dialogue: 0,1:11:41.96,1:11:44.24,Default,,0,0,0,,让我们看看它们在Lisp解释器中是怎样的
Dialogue: 0,1:11:45.74,1:11:49.13,Default,,0,0,0,,我在Lisp中键入A 返回25
Dialogue: 0,1:11:52.83,1:11:57.81,Default,,0,0,0,,如果我仅仅键入D
Dialogue: 0,1:11:58.49,1:12:05.55,Default,,0,0,0,,Lisp返回复合过程D
Dialogue: 0,1:12:07.12,1:12:09.13,Default,,0,0,0,,因为D就是一个过程
Dialogue: 0,1:12:09.69,1:12:12.59,Default,,0,0,0,,我可以运行D 我可以问运行D的结果是什么
Dialogue: 0,1:12:12.59,1:12:15.23,Default,,0,0,0,,这是一个没有运算数的组合式
Dialogue: 0,1:12:16.45,1:12:19.07,Default,,0,0,0,,我考虑到它没有运算数 所以我在D后面没有键入任何东西
Dialogue: 0,1:12:19.39,1:12:21.34,Default,,0,0,0,,Lisp则会说结果是25
Dialogue: 0,1:12:23.01,1:12:29.52,Default,,0,0,0,,我再说周全一点 如果我键入 A的运行结果是多少
Dialogue: 0,1:12:29.54,1:12:30.57,Default,,0,0,0,,只能得到一个错误
Dialogue: 0,1:12:31.79,1:12:35.29,Default,,0,0,0,,跟这里的错误一样
Dialogue: 0,1:12:35.33,1:12:40.51,Default,,0,0,0,,这个错误是因为 A的值——25
Dialogue: 0,1:12:40.56,1:12:43.24,Default,,0,0,0,,并不是我可以应用于某物的运算符
Dialogue: 0,1:12:43.36,1:12:55.05,Declare,,0,0,0,,{\fad(500,500)}MIT OpenCourseWare\Nhttp://ocw.mit.edu
Dialogue: 0,1:12:43.37,1:12:55.05,Declare,,0,0,0,,{\an2\fad(500,500)}本项目主页\Nhttps://github.com/FoOTOo/Learning-SICP
Dialogue: 0,1:12:49.11,1:12:51.11,Default,,0,0,0,,
