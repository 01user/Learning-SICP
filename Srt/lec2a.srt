1
00:00:00,000 --> 00:00:04,140
哈尔滨工业大学 IBM技术中心
倾情制作

2
00:00:04,140 --> 00:00:07,020
压制&&特效：蔡钟毓（JohnTitor）
字幕&&时间轴：徐梓翔（Dyul）

3
00:00:07,020 --> 00:00:10,280
特别感谢：裘宗燕教授
校对：邓雄飞（Dysprosium）

4
00:00:13,020 --> 00:00:22,020
高阶过程
Higher-order Procedures

5
00:00:25,280 --> 00:00:26,580

教授：昨天的内容还算容易
PROFESSOR: Well, yesterday was easy.

6
00:00:27,600 --> 00:00:29,440
你们了解到了所有的编程规则
You learned all of the rules of programming

7
00:00:30,740 --> 00:00:33,440
那些几乎是所有的规则了
and lived Almost all of them.

8
00:00:34,600 --> 00:00:37,100
所以此刻 你们算得上是所谓的---
And so at this point, you're now certified programmers

9
00:00:38,060 --> 00:00:38,740
合格的程序员了
-- it says.

10
00:00:39,700 --> 00:00:43,860
不过 我觉得其实是 啊...
However, I suppose what we did is we, aah,

11
00:00:46,720 --> 00:00:50,660
其实只是给你们尝了点甜头
sort of got you a little bit of into an easy state.

12
00:00:51,280 --> 00:00:54,840
此时此刻 你可能还在认为这门课就像
Here, you still believe it's possible that this might be programming

13
00:00:54,840 --> 00:00:57,640
用BASIC语言或者Pascal语言的某种奇葩语法写程序
in BASIC or Pascal with just a funny syntax.

14
00:00:59,140 --> 00:01:04,440
然而就在今天 这种错觉将会被颠覆
Today, that illusion-- or you can no longer support that belief.

15
00:01:04,780 --> 00:01:07,140
我们即将做的事 就是要彻底粉碎这种想法
What we're going to do today is going to completely smash that.

16
00:01:08,080 --> 00:01:13,420
接下来 我会先在黑板上写一些程序
So let's start out by writing a few programs on the blackboard

17
00:01:13,420 --> 00:01:15,020
它们之间有很多相似之处
that have a lot in common with each other

18
00:01:15,960 --> 00:01:18,360
我们要做的是尝试将它们抽象出来
What we're going to do is try to make them abstractions

19
00:01:18,820 --> 00:01:22,960
这过程并不如在其它大多数语言中那么显而易见
that are not ones that are easy to make in most languages.

20
00:01:23,740 --> 00:01:25,080
让我们先从其它语言也能完成的
Let's start with some very simple ones

21
00:01:25,080 --> 00:01:26,520
简单的例子开始
that you can make in most languages.

22
00:01:27,640 --> 00:01:33,680
假设 我有一个求和一组整数的数学表达式
Supposing I want to write the mathematical expression which adds up a bunch of integers.

23
00:01:34,140 --> 00:01:41,100
比如 我写下的这个表达式 以I为索引 求和从A到B的整数
So if I wanted to write down and say the sum from i equal a to b on i.

24
00:01:41,100 --> 00:01:44,820
你们知道用数学公式可以很方便地计算出它的结果
Now, you know that that's an easy thing to compute in a closed form for it,

25
00:01:44,820 --> 00:01:45,760
但我的重点不在此
and I'm not interested in that.

26
00:01:45,760 --> 00:01:48,180
我想要写一个能够求和那些整数程序
But I'm going to write a program that adds up those integers.

27
00:01:48,960 --> 00:01:52,880
我们能够很容易地想到
Well, that's rather easy to do to say

28
00:01:53,300 --> 00:02:07,400
定义求和从A到B的整数的过程SUM-INT为
I want to define the sum of the integers from a to b to be

29
00:02:07,780 --> 00:02:10,640
接下来有两种可能性
well, it's the following two possibilities.

30
00:02:10,900 --> 00:02:13,420
如果A大于B
If a is greater than b,

31
00:02:15,100 --> 00:02:18,220
毋庸置疑 答案就是0
well, then there's nothing to be done and the answer is zero.

32
00:02:18,980 --> 00:02:21,220
你要以递归的方式思考问题
This is how you're going to have to think recursively.

33
00:02:22,160 --> 00:02:25,020
比如 假如我知道某个简单情形的答案
You're going to say if I have an easy case that I know the answer to,

34
00:02:25,140 --> 00:02:25,980
就可以直接将其作为结果
just write it down.

35
00:02:26,220 --> 00:02:30,420
否则 我就需要将这个问题简化
Otherwise, I'm going to try to reduce this problem to a simpler problem.

36
00:02:30,620 --> 00:02:31,560
比如在这个程序里
And maybe in this case,

37
00:02:31,560 --> 00:02:33,240
我要简化出一个子问题
I'm going to make a subproblem of the simpler problem

38
00:02:33,240 --> 00:02:34,620
然后再做一些工作从而得出结果
and then do something to the result.

39
00:02:35,160 --> 00:02:38,700
所以针对这个程序 最简单的处理方式是
So the easiest way to do this is say that

40
00:02:38,700 --> 00:02:43,340
将下标 在这里是A
I'm going to add the index, which in this case is a,

41
00:02:44,520 --> 00:02:57,500
加上A+1到B的整数的求和结果
to the result of adding up the integers from a plus 1 to b.

42
00:03:02,360 --> 00:03:04,860
现在你们应该都能看懂这个定义了
Now, at this point, you should have no trouble looking at such a definition.

43
00:03:05,740 --> 00:03:09,860
实际上 总的来说 要想得出这个过程定义还是有一些困难的
Indeed, coming up with such a thing might be a little hard in synthesis,

44
00:03:10,180 --> 00:03:12,500
但要想读明白还是比较容易的
but being able to read it at this point should be easy.

45
00:03:13,400 --> 00:03:15,880
现在我想告诉你们的是
And what it says to you is, well,

46
00:03:16,440 --> 00:03:18,960
这个是我想要求解的子问题
here is the subproblem I'm going to solve.

47
00:03:19,120 --> 00:03:21,560
我要求和的是
I'm going to try to add up the integers,

48
00:03:21,880 --> 00:03:25,540
比整个问题的规模少一的整数序列
one fewer integer than I added up for the the whole problem.

49
00:03:26,440 --> 00:03:28,100
接下来需要求和的整数序列的数目会一个个减少
I'm adding up the one fewer one,

50
00:03:28,820 --> 00:03:32,680
最后 当这个子问题求解完毕后 只要再加上a
and that subproblem, once I've solved it, I'm going to add a to that,

51
00:03:34,200 --> 00:03:35,920
就能得到整个问题的答案了
and that will be the answer to this problem.

52
00:03:38,140 --> 00:03:40,400
并且 这里的最简单的情形 我不用做任何处理
And the simplest case, I don't have to do any work.

53
00:03:41,560 --> 00:03:45,160
接下来 我要给出另一个类似的简单问题---
Now, I'm also going to write down another simple one just like this,

54
00:03:46,260 --> 00:03:53,400
以i为下标 求和a到b的整数的平方的数学表达式
which is the mathematical expression, the sum of the square from i equal a to b.

55
00:03:55,340 --> 00:03:58,060
同样的 这个程序也很简单
And again, it's a very simple program.

56
00:04:11,180 --> 00:04:13,060
实际上 这个程序一开始和刚才是一样的
And indeed, it starts the same way.

57
00:04:16,220 --> 00:04:19,820
如果a大于b 那么答案就是0
If a is greater than b, then the answer is zero.

58
00:04:20,820 --> 00:04:25,980
显然 你会发现我又把这部分重复写了一遍
And, of course, we're beginning to see that there's something wrong with me writing this down again.

59
00:04:27,280 --> 00:04:28,860
这段程序和之前是相同的
It's the same program.

60
00:04:29,320 --> 00:04:45,900
这里是a的平方加上a+1到b的平方和
It's the sum of the square of a and the sum of the square of the increment and b.

61
00:04:50,440 --> 00:04:54,480
现在 你们再看看这两个程序 它们几乎是完全一样的
Now, if you look at these things, these programs are almost identical.

62
00:04:56,000 --> 00:04:58,860
并没有太多区别
There's not much to distinguish them.

63
00:04:59,760 --> 00:05:04,240
它们有相同的条件表达式 相同的谓词 相同的推论
They have the same first clause of the conditional and the same predicate and the same consequence,

64
00:05:05,580 --> 00:05:07,880
并且替代部分也非常的相似
and the alternatives are very similar, too.

65
00:05:08,660 --> 00:05:16,220
事实上 唯一的一个区别是 这里是a 而这里是a的平方
They only differ by the fact that where here I have a, here, I have the square of a.

66
00:05:17,200 --> 00:05:21,620
另一个区别 有些无关紧要
The only other difference, but this one's sort of unessential

67
00:05:21,740 --> 00:05:23,860
是这个过程的名字是sum int（整数的和）
is in the name of this procedure is sum int,

68
00:05:24,540 --> 00:05:26,460
而这个过程的名字是sum square（平方和）
whereas the name of the procedure is sum square.

69
00:05:27,420 --> 00:05:31,140
所以这两个程序的区别微乎其微
So the things that vary between these two are very small.

70
00:05:32,760 --> 00:05:36,360
现在来看 如果你重复地写了相同的东西
Now, wherever you see yourself writing the same thing down more than once,

71
00:05:36,840 --> 00:05:38,740
这就产生了一些问题 你并不应该那样做
there's something wrong, and you shouldn't be doing it.

72
00:05:39,800 --> 00:05:43,940
问题并不在于你重复的劳动带来时间浪费
And the reason is not because it's a waste of time to write something down more than once.

73
00:05:45,000 --> 00:05:48,900
而是在于里面的一些思想 非常简单的思想
It's because there's some idea here, a very simple idea,

74
00:05:50,260 --> 00:05:55,160
与求和记法相关的思想 -- 就是这一部分 --
which has to do with the sigma notation-- this much--

75
00:05:56,820 --> 00:05:59,400
其并不依赖于我待求和的内容
not depending upon what it is I'm adding up.

76
00:06:01,280 --> 00:06:05,900
无论何时 当要设计一个复杂的系统并且要弄明白它时
And I would like to be able to-- always, whenever trying to make complicated systems and understand them,

77
00:06:06,220 --> 00:06:09,440
将问题拆分成尽量多的模块是很重要的
it's crucial to divide the things up into as many pieces as I can,

78
00:06:09,640 --> 00:06:11,100
并且每一个模块要能够被独立地解释
each of which I understand separately.

79
00:06:12,640 --> 00:06:16,200
我想弄明白在不依赖具体内容的情况下 把东西加起来的方法
I would like to understand the way of adding things up independently of what it is I'm adding up

80
00:06:17,040 --> 00:06:22,320
这样我就只需要做一次调试 做一次分析
so I can do that having debugged it once and understood it once

81
00:06:23,360 --> 00:06:27,300
还能够与其他用户分享这段程序
and having been able to share that among many different uses of it.

82
00:06:29,040 --> 00:06:30,420
接下来 我有另外一个例子
Here, we have another example.

83
00:06:31,520 --> 00:06:38,800
这是莱布尼茨公式 用来求π/8的值
This is Leibnitz's formula for finding pi over 8.

84
00:06:39,940 --> 00:06:43,500
这一团糟的式子是什么意思？
It's a funny, ugly mess. What is it?

85
00:06:43,500 --> 00:06:54,220
大致是1/(1*3)+1/(5*7)+1/(7*9)+...这样子
It's something like 1 over 1 times 3 plus 1 over 5 times 7 plus 1 over 9 times 11 plus--

86
00:06:54,220 --> 00:07:00,960
有趣的是 根据一些证明 它将收敛到π/8
and for some reason, things like this tend to have interesting values like pi over 8.

87
00:07:01,740 --> 00:07:04,020
我们能发现什么？
But what do we see here?

88
00:07:04,020 --> 00:07:06,980
这个程序或多或少和之前的程序相同
It's the same program or almost the same program.

89
00:07:07,460 --> 00:07:08,920
也是一个求和过程 对吧？
It's a sum. Okay?

90
00:07:08,920 --> 00:07:16,300
我们发现这个表达里有一些细微的差别 它的递增的值是4 
So we're seeing the figure notation, although over here, we're dealing with incrementing by 4

91
00:07:16,620 --> 00:07:18,040
只是细微的差别而已
so it's a slightly different problem,

92
00:07:18,200 --> 00:07:23,580
所以我们需要在这里将a加4 就在鼠标所指的这个地方
which means that over here, I have to change a by 4, as you see right over here.

93
00:07:25,080 --> 00:07:26,200
不是加1了
It's not by 1.

94
00:07:27,920 --> 00:07:28,960
当然 另一个区别是
The other thing, of course,

95
00:07:29,260 --> 00:07:33,960
在之前的求平方和的程序里的求和项是平方值
is that the thing that's represented by square in the previous sum of squares,

96
00:07:33,960 --> 00:07:35,640
又或是在求整数和的程序里的求和项是整数本身
or a when adding up the integers.

97
00:07:36,020 --> 00:07:38,380
在这里 我用了不同的求和项
Well, here, I have a different thing I'm adding up, a different term,

98
00:07:38,680 --> 00:07:43,060
即1 / (a * (a + 2))
which is 1 over a times a plus 2.

99
00:07:43,940 --> 00:07:45,740
但是 其余部分的程序是相同的
But the rest of this program is identical.

100
00:07:48,140 --> 00:07:50,800
总之 每当我们发现有一些过程是相同的
Well, any time we have a bunch of things like this that are identical,

101
00:07:51,360 --> 00:07:54,240
我们就需要做一些抽象来包含它们
we're going to have to come up with some sort of abstraction to cover them.

102
00:07:55,580 --> 00:08:00,460
回想一下 到目前为止 你们学到的只是一些语法规则
If you think about this, what you've learned so far is the rules of some language,

103
00:08:00,520 --> 00:08:07,600
一些基本表达式 组合的方法 抽象的方法 大概就是这些
some primitive, some means of combination, almost all of them, the means of abstraction, almost all of them.

104
00:08:09,360 --> 00:08:11,700
但是 你们还没学到的是 使用的公共模式
But what you haven't learned is common patterns of usage.

105
00:08:12,880 --> 00:08:15,120
大多时候 你要学习的是一门语言习惯用法
Now, most of the time, you learn idioms when learning a language,

106
00:08:15,120 --> 00:08:19,820
它是一种有价值的公共模式
which is a common pattern that mean things that are useful to know in a flash.

107
00:08:20,780 --> 00:08:23,160
如果你是一个FORTRAN程序员 并且富有经验
And if you build a great number of them, if you're a FORTRAN programmer,

108
00:08:23,160 --> 00:08:26,420
你肯定知道
of course, everybody knows how to-- what do you do,

109
00:08:27,240 --> 00:08:30,260
比如 如何求某个数列中的最大值
for example, to get an integer which is the biggest integer in something.

110
00:08:30,860 --> 00:08:32,080
这是经典的问题
It's a classic thing.

111
00:08:32,220 --> 00:08:33,420
每个FORTRAN程序员都知道怎么做
Every FORTRAN programmer knows how to do that.

112
00:08:33,880 --> 00:08:36,820
如果你不知道的话 你可能会陷于困境并花很长的时间想出答案
And if you don't know that, you're in real hot water because it takes a long time to think it out.

113
00:08:37,700 --> 00:08:38,380
然而
However,

114
00:08:39,380 --> 00:08:41,780
在这门语言中我们想展示给你的
one of the things you can do in this language that we're showing you

115
00:08:41,980 --> 00:08:45,600
不是"鱼" 而是"渔"
is not only do you know something like that, but you give the knowledge of that a name.

116
00:08:48,040 --> 00:08:50,040
这就是我们接下来要做的事
And so that's what we're going to be going after right now.

117
00:08:53,020 --> 00:08:55,460
好吧 让我们先看看这些程序的共同点
OK, well, let's see what these things have in common.

118
00:08:58,060 --> 00:09:02,680
在这里我们有一个看似一般的模式
Right over here we have what appears to be a general pattern,

119
00:09:04,040 --> 00:09:07,020
它包含了到目前为止所有的例子
a general pattern which covers all of the cases we've seen so far.

120
00:09:09,380 --> 00:09:13,100
这里定义了一个求和过程
There is a sum procedure, which is being defined.

121
00:09:14,380 --> 00:09:18,040
它有两个参数 代表求和的下界和上界
It has two arguments, which are a lower bound and an upper bound.

122
00:09:19,380 --> 00:09:22,980
首先判断下界是否大于上界
The lower bound is tested to be greater than the upper bound,

123
00:09:22,980 --> 00:09:26,680
如果下界大于上界的话 结果就是0
and if it is greater, then the result is zero.

124
00:09:27,200 --> 00:09:31,080
否则 我们要对下界做一些处理
Otherwise, we're going to do something to the lower bound,

125
00:09:31,080 --> 00:09:33,540
也就是下标
which is the index of the conversation,

126
00:09:34,200 --> 00:09:40,540
将处理后的结果与后面这个过程的结果递归地相加
and add that result to the result of following the procedure recursively

127
00:09:41,300 --> 00:09:45,340
这个过程的参数是next操作处理后的下界
on our lower bound incremented by some next operation

128
00:09:47,560 --> 00:09:49,400
以及与之前相同的上界
with the same upper bound as I had before.

129
00:09:53,380 --> 00:09:56,760
这即是公共的模式
So this is a general pattern,

130
00:09:57,540 --> 00:10:00,980
#TBD (9'58) 我想要做的是
and what I'd like to do is be able to name this general pattern a bit.

131
00:10:03,180 --> 00:10:04,120
这还挺简单
Well, that's sort of easy,

132
00:10:05,000 --> 00:10:08,020
因为我要做的事...
because one of the things I'm going to do right now is--

133
00:10:08,020 --> 00:10:10,020
数字不是非常特殊的东西
there's nothing very special about numbers.

134
00:10:11,340 --> 00:10:13,100
数字仅仅是一种数据
Numbers are just one kind of data.

135
00:10:14,280 --> 00:10:20,300
为各种数据命名看上去也是很合理的事情
It seems to be perfectly reasonable to give all sorts of names to all kinds of data,

136
00:10:21,000 --> 00:10:22,140
比如说 “过程”
for example, procedures.

137
00:10:22,700 --> 00:10:25,680
并且当今很多语言都允许使用过程参数
And now many languages allow you have procedural arguments,

138
00:10:25,900 --> 00:10:28,460
现在 我们即将讨论过程参数
and right now, we're going to talk about procedural arguments.

139
00:10:29,020 --> 00:10:30,100
它们很容易处理
They're very easy to deal with.

140
00:10:30,860 --> 00:10:33,880
我们首先不去考虑过程参数 来做一些很特别的事情
And shortly, we'll do some remarkable things that are not like procedural arguments.

141
00:10:35,420 --> 00:10:41,700
这里 定义我们的求和记法
So here, we'll define our sigma notation.

142
00:10:42,780 --> 00:10:59,740
过程名叫做SUM 参数为term, A, NEXT和B
This is called sum and it takes a term, an A, a next term, and B as arguments.

143
00:10:59,740 --> 00:11:00,900
所以 它有四个参数
So it takes four arguments,

144
00:11:02,460 --> 00:11:05,520
这里我写成小写没有特殊的含义
and there was nothing particularly special about me writing this in lowercase.

145
00:11:06,020 --> 00:11:09,440
我不希望它迷惑你 所以我现在把它改成大写
I hope that it doesn't confuse you, so I'll write it in uppercase right now.

146
00:11:09,780 --> 00:11:10,680
机器并不关心大小写
The machine doesn't care.

147
00:11:14,140 --> 00:11:17,860
但这两个参数并不同。它们不是数字
But these two arguments are different. These are not numbers.

148
00:11:18,840 --> 00:11:22,140
它们是对数字进行计算的过程
These are going to be procedures for computing something given a number.

149
00:11:23,300 --> 00:11:25,700
TERM是这样一个过程 提供它一个下标
Term will be a procedure which, when given an index,

150
00:11:26,140 --> 00:11:28,660
TERM会计算出这个下标所对应的项的值
produce the value of the term for that index.

151
00:11:29,440 --> 00:11:32,420
提供NEXT过程一个下标 它会计算出下一个下标
Next will be given an index, which will produce the next index.

152
00:11:33,560 --> 00:11:34,740
这是用来计数的
This will be for counting.

153
00:11:35,540 --> 00:11:36,720
这很简单
And it's very simple.

154
00:11:40,060 --> 00:11:41,740
就是字面的意思
It's exactly what you see.

155
00:11:42,900 --> 00:11:50,800
如果A大于B 结果就是0
If A is greater than B, then the result is 0.

156
00:11:51,820 --> 00:12:10,000
否则 结果是TERM应用于A所产生的值与TERM,下一个下标产生的结果的和
Otherwise, it's the sum of term applied to A and the sum of term, next index.

157
00:12:15,120 --> 00:12:16,140
我换个方式写
Let me write it this way.

158
00:12:29,580 --> 00:12:31,660
现在 首先我要你们看一些东西
Now, I'd like you to see something, first of all.

159
00:12:31,820 --> 00:12:33,640
我写到黑板这 然后写不下了
I was writing here, and I ran out of space.

160
00:12:34,740 --> 00:12:38,640
于是我使用了缩进 依据的是整齐打印规则
What I did is I start indenting according to the Pretty-printing rule,

161
00:12:38,640 --> 00:12:41,980
意思是我把过程的每个参数对齐
which says that I align all of the arguments of the procedure

162
00:12:43,360 --> 00:12:45,280
这样我就能看清它们的层次
so I can see which ones go together.

163
00:12:46,600 --> 00:12:48,400
这是我刚才无意识地做下的
And this is just something I do automatically,

164
00:12:49,080 --> 00:12:50,220
并且我也希望你们学会这样做
and I want you to learn how to do that, too,

165
00:12:50,220 --> 00:12:51,940
这样你的程序就便于阅读和理解
so your programs can be read and understood.

166
00:12:53,800 --> 00:12:56,900
现在 看看我们有什么
However, what do we have here?

167
00:12:57,200 --> 00:13:02,100
我们有四个参数：过程、下界的下标、
We have four arguments: the procedure, the lower index- - lower bound index--

168
00:13:03,260 --> 00:13:06,180
获得下一个下标的方法 以及上界
the way to get the next index, and the upper bound.

169
00:13:08,440 --> 00:13:14,300
在递归调用的部分实际上传递的是同一个过程
What's passed along on the recursive call is indeed the same procedure

170
00:13:14,960 --> 00:13:16,120
因为我再一次需要它了
because I'm going to need it again,

171
00:13:17,120 --> 00:13:20,140
下一个下标 是用NEXT过程计算出的
the next index, which is using the next procedure to compute it,

172
00:13:20,840 --> 00:13:24,100
计算下一个下标的过程 我也单独地需要 因为这两者是不同的
the procedure for computing next, which I also have to have separately, and that's different.

173
00:13:24,820 --> 00:13:28,200
计算下一个下标的过程与下一个下标是不同的
The procedure for computing next is different from the next index,

174
00:13:28,680 --> 00:13:30,920
下一个下标是next过程应用于上一个下标所产生的结果
which is the result of using next on the last index.

175
00:13:31,960 --> 00:13:33,800
最后我也需要传递上界
And I also have to pass along the upper bound.

176
00:13:36,600 --> 00:13:45,300
于是 这就囊括了所有的这些 以及我们写过的其它的漂亮的程序
So this captures both of these and the other nice program that we are playing with.

177
00:13:47,440 --> 00:13:55,860
利用这个 我们就可以很容易地写出SUM的原始实例程序
So using this, we can write down the original program as instances of sum very simply.

178
00:14:08,700 --> 00:14:10,000
A和B
A and B.

179
00:14:15,260 --> 00:14:20,180
好吧 我在这需要一个identity（恒等）过程 因为...
Well, I'm going to need an identity procedure here because ,ahh,

180
00:14:25,520 --> 00:14:31,740
整数的求和需要我在这里对每一个整数计算一次term
the sum of the integers requires me to in this case compute a term for every integer,

181
00:14:32,060 --> 00:14:34,380
但是这个term过程并不对这个整数做任何改变
but the term procedure doesn't want to do anything to that integer.

182
00:14:35,240 --> 00:14:37,920
所以关于A的identity过程结果就是A
So the identity procedure on A is A

183
00:14:39,000 --> 00:14:40,280
写成X或者其它的符号也没关系
or X or whatever,

184
00:14:40,840 --> 00:14:46,400
接下来 将identity作为sum的term过程
and I want to say the sum of using identity of the term procedure

185
00:14:52,040 --> 00:14:53,860
用A作为初始下标
and using A as the initial index

186
00:14:55,300 --> 00:15:00,780
增量器用来获取下一个下标
and the incrementer being the way to get the next index

187
00:15:01,620 --> 00:15:06,360
B作为上界
and B being the high bound, the upper bound.

188
00:15:07,460 --> 00:15:12,340
这个过程与这里的SUM-INT过程工作方式相同
This procedure does exactly the same as the sum of the integers over here,

189
00:15:12,580 --> 00:15:13,720
计算出的答案也相同
computes the same answer.

190
00:15:17,200 --> 00:15:20,220
现在 值得注意的一点是
Now, one thing you should see, of course,

191
00:15:20,620 --> 00:15:25,380
这里的形式参数写成什么都无所谓
is that there's nothing very special over here about what I used as the formal parameter.

192
00:15:25,380 --> 00:15:28,800
比如 我可以把它写成X 也没关系
I could have, for example, written this X. It doesn't matter.

193
00:15:29,060 --> 00:15:34,240
注意到这个X和那个X并不冲突
I just wanted you to see that this name does not conflict with this one at all.

194
00:15:34,620 --> 00:15:35,820
这是一个内部名称
It's an internal name.

195
00:15:37,480 --> 00:15:41,060
对于第二个过程---平方和 它甚至更简单一些
For the second procedure here, the sum of the squares, it's even a little bit easier.

196
00:15:53,280 --> 00:15:58,020
我们需要做的仅仅是将平方项加起来
And what do we have to do? Nothing more than add up the squares,

197
00:16:00,740 --> 00:16:05,500
这个过程会对每个下标生效
this is the procedure that each index will be given, will be given each-- yes.

198
00:16:06,180 --> 00:16:09,220
每个下标使用这个过程来产生一个项
Each index will have this done to it to get the term.

199
00:16:09,940 --> 00:16:12,420
它对应了那里的term
That's the thing that maps against term over here.

200
00:16:13,140 --> 00:16:14,840
然后将A作为下界
Then I have A as the lower bound,

201
00:16:16,300 --> 00:16:19,300
增量器作为产生下一个项的方法
the incrementer as the next term method,

202
00:16:19,700 --> 00:16:21,140
B作为上界
and B as the upper bound.

203
00:16:26,520 --> 00:16:29,120
最后 来看看之前的pi sums过程
And finally, just for the thing that we did about pi sums,

204
00:16:30,740 --> 00:16:32,560
pi-sums是...
pi sums are sort of--

205
00:16:32,880 --> 00:16:36,240
用这种方法考虑的话 它简单到明显不过了
well, it's even easier to think about them this way because I don't have to think.

206
00:16:36,240 --> 00:16:41,980
我要做的其实是把我要累加的每一项从累加过程中独立出来
What I'm doing is separating the thing I'm adding up from the method of doing the addition.

207
00:16:42,720 --> 00:16:57,880
来看看 比如说 pi-sum A B这个过程
And so we have here, for example, pi sum A B of the sum of things.

208
00:16:59,480 --> 00:17:03,900
我接下来想要写出这个term过程 但不给它命名
I'm going to write the terms procedure here explicitly without giving it a name.

209
00:17:05,180 --> 00:17:06,700
用匿名的方式
This is done anonymously.

210
00:17:06,700 --> 00:17:11,460
如果我只是想一次性的使用它 我并不需要给它一个名字
I don't necessarily have to give a name to something if I just want to use it once.

211
00:17:12,360 --> 00:17:18,640
当然 我可以写出某个表达式来产生一个过程
And, of course, I can write sort of a expression that produces a procedure.

212
00:17:19,180 --> 00:17:23,820
我这里使用希腊字母的λ 而不是L-A-M-B-D-A的全拼
I'm going to write the Greek lambda letter here instead of L-A-M-B-D-A in general

213
00:17:24,000 --> 00:17:26,480
免得占用太多黑板的空间
to avoid taking up a lot of space on blackboards.

214
00:17:26,760 --> 00:17:29,160
可惜 我们的键盘上没有λ键
But unfortunately, we don't have lambda keys on our keyboards.

215
00:17:29,560 --> 00:17:33,340
或许我们可以说服计算机工业界的朋友意识到（λ键的）重要性
Maybe we can convince our friends in the computer industry that this is an important.

216
00:17:33,560 --> 00:17:45,220
该lambda过程以i为参数 操作是1除以i与i+2的积
Lambda of i is the quotient of 1 and the product of i and the sum of i 2,

217
00:17:51,840 --> 00:17:53,120
下标从a开始 
starting at a

218
00:17:53,480 --> 00:18:02,600
递增方法是以i为参数 将i+4的过程
with the way of incrementing being that procedure of an index i, which adds i to 4,

219
00:18:05,980 --> 00:18:09,420
b作为上界
and b being the upper bound.

220
00:18:11,960 --> 00:18:20,060
你可以看到这种记法 将过程用作过程参数 
So you can see that this notation, the invention of the procedure that takes a procedural argument,

221
00:18:20,460 --> 00:18:24,300
允许我们将很多过程组合成一个
allows us to compress a lot of these procedures into one thing.

222
00:18:26,040 --> 00:18:30,680
这个过程---sums 蕴含着一系列的思想
This procedure, sums, covers a whole bunch of ideas.

223
00:18:32,300 --> 00:18:33,740
现在考虑一下为什么这是很重要的？
Now, just why is this important?

224
00:18:34,240 --> 00:18:38,960
它帮助我们将一个问题拆分成两个 实际上 它做到了这点
I tried to say before that it helps us divide a problem into two pieces, and indeed, it does,

225
00:18:40,740 --> 00:18:44,620
比如说 如果某个人提出了另一个实现这个的方法
for example, if someone came up with a different way of implementing this,

226
00:18:45,920 --> 00:18:47,800
当然 确实有一个
which, of course, one might.

227
00:18:49,600 --> 00:18:51,920
比如 一个sum过程的迭代实现
Here, for example, an iterative implementation of sum.

228
00:18:55,500 --> 00:19:00,840
迭代实现在某种程度上也许比递归实现更好
Iterative implementation for some reason might be better than the recursive implementation.

229
00:19:03,100 --> 00:19:04,840
但是它还是有很大不同的
But the important thing is that it's different.

230
00:19:05,980 --> 00:19:11,700
如果我现在用黑板上左边的那种方法实现了我的程序
Now, supposing I had written my program this way that you see on the blackboard on the left.

231
00:19:14,100 --> 00:19:15,480
是的 左边那个程序
That's correct, the left.

232
00:19:17,340 --> 00:19:20,000
后来 我想要改变“求和”这个方法
Well, then if I want to change the method of addition,

233
00:19:21,440 --> 00:19:23,280
我就不得不修改这里的每一个程序
then I'd have to change each of these.

234
00:19:24,740 --> 00:19:28,780
然而 如果我用这里这个方法来实现的话
Whereas if I write them like this that you see here,

235
00:19:29,480 --> 00:19:32,940
那么“求和”这个方法就被封装在了sum过程里
then the method by which I did the addition is encapsulated in the procedure sum.

236
00:19:34,460 --> 00:19:38,400
这个分解允许我只需修改程序的一部分
That decomposition allows me to independently change one part of the program

237
00:19:39,340 --> 00:19:46,140
而不改变用于处理其它问题的那些部分
and prove it perhaps without changing the other part that was written for some of the other cases.

238
00:19:50,280 --> 00:19:51,340
谢谢 大家有问题吗？
Thank you. Are there any questions?

239
00:19:51,960 --> 00:19:52,480
那位男士
Yes, sir.

240
00:19:52,560 --> 00:19:54,500
观众：A后面的值会被一个一个遍历的吗……
AUDIENCE: Would you go over next A and next again on--

241
00:19:54,720 --> 00:19:56,020
教授：是的
PROFESSOR: Yes. It's the same problem.

242
00:19:56,020 --> 00:19:58,680
我确信你们需要花一些时间来想明白
I'm sure you're going to-- you're going to have to work on this.

243
00:19:58,680 --> 00:20:01,540
如果你第一次见到这种写法的话可能会很困惑
This is hard the first time you've ever seen something like this.

244
00:20:01,980 --> 00:20:07,220
这里的过程是可以命名为一个变量
What I have here is a-- procedures can be named by variables.

245
00:20:09,980 --> 00:20:11,180
“过程”这个概念并没有特殊的地方
Procedures are not special.

246
00:20:12,300 --> 00:20:15,420
实际上 sum square也只不过是一个变量 会产生一个值
Actually, sum square is a variable, which has gotten a value,

247
00:20:16,720 --> 00:20:17,580
这就是过程
which is a procedure.

248
00:20:18,200 --> 00:20:21,160
这里其实是定义sum square为一个参数为A、B的lambda过程
This is define sum square to be lambda of A and B something.

249
00:20:22,880 --> 00:20:23,980
所以过程可以被命名
So the procedure can be named.

250
00:20:24,300 --> 00:20:30,080
那样的话 过程就可以被作为参数传递于过程之间
Therefore, they can be passed from one to another, one procedure to another, as arguments.

251
00:20:31,020 --> 00:20:35,600
在这里 我们做的就是把term过程作为参数传递给sum
Well, what we're doing here is we're passing the procedure term as an argument to sum

252
00:20:36,780 --> 00:20:39,440
在下一层的递归中也会用到它
just when we get it around in the next recursive.

253
00:20:41,040 --> 00:20:46,680
同样地 我们也将next过程作为参数传递了
Here, we're passing the procedure next as an argument also.

254
00:20:47,200 --> 00:20:49,180
然而 在这里我们是使用了next过程
However, here we're using the procedure next.

255
00:20:49,540 --> 00:20:50,860
括号提现了这一点
That's what the parentheses mean.

256
00:20:51,300 --> 00:20:55,400
我们将next过程应用于变量A来获得A的下一个值
We're applying next to A to get the next value of A.

257
00:20:56,200 --> 00:20:57,920
如果你想知道next过程映射出了什么
If you look at what next is mapped against,

258
00:20:57,920 --> 00:21:00,520
你可以这样来考虑
remember that the way you think about this is

259
00:21:00,520 --> 00:21:04,620
用实际参数代换过程体中的形式参数
that you substitute the arguments for the formal parameters in the body.

260
00:21:06,040 --> 00:21:09,800
如果你还是困惑的话 就像这样想吧
If you're ever confused, think of the thing that way.

261
00:21:10,080 --> 00:21:13,540
比如在SUM-INT过程中
Well, over here, with sum of the integers.

262
00:21:14,320 --> 00:21:17,040
我用identity过程代换term过程
I substitute identity for a term

263
00:21:19,380 --> 00:21:24,420
用1+增量过程代换过程体中的next过程
and 1 plus the incrementer for next in the body.

264
00:21:25,660 --> 00:21:29,460
在这里我将identity过程应用于了A
Well, the identity procedure on A is what I get here.

265
00:21:30,100 --> 00:21:31,760
identity过程会被继续传递
Identity is being passed along,

266
00:21:33,740 --> 00:21:38,200
在这里 我将1+过程应用于了A
and here, I have increment 1 plus being applied to A

267
00:21:39,740 --> 00:21:41,220
并且1+过程也被传递下去
and 1 plus is being passed along.

268
00:21:42,520 --> 00:21:45,400
清楚这个情况了吗？
Does that clarify the situation?

269
00:21:45,600 --> 00:21:50,640
观众：我们也可以显式地定义那两个过程 然后再传递它们
AUDIENCE: We could also define explicitly those two functions, then pass them.

270
00:21:50,640 --> 00:21:51,320
教授：当然可以
PROFESSOR: Sure.

271
00:21:51,320 --> 00:21:55,380
我们的确可以命名这些过程 就如我这里做的一样
What we can do is we could have given names to them, just like I did here.

272
00:21:55,380 --> 00:21:58,500
实际上 我在这里提供了很多种方式给你们
In fact, I gave you various ways so you could see it, a variety.

273
00:21:58,500 --> 00:22:03,140
在这里 我定义了这个过程 并传递了它的名字
Here, I define the thing which I passed the name of.

274
00:22:03,220 --> 00:22:06,560
我用它的名字来引用它
I referenced it by its name.

275
00:22:07,400 --> 00:22:11,020
实际上这个过程的参数是X 结果也是X
But the thing is, in fact, that procedure, one argument X, which is X.

276
00:22:12,100 --> 00:22:15,780
identity过程实际上相当于lambda (x) (x)
And the identity procedure is just lambda of X X.

277
00:22:17,600 --> 00:22:19,520
这里就是这样的
And that's what you're seeing here.

278
00:22:20,020 --> 00:22:26,420
#TBD在这里 我就给你们写出了它的规范名称
Here, I happened to just write its canonical name there for you to see.

279
00:22:31,760 --> 00:22:33,020
让我们休息5分钟吧
Is it OK if we take our five-minute break?

280
00:23:15,360 --> 00:23:18,760
正如我说的 计算机用于满足人们的需求
As I said, computers to make people happy,

281
00:23:18,920 --> 00:23:20,440
而不是让人去满足计算机的需求
not people to make computers happy.

282
00:23:20,640 --> 00:23:23,980
我们介绍抽象概念的大部分原因
And for the most part, the reason why we introduce all this abstraction stuff

283
00:23:24,220 --> 00:23:28,080
是为了让程序更易写易读
is to make it so that programs can be more easily written and more easily read.

284
00:23:30,160 --> 00:23:33,580
让我们用一些关于抽象的例子
Let's try to understand what's the most complicated program we've seen so far

285
00:23:34,040 --> 00:23:37,140
来理解目前为止我们见到的最复杂的程序
using a little bit of this abstraction stuff.

286
00:23:37,940 --> 00:23:39,700
请看幻灯片
If you look at the slide,

287
00:23:39,960 --> 00:23:49,080
这是我们昨天介绍的Heron of Alexandria方法 用于计算平方根
this is the Heron of Alexandria's method of computing square roots that we saw yesterday.

288
00:23:51,300 --> 00:23:53,880
看一下这个程序
And let's see.

289
00:23:56,060 --> 00:24:01,180
不管怎样 这个程序有一些复杂
Well, in any case, this program is a little complicated.

290
00:24:01,700 --> 00:24:03,720
现在这种情况下
And at the current state of your thinking,

291
00:24:03,900 --> 00:24:05,240
你肯定不会看着这个程序说
you just can't look at that and say,

292
00:24:05,240 --> 00:24:08,940
哦 这个程序的目的真是显而易见
oh, this obviously means something very clear.

293
00:24:10,000 --> 00:24:14,540
它到底在计算什么一点都不明显
It's not obvious from looking at the program what it's computing.

294
00:24:16,040 --> 00:24:19,540
在try过程里有一些循环
There's some loop here inside try,

295
00:24:20,260 --> 00:24:24,200
循环在对y的improvement应用try过程
and a loop does something about trying the improvement of y.

296
00:24:25,800 --> 00:24:28,720
还有一个叫improve的什么东西
There's something called improve,

297
00:24:29,120 --> 00:24:32,500
做了一些关于average和除法的什么工作
which does some averaging and quotienting and things like that.

298
00:24:33,020 --> 00:24:34,580
但是它到底在做什么？
But what's the real idea?

299
00:24:34,580 --> 00:24:36,720
我们可以弄明白这个程序的目的吗？
Can we make it clear what the idea is?

300
00:24:38,360 --> 00:24:39,680
我认为我们可以
Well, I think we can.

301
00:24:41,260 --> 00:24:44,940
我觉得我们可以用之前学到的关于抽象的知识
I think we can use abstraction that we have learned about so far

302
00:24:45,380 --> 00:24:47,700
来说明它到底在干什么
to clarify what's going on.

303
00:24:48,520 --> 00:24:56,460
现在 我们在数学上有一个对平方根结果的更好猜测
Now, what we have mathematically is a procedure for improving a guess for square roots.

304
00:24:57,480 --> 00:25:04,180
如果y是平方根的一个猜测值 那么我们有一个函数f
And if y is a guess for a square root, then what we want to get we'll call a function f.

305
00:25:04,300 --> 00:25:05,700
用来改进猜测值
This is the means of improvement.

306
00:25:06,400 --> 00:25:13,360
我用(y+x/y)/2的结果
I want to get y plus x/y over 2, 

307
00:25:14,140 --> 00:25:22,200
作为改进的平方根猜测值
so the average of y and x divided by y as the improved value for the square root of x

308
00:25:23,840 --> 00:25:37,000
值得注意的一点是 f对根号x的求值结果就是根号x
such that-- one thing you can notice about this function f is that f of the square root of f is in fact the square root of x.

309
00:25:38,680 --> 00:25:42,500
因为 如果在这里我将y替换成根号x
there, if I take the square root of x and substitute it for y here,

310
00:25:43,120 --> 00:25:46,820
将会得到根号x加上x与根号x的商
I see the square root of x plus x divided by the square of x, which is the square root of x.

311
00:25:47,200 --> 00:25:50,200
是2倍根号x除以2 结果就是根号x
That's 2 times the square root of x divided by 2, is the square root of x.

312
00:25:50,920 --> 00:26:12,300
所以 实际上我们在寻找函数f的一个不动点
So, in fact, what we're really looking for is we're looking for a fixed point, a fixed point of the function f.

313
00:26:16,920 --> 00:26:21,240
不动点就是一个值
A fixed point is a place which has the property

314
00:26:21,980 --> 00:26:24,560
将其应用到函数中得到的还是原来的值
that if you put it into the function, you get the same value out.

315
00:26:27,180 --> 00:26:29,680
假设你在上一堂很无聊的课
Now, I suppose if I were giving some nice, boring lecture,

316
00:26:29,680 --> 00:26:35,080
碰巧你面前有一个HP-35计算器
and you happened to have in front of you an HP-35 desk calculator

317
00:26:35,080 --> 00:26:36,920
我过去就在无聊的课上用过
like I used to have when I went to boring lectures.

318
00:26:37,680 --> 00:26:39,500
如果你觉得无事可干
And if you think it was really boring,

319
00:26:39,500 --> 00:26:45,520
你可以进入弧度模式 不停地按cos键 按cos键 按cos键……
you put it into radians mode, and you hit cosine, and you hit cosine, and you hit cosine.

320
00:26:45,760 --> 00:26:50,400
最终 你将会停在大概是0.734这个值
And eventually, you end up with 0.734 or something like that. 0.743

321
00:26:50,460 --> 00:26:51,960
我记不太清了
I don't remember what exactly,

322
00:26:52,160 --> 00:26:53,780
越来越接近那个值
and it gets closer and closer to that.

323
00:26:54,540 --> 00:27:00,620
你可以通过迭代的方法找到一些函数的不动点
Some functions have the property that you can find their fixed point by iterating the function,

324
00:27:02,700 --> 00:27:07,520
实际上在海伦方法中发生的就是这个过程
and that's essentially what's happening in the square root program by Heron's method.

325
00:27:11,180 --> 00:27:13,600
看看我们能不能实现这个想法
So let's see if we can write that down, that idea. 

326
00:27:14,800 --> 00:27:17,040
现在我不打算讲如何计算出不动点
Now, I'm not going to say how I compute fixed points yet.

327
00:27:17,220 --> 00:27:18,560
那可以有很多种方法
There might be more than one way.

328
00:27:19,200 --> 00:27:23,560
首先让我们回到刚才的话题上
But the first thing to do is I'm going to say what I just said.

329
00:27:23,860 --> 00:27:27,020
回到平方根这个问题上
I'm going to say it specifically, the square root.

330
00:27:31,800 --> 00:27:45,360
x的平方根是一个过程的不动点
The square root of x is the fixed point of that procedure

331
00:27:47,660 --> 00:28:02,140
这个过程以y作为参数 计算出x/y和y的平均值
which takes an argument y and averages of x divided by y with y.

332
00:28:05,160 --> 00:28:09,200
并且假定初始不动点的猜测值为1
And we're going to start up with the initial guess for the fixed point of 1.

333
00:28:09,480 --> 00:28:10,800
初始值为几都无所谓
It doesn't matter where it starts.

334
00:28:11,400 --> 00:28:13,620
对于平方根在理论上证明过了
A theorem having to do with square roots.

335
00:28:18,280 --> 00:28:22,080
在这里我仅仅是按愿望思维写出了程序
So what you're seeing here is I'm just trying to write out by wishful thinking.

336
00:28:22,180 --> 00:28:24,360
我并不知道求不动点的具体细节
I don't know how I'm going to make fixed point happen.

337
00:28:24,360 --> 00:28:25,460
这点我们接下来再涉及
We'll worry about that later.

338
00:28:25,900 --> 00:28:30,900
假如我写出了一个求这个过程的不动点的函数
But if somehow I had a way of finding the fixed point of the function computed by this procedure,

339
00:28:32,440 --> 00:28:35,980
那么我就能得到平方根的值了
then I would have-- that would be the square root that I'm looking for.

340
00:28:39,160 --> 00:28:42,700
现在 我们来看看如何求不动点
OK, well, now let's see how we're going to write-- how we're going to come up with fixed points.

341
00:28:43,060 --> 00:28:44,600
实际上这很简单
Well, it's very simple, actually.

342
00:28:44,600 --> 00:28:47,640
我先写出一个简单的版本便于大家理解
I'm going to write an abbreviated version here just so we understand it.

343
00:29:00,060 --> 00:29:02,300
我要找到函数f的不动点a
I'm going to find the fixed point of a function f--

344
00:29:02,940 --> 00:29:08,240
在这个过程里 求不动点的函数我们命名为f
actually, the fixed point of the function computed by the procedure whose name will be f in this procedure.

345
00:29:09,620 --> 00:29:14,520
接下来 需要一个具体的值开始计算
How's that? A long sentence-- starting with a particular starting value.

346
00:29:19,520 --> 00:29:21,580
在过程内部需要一些循环
Well, I'm going to have a little loop inside here,

347
00:29:22,020 --> 00:29:25,120
代表了不停地在计算器上按键的过程
which is going to push the button on the calculator repeatedly,

348
00:29:25,460 --> 00:29:27,380
期待它最终会收敛到一点
hoping that it will eventually converge.

349
00:29:28,600 --> 00:29:35,780
内部的循环我们定义为内部过程
And we will say here internal loops are written by defining internal procedures.

350
00:29:38,980 --> 00:29:42,520
在这里 我需要确定我是否找到了我需要的值
Well, one thing I'm going to have to do is I'm going to have to say whether I'm done.

351
00:29:43,160 --> 00:29:45,140
我将要考察
And the way I'm going to decide when I'm done is when 

352
00:29:45,200 --> 00:29:48,660
新旧两值是否接近得无法区分
the old value and the new value are close enough so I can't distinguish them anymore.

353
00:29:50,360 --> 00:29:55,540
相当于你在计算器上看到结果的变化最终超出了精度范围
That's the standard thing you do on the calculator unless you look at more precision, and eventually, you run out of precision.

354
00:29:57,420 --> 00:30:02,940
所以 这里需要旧值和新值
So the old value and new value,

355
00:30:05,400 --> 00:30:10,380
并且如果它们足够接近
and I'm going to stay here if I can't distinguish them if they're close enough,

356
00:30:14,800 --> 00:30:16,640
接下来的操作我马上会提到
and we'll have to worry about what that is soon.

357
00:30:20,320 --> 00:30:22,620
如果旧值和新值足够接近的话
The old value and the new value are close enough to each other

358
00:30:22,620 --> 00:30:24,080
我们就选择新值作为结果
and let's pick the new value as the answer.

359
00:30:25,400 --> 00:30:28,500
否则 我继续迭代这个过程
Otherwise, I'm going to iterate around again

360
00:30:31,000 --> 00:30:36,360
将当前的新值作为下一轮的旧值
with the next value of old being the current value of new

361
00:30:38,260 --> 00:30:42,960
将f作用于新值的结果作为下一轮的新值
and the next value of new being the result of calling f on new.

362
00:30:53,680 --> 00:30:57,900
相当于我不停地按下计算器的键
And so this is my iteration loop that pushes the button on the calculator.

363
00:30:58,240 --> 00:31:01,760
我可以想象计算器中有两个寄存器：旧与新
I basically think of it as having two registers on the calculator: old and new.

364
00:31:02,420 --> 00:31:07,100
在每一步中 新值成为旧值 f作用后的新值成为新的新值
And in each step, new becomes old, and new gets F of new.

365
00:31:08,700 --> 00:31:10,940
这就是得到下一个猜测值的方法
So this is the thing where I'm getting the next value.

366
00:31:12,720 --> 00:31:21,720
现在 我传入两个值来调用这个方法
And now, I'm going to start this thing up by giving two values.

367
00:31:28,060 --> 00:31:31,200
我详细地在黑板上写出了每一个步骤
I wrote down on the blackboard to be slow so you can see this.

368
00:31:31,680 --> 00:31:35,340
这是你们第一次见到这么复杂的程序
This is the first time you've seen something quite this complicated, I think.

369
00:31:37,380 --> 00:31:48,920
我们还是需要在幻灯片上看一下整个程序
However, we might want to see the whole thing over here in this transparency or slide or whatever.

370
00:31:50,100 --> 00:31:57,680
这里详细地写出了程序所有需要的细节
What we have is all of the details that are required to make this thing work.

371
00:31:58,080 --> 00:32:02,700
在这里 我在close-enuf过程里给出了误差
I have a way of getting a tolerance for a close enough procedure, which we see here.

372
00:32:02,980 --> 00:32:06,180
close-enuf过程确定u和v是否足够接近
The close enough procedure, it tests whether u and v are close enough 

373
00:32:06,700 --> 00:32:12,140
通过比较u和v的差是否小于一个给定的公差实现
by seeing if the absolute value of the difference in u and v is less than the given tolerance, OK?

374
00:32:12,140 --> 00:32:14,620
这里是我刚才在黑板上写出的循环定义
And here is the iteration loop that I just wrote on the blackboard

375
00:32:15,500 --> 00:32:18,260
它的初始化调用在这
and the initialization for it, which is right there.

376
00:32:21,340 --> 00:32:22,180
非常简单
It's very simple.

377
00:32:33,840 --> 00:32:35,720
其实 我还没有说完
But let's see. I haven't told you enough.

378
00:32:36,160 --> 00:32:37,760
实际上这个程序可以更简单
It's actually easier than this.

379
00:32:39,320 --> 00:32:42,620
对于这个问题 在我讲述的内容背后隐含着更多的原理支撑
There is more structure to this problem than I've already told you.

380
00:32:42,620 --> 00:32:44,620
比如为什么这个方法可行
Like why should this work?

381
00:32:45,340 --> 00:32:46,680
为什么它会收敛
Why should it converge?

382
00:32:47,620 --> 00:32:51,220
在这个程序的背后有复杂的数学原理支撑
There's a hairy theorem in mathematics tied up in what I've written here.

383
00:32:52,320 --> 00:32:58,260
为什么我可以认为迭代计算(y+x/y)/2的值就能得到正确的结果
Why is it that I should assume that by iterating averaging the quotient of x and y and y that I should get the right answer?

384
00:32:59,820 --> 00:33:00,820
这些问题的答案都不明显
It isn't so obvious.

385
00:33:03,120 --> 00:33:10,240
当然 除此之外 还会有其他的计算不动点的方法 也能得到平方根的值
Surely there are other things, other procedures, which compute functions whose fixed points would also be the square root.

386
00:33:11,680 --> 00:33:18,620
比如 很明显的 函数g
For example, the obvious one will be a new function g,

387
00:33:19,980 --> 00:33:25,720
它将y映射为x/y
which maps y to x/y.

388
00:33:27,560 --> 00:33:28,620
这甚至更简单
That's even simpler.

389
00:33:30,580 --> 00:33:33,260
函数g的不动点显然也是平方根的值
The fixed point of g is surely the square root also,

390
00:33:33,800 --> 00:33:35,120
并且它使更为简单的过程
and it's a simpler procedure.

391
00:33:36,960 --> 00:33:38,200
为什么我不使用这种方法呢？
Why am I not using it?

392
00:33:38,560 --> 00:33:39,880
显而易见
Well, I suppose you know.

393
00:33:40,100 --> 00:33:41,220
假设x是2
Supposing x is 2

394
00:33:41,320 --> 00:33:42,480
并且猜测的初值是1
and I start out with 1,

395
00:33:42,780 --> 00:33:46,980
我将2除以1 得到2
and if I divide 1 into 2, I get 2.

396
00:33:47,300 --> 00:33:49,200
然后我将2除以2 得到1
And then if I divide 2 into 2, I get 1.

397
00:33:49,200 --> 00:33:52,120
再将2除以1得到2 2除以2得到1……
If I divide 1 into 2, I get 2, and 2 into 2, I get 1,

398
00:33:52,120 --> 00:33:53,820
这样 我永远也接近不了2的平方根
and I never get any closer to the square root.

399
00:33:55,140 --> 00:33:56,100
它在真实值上下摆动
It is oscillates.

400
00:33:59,080 --> 00:34:01,600
实际上 这相当于一个信号处理系统
So what we have is a signal processing system,

401
00:34:02,600 --> 00:34:05,500
一个振荡的电路
an electrical circuit which is oscillating,

402
00:34:05,500 --> 00:34:07,160
我想要减小振荡的振幅
and I want to damp out these oscillations.

403
00:34:10,140 --> 00:34:11,000
当然 我可以做到这点
Well, I can do that.

404
00:34:11,500 --> 00:34:14,440
在这里 我实际上用到的是平均值
See, what I'm really doing here when I'm taking my average,

405
00:34:14,680 --> 00:34:18,040
计算的是某个振荡的均值
the average is averaging the last two values of something which oscillates,

406
00:34:18,680 --> 00:34:19,800
得到了中间的某个值
getting something in between.

407
00:34:21,060 --> 00:34:24,940
传统的方法是在信号处理系统中添加阻尼
The classic way is damping out oscillations in a signal processing system.

408
00:34:28,140 --> 00:34:32,540
为什么我们不把刚才讲的策略用一种更清晰的方式表达呢？
So why don't we write down the strategy that I just said in a more clear way?

409
00:34:34,180 --> 00:34:35,240
其实 这并不那么复杂
Well, that's easy enough.

410
00:34:38,960 --> 00:34:46,260
将根号x的值定义为
I'm going to define the square root of x to be

411
00:34:47,080 --> 00:34:56,380
用平均阻尼的方法得到的某个过程的不动点
a fixed point of the procedure resulting from average damping.

412
00:34:58,120 --> 00:35:01,340
即将average-damp应用于过程
So I have a procedure resulting from average damp

413
00:35:10,000 --> 00:35:20,340
λ (y) (/ x y)
of the procedure, that procedure of y, which divides x by y

414
00:35:24,560 --> 00:35:25,420
初始猜测值为1
starting out at 1.

415
00:35:29,500 --> 00:35:32,560
average-damp是一个特殊的过程
Ah, but average damp is a special procedure

416
00:35:32,940 --> 00:35:34,560
它的参数是一个过程
that's going to take a procedure as its argument

417
00:35:34,800 --> 00:35:36,460
其返回值也是一个过程
and return a procedure as its value.

418
00:35:37,700 --> 00:35:39,460
具体来说
It's a generalization that says

419
00:35:39,800 --> 00:35:40,860
给定一个过程
given a procedure,

420
00:35:41,500 --> 00:35:42,940
它产生出另一个过程
it's the thing which produces a procedure

421
00:35:43,000 --> 00:35:45,940
用于计算出某一个值在给定的过程作用下
which averages the last value 

422
00:35:46,400 --> 00:35:48,500
结果与它原来的平均值
and the value before and after running the procedure.

423
00:35:50,980 --> 00:35:53,660
你可以在任何需要平均阻尼技术的地方使用它
You can use it for anything if you want to damp out oscillations.

424
00:35:54,560 --> 00:35:55,640
我们把它编写出来
So let's write that down.

425
00:35:56,460 --> 00:35:57,160
这很简单
It's very easy.

426
00:36:00,640 --> 00:36:01,920
在语法上
And stylistically here,

427
00:36:02,100 --> 00:36:03,720
我要使用lambda表达式
I'm going to use lambda notation

428
00:36:04,200 --> 00:36:07,860
因为当你的处理对象是过程的时候
because it's much easier to think when you're dealing with procedure, the mid-line procedures,

429
00:36:07,860 --> 00:36:10,520
这种记法会更易于你的理解
to understand that the procedures are the objects I'm dealing with,

430
00:36:10,860 --> 00:36:13,080
所以在这里我打算使用lambda表达式
so I'm going to use lambda notation here.

431
00:36:13,420 --> 00:36:15,020
我并不是经常使用它
Not always. I don't always use it,

432
00:36:15,640 --> 00:36:21,700
但用在这个过程里来阐明自己的想法是非常合适的
but very specifically here to expand on that idea, to elucidate it.

433
00:36:28,440 --> 00:36:30,260
average-damp这个过程
Well, average damp is a procedure,

434
00:36:31,720 --> 00:36:35,420
将一个过程作为自己的参数 记作f
which takes a procedure as its argument, which we will call f.

435
00:36:37,180 --> 00:36:38,060
它产生什么呢？
And what does it produce?

436
00:36:38,280 --> 00:36:44,100
这个过程产生的是一个过程
It produces as its value-- the body of this procedure is a thing which produces a procedure,

437
00:36:44,240 --> 00:36:46,060
产生的过程主体从这里开始
the construct of the procedures right here,

438
00:36:46,620 --> 00:36:48,480
拥有一个参数x
of one argument x,

439
00:36:49,900 --> 00:37:00,000
并计算出f(x)和x的平均值
which averages f of x with x.

440
00:37:10,200 --> 00:37:11,940
这是一个很神奇的过程
This is a very special thing.

441
00:37:12,940 --> 00:37:19,320
我猜这是你们第一次见到一个过程产生出另一个过程作为其结果
I think for the first time you're seeing a procedure which produces a procedure as its value.

442
00:37:21,980 --> 00:37:25,660
这个过程接受了过程f 做了一些工作
This procedure takes the procedure f and does something to it

443
00:37:25,920 --> 00:37:28,340
产生出一个新的过程 拥有一个参数x
to produce a new procedure of one argument x,

444
00:37:29,140 --> 00:37:30,660
计算出f...
which averages f

445
00:37:30,660 --> 00:37:31,200
这里的f
-- this f--

446
00:37:31,460 --> 00:37:33,860
f(x)和x的平均值
applied to x and x itself.

447
00:37:35,640 --> 00:37:37,200
在代码的这个部分
Using the context here,

448
00:37:37,660 --> 00:37:42,760
我将average-damp应用到过程x/y上
I apply average damping to the procedure, which just divides x by y.

449
00:37:44,340 --> 00:37:45,100
就是个除法
It's a division.

450
00:37:48,160 --> 00:37:49,760
接着再找到这个过程的不动点
And I'm finding to fixed point of that,

451
00:37:50,180 --> 00:37:54,440
这个写法更清晰的阐明了整个过程 较之于先前这里的写法
and that's a clearer way of writing down what I wrote down over here,

452
00:37:55,520 --> 00:37:56,480
我找找...
wherever it was.

453
00:37:57,280 --> 00:37:57,820
先前这里的写法
Here,

454
00:37:59,140 --> 00:38:00,880
因为它做出了更进一步的抽象
because it tells why I am writing this down.

455
00:38:04,740 --> 00:38:11,860
我希望以上这些能在一定程度上阐明Heron-Alexandria方法
I suppose this to some extent really clarifies what Heron of Alexandria was up to.

456
00:38:14,000 --> 00:38:15,560
先到此为止吧 有什么问题吗？
I suppose I'll stop now. Are there any questions?

457
00:38:17,900 --> 00:38:19,480
观众：在你定义average-damp过程的时候
AUDIENCE: So when you define average damp,

458
00:38:19,500 --> 00:38:23,340
不需要给f一个变量吗？
don't you need to have a variable on f?

459
00:38:24,700 --> 00:38:28,240
教授：啊 你的问题是...
PROFESSOR: Ah, the question was, and here we're having-- again,

460
00:38:28,240 --> 00:38:29,480
你应该已经了解语法了
you've got to learn about the syntax.

461
00:38:29,480 --> 00:38:32,480
你的问题是当定义average-damp的时候
The question was when defining average damp,

462
00:38:32,920 --> 00:38:36,920
是否需要给f一个变量？
don't you have to have a variable defined with f?

463
00:38:37,640 --> 00:38:39,840
你的意思是提供f的形式参数？
What you are asking about is the formal parameter of f?

464
00:38:40,040 --> 00:38:40,400
观众：是的
AUDIENCE: Yeah.

465
00:38:40,820 --> 00:38:41,540
教授：好的
PROFESSOR: OK.

466
00:38:42,640 --> 00:38:44,140
f的形式参数其实是在这里
The formal parameter of f is here.

467
00:38:44,780 --> 00:38:46,620
f的形式参数...
The formal parameter of f--

468
00:38:47,400 --> 00:38:49,180
观众：我指的是average-damp的形式参数
AUDIENCE: The formal parameter of average damp.

469
00:38:49,840 --> 00:38:54,100
教授：f在这里被应用到了一个参数上 对吗？
PROFESSOR: F is being used to apply it to an argument, right?

470
00:38:54,100 --> 00:38:56,480
实际上f确实需要一个形式参数
It's indeed true that f must have a formal parameter.

471
00:38:57,320 --> 00:38:59,480
我们来找一下f的形式参数在哪
Let's find out what f's formal parameter is.

472
00:39:00,020 --> 00:39:01,760
观众：我想问的是average-damp的形式参数
AUDIENCE: The formal parameter of average damp.

473
00:39:02,020 --> 00:39:04,160
教授：哦 f应该是average-damp的形式参数
PROFESSOR: Oh, f is the formal parameter of average damp.

474
00:39:04,240 --> 00:39:04,960
抱歉
I'm sorry.

475
00:39:05,120 --> 00:39:07,040
你被一些语法混淆了
You're just confusing a syntactic thing.

476
00:39:07,440 --> 00:39:09,120
我应该用换一种方式写
I could have written this the other way.

477
00:39:10,080 --> 00:39:11,300
我已经明白你的问题了
Actually, I didn't understand your question.

478
00:39:12,120 --> 00:39:13,620
我应该用这种方式写
Of course, I could have written it this other way.

479
00:39:19,120 --> 00:39:20,400
它们是一样的
Those are identical notations.

480
00:39:21,120 --> 00:39:25,540
这是另一种写法
This is a different way of writing this.

481
00:39:31,260 --> 00:39:32,880
你得习惯这种lambda记法
You're going to have to get used to lambda notation

482
00:39:32,880 --> 00:39:33,860
我以后也会使用
because I'm going to use it.

483
00:39:35,100 --> 00:39:36,100
在这里
What it says here,

484
00:39:36,580 --> 00:39:39,860
我定义了average-damp这个过程
I'm defining the name average damp

485
00:39:40,060 --> 00:39:43,220
来给这个拥有一个参数f的过程命名
to name the procedure whose of one argument f.

486
00:39:44,160 --> 00:39:46,760
这个f就是average-damp过程的形式参数
That's the formal parameter of the procedure average damp.

487
00:39:48,840 --> 00:39:55,260
这个define的作用是赋予这个名字一个值
What define does is it says give this name a value.

488
00:39:56,380 --> 00:39:57,760
这里就是这个值
Here is the value of for it.

489
00:40:00,940 --> 00:40:03,300
这是个有趣的语法
That there happens to be a funny syntax

490
00:40:04,140 --> 00:40:08,040
在一些情况下能带来一些便利
to make that easier in some cases is purely convenience.

491
00:40:10,580 --> 00:40:12,240
我在这里使用这种写法的原因
But the reason why I wrote it this way here

492
00:40:12,460 --> 00:40:15,800
是为了强调我处理的过程
is to emphasize that I'm dealing with a procedure

493
00:40:15,840 --> 00:40:17,020
接受了一个过程作为参数
that takes a procedure as its argument

494
00:40:17,020 --> 00:40:18,780
并且产生出另一个过程作为值
and produces a procedure as its value.

495
00:40:23,220 --> 00:40:25,460
观众：我不太理解你为什么使用两次lambda
AUDIENCE: I don't understand why you use lambda twice.

496
00:40:25,460 --> 00:40:28,900
难道不能使用一个lambda 以f和x作为参数吗？
Can you just use one lambda and take two arguments f and x?

497
00:40:28,900 --> 00:40:29,260
教授：不能
PROFESSOR: No.

498
00:40:29,260 --> 00:40:29,900
观众：不能？
AUDIENCE: You can't?

499
00:40:29,900 --> 00:40:31,440
教授：不 那是不同的东西了
PROFESSOR: No, that would be a different thing.

500
00:40:32,020 --> 00:40:33,840
如果我在这里写成
If I were to write the procedure

501
00:40:34,240 --> 00:40:37,720
(λ (f x) (average (f x) x))
lambda of f and x, the average of f of x and x,

502
00:40:38,440 --> 00:40:42,160
那么它就不能接受一个过程作为参数
that would not be something which would be allowed to take a procedure as an argument

503
00:40:42,160 --> 00:40:43,800
并且产生一个过程作为值了
and produce a procedure as its value.

504
00:40:44,260 --> 00:40:47,860
它就成为接受一个参数以及一个数字作为它的参数
That would be a thing that takes a procedure as its argument and numbers its argument

505
00:40:48,040 --> 00:40:49,240
并且产生出的是一个新的数
and produces a new number.

506
00:40:50,480 --> 00:40:52,260
而在这里我需要一个过程
But what I'm producing here is a procedure

507
00:40:52,260 --> 00:40:54,920
来作为这个过程的参数
to fit in the procedure slot over here,

508
00:40:54,920 --> 00:40:56,920
并且在这里使用
which is going to be used over here.

509
00:40:58,480 --> 00:40:59,940
所以数字必须来自这里
So the number has to come from here.

510
00:41:01,220 --> 00:41:03,540
最后直到这里才用上x
This is the thing that's going to eventually end up in the x.

511
00:41:04,080 --> 00:41:04,860
如果你仍然很迷惑
And if you're confused,

512
00:41:04,860 --> 00:41:08,520
你可以自己做一些代换
you should do some substitution and see for yourself.

513
00:41:11,580 --> 00:41:11,980
你说
Yes?

514
00:41:12,400 --> 00:41:15,740
观众：你可以展示一下如何不用lambda表达式
AUDIENCE: Will you please show the definition for average damp

515
00:41:15,740 --> 00:41:18,420
来定义average-damp过程吗？
without using lambda notation in both cases.

516
00:41:18,960 --> 00:41:21,080
教授：那样就无法如此简练地实现了
PROFESSOR: I can't make a very simple one like that.

517
00:41:21,080 --> 00:41:22,220
我来定义给你看
Let me do it for you, though.

518
00:41:22,220 --> 00:41:24,220
我可以很容易地去掉这个lambda
I can get rid of this lambda easily.

519
00:41:26,160 --> 00:41:27,680
我不希望...
I don't want to be--

520
00:41:32,400 --> 00:41:33,700
好吧 我说谎了
actually, I'm lying to you.

521
00:41:33,700 --> 00:41:35,460
我不想照你那样去实现
I don't want to do what you want

522
00:41:36,080 --> 00:41:37,860
因为这会远比你想象的复杂
because I think it's more confusing than you think.

523
00:41:38,520 --> 00:41:40,140
我就不去实现你的想法了
I'm not going to write what you want.

524
00:41:54,960 --> 00:41:56,200
这里得起个名字
So we'll have to get a name.

525
00:41:56,200 --> 00:42:00,100
(FOO x)为...
FOO of x to be

526
00:42:05,220 --> 00:42:09,500
...(F x)和x
of F of x and x

527
00:42:11,420 --> 00:42:13,280
返回值是FOO
and return as a value FOO.

528
00:42:16,920 --> 00:42:18,120
这个是等价的写法
This is equivalent,

529
00:42:19,020 --> 00:42:20,560
但我还得另写一个冗余的变量名
but I've had to make an arbitrary name up.

530
00:42:21,280 --> 00:42:23,860
这两个是等价的 但没有使用lambda
This is equivalent to this without any lambdas.

531
00:42:26,280 --> 00:42:30,920
lambda非常适合于需要匿名过程的地方
Lambda is very convenient for naming anonymous procedures.

532
00:42:30,920 --> 00:42:32,200
用它来代表一些匿名的事物
It's the anonymous name of something.

533
00:42:33,660 --> 00:42:39,160
其实存在着更优美的解决方法
Now, if you really want to know a cute way of doing this,

534
00:42:39,300 --> 00:42:40,220
我们以后会提到
we'll talk about it later.

535
00:42:41,380 --> 00:42:44,260
匿名过程的定义还是必要的
We're going to have to define the anonymous procedure.

536
00:42:44,780 --> 00:42:45,640
还有问题吗？
Any other questions?

537
00:42:49,100 --> 00:42:50,480
休息一下吧
And so we go for our break again.

538
00:43:31,360 --> 00:43:36,120
我们现在已经了解了如何使用高阶过程
So now we've seen how to use high-order procedures, they're called.

539
00:43:36,120 --> 00:43:39,520
用来接受过程参数和产生过程结果
That's procedures that take procedural arguments and produce procedural values

540
00:43:40,140 --> 00:43:44,780
来帮助我们阐明和抽象一些复杂的过程
to help us clarify and abstract some otherwise complicated processes.

541
00:43:46,060 --> 00:43:48,520
我现在打算用它来做一些更有趣的事情
I suppose what I'd like to do now is have a bit of fun with that

542
00:43:49,320 --> 00:43:52,900
也同时作为练习
and sort of a little practice as well.

543
00:43:53,720 --> 00:43:55,920
我们来更深入地研究一下square-root过程
So let's play with this square root thing even more.

544
00:43:55,920 --> 00:43:58,620
详尽地剖析和理解其中的工作方式
Let's elaborate it and understand what's going on

545
00:43:59,200 --> 00:44:01,800
并且利用一下它的代码结构
and make use of this kind of programming style.

546
00:44:03,940 --> 00:44:07,500
有件事你们已经知道
One thing that you might know is

547
00:44:07,500 --> 00:44:09,720
有一个通用的方法叫做Newton法
there is a general method called Newton's method

548
00:44:10,640 --> 00:44:13,780
用来计算函数的根
for the purpose of which is to find the roots--

549
00:44:14,480 --> 00:44:17,780
也就是函数的零点
that's the zeroes-- of functions.

550
00:44:18,740 --> 00:44:19,800
举个例子
So, for example,

551
00:44:20,700 --> 00:44:37,060
求y 使得f(y)等于0
to find a y such that f of y equals 0,

552
00:44:37,880 --> 00:44:39,340
首先要从一个猜测值开始
we start with some guess.

553
00:44:40,000 --> 00:44:40,960
这就是Newton法
This is Newton's method.

554
00:44:50,960 --> 00:44:53,720
将初始的猜测值命名为y_0
And the guess we start with we'll call y0,

555
00:44:54,840 --> 00:44:59,180
然后我们迭代地计算下面这个表达式
and then we will iterate the following expression.

556
00:45:00,580 --> 00:45:02,340
Yn+1
y n plus 1--

557
00:45:02,340 --> 00:45:03,760
这是另外一个方程
this is a difference equation--

558
00:45:04,460 --> 00:45:10,040
等于Yn-F(Yn)
is yn minus f of yn

559
00:45:12,000 --> 00:45:17,660
除以f对y的导数
over the derivative with respect to y of f

560
00:45:18,260 --> 00:45:21,760
在Y=Yn点处的值
evaluated at y equal yn.

561
00:45:22,840 --> 00:45:24,180
非常奇怪的式子
Very strange notation.

562
00:45:25,580 --> 00:45:29,340
我得说...
I must say ugh.

563
00:45:30,600 --> 00:45:34,620
f对y的求导得到的是一个函数
The derivative of f with respect to y is a function.

564
00:45:35,340 --> 00:45:37,420
感觉上会有些麻烦
I'm having a little bit of unhappiness with that,

565
00:45:37,840 --> 00:45:38,660
不过没关系
but that's all right.

566
00:45:39,140 --> 00:45:40,900
在用程序语言表达以后
It turns out in the programming language world,

567
00:45:40,980 --> 00:45:42,160
会变得非常清晰
the notation is much clearer.

568
00:45:43,560 --> 00:45:44,480
这是什么？
Now, what is this?

569
00:45:45,700 --> 00:45:46,860
这就是所谓的Newton法
People call it Newton's method.

570
00:45:46,900 --> 00:45:52,180
它用来计算函数f的根
It's a method for finding the roots of the function f.

571
00:45:53,860 --> 00:45:57,300
当收敛的时候 它会计算得很快
And it, of course, sometimes converges, and when it does, it does so very fast.

572
00:45:57,980 --> 00:46:00,340
不过有时是不收敛的
And sometimes, it doesn't converge, and,

573
00:46:00,580 --> 00:46:02,260
那样我们就需要做一些其它的工作
oh well, we have to do something else.

574
00:46:02,760 --> 00:46:05,640
先让我们来讨论一下用Newton法计算平方根
But let's talk about square root by Newton's method.

575
00:46:06,760 --> 00:46:08,320
这会很有趣
Well, that's rather interesting.

576
00:46:08,320 --> 00:46:10,380
我们先使用一下之前用到过的方法
Let's do exactly the same thing we did last time:

577
00:46:10,560 --> 00:46:11,900
按愿望思维的方法
a bit of wishful thinking.

578
00:46:13,020 --> 00:46:14,800
假设我们已经实现了Newton法
We will apply Newton's method,

579
00:46:14,980 --> 00:46:16,420
可以直接使用它
assuming we knew how to do it.

580
00:46:17,840 --> 00:46:19,200
事实上你还并未实现
You don't know how to do it yet.

581
00:46:20,300 --> 00:46:21,140
让我们开始吧
Well, let's go.

582
00:46:24,880 --> 00:46:26,780
这里要写什么？SQRT x（x的平方根）
What do I have here? The square root of x.

583
00:46:31,000 --> 00:46:39,040
将Newton法应用到某个作用在y上的过程上
It's Newton's method applied to a procedure which will represent that function of y,

584
00:46:39,040 --> 00:46:40,500
这个过程用于计算y对应的函数值
which computes that function of y.

585
00:46:42,100 --> 00:46:45,820
这个过程参数是y
Well, that procedure is that procedure of y,

586
00:46:46,840 --> 00:46:51,400
计算出x和根号y的差
which is the difference between x and the square of y.

587
00:46:59,660 --> 00:47:05,880
实际上 如果存在y使得这个式子等于0
Indeed, if I had a value of y for which this was zero,

588
00:47:07,020 --> 00:47:09,740
那么y就是x的平方根
then y would be the square root of x.

589
00:47:13,340 --> 00:47:13,940
明白吗？
See that?

590
00:47:15,160 --> 00:47:18,700
接下来 我令其从1开始尝试
OK, I'm going to start this out searching at 1.

591
00:47:18,880 --> 00:47:24,080
这完全是一个随意写下的猜测值
Again, completely arbitrary property of square roots that I can do that.

592
00:47:24,700 --> 00:47:30,280
现在的问题是 Newton法应该如何实现？
Now, how am I going to compute Newton's method?

593
00:47:31,160 --> 00:47:32,620
方法的过程在这里书写了
Well, this is the method I have it right here.

594
00:47:33,860 --> 00:47:39,580
实际上 我所做的是寻找某个过程的不动点
In fact, what I'm doing is looking for a fixed point of some procedure.

595
00:47:40,940 --> 00:47:44,320
这个过程包含了一些复杂的表达式
This procedure involves some complicated expressions

596
00:47:44,660 --> 00:47:46,740
和一些其它的怪东西
in terms of other complicated things.

597
00:47:47,140 --> 00:47:48,400
我就是要找到这个式子的不动点
Well, I'm trying to find the fixed point of this.

598
00:47:48,400 --> 00:47:52,060
我要找到某个y的值
I want to find the values of y,

599
00:47:52,300 --> 00:47:55,440
使得在这里带入这个值后 得到的是相同的值
which if I put y in here, I get the same value out here

600
00:47:56,580 --> 00:47:58,400
考虑在一定的误差范围内
up to some degree of accuracy.

601
00:47:59,740 --> 00:48:03,400
好在我已经有一个计算不动点的过程了
Well, I already have a fixed point process around to do that.

602
00:48:04,600 --> 00:48:07,300
我们在这里开始定义Newton法
And so, let's just define Newton's method over here.

603
00:48:19,640 --> 00:48:21,920
这个过程需要一个函数和一个猜测值
A procedure which computes a function and a guess,

604
00:48:24,440 --> 00:48:25,340
初始的猜测值
initial guess.

605
00:48:26,180 --> 00:48:28,100
我接下来要做一件事
Now, I'm going to have to do something here.

606
00:48:28,520 --> 00:48:32,520
要计算出函数的导数
I'm going to need the derivative of the function.

607
00:48:32,860 --> 00:48:35,100
我需要一个过程来计算出函数的导数
I'm going to need a procedure which computes the derivative

608
00:48:36,120 --> 00:48:39,140
给出的函数由过程f来计算
of the function computed by the given a procedure f.

609
00:48:41,700 --> 00:48:43,780
我接下来会讲的很仔细
I'm trying to be very careful about what I'm saying.

610
00:48:44,160 --> 00:48:45,860
我不想混淆“过程”和“函数”这两个词
I don't want to mix up the word procedure and function.

611
00:48:45,860 --> 00:48:47,180
函数是数学术语
Function is a mathematical word.

612
00:48:47,880 --> 00:48:52,160
将一个值映射到另一个值
It says I'm mapping from values to other values,

613
00:48:52,420 --> 00:48:53,360
有序偶的集合之类的
a set of ordered pairs.

614
00:48:55,060 --> 00:48:58,100
但有时我也会不小心说岔
But sometimes, I'll accidentally mix those up.

615
00:48:59,800 --> 00:49:01,540
而过程是用来计算函数的
Procedures compute functions.

616
00:49:07,360 --> 00:49:10,220
我将DF定义为...
So I'm going to define the derivative of f

617
00:49:10,820 --> 00:49:12,720
再使用一下按愿望思维
to be by wishful thinking again.

618
00:49:12,720 --> 00:49:13,560
先不管具体如何实现
I don't know how I'm going to do it.

619
00:49:14,360 --> 00:49:15,540
我们之后再讨论
Let's worry about that later--

620
00:49:18,360 --> 00:49:19,020
f的导数
of F.

621
00:49:20,160 --> 00:49:21,560
F是一个过程
So if F is a procedure,

622
00:49:23,280 --> 00:49:26,320
在这里的情况指的是开根号
which happens to be this one over here for a square root,

623
00:49:28,780 --> 00:49:31,780
DF就是其的导数
then DF will be the derivative of it,

624
00:49:31,920 --> 00:49:35,500
也就是由过程F计算的函数的导数
which is also the derivative of the function computed by that procedure.

625
00:49:35,500 --> 00:49:40,620
DF就是一个计算由过程F计算的函数的导数过程
DF will be a procedure that computes the derivative of the function computed by the procedure F.

626
00:49:41,840 --> 00:49:44,520
定义好这个之后 我就要来寻找一个不动点
And then given that, I will just go looking for a fixed point.

627
00:49:51,380 --> 00:49:53,160
我要寻找的不动点是什么的呢？
What is the fixed point I'm looking for?

628
00:49:53,300 --> 00:49:56,440
这个过程有一个参数x
It's the one for that procedure of one argument x,

629
00:49:57,060 --> 00:50:00,000
计算出x减...
which I compute by subtracting x.

630
00:50:00,100 --> 00:50:02,680
x是先前的值 相当于那里的y_n
That's the old-- that's the yn here.

631
00:50:04,480 --> 00:50:11,560
f(x)和df(x)的商
The quotient of f of x and df of x,

632
00:50:20,180 --> 00:50:21,540
从原始的猜测值开始
starting out with the original guess.

633
00:50:29,440 --> 00:50:31,020
整个看上去很简单
That's all very simple.

634
00:50:32,180 --> 00:50:34,220
现在 我还有一个部分没有写
Now, I have one part left that I haven't written,

635
00:50:34,220 --> 00:50:37,380
我先需要你们回顾一下我整个的实现流程
and I want you to see the process by which I write these things,

636
00:50:37,380 --> 00:50:38,520
这在实际经验中是很实用的
because this is really true.

637
00:50:39,820 --> 00:50:41,940
首先我拥有数学的猜想
I start out with some mathematical idea, perhaps.

638
00:50:42,220 --> 00:50:45,480
通过按愿望思维
By wishful thinking, I assume

639
00:50:46,280 --> 00:50:49,200
我假设我已经拥有了一些魔法可以实现一些过程
that by some magic I can do something that I have a name for.

640
00:50:50,580 --> 00:50:52,320
先不关心到底如何去实现它们
I'm not going to worry about how I do it yet.

641
00:50:54,500 --> 00:50:55,860
然后再继续
Then I go walking down here and say, well,

642
00:50:55,860 --> 00:50:59,060
通过这些魔法 我大致实现了整个过程
by some magic, I'm somehow going to figure how to do that,

643
00:51:00,540 --> 00:51:01,960
即使还未实现某些方法
but I'm going to write my program anyway.

644
00:51:03,880 --> 00:51:06,220
这种按愿望思维 对于工程来说是很重要的
Wishful thinking, essential to good engineering,

645
00:51:07,380 --> 00:51:09,700
同样 对于计算机科学也是很重要的
and certainly essential to a good computer science.

646
00:51:12,000 --> 00:51:16,560
那么 有多少人想让你的计算机运行得更快？
So anyway, how many of you wished that your computer ran faster?

647
00:51:20,900 --> 00:51:22,520
求导过程的实现并不会很困难
Well, the derivative isn't so bad either.

648
00:51:23,060 --> 00:51:24,280
有点类似于average-damping过程
Sort of like average damping.

649
00:51:28,980 --> 00:51:35,340
DERIV求导过程接受一个用于计算函数值的过程
The derivative is a procedure that takes a procedure that computes a function as its argument,

650
00:51:36,960 --> 00:51:41,000
然后产生一个过程
and it produces a procedure that computes a function,

651
00:51:41,180 --> 00:51:42,720
接受一个参数x
which needs one argument x.

652
00:51:43,700 --> 00:51:45,080
你们应该都清楚导数的定义
Well, you all know this definition.

653
00:51:45,900 --> 00:51:48,400
是(f(x + dx) - f(x)) / dx  对吗？
It's f of x plus delta x minus f of x over delta x, right?

654
00:51:48,720 --> 00:51:49,860
dx是一个很小的值
For some small delta x.

655
00:51:50,480 --> 00:52:10,180
即(/ (- (f (+ x dx)) (f x)) dx)
So that's the quotient of the difference of f of the sum of x and dx minus f point x divided by dx.

656
00:52:18,040 --> 00:52:21,800
我希望括号没有匹配错误
I think the thing was lining up correctly when I balanced the parentheses.

657
00:52:24,760 --> 00:52:25,840
我希望你们看一下这个
Now, I want you to look at this.

658
00:52:26,660 --> 00:52:27,460
仔细的观察一下
Just look.

659
00:52:30,880 --> 00:52:32,620
我应该还没定义dx
I suppose I haven't told you what dx is.

660
00:52:32,860 --> 00:52:35,420
我会在其它某个地方写下
Somewhere in the world I'm going to have to write down

661
00:52:44,240 --> 00:52:45,340
这样的定义
something like that.

662
00:52:45,760 --> 00:52:46,780
这无关紧要
I'm not interested.

663
00:52:47,820 --> 00:52:53,680
这个过程接受一个过程然后产生出一个近似过程
This is a procedure which takes a procedure and produces an approximation,

664
00:52:53,680 --> 00:52:56,480
这个近似过程用于计算出某个函数的导数
a procedure that computes an approximation of the derivative 

665
00:52:56,540 --> 00:52:58,540
]函数是由给定的过程计算的
]of the function computed by the procedure given

666
00:53:00,860 --> 00:53:03,000
其中使用了大家熟悉的求导方法
by the standard methods that you all know and love.

667
00:53:04,360 --> 00:53:10,440
也许这并不是一个很好的估算导数的方法
Now, it may not be the case that doing this operation is such a good way of approximating a derivative.

668
00:53:11,020 --> 00:53:14,700
数值分析学家可能会跳出来对我说
Numerical analysts here should jump on me and say

669
00:53:14,700 --> 00:53:15,360
不要那样做！
don't do that.

670
00:53:16,320 --> 00:53:18,700
计算机求导确实会带来一定的误差
Computing derivatives produces noisy answers, which is true.

671
00:53:19,960 --> 00:53:23,460
然而这只是用于理解整个过程
However, this again is for the sake of understanding.

672
00:53:24,380 --> 00:53:25,320
回顾一下
Look what we've got.

673
00:53:26,180 --> 00:53:29,520
我们首先起手于一个复杂的数学方法
We started out with what is apparently a mathematically complex thing.

674
00:53:30,820 --> 00:53:32,560
写满的几个黑板中
and in a few blackboards full,

675
00:53:33,760 --> 00:53:36,840
我们试图将这个求根号的问题分解
we managed to decompose the problem of computing square roots

676
00:53:36,840 --> 00:53:42,300
通过你们在数值课程中学到的Newton法
by the way you were taught in your college calculus class-- Newton's method--

677
00:53:43,380 --> 00:53:44,540
分解以后就能很容易处理了
so that it can be understood.

678
00:53:45,480 --> 00:53:46,220
变得清晰了
It's clear.

679
00:53:47,400 --> 00:53:49,780
看一下求解的整个结构
Let's look at the structure of what it is we've got.

680
00:53:51,160 --> 00:53:52,580
请看一下幻灯片
Let's look at this slide.

681
00:53:54,580 --> 00:54:04,140
这是黑板上描述的程序的流程图
This is a diagram of the machine described by the program on the blackboard.

682
00:54:05,440 --> 00:54:06,960
描述了机器执行的过程
There's a machine described here.

683
00:54:08,520 --> 00:54:09,440
有哪些部分呢？
And what have I got?

684
00:54:10,240 --> 00:54:16,540
这个部分代表了Newton法中的函数f
Over here is the Newton's method function f

685
00:54:16,840 --> 00:54:19,040
写在了黑板的最左面
that we have on the left-most blackboard.

686
00:54:20,180 --> 00:54:22,520
它接受了一个参数y
It's the thing that takes an argument called y

687
00:54:22,780 --> 00:54:27,160
计算出x与根号y的差
and puts out the difference between x and the square of y,

688
00:54:29,560 --> 00:54:35,980
通过某种魔法 x作为自由变量从外部进入
where x is some sort of free variable that comes in from the outside by some magic.

689
00:54:37,700 --> 00:54:41,500
所以square-root过程需要获取到x的值
So the square root routine picks up an x,

690
00:54:42,180 --> 00:54:43,640
并给定这个过程
and builds this procedure,

691
00:54:45,280 --> 00:54:48,120
x就被替换到内部的过程中
which I have the x rolled up in it by substitution.

692
00:54:49,720 --> 00:54:54,780
云中的这个过程被作为参数f
Now, this procedure in the cloud is fed in as the f

693
00:54:58,080 --> 00:55:01,280
传递进这个框中的Newton法
into the Newton's method which is here, this box.

694
00:55:04,580 --> 00:55:07,900
f在这里有两个去向
The f is fanned out.

695
00:55:08,400 --> 00:55:10,380
一是被用作参数传递
Part of it goes into something else,

696
00:55:10,900 --> 00:55:14,220
二是被应用到求导过程中 再将求导结果传递
and the other part of it goes through a derivative process into something else

697
00:55:14,980 --> 00:55:17,140
来产生一个新的过程
to produce a procedure,

698
00:55:17,720 --> 00:55:23,360
产生出的过程作为计算Newton法的迭代函数的过程
which computes the function which is the iteration function of Newton's method

699
00:55:23,360 --> 00:55:24,640
最后将其应用到求不动点的方法上
when we use the fixed point method.

700
00:55:27,120 --> 00:55:29,000
所以这个过程
So this procedure,

701
00:55:29,940 --> 00:55:32,420
通过代换使用了（f和df）
which contains it by substitution--

702
00:55:32,560 --> 00:55:38,340
记住 是这里的Newton法构造出了这个过程
remember, Newton's method over here, Newton's method builds this procedure,

703
00:55:39,320 --> 00:55:43,060
并且是在Newton法中定义了f和df
and Newton's method has in it defined f and df,

704
00:55:44,640 --> 00:55:47,300
所以 f和df在这里被捕获
so those are captured over here: f and df.

705
00:55:48,600 --> 00:55:49,900
利用这个过程
Starting with this procedure,

706
00:55:50,440 --> 00:55:52,680
传递进fixed-point过程里
I can now feed this to the fixed point process

707
00:55:53,220 --> 00:55:56,840
再利用从square-root外传递进的初始的猜测值
within an initial guess coming out from the outside from square root

708
00:55:58,140 --> 00:55:59,580
来计算出x的平方根
to produce the square root of x.

709
00:56:03,340 --> 00:56:05,820
于是我们就制造出了一个强大的引擎
So what we've built is a very powerful engine,

710
00:56:06,600 --> 00:56:09,260
通过它我们可以制造出类似的优美的东西
which allows us to make nice things like this.

711
00:56:11,240 --> 00:56:19,160
最后 我想使用Chris Strachey提出的一个基本思想作为结束
Now, I want to end this with basically an idea of Chris Strachey,

712
00:56:19,600 --> 00:56:22,540
他是计算机科学之父之一
one of the grandfathers of computer science.

713
00:56:22,900 --> 00:56:25,180
他是一位逻辑学家 大概...
He's a logician who lived in the--

714
00:56:27,040 --> 00:56:29,700
大概10到15年前他去世了
I suppose about 10 years ago or 15 years ago, he died.

715
00:56:29,860 --> 00:56:31,340
我记不太清了
I don't remember exactly when.

716
00:56:31,500 --> 00:56:34,240
他是指称语义学的发明者之一
He's one of the inventors of something called denotational semantics.

717
00:56:34,600 --> 00:56:42,320
他是将过程或是函数视为程序设计语言中的第一级元素的最主要的提倡者
He was a great advocate of making procedures or functions first-class citizens in a programming language.

718
00:56:43,540 --> 00:56:48,660
这些是程序设计语言中的第一级元素的某些权利或者特权
So here's the rights and privileges of first-class citizens in a programming language.

719
00:56:50,140 --> 00:56:52,080
如果你想要做出任何你想要做出的抽象
It allows you to make any abstraction you like

720
00:56:52,540 --> 00:56:55,460
那么将函数视为第一级元素是必须的
if you have functions as first-class citizens.

721
00:56:57,260 --> 00:57:00,060
第一级元素必须能够可以用变量命名
The first-class citizens must be able to be named by variables.

722
00:57:01,840 --> 00:57:03,660
你们已经见过我这样做过很多次
And you're seeing me doing that all the time.

723
00:57:04,000 --> 00:57:08,200
这里是将某个过程作为变量命名的例子
Here's a nice variable which names a procedure which computes something.

724
00:57:12,820 --> 00:57:15,040
他们必须可以被提供给过程作为参数
They have to be passed as arguments to procedures.

725
00:57:15,040 --> 00:57:16,020
我们之前见过这种情况了
We've certainly seen that.

726
00:57:18,160 --> 00:57:20,940
他们可以由过程作为结果返回
We have to be able to return them as values from procedures.

727
00:57:22,840 --> 00:57:24,320
我们也应该见过了
And I suppose we've seen that.

728
00:57:24,740 --> 00:57:27,040
我们还没有见过关于数据结构的内容
We haven't yet seen anything about data structures.

729
00:57:27,600 --> 00:57:28,440
我们之后会讨论的
We will soon,

730
00:57:29,140 --> 00:57:33,140
这也是作为程序设计语言的第一级元素必要的性质
but it's also the case that in order to have a first-class citizen in a programming language,

731
00:57:33,520 --> 00:57:35,980
它们可以包含在数据结构中
the object has to be allowed to be part of a data structure.

732
00:57:36,760 --> 00:57:37,880
我们马上就会见到
We're going to see that soon.

733
00:57:39,040 --> 00:57:40,320
所以就先到此为止吧
So I just want to close with this

734
00:57:40,820 --> 00:57:46,380
我们见识到了像过程这样的第一级元素
and say having things like procedures as first-class data structures, first-class data,

735
00:57:46,960 --> 00:57:49,800
可以带来如此强大的抽象能力
allows one to make powerful abstractions,

736
00:57:50,220 --> 00:57:53,720
像Newton法这样的通用方法可以被非常清晰地编写出来
which encode general methods like Newton's method in very clear way.

737
00:57:54,380 --> 00:57:55,280
有什么问题吗？
Are there any questions?

738
00:57:56,960 --> 00:57:57,440
请
Yes.

739
00:57:57,980 --> 00:58:01,920
观众：DERIV F可以直接写到fixed-point方法中取代df吗
AUDIENCE: Could you put derivative instead of df directly in the fixed point?

740
00:58:02,120 --> 00:58:02,700
教授：哦 当然
PROFESSOR: Oh, sure.

741
00:58:03,420 --> 00:58:07,400
当然可以直接把DERIV F放到这里
Yes, I could have put deriv of f right here,

742
00:58:08,180 --> 00:58:09,080
没有问题
no question.

743
00:58:11,360 --> 00:58:13,320
每当你见到定义了什么东西
Any time you see something defined,

744
00:58:14,180 --> 00:58:17,240
你就可以直接把定义写到这里
you can put the thing that the definition is there

745
00:58:18,380 --> 00:58:19,320
你会得到相同的结果
and you should get the same result.

746
00:58:20,620 --> 00:58:22,700
实际上 那样就会看上去很有趣
In fact, what that would look like, it's interesting.

747
00:58:22,700 --> 00:58:23,040
观众：lambda
AUDIENCE: Lambda.

748
00:58:23,240 --> 00:58:23,660
教授：嗯？
PROFESSOR: Huh?

749
00:58:23,760 --> 00:58:25,300
观众：你可以把lambda表达式写在那
AUDIENCE: You could put the lambda expression in there.

750
00:58:25,480 --> 00:58:28,340
教授：我也可以把DERIV F写在这
PROFESSOR: I could also put derivative of f here.

751
00:58:29,940 --> 00:58:30,820
这看上去会很有意思
It would look interesting

752
00:58:31,100 --> 00:58:36,620
即((DERIV F) x)
because of the open paren, open paren, deriv of f, closed paren on an x.

753
00:58:38,140 --> 00:58:41,840
那样就会冗余地重复计算导数
Now, that would have the bad property of computing the derivative many times,

754
00:58:42,480 --> 00:58:43,840
因为每当我执行这个过程的时候
because every time I would run this procedure,

755
00:58:43,840 --> 00:58:45,120
都要重新计算导数
I would compute the derivative again.

756
00:58:47,840 --> 00:58:51,800
这里的两个左括号都有意义
However, the two open parens here both would be meaningful.

757
00:58:52,100 --> 00:58:54,960
我希望你们理解这里细节的语法
I want you to understand syntactically that that's a sensible thing.

758
00:58:55,820 --> 00:58:57,460
如果我重写这个程序
Because if was to rewrite this program--

759
00:58:57,460 --> 00:58:58,920
在这里按照你的想法重写
and I should do it right here just so you see

760
00:58:59,760 --> 00:59:00,800
这个问题问得好
because that's a good question--

761
00:59:10,200 --> 00:59:12,260
...F和GUESS
of F and guess

762
00:59:15,800 --> 00:59:26,080
结果是求参数为x
to be fixed point of that procedure of one argument x,

763
00:59:26,380 --> 00:59:44,720
结果为(- x (/ (f x)((DERIV F) x)))的过程的不动点
which subtracts from x the quotient of F applied to x and the deriv of F applied to x.

764
00:59:52,940 --> 00:59:54,220
这里是GUESS
Um, This is guess.

765
00:59:59,500 --> 01:00:01,420
这是一个完全正确的程序
This is a perfectly legitimate program,

766
01:00:02,260 --> 01:00:03,540
因为在这里...
because what I have here--

767
01:00:03,860 --> 01:00:05,300
记住求值规则
remember the evaluation rule.

768
01:00:05,780 --> 01:00:09,040
求值规则是求值每个组合式的所有部分
The evaluation rule is evaluate all of the parts of the combination:

769
01:00:09,040 --> 01:00:11,040
包括运算符和运算对象
the operator and the operands.

770
01:00:11,720 --> 01:00:14,640
这是这个组合式的运算符
This is the operator of this combination.

771
01:00:16,540 --> 01:00:22,120
求值这个运算符会产生F的导数
Evaluating this operator will, of course, produce the derivative of F.

772
01:00:28,080 --> 01:00:31,160
观众：甚者 是否可以在那里写成lambda表达式
AUDIENCE: To get it one step further, you could put the lambda expression there, too.

773
01:00:31,220 --> 01:00:32,020
教授：哦当然
PROFESSOR: Oh, of course.

774
01:00:32,780 --> 01:00:35,720
每当我在某处使用了定义好的东西
Any time I take something which is define,

775
01:00:35,720 --> 01:00:40,760
我也可以将其替换成它定义的具体内容
I can put the thing it's defined to be in the place where the thing defined is.

776
01:00:41,960 --> 01:00:44,820
不用去区分哪个是被定义项 哪个是定义项
I can't remember which is definiens and which is definiendum.

777
01:00:45,460 --> 01:00:51,600
每当我在思考如何在课堂上向新手解释这个问题
When I'm trying to figure out how to do a lecture about this in a freshman class,

778
01:00:51,600 --> 01:00:55,120
我觉得这种概念游戏是很有意思的
I use such words and tell everybody it's fun to tell their friends.

779
01:00:59,200 --> 01:01:00,040
那么就到此为止吧
OK, I think that's it.

