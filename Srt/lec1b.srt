哈尔滨工业大学 IBM技术中心
倾情制作

压制&&特效：（Tacitus）
字幕&&时间轴：曹竞帆（ChingfanTsou）

特别感谢：裘宗燕

[音乐]
[MUSIC PLAYING BY J.S. BACH]

教授 大家好
PROFESSOR: Hi.

大家都已经知道 程序员的工作
You've seen that the job of a programmer

就是设计出能够达成特定目标的程序
is to design processes that accomplish particular goals,

比如求出一个数的平方根
such as finding the square roots of numbers,

或者其它一些你想要做的事
or other sorts of things you might want to do.

目前为止我们还没介绍别的什么东西
We haven't introduced anything else yet.

当然了
Of course,

程序员完成工作的方式就是构造“咒语”
the way in which a programmer does this is by constructing spells,

通过过程和表达式构造出来的“咒语”
which are constructed out of procedures and expressions.

这些“咒语”一定程度上指明了
And that these spells are somehow direct a process

程序员想要的达成目标的方式
to accomplish the goal that was intended by the programmer.

程序员为了使整个过程变得高效
In order for the programmer to do this effectively,

必须理解他写下的代码
he has to understand the relationship

这些“咒语”
between the particular things that he writes,

和他想要控制的程序的行为
these particular spells,

之间的联系
and the behavior of the process that he's attempting to control.

所以我们在这门课中要做的就是试图
So what we're doing this lecture is attempt to

以尽可能清晰的方式建立这样的联系
establish that connection in as clear a way as possible.

我们尤其要理解
What we will particularly do is understand

特定过程和表达式的模式
how particular patterns of procedures and expressions

将会导致怎样的特定程序执行模式
cause particular patterns of execution,

和计算过程的特定的行为
particular behaviors from the processes.

让我们开始吧
Let's get down to that.

我将会从一个非常简单的程序开始
I'm going to start with a very simple program.

这是一个计算两个数的平方和的程序
This is a program to compute the sum of the squares of two numbers.

我们将x和y的平方和定义为
And we'll define the sum of the squares of x and y to be

x的平方
the sum of the square of x

我这么写
-- I'm going to write it that way--

和y的平方的和
and the square of y,

x的平方是指x和x的乘积
where the square of x is the product of x and x.

现在 设想这么一件事
Now,supposing I were to say something to this,

比如 在这个程序这么定义好之后
like,to the system after having defined these things,

跟据定义的形式 求3和4的平方和
of the form,the sum of the squares of 3 and 4,

我希望得到25
I am hoping that I will get out a 25.

因为3的平方是9
Because the square of 3 is 9,

4的平方是16
and the square of 4 is 16,

它们的和是25
and 25 is the sum of those.

但这都是怎么回事呢
But how does that happen?

如果我们要理解程序的执行以及它的控制方法
If we're going to understand processes and how we control them,

那么我们就得把过程的机制
then we have to have a mapping from the mechanisms of this procedure

与过程执行时所产生的行为对应起来
into the way in which these processes behave.

我们将要得到的是一个正式的
What we're going to have is a formal,

或者说半正式的机械的模型
or semi-formal mechanical model,

你要理解计算机如何事实上 大体上实现这个机制
whereby you understand how a machine could,in fact,in principle,do this.

不论实际的计算机究竟是怎么实现的
Whether or not the actual machine really does

我此刻要告诉你们的都与实际的实现完全没有关系
what I'm about to tell you is completely irrelevant at this moment.

实际上 这是一个工程模型
In fact,this is an engineering model

就好像电阻
in the same way that,electrical resistor,

我们写出一个模型V=IR
we write down a model v equals i r,

这基本上是正确的
it's approximately true.

但不是完全正确的
It's not really true.

当电流通过电阻时 电阻会增加
If I put up current through the resistor it goes boom.

所以电压并不总与电流成线性关系
So the voltage is not always proportional to the current,

但是对于部分情况来说这个模型是适用的
but for some purposes the model is appropriate.

比如我们将要介绍的这个模型
In particular,the model we're going to describe right now,

我把这个模型称作代换模型
which I call the substitution model,

这是我们能接触到的最简单的模型
is the simplest model that we have

它可以帮助我们理解过程和程序执行的原理
for understanding how procedures work and how processes work.

以及过程如何使得程序执行
How procedures yield processes.

代换模型 对接下来几天
And that substitution model will be accurate

我们将要接触到的东西都是适用的
for most of the things we'll be dealing with in the next few days.

但最终 幻想总会破灭
But eventually,it will become impossible to sustain the illusion

如果你认为计算机实际就是这么工作的
that that's the way the machine works,

并且我们将要学习其它的更特殊的模型
and we'll go to other more specific and particular models

届时会讨论更多的细节
that will show more detail.

好了 接下来 我们来看下
OK,well,the first thing,of course,is we say,

黑板上的这些内容
what are the things we have here?

这里已经有了一些神秘的符号
We have some cryptic symbols.

这些神秘的符号是由几块组成的
And these cryptic symbols are made out of pieces.

还有几种表达式
There are kinds of expressions.

现在我们看一看都有哪些类型的表达式
So let's write down here the kinds of expressions there are.

有
And we have--

首先有数字
and so far I see things like numbers.

有像那样的符号
I see things like symbols like that.

我们之前见过Lambda表达式
We have seen things before like lambda expressions,

当然了没出现在黑板上
but they're not here.

先撇开不谈
I'm going to leave them out.

Lambda表达式
Lambda expressions,

稍后再讨论
we'll worry about them later.

还有定义
Things like definitions.

还有条件表达式
Things like conditionals.

最后还有组合式
And finally,things like combinations.

这些表达式
These kinds of expressions are

我们稍后再讨论 它们是特殊形式
-- I'll worry about later-- these are special forms.

它们有一些专门的规则
There are particular rules for each of these.

然而我要告诉你们的是 
I'm going to tell you,however,

处理通常情况的规则
the rules for doing a general case.

通常是怎样对一个组合式求值的
How does one evaluate a combination?

因为 实际上 在黑板的那边 
Because,in fact,over here,

全都是一些组合式以及一些符号和数字
all I really have are combinations and some symbols and numbers.

而简单的 比如一个数字
And the simple things like a number,well,

求值的结果就是这个数字所代表的数值
it will evaluate to itself.

在我将要介绍的模型中
In the model I will have for you,

符号的概念将不会出现
the symbols will disappear.

只有当你需要了解
They won't be there at the time when you need them,

当你需要真正理解它的时候才讨论
when you need to get at them.

所以我只需要向大家讲解
So the only thing I really have to explain to you is,

如何对组合式求值
how do we evaluate combinations?

好吧 继续
OK,let's see

先看下第一张幻灯片
So first I want to get the first slide.

这是对一个表达式求值的规则
Here is the rule for evaluating an application.

我们看到这条规则指出
What we have is a rule that says,

要对一个组合式求值
to evaluate a combination,

主要有三个部分
there are two parts,three parts to the rule.

组合式有若干个部分
The combination has several parts.

有运算符和运算对象
It has operators and it has operands.

运算符返回一个过程
The operator returns into a procedure.

也就是说如果我们对运算符求值
If we evaluate the operator,

结果是一个过程
we will get a procedure.

比如你们也看到了
And you saw,for example,

我向计算机输入一个“+”
how I'll type "+" at the machine

然后产生了一些复合的过程以及其它的一些东西
and out came compound procedure something or other.

而对运算对象求值就会得到参数
And the operands produce arguments.

一旦我们完成了对运算符的求值得到了一个过程
Once we've gotten the operator evaluated to get a procedure,

并且对运算对象也完成求值得到了参数
and the argument is evaluated to get argument

也就是运算对象作为参数的值
-- the operand's value to get arguments--

我们通过复制过程体
we apply the procedure to these arguments

来将其应用到这些参数上
by copying the body of the procedure,

用术语来说 过程体指的就是定义这个过程的表达式
which is the expression that the procedure is defined in terms of.

接下来要做的是
What is it supposed to do?

用求得的实际参数代换过程的形式参数
Substituting the argument supplied for the formal parameters of the procedure,

形式参数就是
the formal parameters being the names

过程定义中声明的变量名
defined by the declaration of the procedure.

然后我们对产生的新过程体求值
Then we evaluate the resulting new body,

这个新过程体是由将代换模型应用到之前的过程体而产生的
the body resulting from copying the old body with the substitutions made.

这个规则非常简单
It's a very simple rule,

并且我们会非常形式化地应用这个规则一段时间
and we're going to do it very formally for a little while.

因为接下来几节课
Because for the next few lectures,

我想让各位做的是
what I want you to do is to say,

如果有什么不能理解的
if I don't understand something,if I don't understand something,

就直接机械化地应用这个规则
be very mechanical and do this.

接下来
So let's see.

考虑这么一个求值过程
Let's consider a particular evaluation,

之前讨论过的
the one we were talking about before.

3和4的平方和
The sum of the squares of 3 and 4.

这是什么意思呢
What does that mean?

这是说
It says,take

其实 我已经知道求平方的过程是怎样的
-- well,I could find out what's on the square--

是某个过程
it's some procedure,

但我并不关心这个过程的具体表述
and I'm not going to worry about the representation,

并且我也不会在黑板上写出来
and I'm not going to write it on the blackboard for you.

还有3 代表某个数字
And I have that 3,represents some number,

但如果要我重复这个数字
but if I have to repeat that number,

我并不知道这个数字是什么
I can't tell you the number.

这个数字本身是抽象的
The number itself is some abstract thing.

只知道有个数词能代表它
There's a numeral which represents it,

我把这个它叫作3
which I'll call 3,

并且会在代换中用到它
and I'll use that in my substitution.

4也是个数字
And 4 is also a number.

我在这个过程体中用3代换x 用4代换y
I'm going to substitute 3 for x and 4 for y in the body of this procedure

看黑板这里
that you see over here.

这是过程体
Here's the body of the procedure.

它关联到这个组合式
It corresponds to this combination,

这个组合式是个求和过程
which is an addition.

而它就转化成这样一个过程
So what that reduces to,

我们把这个转化
as a reduction step,

称为归约
we call it,

这样就变成了求3和4的平方和
it's the sum of the square of 3 and the square of 4.

接下来我要做的是
Now,what's the next step I have to do here?

对它求值
I say,well,I have to evaluate this.

根据之前给出的求值规则
According to my rule,

就是各位刚刚在幻灯片上看到的
which you just saw on that overhead or slide,

我们要对运算对象求值
what we had was that we have to evaluate the operands

就是这些运算对象
-- and here are the operands,

这是第一个运算对象 这是第二个运算对象
here's one and here's the next operand--

我们还得对运算符求值
and how we have to evaluate procedure.

对它们求值的顺序无关紧要
The order doesn't matter.

然后我们要应用这个过程
And then we're going to apply the procedure,

即求和过程
which is plus,

然后很神奇的 不知怎么回事就能得到答案
and magically somehow that's going to produce the answer.

我不会深究求和过程的实现
I'm not to open up plus and look inside of it.

然而 为了对运算对象求值
However,in order to evaluate the operand,

我们采用任意一种顺序来求值
let's pick some arbitrary order and do them.

我会从右到左求值
I'm going to go from right to left.

好了 为了对这个运算对象求值
Well,in order to evaluate this operand,

我得用同样的规则对这运算对象的每个部分求值
I have to evaluate the parts of it by the same rule.

首先需要弄清楚求平方是什么
And the parts are I have to find out what square is--

是某个过程
it's some procedure,

有个形式参数x
which has a formal parameter x.

然后还有个运算对象是4
And also,I have an operand which is 4,

用4代换求平方过程的形式参数x
which I have to substitute for x in the body of square.

接下来基本上可以这么说
So the next step is basically to say that

这就变成了求3的平方以及4与4乘积的和
this is the sum of the square of 3 and the product of 4 and 4.

当然了 还可以接着深入分析乘法
Of course,I could open up asterisk if I liked

这个求乘积的操作
-- the multiplication operation--

但现在这个不重要
but I'm not going to do that.

先把乘法过程看作是基本过程
I'm going to consider that primitive.

其实 如果你深究计算机的抽象层次
And,of course,at any level of detail,if you look inside this machine,

你会发现无论在具体哪一个层次
you're going to find that

在其下都还有若干个你不清楚的抽象层次
there's multiple levels below that that you don't know about.

但我们必须明白要学会忽略细节
But one of the things we have to learn how to do is ignore details.

理解复杂事物的关键是
The key to understanding complicated things

避免不必要的观察 计算和思考
is to know what not to look at and what not compute and what not to think.

所以对这个乘法过程的细节我们不深入研究
So we're going to stop this one here and say,

就直接看作两个数的乘积
oh,yes,this is the product of two things.

现在把两个4乘起来
We're going to do it now.

于是就有3的平方与16的和
So this is nothing more than the sum of the square of 3 and 16.

还有一个求平方的表达式要求值
And now I have another thing I have to evaluate,

注意这是3的平方
but that square of 3,

这与之前求4的平方是一个过程
well,it's the same thing.

于是整个表达式就变成了求3和3乘积与16的和
That's the sum of the product of 3 and 3 and 16,

也就是求9和16的和 结果是25
which is the sum of 9 and 16,which is 25.

大家现在看到了应用代换模型的基本方法
So now you see the basic method of doing substitutions.

但我提醒大家
And I warn you that

代换模型并不能准确描述计算机实际的运行方式
this is not a perfect description of what the computer does.

但这个模型对于接下来几节课我们要讨论的问题
But it's a good enough description

已经能描述得足够清楚
for the problems that we're going to have in the next few lectures

你可以先认为这是正确的
that you should think about this religiously.

认为计算机就是这么运行的
And this is how the machine works for now.

之后我们的讨论会变得更加严谨
Later we'll get more detailed.

好了 现在可以看到
Now,of course,

我在这个例子中采用了从右到左的求值顺序
I made a specific choice of the order of evaluation here.

当然还有别的选择
There are other possibilities.

如果我们回过头来再看幻灯片
If we go back to the telestrator here

上所写的代换模型应用规则
and look at the substitution rule,

可以发现刚才我对运算符求值得到了一个过程
we see that I evaluated the operator to get the procedures,

对运算对象求值得到了过程的实际参数
and I evaluated the operands to get the arguments first,

然后才将参数应用到过程
before I do the application.

这样做是完全可行的
It's entirely possible,

还有别的求值顺序比如正则序求值
and there are alternate rules called normal order evaluation

应用正则序你可以先用表达式去代换
whereby you can do the substitution of the expressions

将其作为过程的形式参数的运算对象 然后再求值
which are the operands for the formal parameters inside the body first.

这么做会得到同样的答案
And you'll get also the same answer.

但是现在 考虑到实际情况
But right now,for concreteness,

因为计算机实际是这么运行的
and because this is the way our machine really does it,

我还是会给出在黑板上演示的方式
I'm going to give you this rule,

这种方式给出了明确的顺序
which has a particular order.

当然了这些顺序一定程度上也是灵活可变的
But that order is to some extent arbitrary,too.

长远来看
In the long run,

你采用哪种求值顺序来理解都有各自的理由
there are some reasons why you might pick one order or another,

以后我们会继续讨论这个问题
and we'll get to that later in the subject.

好了 为了让大家理解这都是怎么回事
OK,well now the only other thing I have to tell you

还需要给大家介绍一个东西
about just to understand what's going on is

来看幻灯片上对条件表达式的解释
let's look at the rule for conditionals.

条件表达式很简单
Conditionals are very simple,

我给大家详细解释一下
and I'd like to examine this.

条件表达式就是if表达式
A conditional is something that is if

当然还有cond表达式
-- there's also cond of course--

我会把条件表达式各部分的名称都写下来
but I'm going to give names to the parts of the expression.

首先有一个predicate表达式
There's a predicate,

这是个求值结果为真或假的表达式
which is a thing that is either true or false.

然后有一个consequent表达式
And there's a consequent,

当predicate表达式的结果为真就对这个表达式求值
which is the thing you do if the predicate is true.

还有个alternative表达式
And there's an alternative,

当predicate表达式结果为假就对这个表达式求值
which is the thing you do if the predicate is false.

顺便提一句
It's important,by the way,

知道事物各部分的名称
to get names for,to get names for,

或者表达式各部分的名称
the parts of things,

很重要
or the parts of expressions.

每个“魔法师”都会告诉你
One of the things that every sorcerer will tell you is

如果你能叫出一个“精灵”的名字
if you have the name of a spirit,

你就有控制它的能力
you have power over it.

所以你得掌握这些名称
So you have to learn these names

以便之后的讨论
so that we can discuss these things.

现在我们有了一个predicate表达式
So here we have a predicate,

一个consequent表达式
a consequent,

还有个alternative表达式
and an alternative.

用这些名称 我们发现对于一个if表达式
And,using such words,we see that an if expression,

关键的问题是对predicate表达式的求值
the problems you evaluate to the predicate expression,

如果结果为真
if that yields true,

就对consequent表达式求值
then you then go on to evaluate the consequent.

否则
Otherwise,

就对alternative表达式求值
you evaluate the alternative expression.

我想通过一个具体的程序
So I'd like to illustrate that

来进一步说明这个问题
now in the context of a particular little program.

就写一个我们会经常遇到的程序吧
Going to write down a program which we're going to see many times.

这是由皮亚诺算术定义的求x和y之和的过程
This is the sum of x and y done by what's called Peano arithmetic,

其实就是加1和减1
which is all we're doing is incrementing and decrementing.

来看看这个
And we're going to see this for a little bit.

这是个非常重要的程序
It's a very important program.

如果x等于0
If x equals 0,

那么结果就是y
then the result is y.

否则
Otherwise,

结果就是x减1与y加1的和
this is the sum of the decrement of x and the increment of y.

以后我们会继续研究这个加法过程
We're going to look at this a lot more in the future.

现在看前面
Let's look at the overhead.

现在有了这么个过程
So here we have this procedure,

我们看看怎么应用代换模型
and we're going to look at how we do the substitutions,

以及代换的顺序
the sequence of substitutions.

我现在想要求3和4的和
Well,I'm going to try and add together 3 and 4.

根据我演示给大家步骤
Well,using the first rule that I showed you,

第一步 在过程体中
we substitute 3 for x and 4 four y

用3代换x 用4代换y
in the body of this procedure.

过程体
The body of the procedure is the thing

由if表达式开始 在这儿结束
that begins with if and finishes over here.

于是我们就有了
So what we get is,

如果3是0
of course,if 3 is 0,

那么结果就是4
then the result is 4.

否则
Otherwise,

结果就是3减1
it's the sum of the decrement of 3

与4加1的和
and the increment of 4.

但这部份我不会去管它
But I'm not going to worry about these yet

因为3不等于0
because 3 is not 0.

于是答案不是4
So the answer is not 4.

因此
Therefore,

于是整个if表达式就可以归约成
this if reduces to

对这个表达式的求值
an evaluation of the expression,

求3减1
the sum to the decrement of 3

与4加1的和
and the increment of 4.

继续求值
Continuing with my evaluation,

先认为加1的过程是基本过程
the increment I presume to be primitive,

然后就有了5
and so I get a 5 there.

同样把减1也认为是基本过程
OK,and then the decrement is also primitive,

然后就有了2
and I get a 2.

于是我把问题化简了
And so I change the problem into a simpler problem.

不是3加4的问题了
Instead of adding 3 to 4,

而是2加5的问题了
I'm adding 2 to 5.

为什么这样就变简单了呢
The reason why this is a simpler problem

因为我在减小x
is because I'm counting down on x,

最终x会变为0
and eventually,then,x will be 0.

这就是代换模型了
So,so much for the substitution rule.

通常来讲
In general,

在对if表达式使用代换模型的时候
I'm not going to write down intermediate steps

我不会写下所有中间步骤
when using substitutions having to do with ifs,

因为这么做只能把事情复杂化
because they just expand things to become complicated.

我们要做的是
What we will be doing is saying,

把求3和4的和
oh,yes,the sum of 3 and 4

归约到求2和5的和
results in the sum of 2 and 5

在那之后
and reduces to the sum of 2 and 5.

归约到求1和6的和
which,in fact,reduces to the sum of 1 and 6,

最后归约到求0和7的和
which reduces to the sum of 0 and 7

看这儿
over here,

最后归约到7
which reduces to a 7.

这就是我们想要的结果
That's what we're going to be seeing.

现在 各位对第一部分的内容有疑问么
Are there any questions for the first segment yet?

请
Yes?

学生 你用了1+过程和-1+过程
STUDENT: You're using 1 plus and minus 1 plus

它们都是基本过程么
Are those primitive operations?

教授 是的
PROFESSOR: Yes

你们在这门课中要明白的是
One of the things you're going to be seeing in this subject

我绝对不会考虑
is I'm going to,without thinking about it,

给大家介绍越来越多的基本过程
introduce more and more primitive operations

可以假定
There's presumably some large library

有一些庞大的基本过程的程序库
of primitive operations somewhere.

不用过分追究这些基本过程
But it doesn't matter that they're primitive--

可能有一些手册有这些基本过程的索引便于我们查找
there may be some manual that lists them all.

如果我向你解释基本过程的作用 你应该说
If I tell you what they do,you should say,

啊 是这样 我明白它们的作用了
oh,yes,I know what they do.

比如 这个减1的过程
So one of them is the decrementor

-1+
-- minus 1 plus--

另一个加1的过程
and the other operation is increment,

1+
which is 1 plus.

谢谢大家
Thank you.

第一部分结束
That's the end of the first segment.

[音乐]
[MUSIC PLAYING BY J.S. BACH]

教授 现在我们有了一个合理的 机械的方式
PROFESSOR: Now that we have a reasonably mechanical way

去理解一个由过程
of understanding how a program made out of procedures

和表达式组成的程序是如何演化成计算过程的
and expressions evolves a process,

我想要大家培养出一些直觉
I'd like to develop some intuition

有关程序如何演化成计算过程的直觉
about how particular programs evolve particular processes,

有关程序到底是什么“形状”的直觉
what the shapes of programs have to be

这样才能产生特定“形状”的计算过程
in order to get particular shaped processes.

这让我想到了 画面预览
This is a question about,really,pre-visualizing.

这是个摄影专业术语
That's a word from photography.

我曾经对摄影十分着迷
I used to be interested in photography a lot,

你会发现
and one of the things you discover

初学摄影的时候
when you start trying to learn about photography

你很想成为一名有创意的摄影师
is that you say,gee,I'd like to be a creative photographer.

我知道怎么做 按快门
Now,I know the rules,I push buttons,

调整光圈什么的
and I adjust the aperture and things like that.

但要想有创意
But the key to being a creative person,partly,

一定程度上靠的是能在一定层次上进行分析
is to be able to do analysis at some level.

比如 在按下快门前
To say,how do I know what it is

我怎么知道交卷上最终是怎样的画面呢
that I'm going to get on the film before I push the button.

我能在心中
Can I imagine in my mind

非常准确清晰地刻画出拍好的照片么
the resulting image very precisely and clearly

那精心地取景
as a consequence of the particular framing,

仔细地调整光圈
of the aperture I choose,

仔细地对焦
of the focus,

而拍出来的照片
and things like that?

一定程度来说 这就是摄影的艺术
That's part of the art of doing this sort of thing.

而要掌握摄影的艺术牵涉到许多方面
And learning a lot of that

比如曝光试验片
involves things like test strips.

比如拍摄非常几张简单的画面
You take very simple images

每张都有不同的影像密度
that have varying degrees of density in them,for example,

然后把它们打印在一张纸上
and examine what those look like on a piece of paper

观察它们都有什么不同
when you print them out.

你能发现实际可见的对比度
You find out what is the range of contrasts

都是怎样的范围内
that you can actually see.

还能发现 从实际角度来讲
And what,in a real scene,

都是哪些因素与同一张照片中不同层次
would correspond to the various levels

不同区块的影像密度的产生有关
and zones that you have of density in an image.

今天这节课我就想让大家看一些特别的“曝光试验片”
Well,today I want to look at some very particular test strips,

下面通过幻灯片来看第一张
and I suppose one of them I see here is up on the telestrator,

请看
so we should switch to that.

有两个非常非常重要的程序
There's a very important,very important pair of programs

用来理解在程序执行时
for understanding what's going on in the evolution of a process

计算过程中的求值都是怎样的
by the execution of a program.

大家看到的是两个几乎相同的过程
What we have here are two procedures that are almost identical.

基本上没有区别
Almost no difference between them at all.

只有几个字符不同
It's a few characters that distinguish them.

这两个过程表示的是两种不同的求两数之和的方法
These are two ways of adding numbers together.

第一个
The first one,

看这里
which you see here,

是求两数之和
the first one is the sum of two numbers

和我们上节课讲到的一样
-- just what we did before--

如果第一个参数是0
is if the first one is 0,

第二个参数就是答案
it's the answer of the second one.

否则
Otherwise,

就是第一个参数减1
it's the sum of the decrement of the first

和第二个参数加1的和
and the increment of the second.

你可以这么考虑 有两堆弹珠
And you may think of that as having two piles.

把这两堆加在一块儿形成新的一堆的办法就是
And the way I'm adding these numbers together to make a third pile is by

把弹珠从一堆挪到另一堆去
moving marbles from one to the other.

仅此而已
Nothing more than that.

最终 有一堆会被搬空
And eventually,when I run out of one

另一堆就是加和的结果了
then the other is the sum.

然而 第二个过程不是这样做的
However,the second procedure here doesn't do it that way.

它是这样做的 如果第一个参数是0
It says if the first number is 0,

答案就是第二个
then the answer is the second.

否则 
Otherwise,

答案就是 第一个参数减1
it's the increment of the sum

和第二个参数的和
of the decrement of the first number

然后再加1
and the second.

这种方式就是
So what this says is

把第一个参数减1和第二个数加起来
add together the decrement of the first number and the second

毫无疑问 简化了问题
-- a simpler problem,no doubt--

然后把这个和再加1
and then change that result to increment it.

这就意味着如果你用两堆弹珠的方式来思考
And so this means that if you think about this in terms of piles,

就是说 我左手右手各有一堆弹珠
it means I'm holding in my hand the things to be added later.

然后我要把它们加在一起
And then I'm going to add them in.

然后我慢慢地把其中一堆搬空
As I slowly decrease one pile to 0,

然后把这些拿出来的弹珠
I've got what's left here,

再放回另一堆弹珠中
and then I'm going to add them back.

两种不同的加法
Two different ways of adding.

关于这两个程序 有趣的是
The nice thing about these two programs

它们几乎一样
is that they're almost identical.

唯一的区别是把加1这个过程放哪儿
The only thing is where I put the increment.

把几个字符挪挪地方
A couple of characters moved around.

现在我想弄明白
Now I want to understand the kind of behavior

我们会从这两个程序中看到怎样的行为
we're going to get from each of these programs.

加深大家对这个问题的印象
Just to get them firmly in your mind

我通常不想这么谨慎
-- I usually don't want to be this careful--

但是还是要加深大家的印象
but just to get them firmly in your mind,

我在黑板上把程序再写一遍
I'm going to write the programs again on the blackboard,

然后我会演化出一个计算过程
and then I'm going to evolve a process.

大家都注意观察 看看是怎么回事
And you're going to see what happens.

看看过程演化是怎样的“形状”
We're going to look at the shape of the process

这是程序导致的一个结果
as a consequence of the program.

我们从这个程序开始
So the program we started with is this:

求x与y的和
the sum of x and y says

如果x等于0
if x is 0,

那么答案就是y
then the result is y.

否则 
Otherwise,

答案就是x减1和y加1的和
it's the sum of the decrement of x and the increment of y.

现在 假设我们要求3与4的和
Now,supposing we wish to do this addition of 3 and 4,

3与4的和
the sum of 3 and 4,

接下来呢
well,what is that?

我要代换这两个参数
It says that I have to substitute the arguments

代换过程定义中的形式参数
for the formal parameters in the body.

我在脑海中想像这个过程
I'm doing that in my mind.

然后说 啊 这样
And I say,oh,yes,

3代换了x
3 is substituted for x,

但3不是0
but 3 is not 0,

于是直接进入这一部分
so I'm going to go directly to this part

然后只用关心这一部分就行
and write down the simplified consequent here.

因为我只关心加法过程的行为
Because I'm really interested in the behavior of addition.

好了 接下来
Well,what is that?

就变成了求2和5的过程
That therefore turns into the sum of 2 and 5.

换句话说
In other words,

我把这个问题归约成这个问题
I've reduced this problem to this problem.

然后我又把这个问题化归约成求1和6的和
Then I reduce this problem to the sum of 1 and 6,

再接着归约
and then,going around again once,

就有了0和7的和
I get the sum of 0 and 7.

于是x就等于0了
And that's one where x equals 0

答案是y
so the result is y,

也就是7
and so I write down here a 7.

这就是这个程序把3和4相加
So this is the behavior of the process evolved

而演化出的计算过程的行为
by trying to add together 3 and 4 with this program.

另一个程序
For the other program,

写在这边
which is over here,

如此定义x与y的和
I will define the sum of x and y.

怎么定义的呢
And what is it?

如果x是0
If x is 0,

答案就是y
then the result is y

这和上一个程序一样
-- almost the same--

否则就是x减1与y的和
otherwise the increment of the sum

再加上1
of the decrement of x and y.

写错了 黑板不能自动匹配括号
No.I don't have my balancer in front of me.

好了 接下来
OK,well,let's do it now.

求3与4的和
The sum of 3 and 4.

其实这样更有趣 来看
Well,this is actually a little more interesting.

3当然不等于0 和之前一样
Of course,3 is not 0 as before,

于是答案就是 x减1与y的和再加1
so that results in the increment of the sum of the decrement of x,

也就是2与4的和
which is 2 and 4,

接着变成 1与
which is the increment of the sum of 1 and--

噢 弄错了 加1再加1
whoops: the increment of the increment.

现在要做的是计算这一部分
What I have to do now is compute what this means.

我要对这一部分求值
I have to evaluate this.

也就是
Or what that is,

用2和4代换x和y的结果
the result of substituting 2 and 4 for x and y here.

变成了1与4的和再加1
But that is the increment of the sum of 1 and 4,

现在我得展开这部份
which is-- well,now I have to expand this.

啊 然后就变成了0与4的和加1加1
Ah,but that's the increment of the increment

再加1
of the increment of the sum of 0 and 4.

现在来看看都能做些什么
Ah,but now I'm beginning to find things I can do.

加1加1再加1
The increment of the increment of the increment of--

0和4的和是4
well,the sum of 0 and 4 is 4.

4加1是5
The increment of 4 is 5.

这就变成了5加1再加1
So this is the increment of the increment of 5,

也就是6再加1
which is the increment of 6,

最后答案就是7
which is 7.

两种不同的求和方法
Two different ways of computing sums.

现在来看看
Now,let's see.

这两种计算过程有不同的“形状”
These processes have very different shapes.

我想让各位去感受这些“形状”
I want you to feel these shapes.

这种感觉很关键
It's the feeling for the shapes that matters.

从这里我们能发现什么
What's some things we can see about this?

不知怎么回事 这个有点“直”
Well somehow this is sort of straight.

就这样一路直着下来
It goes this way-- straight.

右边界并没有特别的变化
This right edge doesn't vary particularly in size.

而这边这个呢
Whereas this one,

右边界先变大又变小
I see that this thing gets bigger and then it gets smaller.

我还不知道这意味着什么
So I don't know what that means yet,

我们看到的是什么
but what are we seeing?

是不知怎么回事
We're seeing here that somehow

这些加1的过程先展开后收缩
these increments are expanding out and then contracting back.

我构造出一个推迟进行的操作的链条
I'm building up a bunch of them to do later.

我不能马上求值
I can't do them now.

有的过程需要推迟
There's things to be deferred.

好了 我们继续
Well,let's see,

我可以想象一个抽象的计算机
I can imagine an abstract machine.

也许能制造一些实际的计算机
There's some physical machine,

能像我这样求值
perhaps,that could be built to do it,

能像我演示给大家的一样执行程序
which,in fact,executes these programs exactly as I tell you,

像这样代换字符串
substituting character strings in like this.

这样的计算机
Such a machine,

计算中的步骤与计算所花费的时间近似相等
the number of such steps is an approximation of the amount of time it takes.

用纵轴表示时间
So this way is time.

横轴的宽度表示
And the width of the thing is

进行计算需要保存的信息量
how much I have to remember in order to continue the process.

也就是表示进行计算所需要的空间
And this much is space.

我们看到的是一个计算过程
And what we see here is a process

其时间消耗正比于参数x
that takes a time which is proportional to the argument x.

因为如果我让x增大一倍
Because if I made x larger by 1,

就得把这个表示时间的纵轴再加长一倍
then I'd had an extra line.

于是这就是个计算过程 它的空间 抱歉 时间
So this is a process which is space-- sorry-- time.

这个计算过程消耗的时间为O(x)
The time of this process is what we say order of x.

也就是正比于x
That means it is proportional to x by some constant of proportionality

不要刻意追究这个常比例系数是多少
and I'm not particularly interested in what the constant is.

我们还会发现
The other thing we see here is that

这个计算过程消耗的空间是固定不变的
the amount of space this takes up is constant.

即与1成正比
it's proportional to 1.

于是这个计算过程的空间复杂度就是O(1)的
So the space complexity of this is order of 1.

对这样的计算过程我们有个名字
We have a name for such a process.

叫迭代计算过程
Such a process is called an iteration.

关键的地方
And what matters here

不是什么我设计的
is not that some particular machine I designed here

之前提到的
and talked to you about

代换字符计算机
and called a substitution machine

或者 代换模型
or whatever-- substitution model--

怎么设法在常数空间复杂度内完成计算过程
managed to do this in constant space.

关键的地方是这给出了一个界限
What really matters is this tells us a bound.

任何计算机都应该在常数空间复杂度内完成计算过程
Any machine could do this in constant space.

这个过程代表的算法
This algorithm represented by this procedure

在常数空间复杂度内是可执行的
is executable in constant space.

当然了这种说法忽略了一些细节
Now,of course,the model is ignoring some things,

却量化了一些东西
standard sorts of things.

忽略了比如数值越大越消耗空间等等
Like numbers that are bigger take up more space and so on.

但那确实是抽象过程中我要忽略的一个层次
But that's a level of abstraction at which I'm cutting off.

如何表示数值
How do you represent numbers?

我假定所有的数值都占用同样大小的存储空间
I'm considering every number to be the same size.

事实上数值的增大和它们占用的存储空间的增加都非常缓慢
And numbers grow slowly for the amount of space they take up and their size.

而这个算法的复杂度就不同了
Now,this algorithm is different in its complexity.

我们看到
As we can see here,

这个算法时间复杂度
this algorithm has a time complexity

也是正比于输入参数x的
which is also proportional to the input argument x.

因为如果我把这个3再加1
That's because if I were to add 1 to 3,

如果我把问题规模扩大
if I made a larger problem

扩大了1
which is larger by 1 here,

那我就要在上面再加一行
then I'd add a line at the top

在底下再加一行
and I'd add a line at the bottom.

而且事实上这是个常量
And the fact that it's a constant amount,

就像这个计算过程的步骤数是那个的两倍
like this is twice as many lines as that

我不会关心这个层次的细节 也不会关心那个常量
is not interesting at the level of detail I'm talking about right now.

所以这个计算过程的时间复杂度也是O(x)
So this is a time complexity order of the input argument x.

而空间复杂度呢
And space complexity,

这个比较有趣
well,this is more interesting.

有一些东西是固定不变的
I happen to have some overhead,

比如这些
which you see over here,

是近似保持不变的
which is constant approximately.

是常量的
Constant overhead.

但也有一些增加和减少
But then I have something which increases and decreases

是正比于参数x的
and is proportional to the input argument x.

输入参数x是3
The input argument x is 3.

也就是这里为何有3个推迟操作的加1过程
That's why there are three deferred increments sitting around here.

发现了么
See?

于是这个计算过程的空间复杂度也是O(x)的
So the space complexity here is also order x.

这种计算过程
And this kind of process,

给它取个名字
named for the kind of process,

是递归计算过程
this is a recursion.

更准确地来说
A linear recursion

是线性递归计算过程
I will call it.

因为它的时间和空间复杂度
because of the fact that it's proportional

都是正比于输入参数的
to the input argument in both time and space.

那么这个就可以称为一个线性迭代过程
This could have been a linear iteration.

那么 这两种计算过程的本质是什么
So then what's the essence of this matter?

不太容易看出来
This matter isn't so obvious.

可能还有别的模型
Maybe there are other models

可以用来描述
by which we can describe the differences

迭代和递归计算过程的不同之处
between iterative and recursive processes.

但这就有些困难了
Because this is hard now.

记住
Remember,

这两种计算过程都是递归定义的
we have-- those are both recursive definitions.

我们看到的是
What we're seeing there

两种过程在定义上都使用了递归
are both recursive definitions,

也就是两个过程的定义中都引用了该过程本身
definitions that refer to the thing being defined in the definition.

但是它们却产生了不同“形状”的计算过程
But they lead to different shape processes.

过程定义是递归的
There's nothing special about the fact

而产生的计算过程也是递归的
that the definition is recursive

这没什么特别的
that leads to a recursive process.

好了 来看看另一种有趣的解释
OK.Let's think of another model.

我会和大家谈谈 官僚主义
I'm going to talk to you about bureaucracy.

官僚主义 挺有趣儿的
Bureaucracy is sort of interesting.

在幻灯片上我们看到有关迭代计算过程的解释
Here we see on a slide an iteration.

迭代是一种挺好玩儿的计算过程
An iteration is sort of a fun kind of process.

想象一下有个叫GJS的家伙
Imagine that there's a fellow called GJS

也就是我
-- that stands for me--

遇到了一个问题
and he's got a problem:

他想求3与4的和
he wants to add together 3 and 4.

这个家伙想把3和4加一块儿
This fella here wants to add together 3 and 4.

他打算这么办
Well,the way he's going to do it

他挺懒的
-- he's lazy--

他想找别人帮忙
is he's going to find somebody else to help him do it.

他是这样找人帮忙的
The way he finds someone else to--

他找了个人帮忙 对他说
he finds someone else to help him do it and says,

算出3和4的和
well,give me the answer to 3 and 4

然后把答案返回给我
and return the result to me.

他写了一张小纸递给这个人条然后说
He makes a little piece of paper and says,

给 这是一张纸条
here,here's a piece of paper--

你去解决这个问题
you go ahead and solve this problem

然后把答案返回给我
and give the result back to me.

而这个找来帮忙的家伙呢
And this guy,

也很懒
of course,is lazy,too.

他可不想再看见这张小纸条了
He doesn't want to see this piece of paper again.

他说 啊 好吧
He says,oh,yes,

然后出了个新问题
produce a new problem

是求2和5的和
which is the sum of 2 ad 5

并把答案返回给GJS
and return the result back to GJS.

我不想再看见这张纸条了
I don't want to see it again.

这个家伙不想再看见这张纸条了
This guy does not want to see this piece of paper.

于是就出了一个新问题
And then this fellow makes a new problem,

也就是求1与6的和的问题
which is the addition of the sum of 1 and 6,

他又把纸条传给了这个家伙 并说到
and he give it to this fella and says,

算出答案然后把答案告诉GJS
produce that answer and returned it to GJS.

那个家伙又接着出了个新问题
And that produces a problem,

求0与7的和
which is to add together 0 and 7

然后把答案返回给GJS
and give the result to GJS.

最后这个家伙直接说
This fella finally just says,

啊 好吧 答案是7
oh,yeah,the answer is 7,

然后把答案返回给了GJS
and sends it back to GJS.

迭代计算过程就是这样的
That's what an iteration is.

相对而言
By contrast,

递归计算过程就有些不同了
a recursion is a slightly different kind of process.

它更加“官僚主义”
This one involves more bureaucracy.

它使得更多的人变得忙碌
It keeps more people busy.

更多的人被雇佣
It keeps more people employed.

当然了也许能增加就业使这种方法更好
Perhaps it's better for that reason.

请看幻灯片
But here it is:

我想要知道3与4的和
I want the answer to the problem 3 and 4.

于是写了张纸条 说到
So I make a piece of paper that says,

把答案返回给我
give the result back to me.

然后我把纸条给了这个家伙
Give it to this fella.

这个家伙说
This fellow says,

好吧我会记得
oh,yes,I will remember

一会儿要加1
that I have to add later,

而我又得知道2加4的和是多少
and I want to get the answer the problem 2 plus 4,

于是把这个问题给了Harry
give that one to Harry,

然后把结果返回给我 Joe
and have the results sent back to me-- I'm Joe.

一旦Harry返回了答案
When the answer comes back from Harry,

也就是6
which is a 6,

我就会把答案加1
I will then do the increment

然后把结果返回给GJS
and give that 7 back to GJS.

大家可以发现 在递归计算过程中 需要保留的纸条
So there are more pieces of paper outstanding

比迭代计算过程的多
in the recursive process than the iteration.

还有一种方法可以用来理解迭代计算过程
There's another way to think about what an iteration is

以及迭代计算过程和递归计算过程的不同之处
and the difference between an iteration and a recursion.

问题的关键在于
You see,the question is,

有多少东西是不可见的
how much stuff is under the table?

如果我要停止
If I were to stop--

假设我现在要关闭计算机
supposing I were to kill this computer right now,OK?

此时我丢失了事务的状态
And at this point I lose the state of affairs,

但我能接着进行运算
well,I could continue the computation from this point

因为继续运算所需要的所有信息都在参数变量中
cause everything I need to continue the computation is in the variables

即程序员编写过程时定义的变量
that were defined in the procedure that the programmer wrote for me.

迭代计算过程能用明确的变量保存计算过程中的状态
An iteration is a system that has all of its state in explicit variables.

这一点递归计算过程就不同
Whereas the recursion is not quite the same.

如果我弄丢了这堆垃圾
If I were to lose this pile of junk over here

那就只剩下求1与4的和了
and all I was left with was the sum of 1 and 4,

这些信息不足以继续
that's not enough information to continue the process

从初始的求3与4的和的问题
of computing out the 7 from the original problem

求出7的计算过程
of adding together 3 of 4.

除了保存在过程中的
Besides the information that's in the variables

形式参数变量中的信息
of the formal parameters of the program,

计算机还保存了一些不可见的信息
there is also information under the table belonging to the computer,

也就是都有哪些过程被推迟计算了
which is what things have been deferred for later.

当然了
And,of course,

有个实际的比喻
there's a physical analogy to this,

比如微分方程
which is in differential equations,for example,

当我们说到画一个圆的时候
when we talk about something like drawing a circle.

试图画一个圆
Try to draw a circle,

你从一个微分方程中解得它
you make that out of a differential equation

即状态的改变是我当前状态的一个函数
which says the change in my state as a function of my current state.

于是如果我当前的状态由y和x的特定值表征
So if my current state corresponds to particular values of y and x

那么我就能求出一个导数 表征状态如何改变
then I can compute from them a derivative which says how the state must change.

并且 实际上
And,in fact

大家可以看出这是一个圆
you can see this was a circle

因为如果碰巧
because if I happen to be,

在这个点
say,at this place over here,

比如在(1,0)这个点
at (1,0),for example

在这个图像上
on this graph,

那就是说y的导数是x
then it means that the derivative of y is x,

我们也看见了
which we see over here.

是1
That's 1,

接着向上走
so I'm going up.

x的导数是-y
And the derivative of x is minus y,

意味着要走回来
which means I'm going backwards.

实际在这点什么也没做
I'm actually doing nothing at this point,

然后开始走回来使y增加
then I start going backwards as y increases.

这样就画出了一个圆
So that's how you make a circle.

有趣的是
And the interesting thing to see is

这儿有一个程序能用这种方法画出一个圆
a little program that will draw a circle by this method.

实际上 不会画一出一个圆
Actually,this won't draw a circle

因为这个程序实际是一个积分器
because it's a forward or integrator

并且最终会陷入死循环
and will eventually spiral out and all that.

但陷入死循环前还是能画出一个圆的
But it'll draw a circle for a while before it starts spiraling.

然而 我们在这儿看到的是两个表征状态的变量
However,what we see here is two state variables,

x和y
x and y.

还有个迭代计算过程表明
And there's an iteration that says,

要画一个圆
in order to circle,

已经有了x和y
given an x and y,

我想要的是x和y的下一组取值以用来画圆
what I want is to circle with the next values of x and y

也就是x原有的值减去y和dt的乘积
being the old value of x decrement by y times dt

dt就是时间变化
where dt is the time step

还有y原有的值加上x的dt的乘积
and the old value of y being implemented by x times dt,

然后就得到了x和y的新的取值
giving me the new values of x and y.

好了 现在大家对于两种不同的计算过程的感觉
So now you have a feeling

应该都有了一个直观的感觉
for at least two different kinds of processes

而这两种计算过程却可能是由几乎相同的程序产生的
that can be evolved by almost the same program.

像这样做了一点扰动分析之后
And with a little bit of perturbation analysis like this,

如何小小地修改一下程序观察计算过程是怎样变化的
how you change a program a little bit and see how the process changes,

这样才能有直观的感受
that's how we get some intuition.

之后我们就会用到这样的直观感受
Pretty soon we're going to use that intuition

来构建大型的 恼人的 复杂的系统
to build big,hairy,complicated systems.

谢谢
Thank you.

[音乐]
[MUSIC PLAYING BY J.S.BACH]

教授 好了
PROFESSOR: Well,

各位之前已经见过一个对若干程序的简单的扰动分析
you've just seen a simple perturbational analysis of some programs.

我拿一个程序与另一个很相似的程序进行比较
I took a program that was very similar to another program

观察他们如何演化出计算过程
and looked at them both and saw how they evolved processes.

我想再给大家介绍点不同的东西
I want to show you some variety

向大家展示程序可能具有的别的一些计算过程和“形状”
by showing you some other processes and shapes they may have.

同样地 我们将要举例非常简单的程序
Again,we're going to take very simple things,

简单到你都不想写的程序
programs that you wouldn't want to ever write.

那可能是最糟糕的方式
They would be probably the worst way

去进行一些计算过程
of computing some of the things we're going to compute.

但我还是要展示给大家
But I'm just going to show you these things

是想要展现
for the purpose of feeling out

一个程序如何
how a program represents itself

在计算过程的求值中表现出自己的相应规则
as the rule for the evolution of a process.

考虑一个有趣的问题
So let's consider a fun thing,

斐波那契数列
the Fibonacci numbers.

大家可能已经知道斐波那契数列了
You probably know about the Fibonacci numbers.

我记不清是谁了
Somebody,I can't remember who,

有一个人对兔群的繁殖问题很感兴趣
was interested in the growth of piles of rabbits.

不管怎样
And for some reason or other,

我们都知道兔群趋向于指数式增长
the piles of rabbits tend to grow exponentially,as we know.

对于这个过程我们有个不错的模型来解释
And we have a nice model for this process,

由两个数开始算起
is that we start with two numbers,

0和1
0 and 1.

之后的每个数都是前两个数之和
And then every number after this is the sum of the two previous.

于是接下来就是1
So we have here a 1.

然后这两数之和就是2
Then the sum of these two is 2.

那两数之和是3
The sum of those two is 3.

那两数之和是5
The sum of those two is 5.

那两数之和是8
The sum of those two is 8.

那两数之和是13
The sum of those two is 13.

这是21
This is 21.

34 55
34.55.

等等
Et cetera.

如果给这些数字标上序号
If we start numbering these numbers,

第0个
say this is the zeroth one,

第1个
the first one,

第2个
the second one,

第3个
the third one,

第4个
the fourth one,

等等
et cetera.

这是第10个
This is the 10th one,

第10个斐波那契数
the 10th Fibonacci number.

这些数字增长很快
These numbers grow very fast

就像兔子们一样
Just like rabbits.

为什么兔群是这样增长的呢
Why rabbits grow this way

我不会瞎猜
I'm not going to hazard a guess.

接下来我要为大家展示
Now,I'm going to try to write for you

写一个极简单的程序来计算斐波那契数
the very simplest program that computes Fibonacci numbers.

我想要的是一个程序
What I want is a program that,

输入一个n
given an n,

就能输出第n个斐波那契数
will produce for me Fibonacci event.

我就写在这儿了
OK?I'll write it right here.

想要得到第n个斐波那契数
I want the Fibonacci of n,

也就是说 这是那个n
which means the-- this is the n,

这是第n个斐波那契数
and this is Fibonacci of n.

我这么写
And here's the story.

如果n小于2
If n is less than 2,

那么答案就是n
then the result is n.

因为此时斐波那契数和序号相等
Because that's what these are.

这是最开始的规定
That's how you start it up.

否则
Otherwise,

答案就是第n-1个斐波那契数
the result is the sum of Fib of n minus 1

和第n-2个斐波那契数的和
and the Fibonacci number,n minus 2.

这是个很简单的
So this is a very simple,

很直接的
direct specification

求斐波那契数的实现
of the description of Fibonacci numbers

就是根据斐波那契数的定义直接写出这个过程
that I gave you when I introduced those numbers.

用最简单可行的方式直接描述了定义中的递归关系
It represents the recurrence relation in the simplest possible way.

现在 我们又如何解释这个过程呢
Now,how do we use such a thing?

我们来分析一下这个过程所演化出的计算过程
Let's draw this process.

让我们来看看这个过程都做了些什么
Let's figure out what this does.

举一个简单的例子 求第4个斐波那契数
Let's consider something very simple by computing Fibonacci of 4.

要求第4个斐波那契数
To compute Fibonacci of 4,

我应该怎么做呢
what do I do?

根据过程的定义 4并不比2小
Well,it says I have-- it's not less than 2.

因此答案就是两个数之和
Therefore it's the sum of two things

然后 我又要求出
Well,in order to compute that I have to compute,then,

第3个和第2个斐波那契数
Fibonacci of 3 and Fibonacci of 2

要求出第3个斐波那契数
In order to compute Fibonacci of 3,

我就得求出第2个斐波那契数和第1个斐波那契数
I have to compute Fibonacci of 2 and Fibonacci of 1.

而为了求出第2个斐波那契数
In order to compute Fibonacci of 2,

就得求出第1个和第0个斐波那契数
I have to compute Fibonacci of 1 and Fibonacci of 0.

要求第1个斐波那契数
In order to compute Fibonacci of 1,

答案就是1
well,the answer is 1.

这正是递归的边界条件
That's from the base case of this recursion.

而第0个斐波那契数
And in order to compute Fibonacci of 0,

是0
well,that answer is 0,

也是递归的边界条件
from the same base.

然后这儿有个1
And here is a 1.

第2个斐波那契数就是第1个斐波那契数
And Fibonacci of 2 is really the sum of Fibonacci of 1.

和第0个斐波那契数的和
And Fib of 0,

分别求出它们
in order to compute that,

就有了一个1
I get a 1,

和一个0
and here I've got a 0.

我画出了一棵树
I've built a tree.

通过这棵树我们能看出一些结果
Now,we can observe some things about this tree.

我们能发现为何
We can see why

这是个非常糟糕的
this is an extremely bad way

求斐波那契数的办法
to compute Fibonacci numbers.

因为 为了求第4个斐波那契数
Because in order to compute Fibonacci of 4,

就得求两次第2个斐波那契数
I had to compute Fibonacci of 2's sub-tree twice.

实际上 如果再多求一个斐波那契数
In fact,in order to add one more,

假设我想要求第5个斐波那契数
supposing I want to do Fibonacci of 5,

那我要做的就是
what I really have to do then

求第4个斐波那契数和第3个斐波那契数的和
is compute Fibonacci of 4 plus Fibonacci of 3.

但第3个斐波那契数已经求过一遍了
But Fibonacci of 3's sub-tree has already been built.

整个递归树描述了一个指数时间复杂度的递归计算过程
This is a prescription for a process that's exponential in time.

只要多求一个斐波那契数
To add 1,

时间复杂度就得乘上一个数
I have to multiply by something

因为多求一个斐波那契数 需要把已经计算过的过程
because I take a proportion

再计算一次
of the existing thing

时间复杂度就成比例地急剧增长
and add it to itself to add one more step.

于是这个过程的时间复杂度就是
So this is a thing whose time complexity is order of

实际上就是O(Fib(n)) （Fib(n)指第n个斐波那契数）
-- actually,it turns out to be Fibonacci-- of n.

这个过程的时间复杂度就是按斐波那契数列增长
There's a thing that grows exactly at Fibonacci numbers.

这很恐怖
It's a horrible thing.

你都不想这么求斐波那契数
You wouldn't want to do it.

时间复杂度这么增长
The reason why the time has to grow that way

是因为在这个模型中
is because we're presuming in the model

之前给出的代换模型
--the substitution model that I gave you,

我没在这儿形式化地应用代换模型
which I'm not doing formally here,

只是简单地表示了一下
I sort of now spit it out in a simple way--

我们假设所有事情都是按顺序完成的
but presuming that everything is done sequentially.

即这个递归树中每个节点都会被检查
That every one of these nodes in this tree has to be examined.

于是 由于树的节点数
And so since the number of nodes

是按指数增长的
in this tree grows exponentially,

因为要多求一个斐波那契数
because I add a proportion of the existing nodes

就要把已经遍历过的节点再遍历一遍
to the nodes I already have to add 1,

然后就发现时间复杂度呈爆炸式的指数增长
then I know I've got an exponential explosion here.

现在 再来考虑
Now,let's see if we can think of

这个过程的空间复杂度
how much space this takes up.

空间复杂度不算太高
Well,it's not so bad.

它主要取决于我们要记录多少信息
It depends on how much we have to remember

才能使整个计算过程得以持续进行
in order to continue this thing running.

这个并不难
Well,that's not so hard.

从这里看出
It says,gee,

想要知道我现在处于树中的什么位置
in order to know where I am in this tree,

就要记录一条回到根节点的路径
I have to have a path back to the root.

也就是说
In other words,

为了
in order to--

考虑一下路径
let's consider the path.

我要把这个过程执行一遍
I would have to execute this.

我说 啊 好吧
I'd say,oh,yes

我向下走到这儿
I'm going to go down here.

不用管方向
I don't care which direction I go.

我这么走
I have to do this.

这么走
I have to then do this.

用一种有趣的方式遍历这棵树
I have to traverse this tree in a sort of funny way.

又接着走这条有趣的小路
I'm going to walk this nice little path.

回到了这里
I come back to here.

好了我已经记住接下来要去哪儿了
Well,I've got to remember where I'm going to be next.

我记在心里了
I've got to keep that in mind.

于是我得知道已经遍历过的节点
So I have to know what I've done.

还得知道未遍历的节点
I have to know what's left.

为了计算出第4个斐波那契数
In order to compute Fibonacci of 4,

某一时刻我会向下走到这儿
at some point I'm going to have to be down here.

我还要记得
And I have to remember

要回到这儿
that I have to go back to here

又回到这儿做一次加法
and then go back to here to do an addition.

然后又走到这儿做一次加法
And then go back to here to do an addition

之前还需要检查这个尚未检查的节点
to something I haven't touched yet.

消耗的空间就是路径的长度
The amount of space that takes up is the path,

最长路径的长度
the longest path.

它有多长
How long it is.

长度就是n
And that grows as n.

于是消耗的空间
So the space

因为那是树的最长下降深度
-- because that's the length of the deepest line through the tree--

空间复杂度就是O(n)
the space is order of n.

可以看出这个过程时空效率都很低
It's a pretty bad process.

我想让各位获得的是
Now,one thing I want to see from this

一种直观的感觉
is a feeling

关于整个计算过程的直观感觉
of what's going on here.

为何
Why are there--

这个程序是如何与整个计算过程联系起来的
how is this program related to this process?

在这儿 我们看到了什么
Well,what are we seeing here?

这个程序实际上
There really are

只做了两件事
only two sorts of things this program does.

这个程序由两条规则组成
This program consists of two rules,

假如你也这么认为的话
if you will.

第一条规则是 第n个斐波那契数
One rule that says Fibonacci of n

就是这里求和过程的结果
is this sum that you see over here,

对应递归树中这样的一个节点
which is a node that's shaped like this.

它指出要把整个过程分为两部分
It says that I break up something into two parts.

在有的情况下
Under some condition

看这里 n比2大
over here that n is greater than 2,

递归树中对应节点就分为两部分
then the node breaks up into two parts.

比2小
Less than 2.

不 比2大 是的
No.Greater than 2.Yes.

还有一种可能
The other possibility is that

有的归约导致节点没有分成两部分
I have a reduction that looks like this.

也就是这样的情况
And that's this case.

如果比2小
If it's less than 2,

答案就是n本身
the answer is n itself.

我们在这儿看到的是
So what we're seeing here is that

构建起的计算过程
the process that got built

局部来看 每个节点
locally at every place

都是这条规则的实际体现
is an instance of this rule.

这里是规则的一次实际体现
Here's one instance of the rule.

这里是规则的又一次实际体现
Here is another instance of the rule.

人们之所以认为
And the reason why people think of

编程很难 确实挺难的
programming as being hard,of course,

是因为编程实际是在编写一种通用规则
is because you're writing down a general rule,

这种通用规则会被应用于很多实际情况
which is going to be used for lots of instances,

而某一个特定的实际情况
that a particular instance--

而编写好的程序会为你处理每种特定的实际情况
it's going to control each particular instance for you.

你必须写出这样的程序
You've got to write down something

它是通用的 并且考虑到变量
that's a general and in terms of variables,

你要考虑那些变量
and you have to think of all the things

所有可能的取值
that could possibly fit in those variables,

所有这些最终都必须通向
and all those have to lead to

你想要实现的计算过程
the process you want to work.

局部看来 你又得把计算过程分成
Locally,you have to break up your process

可以表示出来的若干部分
into things that can be represented

考虑到这些非常特定的局部规则
in terms of these very specific local rules.

好了 来看一下
Well,let's see.

斐波那契数 当然了 不太有趣
Fibonaccis are,of course,not much fun.

不 其实还是挺有趣的
Yes,they are.

大家还会学习黄金分割等概念
You get something called the golden ratio,

并且说不定什么时候我们还有可能接触更多的类似的东西
and we may even see a lot of that some time.

好了 下面来讨论另一件事
Well,let's talk about another thing.

有个很有名的游戏叫汉诺塔
There's a famous game called the Towers of Hanoi,

举这个例子是因为我教会大家
because I want to teach you

如何递归地思考问题
how to think about things recursively.

游戏是这样的
The problem is this one:

我有一堆盘子
I have a bunch of disks,

又有几根柱子
I have a bunch of spikes,

传说在遥远的东方某地
and it's rumored that somewhere in the Orient

有一个有64个盘子的汉诺塔
there is a 64-high tower,

僧侣们每天的工作就是
and the job of various monks or something

移动盘子从一个柱子到另一个
is to move these spikes

移动的规则很复杂
in some complicated pattern

然后最终这些盘子
so eventually-- these disks--

最终我把所有的盘子
so eventually I moved all of the disks

从一个柱子移到了另一个柱子
from one spike to the other.

如果有64个盘子
And if it's 64 high,

就要移动2的64次方（减1 译者注）次
and it's going to take 2 to the 64th moves,

要花费很长时间
then it's a long time.

僧侣们声称盘子移完之时即是宇宙终结之时
They claim that the universe ends when this is done.

好了
Well,let's see.

构造一个递归过程的方法其实很简单
The way in which you would construct a recursive process

就是“想当然”
is by wishful thinking.

你们要相信
You have to believe.

这个主意
So,the idea.

假如我想把这一堆盘子从这儿移到这儿
Supposing I want to move this pile from here to here,

从1号柱移动到2号柱
from spike one to spike two,

好吧 其实不怎么难
well,that's not so hard.

假如 不知怎么回事
See,supposing somehow,

好像有魔法在作用
by some magic--

因为有个更简单的问题
because I've got a simpler problem

我把3个盘子移到这里
-- I move a three-high pile to here--

一次只能移动一个盘子
I can only move one disk at a time,

不管我是怎么做到的
so I don't even think how I did it.

但假设我做到了
But supposing I could do that,

那我只用拿起这个盘子
well,then I could just pick up this disk

把它移到这里
and move it here.

现在问题就简单了
And now I have a simple problem,

把这3个盘子移到这里
I have to move a three-high tower to here,

之前已经做过了
which is no problem.

于是通过两次对3个盘子的移动
So by two moves of a three high tower

再加上1次对一个盘子的移动
plus one move of a single object.

我就能把整堆盘子从这儿移动到这儿
I can move the tower from here to here.

不管怎样
Now,whether or not--

不管探究到什么程度
this is not obvious

都不能明显看出整个过程是正确的
in any deep way that this works.

还有 为什么呢
And why?

为什么我就能假设
Now why is it the case that I can presume,maybe,

假设我能把成功移动这三个盘子
that I can move the three-high tower.

好吧 这是因为
Well the answer is because

我总能减小问题的规模
I'm always counting down,

然后最终是0个盘子的移动问题
and eventually I get down to zero-high tower,

0个盘子不需要移动
and a zero-high tower requires no moves.

现在可以写出整个过程的算法了
So let's write the algorithm for that.

很简单
Very easy.

我会给这些柱子编号
I'm going to label these towers with numbers,

但它们各自编号成什么无关紧要
but it doesn't matter what they're labelled with.

问题就是把n个盘子
And the problem is to move an n-high tower

从一个起始柱移到终点柱
from a spike called From to a spike called To

另一个柱子作为中转 称作中转柱
with a particular spike called Spare.

这就是主要的过程
That's what we're going to do.

用这个我非形式化描述的算法
Using the algorithm I informally described to you,

把n个盘子从起始柱移到终点柱 另一个柱子作为中转
move of a n-high tower from From to To with a Spare.

接着就有两种情况了
Well,I've got two cases,

就要分析都是怎样的情况
and this is a case analysis,

就像之前所做的分析一样
just like it is in all the other things we've done.

如果n等于0 那么
If n is 0,then

我会输出一些东西 输出"Done"
-- I'm going to put out some answers-- Done,we'll say.

我不知道那代表什么意思
I don't know what that means

因为我们也不会遇到这样的情况
Because we'll never use that answer for anything.

我们还是会移动盘子的
We're going to do these moves.

否则
Else.

就移动一次
I'm going to do a move.

移动少于n个盘子
Move a tower of height less than n,

也就是n-1个盘子
the decrement of n height.

把它们移到中转柱上
Now,I'm going to move it to the Spare tower.

整体的思想就是
The whole idea now

把它们从这里移到这里
is to move this from here to here,

移到中转柱
to the Spare tower

从起始柱到中转柱
-- so from From to Spare--

用终点柱作为中转
using To as a spare tower.

之后某个时候
Later,somewhere later,

我就会移动之前的那n个盘子
I'm going to move that same n-high tower,

在那之前已经完成了这个盘子的移动
after I've done this.

要移动n个盘子同样的道理就要上面的n-1个盘子
Going to move that same n minus one-high tower

从中转柱移到终点柱
from the Spare tower to the To tower

用起始柱作为中转
using the From tower as my spare.

编写成代码就是从中转柱移动到终点柱
So the Spare tower to the To tower

用起始柱作为中转
using the From as the spare.

当进行到这种情况
All I have to do now is

剩下要做的事情就是
when I've gotten it in this condition,

现在就是这种情况
between these two moves of a whole tower

在两次移动同一堆盘子之间
-- I've got it into that condition--

只需移动一个盘子
now I just have to move one disk.

所以我想要说的就是
So I'm going to say that

有个什么过程输出一条信息表示做了一次盘子的移动
some things are printing a move

不管这个过程具体怎么实现的
and I don't care how it works.

把盘子从起始柱移动到终点柱
From to To.

现在大家就能明白为何我在这个时候举这样一个例子
Now,you see the reason why I'm bringing this up

是因为在某种程度上
at this moment is this is an almost identical program

这个程序和之前这个程序几乎一样
to this one in some sense.

尽管它们所求解的问题不一样
It's not computing the same mathematical quantity,

演化出的递归树也不尽相同
it's not exactly the same tree,

但不管怎样都会在计算过程中演化出一棵递归树
but it's going to produce a tree.

移动这些盘子的过程
The general way of making these moves

会导致生成一棵指数树
is going to lead to an exponential tree.

好了 接下来试着来移动4个盘子
Well,let's do this four-high.

我还是得看着小抄来移盘子
I have my little crib sheet here

不然会弄错
otherwise I get confused.

好了 下面形式化地提出这个问题
Well,what I'm going to put in is the question of

把4个摞在一起的盘子
move a tower of height four

从1号柱子移动到2号
from one to spike two

用3号柱子作为中转
using spike three as a spare.

这就是接下来我要做的
That's all I'm really going to do.

好吧 开始吧
You know,let's just do it.

我不打算写出
I'm not going to worry about

过程执行的具体步骤
writing out the trace of this.

你自己可以做到
You can do that yourself

因为那很简单
because it's very simple.

我要把1号柱子上的一个盘子移动到3号柱子上
I'm going to move disk one to disk three.

这是怎么回事呢
And how do I get to move disk one to disk three?

我怎么知道要这么做呢
How do I know that?

好吧 我想还是得查看一下程序执行的具体步骤
Well,I suppose I have to look at the trace a little bit.

才能明白我这是在做什么
What am I doing here?

好吧 这个不等于
Well,and this is not--

n不等于0
n is not zero.

那我看一下这里过程的定义
So I'm going to look down here.

这得需要两次移动
This is going to require doing two moves.

只观察第一次吧
I'm only going to look at the first one.

第一次是说把
It's going to require moving--

我怎么写成了移动一座塔
why do I have move tower?

塔可不好移
It makes it harder for me to move.

我要移动摞成一摞的3个盘子
I'm going to move a three-high tower

从起始柱
from the From place,

也就是4号柱（教授不小心犯错 译者注）
which is four,

移动到中转柱
to the Spare,

即2号柱
which is two,

用3号柱
using three as my

不 用 用
-- no,using,using--

学生 [听不清]
STUDENT: [INAUDIBLE PHRASE]

教授 啊 是这样 抱歉
PROFESSOR: Yes,I'm sorry.

从2号柱 
From two--

从1号柱到3号柱用2号柱作为中转
from one to three using two as my spare.

这就对了
That's right.

之后这儿还有一次移动
And then there's another move over here afterwards.

现在可以说
So now I say,

啊 是的
oh,yes,

接下来还得把之上两个盘子
that requires me moving a two-high tower

从1号柱移动到2号柱 用3号柱作为中转
from one to two using three as a spare.

同样的还得再移一次
And so,are the same,

接下来 又要移动
and that's going to require me moving

一个盘子 从1号柱到2号柱
a one-high tower from one to three

用2号柱作为中转
using two as a spare.

好了 当然之后还得再移一次
Well,and then there's lots of other things to be done.

于是我把1个盘子
So I move my one-high tower

从1号柱移动到3号柱 用2号柱作为中转
from one to three using two as a spare,

实际上没用到2号柱
which I didn't do anything with.

好了 整个过程还是非常简单的
Well,this thing just proceeds very simply.

接下来我把这个盘子从1号柱移到2号柱
I move this from one to two.

然后把这个盘子从3号柱移动到2号柱
And I move this disk from three to two.

其实我不想移了
And I don't really want to do it,

但还得继续 从1到3
but I move from one to three.

然后从2到1
Then I move two to one.

从2到3
Then I move two to three.

从1到3
Then one to three.

1到2
One to two.

3到2
Three to two.

3到1
Three to one.

当然了这是因为我之前已经准备好了
This all got worked out beforehand,of course.

2到1
Two to one.

3到2
Three to two.

1到3
One to three.

学生 [听不清]
STUDENT: [INAUDIBLE PHRASE].

教授 噢 从1到3
PROFESSOR: Oh,one to three.

抱歉 谢谢提醒
Excuse me.Thank you.

1到2
One to two.

然后3到2 呼
And then three to two.Whew.

现在请大家思考
Now what I'd like you to think about,

你们刚才看到的是解决这个问题的递归算法
you just saw a recursive algorithm for doing this,

显然要耗费指数级的时间
and it takes exponential time,of course.

不知道是否有别的算法
Now,I don't know if there's any algorithm

不用耗费指数级的时间 它一定会耗费指数级的时间
that doesn't take exponential time-- it has to.

因为我每次只能移动一个盘子
As I'm doing one operation

每次只能移动一个盘子
-- I can only move one thing at a time--

没有什么算法不用耗费指数级的时间
there's no algorithm that's not going to take exponential time.

但是 你能写出迭代的算法
But can you write an iterative algorithm

而不是递归的算法么
rather than a recursive algorithm for doing this?

我一直爱琢磨
One of the sort of little things I like to think about

能否给出一个算法
Can you write one that,

不是像我描述的这样
in fact,doesn't break this problem

把一个问题分解成两个子问题
into two sub-problems the way I described,

而是用一个更局部的规则
but rather proceeds a step at a time

一次演化出整个计算过程
using a more local rule.

那可能会很有趣
That might be fun.

谢谢大家 第三部分结束
Thank you so much for the third segment.

有什么问题要问么
Are there questions?

学生 我想知道有没有什么办法
STUDENT: I wonder if there's a way

能减小递归过程的代价
to reduce a tree or recursion problem,

能否把中间过程
how do you save the intermediate work

计算出的斐波那契数保存下来
you have done in computing the Fibonacci number?

教授 呃 好吧 实际上
PROFESSOR: Oh,well,in fact,

你刚才说的就是一种办法
one of the ways to do is what you just said.

你说  把中间过程的结果保存下来 是吧
You said,I save the intermediate work.OK?

好的 我告诉你
Well,let me tell you

再次说一下 我们后面会见到
-- this,again,we'll see later--

但现在假设就是这种情形
but suppose it's the case that

不论何时做怎样的计算
anytime I compute anything,

所有的这些斐波那契数
any one of these Fibonacci numbers,

我记录一个表
I remember the table

在表中查询
that takes only linear time

只用线性的时间
to look up the answer.

如果我已经计算过了
Then if I ever see it again,

就不再递归地求解了
instead of doing the expansional tree,

是直接在表中查询
I look it up.

我把问题
I've just transformed my problem

变得简单多了
into a problem that's much simpler.

当然
Now,of course,

这种方法已经被使用了
there are the way to do this,as well.

这种方法叫作记忆化
That one's called memoization,

这学期你们就会遇到
and you'll see it sometime later in this term.

但我认为还有个方法是线性时间复杂度的
But I suppose there's a very simple linear time and,

实际上 是用迭代模型计算斐波那契数
in fact,iterative model for computing Fibonaccis,

这也是需要各位坐下来仔细思考的
and that's another thing you should sit down and work out.

这很重要
That's important.

明白怎么运用迭代模型很重要
It's important to see how to do this.

希望大家多练习一下
I want you to practice.

MIT OpenCourseWare
http://ocw.mit.edu

本项目主页
https://github.com/FoOTOo/Learning-SICP
