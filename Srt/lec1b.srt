1
00:00:00,000 --> 00:00:00,000
哈尔滨工业大学 IBM技术中心
倾情制作

2
00:00:00,000 --> 00:00:00,000
压制&&特效：（Tacitus）
字幕&&时间轴：曹竞帆（ChingfanTsou）

3
00:00:00,000 --> 00:00:00,000
特别感谢：裘宗燕

4
00:00:01,840 --> 00:00:14,160
[音乐]
[MUSIC PLAYING BY J.S. BACH]

5
00:00:14,160 --> 00:00:14,700
教授 大家好
PROFESSOR: Hi.

6
00:00:15,960 --> 00:00:17,820
大家都已经知道 程序员的工作
You've seen that the job of a programmer

7
00:00:19,060 --> 00:00:22,080
就是设计出能够达成特定目标的程序
is to design processes that accomplish particular goals,

8
00:00:23,400 --> 00:00:25,200
比如求出一个数的平方根
such as finding the square roots of numbers,

9
00:00:25,940 --> 00:00:27,720
或者其它一些你想要做的事
or other sorts of things you might want to do.

10
00:00:28,460 --> 00:00:30,140
目前为止我们还没介绍别的什么东西
We haven't introduced anything else yet.

11
00:00:31,760 --> 00:00:32,370
当然了
Of course,

12
00:00:32,380 --> 00:00:35,310
程序员完成工作的方式就是构造“咒语”
the way in which a programmer does this is by constructing spells,

13
00:00:36,080 --> 00:00:39,960
通过过程和表达式构造出来的“咒语”
which are constructed out of procedures and expressions.

14
00:00:40,700 --> 00:00:45,380
这些“咒语”一定程度上指明了
And that these spells are somehow direct a process

15
00:00:45,480 --> 00:00:47,680
程序员想要的达成目标的方式
to accomplish the goal that was intended by the programmer.

16
00:00:48,840 --> 00:00:50,660
程序员为了使整个过程变得高效
In order for the programmer to do this effectively,

17
00:00:50,940 --> 00:00:52,660
必须理解他写下的代码
he has to understand the relationship

18
00:00:52,880 --> 00:00:54,730
这些“咒语”
between the particular things that he writes,

19
00:00:54,800 --> 00:00:55,940
和他想要控制的程序的行为
these particular spells,

20
00:00:56,200 --> 00:00:59,020
之间的联系
and the behavior of the process that he's attempting to control.

21
00:01:01,300 --> 00:01:03,180
所以我们在这门课中要做的就是试图
So what we're doing this lecture is attempt to

22
00:01:03,180 --> 00:01:06,000
以尽可能清晰的方式建立这样的联系
establish that connection in as clear a way as possible.

23
00:01:07,260 --> 00:01:09,330
我们尤其要理解
What we will particularly do is understand

24
00:01:09,330 --> 00:01:13,390
特定过程和表达式的模式
how particular patterns of procedures and expressions

25
00:01:14,280 --> 00:01:16,210
将会导致怎样的特定程序执行模式
cause particular patterns of execution,

26
00:01:16,460 --> 00:01:19,000
和计算过程的特定的行为
particular behaviors from the processes.

27
00:01:22,100 --> 00:01:23,230
让我们开始吧
Let's get down to that.

28
00:01:23,860 --> 00:01:25,770
我将会从一个非常简单的程序开始
I'm going to start with a very simple program.

29
00:01:27,920 --> 00:01:31,000
这是一个计算两个数的平方和的程序
This is a program to compute the sum of the squares of two numbers.

30
00:01:33,320 --> 00:01:44,600
我们将x和y的平方和定义为
And we'll define the sum of the squares of x and y to be

31
00:01:45,700 --> 00:01:49,720
x的平方
the sum of the square of x

32
00:01:49,720 --> 00:01:50,780
我这么写
-- I'm going to write it that way--

33
00:01:51,440 --> 00:01:53,630
和y的平方的和
and the square of y,

34
00:01:56,260 --> 00:02:11,000
x的平方是指x和x的乘积
where the square of x is the product of x and x.

35
00:02:13,840 --> 00:02:16,080
现在 设想这么一件事
Now,supposing I were to say something to this,

36
00:02:16,780 --> 00:02:19,970
比如 在这个程序这么定义好之后
like,to the system after having defined these things,

37
00:02:20,180 --> 00:02:24,300
跟据定义的形式 求3和4的平方和
of the form,the sum of the squares of 3 and 4,

38
00:02:25,240 --> 00:02:28,560
我希望得到25
I am hoping that I will get out a 25.

39
00:02:29,120 --> 00:02:30,610
因为3的平方是9
Because the square of 3 is 9,

40
00:02:30,610 --> 00:02:31,880
4的平方是16
and the square of 4 is 16,

41
00:02:32,580 --> 00:02:33,970
它们的和是25
and 25 is the sum of those.

42
00:02:34,980 --> 00:02:35,960
但这都是怎么回事呢
But how does that happen?

43
00:02:36,380 --> 00:02:39,660
如果我们要理解程序的执行以及它的控制方法
If we're going to understand processes and how we control them,

44
00:02:39,660 --> 00:02:45,060
那么我们就得把过程的机制
then we have to have a mapping from the mechanisms of this procedure

45
00:02:45,680 --> 00:02:48,260
与过程执行时所产生的行为对应起来
into the way in which these processes behave.

46
00:02:49,160 --> 00:02:50,720
我们将要得到的是一个正式的
What we're going to have is a formal,

47
00:02:50,960 --> 00:02:53,140
或者说半正式的机械的模型
or semi-formal mechanical model,

48
00:02:53,820 --> 00:02:57,280
你要理解计算机如何事实上 大体上实现这个机制
whereby you understand how a machine could,in fact,in principle,do this.

49
00:02:57,600 --> 00:03:00,060
不论实际的计算机究竟是怎么实现的
Whether or not the actual machine really does

50
00:03:00,080 --> 00:03:02,720
我此刻要告诉你们的都与实际的实现完全没有关系
what I'm about to tell you is completely irrelevant at this moment.

51
00:03:03,490 --> 00:03:04,920
实际上 这是一个工程模型
In fact,this is an engineering model

52
00:03:05,440 --> 00:03:07,630
就好像电阻
in the same way that,electrical resistor,

53
00:03:07,840 --> 00:03:09,810
我们写出一个模型V=IR
we write down a model v equals i r,

54
00:03:10,360 --> 00:03:11,410
这基本上是正确的
it's approximately true.

55
00:03:12,020 --> 00:03:13,060
但不是完全正确的
It's not really true.

56
00:03:13,540 --> 00:03:15,450
当电流通过电阻时 电阻会增加
If I put up current through the resistor it goes boom.

57
00:03:16,560 --> 00:03:19,820
所以电压并不总与电流成线性关系
So the voltage is not always proportional to the current,

58
00:03:20,120 --> 00:03:23,220
但是对于部分情况来说这个模型是适用的
but for some purposes the model is appropriate.

59
00:03:23,860 --> 00:03:26,260
比如我们将要介绍的这个模型
In particular,the model we're going to describe right now,

60
00:03:26,260 --> 00:03:27,850
我把这个模型称作代换模型
which I call the substitution model,

61
00:03:28,180 --> 00:03:30,280
这是我们能接触到的最简单的模型
is the simplest model that we have

62
00:03:30,500 --> 00:03:33,020
它可以帮助我们理解过程和程序执行的原理
for understanding how procedures work and how processes work.

63
00:03:33,770 --> 00:03:35,470
以及过程如何使得程序执行
How procedures yield processes.

64
00:03:36,000 --> 00:03:38,110
代换模型 对接下来几天
And that substitution model will be accurate

65
00:03:38,240 --> 00:03:40,770
我们将要接触到的东西都是适用的
for most of the things we'll be dealing with in the next few days.

66
00:03:41,580 --> 00:03:45,490
但最终 幻想总会破灭
But eventually,it will become impossible to sustain the illusion

67
00:03:45,500 --> 00:03:46,250
如果你认为计算机实际就是这么工作的
that that's the way the machine works,

68
00:03:46,490 --> 00:03:49,600
并且我们将要学习其它的更特殊的模型
and we'll go to other more specific and particular models

69
00:03:49,920 --> 00:03:51,020
届时会讨论更多的细节
that will show more detail.

70
00:03:53,200 --> 00:03:57,640
好了 接下来 我们来看下
OK,well,the first thing,of course,is we say,

71
00:03:57,640 --> 00:03:58,780
黑板上的这些内容
what are the things we have here?

72
00:03:58,780 --> 00:04:00,030
这里已经有了一些神秘的符号
We have some cryptic symbols.

73
00:04:00,900 --> 00:04:03,770
这些神秘的符号是由几块组成的
And these cryptic symbols are made out of pieces.

74
00:04:04,090 --> 00:04:05,380
还有几种表达式
There are kinds of expressions.

75
00:04:05,720 --> 00:04:08,100
现在我们看一看都有哪些类型的表达式
So let's write down here the kinds of expressions there are.

76
00:04:17,580 --> 00:04:18,180
有
And we have--

77
00:04:18,260 --> 00:04:20,180
首先有数字
and so far I see things like numbers.

78
00:04:25,060 --> 00:04:27,550
有像那样的符号
I see things like symbols like that.

79
00:04:31,790 --> 00:04:34,940
我们之前见过Lambda表达式
We have seen things before like lambda expressions,

80
00:04:34,940 --> 00:04:35,710
当然了没出现在黑板上
but they're not here.

81
00:04:35,870 --> 00:04:36,720
先撇开不谈
I'm going to leave them out.

82
00:04:36,720 --> 00:04:37,680
Lambda表达式
Lambda expressions,

83
00:04:38,190 --> 00:04:39,290
稍后再讨论
we'll worry about them later.

84
00:04:44,500 --> 00:04:45,640
还有定义
Things like definitions.

85
00:04:51,550 --> 00:04:52,660
还有条件表达式
Things like conditionals.

86
00:04:58,040 --> 00:05:00,050
最后还有组合式
And finally,things like combinations.

87
00:05:06,660 --> 00:05:09,050
这些表达式
These kinds of expressions are

88
00:05:10,090 --> 00:05:14,090
我们稍后再讨论 它们是特殊形式
-- I'll worry about later-- these are special forms.

89
00:05:14,740 --> 00:05:16,920
它们有一些专门的规则
There are particular rules for each of these.

90
00:05:17,320 --> 00:05:18,430
然而我要告诉你们的是
I'm going to tell you,however,

91
00:05:18,430 --> 00:05:20,370
处理通常情况的规则
the rules for doing a general case.

92
00:05:20,750 --> 00:05:22,370
通常是怎样对一个组合式求值的
How does one evaluate a combination?

93
00:05:23,200 --> 00:05:24,370
因为 实际上 在黑板的那边
Because,in fact,over here,

94
00:05:24,760 --> 00:05:27,800
全都是一些组合式以及一些符号和数字
all I really have are combinations and some symbols and numbers.

95
00:05:28,990 --> 00:05:30,610
而简单的 比如一个数字
And the simple things like a number,well,

96
00:05:30,610 --> 00:05:32,090
求值的结果就是这个数字所代表的数值
it will evaluate to itself.

97
00:05:33,000 --> 00:05:34,680
在我将要介绍的模型中
In the model I will have for you,

98
00:05:34,700 --> 00:05:35,860
符号的概念将不会出现
the symbols will disappear.

99
00:05:36,810 --> 00:05:39,450
只有当你需要了解
They won't be there at the time when you need them,

100
00:05:39,450 --> 00:05:40,970
当你需要真正理解它的时候才讨论
when you need to get at them.

101
00:05:41,420 --> 00:05:43,530
所以我只需要向大家讲解
So the only thing I really have to explain to you is,

102
00:05:43,530 --> 00:05:44,850
如何对组合式求值
how do we evaluate combinations?

103
00:05:47,950 --> 00:05:49,010
好吧 继续
OK,let's see

104
00:05:50,010 --> 00:05:52,540
先看下第一张幻灯片
So first I want to get the first slide.

105
00:05:53,310 --> 00:05:58,440
这是对一个表达式求值的规则
Here is the rule for evaluating an application.

106
00:06:01,040 --> 00:06:06,140
我们看到这条规则指出
What we have is a rule that says,

107
00:06:06,140 --> 00:06:07,050
要对一个组合式求值
to evaluate a combination,

108
00:06:07,050 --> 00:06:08,900
主要有三个部分
there are two parts,three parts to the rule.

109
00:06:09,540 --> 00:06:11,790
组合式有若干个部分
The combination has several parts.

110
00:06:12,020 --> 00:06:15,090
有运算符和运算对象
It has operators and it has operands.

111
00:06:16,420 --> 00:06:19,060
运算符返回一个过程
The operator returns into a procedure.

112
00:06:19,810 --> 00:06:20,910
也就是说如果我们对运算符求值
If we evaluate the operator,

113
00:06:20,930 --> 00:06:21,890
结果是一个过程
we will get a procedure.

114
00:06:22,100 --> 00:06:23,200
比如你们也看到了
And you saw,for example,

115
00:06:23,200 --> 00:06:24,980
我向计算机输入一个“+”
how I'll type "+" at the machine

116
00:06:24,980 --> 00:06:27,170
然后产生了一些复合的过程以及其它的一些东西
and out came compound procedure something or other.

117
00:06:28,520 --> 00:06:30,260
而对运算对象求值就会得到参数
And the operands produce arguments.

118
00:06:31,620 --> 00:06:35,250
一旦我们完成了对运算符的求值得到了一个过程
Once we've gotten the operator evaluated to get a procedure,

119
00:06:35,250 --> 00:06:37,540
并且对运算对象也完成求值得到了参数
and the argument is evaluated to get argument

120
00:06:37,550 --> 00:06:39,090
也就是运算对象作为参数的值
-- the operand's value to get arguments--

121
00:06:39,090 --> 00:06:41,170
我们通过复制过程体
we apply the procedure to these arguments

122
00:06:41,880 --> 00:06:43,950
来将其应用到这些参数上
by copying the body of the procedure,

123
00:06:44,240 --> 00:06:46,940
用术语来说 过程体指的就是定义这个过程的表达式
which is the expression that the procedure is defined in terms of.

124
00:06:47,220 --> 00:06:48,570
接下来要做的是
What is it supposed to do?

125
00:06:49,280 --> 00:06:53,950
用求得的实际参数代换过程的形式参数
Substituting the argument supplied for the formal parameters of the procedure,

126
00:06:54,680 --> 00:06:56,220
形式参数就是
the formal parameters being the names

127
00:06:56,220 --> 00:06:58,220
过程定义中声明的变量名
defined by the declaration of the procedure.

128
00:06:58,760 --> 00:07:00,850
然后我们对产生的新过程体求值
Then we evaluate the resulting new body,

129
00:07:01,020 --> 00:07:04,770
这个新过程体是由将代换模型应用到之前的过程体而产生的
the body resulting from copying the old body with the substitutions made.

130
00:07:06,990 --> 00:07:08,270
这个规则非常简单
It's a very simple rule,

131
00:07:09,370 --> 00:07:11,650
并且我们会非常形式化地应用这个规则一段时间
and we're going to do it very formally for a little while.

132
00:07:11,980 --> 00:07:14,420
因为接下来几节课
Because for the next few lectures,

133
00:07:14,730 --> 00:07:15,740
我想让各位做的是
what I want you to do is to say,

134
00:07:15,740 --> 00:07:18,930
如果有什么不能理解的
if I don't understand something,if I don't understand something,

135
00:07:19,280 --> 00:07:20,930
就直接机械化地应用这个规则
be very mechanical and do this.

136
00:07:23,570 --> 00:07:24,160
接下来
So let's see.

137
00:07:25,970 --> 00:07:27,630
考虑这么一个求值过程
Let's consider a particular evaluation,

138
00:07:27,740 --> 00:07:28,990
之前讨论过的
the one we were talking about before.

139
00:07:29,210 --> 00:07:32,960
3和4的平方和
The sum of the squares of 3 and 4.

140
00:07:35,560 --> 00:07:36,660
这是什么意思呢
What does that mean?

141
00:07:36,660 --> 00:07:37,760
这是说
It says,take

142
00:07:38,260 --> 00:07:40,660
其实 我已经知道求平方的过程是怎样的
-- well,I could find out what's on the square--

143
00:07:40,660 --> 00:07:41,860
是某个过程
it's some procedure,

144
00:07:42,140 --> 00:07:43,710
但我并不关心这个过程的具体表述
and I'm not going to worry about the representation,

145
00:07:43,710 --> 00:07:45,710
并且我也不会在黑板上写出来
and I'm not going to write it on the blackboard for you.

146
00:07:46,810 --> 00:07:48,530
还有3 代表某个数字
And I have that 3,represents some number,

147
00:07:49,250 --> 00:07:51,360
但如果要我重复这个数字
but if I have to repeat that number,

148
00:07:51,360 --> 00:07:52,280
我并不知道这个数字是什么
I can't tell you the number.

149
00:07:52,410 --> 00:07:54,190
这个数字本身是抽象的
The number itself is some abstract thing.

150
00:07:54,490 --> 00:07:55,860
只知道有个数词能代表它
There's a numeral which represents it,

151
00:07:55,890 --> 00:07:56,690
我把这个它叫作3
which I'll call 3,

152
00:07:56,960 --> 00:07:59,000
并且会在代换中用到它
and I'll use that in my substitution.

153
00:07:59,370 --> 00:08:01,400
4也是个数字
And 4 is also a number.

154
00:08:01,570 --> 00:08:07,680
我在这个过程体中用3代换x 用4代换y
I'm going to substitute 3 for x and 4 for y in the body of this procedure

155
00:08:07,680 --> 00:08:08,570
看黑板这里
that you see over here.

156
00:08:09,170 --> 00:08:10,580
这是过程体
Here's the body of the procedure.

157
00:08:11,180 --> 00:08:13,780
它关联到这个组合式
It corresponds to this combination,

158
00:08:13,790 --> 00:08:14,520
这个组合式是个求和过程
which is an addition.

159
00:08:17,160 --> 00:08:18,480
而它就转化成这样一个过程
So what that reduces to,

160
00:08:18,820 --> 00:08:19,870
我们把这个转化
as a reduction step,

161
00:08:19,870 --> 00:08:20,370
称为归约
we call it,

162
00:08:20,670 --> 00:08:28,740
这样就变成了求3和4的平方和
it's the sum of the square of 3 and the square of 4.

163
00:08:30,000 --> 00:08:33,710
接下来我要做的是
Now,what's the next step I have to do here?

164
00:08:33,710 --> 00:08:35,710
对它求值
I say,well,I have to evaluate this.

165
00:08:35,710 --> 00:08:37,010
根据之前给出的求值规则
According to my rule,

166
00:08:37,010 --> 00:08:40,640
就是各位刚刚在幻灯片上看到的
which you just saw on that overhead or slide,

167
00:08:41,410 --> 00:08:45,780
我们要对运算对象求值
what we had was that we have to evaluate the operands

168
00:08:45,930 --> 00:08:47,080
就是这些运算对象
-- and here are the operands,

169
00:08:47,340 --> 00:08:49,080
这是第一个运算对象 这是第二个运算对象
here's one and here's the next operand--

170
00:08:49,400 --> 00:08:50,770
我们还得对运算符求值
and how we have to evaluate procedure.

171
00:08:50,770 --> 00:08:51,850
对它们求值的顺序无关紧要
The order doesn't matter.

172
00:08:52,510 --> 00:08:55,710
然后我们要应用这个过程
And then we're going to apply the procedure,

173
00:08:55,710 --> 00:08:56,280
即求和过程
which is plus,

174
00:08:56,280 --> 00:08:58,620
然后很神奇的 不知怎么回事就能得到答案
and magically somehow that's going to produce the answer.

175
00:08:58,880 --> 00:09:01,050
我不会深究求和过程的实现
I'm not to open up plus and look inside of it.

176
00:09:02,140 --> 00:09:04,500
然而 为了对运算对象求值
However,in order to evaluate the operand,

177
00:09:04,510 --> 00:09:05,970
我们采用任意一种顺序来求值
let's pick some arbitrary order and do them.

178
00:09:06,430 --> 00:09:07,580
我会从右到左求值
I'm going to go from right to left.

179
00:09:08,190 --> 00:09:09,840
好了 为了对这个运算对象求值
Well,in order to evaluate this operand,

180
00:09:09,840 --> 00:09:13,410
我得用同样的规则对这运算对象的每个部分求值
I have to evaluate the parts of it by the same rule.

181
00:09:13,970 --> 00:09:15,850
首先需要弄清楚求平方是什么
And the parts are I have to find out what square is--

182
00:09:15,850 --> 00:09:16,580
是某个过程
it's some procedure,

183
00:09:16,580 --> 00:09:18,120
有个形式参数x
which has a formal parameter x.

184
00:09:19,180 --> 00:09:22,580
然后还有个运算对象是4
And also,I have an operand which is 4,

185
00:09:23,560 --> 00:09:27,550
用4代换求平方过程的形式参数x
which I have to substitute for x in the body of square.

186
00:09:28,410 --> 00:09:30,370
接下来基本上可以这么说
So the next step is basically to say that

187
00:09:30,370 --> 00:09:38,180
这就变成了求3的平方以及4与4乘积的和
this is the sum of the square of 3 and the product of 4 and 4.

188
00:09:40,600 --> 00:09:43,710
当然了 还可以接着深入分析乘法
Of course,I could open up asterisk if I liked

189
00:09:43,720 --> 00:09:45,970
这个求乘积的操作
-- the multiplication operation--

190
00:09:46,680 --> 00:09:47,480
但现在这个不重要
but I'm not going to do that.

191
00:09:47,500 --> 00:09:48,610
先把乘法过程看作是基本过程
I'm going to consider that primitive.

192
00:09:49,790 --> 00:09:53,250
其实 如果你深究计算机的抽象层次
So,and,of course,at any level of detail,if you look inside this machine,

193
00:09:53,250 --> 00:09:54,320
你会发现无论在具体哪一个层次
you're going to find that

194
00:09:54,320 --> 00:09:56,820
在其下都还有若干个你不清楚的抽象层次
there's multiple levels below that that you don't know about.

195
00:09:57,980 --> 00:10:00,650
但我们必须明白要学会忽略细节
But one of the things we have to learn how to do is ignore details.

196
00:10:01,980 --> 00:10:03,960
理解复杂事物的关键是
The key to understanding complicated things

197
00:10:04,280 --> 00:10:08,290
避免不必要的观察 计算和思考
is to know what not to look at and what not compute and what not to think.

198
00:10:09,260 --> 00:10:10,840
所以对这个乘法过程的细节我们不深入研究
So we're going to stop this one here and say,

199
00:10:10,840 --> 00:10:13,560
就直接看作两个数的乘积
oh,yes,this is the product of two things.

200
00:10:13,970 --> 00:10:15,000
现在把两个4乘起来
We're going to do it now.

201
00:10:15,660 --> 00:10:22,320
于是就有3的平方与16的和
So this is nothing more than the sum of the square of 3 and 16.

202
00:10:22,960 --> 00:10:25,640
还有一个求平方的表达式要求值
And now I have another thing I have to evaluate,

203
00:10:27,010 --> 00:10:28,120
注意这是3的平方
but that square of 3,

204
00:10:28,120 --> 00:10:29,080
这与之前求4的平方是一个过程
well,it's the same thing.

205
00:10:29,080 --> 00:10:35,200
于是整个表达式就变成了求3和3乘积与16的和
That's the sum of the product of 3 and 3 and 16,

206
00:10:35,960 --> 00:10:41,810
也就是求9和16的和 结果是25
which is the sum of 9 and 16,which is 25.

207
00:10:44,500 --> 00:10:48,570
大家现在看到了应用代换模型的基本方法
So now you see the basic method of doing substitutions.

208
00:10:49,800 --> 00:10:51,730
但我提醒大家
And I warn you that

209
00:10:52,110 --> 00:10:55,410
代换模型并不能准确描述计算机实际的运行方式
this is not a perfect description of what the computer does.

210
00:10:56,800 --> 00:10:58,200
但这个模型对于接下来几节课我们要讨论的问题
But it's a good enough description

211
00:10:58,200 --> 00:11:02,000
已经能描述得足够清楚
for the problems that we're going to have in the next few lectures

212
00:11:02,510 --> 00:11:04,120
你可以先认为这是正确的
that you should think about this religiously.

213
00:11:04,820 --> 00:11:07,230
认为计算机就是这么运行的
And this is how the machine works for now.

214
00:11:07,520 --> 00:11:08,920
之后我们的讨论会变得更加严谨
Later we'll get more detailed.

215
00:11:11,700 --> 00:11:12,280
好了 现在可以看到
Now,of course,

216
00:11:12,280 --> 00:11:15,020
我在这个例子中采用了从右到左的求值顺序
I made a specific choice of the order of evaluation here.

217
00:11:15,530 --> 00:11:16,530
当然还有别的选择
There are other possibilities.

218
00:11:17,020 --> 00:11:20,580
如果我们回过头来再看幻灯片
If we go back to this,ah,to the telestrator here

219
00:11:20,580 --> 00:11:21,870
上所写的代换模型应用规则
and look at the substitution rule,

220
00:11:22,800 --> 00:11:25,650
可以发现刚才我对运算符求值得到了一个过程
we see that I evaluated the operator to get the procedures,

221
00:11:25,900 --> 00:11:28,690
对运算对象求值得到了过程的实际参数
and I evaluated the operands to get the arguments first,

222
00:11:28,690 --> 00:11:29,950
然后才将参数应用到过程
before I do the application.

223
00:11:30,730 --> 00:11:32,030
这样做是完全可行的
It's entirely possible,

224
00:11:32,030 --> 00:11:34,650
还有别的求值顺序比如正则序求值
and there are alternate rules called normal order evaluation

225
00:11:35,020 --> 00:11:37,470
应用正则序你可以先用表达式去代换
whereby you can do the substitution of the expressions

226
00:11:37,470 --> 00:11:44,640
将其作为过程的形式参数的运算对象 然后再求值
which are the operands for the formal parameters inside the body first.

227
00:11:45,970 --> 00:11:47,650
这么做会得到同样的答案
And you'll get also the same answer.

228
00:11:48,560 --> 00:11:50,110
但是现在 考虑到实际情况
But right now,for concreteness,

229
00:11:50,110 --> 00:11:52,240
因为计算机实际是这么运行的
and because this is the way our machine really does it,

230
00:11:52,900 --> 00:11:54,000
我还是会给出在黑板上演示的方式
I'm going to give you this rule,

231
00:11:54,000 --> 00:11:55,130
这种方式给出了明确的顺序
which has a particular order.

232
00:11:56,120 --> 00:11:58,140
当然了这些顺序一定程度上也是灵活可变的
But that order is to some extent arbitrary,too.

233
00:11:59,620 --> 00:12:01,340
归根到底
In the long run,in the long run,

234
00:12:01,340 --> 00:12:03,760
采用哪种求值顺序来理解
都有各自的依据
there are some reasons why you might pick one order or another,

235
00:12:03,760 --> 00:12:05,760
以后我们会继续讨论这个问题
and we'll get to that later in the subject.

236
00:12:11,930 --> 00:12:15,130
好了 为了让大家理解这都是怎么回事
OK,well now the only other thing I have to tell you about

237
00:12:15,150 --> 00:12:16,420
还需要给大家介绍一个东西
ejust to understand what's going on

238
00:12:16,440 --> 00:12:18,670
来看幻灯片上对条件表达式的解释
is let's look at the rule for conditionals.

239
00:12:19,470 --> 00:12:21,620
条件表达式很简单
Conditionals are very simple,

240
00:12:22,490 --> 00:12:25,440
我给大家详细解释一下
and I'd like to examine this.

241
00:12:26,890 --> 00:12:31,380
条件表达式就是if表达式
A conditional is something that is if

242
00:12:31,980 --> 00:12:33,380
当然还有cond表达式
-- there's also cond of course--

243
00:12:33,570 --> 00:12:35,700
我会把条件表达式各部分的名称都写下来
but I'm going to give names to the parts of the expression.

244
00:12:35,700 --> 00:12:36,490
首先有一个判断表达式
There's a predicate,

245
00:12:38,080 --> 00:12:40,050
这是个求值结果为真或假的表达式
which is a thing that is either true or false.

246
00:12:41,010 --> 00:12:42,010
然后有一个结果子句
And there's a consequent,

247
00:12:45,600 --> 00:12:47,490
当判断表达式的结果为真就对这个表达式求值
which is the thing you do if the predicate is true.

248
00:12:48,010 --> 00:12:49,020
还有个选择表达式
And there's an alternative,

249
00:12:52,520 --> 00:12:54,610
当判断表达式结果为假
就对这个表达式求值
which is the thing you do if the predicate is false.

250
00:12:55,090 --> 00:12:56,350
顺便提一句
It's important,by the way,

251
00:12:56,760 --> 00:12:59,960
知道事物各部分的名称
to get names for,to get names for,

252
00:13:00,260 --> 00:13:01,390
或者表达式各部分的名称
the parts of things,

253
00:13:01,390 --> 00:13:02,730
很重要
or the parts of expressions.

254
00:13:03,420 --> 00:13:05,660
每个“魔法师”都会告诉你
One of the things that every sorcerer will tell you

255
00:13:05,690 --> 00:13:07,140
如果你能叫出一个“精灵”的名字
is if you have the name of a spirit,

256
00:13:07,140 --> 00:13:08,110
你就有控制它的能力
you have power over it.

257
00:13:10,050 --> 00:13:11,080
所以你得掌握这些名称
So you have to learn these names

258
00:13:11,080 --> 00:13:12,560
以便之后的讨论
so that we can discuss these things.

259
00:13:13,370 --> 00:13:15,410
现在我们有了一个判断表达式
So here we have a predicate,

260
00:13:15,410 --> 00:13:16,100
一个结果表达式
a consequent,

261
00:13:16,100 --> 00:13:16,810
还有个选择表达式
and an alternative.

262
00:13:17,420 --> 00:13:21,060
用这些名称 我们发现对于一个if表达式
And,using such words,we see that an if expression,

263
00:13:21,360 --> 00:13:23,500
关键的问题是对判断表达式的求值
the problems you evaluate to the predicate expression,

264
00:13:26,810 --> 00:13:28,890
如果结果为真
if that yields true,

265
00:13:29,220 --> 00:13:29,850
就对结果表达式求值
then you then go on to evaluate the consequent.

266
00:13:30,190 --> 00:13:30,200
就对选择表达式求值
you evaluate the alternative expression.

267
00:13:30,200 --> 00:13:31,920
否则
Otherwise,
就对选择表达式求值
you evaluate the alternative expression.

268
00:13:31,920 --> 00:13:31,930
就对选择表达式求值
you evaluate the alternative expression.

269
00:13:34,530 --> 00:13:35,840
我想通过一个具体的程序
So I'd like to illustrate that

270
00:13:36,170 --> 00:13:42,250
来进一步说明这个问题
now in the context of a particular,of a particular,little program.

271
00:13:43,200 --> 00:13:45,280
就写一个我们会经常遇到的程序吧
Going to write down a program which we're going to see many times.

272
00:13:51,470 --> 00:13:58,430
这是由皮亚诺算术定义的求x和y之和的过程
This is the sum of x and y done by what's called Peano arithmetic,

273
00:13:58,430 --> 00:14:00,430
其实就是加1和减1
which is all we're doing is incrementing and decrementing.

274
00:14:01,500 --> 00:14:02,660
来看看这个
And we're going to see this for a little bit.

275
00:14:02,660 --> 00:14:03,980
这是个非常重要的程序
It's a very important program.

276
00:14:06,020 --> 00:14:07,120
如果x等于0
If x equals 0,

277
00:14:09,680 --> 00:14:11,260
那么结果就是y
then the result is y.

278
00:14:11,580 --> 00:14:12,270
否则
Otherwise,

279
00:14:12,270 --> 00:14:20,350
结果就是x减1与y加1的和
this is the sum of the decrement of x and the increment of y.

280
00:14:23,220 --> 00:14:26,110
以后我们会继续研究这个加法过程
We're going to look at this a lot more in the future.

281
00:14:27,580 --> 00:14:28,740
现在看前面
Let's look at the overhead.

282
00:14:28,980 --> 00:14:31,090
现在有了这么个过程
So here we have this procedure,

283
00:14:31,090 --> 00:14:33,180
我们看看怎么应用代换模型
and we're going to look at how we do the substitutions,

284
00:14:33,180 --> 00:14:34,270
以及代换的顺序
the sequence of substitutions.

285
00:14:35,760 --> 00:14:37,700
我现在想要求3和4的和
Well,I'm going to try and add together 3 and 4.

286
00:14:38,280 --> 00:14:40,200
根据我演示给大家步骤
Well,using the first rule that I showed you,

287
00:14:40,420 --> 00:14:43,900
第一步 在过程体中
we substitute 3 for x and 4 four y

288
00:14:44,180 --> 00:14:45,620
用3代换x 用4代换y
in the body of this procedure.

289
00:14:45,800 --> 00:14:47,360
过程体
The body of the procedure is the thing

290
00:14:47,360 --> 00:14:49,690
由if表达式开始 在这儿结束
that begins with if and finishes over here.

291
00:14:51,020 --> 00:14:51,940
于是我们就有了
So what we get is,

292
00:14:51,940 --> 00:14:53,390
如果3是0
of course,if 3 is 0,

293
00:14:53,390 --> 00:14:54,600
那么结果就是4
then the result is 4.

294
00:14:55,570 --> 00:14:56,350
否则
Otherwise,

295
00:14:56,450 --> 00:14:58,360
结果就是3减1
it's the sum of the decrement of 3

296
00:14:58,360 --> 00:14:59,320
与4加1的和
and the increment of 4.

297
00:15:01,080 --> 00:15:02,490
但这部份我不会去管它
But I'm not going to worry about these yet

298
00:15:03,020 --> 00:15:04,820
因为3不等于0
because 3 is not 0.

299
00:15:05,290 --> 00:15:06,540
于是答案不是4
So the answer is not 4.

300
00:15:07,970 --> 00:15:08,430
因此
Therefore,

301
00:15:08,450 --> 00:15:10,960
于是整个if表达式就可以归约成
this if reduces to

302
00:15:10,960 --> 00:15:12,610
对这个表达式的求值
an evaluation of the expression,

303
00:15:12,850 --> 00:15:14,010
求3减1
the sum to the decrement of 3

304
00:15:14,010 --> 00:15:14,920
与4加1的和
and the increment of 4.

305
00:15:16,580 --> 00:15:17,800
继续求值
Continuing with my evaluation,

306
00:15:17,800 --> 00:15:19,800
先认为加1的过程是基本过程
the increment I presume to be primitive,

307
00:15:20,380 --> 00:15:21,800
然后就有了5
and so I get a 5 there.

308
00:15:22,680 --> 00:15:24,530
同样把减1也认为是基本过程
OK,and then the decrement is also primitive,

309
00:15:24,530 --> 00:15:25,330
然后就有了2
and I get a 2.

310
00:15:25,680 --> 00:15:28,080
于是我把问题化简了
And so I change the problem into a simpler problem.

311
00:15:28,080 --> 00:15:30,080
不是3加4的问题了
Instead of adding 3 to 4,

312
00:15:30,840 --> 00:15:32,080
而是2加5的问题了
I'm adding 2 to 5.

313
00:15:33,130 --> 00:15:34,600
为什么这样就变简单了呢
The reason why this is a simpler problem

314
00:15:34,600 --> 00:15:37,310
因为我在减小x
is because I'm counting down on x,

315
00:15:37,780 --> 00:15:40,160
最终x会变为0
and eventually,then,x will be 0.

316
00:15:43,070 --> 00:15:44,990
这就是代换模型了
So,so much for the substitution rule.

317
00:15:45,690 --> 00:15:46,420
通常来讲
In general,

318
00:15:46,420 --> 00:15:48,900
在对if表达式使用代换模型的时候
I'm not going to write down intermediate steps

319
00:15:48,900 --> 00:15:50,900
我不会写下所有中间步骤
when using substitutions having to do with ifs,

320
00:15:51,500 --> 00:15:54,660
因为这么做只能把事情复杂化
because they just expand things to become complicated.

321
00:15:55,120 --> 00:15:56,400
我们要做的是
What we will be doing is saying,

322
00:15:56,400 --> 00:15:58,190
把求3和4的和
oh,yes,the sum of 3 and 4

323
00:15:58,190 --> 00:16:00,780
归约到求2和5的和
results in the sum of 2 and 5

324
00:16:01,390 --> 00:16:02,920
在那之后
and reduces to the sum of 2 and 5.

325
00:16:03,160 --> 00:16:06,040
归约到求1和6的和
which,in fact,reduces to the sum of 1 and 6,

326
00:16:06,740 --> 00:16:09,700
最后归约到求0和7的和
which reduces to the sum of 0 and 7

327
00:16:09,700 --> 00:16:10,360
看这儿
over here,

328
00:16:10,860 --> 00:16:11,960
最后归约到7
which reduces to a 7.

329
00:16:13,730 --> 00:16:14,680
这就是我们想要的结果
That's what we're going to be seeing.

330
00:16:16,180 --> 00:16:17,850
现在 各位对第一部分的内容有疑问么
Are there any questions for the first segment yet?

331
00:16:20,180 --> 00:16:20,680
有吗
Yes?

332
00:16:21,010 --> 00:16:23,530
学生 你用了1+过程和-1+过程
STUDENT: You're using 1 plus and minus 1 plus

333
00:16:23,530 --> 00:16:25,460
它们都是基本过程么
Are those primitive operations?

334
00:16:25,460 --> 00:16:26,100
教授 是的
PROFESSOR: Yes

335
00:16:26,410 --> 00:16:28,450
你们在这门课中要明白的是
One of the things you're going to be seeing in this subject

336
00:16:28,970 --> 00:16:32,110
我绝对不会考虑
is I'm going to,without thinking about it,

337
00:16:32,260 --> 00:16:35,680
给大家介绍越来越多的基本过程
introduce more and more primitive operations

338
00:16:35,920 --> 00:16:37,710
可以假定
There's presumably some large library

339
00:16:37,710 --> 00:16:39,260
有一些庞大的基本过程的程序库
of primitive operations somewhere.

340
00:16:39,450 --> 00:16:41,100
不用过分追究这些基本过程
But it doesn't matter that they're primitive--

341
00:16:41,100 --> 00:16:43,100
可能有一些手册有这些基本过程的索引便于我们查找
there may be some manual that lists them all.

342
00:16:43,100 --> 00:16:44,860
如果我向你解释基本过程的作用 你应该说
If I tell you what they do,you should say,

343
00:16:44,860 --> 00:16:46,300
啊 是这样 我明白它们的作用了
oh,yes,I know what they do.

344
00:16:46,660 --> 00:16:48,300
比如 这个减1的过程
So one of them is the decrementor

345
00:16:48,670 --> 00:16:49,490
-1+
-- minus 1 plus--

346
00:16:49,790 --> 00:16:50,890
另一个加1的过程
and the other operation is increment,

347
00:16:50,890 --> 00:16:51,780
1+
which is 1 plus.

348
00:16:53,140 --> 00:16:53,480
谢谢大家
Thank you.

349
00:16:53,490 --> 00:16:54,900
第一部分结束
That's the end of the first segment.

350
00:17:05,540 --> 00:17:19,170
[音乐]
[MUSIC PLAYING BY J.S. BACH]

351
00:17:19,310 --> 00:17:21,540
教授 现在我们有了一个合理的 机械的方式
PROFESSOR: Now that we have a reasonably mechanical way

352
00:17:21,540 --> 00:17:27,300
去理解一个由过程
of understanding how a program made out of procedures

353
00:17:27,300 --> 00:17:30,700
和表达式组成的程序是如何演化成计算过程的
and expressions evolves a process,

354
00:17:31,160 --> 00:17:32,700
我想要大家培养出一些直觉
I'd like to develop some intuition

355
00:17:33,460 --> 00:17:37,150
有关程序如何演化成计算过程的直觉
about how particular programs evolve particular processes,

356
00:17:37,380 --> 00:17:39,150
有关程序到底是什么“形状”的直觉
what the shapes of programs have to be

357
00:17:39,150 --> 00:17:41,150
这样才能产生特定“形状”的计算过程
in order to get particular shaped processes.

358
00:17:42,430 --> 00:17:46,000
这让我想到了 画面预览
This is a question about,really,pre-visualizing.

359
00:17:47,140 --> 00:17:48,670
这是个摄影专业术语
That's a word from photography.

360
00:17:48,670 --> 00:17:51,020
我曾经对摄影十分着迷
I used to be interested in photography a lot,

361
00:17:51,890 --> 00:17:53,700
你会发现
and one of the things you discover

362
00:17:53,700 --> 00:17:55,250
初学摄影的时候
when you start trying to learn about photography

363
00:17:55,250 --> 00:17:57,860
你很想成为一名有创意的摄影师
is that you say,gee,I'd like to be a creative photographer.

364
00:17:58,520 --> 00:18:00,100
我知道怎么做 按快门
Now,I know the rules,I push buttons,

365
00:18:00,100 --> 00:18:02,800
调整光圈什么的
and I adjust the aperture and things like that.

366
00:18:03,140 --> 00:18:06,320
但要想有创意
But the key to being a creative person,partly,

367
00:18:06,320 --> 00:18:09,400
一定程度上靠的是能在一定层次上进行分析
is to be able to do analysis at some level.

368
00:18:09,400 --> 00:18:12,540
比如 在按下快门前
To say,how do I know what it is

369
00:18:12,540 --> 00:18:15,320
我怎么知道交卷上最终是怎样的画面呢
that I'm going to get on the film before I push the button.

370
00:18:16,920 --> 00:18:18,770
我能在心中
Can I imagine in my mind

371
00:18:20,290 --> 00:18:23,340
非常准确清晰地刻画出拍好的照片么
the resulting image very precisely and clearly

372
00:18:24,970 --> 00:18:27,700
那精心地取景
as a consequence of the particular framing,

373
00:18:27,700 --> 00:18:29,120
仔细地调整光圈
of the aperture I choose,

374
00:18:29,120 --> 00:18:30,140
仔细地对焦
of the focus,

375
00:18:30,140 --> 00:18:31,210
而拍出来的照片
and things like that?

376
00:18:32,480 --> 00:18:35,070
一定程度来说 这就是摄影的艺术
That's part of the art of doing this sort of thing.

377
00:18:35,600 --> 00:18:38,480
而要掌握摄影的艺术牵涉到许多方面
And a lot of that involves,learning a lot of that

378
00:18:38,480 --> 00:18:40,050
比如曝光试验片
involves things like test strips.

379
00:18:40,580 --> 00:18:42,400
比如拍摄非常几张简单的画面
You take very simple images

380
00:18:42,970 --> 00:18:46,050
每张都有不同的影像密度
that have varying degrees of density in them,for example,

381
00:18:46,340 --> 00:18:49,330
然后把它们打印在一张纸上
and examine what those look like on a piece of paper

382
00:18:49,330 --> 00:18:50,190
观察它们都有什么不同
when you print them out.

383
00:18:51,180 --> 00:18:53,520
你能发现实际可见的对比度
You find out what is the range of contrasts

384
00:18:53,520 --> 00:18:54,610
都是怎样的范围内
that you can actually see.

385
00:18:55,470 --> 00:18:56,880
还能发现 从实际角度来讲
And what,in a real scene,

386
00:18:56,880 --> 00:18:59,160
都是哪些因素与同一张照片中不同层次
would correspond to the various levels

387
00:18:59,160 --> 00:19:03,640
不同区块的影像密度的产生有关
and zones that you have of density in an image.

388
00:19:05,020 --> 00:19:08,540
今天这节课我就想让大家看一些特别的“曝光试验片”
Well,today I want to look at some very particular test strips,

389
00:19:09,290 --> 00:19:12,280
下面通过幻灯片来看第一张
and I suppose one of them I see here is up on the telestrator,

390
00:19:12,280 --> 00:19:14,040
请看
so we should switch to that.

391
00:19:14,810 --> 00:19:18,840
有两个非常非常重要的程序
There's a very important,very important pair of programs

392
00:19:18,840 --> 00:19:24,050
用来理解在程序执行时
for understanding what's going on in the evolution of a process

393
00:19:24,190 --> 00:19:25,600
计算过程中的求值都是怎样的
by the execution of a program.

394
00:19:26,900 --> 00:19:30,010
大家看到的是两个几乎相同的过程
What we have here are two procedures that are almost identical.

395
00:19:32,110 --> 00:19:34,580
基本上没有区别
Almost no difference between them at all.

396
00:19:35,080 --> 00:19:37,260
只有几个字符不同
It's a few characters that distinguish them.

397
00:19:38,610 --> 00:19:41,010
这两个过程表示的是两种不同的求两数之和的方法
These are two ways of adding numbers together.

398
00:19:42,110 --> 00:19:43,010
第一个
The first one,

399
00:19:43,610 --> 00:19:45,700
看这里
which you see here,

400
00:19:46,170 --> 00:19:48,900
是求两数之和
the first one is the sum of two numbers

401
00:19:48,900 --> 00:19:49,940
和我们上节课讲到的一样
-- just what we did before--

402
00:19:50,440 --> 00:19:51,650
如果第一个参数是0
is if the first one is 0,

403
00:19:51,650 --> 00:19:52,960
第二个参数就是答案
it's the answer of the second one.

404
00:19:53,210 --> 00:19:53,840
否则
Otherwise,

405
00:19:53,840 --> 00:19:55,840
就是第一个参数减1
it's the sum of the decrement of the first

406
00:19:55,840 --> 00:19:56,940
和第二个参数加1的和
and the increment of the second.

407
00:19:57,610 --> 00:20:03,360
你可以这么考虑 有两堆弹珠
And you may think of that as having two piles,having two piles.

408
00:20:04,090 --> 00:20:07,180
把这两堆加在一块儿形成新的一堆的办法就是
And the way I'm adding these numbers together to make a third pile is by

409
00:20:07,180 --> 00:20:09,180
把弹珠从一堆挪到另一堆去
moving marbles from one to the other.

410
00:20:10,130 --> 00:20:11,070
仅此而已
Nothing more than that.

411
00:20:11,290 --> 00:20:12,850
最终 有一堆会被搬空
And eventually,when I run out of one

412
00:20:12,850 --> 00:20:13,900
另一堆就是加和的结果了
then the other is the sum.

413
00:20:15,330 --> 00:20:19,240
然而 第二个过程不是这样做的
However,the second procedure here doesn't do it that way.

414
00:20:20,340 --> 00:20:22,380
它是这样做的 如果第一个参数是0
It says if the first number is 0,

415
00:20:22,380 --> 00:20:23,550
答案就是第二个
then the answer is the second.

416
00:20:24,020 --> 00:20:24,530
否则
Otherwise,

417
00:20:24,530 --> 00:20:26,990
答案就是 第一个参数减1
it's the increment of the sum

418
00:20:26,990 --> 00:20:28,900
和第二个参数的和
of the decrement of the first number

419
00:20:28,900 --> 00:20:29,560
然后再加1
and the second.

420
00:20:31,020 --> 00:20:32,010
这种方式就是
So what this says is

421
00:20:32,020 --> 00:20:36,490
把第一个参数减1和第二个数加起来
add together,add together the decrement of the first number and the second

422
00:20:36,490 --> 00:20:38,320
毫无疑问 简化了问题
-- a simpler problem,no doubt--

423
00:20:38,320 --> 00:20:41,540
然后把这个和再加1
and then change that result to increment it.

424
00:20:42,780 --> 00:20:46,060
这就意味着如果你用两堆弹珠的方式来思考
And so this means that if you think about this in terms of piles,

425
00:20:46,480 --> 00:20:50,100
就是说 我左手右手各有一堆弹珠
it means I'm holding in my hand the things to be added later.

426
00:20:51,450 --> 00:20:53,020
然后我要把它们加在一起
And then I'm going to add them in.

427
00:20:53,610 --> 00:20:56,060
然后我慢慢地把其中一堆搬空
As I slowly decrease one pile to 0,

428
00:20:56,430 --> 00:20:57,710
然后把这些拿出来的弹珠
I've got what's left here,

429
00:20:57,710 --> 00:20:58,890
再放回另一堆弹珠中
and then I'm going to add them back.

430
00:20:59,960 --> 00:21:01,170
两种不同的加法
Two different ways of adding.

431
00:21:02,160 --> 00:21:04,200
关于这两个程序 有趣的是
The nice thing about these two programs

432
00:21:04,460 --> 00:21:05,850
它们几乎一样
is that they're almost identical.

433
00:21:06,450 --> 00:21:08,260
唯一的区别是把加1这个过程放哪儿
The only thing is where I put the increment.

434
00:21:09,140 --> 00:21:10,570
把几个字符挪挪地方
A couple of characters moved around.

435
00:21:11,490 --> 00:21:14,280
现在我想弄明白
Now I want to understand,I want to understand the kind of behavior

436
00:21:14,760 --> 00:21:16,820
我们会从这两个程序中看到怎样的行为
we're going to get from each of these programs.

437
00:21:17,330 --> 00:21:19,040
加深大家对这个问题的印象
Just to get them firmly in your mind

438
00:21:19,280 --> 00:21:21,680
我通常不想这么谨慎
-- I usually don't want to be this careful--

439
00:21:21,680 --> 00:21:23,610
但是还是要加深大家的印象
but just to get them firmly in your mind,

440
00:21:23,610 --> 00:21:25,330
我在黑板上把程序再写一遍
I'm going to write the programs again on the blackboard,

441
00:21:25,330 --> 00:21:27,100
然后我会演化出一个计算过程
and then I'm going to evolve a process.

442
00:21:27,770 --> 00:21:29,100
大家都注意观察 看看是怎么回事
And you're going to see what happens.

443
00:21:29,460 --> 00:21:31,340
看看过程演化是怎样的“形状”
We're going to look at the shape of the process

444
00:21:31,340 --> 00:21:32,740
这是程序导致的一个结果
as a consequence of the program.

445
00:21:34,040 --> 00:21:35,730
我们从这个程序开始
So the program we started with is this:

446
00:21:40,510 --> 00:21:44,160
求x与y的和
the sum of x and y says

447
00:21:44,160 --> 00:21:49,410
如果x等于0
if x is 0,

448
00:21:49,410 --> 00:21:50,670
那么答案就是y
then the result is y.

449
00:21:50,670 --> 00:21:51,520
否则
Otherwise,

450
00:21:51,520 --> 00:21:58,220
答案就是x减1和y加1的和
it's the sum of the decrement of x and the increment of y.

451
00:22:01,260 --> 00:22:05,490
现在 假设我们要求3与4的和
Now,supposing we wish to do this addition of 3 and 4,

452
00:22:06,610 --> 00:22:09,120
3与4的和
the sum of 3 and 4,

453
00:22:09,530 --> 00:22:10,300
接下来呢
well,what is that?

454
00:22:10,530 --> 00:22:13,690
我要代换这两个参数
It says that I have to substitute the arguments

455
00:22:14,030 --> 00:22:16,040
代换过程定义中的形式参数
for the formal parameters in the body.

456
00:22:17,380 --> 00:22:18,920
我在脑海中想像这个过程
I'm doing that in my mind.

457
00:22:19,560 --> 00:22:20,660
然后说 啊 这样
And I say,oh,yes,

458
00:22:20,660 --> 00:22:21,920
3代换了x
3 is substituted for x,

459
00:22:21,920 --> 00:22:23,280
但3不是0
but 3 is not 0,

460
00:22:24,650 --> 00:22:27,000
于是直接进入这一部分
so I'm going to go directly to this part

461
00:22:27,000 --> 00:22:30,400
然后只用关心这一部分就行
and write down the simplified consequent here.

462
00:22:30,400 --> 00:22:31,980
因为我只关心加法过程的行为
Because I'm really interested in the behavior of addition.

463
00:22:33,100 --> 00:22:33,840
好了 接下来
Well,what is that?

464
00:22:34,080 --> 00:22:37,760
就变成了求2和5的过程
That therefore turns into the sum of 2 and 5.

465
00:22:38,400 --> 00:22:38,610
换句话说
In other words,

466
00:22:38,610 --> 00:22:40,270
我把这个问题归约成这个问题
I've reduced this problem to this problem.

467
00:22:41,410 --> 00:22:46,280
然后我又把这个问题化归约成求1和6的和
Then I reduce this problem to the sum of 1 and 6,

468
00:22:47,220 --> 00:22:49,340
再接着归约
and then,going around again once,

469
00:22:49,600 --> 00:22:52,480
就有了0和7的和
I get the sum of 0 and 7.

470
00:22:52,970 --> 00:22:54,930
于是x就等于0了
And that's one where x equals 0

471
00:22:54,930 --> 00:22:56,220
答案是y
so the result is y,

472
00:22:56,220 --> 00:22:58,220
也就是7
and so I write down here a 7.

473
00:22:59,920 --> 00:23:02,780
这就是这个程序把3和4相加
So this is the behavior of the process evolved

474
00:23:02,780 --> 00:23:05,360
而演化出的计算过程的行为
by trying to add together 3 and 4 with this program.

475
00:23:07,390 --> 00:23:08,680
另一个程序
For the other program,

476
00:23:09,630 --> 00:23:10,610
写在这边
which is over here,

477
00:23:17,800 --> 00:23:22,250
如此定义x与y的和
I will define the sum of x and y.

478
00:23:23,360 --> 00:23:23,980
怎么定义的呢
And what is it?

479
00:23:26,480 --> 00:23:29,170
如果x是0
If x is 0,

480
00:23:29,620 --> 00:23:30,810
答案就是y
then the result is y

481
00:23:30,810 --> 00:23:31,630
这和上一个程序一样
-- almost the same--

482
00:23:31,630 --> 00:23:34,800
否则就是x减1与y的和
otherwise the increment of the sum

483
00:23:35,550 --> 00:23:40,260
再加上1
of the decrement of x and y.

484
00:23:47,370 --> 00:23:54,640
写错了 黑板不能自动匹配括号
No.I don't have my balancer in front of me.

485
00:23:56,080 --> 00:23:57,330
好了 接下来
OK,well,let's do it now.

486
00:23:58,800 --> 00:24:00,100
求3与4的和
The sum of 3 and 4.

487
00:24:01,160 --> 00:24:02,690
其实这样更有趣 来看
Well,this is actually a little more interesting.

488
00:24:03,310 --> 00:24:05,630
3当然不等于0 和之前一样
Of course,3 is not 0 as before,

489
00:24:06,160 --> 00:24:12,130
于是答案就是 x减1与y的和再加1
so that results in the increment of the sum of the decrement of x,

490
00:24:12,130 --> 00:24:14,260
也就是2与4的和
which is 2 and 4,

491
00:24:15,800 --> 00:24:22,650
接着变成 1与
which is the increment of the sum of 1 and--

492
00:24:22,850 --> 00:24:24,990
噢 弄错了 加1再加1
whoops: the increment of the increment.

493
00:24:25,650 --> 00:24:29,170
现在要做的是计算这一部分
What I have to do now is compute what this means.

494
00:24:29,470 --> 00:24:30,590
我要对这一部分求值
I have to evaluate this.

495
00:24:30,810 --> 00:24:31,720
也就是
Or what that is,

496
00:24:31,870 --> 00:24:34,720
用2和4代换x和y的结果
the result of substituting 2 and 4 for x and y here.

497
00:24:35,200 --> 00:24:40,840
变成了1与4的和再加1
But that is the increment of the sum of 1 and 4,

498
00:24:43,490 --> 00:24:45,920
现在我得展开这部份
which is-- well,now I have to expand this.

499
00:24:47,160 --> 00:24:51,230
啊 然后就变成了0与4的和加1加1
Ah,but that's the increment of the increment

500
00:24:53,520 --> 00:24:56,130
再加1
of the increment of the sum of 0 and 4.

501
00:24:59,390 --> 00:25:02,380
现在来看看都能做些什么
Ah,but now I'm beginning to find things I can do.

502
00:25:02,860 --> 00:25:06,850
加1加1再加1
The increment of the increment of the increment of--

503
00:25:06,850 --> 00:25:08,590
0和4的和是4
well,the sum of 0 and 4 is 4.

504
00:25:12,030 --> 00:25:13,610
4加1是5
The increment of 4 is 5.

505
00:25:14,560 --> 00:25:18,760
这就变成了5加1再加1
So this is the increment of the increment of 5,

506
00:25:20,180 --> 00:25:23,200
也就是6再加1
which is the increment of 6,

507
00:25:23,900 --> 00:25:24,970
最后答案就是7
which is 7.

508
00:25:26,100 --> 00:25:28,060
两种不同的求和方法
Two different ways of computing sums.

509
00:25:29,540 --> 00:25:30,330
现在来看看
Now,let's see.

510
00:25:31,260 --> 00:25:33,260
这两种计算过程有不同的“形状”
These processes have very different shapes.

511
00:25:33,920 --> 00:25:35,400
我想让各位去感受这些“形状”
I want you to feel these shapes.

512
00:25:36,350 --> 00:25:38,370
这种感觉很关键
It's the feeling for the shapes that matters.

513
00:25:40,340 --> 00:25:42,030
从这里我们能发现什么
What's some things we can see about this?

514
00:25:42,660 --> 00:25:44,120
不知怎么回事 这个有点“直”
Well somehow this is sort of straight.

515
00:25:45,250 --> 00:25:46,600
就这样一路直着下来
It goes this way-- straight.

516
00:25:47,340 --> 00:25:51,930
右边界并没有特别的变化
This right edge doesn't vary particularly in size.

517
00:25:53,770 --> 00:25:54,700
而这边这个呢
Whereas this one,

518
00:25:54,990 --> 00:25:58,320
右边界先变大又变小
I see that this thing gets bigger and then it gets smaller.

519
00:26:00,910 --> 00:26:02,620
我还不知道这意味着什么
So I don't know what that means yet,

520
00:26:02,620 --> 00:26:03,630
我们看到的是什么
but what are we seeing?

521
00:26:03,630 --> 00:26:05,900
是不知怎么回事
We're seeing here that somehow

522
00:26:07,170 --> 00:26:10,940
这些加1的过程先展开后收缩
these increments are expanding out and then contracting back.

523
00:26:12,760 --> 00:26:14,570
我构造出一个推迟进行的操作的链条
I'm building up a bunch of them to do later.

524
00:26:16,090 --> 00:26:17,070
我不能马上求值
I can't do them now.

525
00:26:18,720 --> 00:26:19,860
有的过程需要推迟
There's things to be deferred.

526
00:26:21,400 --> 00:26:22,160
好了 我们继续
Well,let's see,

527
00:26:22,670 --> 00:26:24,290
我可以想象一个抽象的计算机
I can imagine an abstract machine.

528
00:26:24,290 --> 00:26:25,480
也许能制造一些实际的计算机
There's some physical machine,

529
00:26:25,480 --> 00:26:26,840
能像我这样求值
perhaps,that could be built to do it,

530
00:26:26,840 --> 00:26:30,010
能像我演示给大家的一样执行程序
which,in fact,executes these programs exactly as I tell you,

531
00:26:30,010 --> 00:26:32,850
像这样代换字符串
substituting character strings in like this.

532
00:26:34,210 --> 00:26:35,080
这样的计算机
Such a machine,

533
00:26:35,780 --> 00:26:38,750
计算中的步骤与计算所花费的时间近似相等
the number of such steps is an approximation of the amount of time it takes.

534
00:26:39,730 --> 00:26:40,830
用纵轴表示时间
So this way is time.

535
00:26:43,630 --> 00:26:46,420
横轴的宽度表示
And the width of the thing is

536
00:26:46,970 --> 00:26:49,700
进行计算需要保存的信息量
how much I have to remember in order to continue the process.

537
00:26:50,110 --> 00:26:51,150
也就是表示进行计算所需要的空间
And this much is space.

538
00:26:53,540 --> 00:26:56,180
我们看到的是一个计算过程
And what we see here is a process

539
00:26:57,090 --> 00:27:00,910
其时间消耗正比于参数x
that takes a time which is proportional to the argument x.

540
00:27:02,420 --> 00:27:04,350
因为如果我让x增大一倍
Because if I made x larger by 1,

541
00:27:04,350 --> 00:27:05,520
就得把这个表示时间的纵轴再加长一倍
then I'd had an extra line.

542
00:27:08,480 --> 00:27:12,260
于是这就是个计算过程 它的空间 抱歉 时间
So this is a process which is space-- sorry-- time.

543
00:27:14,520 --> 00:27:19,160
这个计算过程消耗的时间为O(x)
The time of this process is what we say order of x.

544
00:27:20,540 --> 00:27:24,890
也就是正比于x
That means it is proportional to x by some constant of proportionality

545
00:27:24,890 --> 00:27:27,150
不要刻意追究这个常比例系数是多少
and I'm not particularly interested in what the constant is.

546
00:27:28,360 --> 00:27:29,530
我们还会发现
The other thing we see here

547
00:27:29,540 --> 00:27:32,280
这个计算过程消耗的空间是固定不变的
is that the amount of space this takes up is constant.

548
00:27:33,370 --> 00:27:34,530
即与1成正比
it's proportional to 1.

549
00:27:35,200 --> 00:27:40,420
于是这个计算过程的空间复杂度就是O(1)的
So the space complexity of this is order of 1.

550
00:27:41,710 --> 00:27:43,360
对这样的计算过程我们有个名字
We have a name for such a process.

551
00:27:43,870 --> 00:27:45,810
叫迭代计算过程
Such a process is called an iteration.

552
00:27:50,800 --> 00:27:51,900
关键的地方
And what matters here

553
00:27:51,900 --> 00:27:55,820
不是什么我设计的
is not that some particular machine I designed here

554
00:27:56,450 --> 00:27:57,960
之前提到的
and talked to you about

555
00:27:57,960 --> 00:27:59,320
代换字符计算机
and called a substitution machine

556
00:27:59,320 --> 00:28:00,720
或者 代换模型
or whatever-- substitution model--

557
00:28:01,060 --> 00:28:03,880
怎么设法在常数空间复杂度内完成计算过程
managed to do this in constant space.

558
00:28:04,220 --> 00:28:06,090
关键的地方是这给出了一个界限
What really matters is this tells us a bound.

559
00:28:06,750 --> 00:28:09,200
任何计算机都应该在常数空间复杂度内完成计算过程
Any machine could do this in constant space.

560
00:28:09,360 --> 00:28:12,030
这个过程代表的算法
This algorithm represented by this procedure

561
00:28:12,440 --> 00:28:14,030
在常数空间复杂度内是可执行的
is executable in constant space.

562
00:28:14,840 --> 00:28:17,330
当然了这种说法忽略了一些细节
Now,of course,the model is ignoring some things,

563
00:28:17,630 --> 00:28:18,640
却量化了一些东西
standard sorts of things.

564
00:28:18,640 --> 00:28:21,980
忽略了比如数值越大越消耗空间等等
Like numbers that are bigger take up more space and so on.

565
00:28:21,980 --> 00:28:24,010
但那确实是抽象过程中我要忽略的一个层次
But that's a level of abstraction at which I'm cutting off.

566
00:28:24,010 --> 00:28:24,920
如何表示数值
How do you represent numbers?

567
00:28:24,920 --> 00:28:26,640
我假定所有的数值都占用同样大小的存储空间
I'm considering every number to be the same size.

568
00:28:27,710 --> 00:28:31,420
事实上数值的增大和它们占用的存储空间的增加都非常缓慢
And numbers grow slowly for the amount of space they take up and their size.

569
00:28:33,860 --> 00:28:36,680
而这个算法的复杂度就不同了
Now,this algorithm is different in its complexity.

570
00:28:37,390 --> 00:28:38,680
我们看到
As we can see here,

571
00:28:40,370 --> 00:28:43,210
这个算法时间复杂度
this algorithm has a time complexity

572
00:28:44,680 --> 00:28:48,560
也是正比于输入参数x的
which is also proportional to the input argument x.

573
00:28:49,130 --> 00:28:51,610
因为如果我把这个3再加1
That's because if I were to add 1 to 3,

574
00:28:51,610 --> 00:28:53,320
如果我把问题规模扩大
if I made a larger problem

575
00:28:53,320 --> 00:28:54,980
扩大了1
which is larger by 1 here,

576
00:28:54,980 --> 00:28:56,170
那我就要在上面再加一行
then I'd add a line at the top

577
00:28:56,170 --> 00:28:57,290
在底下再加一行
and I'd add a line at the bottom.

578
00:29:00,280 --> 00:29:01,980
而且事实上这是个常量
And the fact that it's a constant amount,

579
00:29:01,980 --> 00:29:04,050
就像这个计算过程的步骤数是那个的两倍
like this is twice as many lines as that

580
00:29:04,290 --> 00:29:06,600
我不会关心这个层次的细节 也不会关心那个常量
is not interesting at the level of detail I'm talking about right now.

581
00:29:07,730 --> 00:29:12,020
所以这个计算过程的时间复杂度也是O(x)
So this is a time complexity order of the input argument x.

582
00:29:12,640 --> 00:29:13,950
而空间复杂度呢
And space complexity,

583
00:29:15,880 --> 00:29:17,060
这个比较有趣
well,this is more interesting.

584
00:29:17,390 --> 00:29:19,970
有一些东西是固定不变的
I happen to have some overhead,

585
00:29:20,180 --> 00:29:21,000
比如这些
which you see over here,

586
00:29:21,000 --> 00:29:22,720
是近似保持不变的
which is constant approximately.

587
00:29:23,290 --> 00:29:24,090
是常量的
Constant overhead.

588
00:29:24,340 --> 00:29:27,210
但也有一些增加和减少
But then I have something which increases and decreases

589
00:29:27,210 --> 00:29:29,460
是正比于参数x的
and is proportional to the input argument x.

590
00:29:29,710 --> 00:29:31,060
输入参数x是3
The input argument x is 3.

591
00:29:31,060 --> 00:29:34,690
也就是这里为何有3个推迟操作的加1过程
That's why there are three deferred increments sitting around here.

592
00:29:36,360 --> 00:29:36,650
发现了么
See?

593
00:29:37,400 --> 00:29:40,060
于是这个计算过程的空间复杂度也是O(x)的
So the space complexity here is also order x.

594
00:29:41,400 --> 00:29:43,150
这种计算过程
And this kind of process,

595
00:29:43,410 --> 00:29:44,640
给它取个名字
named for the kind of process,

596
00:29:44,640 --> 00:29:45,850
是递归计算过程
this is a recursion.

597
00:29:50,410 --> 00:29:51,280
更准确地来说
A linear recursion

598
00:29:51,280 --> 00:29:51,870
是线性递归计算过程
I will call it.

599
00:29:54,600 --> 00:29:56,680
因为它的时间和空间复杂度
because of the fact that it's proportional

600
00:29:56,680 --> 00:29:58,520
都是正比于输入参数的
to the input argument in both time and space.

601
00:30:01,360 --> 00:30:03,070
那么这个就可以称为一个线性迭代过程
This could have been a linear iteration.

602
00:30:13,630 --> 00:30:15,070
那么 这两种计算过程的本质是什么
So then what's the essence of this matter?

603
00:30:16,190 --> 00:30:17,780
不太容易看出来
This matter isn't so obvious.

604
00:30:18,750 --> 00:30:19,690
可能还有别的模型
Maybe there are other models

605
00:30:19,690 --> 00:30:21,630
可以用来描述
by which we can describe the differences

606
00:30:21,630 --> 00:30:23,390
迭代和递归计算过程的不同之处
between iterative and recursive processes.

607
00:30:23,390 --> 00:30:24,410
但这就有些困难了
Because this is hard now.

608
00:30:25,150 --> 00:30:25,390
记住
Remember,

609
00:30:25,390 --> 00:30:27,140
这两种计算过程都是递归定义的
we have-- those are both recursive definitions.

610
00:30:28,010 --> 00:30:28,940
我们看到的是
What we're seeing there

611
00:30:29,980 --> 00:30:31,380
两种过程在定义上都使用了递归
are both recursive definitions,

612
00:30:31,680 --> 00:30:34,370
也就是两个过程的定义中都引用了该过程本身
definitions that refer to the thing being defined in the definition.

613
00:30:35,050 --> 00:30:36,620
但是它们却产生了不同“形状”的计算过程
But they lead to different shape processes.

614
00:30:37,440 --> 00:30:41,250
过程定义是递归的
There's nothing special about the fact

615
00:30:41,250 --> 00:30:42,540
而产生的计算过程也是递归的
that the definition is recursive

616
00:30:42,540 --> 00:30:44,170
这没什么特别的
that leads to a recursive process.

617
00:30:45,770 --> 00:30:49,490
好了 来看看另一种有趣的解释
OK.Let's think of another model.

618
00:30:49,850 --> 00:30:51,490
我会和大家谈谈 官僚主义
I'm going to talk to you about bureaucracy.

619
00:30:52,620 --> 00:30:54,290
官僚主义 挺有趣儿的
Bureaucracy is sort of interesting.

620
00:30:54,650 --> 00:30:58,890
在幻灯片上我们看到有关迭代计算过程的解释
Here we see on a slide an iteration.

621
00:31:00,120 --> 00:31:02,220
迭代是一种挺好玩儿的计算过程
An iteration is sort of a fun kind of process.

622
00:31:03,820 --> 00:31:06,210
想象一下有个叫GJS的家伙
Imagine that there's a fellow called GJS

623
00:31:06,330 --> 00:31:07,160
也就是我
-- that stands for me--

624
00:31:08,400 --> 00:31:09,260
遇到了一个问题
and he's got a problem:

625
00:31:09,260 --> 00:31:10,770
他想求3与4的和
he wants to add together 3 and 4.

626
00:31:13,010 --> 00:31:14,820
这个家伙想把3和4加一块儿
This fella here wants to add together 3 and 4.

627
00:31:16,260 --> 00:31:17,170
他打算这么办
Well,the way he's going to do it

628
00:31:17,170 --> 00:31:17,900
他挺懒的
-- he's lazy--

629
00:31:18,260 --> 00:31:20,180
他想找别人帮忙
is he's going to find somebody else to help him do it.

630
00:31:21,060 --> 00:31:22,210
他是这样找人帮忙的
The way he finds someone else to--

631
00:31:22,210 --> 00:31:24,210
他找了个人帮忙 对他说
he finds someone else to help him do it and says,

632
00:31:24,210 --> 00:31:25,970
算出3和4的和
well,give me the answer to 3 and 4

633
00:31:26,010 --> 00:31:27,260
然后把答案返回给我
and return the result to me.

634
00:31:28,010 --> 00:31:30,180
他写了一张小纸递给这个人条然后说
He makes a little piece of paper and says,

635
00:31:30,460 --> 00:31:31,770
给 这是一张纸条
here,here's a piece of paper--

636
00:31:31,770 --> 00:31:32,620
你去解决这个问题
you go ahead and solve this problem

637
00:31:32,620 --> 00:31:33,800
然后把答案返回给我
and give the result back to me.

638
00:31:35,480 --> 00:31:36,000
而这个找来帮忙的家伙呢
And this guy,

639
00:31:36,000 --> 00:31:36,930
也很懒
of course,is lazy,too.

640
00:31:38,010 --> 00:31:39,630
他可不想再看见这张小纸条了
He doesn't want to see this piece of paper again.

641
00:31:40,960 --> 00:31:42,210
他说 啊 好吧
He says,oh,yes,

642
00:31:44,450 --> 00:31:45,480
然后出了个新问题
produce a new problem

643
00:31:45,480 --> 00:31:46,940
是求2和5的和
which is the sum of 2 ad 5

644
00:31:46,940 --> 00:31:49,120
并把答案返回给GJS
and return the result back to GJS.

645
00:31:50,080 --> 00:31:51,210
我不想再看见这张纸条了
I don't want to see it again.

646
00:31:52,000 --> 00:31:53,700
这个家伙不想再看见这张纸条了
This guy does not want to see this piece of paper.

647
00:31:55,860 --> 00:31:59,940
于是就出了一个新问题
And then this fellow makes a new problem,

648
00:32:00,260 --> 00:32:02,030
也就是求1与6的和的问题
which is the addition of the sum of 1 and 6,

649
00:32:02,030 --> 00:32:04,260
他又把纸条传给了这个家伙 并说到
and he give it to this fella and says,

650
00:32:04,260 --> 00:32:06,820
算出答案然后把答案告诉GJS
produce that answer and returned it to GJS.

651
00:32:08,100 --> 00:32:09,740
那个家伙又接着出了个新问题
And that produces a problem,

652
00:32:09,740 --> 00:32:11,310
求0与7的和
which is to add together 0 and 7

653
00:32:11,310 --> 00:32:13,090
然后把答案返回给GJS
and give the result to GJS.

654
00:32:13,810 --> 00:32:15,010
最后这个家伙直接说
This fella finally just says,

655
00:32:15,010 --> 00:32:16,120
啊 好吧 答案是7
oh,yeah,the answer is 7,

656
00:32:16,120 --> 00:32:17,340
然后把答案返回给了GJS
and sends it back to GJS.

657
00:32:18,140 --> 00:32:19,170
迭代计算过程就是这样的
That's what an iteration is.

658
00:32:19,870 --> 00:32:20,800
相对而言
By contrast,

659
00:32:21,260 --> 00:32:23,570
递归计算过程就有些不同了
a recursion is a slightly different kind of process.

660
00:32:26,060 --> 00:32:27,610
它更加“官僚主义”
This one involves more bureaucracy.

661
00:32:28,140 --> 00:32:29,380
它使得更多的人变得忙碌
It keeps more people busy.

662
00:32:30,190 --> 00:32:31,900
更多的人被雇佣
It keeps more people employed.

663
00:32:32,400 --> 00:32:34,860
当然了能增加就业也许更好
Perhaps it's better for that reason.

664
00:32:35,600 --> 00:32:36,160
请看幻灯片
But here it is:

665
00:32:36,160 --> 00:32:38,160
我想要知道3与4的和
I want the answer to the problem 3 and 4.

666
00:32:38,520 --> 00:32:39,900
于是写了张纸条 说到
So I make a piece of paper that says,

667
00:32:39,900 --> 00:32:40,990
把答案返回给我
give the result back to me.

668
00:32:42,840 --> 00:32:43,610
然后我把纸条给了这个家伙
Give it to this fella.

669
00:32:44,330 --> 00:32:45,080
这个家伙说
This fellow says,

670
00:32:45,220 --> 00:32:45,860
好吧我会记得
oh,yes,I will remember

671
00:32:46,440 --> 00:32:48,170
一会儿要加1
that I have to add later,

672
00:32:49,040 --> 00:32:51,560
而我又得知道2加4的和是多少
and I want to get the answer the problem 2 plus 4,

673
00:32:52,020 --> 00:32:54,740
于是把这个问题给了Harry
give that one to Harry,

674
00:32:54,740 --> 00:32:57,040
然后把结果返回给我 Joe
and have the results sent back to me-- I'm Joe.

675
00:32:58,520 --> 00:33:00,260
一旦Harry返回了答案
When the answer comes back from Harry,

676
00:33:00,260 --> 00:33:01,050
也就是6
which is a 6,

677
00:33:01,300 --> 00:33:02,500
我就会把答案加1
I will then do the increment

678
00:33:04,120 --> 00:33:05,650
然后把结果返回给GJS
and give that 7 back to GJS.

679
00:33:07,290 --> 00:33:09,050
大家可以发现 在递归计算过程中 需要保留的纸条
So there are more pieces of paper outstanding

680
00:33:09,660 --> 00:33:12,290
比迭代计算过程的多
in the recursive process than the iteration.

681
00:33:16,540 --> 00:33:18,660
还有一种方法可以用来理解迭代计算过程
There's another way to think about what an iteration is

682
00:33:19,300 --> 00:33:20,990
以及迭代计算过程和递归计算过程的不同之处
and the difference between an iteration and a recursion.

683
00:33:21,420 --> 00:33:22,760
问题的关键在于
You see,the question is,

684
00:33:22,760 --> 00:33:24,780
有多少东西是不可见的
how much stuff is under the table?

685
00:33:26,000 --> 00:33:27,550
如果我要停止
something,if I were to stop--

686
00:33:28,360 --> 00:33:32,130
假设我现在要关闭计算机
supposing I were to kill this computer right now,OK?

687
00:33:32,130 --> 00:33:35,180
此时我丢失了事务的状态
And at this point I lose the state of affairs,

688
00:33:36,680 --> 00:33:38,690
但我能接着进行运算
well,I could continue the computation from this point

689
00:33:39,390 --> 00:33:44,290
因为继续运算所需要的所有信息都在参数变量中
cause everything I need to continue the computation is in the variables

690
00:33:44,290 --> 00:33:48,540
即程序员编写过程时定义的变量
that were defined in the procedure that the programmer wrote for me.

691
00:33:49,440 --> 00:33:53,810
迭代计算过程能用明确的变量保存计算过程中的状态
An iteration is a system that has all of its state in explicit variables.

692
00:33:56,670 --> 00:34:00,020
这一点递归计算过程就不同
Whereas the recursion is not quite the same.

693
00:34:00,940 --> 00:34:04,040
如果我弄丢了这堆垃圾
If I were to lose this pile of junk over here

694
00:34:04,880 --> 00:34:06,850
那就只剩下求1与4的和了
and all I was left with was the sum of 1 and 4,

695
00:34:07,000 --> 00:34:09,530
这些信息不足以继续
that's not enough information to continue the process

696
00:34:09,530 --> 00:34:11,870
从初始的求3与4的和的问题
of computing out the 7 from the original problem

697
00:34:11,870 --> 00:34:13,130
求出7的计算过程
of adding together 3 of 4.

698
00:34:14,580 --> 00:34:18,350
除了保存在过程中的
Besides the information that's in the variables

699
00:34:19,290 --> 00:34:21,420
形式参数变量中的信息
of the formal parameters of the program,

700
00:34:22,830 --> 00:34:25,920
计算机还保存了一些不可见的信息
there is also information under the table belonging to the computer,

701
00:34:26,500 --> 00:34:28,280
也就是都有哪些过程被推迟计算了
which is what things have been deferred for later.

702
00:34:30,100 --> 00:34:30,680
当然了
And,of course,

703
00:34:30,930 --> 00:34:32,680
有个实际的比喻
there's a physical analogy to this,

704
00:34:33,220 --> 00:34:37,080
比如微分方程
which is in differential equations,for example,

705
00:34:37,740 --> 00:34:40,560
当我们说到画一个圆的时候
when we talk about something like drawing a circle.

706
00:34:41,760 --> 00:34:42,990
试图画一个圆
Try to draw a circle,

707
00:34:42,990 --> 00:34:46,030
你从一个微分方程中解得它
you make that out of a differential equation

708
00:34:46,030 --> 00:34:52,440
即状态的改变是我当前状态的一个函数
which says the change in my state as a function of my current state.

709
00:34:52,890 --> 00:34:56,920
于是如果我当前的状态由y和x的特定值表征
So if my current state corresponds to particular values of y and x

710
00:34:57,630 --> 00:35:01,100
那么我就能求出一个导数 表征状态如何改变
then I can compute from them a derivative which says how the state must change.

711
00:35:03,150 --> 00:35:03,570
并且 实际上
And,in fact

712
00:35:03,580 --> 00:35:05,630
大家可以看出这是一个圆
this,you can see this was a circle

713
00:35:06,010 --> 00:35:09,760
因为如果碰巧
because if I happen to be,

714
00:35:09,760 --> 00:35:11,100
在这个点
say,at this place over here,

715
00:35:11,770 --> 00:35:15,500
比如在(1,0)这个点
at (1,0),for example

716
00:35:15,530 --> 00:35:16,210
在这个图像上
on this graph,

717
00:35:16,730 --> 00:35:22,180
那就是说y的导数是x
then it means that the derivative of y is x,

718
00:35:22,240 --> 00:35:23,160
我们也看见了
which we see over here.

719
00:35:23,160 --> 00:35:24,040
是1
That's 1,

720
00:35:24,040 --> 00:35:25,100
接着向上走
so I'm going up.

721
00:35:25,780 --> 00:35:28,640
x的导数是-y
And the derivative of x is minus y,

722
00:35:28,640 --> 00:35:29,700
意味着要走回来
which means I'm going backwards.

723
00:35:30,860 --> 00:35:32,520
实际在这点什么也没做
I'm actually doing nothing at this point,

724
00:35:32,680 --> 00:35:36,220
然后开始走回来使y增加
then I start going backwards as y increases.

725
00:35:37,720 --> 00:35:39,440
这样就画出了一个圆
So that's how you make a circle.

726
00:35:39,720 --> 00:35:41,940
有趣的是
And the interesting thing to see is

727
00:35:41,940 --> 00:35:44,900
这儿有一个程序能用这种方法画出一个圆
a little program that will draw a circle by this method.

728
00:35:44,940 --> 00:35:46,180
实际上 不会画一出一个圆
Actually,this won't draw a circle

729
00:35:46,200 --> 00:35:48,320
因为这个程序实际是一个积分器
because it's a forward oil or integrator

730
00:35:48,320 --> 00:35:50,480
并且最终会陷入死循环
and will eventually spiral out and all that.

731
00:35:50,480 --> 00:35:52,900
但陷入死循环前还是能画出一个圆的
But it'll draw a circle for a while before it starts spiraling.

732
00:35:54,080 --> 00:35:55,920
然而 我们在这儿看到的是两个表征状态的变量
However,what we see here is two state variables,

733
00:35:55,920 --> 00:35:56,660
x和y
x and y.

734
00:35:57,740 --> 00:35:59,220
还有个迭代计算过程表明
And there's an iteration that says,

735
00:35:59,600 --> 00:36:00,520
要画一个圆
in order to circle,

736
00:36:00,760 --> 00:36:01,740
已经有了x和y
given an x and y,

737
00:36:02,100 --> 00:36:04,520
我想要的是x和y的下一组取值以用来画圆
what I want is to circle with the next values of x and y

738
00:36:04,520 --> 00:36:08,580
也就是x原有的值减去y和dt的乘积
being the old value of x decrement by y times dt

739
00:36:08,580 --> 00:36:09,760
dt就是时间变化
where dt is the time step

740
00:36:10,320 --> 00:36:15,780
还有y原有的值加上x的dt的乘积
and the old value of y being implemented by x times dt,

741
00:36:16,080 --> 00:36:17,780
然后就得到了x和y的新的取值
giving me the new values of x and y.

742
00:36:21,160 --> 00:36:22,940
好了 现在大家对于两种不同的计算过程的感觉
So now you have a feeling

743
00:36:23,620 --> 00:36:25,740
应该都有了一个直观的感觉
for at least two different kinds of processes

744
00:36:26,920 --> 00:36:29,720
而这两种计算过程却可能是由几乎相同的程序产生的
that can be evolved by almost the same program.

745
00:36:32,300 --> 00:36:34,560
像这样做了一点扰动分析之后
And with a little bit of perturbation analysis like this,

746
00:36:35,340 --> 00:36:37,880
如何小小地修改一下程序观察计算过程是怎样变化的
how you change a program a little bit and see how the process changes,

747
00:36:38,680 --> 00:36:39,800
这样才能有直观的感受
that's how we get some intuition.

748
00:36:43,540 --> 00:36:45,160
来构建大型的 恼人的 复杂的系统
to build big,hairy,complicated systems.
之后我们就会用到这样的直观感受
Pretty soon we're going to use that intuition

749
00:36:45,160 --> 00:36:45,180
之后我们就会用到这样的直观感受
Pretty soon we're going to use that intuition

750
00:36:46,360 --> 00:36:46,800
谢谢
Thank you.

751
00:36:56,880 --> 00:37:06,660
[音乐]
[MUSIC PLAYING BY J.S.BACH]

752
00:37:06,660 --> 00:37:06,920
教授 好了
PROFESSOR: Well,

753
00:37:06,920 --> 00:37:11,100
各位之前已经见过一个对若干程序的简单的扰动分析
you've just seen a simple perturbational analysis of some programs.

754
00:37:11,600 --> 00:37:14,300
我拿一个程序与另一个很相似的程序进行比较
I took a program that was very similar to another program

755
00:37:14,300 --> 00:37:17,340
观察他们如何演化出计算过程
and looked at them both and saw how they evolved processes.

756
00:37:18,220 --> 00:37:19,520
我想再给大家介绍点不同的东西
I want to show you some variety

757
00:37:19,520 --> 00:37:22,720
向大家展示程序可能具有的别的一些计算过程和“形状”
by showing you some other processes and shapes they may have.

758
00:37:24,280 --> 00:37:25,860
同样地 我们将要举例非常简单的程序
Again,we're going to take very simple things,

759
00:37:26,140 --> 00:37:27,860
简单到你都不想写的程序
programs that you wouldn't want to ever write.

760
00:37:29,040 --> 00:37:30,460
那可能是最糟糕的方式
They would be probably the worst way

761
00:37:31,420 --> 00:37:33,060
去进行一些计算过程
of computing some of the things we're going to compute.

762
00:37:33,740 --> 00:37:35,060
但我还是要展示给大家
But I'm just going to show you these things

763
00:37:35,400 --> 00:37:36,520
是想要展现
for the purpose of feeling out

764
00:37:37,420 --> 00:37:41,320
一个程序如何
how a program represents itself

765
00:37:41,600 --> 00:37:44,520
在计算过程的求值中表现出自己的相应规则
as the rule for the evolution of a process.

766
00:37:46,760 --> 00:37:48,800
考虑一个有趣的问题
So let's consider a fun thing,

767
00:37:48,800 --> 00:37:49,920
斐波那契数列
the Fibonacci numbers.

768
00:37:50,400 --> 00:37:52,020
大家可能已经知道斐波那契数列了
You probably know about the Fibonacci numbers.

769
00:37:53,000 --> 00:37:54,280
我记不清是谁了
Somebody,I can't remember who,

770
00:37:54,660 --> 00:37:59,060
有一个人对兔群的繁殖问题很感兴趣
was interested in the growth of piles of rabbits.

771
00:37:59,920 --> 00:38:01,140
不管怎样
And for some reason or other,

772
00:38:01,380 --> 00:38:04,820
我们都知道兔群趋向于指数式增长
the piles of rabbits tend to grow exponentially,as we know.

773
00:38:05,520 --> 00:38:08,620
对于这个过程我们有个不错的模型来解释
And we have a nice model for this process,

774
00:38:08,620 --> 00:38:11,520
由两个数开始算起
is that we start with two numbers,

775
00:38:11,520 --> 00:38:12,360
0和1
0 and 1.

776
00:38:13,420 --> 00:38:16,560
之后的每个数都是前两个数之和
And then every number after this is the sum of the two previous.

777
00:38:17,840 --> 00:38:19,600
于是接下来就是1
So we have here a 1.

778
00:38:20,100 --> 00:38:21,900
然后这两数之和就是2
Then the sum of these two is 2.

779
00:38:22,380 --> 00:38:23,900
那两数之和是3
The sum of those two is 3.

780
00:38:24,300 --> 00:38:25,900
那两数之和是5
The sum of those two is 5.

781
00:38:26,400 --> 00:38:27,900
那两数之和是8
The sum of those two is 8.

782
00:38:28,280 --> 00:38:30,540
那两数之和是13
The sum of those two is 13.

783
00:38:31,360 --> 00:38:33,260
这是21
This is 21.

784
00:38:34,360 --> 00:38:37,740
34 55
34.55.

785
00:38:38,000 --> 00:38:38,520
等等
Et cetera.

786
00:38:40,300 --> 00:38:41,900
如果给这些数字标上序号
If we start numbering these numbers,

787
00:38:42,360 --> 00:38:43,720
第0个
say this is the zeroth one,

788
00:38:43,720 --> 00:38:44,380
第1个
the first one,

789
00:38:44,380 --> 00:38:45,060
第2个
the second one,

790
00:38:45,060 --> 00:38:45,620
第3个
the third one,

791
00:38:45,620 --> 00:38:46,580
第4个
the fourth one,

792
00:38:46,580 --> 00:38:47,040
等等
et cetera.

793
00:38:47,420 --> 00:38:48,420
这是第10个
This is the 10th one,

794
00:38:49,000 --> 00:38:50,040
第10个斐波那契数
the 10th Fibonacci number.

795
00:38:51,620 --> 00:38:53,000
这些数字增长很快
These numbers grow very fast

796
00:38:54,620 --> 00:38:55,360
就像兔子们一样
Just like rabbits.

797
00:38:55,640 --> 00:38:56,760
为什么兔群是这样增长的呢
Why rabbits grow this way

798
00:38:56,760 --> 00:38:58,140
我不会瞎猜
I'm not going to hazard a guess.

799
00:38:59,320 --> 00:39:00,960
接下来我要为大家展示
Now,I'm going to try to write for you

800
00:39:01,280 --> 00:39:05,260
写一个极简单的程序来计算斐波那契数
the very simplest program that computes Fibonacci numbers.

801
00:39:07,040 --> 00:39:09,620
我想要的是一个程序
It's,ah,what I want is a program that,

802
00:39:09,620 --> 00:39:11,160
输入一个n
given an n,

803
00:39:12,320 --> 00:39:13,900
就能输出第n个斐波那契数
will produce for me Fibonacci event.

804
00:39:17,860 --> 00:39:22,320
我就写在这儿了
OK?I'll write it right here.

805
00:39:27,860 --> 00:39:30,740
想要得到第n个斐波那契数
I want the Fibonacci of n,

806
00:39:30,740 --> 00:39:32,500
也就是说 这是那个n
which means the-- this is the n,

807
00:39:33,860 --> 00:39:34,880
这是第n个斐波那契数
and this is Fibonacci of n.

808
00:39:36,080 --> 00:39:37,080
我这么写
And here's the story.

809
00:39:37,400 --> 00:39:42,280
如果n小于2
If n is less than 2,

810
00:39:42,740 --> 00:39:43,940
那么答案就是n
then the result is n.

811
00:39:45,060 --> 00:39:46,040
因为此时斐波那契数和序号相等
Because that's what these are.

812
00:39:46,920 --> 00:39:47,660
这是最开始的规定
That's how you start it up.

813
00:39:48,700 --> 00:39:49,420
否则
Otherwise,

814
00:39:49,760 --> 00:39:55,180
答案就是第n-1个斐波那契数
the result is the sum of Fib of n minus 1

815
00:39:58,220 --> 00:40:00,420
和第n-2个斐波那契数的和
and the Fibonacci number,n minus 2.

816
00:40:10,220 --> 00:40:11,260
这是个很简单的
So this is a very simple,

817
00:40:11,440 --> 00:40:12,680
很直接的
direct specification

818
00:40:12,960 --> 00:40:14,900
求斐波那契数的实现
of the description of Fibonacci numbers

819
00:40:15,540 --> 00:40:17,140
就是根据斐波那契数的定义直接写出这个过程
that I gave you when I introduced those numbers.

820
00:40:19,260 --> 00:40:21,940
用最简单可行的方式直接描述了定义中的递归关系
It represents the recurrence relation in the simplest possible way.

821
00:40:23,260 --> 00:40:24,720
现在 我们又如何解释这个过程呢
Now,how do we use such a thing?

822
00:40:25,080 --> 00:40:25,980
我们来分析一下这个过程所演化出的计算过程
Let's draw this process.

823
00:40:26,840 --> 00:40:27,980
让我们来看看这个过程都做了些什么
Let's figure out what this does.

824
00:40:29,240 --> 00:40:32,080
举一个简单的例子 求第4个斐波那契数
Let's consider something very simple by computing Fibonacci of 4.

825
00:40:35,840 --> 00:40:37,020
要求第4个斐波那契数
To compute Fibonacci of 4,

826
00:40:37,020 --> 00:40:37,620
我应该怎么做呢
what do I do?

827
00:40:38,720 --> 00:40:41,960
根据过程的定义 4并不比2小
Well,it says I have-- it's not less than 2.

828
00:40:42,740 --> 00:40:44,320
因此答案就是两个数之和
Therefore it's the sum of two things

829
00:40:45,160 --> 00:40:47,000
然后 我又要求出
Well,in order to compute that I have to compute,then,

830
00:40:47,460 --> 00:40:52,520
第3个和第2个斐波那契数
Fibonacci of 3 and Fibonacci of 2

831
00:40:56,880 --> 00:40:58,620
要求出第3个斐波那契数
In order to compute Fibonacci of 3,

832
00:40:58,960 --> 00:41:04,020
我就得求出第2个斐波那契数和第1个斐波那契数
I have to compute Fibonacci of 2 and Fibonacci of 1.

833
00:41:07,640 --> 00:41:09,280
而为了求出第2个斐波那契数
In order to compute Fibonacci of 2,

834
00:41:09,800 --> 00:41:12,140
就得求出第1个和第0个斐波那契数
I have to compute Fibonacci of 1 and Fibonacci of 0.

835
00:41:16,500 --> 00:41:17,900
要求第1个斐波那契数
In order to compute Fibonacci of 1,

836
00:41:17,900 --> 00:41:18,960
答案就是1
well,the answer is 1.

837
00:41:19,880 --> 00:41:24,520
这正是递归的边界条件
That's from the base case of this recursion.

838
00:41:25,740 --> 00:41:28,140
而第0个斐波那契数
And in order to compute Fibonacci of 0,

839
00:41:28,140 --> 00:41:29,080
是0
well,that answer is 0,

840
00:41:29,080 --> 00:41:29,860
也是递归的边界条件
from the same base.

841
00:41:30,100 --> 00:41:31,660
然后这儿有个1
And here is a 1.

842
00:41:32,800 --> 00:41:36,140
第2个斐波那契数就是第1个斐波那契数
And Fibonacci of 2 is really the sum of Fibonacci of 1.

843
00:41:38,300 --> 00:41:39,220
和第0个斐波那契数的和
And Fib of 0,

844
00:41:40,580 --> 00:41:41,440
分别求出它们
in order to compute that,

845
00:41:41,480 --> 00:41:42,180
就有了一个1
I get a 1,

846
00:41:42,840 --> 00:41:43,860
和一个0
and here I've got a 0.

847
00:41:46,680 --> 00:41:47,500
我画出了一棵树
I've built a tree.

848
00:41:49,880 --> 00:41:52,440
通过这棵树我们能看出一些结果
Now,we can observe some things about this tree.

849
00:41:53,300 --> 00:41:53,920
我们能发现为何
We can see why

850
00:41:53,920 --> 00:41:55,540
这是个非常糟糕的
this is an extremely bad way

851
00:41:55,540 --> 00:41:56,720
求斐波那契数的办法
to compute Fibonacci numbers.

852
00:41:58,120 --> 00:42:00,020
因为 为了求第4个斐波那契数
Because in order to compute Fibonacci of 4,

853
00:42:00,180 --> 00:42:02,740
就得求两次第2个斐波那契数
I had to compute Fibonacci of 2's sub-tree twice.

854
00:42:07,300 --> 00:42:09,000
实际上 如果再多求一个斐波那契数
In fact,in order to add one more,

855
00:42:09,400 --> 00:42:11,000
假设我想要求第5个斐波那契数
supposing I want to do Fibonacci of 5,

856
00:42:12,480 --> 00:42:13,540
那我要做的就是
what I really have to do then

857
00:42:13,540 --> 00:42:16,180
求第4个斐波那契数和第3个斐波那契数的和
is compute Fibonacci of 4 plus Fibonacci of 3.

858
00:42:17,760 --> 00:42:20,900
但第3个斐波那契数已经求过一遍了
But Fibonacci of 3's sub-tree has already been built.

859
00:42:24,500 --> 00:42:29,200
整个递归树描述了一个指数时间复杂度的递归计算过程
This is a prescription for a process that's exponential in time.

860
00:42:30,220 --> 00:42:31,100
只要多求一个斐波那契数
To add 1,

861
00:42:31,360 --> 00:42:32,800
时间复杂度就得乘上一个数
I have to multiply by something

862
00:42:32,800 --> 00:42:33,920
因为多求一个斐波那契数 需要把已经计算过的过程
because I take a proportion

863
00:42:33,920 --> 00:42:34,660
再计算一次
of the existing thing

864
00:42:34,660 --> 00:42:38,660
时间复杂度就成比例地急剧增长
and add it to itself to add one more step.

865
00:42:40,200 --> 00:42:47,760
于是这个过程的时间复杂度就是
So this is a thing whose time complexity is order of

866
00:42:47,940 --> 00:42:50,600
实际上就是O(Fib(n)) （Fib(n)指第n个斐波那契数）
-- actually,it turns out to be Fibonacci-- of n.

867
00:42:55,940 --> 00:42:58,240
这个过程的时间复杂度就是按斐波那契数列增长
There's a thing that grows exactly at Fibonacci numbers.

868
00:43:00,760 --> 00:43:01,560
这很恐怖
It's a horrible thing.

869
00:43:02,240 --> 00:43:03,040
你都不想这么求斐波那契数
You wouldn't want to do it.

870
00:43:03,440 --> 00:43:05,180
时间复杂度这么增长
The reason why the time has to grow that way

871
00:43:05,180 --> 00:43:06,680
是因为在这个模型中
is because we're presuming in the model

872
00:43:06,680 --> 00:43:08,140
之前给出的代换模型
--the substitution model that I gave you,

873
00:43:08,140 --> 00:43:09,580
我没在这儿形式化地应用代换模型
which I'm not doing formally here,

874
00:43:10,280 --> 00:43:13,200
只是简单地表示了一下
I sort of now spit it out in a simple way--

875
00:43:14,000 --> 00:43:16,200
我们假设所有事情都是按顺序完成的
but presuming that everything is done sequentially.

876
00:43:17,560 --> 00:43:21,180
即这个递归树中每个节点都会被检查
That every one of these nodes in this tree has to be examined.

877
00:43:24,420 --> 00:43:25,580
于是 由于树的节点数
And so since the number of nodes

878
00:43:25,580 --> 00:43:27,660
是按指数增长的
in this tree grows exponentially,

879
00:43:28,080 --> 00:43:30,020
因为要多求一个斐波那契数
because I add a proportion of the existing nodes

880
00:43:30,760 --> 00:43:32,440
就要把已经遍历过的节点再遍历一遍
to the nodes I already have to add 1,

881
00:43:33,880 --> 00:43:36,800
然后就发现时间复杂度呈爆炸式的指数增长
then I know I've got an exponential explosion here.

882
00:43:38,460 --> 00:43:39,840
现在 再来考虑
Now,let's see if we can think of

883
00:43:39,840 --> 00:43:41,200
这个过程的空间复杂度
how much space this takes up.

884
00:43:44,160 --> 00:43:45,180
空间复杂度不算太高
Well,it's not so bad.

885
00:43:45,800 --> 00:43:47,360
它主要取决于我们要记录多少信息
It depends on how much we have to remember

886
00:43:47,360 --> 00:43:48,620
才能使整个计算过程得以持续进行
in order to continue this thing running.

887
00:43:50,280 --> 00:43:51,220
这个并不难
Well,that's not so hard.

888
00:43:51,500 --> 00:43:52,220
从这里看出
It says,gee,

889
00:43:52,400 --> 00:43:54,220
想要知道我现在处于树中的什么位置
in order to know where I am in this tree,

890
00:43:54,340 --> 00:43:55,880
就要记录一条回到根节点的路径
I have to have a path back to the root.

891
00:43:56,720 --> 00:43:57,160
也就是说
In other words,

892
00:43:57,340 --> 00:43:57,800
为了
in order to--

893
00:43:57,800 --> 00:43:58,720
考虑一下路径
let's consider the path.

894
00:43:58,720 --> 00:43:59,680
我要把这个过程执行一遍
I would have to execute this.

895
00:44:00,400 --> 00:44:01,180
我说 啊 好吧
I'd say,oh,yes

896
00:44:01,180 --> 00:44:02,220
我向下走到这儿
I'm going to go down here.

897
00:44:02,580 --> 00:44:03,940
不用管方向
I don't care which direction I go.

898
00:44:04,620 --> 00:44:05,660
我这么走
I have to do this.

899
00:44:06,100 --> 00:44:06,880
这么走
I have to then do this.

900
00:44:06,880 --> 00:44:08,880
用一种有趣的方式遍历这棵树
I have to traverse this tree in a sort of funny way.

901
00:44:11,660 --> 00:44:13,180
又接着走这条有趣的小路
I'm going to walk this nice little path.

902
00:44:13,580 --> 00:44:14,680
回到了这里
I come back to here.

903
00:44:15,400 --> 00:44:17,420
好了我已经记住接下来要去哪儿了
Well,I've got to remember where I'm going to be next.

904
00:44:18,180 --> 00:44:19,200
我记在心里了
I've got to keep that in mind.

905
00:44:19,800 --> 00:44:20,860
于是我得知道已经遍历过的节点
So I have to know what I've done.

906
00:44:20,860 --> 00:44:22,020
还得知道未遍历的节点
I have to know what's left.

907
00:44:22,400 --> 00:44:25,600
为了计算出第4个斐波那契数
In order to compute Fibonacci of 4,

908
00:44:25,600 --> 00:44:27,600
某一时刻我会向下走到这儿
at some point I'm going to have to be down here.

909
00:44:28,260 --> 00:44:29,740
我还要记得
And I have to remember

910
00:44:30,080 --> 00:44:31,360
要回到这儿
that I have to go back to here

911
00:44:31,540 --> 00:44:32,960
又回到这儿做一次加法
and then go back to here to do an addition.

912
00:44:33,380 --> 00:44:34,420
然后又走到这儿做一次加法
And then go back to here to do an addition

913
00:44:34,420 --> 00:44:35,440
之前还需要检查这个尚未检查的节点
to something I haven't touched yet.

914
00:44:37,880 --> 00:44:40,340
消耗的空间就是路径的长度
The amount of space that takes up is the path,

915
00:44:40,340 --> 00:44:41,160
最长路径的长度
the longest path.

916
00:44:42,400 --> 00:44:43,360
它有多长
How long it is.

917
00:44:45,620 --> 00:44:46,860
长度就是n
And that grows as n.

918
00:44:48,080 --> 00:44:48,860
于是消耗的空间
So the space

919
00:44:50,640 --> 00:44:53,620
因为那是树的最长下降深度
-- because that's the length of the deepest line through the tree--

920
00:44:54,280 --> 00:44:56,220
空间复杂度就是O(n)
the space is order of n.

921
00:44:58,880 --> 00:44:59,920
可以看出这个过程时空效率都很低
It's a pretty bad process.

922
00:45:08,660 --> 00:45:10,260
我想让各位获得的是
Now,one thing I want to see from this

923
00:45:11,860 --> 00:45:13,520
一种直观的感觉
is a feeling

924
00:45:13,540 --> 00:45:14,440
关于整个计算过程的直观感觉
of what's going on here.

925
00:45:15,380 --> 00:45:16,560
为何
Why are there--

926
00:45:17,140 --> 00:45:19,420
这个程序是如何与整个计算过程联系起来的
how is this program related to this process?

927
00:45:20,800 --> 00:45:21,620
在这儿 我们看到了什么
Well,what are we seeing here?

928
00:45:21,800 --> 00:45:22,820
这个程序实际上
There really are

929
00:45:23,740 --> 00:45:25,640
只做了两件事
only two sorts of things this program does.

930
00:45:27,080 --> 00:45:28,620
这个程序由两条规则组成
This program consists of two rules,

931
00:45:28,620 --> 00:45:29,100
假如你也这么认为的话
if you will.

932
00:45:29,560 --> 00:45:31,700
第一条规则是 第n个斐波那契数
One rule that says Fibonacci of n

933
00:45:32,200 --> 00:45:36,200
就是这里求和过程的结果
is this sum that you see over here,

934
00:45:37,240 --> 00:45:39,400
对应递归树中这样的一个节点
which is a node that's shaped like this.

935
00:45:41,900 --> 00:45:44,880
它指出要把整个过程分为两部分
It says that I break up something into two parts.

936
00:45:46,340 --> 00:45:49,340
在有的情况下 看这里
Under some condition,under some condition over here

937
00:45:49,860 --> 00:45:51,040
n比2大
that n is greater than 2,

938
00:45:56,500 --> 00:45:56,520
比2小
Less than 2.

939
00:45:56,520 --> 00:45:57,040
递归树中对应节点就分为两部分
then the node breaks up into two parts.
比2小
Less than 2.

940
00:45:57,580 --> 00:45:58,560
不 比2大 是的
No.Greater than 2.Yes.

941
00:46:01,600 --> 00:46:03,600
还有一种可能
The other possibility is that

942
00:46:03,600 --> 00:46:05,140
有的归约导致节点没有分成两部分
I have a reduction that looks like this.

943
00:46:08,920 --> 00:46:09,780
也就是这样的情况
And that's this case.

944
00:46:10,960 --> 00:46:11,740
如果比2小
If it's less than 2,

945
00:46:11,740 --> 00:46:12,780
答案就是n本身
the answer is n itself.

946
00:46:14,200 --> 00:46:15,200
我们在这儿看到的是
So what we're seeing here is that

947
00:46:15,360 --> 00:46:16,860
构建起的计算过程
the process that got built

948
00:46:17,440 --> 00:46:18,740
局部来看 每个节点
locally at every place

949
00:46:19,260 --> 00:46:20,440
都是这条规则的实际体现
is an instance of this rule.

950
00:46:21,920 --> 00:46:23,220
这里是规则的一次实际体现
Here's one instance of the rule.

951
00:46:23,800 --> 00:46:25,220
这里是规则的又一次实际体现
Here is another instance of the rule.

952
00:46:26,080 --> 00:46:27,380
人们之所以认为
And the reason why people think of

953
00:46:27,380 --> 00:46:29,260
编程很难 确实挺难的
programming as being hard,of course,

954
00:46:29,900 --> 00:46:32,160
是因为编程实际是在编写一种通用规则
is because you're writing down a general rule,

955
00:46:34,720 --> 00:46:36,340
这种通用规则会被应用于很多实际情况
which is going to be used for lots of instances,

956
00:46:37,000 --> 00:46:38,200
而某一个特定的实际情况
that a particular instance--

957
00:46:38,840 --> 00:46:41,540
而编写好的程序会为你处理每种特定的实际情况
it's going to control each particular instance for you.

958
00:46:43,560 --> 00:46:44,640
你必须写出这样的程序
You've got to write down something

959
00:46:44,640 --> 00:46:47,180
它是通用的 并且考虑到变量
that's a general and in terms of variables,

960
00:46:47,180 --> 00:46:48,160
你要考虑那些变量
and you have to think of all the things

961
00:46:48,160 --> 00:46:49,540
所有可能的取值
that could possibly fit in those variables,

962
00:46:49,800 --> 00:46:50,760
所有这些最终都必须通向
and all those have to lead to

963
00:46:50,760 --> 00:46:52,180
你想要实现的计算过程
the process you want to work.

964
00:46:53,200 --> 00:46:55,400
局部看来 你又得把计算过程分成
Locally,you have to break up your process

965
00:46:56,100 --> 00:46:58,240
可以表示出来的若干部分
into things that can be represented

966
00:46:58,240 --> 00:47:00,340
考虑到这些非常特定的局部规则
in terms of these very specific local rules.

967
00:47:03,220 --> 00:47:03,800
好了 来看一下
Well,let's see.

968
00:47:04,660 --> 00:47:06,800
斐波那契数 当然了 不太有趣
Fibonaccis are,of course,not much fun.

969
00:47:07,820 --> 00:47:08,440
不 其实还是挺有趣的
Yes,they are.

970
00:47:09,160 --> 00:47:10,920
大家还会学习黄金分割等概念
You get something called the golden ratio,

971
00:47:12,100 --> 00:47:14,060
并且说不定什么时候我们还有可能接触更多的类似的东西
and we may even see a lot of that some time.

972
00:47:15,080 --> 00:47:16,140
好了 下面来讨论另一件事
Well,let's talk about another thing.

973
00:47:16,600 --> 00:47:19,640
有个很有名的游戏叫汉诺塔
There's a famous game called the Towers of Hanoi,

974
00:47:19,640 --> 00:47:20,280
举这个例子是因为我教会大家
because I want to teach you

975
00:47:20,280 --> 00:47:21,980
如何递归地思考问题
how to think about things recursively.

976
00:47:23,860 --> 00:47:25,940
游戏是这样的
The problem is this one:

977
00:47:26,860 --> 00:47:28,040
我有一堆盘子
I have a bunch of disks,

978
00:47:29,040 --> 00:47:30,060
又有几根柱子
I have a bunch of spikes,

979
00:47:31,500 --> 00:47:34,300
传说在遥远的东方某地
and it's rumored that somewhere in the Orient

980
00:47:35,100 --> 00:47:36,760
有一个有64个盘子的汉诺塔
there is a 64-high tower,

981
00:47:37,080 --> 00:47:39,100
僧侣们每天的工作就是
and the job of various monks or something

982
00:47:39,200 --> 00:47:40,600
移动盘子从一个柱子到另一个
is to move these spikes

983
00:47:40,600 --> 00:47:41,860
移动的规则很复杂
in some complicated pattern

984
00:47:42,040 --> 00:47:44,540
然后最终这些盘子
so eventually-- these disks--

985
00:47:44,940 --> 00:47:48,520
最终我把所有的盘子
so eventually I moved all of the disks

986
00:47:48,660 --> 00:47:49,840
从一个柱子移到了另一个柱子
from one spike to the other.

987
00:47:50,380 --> 00:47:51,540
如果有64个盘子
And if it's 64 high,

988
00:47:52,000 --> 00:47:54,180
就要移动2的64次方（减1 译者注）次
and it's going to take 2 to the 64th moves,

989
00:47:54,980 --> 00:47:56,180
要花费很长时间
then it's a long time.

990
00:47:57,820 --> 00:48:01,500
僧侣们声称盘子移完之时即是宇宙终结之时
They claim that the universe ends when this is done.

991
00:48:03,420 --> 00:48:04,060
好了
Well,let's see.

992
00:48:05,580 --> 00:48:08,120
构造一个递归过程的方法其实很简单
The way in which you would construct a recursive process

993
00:48:08,720 --> 00:48:09,660
就是“想当然”
is by wishful thinking.

994
00:48:11,580 --> 00:48:12,440
你们要相信
You have to believe.

995
00:48:14,340 --> 00:48:15,240
这个主意
So,the idea.

996
00:48:15,320 --> 00:48:18,360
假如我想把这一堆盘子从这儿移到这儿
Supposing I want to move this pile from here to here,

997
00:48:19,500 --> 00:48:21,360
从1号柱移动到2号柱
from spike one to spike two,

998
00:48:23,460 --> 00:48:24,540
好吧 其实不怎么难
well,that's not so hard.

999
00:48:25,100 --> 00:48:26,540
假如 不知怎么回事
See,supposing somehow,

1000
00:48:27,000 --> 00:48:27,780
好像有魔法在作用
by some magic--

1001
00:48:27,860 --> 00:48:28,860
因为有个更简单的问题
because I've got a simpler problem

1002
00:48:29,020 --> 00:48:30,600
我把3个盘子移到这里
-- I move a three-high pile to here--

1003
00:48:30,860 --> 00:48:32,000
一次只能移动一个盘子
I can only move one disk at a time,

1004
00:48:32,000 --> 00:48:32,960
不管我是怎么做到的
so I don't even think how I did it.

1005
00:48:33,640 --> 00:48:34,800
但假设我做到了
But supposing I could do that,

1006
00:48:36,300 --> 00:48:38,080
那我只用拿起这个盘子
well,then I could just pick up this disk

1007
00:48:38,080 --> 00:48:38,680
把它移到这里
and move it here.

1008
00:48:41,140 --> 00:48:42,520
现在问题就简单了
And now I have a simple problem,

1009
00:48:42,620 --> 00:48:43,940
把这3个盘子移到这里
I have to move a three-high tower to here,

1010
00:48:44,680 --> 00:48:45,420
之前已经做过了
which is no problem.

1011
00:48:45,780 --> 00:48:47,780
于是通过两次对3个盘子的移动
So by two moves of a three high tower

1012
00:48:47,780 --> 00:48:49,180
再加上1次对一个盘子的移动
plus one move of a single object.

1013
00:48:50,700 --> 00:48:52,760
我就能把整堆盘子从这儿移动到这儿
I can move the tower from here to here.

1014
00:48:55,260 --> 00:48:56,440
不管怎样
Now,whether or not--

1015
00:48:57,180 --> 00:48:58,440
不管探究到什么程度
this is not obvious

1016
00:48:59,240 --> 00:49:00,980
都不能明显看出整个过程是正确的
in any deep way that this works.

1017
00:49:02,360 --> 00:49:02,980
还有 为什么呢
And why?

1018
00:49:03,900 --> 00:49:06,520
为什么我就能假设
Now why is it the case that I can presume,maybe,

1019
00:49:06,640 --> 00:49:07,920
假设我能把成功移动这三个盘子
that I can move the three-high tower.

1020
00:49:11,080 --> 00:49:12,260
好吧 这是因为
Well the answer is because

1021
00:49:12,540 --> 00:49:13,660
我总能减小问题的规模
I'm always counting down,

1022
00:49:14,080 --> 00:49:15,960
然后最终是0个盘子的移动问题
and eventually I get down to zero-high tower,

1023
00:49:16,200 --> 00:49:17,800
0个盘子不需要移动
and a zero-high tower requires no moves.

1024
00:49:19,800 --> 00:49:21,680
现在可以写出整个过程的算法了
So let's write the algorithm for that.

1025
00:49:23,820 --> 00:49:24,400
很简单
Very easy.

1026
00:49:26,120 --> 00:49:28,720
我会给这些柱子编号
I'm going to label these towers with numbers,

1027
00:49:28,720 --> 00:49:30,120
但它们各自编号成什么无关紧要
but it doesn't matter what they're labelled with.

1028
00:49:30,780 --> 00:49:32,800
问题就是把n个盘子
And the problem is to move an n-high tower

1029
00:49:33,800 --> 00:49:36,440
从一个起始柱移到终点柱
from a spike called From to a spike called To

1030
00:49:36,620 --> 00:49:38,240
另一个柱子作为中转 称作中转柱
with a particular spike called Spare.

1031
00:49:39,520 --> 00:49:40,200
这就是主要的过程
That's what we're going to do.

1032
00:49:48,700 --> 00:49:52,120
用这个我非形式化描述的算法
Using the algorithm I informally described to you,

1033
00:49:52,720 --> 00:50:01,700
把n个盘子从起始柱移到终点柱 另一个柱子作为中转
move of a n-high tower from From to To with a Spare.

1034
00:50:05,940 --> 00:50:08,480
接着就有两种情况了
Well,I've got two cases,

1035
00:50:09,220 --> 00:50:10,480
就要分析都是怎样的情况
and this is a case analysis,

1036
00:50:10,940 --> 00:50:14,360
就像之前所做的分析一样
just like it is in all the other things we've done.

1037
00:50:20,920 --> 00:50:21,840
如果n等于0 那么
If n is 0,then

1038
00:50:22,780 --> 00:50:24,940
我会输出一些东西 输出"Done"
-- I'm going to put out some answers-- Done,we'll say.

1039
00:50:26,560 --> 00:50:27,560
我不知道那代表什么意思
I don't know what that means

1040
00:50:29,360 --> 00:50:31,160
因为我们也不会遇到这样的情况
Because we'll never use that answer for anything.

1041
00:50:31,640 --> 00:50:32,620
我们还是会移动盘子的
We're going to do these moves.

1042
00:50:34,000 --> 00:50:34,380
否则
Else.

1043
00:50:36,280 --> 00:50:37,320
就移动一次
I'm going to do a move.

1044
00:50:39,900 --> 00:50:42,360
移动少于n个盘子
Move a tower of height less than n,

1045
00:50:44,160 --> 00:50:46,300
也就是n-1个盘子
the decrement of n height.

1046
00:50:47,740 --> 00:50:50,080
把它们移到中转柱上
Now,I'm going to move it to the Spare tower.

1047
00:50:50,720 --> 00:50:51,720
整体的思想就是
The whole idea now

1048
00:50:52,020 --> 00:50:53,880
把它们从这里移到这里
is to move this from here to here,

1049
00:50:54,940 --> 00:50:55,600
移到中转柱
to the Spare tower

1050
00:50:55,860 --> 00:50:57,160
从起始柱到中转柱
-- so from From to Spare--

1051
00:51:02,340 --> 00:51:04,380
用终点柱作为中转
using To as a spare tower.

1052
00:51:08,560 --> 00:51:10,080
之后某个时候
Later,somewhere later,

1053
00:51:10,080 --> 00:51:14,800
我就会移动之前的那n个盘子
I'm going to move that same n-high tower,

1054
00:51:15,240 --> 00:51:16,160
在那之前已经完成了这个盘子的移动
after I've done this.

1055
00:51:17,340 --> 00:51:20,200
要移动n个盘子同样的道理就要上面的n-1个盘子
Going to move that same n minus one-high tower

1056
00:51:20,620 --> 00:51:23,540
从中转柱移到终点柱
from the Spare tower to the To tower

1057
00:51:23,940 --> 00:51:25,860
用起始柱作为中转
using the From tower as my spare.

1058
00:51:29,060 --> 00:51:39,040
编写成代码就是从中转柱移动到终点柱
So the Spare tower to the To tower

1059
00:51:40,040 --> 00:51:44,140
用起始柱作为中转
using the From as the spare.

1060
00:51:48,440 --> 00:51:49,580
当进行到这种情况
All I have to do now

1061
00:51:50,020 --> 00:51:51,840
剩下要做的事情就是
is when I've gotten it in this condition,

1062
00:51:52,100 --> 00:51:55,080
现在就是这种情况
between these two moves of a whole tower

1063
00:51:56,260 --> 00:51:57,420
在两次移动同一堆盘子之间
-- I've got it into that condition--

1064
00:51:57,580 --> 00:52:00,480
只需移动一个盘子
now I just have to move one disk.

1065
00:52:02,820 --> 00:52:03,380
所以我想要说的就是
So I'm going to say that

1066
00:52:03,380 --> 00:52:04,300
有个什么过程输出一条信息表示做了一次盘子的移动
some things are printing a move

1067
00:52:04,300 --> 00:52:05,200
不管这个过程具体怎么实现的
and I don't care how it works.

1068
00:52:11,340 --> 00:52:13,900
把盘子从起始柱移动到终点柱
From to To.

1069
00:52:17,420 --> 00:52:19,780
现在大家就能明白为何我在这个时候举这样一个例子
Now,you see the reason why I'm bringing this up

1070
00:52:19,780 --> 00:52:23,060
是因为在某种程度上
at this moment is this is an almost identical program

1071
00:52:23,060 --> 00:52:25,060
这个程序和之前这个程序几乎一样
to this one in some sense.

1072
00:52:26,600 --> 00:52:28,940
尽管它们所求解的问题不一样
It's not computing the same mathematical quantity,

1073
00:52:29,240 --> 00:52:30,940
演化出的递归树也不尽相同
it's not exactly the same tree,

1074
00:52:31,220 --> 00:52:32,320
但不管怎样都会在计算过程中演化出一棵递归树
but it's going to produce a tree.

1075
00:52:34,300 --> 00:52:36,180
移动这些盘子的过程
The general way of making these moves

1076
00:52:36,920 --> 00:52:39,580
会导致生成一棵指数树
is going to lead to an exponential tree.

1077
00:52:41,380 --> 00:52:43,060
好了 接下来试着来移动4个盘子
Well,let's do this four-high.

1078
00:52:44,100 --> 00:52:47,220
我还是得看着小抄来移盘子
I have my little crib sheet here

1079
00:52:49,240 --> 00:52:50,400
不然会弄错
otherwise I get confused.

1080
00:52:54,360 --> 00:52:56,480
好了 下面形式化地提出这个问题
Well,what I'm going to put in is the question of

1081
00:52:56,700 --> 00:53:05,400
把4个摞在一起的盘子
move a tower of height four

1082
00:53:06,240 --> 00:53:08,500
从1号柱子移动到2号
from one to spike two

1083
00:53:08,660 --> 00:53:10,460
用3号柱子作为中转
using spike three as a spare.

1084
00:53:11,680 --> 00:53:12,720
这就是接下来我要做的
That's all I'm really going to do.

1085
00:53:13,860 --> 00:53:15,140
好吧 开始吧
You know,let's just do it.

1086
00:53:15,140 --> 00:53:16,120
我不打算写出
I'm not going to worry about

1087
00:53:16,120 --> 00:53:17,580
过程执行的具体步骤
writing out the trace of this.

1088
00:53:17,620 --> 00:53:18,540
你自己可以做到
You can do that yourself

1089
00:53:19,560 --> 00:53:20,380
因为那很简单
because it's very simple.

1090
00:53:21,620 --> 00:53:24,580
我要把1号柱子上的一个盘子移动到3号柱子上
I'm going to move disk one to disk three.

1091
00:53:26,300 --> 00:53:28,100
这是怎么回事呢
And how do I get to move disk one to disk three?

1092
00:53:28,280 --> 00:53:28,940
我怎么知道要这么做呢
How do I know that?

1093
00:53:29,180 --> 00:53:30,820
好吧 我想还是得查看一下程序执行的具体步骤
Well,I suppose I have to look at the trace a little bit.

1094
00:53:32,420 --> 00:53:33,220
才能明白我这是在做什么
What am I doing here?

1095
00:53:33,520 --> 00:53:34,440
好吧 这个不等于
Well,and this is not--

1096
00:53:34,440 --> 00:53:35,340
n不等于0
n is not zero.

1097
00:53:36,400 --> 00:53:37,860
那我看一下这里过程的定义
So I'm going to look down here.

1098
00:53:38,340 --> 00:53:40,220
这得需要两次移动
This is going to require doing two moves.

1099
00:53:40,640 --> 00:53:41,680
只观察第一次吧
I'm only going to look at the first one.

1100
00:53:41,940 --> 00:53:43,160
第一次是说把
It's going to require moving--

1101
00:53:47,500 --> 00:53:48,880
我怎么写成了移动一座塔
why do I have move tower?

1102
00:53:48,880 --> 00:53:50,340
塔可不好移
It makes it harder for me to move.

1103
00:53:52,580 --> 00:53:56,280
我要移动摞成一摞的3个盘子
I'm going to move a three-high tower

1104
00:53:57,560 --> 00:53:59,460
从起始柱
from the From place,

1105
00:53:59,580 --> 00:54:00,340
也就是4号柱（教授不小心犯错 译者注）
which is four,

1106
00:54:01,400 --> 00:54:02,160
移动到中转柱
to the Spare,

1107
00:54:02,320 --> 00:54:03,140
即2号柱
which is two,

1108
00:54:03,900 --> 00:54:06,400
用3号柱
using three as my

1109
00:54:07,960 --> 00:54:09,800
不 用 用
-- no,using,using--

1110
00:54:09,980 --> 00:54:15,740
学生 [听不清]
STUDENT: [INAUDIBLE PHRASE]

1111
00:54:15,820 --> 00:54:16,920
教授 啊 是这样 抱歉
PROFESSOR: Yes,I'm sorry.

1112
00:54:17,540 --> 00:54:18,880
从2号柱
From two--

1113
00:54:19,340 --> 00:54:25,680
从1号柱到3号柱用2号柱作为中转
from one to three using two as my spare.

1114
00:54:25,900 --> 00:54:26,200
这就对了
That's right.

1115
00:54:27,140 --> 00:54:31,200
之后这儿还有一次移动
And then there's another move over here afterwards.

1116
00:54:32,800 --> 00:54:33,580
现在可以说
So now I say,

1117
00:54:33,880 --> 00:54:34,320
啊 是的
oh,yes,

1118
00:54:34,420 --> 00:54:37,880
接下来还得把之上两个盘子
that requires me moving a two-high tower

1119
00:54:38,680 --> 00:54:42,140
从1号柱移动到2号柱 用3号柱作为中转
from one to two using three as a spare.

1120
00:54:43,000 --> 00:54:43,960
同样的还得再移一次
And so,are the same,

1121
00:54:44,580 --> 00:54:45,980
接下来 又要移动
and that's going to require me moving

1122
00:54:47,540 --> 00:54:52,000
一个盘子 从1号柱到2号柱
a one-high tower from one to three

1123
00:54:52,180 --> 00:54:53,220
用2号柱作为中转
using two as a spare.

1124
00:54:57,500 --> 00:54:59,300
好了 当然之后还得再移一次
Well,and then there's lots of other things to be done.

1125
00:55:03,260 --> 00:55:05,080
于是我把1个盘子
So I move my one-high tower

1126
00:55:06,160 --> 00:55:09,220
从1号柱移动到3号柱 用2号柱作为中转
from one to three using two as a spare,

1127
00:55:09,220 --> 00:55:10,300
实际上没用到2号柱
which I didn't do anything with.

1128
00:55:11,140 --> 00:55:12,800
好了 整个过程还是非常简单的
Well,this thing just proceeds very simply.

1129
00:55:15,300 --> 00:55:16,660
接下来我把这个盘子从1号柱移到2号柱
I move this from one to two.

1130
00:55:17,360 --> 00:55:19,260
然后把这个盘子从3号柱移动到2号柱
And I move this disk from three to two.

1131
00:55:20,980 --> 00:55:22,120
其实我不想移了
And I don't really want to do it,

1132
00:55:22,520 --> 00:55:23,800
但还得继续 从1到3
but I move from one to three.

1133
00:55:24,680 --> 00:55:26,480
然后从2到1
Then I move two to one.

1134
00:55:29,040 --> 00:55:30,400
从2到3
Then I move two to three.

1135
00:55:31,940 --> 00:55:34,900
从1到3
Then one to three.

1136
00:55:35,940 --> 00:55:36,820
1到2
One to two.

1137
00:55:39,360 --> 00:55:41,040
3到2
Three to two.

1138
00:55:41,800 --> 00:55:42,560
3到1
Three to one.

1139
00:55:44,060 --> 00:55:45,540
当然了这是因为我之前已经准备好了
This all got worked out beforehand,of course.

1140
00:55:46,040 --> 00:55:46,700
2到1
Two to one.

1141
00:55:47,480 --> 00:55:48,980
3到2
Three to two.

1142
00:55:49,780 --> 00:55:51,420
1到3
One to three.

1143
00:55:52,920 --> 00:55:54,040
学生 [听不清]
STUDENT: [INAUDIBLE PHRASE].

1144
00:55:54,060 --> 00:55:54,840
教授 噢 从1到3
PROFESSOR: Oh,one to three.

1145
00:55:54,840 --> 00:55:55,780
抱歉 谢谢提醒
Excuse me.Thank you.

1146
00:55:56,080 --> 00:55:56,840
1到2
One to two.

1147
00:55:58,720 --> 00:56:01,520
然后3到2 呼
And then three to two.Whew.

1148
00:56:03,880 --> 00:56:05,920
现在请大家思考
Now what I'd like you to think about,

1149
00:56:07,120 --> 00:56:08,820
你们刚才看到的是解决这个问题的递归算法
you just saw a recursive algorithm for doing this,

1150
00:56:09,100 --> 00:56:10,340
显然要耗费指数级的时间
and it takes exponential time,of course.

1151
00:56:11,120 --> 00:56:12,220
不知道是否有别的算法
Now,I don't know if there's any algorithm

1152
00:56:12,220 --> 00:56:14,060
不用耗费指数级的时间 它一定会耗费指数级的时间
that doesn't take exponential time-- it has to.

1153
00:56:14,440 --> 00:56:15,920
因为我每次只能移动一个盘子
As I'm doing one operation

1154
00:56:15,920 --> 00:56:17,240
每次只能移动一个盘子
-- I can only move one thing at a time--

1155
00:56:17,540 --> 00:56:19,240
没有什么算法不用耗费指数级的时间
there's no algorithm that's not going to take exponential time.

1156
00:56:21,420 --> 00:56:22,640
但是 你能写出迭代的算法
But can you write an iterative algorithm

1157
00:56:23,640 --> 00:56:25,160
而不是递归的算法么
rather than a recursive algorithm for doing this?

1158
00:56:28,360 --> 00:56:30,260
我一直爱琢磨
One of the sort of little things I like to think about

1159
00:56:32,320 --> 00:56:34,840
能否给出一个算法
Can you write one that,

1160
00:56:35,040 --> 00:56:39,060
不是像我描述的这样
in fact,doesn't break this problem

1161
00:56:39,080 --> 00:56:40,560
把一个问题分解成两个子问题
into two sub-problems the way I described,

1162
00:56:41,020 --> 00:56:43,200
而是用一个更局部的规则
but rather proceeds a step at a time

1163
00:56:43,260 --> 00:56:44,800
一次演化出整个计算过程
using a more local rule.

1164
00:56:47,760 --> 00:56:48,480
那可能会很有趣
That might be fun.

1165
00:56:50,340 --> 00:56:51,720
谢谢大家 第三部分结束
Thank you so much for the third segment.

1166
00:56:55,880 --> 00:56:56,380
有什么问题要问么
Are there questions?

1167
00:56:57,400 --> 00:56:58,280
学生 我想知道有没有什么办法
STUDENT: I wonder if there's a way

1168
00:56:58,280 --> 00:57:01,660
能减小递归过程的代价
to reduce a tree or recursion problem,

1169
00:57:02,060 --> 00:57:05,660
能否把中间过程
how do you save the intermediate work

1170
00:57:05,760 --> 00:57:08,180
计算出的斐波那契数保存下来
you have done in computing the Fibonacci number?

1171
00:57:09,000 --> 00:57:10,100
教授 呃 好吧 实际上
PROFESSOR: Oh,well,in fact,one way,that

1172
00:57:11,200 --> 00:57:13,120
你刚才说的就是一种办法
one of the ways to do is what you just said.

1173
00:57:13,580 --> 00:57:16,500
你说  把中间过程的结果保存下来 是吧
You said,I save the intermediate work.OK?

1174
00:57:16,620 --> 00:57:18,360
好的 我告诉你
Well,let me tell you

1175
00:57:18,940 --> 00:57:20,100
再次说一下 我们后面会见到
-- this,again,we'll see later--

1176
00:57:20,720 --> 00:57:21,820
但现在假设就是这种情形
but suppose it's the case

1177
00:57:22,360 --> 00:57:24,060
不论何时做怎样的计算
that anytime I compute anything,

1178
00:57:24,340 --> 00:57:25,720
所有的这些斐波那契数
any one of these Fibonacci numbers,

1179
00:57:26,400 --> 00:57:27,620
我记录一个表
I remember the table

1180
00:57:27,900 --> 00:57:28,920
在表中查询
that takes only linear time

1181
00:57:28,920 --> 00:57:31,580
只用线性的时间
to look up the answer.

1182
00:57:32,720 --> 00:57:33,660
如果我已经计算过了
Then if I ever see it again,

1183
00:57:33,660 --> 00:57:35,340
就不再递归地求解了
instead of doing the expansional tree,

1184
00:57:35,620 --> 00:57:36,100
是直接在表中查询
I look it up.

1185
00:57:36,700 --> 00:57:37,940
我把问题
I've just transformed my problem

1186
00:57:38,780 --> 00:57:39,840
变得简单多了
into a problem that's much simpler.

1187
00:57:40,980 --> 00:57:41,620
当然
Now,of course,

1188
00:57:42,260 --> 00:57:43,560
这种方法已经被使用了
there are the way to do this,as well.

1189
00:57:44,240 --> 00:57:45,340
这种方法叫作记忆化
That one's called memoization,

1190
00:57:45,340 --> 00:57:47,620
这学期你们就会遇到
and you'll see it sometime later in this term.

1191
00:57:48,240 --> 00:57:53,280
但我认为还有个方法是线性时间复杂度的
But I suppose there's a very simple linear time and,

1192
00:57:53,360 --> 00:57:55,920
实际上 是用迭代模型计算斐波那契数
in fact,iterative model for computing Fibonaccis,

1193
00:57:56,660 --> 00:57:58,200
这也是需要各位坐下来仔细思考的
and that's another thing you should sit down and work out.

1194
00:58:00,080 --> 00:58:00,720
这很重要
That's important.

1195
00:58:01,260 --> 00:58:02,620
明白怎么运用迭代模型很重要
It's important to see how to do this.

1196
00:58:05,200 --> 00:58:06,060
希望大家多练习一下
I want you to practice.

1197
00:58:06,500 --> 00:58:08,100
MIT OpenCourseWare
http://ocw.mit.edu

1198
00:58:08,100 --> 00:58:10,240
本项目主页
https://github.com/FoOTOo/Learning-SICP

