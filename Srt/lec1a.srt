哈尔滨工业大学 IBM技术中心
FoOTOo实验室

字幕 && 时间轴：邓雄飞（Dysprosium)
校对：吴　晋（Cliff Woo）


欢迎大家来一起学习这门计算机科学的基础课程
I'd like to welcome you to this course on computer science. 

事实上 以这样的方式来表述并不恰当
Actually, that's a terrible way to start.

于此来说 计算机科学是个糟糕的名字
Computer science is a terrible name for this business.

首先 它不算是一门科学
First of all, it's not a science.

它更应该被称为工程或者是艺术
It might be engineering or it might be art,

但我们实际上会发现，这个所谓的计算机科学
but we'll actually see that computer so-called science

却与魔法一样的有众多神奇之处
actually has a lot in common with magic,

这些将会在课程中一一体现
and we'll see that in this course.

所以 不能称其为一门科学
So it's not a science.

这门学科和“计算机”也并非紧密相关
It's also not really very much about computers.

类似的，就像我们说
And it's not about computers in the same sense 

物理学中并不仅仅有关粒子加速器
that physics is not really about particle accelerators, 

生物学中并不全然是显微镜和培养皿一样
and biology is not really about microscopes and petri dishes.

同理
And it's not about computers in the same sense

几何学中也并不全然是介绍如何使用测量仪器
that geometry is not really about using surveying instruments.

事实上 计算机科学和几何学有很多共性
In fact, there's a lot of commonality between computer science and geometry.

首先 几何学
Geometry, first of all,

只是另一个有个糟糕名字的学科
is another subject with a lousy name.

这个名字来自于Gaia 意为土地
The name comes from Gaia, meaning the Earth,

以及metron 意为测量
and metron, meaning to measure.

几何学最初意为测地或者勘探
Geometry originally meant measuring the Earth or surveying.

这是因为数千年前的埃及祭司
And the reason for that was that, thousands of years ago,

为了计算如何去修复年年被尼罗河的洪水
the Egyptian priesthood developed the rudiments of geometry

所毁坏的牧田边界
in order to figure out how to restore the boundaries of fields

而建立了几何学基础
that were destroyed in the annual flooding of the Nile.

而对出于这个目的的埃及人来说
And to the Egyptians who did that,

几何学的确是掌握对测量仪器的使用
geometry really was the use of surveying instruments.

现在 我们以为计算机科学就是介绍计算机的使用
Now, the reason that we think computer science is about computers

就正如埃及人认为
is pretty much the same reason that the Egyptians thought geometry

几何学是介绍如何使用测量仪器的。
was about surveying instruments.

换句话说 任何一门学科起步的时候
And that is, when some field is just getting started 

你都对它了解不深
and you don't really understand it very well,

这很容易使你混淆所做的事与所用之物
it's very easy to confuse the essence of what you're doing with the tools that you use.

确实 就绝对规模来说
And indeed, on some absolute scale of things, 

我们对计算机科学的实质的了解
we probably know less about the essence of computer science

比埃及人对几何学的了解还少
than the ancient Egyptians really knew about geometry.

那么 我所谓的计算机科学的本质是什么呢
Well, what do I mean by the essence of computer science? 

我所谓的几何学本质又是什么呢
What do I mean by the essence of geometry?

看 可以确认的是古埃及人确实使用测量仪器
See, it's certainly true that these Egyptians went off

并且已经消失多年
and used surveying instruments,

但当我们在几千年后回过头来重新审视这段历史
but when we look back on them after a couple of thousand years,

我们会说
we say,

天啊 看他们在做什么
gee, what they were doing,

他们的工作是多么的重要
the important stuff they were doing,

已经开始对时间和空间进行形式化表述
was to begin to formalize notions about space and time,

并归纳出一套讨论数学真理的形式化方法
to start a way of talking about mathematical truths formally.

这直接导致了公理化方法
That led to the axiomatic method.

以及各种现代数学的产生
That led to sort of all of modern mathematics,

同时也指明了一种精确讨论
figuring out a way to talk precisely about

所谓的描述真理的陈述性知识的方法
so-called declarative knowledge, what is true.

与此相似的 我认为未来人们会回过头来审视并说
Well, similarly, I think in the future people will look back and say,

啊 这些20世纪的原始人
yes, those primitives in the 20th century were fiddling around

不务正业地玩弄着叫计算机的小玩意
with these gadgets called computers,

但它们真正在做的是开始学习
but really what they were doing is starting to learn

如何去对计算过程进行形式化表述
how to formalize intuitions about process,

如何去解决问题
how to do things,

并结合两者发展一套对问题处理过程精确表述的方法
starting to develop a way to talk precisely about how-to knowledge,

这与讨论真理的几何学形成了对照
as opposed to geometry that talks about what is true.

让我给你们举个例子吧
Let me give you an example of that.

来瞧瞧
Let's take a look

数学中是这样来定义平方根的:
Here is a piece of mathematics that says what a square root is.

定义X的平方根Y是这样一个数
The square root of X is the number Y,

Y的平方等于X 且Y大于等于0
such that Y squared is equal to X and Y is greater than 0.

这是一个很好的定义
Now, that's a fine piece of mathematics,

但它只告诉了你平方根是什么
but just telling you what a square root is 

却没有告诉你如何去求取一个平方根
doesn't really say anything about how you might go out and find one.

那么我们将其与一条过程性知识做比较
So let's contrast that with a piece of imperative knowledge,

你如何去求取一个平方根
how you might go out and find a square root.

事实上 这来自于埃及 不太久远的埃及
This, in fact, also comes from Egypt, not ancient, ancient Egypt.

亚历山大的Heron提出的一个算法
This is an algorithm due to Heron of Alexandria,

称作连续取均值求平方根法
called how to find a square root by successive averaging.

这个算法是说
And what it says is that,

为了算出平方根
in order to find a square root,

首先你应该给出一个假定值guess 并不断迭代
you make a guess, you improve that guess --

迭代的方法是通过
and the way you improve the guess

不断求假定值guess与X/guess的平均值
is to average the guess and X over the guess,

我们稍后将会讨论
and we'll talk a little bit later about

为什么这是合理的
why that's a reasonable thing--

通过不断迭代 直到它足够精确
and you keep improving the guess until it's good enough.

这就是实现方法。
That's a method.

这也是如何完成一项工作与
That's how to do something as opposed to 

其对应的陈述性知识的对照
declarative knowledge that says what you're looking for.

这就是一个过程
That's a process.

那么  通常来说什么是过程呢？
Well, what's a process in general?

这定义起来非常困难
It's kind of hard to say.

你可以把它看作一种活在计算机内
You can think of it as like a magical spirit

并且可以完成一些事的魔法精灵
that sort of lives in the computer and does something. 

一些称为程序的规则模式
And the thing that directs a process is

指导着这类过程的进行
a pattern of rules called a procedure.

这些程序便是符咒
So procedures are the spells, if you like,

（程序）控制这些魔法精灵（完成一些事）就叫做过程
that control these magical spirits that are the processes.

你们知道人人都需要一门魔法语言
I guess you know everyone needs a magical language,

那些魔术师 真正的魔术师 用远古的阿卡狄亚语
and sorcerers, real sorcerers,

或者苏美尔语 或者巴比伦语 或者其它的
use ancient Arcadian or Sumerian or Babylonian or whatever.

而我们将用一门叫Lisp的魔法语言
We're going to conjure our spirits

来召唤出我们的精灵
in a magical language called Lisp,

这门语言是被设计用来
which is a language designed for talking about,

编写如咒语版的程序 来指导过程的进行
for casting the spells that are procedures to direct the processes.

学习Lisp非常容易
Now, it's very easy to learn Lisp.

事实上 我会在几分钟内教会你
In fact, in a few minutes, I'm going to teach you,

基本上 整个Lisp
essentially, all of Lisp.

我也会教你 基本上 所有的规则
I'm going to teach you, essentially, all of the rules.

你不会感到特别的吃惊
And you shouldn't find that particularly surprising.

这就像你在学习象棋时
That's sort of like saying it's very easy

认为象棋的规则十分简单一样
to learn the rules of chess.

事实也如此 几分钟内
And indeed, in a few minutes,

你可以与任何人谈论象棋的规则
you can tell somebody the rules of chess.

但是 这全然不等同于说
But of course, that's very different from

你所知道这些规则所蕴含的东西
saying you understand the implications of those rules

以及如何利用这些规则去成为象棋大师
and how to use those rules to become a masterful chess player.

Lisp亦如此
Well, Lisp is the same way.

我将在几分钟内道清规则
We're going to state the rules in a few minutes,

这说起来非常容易
and it'll be very easy to see.

但真正困难的是如何运用这些规则
But what's really hard is going to be the implications of those rules,

以及你如何利用这些规则成为编程大师
how you exploit those rules to be a master programmer.

这些规则的应用将占据我们
And the implications of those rules are going to take us the,

余下的课程 甚至更多
well, the whole rest of the subject and, of course, way beyond.

所以 在计算机科学中
OK, so in computer science,

我们的任务则是
we're in the business of

形式化这种如有关“怎么办”的过程性知识
formalizing this sort of how-to imperative knowledge,

如何将之付诸实际
how to do stuff.

这也便是计算机科学的真正的议题
And the real issues of computer science are, of course,

当然 并不是告诉人们如何去求平方根
not telling people how to do square roots.

因为如果那是计算机科学的全部的的话
Because if that was all it was,

就不会有什么大问题了
there wouldn't be no big deal.

真正的问题来自于当我们尝试
The real problems come when we try to 

构建非常非常大的系统时
build very, very large systems,

以至于程序可以长达数千页
computer programs that are thousands of pages long,

长得没有人能马上将其装入脑中
so long that nobody can really hold them in their heads all at once.

而使这成为现实的则是因为
And the only reason that that's possible is because

我们有在大系统中控制复杂度的技术
there are techniques for controlling the complexity of these large systems.

这些控制复杂度的技术
And these techniques that are controlling complexity

正是我们课程所讨论的
are what this course is really about.

从某种意义上来说
And in some sense,

这也正是计算机科学所在
that's really what computer science is about.

这样说或许会很奇怪
Now, that may seem like a very strange thing to say.

毕竟 除了计算机科学家外
Because after all, a lot of people besides computer scientists

仍然有很多人与控制复杂度打交道
deal with controlling complexity.

一个航班就是一个非常复杂的系统
A large airliner is an extremely complex system,

设计那个的航空工程师
and the aeronautical engineers who design that

便在处理这个巨大的复杂度
are dealing with immense complexity.

但这种复杂度又与
But there's a difference between that kind of complexity

计算机科学中的（复杂度）有别
and what we deal with in computer science.

从某种意义上来说
And that is that computer science,

因为计算机科学不是真实的 --存疑
in some sense, isn't real.

例如 当一名工程师设计物理系统时
You see, when an engineer is designing a physical system,

这些都是由真实的部分构成
that's made out of real parts.

负责的该工作得到工程师
The engineers who worry about that

就得对付系统中的公差、近似值以及噪声
have to address problems of tolerance and approximation and noise in the system.

譬如说 作为一名电气工程师
So for example, as an electrical engineer,

我可以很容易的做一个单极放大器
I can go off and easily build a one-stage amplifier

或者是一个双极放大器
or a two-stage amplifier,

我也可想象将其大量串联
and I can imagine cascading a lot of them

来建造一个百万极的放大器
to build a million-stage amplifier.

但这样做是很荒谬的
But it's ridiculous to build such a thing,

因为在远没到百万极的时候
because long before the millionth stage,

这种组合方法打从头产生的热噪声
the thermal noise in those components way at the beginning

会慢慢增强 并使得我们的幸苦付之一炬
is going to get amplified and make the whole thing meaningless.

计算机科学处理的是理想化组件
Computer science deals with idealized components.

我们对将要结合在一起的
We know as much as we want about these little program 

程序和数据了如指掌
and data pieces that we're fitting things together.

我们不需要去关心公差
We don't have to worry about tolerance.

也就是说 在建立大项目时
And that means that, in building a large program,

在我所能做和我所能想之间
there's not all that much difference

并不没有太大的不同
between what I can build and what I can imagine,

因为这些部分都是抽象单元
because the parts are these abstract entities

我可以随心所欲的
that I know as much as I want.

-- 待议
I know about them as precisely as I'd like.

这便与其它的工程不同
So as opposed to other kinds of engineering,

（在其它的工程中）来自于物理系统的约束
where the constraints on what you can build

便是你可做之事的约束
are the constraints of physical systems,

物理定律 噪声 近似值的约束
the constraints of physics and noise and approximation,

而建立大型软件系统时所施加的约束
the constraints imposed in building large software systems

就是对我们大脑的限制
are the limitations of our own minds.

从这个角度来看
So in that sense,

计算机科学就像是工程中的一种抽象形式
computer science is like an abstract form of engineering.

在这种工程中 我们忽略
It's the kind of engineering where you ignore

现实所施加的约束
the constraints that are imposed by reality.

那么 这其中有哪些技术呢
Well, what are some of these techniques?

计算机科学中并没有特别的技术
They're not special to computer science.

第一个技术 在所有的工程中都有使用
First technique, which is used in all of engineering,

是一种叫“黑箱抽象”的抽象
is a kind of abstraction called black-box abstraction.

取用一些东西并将其封装成箱子
Take something and build a box about it.

举个例子 如果我们审视求取平方根的方法
Let's see, for example, if we looked at that square root method,

我会取用它们作为一个箱子
I might want to take that and build a box.

也就是说 为了找到X的平方根
That sort of says, to find the square root of X.

或许会有一系列的复杂规则
And that might be a whole complicated set of rules.

最后我会得到一个可以输入某物的东西
And that might end up being a kind of thing where I can put in,

输入36 然后说36的平方根是多少呢
say, 36 and say, what's the square root of 36?

输出6
And out comes 6.

重点则是
And the important thing is that

我这样去设计它 就可以使得
I'd like to design that so that

如果George想要计算
if George comes along and would like to compute,

它想计算A的平方根加上B的平方根
say, the square root of A plus the square root of B,

它就可以像使用模块一样使用这个到箱子
he can take this thing and use it as a module 

而无需看箱子里面
without having to look inside 

它可以像这样创立东西
and build something that looks like this, 

A和B以及一个平方根和或者另一个平方根箱子
like an A and a B and a square root box and another square root box 

然后某个东西将这些结果加在一起并输出答案
and then something that adds that would put out the answer.

如你所见 就我想实现的功能来说
And you can see, just from the fact that I want to do that,

对于George来说
is from George's point of view,

内部有什么并不重要
the internals of what's in here should not be important.

例如 我这样写无关紧要
So for instance, it shouldn't matter that, when I wrote this,

我说求X的平方根
I said I want to find the square root of X.

我亦可说找Y的平方根
I could have said the square root of Y,

或者说找A的平方根 或者是其它任何东西
or the square root of A, or anything at all

黑箱抽象的基本观念则是
That's the fundamental notion of putting something in a box

把东西放入箱子里以隐藏细节
using black-box abstraction to suppress detail.

这样做的原因则是你可以脱身去构建更大的箱子
And the reason for that is you want to go off and build bigger boxes.

现在 除了隐藏细节外
Now, there's another reason for doing black-box abstraction

使用黑盒抽象还有另外一个原因
other than you want to suppress detail for building bigger boxes.

有时 你想要用你的方式去完成一件事
Sometimes you want to say that your way of doing something,

你自己的方式
your how-to method,

这就是一个一般的事的实例
is an instance of a more general thing,

并且你也希望你的方式能够表达那种一般性
and you'd like your language to be able to express that generality.

我再举一例
Let me show you another example 

继续平方根的讨论
sticking with square roots. 

让我们回过头再来看看
Let's go back and take another look at that slide

求平方根的算法
with the square root algorithm on it.

想一想算法是怎么说的
Remember what that says.

算法说 为了求解 我先要作出猜测
That says, in order to do something, I make a guess,

然后我改进猜测并且不断的改进猜测
and I improve that guess, and I sort of keep improving that guess.

因此这就有一个找到某个到东西的通法
So there's the general strategy of, I'm looking for something,

就是我不断改进它
and the way I find it is that I keep improving it.

这里有个找到某个东西的不动点
Now, that's a particular case of another kind of strategy

的另一种策略的特别例子
for finding a fixed point of something.

每个函数都有一个不动点
So you have a fixed point of a function.

函数的不动点是一个值
A fixed point of a function is something, is a value.

F的不动点Y满足F(Y)=Y
A fixed point of a function F is a value Y, such that F of Y equals Y.

我可能会做的一件事就是开始做一个猜测
And the way I might do that is start with a guess.

我想要得到在我应用函数F时不会改变的东西
And then if I want something that doesn't change when I keep applying F,

我会不断应用函数F直到结果不会有很大改变
is I'll keep applying F over and over until that result doesn't change very much.

这便是一个通法
So there's a general strategy.

于此 为了计算X的平方根
And then, for example, to compute the square root of X,

我可以试着找到Y与X/Y的平均值函数的不动点
I can try and find a fixed point of the function which takes Y to the average of X/Y.

因为如果我真有一个等于X平方根的Y
And the idea that is that if I really had Y equal to the square root of X,

那么Y和X/Y应为同一值
then Y and X/Y would be the same value.

它们俩都是X的平方根
They'd both be the square root of X,

因为X除根号X得根号X
because X over the square root of X is the square root of X.

如果平均值Y等于X的平方根
And so the average if Y were equal to the square of X,

那么这个平均值就不会改变
then the average wouldn't change. 

因此X的平方根即是某一特定函数的不动点
So the square root of X is a fixed point of that particular function.

现在 我将要描述
Now, what I'd like to have, I'd like to express 

寻找不动点的通法
the general strategy for finding fixed points. 

我所能想象的 便是我可以
So what I might imagine doing, is to find,

用我自己的语言定义一个输出不动点的箱子
is to be able to use my language to define a box that says "fixed point,"

就如我可以定义一个输出平方根的盒子一样
just like I could make a box that says "square root."

我想要用自己的方法来实现
And I'd like to be able to express this in my language.

因此 对于这种“怎么办”的过程性知识
So I'd like to express not only the imperative how-to knowledge

我不仅是想表达具体的如何求平方根
of a particular thing like square root,

我也想去表达更加通用的
but I'd like to be able to express the imperative knowledge

如找不动点
of how to do a general thing like how to find fixed point.

让我们再回过头来看看
And in fact, let's go back and look at that slide again.

不但如何去找到一个不动点
See, not only is this a piece of imperative knowledge,

是一种过程性知识
how to find a fixed point,

在这下面  这里
but over here on the bottom,

这儿还有另一种过程性知识 说的是
there's another piece of imperative knowledge which says,

计算平方根的一种方法就是应用找不动点这种通法
one way to compute square root is to apply this general fixed point method.

因此我也想要表述这种过程性知识
So I'd like to also be able to express that imperative knowledge.

那又会是什么样呢
What would that look like?

这个不动点盒子可能会是这样
That would say, this fixed point box is such that

如果我输入一个函数 该函数从Y映射到Y和X/Y的平均值
if I input to it the function that takes Y to the average of Y and X/Y,

然后我们将会得到求不动点的箱子就是求平方根的一个方法
then what should come out of that fixed point box is a method for finding square roots.

因此在这些我们构建的箱子中
So in these boxes we're building,

输入和输出都不局限于数字
we're not only building boxes that you input numbers and output numbers,

我们将要构建能够
we're going to be building in boxes that,

输出找到平方根计算方法的盒子
in effect, compute methods like finding square root.

我用的是一个输入函数
And my take is their inputs functions,

比如Y映射到Y和X/Y的平均值的函数
like Y goes to the average of Y and X/Y.

我们想要这么做的原因则是
The reason we want to do that,

输入是一个过程 输出也是一个过程
the reason this is a procedure, will end up being a procedure,

（输出的那个）过程的值也是一个过程
as we'll see, whose value is another procedure,

我们这样做的原因则是
the reason we want to do that is because

程序将是我们讨论过程性知识的途径
procedures are going to be our ways of talking about imperative knowledge. 

这样做非常强大 是因为
And the way to make that very powerful is

我们能够讨论其它类型的知识
to be able to talk about other kinds of knowledge.

实际上 这个过程是讨论的另一个过程
So here is a procedure that, in effect, talks about another procedure,

一个讨论通法的通法
a general strategy that itself talks about general strategies.

那么 我们将有三个主要话题
Well, our first topic in this course-- 

而首个主题则是
there'll be three major topics-- 

黑箱抽象
will be black-box abstraction.

让我们稍稍深入一点
Let's look at that in a little bit more detail.

我们将讨论
What we're going to do is we will start out talking about

Lisp是如何通过初等建立起来的
how Lisp is built up out of primitive objects.

语言给我们提供了什么？
What does the language supply with us?

我们只能在这里看到初等过程和初等数据
And we'll see that there are primitive procedures and primitive data.

然后我们将会看到
Then we're going to see,

我们如何去用这些初等对象
how do you take those primitives and 

并把它们组合起来构建更复杂的东西
combine them to make more complicated things, 

组合的手段
means of combination?

我们将看到把事物结合在一起的方法
And what we'll see is that there are ways of putting things together,

将初等过程放在一起构建复杂的过程
putting primitive procedures together to make more complicated procedures.

我们也将看到如何将初等数据放在一起来构建复合数据
And we'll see how to put primitive data together to make compound data.

然后我们将会问到 把这些东西复合以后
Then we'll say, well, having made those compounds things,

你如何将它们抽象出来
how do you abstract them?

你如何用黑箱子包装它们
How do you put those black boxes around them

使得你可以将它们作为组件用于更复杂的东西
so you can use them as components in more complex things?

我们会发现这些都是通过定义程序
And we'll see that's done by defining procedures and

以及一种处理复合数据的叫做抽象的技术完成的
a technique for dealing with compound data called data abstraction.

以及 最重要的是
And then, what's maybe the most important thing,


is going from just the rules to how does an expert work?

你如何去表达做事情更普遍的方法 就比如
How do you express common patterns of doing things, like saying, well,

找不动点的方法
there's a general method of fixed point and

而找平方根是它的一个特法
square root is a particular case of that?

我们将会使用
And we're going to use--

我们已经提到过的
I've already hinted at it-- 

某种叫做高阶过程的东西
something called higher-order procedures,

亦即 它的输入输出和它本身都是过程
namely procedures whose inputs and outputs are themselves procedures.

我们将会看到一些有趣的东西
And then we'll also see something very interesting.

我们越深入 越抽象
We'll see, as we go further and further on and become more abstract,

那么将会发现
there'll be very--

我们认为是数据和我们认为是过程之间的
well, the line between what we consider to be data and

分界线将变得模糊到难以置信的程度
what we consider to be procedures is going to blur at an incredible rate.

这便是我们的第一个主题 黑箱抽象
Well, that's our first subject, black-box abstraction.

让我们来看看第二个主题
Let's look at the second topic.

这样说吧
I can introduce it like this.

假设我想表达某个想法
See, suppose I want to express the idea--

请注意 我们讨论的是想法
remember, we're talking about ideas--

假设我想表达某个想法 使得
suppose I want to express the idea that

我可以取用某个东西并将其与另两物之和相乘
I can take something and multiply it by the sum of two other things.

举例来说
So for example, I might say, 

我用1和3（之和）乘2 得8
if I had 1 and 3 and multiply that by 2, I get 8.

但我想说的是关于线性组合的普遍观念
But I'm talking about the general idea of what's called linear combination,

是说你可以将两物的和乘以另一物
that you can add two things and multiply them by something else.

在数集上思考这个问题是很容易的
It's very easy when I think about it for numbers,

但假设我亦想将此观念应用于
but suppose I also want to use that same idea to think about,

加和两向量a1和a2
I could add two vectors, a1 and a2,

并数乘某一因子x得另一向量
and then scale them by some factor x and get another vector.

我更可以说 若a1和a2皆为多项式
Or I might say, I want to think about a1 and a2 as being polynomials,

我想加和这两个多项式
and I might want to add those two polynomials and

让后加它们乘以2得到一个更复杂的
then multiply them by 2 to get a more complicated one.

a1或a2亦可为电信号
Or a1 and a2 might be electrical signals,

我想将此二电信号加和
and I might want to think about summing those two electrical signals and

并将所得放入一个放大器
then putting the whole thing through an amplifier,

用一个类似于2的因子乘以它们
multiplying it by some factor of 2 or something.

这种观念就是 我想用一个通用记号表示它们
The idea is I want to think about the general notion of that.

现在 如果我们的语言好得可以表达这种普遍观念
Now, if our language is going to be good language for expressing those kind of general ideas,

如果我真可以这样
if I really, really can do that,

我将会说
I'd like to be able to say

我将用x乘以a1和a2的和
I'm going to multiply by x the sum of a1 and a2,

而且我也想表达更普遍的观念
and I'd like that to express the general idea of

以至于适合各个不同种类的a1和a2
all different kinds of things that a1 and a2 could be.

现在回过头来想想 似乎有点问题 
Now, if you think about that, there's a problem,

毕竟 我加和两个数字和两个多项式
because after all, the actual primitive operations

所用的初等操作
that go on in the machine are obviously going to be different

在机器内部显然是不同的
if I'm adding two numbers than if I'm adding two polynomials,

甚至于我加和两个电信号或声波
or if I'm adding the representation of two electrical signals or wave forms.

总会有关于不同东西的认识
Somewhere, there has to be the knowledge of the kinds of various things

以及将它们加和在一起的方法
that you can add and the ways of adding them.

现在 为了构建这件一个系统
Now, to construct such a system,

问题是 我该将这种认识用于何处？
the question is, where do I put that knowledge?

我如在我面对的各种选择中作出抉择？ --待议
How do I think about the different kinds of choices I have?

而如果明天George想出了一种新类型的对象
And if tomorrow George comes up with a new kind of object

并将它用于加和以及乘积
that might be added and multiplied,

我又该如何把这个新类型引入到系统中
how do I add George's new object to the system

且不把已有的东西弄得一团糟
without screwing up everything that was already there?

这便是我们的第二大主题
Well, that's going to be the second big topic,

控制复杂度的方法
the way of controlling that kind of complexity.

这通过建立约定的接口实现
And the way you do that is by establishing conventional interfaces,

在把东西插入到一起的方法上打成共识
agreed upon ways of plugging things together.

就如同电气工程中
Just like in electrical engineering,

人们为连接器建立标准阻抗
people have standard impedances for connectors,

如果你用符合这个标准的东西构建系统的话
and then you know if you build something with one of those standard impedances,

你就知道你可以把东西组合在一起
you can plug it together with something else.

这又将是我们的第二大主题 约定的接口
So that's going to be our second large topic, conventional interfaces.

我们将要讨论通用操作
What we're going to see is, first, we're going to talk about the problem of generic operations,

也就如我提到的
which is the one I alluded to,

可以应用于各种数据的加法
things like "plus" that have to work with all different kinds of data.

所以我们讨论通用操作
So we talk about generic operations.

然后我们将讨论大型架构
Then we're going to talk about really large-scale structures.


How do you put together very large programs

that model the kinds of complex systems in the real world that you'd like to model?

我们将看到 在构建这样的系统时
And what we're going to see is that

有两周非常重要的隐喻
there are two very important metaphors for putting together such systems.

其一是面向对象编程
One is called object-oriented programming,

在这种模式中 你把你的系统想象成一种社会
where you sort of think of your system as a kind of society

这个社会中的小东西都是通过相互间传递消息联系起来的
full of little things that interact by sending information between them.

其二是关于聚集的操作 称作“流”
And then the second one is operations on aggregates, called streams,

你可以认为是 --待议
where you think of a large system put together kind of


like a signal processing engineer puts together a large electrical system.

这就是我们的第二个话题
That's going to be our second topic.

现在 我们将要讨论第三个话题
Now, the third thing we're going to come to,

控制复杂度的第三个技术
the third basic technique for controlling complexity,

便是定义新的语言
is making new languages.

因为有时 当你有点受不了设计的复杂度时
Because sometimes, when you're sort of overwhelmed by the complexity of a design,

你可以采取的控制复杂度的方法则是采用一门新语言
the way that you control that complexity is to pick a new design language.

新语言的设计意图则是突出系统的不同方面
And the purpose of the new design language will be to highlight different aspects of the system.

它隐藏某方面的细节但强调另外方面的细节
It will suppress some kinds of details and emphasize other kinds of details.

我们将来到本课中最神奇的部分
This is going to be the most magical part of the course.

我们将开始于构建新的计算机语言
We're going to start out by actually looking at the technology for building new computer languages.

而第一件事就是将其构建于Lisp中
The first thing we're going to do is actually build in Lisp.

我们用Lisp表达Lisp自我解释的过程
We're going to express in Lisp the process of interpreting Lisp itself.

这是一个非常类似于自循环的东西
And that's going to be a very sort of self-circular thing.

这与一个神奇的符号有关
There's a little mystical symbol that has to do with that.

解释Lisp的步骤是
The process of interpreting Lisp is sort of a giant wheel of two processes,

应用和求值——这两大步骤的轮转
apply and eval,

可以说两者不断地互相交替
which sort of constantly reduce expressions to each other.

然后 我们将看到其余的各种魔法
Then we're going to see all sorts of other magical things.

譬如另一种魔法符号
Here's another magical symbol.

一种叫做Y运算符的东西
This is sort of the Y operator,

某种意义上 它在我们过程式语言中用于 表达无限
which is, in some sense, the expression of infinity inside our procedural language.

我们也会谈论到它
We'll take a look at that.

言而总之 课程的这节被称作“元语言抽象”
In any case, this section of the course is called Metalinguistic Abstraction,

讨论你如何构建一门新语言的抽象
abstracting by talking about how you construct new languages.

如我所言 我们将从学习解释的过程开始
As I said, we're going to start out by looking at the process of interpretation.

我们将学习应用-求值循环和构建Lisp
We're going to look at this apply-eval loop, and build Lisp.

你将发现这是非常普遍的
Then, just to show you that this is very general,

我们将用同样的技术去构建一门全完不同的语言
we're going to use exactly the same technology to build a very different kind of language,

一种所谓的逻辑编程语言
a so-called logic programming language,

一种无关具有有输入和输出的过程的语言
where you don't really talk about procedures at all that have inputs and outputs.

而是一种讨论事物关系的语言
What you do is talk about relations between things.

最终 我们将讨论如何将这些东西
And then finally, we're going to talk about how you implement these things very concretely

实实在在的实现在简单的机器上
on the very simplest kind of machines.

比如说这个
We'll see something like this.

如图所示的芯片
This is a picture of a chip,

就是我们在硬件部分谈及的Lisp解释器
which is the Lisp interpreter that we will be talking about then in hardware.

这三大主题就是本课的提纲
Well, there's an outline of the course, three big topics.

黑箱抽象 约定的接口 元语言抽象
Black-box abstraction, conventional interfaces, metalinguistic abstraction.

好 先休息一会儿 然后正式开始
Now, let's take a break now and then we'll get started.

[音乐]
[JESU, JOY OF MAN'S DESIRING]

现在让我们正式开始学习Lisp
Let's actually start in learning Lisp now.

事实上 我们将开始学习一些更重要的事
Actually, we'll start out by learning something much more important,

或许将是本科中最重要的 不是Lisp本身
maybe the very most important thing in this course, which is not Lisp, 

而是一种的通用框架
in particular, of course, but rather a general framework

用于组织我之前提到的语言
for thinking about languages that I already alluded to.

当有人要想你展示一门新语言
When somebody tells you they're going to show you a language,

你应该问它
what you should say is,

（你的语言）所用的初等元素是什么？
what I'd like you to tell me is what are the primitive elements?

这门语言又配备了什么？
What does the language come with?

你又如何将它们放在一起？
Then, what are the ways you put those together?

组合的手段是什么？
What are the means of combination?

允许你将这些初等元素整合在一起
What are the things that allow you to take these primitive elements

以构建更大的对象的又是什么？
and build bigger things out of them?

把东西放在一起的方法是什么？
What are the ways of putting things together?

以及 抽象的方法是什么？
And then, what are the means of abstraction?

我们如何取用这些东西并把它们封装成箱子？
How do we take those complicated things and draw those boxes around them?

我们如何为它们命名使得我们可以
How do we name them so that we can now use them

把它们当作初等元素来用于构建更复杂的东西？
as if they were primitive elements in making still more complex things?

等等 等等 等等
And so on, and so on, and so on.

因此 当有人告诉你
So when someone says to you, gee,

嘿 我发明了一种新的计算机语言
I have a great new computer language,

你不应该问 用你的语言编写求逆矩阵需要多少代码
you don't say, how many characters does it take to invert a matrix?

这是风马牛不相及的
It's irrelevant.

如果该语言内建了矩阵或者类似的东西
What you say is, if the language did not come with matrices built in

那你就应该问它
or with something else built in,

我应该如何构建这些东西？？ -- 待议
how could I then build that thing?

使得我这样做的组合手段是什么？
What are the means of combination which would allow me to do that?

让我们能够把这些当作元素来
And then, what are the means of abstraction

构建更复杂的东西
which allow me then to use those as elements

的抽象手段是什么？
in making more complicated things yet?

我们将看到Lisp有一些初等数据和初等过程
Well, we're going to see that Lisp has some primitive data and some primitive procedures.

好吧 这次是真的开始了
In fact, let's really start.

这里有一个Lisp的初等数据 数字3
And here's a piece of primitive data in Lisp, number 3.

事实上 如果打破沙锅问到底的话 这不是数字3
Actually, if I'm being very pedantic, that's not the number 3.

这只是一个符号 用以代表柏拉图观念下的数字3的
That's some symbol that represents Plato's concept of the number 3.

这又是另一个
And here's another.

这个是Lisp中又一个初等数据 17.4
Here's some more primitive data in Lisp, 17.4.

又或者说 代表17.4
Or actually, some representation of 17.4.

这儿还有一个5
And here's another one, 5.

然后这儿又有一个内建于Lisp的初等对象“+”
Here's another primitive object that's built in Lisp, addition.

如果又要打破砂锅问到底的话
Actually, to use the same kind of pedantic--

这只是一个名字 代表加和事物的初等方法而已
this is a name for the primitive method of adding things.

就像这个是柏拉图式的3
Just like this is a name for Plato's number 3,

这也只是一个代表柏拉图观念下的将某些东西加和起来
this is a name for Plato's concept of how you add things.

这些都是初等元素
So those are some primitive elements.

我可以将它们放在一起
I can put them together.

我可以说 3加17.4加5的和是多少
I can say, gee, what's the sum of 3 and 17.4 and 5?

这等同于说
And the way I do that is to say,

让我们把求和运算符应用于这三个数
let's apply the sum operator to these three numbers.

我可以得到什么呢 是8 是17 还是25.4
And I should get, what? 8, 17. 25.4.

因此 我可以问Lisp这个的值是多少
So I should be able to ask Lisp what the value of this is,

（表达式）返回25.4
and it will return 25.4.

介绍一些名字吧
Let's introduce some names.

我所写的这些东西就叫做组合
This thing that I typed is called a combination.

通常 一个组合式由运算符 
And a combination consists, in general, of applying an operator-- 

这些就是运算符
so this is an operator--

和应用该运算符的运算对象组成
to some operands.

这些是运算对象
These are the operands.

当然 我可以完成更复杂的事
And of course, I can make more complex things.

我可以使之更复杂是因为 这些运算对象
The reason I can get complexity out of this is because the operands themselves,

通常来说 也可以是组合式
in general, can be combinations.

比如 3加上5乘以6乘以8乘以2的积的和是多少
So for instance, I could say, what is the sum of 3 and the product of 5 and 6 and 8 and 2?

而我应该得到 我算一下 30 40 43
And I should get-- let's see-- 30, 40, 43.

因此Lisp应该给我说这个表达式的值是43
So Lisp should tell me that that's 43.

形成组合式是我们打成目的的基本组合方法
Forming combinations is the basic needs of combination that we'll be looking at.

你所看到的这些语法
And then, well, you see some syntax here.

就是Lisp用的所谓的前缀表示法
Lisp uses what's called prefix notation,

意即操作符在操作数的左端
which means that the operator is written to the left of the operands.

这只是个约定
It's just a convention.

注意 这些都被括起来了
And notice, it's fully parenthesized.

这些括号使得它们区别开来
And the parentheses make it completely unambiguous.

因此只要看看这个 我就可以知道这个是操作符
So by looking at this, I can see that there's the operator,

以及这有1个 2个 3个 4个操作数
and there are 1, 2, 3, 4 operands.

而且我也可以发现第二个操作数是个组合式
And I can see that the second operand here is itself some combination

该组合式有一个运算符和两个运算对象
that has one operator and two operands.

Lisp中的括号 有点或者非常不同于
Parentheses in Lisp are a little bit,

通常数学中的括号
or are very unlike parentheses in conventional mathematics.

数学中 我们常将其用于分组
In mathematics, we sort of use them to mean grouping,

如果有时你忘了闭合括号 但其它人能理解你的意图
and it sort of doesn't hurt if sometimes you leave out parentheses

这也无关紧要
if people understand that that's a group.

通常的 你多加了括号也无所谓
And in general, it doesn't hurt if you put in extra parentheses,

因为这样只会使得分组更加明确
because that maybe makes the grouping more distinct.

Lisp可不像这样
Lisp is not like that.

Lisp中你既不能不闭合括号
In Lisp, you cannot leave out parentheses,

亦不能添加多余的括号
and you cannot put in extra parentheses,

因为加括号总是意味着
because putting in parentheses always means,

确切的来说 所括之物是一个组合式
exactly and precisely, this is a combination which has meaning,

表示将运算符应用于运算对象
applying operators to operands.

如果我不闭合这个括号
And if I left this out, if I left those parentheses out,

这个就变成其它的意思了
it would mean something else.

事实上 把这件事想明白的方法则是
In fact, the way to think about this,

把我写的这些东西想作一个树
is really what I'm doing when I write something like this is writing a tree.

这个组合式实际上是一个树 树具有一个“+”
So this combination is a tree that has a plus and

以及 一个3和一些其它的东西和一个8 还有一个2
then a 3 and then a something else and an 8 and a 2.

而这里的其它的东西
And then this something else here is 

它本身是一个有一个“*”一个5和一个6的子树
itself a little subtree that has a star and a 5 and a 6.

我们可以这样认为
And the way to think of that is, really,

我们只是在构建这些树而已
what's going on are we're writing these trees,

括号只是将这种二维结构写作线性字符串
and parentheses are just a way to write this two-dimensional structure

的一种方法罢了
as a linear character string.

因为至少在Lisp发明时 人们还在用电传打字机或者打孔卡
Because at least when Lisp first started and people had teletypes or punch cards or whatever,

这种记法方便多了
this was more convenient.

如果Lisp发明在当今 语法可能会像树那样
Maybe if Lisp started today, the syntax of Lisp would look like that.

那么 让我们看看在计算机里面它究竟是什么样
Well, let's look at what that actually looks like on the computer.

这里有个Lisp解释套件
Here I have a Lisp interaction set up.

这是个编辑器
There's a editor.

我将要在上方写一些表达式并让Lisp对其求值
And on the top, I'm going to type some values and ask Lisp what they are.

比如 我可以问Lisp
So for instance, I can say to Lisp,

这个符号的值是多少
what's the value of that symbol?

我键入3
That's 3.

然后叫Lisp对其求值
And I ask Lisp to evaluate it.

然后你就会看到Lisp在下面返回了一些信息
And there you see Lisp has returned on the bottom,

这个值就是3
and said, oh yeah, that's 3.

我也可以问 3加上4加上8的和是多少
Or I can say, what's the sum of 3 and 4 and 8?

键入这个组合式
What's that combination?

让Lisp对其求值
And ask Lisp to evaluate it.

返回15
That's 15.

我可以键入一些更复杂的东西
Or I can type in something more complicated.

将3乘以7加19.5的和的乘积求和得多少
I can say, what's the sum of the product of 3 and the sum of 7 and 19.5?

你会发现Lisp内建了一些功能
And you'll notice here that Lisp has something built in

帮你跟踪这些括号
that helps me keep track of all these parentheses.

看我键入下一个右圆括号
Watch as I type the next closed parentheses,

用于闭合以“*”开头的那个组合式
which is going to close the combination starting with the star.

开头的那个左括号会闪一下
The opening one will flash.

我把这些括号擦去 再示范一次
Here, I'll rub those out and do it again.

键入右括号 闭合了“+”组合式
Type close, and you see that closes the plus.

再键入右括号 闭合了“*”组合式
Close again, that closes the star.

现在我又回到了加 我将它们与4相加
Now I'm back to the sum, and maybe I'm going to add that all to 4.

闭合了“+”组合式
That closes the plus.

现在我补全了组合 然后我问Lisp它们的值是多少
Now I have a complete combination, and I can ask Lisp for the value of that.

这种内建于各种Lisp系统的
That kind of paren balancing is something that's built into

括号匹配工具帮你跟进（括号匹配）
a lot of Lisp systems to help you keep track,

因为手工闭合这些括号太幸苦了
because it is kind of hard just by hand doing all these parentheses.

这又有一种保持括号跟进的约定
There's another kind of convention for keeping track of parentheses.

我另外写一个复杂的组合式
Let me write another complicated combination.

将3和5的积与某物求和
Let's take the sum of the product of 3 and 5 and add that to something.

现在我将要缩进
And now what I'm going to do is

使得这些运算对象都是垂直书写的
I'm going to indent so that the operands are written vertically.

将这些加上47乘以
Which the sum of that and the product of 47 and--

恩…… 47乘以20和6.8的差
let's say the product of 47 with a difference of 20 and 6.8.

意即从20中减去6.8
That means subtract 6.8 from 20.

然后 这个括号闭合了
And then you see the parentheses close.

闭合“-” 闭合“*”
Close the minus. Close the star.

现在 我们再写一个运算符
And now let's get another operator.

Lisp编辑器自动缩进到正确的位置
You see the Lisp editor here is indenting to the right position automatically

来帮助我保持跟进
to help me keep track.

我再示范一次
I'll do that again.

这样就又闭合了最后一个括号
I'll close that last parentheses again.

它匹配了这个“+”（的括号）
You see it balances the plus.

现在我想问 这个的值是多少
Now I can say, what's the value of that?

因此 这两件事 缩进到正确的位置
So those two things, indenting to the right level,

也就是所谓的美观的输出
which is called pretty printing,

以及闭合提示
and flashing parentheses,

是许多Lisp系统所内建用于帮你保持跟进的工具
are two things that a lot of Lisp systems have built in to help you keep track.

你应该学习如何使用它们
And you should learn how to use them.

好 这些都是基本的内容
Ok, those are the primitives.

这就是一种组合的方法
There's a means of combination.

现在让我们来看看抽象的方法
Now let's go up to the means of abstraction.

我希望我能够写一些像这样的组合式
I'd like to be able to take the idea that I do some combination like this,

将它抽象化并给它命名
and abstract it and give it a simple name,

使得我可以将其作为一个（我们语言的）元素
so I can use that as an element.

在Lisp中 我可以用“define”来实现
And I do that in Lisp with "define."

比如说
So I can say, for example,

定义A为5乘以5
define A to be the product of 5 and 5.

现在我可以问Lisp
And now I could say, for example, to Lisp,

A和A的乘积是多少
what is the product of A and A?

这个是25所以这个就是625
And this should be 25, and this should be 625.

但更重要的则是 我现在可以使用A
And then, crucial thing, I can now use A--

我已经在这个组合式里面用过了
here I've used it in a combination--

但我也可以再更复杂的组合式里面使用它
but I could use that in other more complicated things that I name in turn.

我也可以说 定义B为
So I could say, define B to be the sum of,

A与5乘以A的积的和
we'll say, A and the product of 5 and A.

闭合“+”
And then close the plus.

让我们来看看它在计算机中是怎样的吧
Let's take a look at that on the computer and see how that looks.

我就像黑板上写的那样键入就可以了
So I'll just type what I wrote on the board.

我告诉Lisp
I could say, define A to be the product of 5 and 5.

定义A为5乘以5的积
And I'll tell that to Lisp.

注意Lisp在下方回应了一个A
And notice what Lisp responded there with was an A in the bottom.

通常来说 你如果在Lisp中键入了一个定义
In general, when you type in a definition in Lisp,

它返回被定义的符号
it responds with the symbol being defined.

现在我问Lisp A乘以A的积是多少
Now I could say to Lisp, what is the product of A and A?

Lisp返回625
And it says that's 625.

我也可以定义B为A加上5乘以A的积的和
I can define B to be the sum of A and the product of 5 and A.

闭合“*” 闭合“+” 闭合“define”
Close a paren closes the star.  Close the plus. Close the "define."

Lisp在下方正常返回B
Lisp says, OK, B, there on the bottom.

现在我可以问Lisp B的值是多少
And now I can say to Lisp, what's the value of B?

我也可以问一些更复杂的事
And I can say something more complicated,

比如A加上B除以5的商的和是多少
like what's the sum of A and the quotient of B and 5?

这个斜杠是另一个初等运算符 代表除
That slash is divide, another primitive operator.

我让B除以5 并加在A上
I've divided B by 5, added it to A.

Lisp正常返回55
Lisp says, OK, that's 55.

就像这样
So there's what it looks like.

这是定义东西的基本方法
There's the basic means of defining something.

这是最简单的命名方法 但并不非常有效
It's the simplest kind of naming, but it's not really very powerful.

注意我们讨论的是通用方法
See, what I'd really like to name--

因此我真正想定义的是
remember, we're talking about general methods--

一种通用观念 使得
I'd like to name, oh, the general idea that, for example,

我能得到 5乘5 6乘6 1001乘1001 1001.7乘1001.7
I could multiply 5 by 5, or 6 by 6, or 1,001 by 1,001, 1,001.7 by 1,001.7.

我想给让一个数自乘这种想法一个名字
I'd like to be able to name the general idea of multiplying something by itself.

你应该知道 这叫做平方
Well, you know what that is. That's called squaring.

而在Lisp中我应该这样实现
And the way I can do that in Lisp is I can say,

定义 square 某个叫x的东西 为 将x乘以x自己
define to square something x, multiply x by itself.

定义完毕后 我可以问Lisp
And then having done that, I could say to Lisp,

比如 10的平方是多少
for example, what's the square of 10?

Lisp返回100
And Lisp will say 100.

让我们深入讨论一下
So now let's actually look at that a little more closely.

这儿是square的定义
Right, there's the definition of square.

square某物 即是将该物其自乘
To square something, multiply it by itself.

这里的x
You see this x here.

应该算是一种代词
That x is kind of a pronoun,

指代了我欲平方之物
which is the something that I'm going to square.

实际上我将其乘以x 即是乘以它自己
And what I do with it is I multiply x, I multiply it by itself.

这些就是定义一个过程的记法
OK. So there's the notation for defining a procedure.

这样说可能把你搞糊涂了
Actually, this is a little bit confusing,

因为这就像我在用square一样
because this is sort of how I might use square.

但如果我说x的平方根或者10的平方根
And I say square root of x or square root of 10,

并没有说清楚我为什么东西命了名
but it's not making it very clear that I'm actually naming something.

所以让我换个方式来写这个定义
So let me write this definition in another way

这样可以使得我确实是定义了一些东西
that makes it a little bit more clear that I'm naming something.

我“定义”square为lambda x乘以xx
I'll say, "define" square to be lambda of x times xx.

这里 我定义 square 就像我在那里为某物命名为A一样
Here, I'm naming something square, just like over here, I'm naming something A.

我命名square之物
The thing that I'm naming square--

这里 我把这个组合式的值命名为A
here, the thing I named A was the value of this combination.

在这里 我把这个东西命名为square
Here, the thing that I'm naming square is this thing

这个以lambda开头的东西
that begins with lambda,

lambda在Lisp中用以定义一个过程
and lambda is Lisp's way of saying make a procedure.

让我们来这边深入的了解
Let's look at that more closely on the slide.

这个定义读作
The way I read that definition is to say,

定义square为构建一个过程
I define square to be make a procedure--

而lambda是指
that's what the lambda is--

构建一个有个叫x的参数的过程
make a procedure with an argument named x.

而该过程返回将x自乘的结果
And what it does is return the results of multiplying x by itself.

现在 我们将要使用定义的这种顶级形式
Now, in general, we're going to be using this top form of defining,

因为这个更加方便一点
just because it's a little bit more convenient.

但是也别忘了它实质上也是这个
But don't lose sight of the fact that it's really this.

事实上 就Lisp解释器所关心的而言
In fact, as far as the Lisp interpreter's concerned,

用这种方法和用这种方法没有区别
there's no difference between typing this to it and typing this to it.

换句话说说 这只是一种语法糖
And there's a word for that, sort of syntactic sugar.

语法糖的意思就是
What syntactic sugar means,

它这种形式更加方便键入一点
it's having somewhat more convenient surface forms for typing something.

这只是这下面的有lambda的表达式的语法糖而已
So this is just really syntactic sugar for this underlying Greek thing with the lambda.

你应该记住
And the reason you should remember that is don't forget that,

当我这样写的时候 其实是在给某物命名
when I write something like this, I'm really naming something.

我将某物命名为square
I'm naming something square,

我命名为square的是一个构建的过程
and the something that I'm naming square is a procedure that's getting constructed.

让我们看看在计算机里面又是 怎样的吧
Well, let's look at that on the computer, too.

定义square x为x乘以x的积
So I'll come and I'll say, define square of x to be times xx.

将它送入Lisp
Now I'll tell Lisp that. 

返回square
It says "square."

现在 我已经将某个东西命名为square了
See, I've named something "square."

完毕后 我就可以问Lisp 1001的平方是多少
Now, having done that, I can ask Lisp for, what's the square of 1,001?

或者更通常的来说 我可以问 5加上7的和的平方是多少
Or in general, I could say, what's the square of the sum of 5 and 7?

12的平方是144
The square of 12's 144.

在某些组合式中我亦可把square当作一个元素
Or I can use square itself as an element in some combination.

3的平方加上4的平方的和是多少
I can say, what's the sum of the square of 3 and the square of 4?

9加上16得25
9 and 16 is 25.

我可以将square作为元素用于更复杂点的式子
Or I can use square as an element in some much more complicated thing.

比如 1001的平方点的平方的平方是多少
I can say, what's the square of, the sqare of, the square of 1,001?

这就是1001点的平方的平方的平方
And there's the square of the square of the square of 1,001.

我也可以问Lisp square本身是什么
Or I can say to Lisp, what is square itself?

它的值是是什么
What's the value of that?

Lisp用一种约定的方法告诉我这是一个过程
And Lisp returns some conventional way of telling me that that's a procedure.

它返回 复合过程square
It says, "compound procedure square."

记住 square的值是一个过程
Remember, the value of square is this procedure,

而那些用星号和括号的记法
and the thing with the stars and the brackets

只是Lisp用来描述这个过程的约定
are just Lisp's conventional way of describing that.

让我们再看两个关于define的例子
Let's look at two more examples of defining.

这有两个过程
Here are two more procedures.

定义x和y的平均值为x加上y的和除以2的商
I can define the average of x and y to be the sum of x and y divided by 2.

以及定义好平方和平均值后 我可以定义均方
Or having had average and mean square, having had average and square,

我可以用它们来讨论某物的均方
I can use that to talk about the mean square of something,

即x的平方与y的平方的平均值
which is the average of the square of x and the square of y.

当定义好它们后 我可以问
So for example, having done that, I could say,

2和3的均方是多少
what's the mean square of 2 and 3?

我将会得到 4和9的平均值 即6.5
And I should get the average of 4 and 9, which is 6.5.

关键点在于 定义了square后
The key thing here is that, having defined square,

我可以把它当作一个初等元素来使用
I can use it as if it were primitive.

因此在这里
So if we look here on the slide,

我在讨论均方的时候
if I look at mean square,

从这点来说 定义均方的那个人不必要知道
the person defining mean square doesn't have to know, at this point, 

究竟square是由语言内建支持
whether square was something built into the language

还是自定义的过程
or whether it was a procedure that was defined.

这是Lisp的关键之一
And that's a key thing in Lisp,

你无法准确区别
that you do not make arbitrary distinctions between things

哪些是语言的初等对象 哪些是语言的内建支持
that happen to be primitive in the language and things that happen to be built in.

这些东西 人们用起来毋须知晓
A person using that shouldn't even have to know.

所以你构建的东西就如同它们有初等对象般
So the things you construct get used with all the power and flexibility

所有能力和灵活性
as if they were primitives. 

你课余可以上机试试
In fact, you can drive that home by looking on the computer one more time.

来谈谈“+”吧
We talked about plus.

事实上 我们回到电脑屏幕 键入
And in fact, if I come here on the computer screen and say,

“+”的值是什么
what is the value of plus?

注意Lisp在下方打印出
Notice what Lisp types out. On the bottom there, it typed out,

复合过程“+”
"compound procedure plus."

因为在此系统中
Because, in this system,

“+”运算符结果是一个复合过程
it turns out that the addition operator is itself a compound procedure.

但如果我不这样键入一试 你永远不会知道
And if I didn't just type that in, you'd never know that,

所以这没什么不同
and it wouldn't make any difference anyway.

我们并不关心
We don't care.

这远远低于我们所处的抽象层
It's below the level of the abstraction that we're dealing with.

通常来说 关键点是你不应该也无法区别
So the key thing is you cannot tell, should not be able to tell, in general,

内建之物与复合之物的不同
the difference between things that are built in and things that are compound.

何以致此
Why is that?

因为有一个抽象层将复合之物封装了起来
Because the things that are compound have an abstraction wrapper wrapped around them.

我们已经介绍了Lisp的大多数元素了
We've seen almost all the elements of Lisp now.

还有一个就是
There's only one more we have to look at,

我们如何做“分情况分析”
and that is how to make a case analysis.

我再说通俗一点
Let me show you what I mean.

让我们考虑绝对值函数的数学定义
We might want to think about the mathematical definition of the absolute value functions.

我或许会说x的绝对值这样是一个函数
I might say the absolute value of x is the function

若x小于0 则为-x
which has the property that it's negative of x. For x less than 0,

若x等于0 则为0
it's 0 for x equal to 0.

若x大于0 则就是x
And it's x for x greater than 0.

而Lisp有一套做分情况分析办法
And Lisp has a way of making case analyses.

我来演示定义绝对值
Let me define for you absolute value.

定义绝对值为 x是有条件的
Say define the absolute value of x is conditional.

这就是分情况分析
This means case analysis, COND.

如果x小于0 则结果为-x
If x is less than 0, the answer is negate x.

我这里写的是一个子句
What I've written here is a clause.

这整个是一个由两部分组成的条件表达式
This whole thing is a conditional clause, and it has two parts.

这个部分叫做谓词或者条件
This part here is a predicate or a condition.

这就是一个条件
That's a condition.

用以表达条件的东西叫做谓词
And the condition is expressed by something called a predicate,

Lisp中的谓词是一种
and a predicate in Lisp is some sort of thing

可以返回true或者false的东西
that returns either true or false.

你会发现Lisp有一个基本过程 小于
And you see Lisp has a primitive procedure, less-than,

它返回true或者false
that tests whether something is true or false.

子句其余部分为一个动作或者需要做的事
And the other part of a clause is an action or a thing to do,

本例中为true
in the case where that's true.

在这里 我则是取x的相反数
And here, what I'm doing is negating x.

有趣的是 Lisp中减运算符符与相反数运算符是同一个
The negation operator, the minus sign in Lisp is a little bit funny.

如果有两个及两个以上的参数
If there's two or more arguments,

正如我们看到的 如果刚好有两个参数 就从第一个中减去第二个
if there's two arguments it subtracts the second one from the first, and we saw that.

如果只有一个参数 则取其相反数
And if there's one argument, it negates it.

这与前面相符合
So this corresponds to that.

这又是一个COND子句
And then there's another COND clause.

这是说 在x等于0的时候 结果为0
It says, in the case where x is equal to 0, the answer is 0.

在x大于0的时候 结果为x
And in the case where x is greater than 0, the answer is x.

闭合子句 闭合COND 闭合define
Close that clause. Close the COND. Close the definition.

这就是绝对值的定义
And there's the definition of absolute value.

你会发现这种按情况分析
And you see it's the case analysis that looks very much

与数学中所用的非常相似
like the case analysis you use in mathematics.

我们还有一种书写情况不多的按情况情况分析的方法
There's a somewhat different way of writing a restricted case analysis.

很多时候 你在按情况分析时只有一种情况
Often, you have a case analysis where you only have one case,

你首先测试某物
where you test something,

你将视其为true或false来做某事
and then depending on whether it's true or false, you do something.

所以这是另外一种定义绝对值的方法
And here's another definition of absolute value

但看起来是几乎一样的
which looks almost the same,

像这样 如果x小于0 结果则为x的相反数
which says, if x is less than 0, the result is negate x.

否则 结果即为x
Otherwise, the answer is x.

我们将会大量的使用“if”
And we'll be using "if" a lot.

再次声明
But again, the thing to remember is that

你们在这里看到的绝对值形式
this form of absolute value that you're looking at here,

和我在黑板上写的那种
and then this one over here that I wrote on the board,

本质上是一样的
are essentially the same.

而“if”和“COND”则是
And "if" and COND are-- well, whichever way you like it.

你可以把“COND”想做“if”的语法糖衣
You can think of COND as syntactic sugar for "if",

亦或“if”是“COND”的语法糖衣
or you can think of "if" as syntactic sugar for COND,

这毫无区别
and it doesn't make any difference.

Lisp系统会实现中一个
The person implementing a Lisp system will pick one

而用语法糖衣的方式实现另一个
and implement the other in terms of that.

你首先实现哪一个无所谓
And it doesn't matter which one you pick.

让我们停下来 解决几点疑问
Why don't we break now, and then take some questions.

为什么我有时用define时
How come sometimes when I write define,

我在这里使用了一个左括号
I put an open paren here and say,

输入 define (XXX
define open paren something or other,

而有时我这样写时却没加左括号
and sometimes when I write this, I don't put an open paren?

是因为你所见的用与表达式的
The answer is, this particular form of "define",

“define”这种形式
where you say define some expression,

对于定义过程来说非常特殊
is this very special thing for defining procedures.

再次强调 这实际上是说我定义这个叫square的符号为这个
But again, what it really means is I'm defining this symbol, square, to be that.

你所知道的则是 你先写一个“define”
So the way you should think about it is what "define" does is you write "define",

然后你再写一个符号 没有左括号
and the second thing you write is the symbol here-- no open paren--

这是你将要定义的符号
the symbol you're defining

这又是你要将其定义为什么
and what you're defining it to be.

就像这儿和这儿
That's like here and like here.

这是“define”的基本使用方法
That's sort of the basic way you use "define."

然而 这种特殊的语法技巧
And then, there's this special syntactic trick

使得你可以定义像这样的过程
which allows you to define procedures that look like this.

因此区别就在于你是否定义了一个过程
So the difference is, it's whether or not you're defining a procedure.

[音乐]
[JESU, JOY OF MAN'S DESIRING]

信不信由你 你们已经学了足够多的Lisp了
Well, believe it or not, you actually now know enough Lisp

基本上足以编写
to write essentially any numerical procedure

你可以在FORTRAN、Basic或者其它语言上
that you'd write in a language like FORTRAN or Basic or whatever,

编写的任何数值过程
or, essentially, any other language.

或许你会说 这不可能
And you're probably saying, that's not believable,

因为你知道这些语言有
because you know that these languages have things

像“for”语句和“do-until-whil”语句的东西
like "for statements", and "do until while" or something.

实际上这些我们一点也用不着
But we don't really need any of that.

本课中我们一点也不会使用这些东西
In fact, we're not going to use any of that in this course.

我给你们来个下马威
Let me show you.

回过头来看看平方根
Again, looking back at square root,

让我们看看亚历山大的Heron提出的平方根算法
let's go back to this square root algorithm of Heron of Alexandria.

想想它是怎么说的
Remember what that said.

算法说 为了找到X的平方根的近似值
It said, to find an approximation to the square root of X,

你做出猜测
you make a guess,

然后通过取guess和X/guess的平均数来改进猜测
you improve that guess by averaging the guess and X over the guess.

你不断改进猜测 直到这个猜测足够好
You keep improving that until the guess is good enough.

我已经提到过这种思想
I already alluded to the idea.

这种思想是说 如果你最初采用的猜测
The idea is that, if the initial guess that you took

真真切切的等于X的平方根
was actually equal to the square root of X,

那么G就会等于X/G
then G here would be equal to X/G.

如果你算出平方根 对其取平均数并不会改变它
So if you hit the square root, averaging them wouldn't change it.

如果你所采用的G比X的平方根大
If the G that you picked was larger than the square root of X,

那么X/G就会比X的平方根小
then X/G will be smaller than the square root of X,

因此当你取G与X/G的平均值时
so that when you average G and X/G,

就得到了两者之间的某数
you get something in between.

同理 若你采用的G过小 答案则会过大
So if you pick a G that's too small, your answer will be too large.

如果你采用了一个太大的G
If you pick a G that's too large,

如果你的G比X的平方根还要大的话
if your G is larger than the square root of X

X/G就会比X的平方根还要小
and X/G will be smaller than the square root of X.

因此取平均值使得你总可以得到两者间的某数
So averaging always gives you something in between.


And then, it's not quite trivial, but it's possible to show that,

事实上 如果G只差X的平方根一点的话
in fact, if G misses the square root of X by a little bit,

G和X/G的平均值就会慢慢的向X的平方根靠近
the average of G and X/G will actually keep getting closer to the square root of X.

只要你不断的这样做
So if you keep doing this enough,

最终就可以不断地靠近
you'll eventually get as close as you want.

另外一个事实则是
And then there's another fact,

你总可以使用1作为一个初始猜测来开始这个步骤
that you can always start out this process by using 1 as an initial guess.

它总是朝X的平方根聚拢
And it'll always converge to the square root of X.

这就是亚历山大的Heron的连续求平均值法
So that's this method of successive averaging due to Heron of Alexandria.

让我们在Lisp中实现
Let's write it in Lisp.

中心思想是
Well, the central idea is,

尝试将guess作为X的平方根的一个猜想意味着什么
what does it mean to try a guess for the square root of X?

我来编码
Let's write that.

定义（try guess x）
So we'll say, define to try a guess for the square root of X,

我们该如何做 我们会说
what do we do? We'll say,

如果猜测好到可以作为X的平方根
if the guess is good enough to be a guess for the square root of X,

那么我们就可以将这个猜测作为答案
then, as an answer, we'll take the guess.

否则 我们就会尝试改进猜测
Otherwise, we will try the improved guess.

我们将通过改进这个猜测来作为X的平方根
We'll improve that guess for the square root of X,

并尝试是否为X平方根
and we'll try that as a guess for the square root of X.

闭合try 闭合if 闭合define
Close the "try." Close the "if." Close the "define."

这就是我们如何尝试一个猜测
So that's how we try a guess.

然后 这个过程的下一步是说
And then, the next part of the process said,

为了计算平方根
in order to compute square roots, we'll say,

定义计算X的平方根为
define to compute the square root of X,

从1作为X的平方根的一个猜测开始尝试
we will try 1 as a guess for the square root of X.

我们必须定义一些其它的东西
Well, we have to define a couple more things.

我们必须说明 一个猜测如何才叫“足够好”
We have to say, how is a guess good enough?

我们又该如何改进这个猜测
And how do we improve a guess?

那么让我们来看看
So let's look at that.

而改进一个X的平方根的一个猜测的算法则是
The algorithm to improve a guess for the square root of X,

取平均数
we average-- that was the algorithm--

我们取guess和X/guess的平均数
we average the guess with the quotient of dividing X by the guess.

这就是我们如何改进一个猜测
That's how we improve a guess.

为了区别一个猜测是否足够好 我们需要规定些什么
And to tell whether a guess is good enough, well, we have to decide something.

如果这个是X的平方根的一个猜测
This is supposed to be a guess for the square root of X,

你可能做的一件事就是
so one possible thing you can do is say,

当你采用这个猜测并将其平方
when you take that guess and square it,

你会得到一个非常接近于X的数
do you get something very close to X?

而表达这个意图的一种方式是
So one way to say that is to say,

我们用X减去guess的平方
I square the guess, subtract X from that,

并且如果所得结果的绝对值
and see if the absolute value of that

比一个由你的意图决定的很小的数还小
whole thing is less than some small number, which depends on my purposes.

因此 我们有计算X的平方根的一整套过程
So there's a complete procedure for how to compute the square root of X.

我们再来深入观察一下这个结构
Let's look at the structure of that a little bit.

我搞定了整件事
I have the whole thing.

我有一个用于计算X的平方根的记号
I have the notion of how to compute a square root.

这是一种模块
That's some kind of module.

也是一种黑箱
That's some kind of black box.

它的定义依赖于如何尝试将一个猜测作为X的平方根
It's defined in terms of how to try a guess for the square root of X.

定义try是用来完成
"Try" is defined in terms of, well,

检查某数是否足够好以及如何去改进该数
telling whether something is good enough and telling how to improve something.

而good-enough
So good enough.

try的定义依赖于good-enough和improve
"Try" is defined in terms of "good enough" and "improve".

让我们来看看我填入了些什么
And let's see what else I fill in.

如果我向下拓展这棵树
Well, I'll go down this tree.

good-enough的定义依赖于abs和square
"Good enough" was defined in terms of absolute value, and square.

而improve的定义依赖与一种叫做取平均值的东西
And improve was defined in terms of something called averaging

而其它的都是一些基本运算符
and then some other primitive operator.

square-root的定义依赖于try
Square root's defined in terms of "try".

try的定义依赖于good-enough和improve
"Try" is defined in terms of "good enough" and "improve",

甚至依赖于try本身
but also "try" itself.

因此try的也按照它如何应用于自身而定义
So "try" is also defined in terms of how to try itself.

额 这可能会给你造成一些麻烦
Well, that may give you some problems.

你的高中几何老师或许告诉过你
Your high school geometry teacher probably told you

用一个东西自己去定义自己是很淘气的事
that it's naughty to try and define things in terms of themselves,

因为这根本行不通
because it doesn't make sense.

这（种说法）是错的
But that's false.

有时候用一个东西自己来定义自己运行得非常完美
Sometimes it makes perfect sense to define things in terms of themselves.

我们来看看这个例子
And this is the case. And we can look at that.

假设我问Lisp 2的平方根是多少
We could write down what this means, and say,

我们可以写出它究竟是什么意思
suppose I asked Lisp what the square root of 2 is.

2的平方根是什么意思
What's the square root of 2 mean?

意思就是我将用1作为2的平方根的一个猜测
Well, that means I try 1 as a guess for the square root of 2.

然后我考虑 对于2的平方根来说 1是一个足够好的猜测么
Now I look. I say, gee, is 1 a good enough guess for the square root of 2?

这取决于good-enough是如何判断的
And that depends on the test that "good enough" does.

本例中 good-enough会说
And in this case, "good enough" will say,

不 对于2的平方根来说 1不是一个足够好的猜测
no, 1 is not a good enough guess for the square root of 2.

因此我会继续说 我试试一个改进值
So that will reduce to saying, I have to try an improved--

改进猜测值1
improve 1 as a guess for the square root of 2,

然后将其作为2的平方根的一个猜测
and try that as a guess for the square root of 2.

改进猜测值1用作2的平方根
Improving 1 as a guess for the square root of 2

也就是说我取1和2/1的平均值
means I average 1 and 2 divided by 1.

因此我们将取平均数
So this is going to be average.

这段代码将会取1和2/1的平均数
This piece here will be the average of 1 and the quotient of 2 by 1.

那么这段代码
That's this piece here.

我算算 结果是1.5
And I'm gonna try... And this is 1.5.

因此这个(sqrt 2)还原到(try 1 2)
So this square root of 2 reduces to trying 1 for the square root of 2,

然后还原到(try 1.5 2)
which reduces to trying 1.5 as a guess for the square root of 2.

因此这行得通
So that makes sense.

让我们看下剩下的步骤
Let's look at the rest of the process.

如果我尝试1.5 则会还原到
If I try 1.5, that reduces.

1.5作为2的平方根的猜测 并不是足够好
1.5 turns out to be not good enough as a guess for the square root of 2.

然后又还原到
So that reduces to trying the average of

(try (average 1.5 (/ 2 1.5)))
1.5 and 2 divided by 1.5 as a guess for the square root of 2.

平均值是1.333
That average turns out to be 1.333.

然后整个事又还原到(try 1.3333 2)
So this whole thing reduces to trying 1.333 as a guess for the square root of 2.

如此进行下去
And then so on.

然后又还原到good-enough 1.4或者其它的
That reduces to another called a "good enough", 1.4 something or other.

然后这个（步骤）会持续进行到
And then it keeps going until the process finally stops

good-enough认为足够好了才停止
with something that "good enough" thinks is good enough, which,

本例中 是1.4242或者其它的东西
in this case, is 1.4142 something or other.

因此这个这个步骤运行得非常完美
So the process makes perfect sense.

这种 通过这种方法定义叫做“递归定义”
This, by the way, is called a recursive definition.

构建递归定义的能力来自于不可思议力量
And the ability to make recursive definitions is a source of incredible power.

正如你所见 我已提到过
And as you can already see I've hinted at,


it's the thing that effectively allows you to do these infinite computations


that go on until something is true,


without having any other constricts other than the ability to call a procedure.

还有一件事
Well, let's see, there's one more thing.

我再在这里给你们展示一个关于平方根的不同定义
Let me show you a variant of this definition of square root here on the slide.

这是一种相同的东西
Here's sort of the same thing.

在这儿 我把“improve”、“good-enough”、“try”的定义
What I've done here is packaged the definitions of

全都封装在了“sqrt”里面
"improve" and "good enough" and "try" inside "square root".

因此实际上 我们构建了一个平方根箱子
So, in effect, what I've done is I've built a square root box.

我构建了一个其它人可以使用的平方根箱子
So I've built a box that's the square root procedure that someone can use.

它们输入36 然后（箱子）输出6
They might put in 36 and get out 6.

但是 箱子里面的那些小包
And then, packaged inside this box

就是“try”、“good-enough”和“improve”的定义
are the definitions of "try" and "good enough" and "improve."

它们都隐藏在箱子里面
So they're hidden inside this box.

这样做的原因则是
And the reason for doing that is that,

如果有人正在使用这个平方根
if someone's using this square root,

如果George正在使用这个平方根
if George is using this square root,

George并不会关心
George probably doesn't care very much that,

当我在实现平方根时
when I implemented square root,

我定义了箱子内的那些“try”、“good-enough”和“improve”过程
I had things inside there called "try" and "good enough" and "improve".

事实上 Harry可能会实现一个也具有
And in fact, Harry might have a cube root procedure

“try”、“good-enough”和“improve”的立方根箱子
that has "try" and "good enough" and "improve".

因此 为了不让整个系统变得混乱
And in order to not get the whole system confused,

Harry把这些内部过程封装在它的立方根过程为好
it'd be good for Harry to package his internal procedures inside his cube root procedure.

这个叫做块结构
Well, this is called block structure,

这是把东西打包到定义内部的一种方法
this particular way of packaging internals inside of a definition.

让我们回过头来再看看
And let's go back and look at the slide again.

这种过程的读法这是 为了定义平方根
The way to read this kind of procedure is to say, to define "square root",

那么 在其内部
well, inside that definition,

我们已有“improve”的定义
I'll have the definition of an "improve" and

我们已有“good-enough”和“try”的定义
the definition of "good enough" and the definition of "try."

以及这些定义的实体
And then, subject to those definitions,

我求平方根的定义实体是从1开始尝试
the way I do square root is to try 1.

注意这里 我不必将X当做参数传递
And notice here, I don't have to say 1 as a guess for the square root of X,

因为它们都在平方根内部
because since it's all inside the square root,

它相当于已知这个X了
it sort of has this X known.

我来总结下
Let me summarize.

我们从表述过程性知识
We started out with the idea that

开始学习
what we're going to be doing is expressing imperative knowledge.

事实上 如果从Lisp这边总结的话
And in fact, here's a slide that summarizes the way we looked at Lisp.

我们从初等元素如“+”和“*”开始
We started out by looking at some primitive elements in addition and multiplication,

一些用于测试某物小于或等于的谓词
some predicates for testing whether something is less-than or something's equal.

但事实上 藏匿在系统下的我们所用的这些东西的真正面目
And in fact, we saw really sneakily in the system we're actually using,

并不是初等元素 但这无所谓
these aren't actually primitives, but it doesn't matter.

重要的是我们会把它们当作是初等元素
What matters is we're going to use them as if they're primitives.

我们不会看系统内部
We're not going to look inside.

我们也有一些初等数据和一些数
We also have some primitive data and some numbers.

我们学习了合成的手段 组合的手段
We saw some means of composition, means of combination,

用运算符和运算对象合成函数和构建组合式
the basic one being composing functions and

的基本方法
building combinations with operators and operands.

还有一些像是“COND”、“if”和“define”的东西
And there were some other things, like COND and "if" and "define".

具体来说 关于“define”的重点则是
But the main thing about "define," in particular,

它是一种抽象的手段
was that it was the means of abstraction.

它是我们为某物命名的方法
It was the way that we name things.

我们但可以从之前的 也可以从这里看出
You can also see from this slide not only where we've been,

有时候 我们需要讨论如何组合初等出具以得到复合数据
At some point, we'll have to talk about how you combine primitive data to get compound data,

以及你如何抽象数据 使得你可以在一个更大的环境中
and how you abstract data so you can use large globs of data

把这个当作初等数据使用
as if they were primitive.

这也是我们的目的所在
So that's where we're going.

在我们达到目的之前 下节课我们首先将会讨论
But before we do that, for the next couple of lectures we're going to be talking about,

你如何在我们编写的过程和机器内部的内部过程
first of all, how it is that you make a link

中建立联系
between these procedures we write and the processes that happen in the machine.

以及 你如何使用Lisp的力量
And then, how it is that you start using the power of Lisp

去思考不仅仅是单个的小型计算
to talk not only about these individual little computations,

而是更加通用的方法
but about general conventional methods of doing things.

好了 有任何疑问么
OK, are there any questions?

学生：在定义A时 如果我们用一个括号将A扩起
AUDIENCE: Yes. If we defined A using parentheses instead of as we did,

会与不使用括号不同么？
what would be the difference?

教授：如果我这样写
PROFESSOR: If I wrote this, if I wrote that,

我则会是定义一个过程并命名为A
what I would be doing is defining a procedure named A.

本例中 这个过程没有参数
In this case, a procedure of no arguments, which,

而当我运行它 则会返回5乘以5
when I ran it, would give me back 5 times 5.

学生：我的意思是
AUDIENCE: Right. I mean, you come up with the same thing,

except for you really got a different--

教授：好 的确会有不同 之前的那一个
PROFESSOR: Right. And the difference would be, in the old one--

我还是在这里写清楚一点吧
Let me be a little bit clearer here.

我们还是把这个叫做A
Let's call this A, like here.

作为对比 我们假装这里有一个
And pretend here, just for contrast, I wrote,

我定义D为5乘以5
define D to be the product of 5 and 5.

这两者的区别则是
And the difference between those,

让我们看看它们在Lisp解释器中是怎样的
let's think about interactions with the Lisp interpreter.

我在Lisp中键入A 返回25
I could type in A and Lisp would return 25.

如果我仅仅键入D
I could type in D, if I just typed in D,

Lisp返回复合过程D
Lisp would return compound procedure D,

因为D就是一个过程
because that's what it is. It's a procedure.

我可以运行D 我可以问运行D的结果是什么
I could run D. I could say, what's the value of running D?

这是一个没有运算数的组合式
Here is a combination with no operands.

我考虑到它没有运算数 所以我在D后面没有键入任何东西
I see there are no operands. I didn't put any after D.

Lisp则会说结果是25
And it would say, oh, that's 25.

我再说周全一点 如果我键入 A的运行结果是多少
Or I could say, just for completeness, if I typed in, what's the value of running A?

只能得到一个错误
I get an error.

跟这里的错误一样
The error would be the same one as over there.

这个错误是因为 A的值——25
It'd be the error would say, sorry, 25, which is the value of A,

并不是我可以应用于某物的运算符
is not an operator that I can apply to something.

MIT OpenCourseWare
http://ocw.mit.edu
