1
00:00:01,100 --> 00:00:04,500
哈尔滨工业大学 IBM技术中心
倾情制作

2
00:00:05,000 --> 00:00:09,000
校对：吴　晋（Cliff Woo）
字幕：邓雄飞（Dysprosium）
时间轴：邓雄飞（Dysprosium)

3
00:00:09,300 --> 00:00:13,000
特别感谢：裘宗燕

4
00:00:14,625 --> 00:00:18,544
欢迎大家来一起学习这门计算机科学的基础课程
I'd like to welcome you to this course on computer science. 

5
00:00:28,319 --> 00:00:29,802
事实上 以这样的方式来表述并不恰当
Actually, that's a terrible way to start.

6
00:00:29,919 --> 00:00:31,893
于此来说 计算机科学是个糟糕的名字
Computer science is a terrible name for this business.

7
00:00:32,228 --> 00:00:34,685
首先 它不算是一门科学
First of all, it's not a science.

8
00:00:35,925 --> 00:00:39,021
它更应该被称为工程或者是艺术
It might be engineering or it might be art,

9
00:00:39,983 --> 00:00:42,540
但我们实际上会发现 这个所谓的计算机科学
but we'll actually see that computer so-called science

10
00:00:43,839 --> 00:00:44,951
却与魔法一样的有众多神奇之处
actually has a lot in common with magic,

11
00:00:45,461 --> 00:00:46,663
这些将会在课程中一一体现
and we'll see that in this course.

12
00:00:46,974 --> 00:00:48,452
所以 不能称其为一门科学
So it's not a science.

13
00:00:48,648 --> 00:00:51,854
这门学科和“计算机”也并非紧密相关
It's also not really very much about computers.

14
00:00:53,353 --> 00:00:55,034
类似的 就像我们说
And it's not about computers in the same sense 

15
00:00:55,258 --> 00:00:59,330
物理学中并不仅仅有关粒子加速器
that physics is not really about particle accelerators, 

16
00:01:00,749 --> 00:01:04,990
生物学中并不全然是显微镜和培养皿一样
and biology is not really about microscopes and petri dishes.

17
00:01:06,010 --> 00:01:09,471
同理
And it's not about computers in the same sense

18
00:01:09,865 --> 00:01:14,412
几何学中也并不全是介绍如何使用测量仪器
that geometry is not really about using surveying instruments.

19
00:01:16,401 --> 00:01:20,930
事实上 计算机科学和几何学有很多共性
In fact, there's a lot of commonality between computer science and geometry.

20
00:01:21,000 --> 00:01:22,213
首先 几何学
Geometry, first of all,

21
00:01:22,579 --> 00:01:24,535
只是另一个有个糟糕名字的学科
is another subject with a lousy name.

22
00:01:25,691 --> 00:01:27,400
这个名字来自于Gaia 意为土地
The name comes from Gaia, meaning the Earth,

23
00:01:27,692 --> 00:01:28,645
以及metron 意为测量
and metron, meaning to measure.

24
00:01:29,011 --> 00:01:33,165
几何学最初意为测地或者勘探
Geometry originally meant measuring the Earth or surveying.

25
00:01:34,227 --> 00:01:36,446
这是因为数千年前的埃及祭司
And the reason for that was that, thousands of years ago,

26
00:01:37,820 --> 00:01:41,237
为了计算如何去修复年年被尼罗河的洪水
the Egyptian priesthood developed the rudiments of geometry

27
00:01:42,603 --> 00:01:46,003
所毁坏的牧田边界
in order to figure out how to restore the boundaries of fields

28
00:01:46,347 --> 00:01:48,240
而建立了几何学基础
that were destroyed in the annual flooding of the Nile.

29
00:01:49,439 --> 00:01:50,604
而对出于这个目的的埃及人来说
And to the Egyptians who did that,

30
00:01:51,275 --> 00:01:53,413
几何学的确是掌握对测量仪器的使用
geometry really was the use of surveying instruments.

31
00:01:55,517 --> 00:01:58,107
现在 我们以为计算机科学就是介绍计算机的使用
Now, the reason that we think computer science is about computers

32
00:01:58,467 --> 00:02:02,232
就正如埃及人认为
is pretty much the same reason that the Egyptians thought geometry

33
00:02:02,439 --> 00:02:03,657
几何学是介绍如何使用测量仪器的
was about surveying instruments.

34
00:02:04,493 --> 00:02:06,926
换句话说 任何一门学科起步的时候
And that is, when some field is just getting started 

35
00:02:07,187 --> 00:02:09,414
你都对它了解不深
and you don't really understand it very well,

36
00:02:11,066 --> 00:02:16,224
这很容易使你混淆所做的事与所用之物
it's very easy to confuse the essence of what you're doing with the tools that you use.

37
00:02:17,533 --> 00:02:19,988
确实 就绝对规模来说
And indeed, on some absolute scale of things, 

38
00:02:20,138 --> 00:02:24,370
我们对计算机科学的实质的了解
we probably know less about the essence of computer science

39
00:02:24,523 --> 00:02:26,911
比埃及人对几何学的了解还少
than the ancient Egyptians really knew about geometry.

40
00:02:30,065 --> 00:02:32,440
那么 我所谓的计算机科学的本质是什么呢
Well, what do I mean by the essence of computer science? 

41
00:02:32,616 --> 00:02:33,966
我所谓的几何学本质又是什么呢
What do I mean by the essence of geometry?

42
00:02:34,253 --> 00:02:36,000
看 可以确认的是 古埃及人确实使用测量仪器
See, it's certainly true that these Egyptians went off

43
00:02:36,225 --> 00:02:37,229
并且已经消失多年
and used surveying instruments,

44
00:02:37,469 --> 00:02:41,305
但当我们在几千年后回过头来重新审视这段历史
but when we look back on them after a couple of thousand years,

45
00:02:41,424 --> 00:02:42,052
我们会说
we say,

46
00:02:42,222 --> 00:02:43,196
天啊 看他们在做什么
gee, what they were doing,

47
00:02:43,396 --> 00:02:45,038
他们的工作是多么的重要
the important stuff they were doing,

48
00:02:45,179 --> 00:02:49,524
已经开始对时间和空间进行形式化表述
was to begin to formalize notions about space and time,

49
00:02:50,086 --> 00:02:57,080
并归纳出一套讨论数学真理的形式化方法
to start a way of talking about mathematical truths formally.

50
00:02:57,810 --> 00:02:59,446
这直接导致了公理化方法
That led to the axiomatic method.

51
00:02:59,661 --> 00:03:02,081
以及各种现代数学的产生
That led to sort of all of modern mathematics,

52
00:03:04,006 --> 00:03:06,453
同时也指明了一种精确讨论
figuring out a way to talk precisely about

53
00:03:06,641 --> 00:03:09,743
所谓的描述真理的陈述性知识的方法
so-called declarative knowledge, what is true.

54
00:03:12,447 --> 00:03:16,234
与此相似的 我认为未来人们会回过头来审视并说
Well, similarly, I think in the future people will look back and say,

55
00:03:16,347 --> 00:03:19,102
啊 这些20世纪的原始人
yes, those primitives in the 20th century were fiddling around

56
00:03:19,249 --> 00:03:20,754
不务正业地玩弄着叫计算机的小玩意
with these gadgets called computers,

57
00:03:21,761 --> 00:03:25,800
但它们真正在做的是开始学习
but really what they were doing is starting to learn

58
00:03:25,998 --> 00:03:32,106
如何去对计算过程进行形式化表述
how to formalize intuitions about process,

59
00:03:32,358 --> 00:03:33,900
如何去解决问题
how to do things,

60
00:03:39,424 --> 00:03:50,801
并结合两者发展一套对问题处理过程精确表述的方法
starting to develop a way to talk precisely about how-to knowledge,

61
00:03:51,841 --> 00:03:55,589
这与讨论真理的几何学形成了对照
as opposed to geometry that talks about what is true.

62
00:03:56,412 --> 00:03:58,120
让我给你们举个例子吧
Let me give you an example of that.

63
00:04:02,192 --> 00:04:02,855
来瞧瞧
Let's take a look

64
00:04:02,977 --> 00:04:09,884
数学中是这样来定义平方根的:
Here is a piece of mathematics that says what a square root is.

65
00:04:10,048 --> 00:04:13,901
定义X的平方根Y是这样一个数
The square root of X is the number Y,

66
00:04:15,987 --> 00:04:20,037
Y的平方等于X 且Y大于等于0
such that Y squared is equal to X and Y is greater than 0.

67
00:04:20,251 --> 00:04:22,057
这是一个很好的定义
Now, that's a fine piece of mathematics,

68
00:04:22,837 --> 00:04:25,372
但它只告诉了你平方根是什么
but just telling you what a square root is 

69
00:04:25,523 --> 00:04:30,405
却没有告诉你如何去求取一个平方根
doesn't really say anything about how you might go out and find one.

70
00:04:31,392 --> 00:04:35,763
那么我们将其与一条指令性知识做比较
So let's contrast that with a piece of imperative knowledge,

71
00:04:37,376 --> 00:04:39,914
你如何去求取一个平方根
how you might go out and find a square root.

72
00:04:40,109 --> 00:04:45,856
事实上 这来自于埃及 不太久远的埃及
This, in fact, also comes from Egypt, not ancient, ancient Egypt.

73
00:04:45,972 --> 00:04:48,435
亚历山大的Heron提出的一个算法
This is an algorithm due to Heron of Alexandria,

74
00:04:49,821 --> 00:04:52,326
称作连续取均值求平方根法
called how to find a square root by successive averaging.

75
00:04:52,923 --> 00:04:54,969
这个算法是说
And what it says is that,

76
00:04:55,065 --> 00:04:59,588
为了算出平方根
in order to find a square root,

77
00:05:03,359 --> 00:05:07,884
首先你应该给出一个猜测值guess 并不断改进
you make a guess, you improve that guess --

78
00:05:10,159 --> 00:05:11,254
改进的方法是通过
and the way you improve the guess

79
00:05:11,386 --> 00:05:13,506
不断求猜测值guess与X/guess的平均值
is to average the guess and X over the guess,

80
00:05:13,668 --> 00:05:15,296
我们稍后将会讨论
and we'll talk a little bit later about

81
00:05:15,424 --> 00:05:16,672
为什么这是合理的
why that's a reasonable thing--

82
00:05:16,901 --> 00:05:18,921
通过不断改进 直到它足够精确
and you keep improving the guess until it's good enough.

83
00:05:19,702 --> 00:05:20,408
这就是实现方法
That's a method.

84
00:05:20,544 --> 00:05:24,368
这也是如何完成一项工作与
That's how to do something as opposed to 

85
00:05:24,513 --> 00:05:26,887
其对应的陈述性知识的对照
declarative knowledge that says what you're looking for.

86
00:05:28,120 --> 00:05:29,315
这就是一个过程
That's a process.

87
00:05:34,418 --> 00:05:37,877
那么 通常来说什么是过程呢？
Well, what's a process in general?

88
00:05:38,840 --> 00:05:39,695
这定义起来非常困难
It's kind of hard to say.

89
00:05:39,830 --> 00:05:43,271
你可以将它象征性地看成一个活在计算机内
You can think of it as like a magical spirit

90
00:05:44,731 --> 00:05:46,885
并且可以完成一些操作的精灵
that sort of lives in the computer and does something. 

91
00:05:47,931 --> 00:05:53,818
一些被称为程序的规则模式
And the thing that directs a process is

92
00:05:53,943 --> 00:05:57,535
指导着这类过程的进行
a pattern of rules called a procedure.

93
00:06:01,881 --> 00:06:04,286
程序可以被认为是符咒
So procedures are the spells, if you like,

94
00:06:05,104 --> 00:06:08,952
使用程序来控制这些精灵完成一些操作就叫做过程
that control these magical spirits that are the processes.

95
00:06:10,809 --> 00:06:12,422
你们知道人人都需要一门魔法语言
I guess you know everyone needs a magical language,

96
00:06:12,551 --> 00:06:14,104
那些魔术师 真正的魔术师 用远古的阿卡狄亚语
and sorcerers, real sorcerers,

97
00:06:14,278 --> 00:06:18,145
或者苏美尔语 或者巴比伦语 或者其它的
use ancient Arcadian or Sumerian or Babylonian or whatever.

98
00:06:18,352 --> 00:06:19,648
而我们将用一门叫Lisp的魔法语言
We're going to conjure our spirits

99
00:06:19,896 --> 00:06:22,265
来召唤出我们的精灵
in a magical language called Lisp,

100
00:06:24,618 --> 00:06:27,391
这门语言是被设计用来
which is a language designed for talking about,

101
00:06:28,482 --> 00:06:31,393
编写如咒语版的程序 来指导过程的进行
for casting the spells that are procedures to direct the processes.

102
00:06:31,906 --> 00:06:33,469
学习Lisp非常容易
Now, it's very easy to learn Lisp.

103
00:06:33,831 --> 00:06:35,697
事实上 我会在几分钟内教会你
In fact, in a few minutes, I'm going to teach you,

104
00:06:35,838 --> 00:06:36,712
整个Lisp
essentially, all of Lisp.

105
00:06:36,926 --> 00:06:38,515
及其所有的规则
I'm going to teach you, essentially, all of the rules.

106
00:06:40,587 --> 00:06:42,523
你不必感到很惊讶
And you shouldn't find that particularly surprising.

107
00:06:43,442 --> 00:06:45,589
这就像你在学习象棋时
That's sort of like saying it's very easy

108
00:06:45,732 --> 00:06:46,849
认为象棋的规则十分简单一样
to learn the rules of chess.

109
00:06:46,941 --> 00:06:48,187
事实也如此 几分钟内
And indeed, in a few minutes,

110
00:06:48,281 --> 00:06:49,258
你可以与任何人谈论象棋的规则
you can tell somebody the rules of chess.

111
00:06:50,661 --> 00:06:51,999
但是 这全然不等同于说
But of course, that's very different from

112
00:06:52,112 --> 00:06:55,037
你所知道这些规则所蕴含的东西
saying you understand the implications of those rules

113
00:06:55,173 --> 00:06:58,385
以及如何利用这些规则去成为象棋大师
and how to use those rules to become a masterful chess player.

114
00:06:58,500 --> 00:06:59,379
Lisp也是如此
Well, Lisp is the same way.

115
00:07:00,292 --> 00:07:01,739
我将在几分钟内道清规则
We're going to state the rules in a few minutes,

116
00:07:02,314 --> 00:07:03,233
这说起来非常容易
and it'll be very easy to see.

117
00:07:03,376 --> 00:07:06,645
但真正困难的是如何运用这些规则
But what's really hard is going to be the implications of those rules,

118
00:07:07,278 --> 00:07:10,014
以及你如何利用这些规则成为编程大师
how you exploit those rules to be a master programmer.

119
00:07:12,018 --> 00:07:15,079
这些规则的应用将占据我们
And the implications of those rules are going to take us the,

120
00:07:15,266 --> 00:07:18,111
余下的课程 甚至更多
well, the whole rest of the subject and, of course, way beyond.

121
00:07:21,341 --> 00:07:22,665
所以 在计算机科学中
OK, so in computer science,

122
00:07:24,471 --> 00:07:25,902
我们的任务则是
we're in the business of

123
00:07:26,016 --> 00:07:30,138
形式化这种如有关“怎么做”的指令性知识
formalizing this sort of how-to imperative knowledge,

124
00:07:30,771 --> 00:07:31,654
并将之付诸实际
how to do stuff.

125
00:07:33,304 --> 00:07:35,370
这也便是计算机科学的真正的议题
And the real issues of computer science are, of course,

126
00:07:35,497 --> 00:07:37,915
当然 并不是告诉人们如何去求平方根
not telling people how to do square roots.

127
00:07:38,979 --> 00:07:39,977
因为如果那是计算机科学的全部的的话
Because if that was all it was,

128
00:07:40,101 --> 00:07:41,010
就不会有什么大问题了
there wouldn't be no big deal.

129
00:07:41,726 --> 00:07:44,036
真正的问题来自于当我们尝试
The real problems come when we try to 

130
00:07:44,223 --> 00:07:45,715
构建非常非常大的系统时
build very, very large systems,

131
00:07:46,569 --> 00:07:49,082
程序可能会长达数千页
computer programs that are thousands of pages long,

132
00:07:49,377 --> 00:07:53,791
长得没有人能马上将其装入脑中
so long that nobody can really hold them in their heads all at once.

133
00:07:54,604 --> 00:07:58,360
而使这些得以实现则是因为
And the only reason that that's possible is because

134
00:07:58,663 --> 00:08:19,440
我们有在大系统中控制复杂度的技术
there are techniques for controlling the complexity of these large systems.

135
00:08:20,259 --> 00:08:22,370
这些控制复杂度的技术
And these techniques that are controlling complexity

136
00:08:22,546 --> 00:08:24,522
正是我们课程所讨论的
are what this course is really about.

137
00:08:24,737 --> 00:08:25,476
从某种意义上来说
And in some sense,

138
00:08:25,614 --> 00:08:27,021
这也正是计算机科学的关键所在
that's really what computer science is about.

139
00:08:29,582 --> 00:08:30,764
这样说听起来或许很奇怪
Now, that may seem like a very strange thing to say.

140
00:08:30,897 --> 00:08:35,317
毕竟 除了计算机科学家外
Because after all, a lot of people besides computer scientists

141
00:08:35,493 --> 00:08:37,372
仍然有很多人在做复杂度控制相关的工作
deal with controlling complexity.

142
00:08:37,592 --> 00:08:40,577
一个航班就是一个非常复杂的系统
A large airliner is an extremely complex system,

143
00:08:41,711 --> 00:08:43,210
设计它的航空工程师
and the aeronautical engineers who design that

144
00:08:43,421 --> 00:08:47,270
便在处理这个巨大的复杂度
are dealing with immense complexity.

145
00:08:47,389 --> 00:08:49,744
但这种复杂度又与
But there's a difference between that kind of complexity

146
00:08:50,657 --> 00:08:52,152
计算机科学中的（复杂度）有别
and what we deal with in computer science.

147
00:08:55,127 --> 00:08:57,285
从某种意义上来说
And that is that computer science,

148
00:08:57,515 --> 00:08:59,483
因为计算机科学不是“真实”的（译注：非物理系统的）
in some sense, isn't real.

149
00:09:02,590 --> 00:09:06,172
例如 当一名工程师设计物理系统时
You see, when an engineer is designing a physical system,

150
00:09:07,092 --> 00:09:08,043
这些都是由真实的物理部件构成
that's made out of real parts.

151
00:09:09,555 --> 00:09:10,675
负责的该工作的工程师
The engineers who worry about that

152
00:09:11,751 --> 00:09:16,478
就得对付系统中的公差、近似值以及噪声
have to address problems of tolerance and approximation and noise in the system.

153
00:09:16,598 --> 00:09:18,889
譬如说 作为一名电气工程师
So for example, as an electrical engineer,

154
00:09:19,040 --> 00:09:21,281
可以很容易的做一个单极放大器
I can go off and easily build a one-stage amplifier

155
00:09:21,544 --> 00:09:22,581
或者是一个双极放大器
or a two-stage amplifier,

156
00:09:23,300 --> 00:09:25,096
也可想象将其大量串联
and I can imagine cascading a lot of them

157
00:09:25,211 --> 00:09:26,520
来建造一个百万极的放大器
to build a million-stage amplifier.

158
00:09:26,647 --> 00:09:28,494
但这样做是不可行的
But it's ridiculous to build such a thing,

159
00:09:28,881 --> 00:09:31,702
因为在远没到百万数量级的时候
because long before the millionth stage,

160
00:09:31,961 --> 00:09:34,229
这种组合方法打从头产生的热噪声
the thermal noise in those components way at the beginning

161
00:09:34,375 --> 00:09:36,598
会慢慢增强 并使得我们的幸苦付之一炬
is going to get amplified and make the whole thing meaningless.

162
00:09:38,957 --> 00:09:42,676
计算机科学处理的是理想化组件
Computer science deals with idealized components.

163
00:09:44,028 --> 00:09:47,287
我们对将要结合在一起的
We know as much as we want about these little program 

164
00:09:47,505 --> 00:09:49,115
程序和数据了如指掌
and data pieces that we're fitting things together.

165
00:09:50,974 --> 00:09:53,020
我们不需要去关心公差
We don't have to worry about tolerance.

166
00:09:53,169 --> 00:09:56,299
也就是说 在构建大系统时
And that means that, in building a large program,

167
00:09:57,981 --> 00:09:59,586
在我理想和现实之间
there's not all that much difference

168
00:10:00,257 --> 00:10:03,630
并不没有太大的不同
between what I can build and what I can imagine,

169
00:10:05,425 --> 00:10:07,369
因为这些部分都是抽象单元
because the parts are these abstract entities

170
00:10:07,588 --> 00:10:10,122
可以随心所欲的组合
that I know as much as I want.

171
00:10:10,310 --> 00:10:11,940
可以据目前所知而自由构建
I know about them as precisely as I'd like.

172
00:10:13,371 --> 00:10:15,052
就是与其它的工程不同之处
So as opposed to other kinds of engineering,

173
00:10:15,214 --> 00:10:17,253
（在其它的工程中）对你所构建系统的约束
where the constraints on what you can build

174
00:10:17,342 --> 00:10:18,459
来自于物理系统以及
are the constraints of physical systems,

175
00:10:18,695 --> 00:10:20,535
物理定律 噪声 近似值等
the constraints of physics and noise and approximation,

176
00:10:21,017 --> 00:10:25,360
而建立大型软件系统时所施加的约束
the constraints imposed in building large software systems

177
00:10:25,495 --> 00:10:27,134
就是对我们大脑的限制
are the limitations of our own minds.

178
00:10:28,929 --> 00:10:29,669
从这个角度来看
So in that sense,

179
00:10:29,853 --> 00:10:33,224
计算机科学就像是工程中的一种抽象形式
computer science is like an abstract form of engineering.

180
00:10:33,600 --> 00:10:35,589
在这种工程中 我们忽略
It's the kind of engineering where you ignore

181
00:10:35,719 --> 00:10:37,576
现实所施加的约束
the constraints that are imposed by reality.

182
00:10:41,925 --> 00:10:45,701
那么 这其中有哪些技术呢
Well, what are some of these techniques?

183
00:10:46,231 --> 00:10:47,740
计算机科学中并没有特别的技术
They're not special to computer science.

184
00:10:50,394 --> 00:10:52,102
第一个技术是在很多工程中都使用的
First technique, which is used in all of engineering,

185
00:10:53,613 --> 00:10:58,762
被称为“黑盒抽象”的方法
is a kind of abstraction called black-box abstraction.

186
00:11:07,831 --> 00:11:12,139
即将一些东西组合并封装起来
Take something and build a box about it.

187
00:11:14,272 --> 00:11:19,434
以之前我们提到的求取平方根的方法为例
Let's see, for example, if we looked at that square root method,

188
00:11:22,816 --> 00:11:27,355
我将这些操作视为一个“盒子”
I might want to take that and build a box.

189
00:11:30,236 --> 00:11:36,740
也就是说 为了找到X的平方根
That sort of says, to find the square root of X.

190
00:11:38,905 --> 00:11:40,820
或许会有一系列的复杂规则
And that might be a whole complicated set of rules.

191
00:11:42,559 --> 00:11:46,182
我们将规则封装 给定输入数据即可获取结果
And that might end up being a kind of thing where I can put in,

192
00:11:46,650 --> 00:11:49,615
比如说 输入36 然后说36的平方根是多少呢
say, 36 and say, what's the square root of 36?

193
00:11:49,910 --> 00:11:51,011
则给出结果 6
And out comes 6.

194
00:11:54,326 --> 00:11:55,973
重点是
And the important thing is that

195
00:11:56,152 --> 00:11:57,637
通过这样的设计 
I'd like to design that so that

196
00:11:59,612 --> 00:12:03,633
可以方便他人的使用
if George comes along and would like to compute,

197
00:12:05,119 --> 00:12:09,463
例如Goerge想计算A的平方根加上B的平方根
say, the square root of A plus the square root of B,

198
00:12:11,376 --> 00:12:14,278
他无需了解“盒子”内部的构成
he can take this thing and use it as a module 

199
00:12:14,385 --> 00:12:15,508
而直接可以以模块的形式使用它
without having to look inside 

200
00:12:15,645 --> 00:12:17,856
也可以利用它去构建新的“盒子”
and build something that looks like this, 

201
00:12:18,503 --> 00:12:23,752
例如构建一个 A和B以及一个平方根和或者另一个平方根盒子
like an A and a B and a square root box and another square root box 

202
00:12:24,496 --> 00:12:33,427
然后将这些结果加在一起并输出答案
and then something that adds that would put out the answer.

203
00:12:33,761 --> 00:12:37,700
如你所见 就我想实现的功能的层面来看
And you can see, just from the fact that I want to do that,

204
00:12:38,828 --> 00:12:39,979
对于George来说
is from George's point of view,

205
00:12:40,269 --> 00:12:42,652
盒子内部是什么样并不重要
the internals of what's in here should not be important.

206
00:12:44,148 --> 00:12:47,018
例如 以下这些说法都没什么问题
So for instance, it shouldn't matter that, when I wrote this,

207
00:12:47,176 --> 00:12:49,876
我说求X的平方根
I said I want to find the square root of X.

208
00:12:50,651 --> 00:12:51,827
也可以说计算Y的平方根
I could have said the square root of Y,

209
00:12:52,611 --> 00:12:55,176
或者其它任何数的平方根
or the square root of A, or anything at all

210
00:12:56,768 --> 00:13:01,778
黑盒抽象的基本规则是
That's the fundamental notion of putting something in a box

211
00:13:03,442 --> 00:13:05,995
将处理过程放入盒子里以隐藏细节
using black-box abstraction to suppress detail.

212
00:13:07,500 --> 00:13:10,541
这样做的原因则是你可以脱身去构建更大的盒子
And the reason for that is you want to go off and build bigger boxes.

213
00:13:11,906 --> 00:13:14,195
现在 除了隐藏细节外
Now, there's another reason for doing black-box abstraction

214
00:13:14,369 --> 00:13:18,215
使用黑盒抽象还有另外一个原因
other than you want to suppress detail for building bigger boxes.

215
00:13:18,336 --> 00:13:24,757
有的时候 你想要用
Sometimes you want to say that your way of doing something,

216
00:13:24,898 --> 00:13:26,432
你的方式去完成一件事
your how-to method,

217
00:13:28,391 --> 00:13:30,343
这是常有的事儿
is an instance of a more general thing,

218
00:13:31,119 --> 00:13:34,122
同时 你也希望你的表述方式能够具有普遍性
and you'd like your language to be able to express that generality.

219
00:13:35,573 --> 00:13:37,677
我们接着用实例来说明
Let me show you another example 

220
00:13:37,804 --> 00:13:39,777
继续刚才关于平方根的讨论
sticking with square roots. 

221
00:13:39,913 --> 00:13:42,106
让我们回过头再来看看
Let's go back and take another look at that slide

222
00:13:42,257 --> 00:13:43,304
求平方根的算法
with the square root algorithm on it.

223
00:13:44,367 --> 00:13:45,177
想一想之前是怎么说的
Remember what that says.

224
00:13:46,003 --> 00:13:49,149
为了求解 首先要作出猜测
That says, in order to do something, I make a guess,

225
00:13:50,677 --> 00:13:54,392
然后基于这个猜测 做出持续不断的改进
and I improve that guess, and I sort of keep improving that guess.

226
00:13:55,994 --> 00:13:59,692
因此就存在一个找到某个到结果的通用方法
So there's the general strategy of, I'm looking for something,

227
00:14:01,233 --> 00:14:03,552
就是持续不断地改进结果
and the way I find it is that I keep improving it.

228
00:14:04,255 --> 00:14:09,804
这个例子 则可以做为找到某个结果的不动点
Now, that's a particular case of another kind of strategy

229
00:14:10,944 --> 00:14:12,785
策略的特例
for finding a fixed point of something.

230
00:14:14,686 --> 00:14:16,142
每个函数都有一个不动点
So you have a fixed point of a function.

231
00:14:17,701 --> 00:14:25,588
函数的不动点是一个值
A fixed point of a function is something, is a value.

232
00:14:26,282 --> 00:14:31,342
F的不动点Y满足F(Y)=Y
A fixed point of a function F is a value Y, such that F of Y equals Y.

233
00:14:33,026 --> 00:14:40,188
首先要做是做出一个猜测
And the way I might do that is start with a guess.

234
00:14:42,074 --> 00:14:45,236
在迭代函数F时不会改变的东西则是我们所求的结果
And then if I want something that doesn't change when I keep applying F,

235
00:14:45,516 --> 00:14:49,340
我会不断迭代函数F直到结果不会有很大改变
is I'll keep applying F over and over until that result doesn't change very much.

236
00:14:50,125 --> 00:14:51,482
这就是一个通法
So there's a general strategy.

237
00:14:52,264 --> 00:14:55,913
因此 为了计算X的平方根
And then, for example, to compute the square root of X,

238
00:14:56,107 --> 00:15:03,007
我可以试着找到Y与X/Y的平均值函数的不动点
I can try and find a fixed point of the function which takes Y to the average of X/Y.

239
00:15:03,503 --> 00:15:07,334
因为如果我真有一个等于X平方根的Y
And the idea that is that if I really had Y equal to the square root of X,

240
00:15:08,092 --> 00:15:11,359
那么Y和X/Y应为同一值
then Y and X/Y would be the same value.

241
00:15:12,046 --> 00:15:13,452
它们俩都是X的平方根
They'd both be the square root of X,

242
00:15:15,027 --> 00:15:18,889
因为X除根号X得根号X
because X over the square root of X is the square root of X.

243
00:15:19,105 --> 00:15:21,391
如果平均值Y等于X的平方根
And so the average if Y were equal to the square of X,

244
00:15:22,294 --> 00:15:24,767
那么这个平均值就不会改变
then the average wouldn't change. 

245
00:15:26,015 --> 00:15:28,364
因此X的平方根即是某一特定函数的不动点
So the square root of X is a fixed point of that particular function.

246
00:15:30,181 --> 00:15:33,005
现在 我将要描述
Now, what I'd like to have, I'd like to express 

247
00:15:33,872 --> 00:15:35,972
寻找不动点的通用方法
the general strategy for finding fixed points. 

248
00:15:36,360 --> 00:15:39,686
我所希望做的就是
So what I might imagine doing, is to find,

249
00:15:41,016 --> 00:15:46,190
用我自己的语言定义一个可以获得不动点的“盒子”
is to be able to use my language to define a box that says "fixed point,"

250
00:15:49,739 --> 00:15:51,749
正如我可以定义一个输出平方根的盒子一样
just like I could make a box that says "square root."

251
00:15:51,981 --> 00:15:54,980
我想要用自己的语言来表述
And I'd like to be able to express this in my language.

252
00:15:56,258 --> 00:16:01,259
因此 对于这种“怎么做”的指令性知识
So I'd like to express not only the imperative how-to knowledge

253
00:16:01,398 --> 00:16:03,143
我不仅是想表达具体应该如何求平方根
of a particular thing like square root,

254
00:16:03,477 --> 00:16:05,401
我也希望能够表述更加通用问题
but I'd like to be able to express the imperative knowledge

255
00:16:05,583 --> 00:16:07,820
例如 怎么求取不动点
of how to do a general thing like how to find fixed point.

256
00:16:09,920 --> 00:16:12,662
让我们再回过头来看看之前的幻灯片
And in fact, let's go back and look at that slide again.

257
00:16:14,943 --> 00:16:23,256
不但如何去求取一个不动点
See, not only is this a piece of imperative knowledge,

258
00:16:23,396 --> 00:16:24,879
是一种指令性知识
how to find a fixed point,

259
00:16:26,264 --> 00:16:27,218
在这下面  这里
but over here on the bottom,

260
00:16:27,379 --> 00:16:29,874
这儿还有另一种指令性知识 说的是
there's another piece of imperative knowledge which says,

261
00:16:30,330 --> 00:16:35,400
计算平方根的一种方法就是应用找不动点的方法
one way to compute square root is to apply this general fixed point method.

262
00:16:36,111 --> 00:16:38,449
如果 也想要表述这种指令性知识
So I'd like to also be able to express that imperative knowledge.

263
00:16:39,647 --> 00:16:40,524
那结果会是什么样呢？
What would that look like?

264
00:16:40,719 --> 00:16:44,458
这个不动点盒子可能会是这样
That would say, this fixed point box is such that

265
00:16:45,658 --> 00:16:58,533
如果我输入一个函数 该函数从Y映射到Y和X/Y的平均值
if I input to it the function that takes Y to the average of Y and X/Y,

266
00:16:59,606 --> 00:17:05,781
然后我们将会得到求不动点的盒子就是求平方根的一个方法
then what should come out of that fixed point box is a method for finding square roots.

267
00:17:08,843 --> 00:17:10,026
因此在这些我们构建的盒子中
So in these boxes we're building,

268
00:17:10,210 --> 00:17:14,540
输入和输出都不局限于数字
we're not only building boxes that you input numbers and output numbers,

269
00:17:16,336 --> 00:17:18,092
我们将要构建能够
we're going to be building in boxes that,

270
00:17:18,225 --> 00:17:21,112
找到平方根计算方法的盒子
in effect, compute methods like finding square root.

271
00:17:22,229 --> 00:17:25,316
我用的是一个输入函数
And my take is their inputs functions,

272
00:17:26,406 --> 00:17:28,846
比如Y映射到Y和X/Y的平均值的函数
like Y goes to the average of Y and X/Y.

273
00:17:29,851 --> 00:17:31,375
我们之所以采用这种方式是希望
The reason we want to do that,

274
00:17:32,080 --> 00:17:35,455
输入是一个过程 输出也是一个过程
the reason this is a procedure, will end up being a procedure,

275
00:17:35,685 --> 00:17:38,165
处理过程中产生的值也是一个过程
as we'll see, whose value is another procedure,

276
00:17:39,341 --> 00:17:40,659
之所以这样做是因为
the reason we want to do that is because

277
00:17:40,839 --> 00:17:45,822
我们将通过程序来讨论指令性知识
procedures are going to be our ways of talking about imperative knowledge. 

278
00:17:47,917 --> 00:17:49,564
这种处理方式很强大
And the way to make that very powerful is

279
00:17:49,697 --> 00:17:51,765
我们将可以基于此来讨论其它类型的知识
to be able to talk about other kinds of knowledge.

280
00:17:53,324 --> 00:17:56,070
实际上 我们讨论的是一种生成过程的过程
So here is a procedure that, in effect, talks about another procedure,

281
00:17:57,126 --> 00:17:59,899
一种生成通法的通法
a general strategy that itself talks about general strategies.

282
00:18:04,072 --> 00:18:07,798
那么 我们将主要讨论三个主题的内容
Well, our first topic in this course-- 

283
00:18:07,994 --> 00:18:09,616
而首个主题则是
there'll be three major topics-- 

284
00:18:09,766 --> 00:18:10,966
黑盒抽象
will be black-box abstraction.

285
00:18:11,080 --> 00:18:13,376
让我们稍稍深入一点
Let's look at that in a little bit more detail.

286
00:18:15,135 --> 00:18:23,595
我们将讨论
What we're going to do is we will start out talking about

287
00:18:23,793 --> 00:18:26,271
Lisp是如何通过基本对象建立起来的
how Lisp is built up out of primitive objects.

288
00:18:27,371 --> 00:18:28,758
以及Lisp的构成
What does the language supply with us?

289
00:18:29,598 --> 00:18:32,984
接下来 将会涉及到一些基本过程和基础数据
And we'll see that there are primitive procedures and primitive data.

290
00:18:36,171 --> 00:18:36,759
然后我们将会看到
Then we're going to see,

291
00:18:36,870 --> 00:18:38,523
我们如何使用这些基本对象
how do you take those primitives and 

292
00:18:38,624 --> 00:18:40,316
并把它们组合起来构建更复杂的东西
combine them to make more complicated things, 

293
00:18:41,439 --> 00:18:42,471
及相应的组合方法
means of combination?

294
00:18:42,653 --> 00:18:45,858
后续将讨论各种进行组合的方法以及
And what we'll see is that there are ways of putting things together,

295
00:18:46,394 --> 00:18:50,218
如何用基本过程来构建更复杂的过程
putting primitive procedures together to make more complicated procedures.

296
00:18:50,971 --> 00:18:53,982
同时 我们也将看到如何将基本数据组合成复合数据
And we'll see how to put primitive data together to make compound data.

297
00:18:56,108 --> 00:18:59,291
然后我们将会介绍如何对复合数据
Then we'll say, well, having made those compounds things,

298
00:18:59,677 --> 00:19:00,917
如何将它们抽象出来
how do you abstract them?

299
00:19:02,793 --> 00:19:04,664
如何用黑盒对它们进行封装
How do you put those black boxes around them

300
00:19:04,756 --> 00:19:07,711
使得你可以将它们作为组件用于更复杂的东西
so you can use them as components in more complex things?

301
00:19:08,038 --> 00:19:10,483
我们会发现这些都是通过定义程序
And we'll see that's done by defining procedures and

302
00:19:11,495 --> 00:19:14,349
以及一种处理复合数据的数据抽象技术完成的
a technique for dealing with compound data called data abstraction.

303
00:19:15,400 --> 00:19:16,915
最重要的是
And then, what's maybe the most important thing,

304
00:19:17,967 --> 00:19:21,040
我们可以从中了解到专家是如何工作的
is going from just the rules to how does an expert work?

305
00:19:21,624 --> 00:19:26,923
对于找不动点的方法来讲 
How do you express common patterns of doing things, like saying, well,

306
00:19:27,059 --> 00:19:28,575
找平方根的方式是它的一个特例
there's a general method of fixed point and

307
00:19:28,773 --> 00:19:30,424
你如何表述完成工作中所存在的通用模式呢？
square root is a particular case of that?

308
00:19:31,933 --> 00:19:34,349
我们将会使用
And we're going to use--

309
00:19:34,541 --> 00:19:35,641
之前已经提到过的
I've already hinted at it-- 

310
00:19:35,811 --> 00:19:36,859
某种叫做高阶过程的东西
something called higher-order procedures,

311
00:19:37,184 --> 00:19:41,609
也就是说 它的输入输出和它本身都是过程
namely procedures whose inputs and outputs are themselves procedures.

312
00:19:43,224 --> 00:19:44,636
我们将会看到一些有趣的东西
And then we'll also see something very interesting.

313
00:19:44,853 --> 00:19:48,040
随着学习的深入 将会越发抽象
We'll see, as we go further and further on and become more abstract,

314
00:19:48,658 --> 00:19:49,864
那么将会发现
there'll be very--

315
00:19:49,982 --> 00:19:53,567
我们认为是数据和我们认为是过程之间的
well, the line between what we consider to be data and

316
00:19:53,716 --> 00:19:57,350
分界线将变得模糊到难以置信的程度
what we consider to be procedures is going to blur at an incredible rate.

317
00:20:02,992 --> 00:20:06,679
这便是我们的第一个主题 黑盒抽象
Well, that's our first subject, black-box abstraction.

318
00:20:06,917 --> 00:20:08,174
让我们来看看第二个主题
Let's look at the second topic.

319
00:20:11,123 --> 00:20:13,434
这样说吧
I can introduce it like this.

320
00:20:13,652 --> 00:20:17,644
假设我想表达某个想法
See, suppose I want to express the idea--

321
00:20:19,570 --> 00:20:21,838
请注意 我们讨论的是想法
remember, we're talking about ideas--

322
00:20:22,978 --> 00:20:24,923
比如说
suppose I want to express the idea that

323
00:20:26,475 --> 00:20:34,579
我想将某个元素与另两个元素之和相乘
I can take something and multiply it by the sum of two other things.

324
00:20:36,128 --> 00:20:37,482
举例来说
So for example, I might say, 

325
00:20:38,010 --> 00:20:41,078
我用1和3（之和）乘2 得8
if I had 1 and 3 and multiply that by 2, I get 8.

326
00:20:41,916 --> 00:20:44,666
但我这里想讨论的是关于线性组合的基本想法
But I'm talking about the general idea of what's called linear combination,

327
00:20:45,386 --> 00:20:47,537
是说你可以将两个元素的和乘以另一个元素
that you can add two things and multiply them by something else.

328
00:20:49,220 --> 00:20:50,682
在数集内思考这个问题是很容易的
It's very easy when I think about it for numbers,

329
00:20:50,946 --> 00:20:54,963
但假设我想将这个想法应用于
but suppose I also want to use that same idea to think about,

330
00:20:56,040 --> 00:20:58,130
对两向量a1和a2相加
I could add two vectors, a1 and a2,

331
00:20:59,802 --> 00:21:02,748
乘以某一因子x然后得到另一向量
and then scale them by some factor x and get another vector.

332
00:21:03,142 --> 00:21:09,309
我甚至可以说 若a1和a2皆为多项式
Or I might say, I want to think about a1 and a2 as being polynomials,

333
00:21:10,975 --> 00:21:13,999
我想对这两个多项式求和
and I might want to add those two polynomials and

334
00:21:14,139 --> 00:21:16,886
然后乘以2得到一个多项式
then multiply them by 2 to get a more complicated one.

335
00:21:20,066 --> 00:21:23,389
同理 a1或a2也可以是电信号
Or a1 and a2 might be electrical signals,

336
00:21:24,411 --> 00:21:27,713
我想将二个信号加和
and I might want to think about summing those two electrical signals and

337
00:21:27,873 --> 00:21:29,832
并将结果放入一个放大器
then putting the whole thing through an amplifier,

338
00:21:30,024 --> 00:21:32,585
用一个类似于2的因子乘以它们
multiplying it by some factor of 2 or something.

339
00:21:33,894 --> 00:21:36,669
这种想法的基本点是 我希望用一个通用记号表示它们
The idea is I want to think about the general notion of that.

340
00:21:38,479 --> 00:21:45,386
假如我们的语言可以很好的表述这类想法
Now, if our language is going to be good language for expressing those kind of general ideas,

341
00:21:47,056 --> 00:21:48,611
如果真可以这样的话
if I really, really can do that,

342
00:21:50,726 --> 00:21:51,456
我将会以这样的方式表述
I'd like to be able to say

343
00:21:55,014 --> 00:21:59,965
用x乘以a1和a2的和
I'm going to multiply by x the sum of a1 and a2,

344
00:22:02,771 --> 00:22:06,113
更进一步 我希望做更抽象更基本的表述
and I'd like that to express the general idea of

345
00:22:06,283 --> 00:22:09,088
使其可以适应各个不同类型的a1和a2
all different kinds of things that a1 and a2 could be.

346
00:22:09,887 --> 00:22:11,419
现在回过头来想想 似乎有点问题 
Now, if you think about that, there's a problem,

347
00:22:11,549 --> 00:22:15,764
毕竟 对两个数字和两个多项式进行加和运算
because after all, the actual primitive operations

348
00:22:16,044 --> 00:22:18,322
所用的基本操作
that go on in the machine are obviously going to be different

349
00:22:18,461 --> 00:22:22,535
在机器内部显然是不同的
if I'm adding two numbers than if I'm adding two polynomials,

350
00:22:23,257 --> 00:22:27,264
对两个电信号或声波加和也有同样的问题
or if I'm adding the representation of two electrical signals or wave forms.

351
00:22:27,845 --> 00:22:32,088
无论怎样 对不同类型的元素进行求和运算
Somewhere, there has to be the knowledge of the kinds of various things

352
00:22:32,425 --> 00:22:34,389
总是需要使用不同的方法
that you can add and the ways of adding them.

353
00:22:37,442 --> 00:22:38,812
现在 为了构建这样一个系统
Now, to construct such a system,

354
00:22:38,978 --> 00:22:40,490
我们将如何使用这些知识呢？
the question is, where do I put that knowledge?

355
00:22:41,092 --> 00:22:44,262
如何在各种方法中进行选择？
How do I think about the different kinds of choices I have?

356
00:22:44,448 --> 00:22:47,971
而如果明天George又想出了一种新类型的对象
And if tomorrow George comes up with a new kind of object

357
00:22:48,286 --> 00:22:49,962
并将它用于加和以及乘积
that might be added and multiplied,

358
00:22:50,834 --> 00:22:52,872
我又该如何把这个新类型引入到系统中
how do I add George's new object to the system

359
00:22:53,356 --> 00:22:55,234
而且能够做到不把已有的系统弄得一团糟？
without screwing up everything that was already there?

360
00:22:57,718 --> 00:23:00,259
这便是我们的第二大主题
Well, that's going to be the second big topic,

361
00:23:00,456 --> 00:23:02,715
控制复杂度的方法
the way of controlling that kind of complexity.

362
00:23:03,728 --> 00:23:07,980
我们实现的方法是按照约定来实现相应的接口
And the way you do that is by establishing conventional interfaces,

363
00:23:17,748 --> 00:23:20,058
并以此将各部分组合起来
agreed upon ways of plugging things together.

364
00:23:20,229 --> 00:23:21,598
就如同电气工程中
Just like in electrical engineering,

365
00:23:22,836 --> 00:23:24,861
人们为连接器规定标准阻抗
people have standard impedances for connectors,

366
00:23:26,023 --> 00:23:27,999
如果用符合这个标准的东西来构建系统
and then you know if you build something with one of those standard impedances,

367
00:23:28,485 --> 00:23:30,268
你就知道你可以把各个部件组合在一起
you can plug it together with something else.

368
00:23:32,813 --> 00:23:35,233
这就是我们将要讨论的第二个主题：约定接口
So that's going to be our second large topic, conventional interfaces.

369
00:23:35,645 --> 00:23:40,715
如我之前提到的
What we're going to see is, first, we're going to talk about the problem of generic operations,

370
00:23:40,923 --> 00:23:42,501
接下来我们将讨论通用操作中的问题
which is the one I alluded to,

371
00:23:42,653 --> 00:23:47,076
例如对各种不同类型数据进行均适用的加法操作
things like "plus" that have to work with all different kinds of data.

372
00:23:52,713 --> 00:23:54,329
随后则会讨论通用操作
So we talk about generic operations.

373
00:23:54,522 --> 00:23:56,635
然后我们将讨论大型架构问题
Then we're going to talk about really large-scale structures.

374
00:23:58,290 --> 00:24:00,380
如果通过对现实世界的复杂系统建模
How do you put together very large programs

375
00:24:00,912 --> 00:24:04,444
来构建大型程序
that model the kinds of complex systems in the real world that you'd like to model?

376
00:24:05,426 --> 00:24:06,408
我们将看到 在构建这样的系统时
And what we're going to see is that

377
00:24:06,494 --> 00:24:11,722
有两种非常重要的方法
there are two very important metaphors for putting together such systems.

378
00:24:11,862 --> 00:24:13,846
其一是面向对象编程
One is called object-oriented programming,

379
00:24:14,000 --> 00:24:18,415
在这种模式中 你把你的系统想象成一个社区
where you sort of think of your system as a kind of society

380
00:24:19,259 --> 00:24:21,919
社区中的各个部分都是通过相互间传递消息联系起来的
full of little things that interact by sending information between them.

381
00:24:23,318 --> 00:24:27,364
其二是关于聚集的操作 称作“流”
And then the second one is operations on aggregates, called streams,

382
00:24:27,798 --> 00:24:31,331
使用这种方式构建大型系统
where you think of a large system put together kind of

383
00:24:31,462 --> 00:24:34,844
类似于电气工程师构造大型电气系统
like a signal processing engineer puts together a large electrical system.

384
00:24:38,989 --> 00:24:40,400
这就是我们的第二个话题
That's going to be our second topic.

385
00:24:43,322 --> 00:24:45,759
现在 我们将要讨论第三个话题
Now, the third thing we're going to come to,

386
00:24:45,921 --> 00:24:49,258
控制复杂度的第三个技术
the third basic technique for controlling complexity,

387
00:24:49,492 --> 00:24:50,731
便是定义新的语言
is making new languages.

388
00:24:51,706 --> 00:24:55,168
因为有时 当你有点受不了设计的复杂度时
Because sometimes, when you're sort of overwhelmed by the complexity of a design,

389
00:24:55,340 --> 00:24:59,243
你可以通过定义一门新的语言来控制系统复杂度
the way that you control that complexity is to pick a new design language.

390
00:25:01,274 --> 00:25:05,493
新语言的设计意图是为了强调系统的某个方面
And the purpose of the new design language will be to highlight different aspects of the system.

391
00:25:05,832 --> 00:25:09,165
它一方面隐藏了部分细节 另一方面则但强调一些其他的细节
It will suppress some kinds of details and emphasize other kinds of details.

392
00:25:12,895 --> 00:25:15,717
这部分将是课程中最神奇的部分
This is going to be the most magical part of the course.

393
00:25:15,899 --> 00:25:20,757
我们将开始于构建新的计算机语言
We're going to start out by actually looking at the technology for building new computer languages.

394
00:25:21,243 --> 00:25:25,858
实际上我们首先要完成的工作已经内建于Lisp之中了
The first thing we're going to do is actually build in Lisp.

395
00:25:29,397 --> 00:25:33,575
我们将展现如何用Lisp来解释Lisp
We're going to express in Lisp the process of interpreting Lisp itself.

396
00:25:34,253 --> 00:25:36,794
这是一个非常类似于自循环的过程
And that's going to be a very sort of self-circular thing.

397
00:25:37,180 --> 00:25:39,569
这与（Lisp中）一个神奇的符号有关
There's a little mystical symbol that has to do with that.

398
00:25:40,978 --> 00:25:46,252
解释Lisp的步骤是
The process of interpreting Lisp is sort of a giant wheel of two processes,

399
00:25:46,389 --> 00:25:47,827
应用和求值——这两大步骤的轮转
apply and eval,

400
00:25:47,958 --> 00:25:50,429
这两者不断地互相交替进行
which sort of constantly reduce expressions to each other.

401
00:25:52,413 --> 00:25:53,934
接下来 我们将看到其余神奇的东西
Then we're going to see all sorts of other magical things.

402
00:25:54,103 --> 00:25:56,406
譬如另一种魔法符号
Here's another magical symbol.

403
00:25:56,946 --> 00:26:01,074
一种叫做Y运算符的东西
This is sort of the Y operator,

404
00:26:01,377 --> 00:26:06,306
某种意义上 它在过程式语言中用于 表达无限
which is, in some sense, the expression of infinity inside our procedural language.

405
00:26:06,419 --> 00:26:07,628
我们也会谈论到它
We'll take a look at that.

406
00:26:08,531 --> 00:26:14,373
总之 这部分课程被称作“元语言抽象”
In any case, this section of the course is called Metalinguistic Abstraction,

407
00:26:16,154 --> 00:26:25,785
主要讨论如何构建一门新语言
abstracting by talking about how you construct new languages.

408
00:26:30,313 --> 00:26:35,360
如我所言 我们将从了解解释的过程开始
As I said, we're going to start out by looking at the process of interpretation.

409
00:26:35,587 --> 00:26:41,677
随后则一起讨论应用-求值循环和构建Lisp
We're going to look at this apply-eval loop, and build Lisp.

410
00:26:42,145 --> 00:26:43,728
你将发现这种方法具有相当的普遍性
Then, just to show you that this is very general,

411
00:26:44,292 --> 00:26:47,814
我们将用同样的技术去构建一门全完不同的语言
we're going to use exactly the same technology to build a very different kind of language,

412
00:26:48,489 --> 00:26:49,861
一种所谓的逻辑编程语言
a so-called logic programming language,

413
00:26:50,512 --> 00:26:54,389
一种无关具有输入和输出的过程
where you don't really talk about procedures at all that have inputs and outputs.

414
00:26:54,579 --> 00:26:56,803
而仅关注元素之间关系的语言
What you do is talk about relations between things.

415
00:26:57,251 --> 00:27:03,475
最终 我们将讨论如何将这些东西
And then finally, we're going to talk about how you implement these things very concretely

416
00:27:03,668 --> 00:27:04,969
实实在在的实现在简单的机器上
on the very simplest kind of machines.

417
00:27:05,601 --> 00:27:07,942
比如说这个
We'll see something like this.

418
00:27:09,046 --> 00:27:11,690
如图所示的芯片
This is a picture of a chip,

419
00:27:11,923 --> 00:27:17,287
就是我们在硬件部分谈及的Lisp解释器
which is the Lisp interpreter that we will be talking about then in hardware.

420
00:27:19,908 --> 00:27:23,342
这三大主题就是本课的提纲
Well, there's an outline of the course, three big topics.

421
00:27:24,869 --> 00:27:28,969
黑盒抽象 约定接口 元语言抽象
Black-box abstraction, conventional interfaces, metalinguistic abstraction.

422
00:27:31,602 --> 00:27:33,466
好 先休息一会儿 然后正式开始
Now, let's take a break now and then we'll get started.

423
00:27:52,075 --> 00:28:02,571
[音乐]
[JESU, JOY OF MAN'S DESIRING]

424
00:28:03,821 --> 00:28:06,392
现在让我们正式开始学习Lisp
Let's actually start in learning Lisp now.

425
00:28:07,945 --> 00:28:10,734
事实上 我们将开始学习一些非常重要的内容
Actually, we'll start out by learning something much more important,

426
00:28:10,907 --> 00:28:13,957
在这门课程中最重要的 不是Lisp本身
maybe the very most important thing in this course, which is not Lisp, 

427
00:28:14,137 --> 00:28:17,964
而是一种的通用框架体系
in particular, of course, but rather a general framework

428
00:28:18,443 --> 00:28:21,291
我们用它来组织我之前提到的语言
for thinking about languages that I already alluded to.

429
00:28:21,671 --> 00:28:24,650
当有人要向你展示一门新语言
When somebody tells you they're going to show you a language,

430
00:28:24,837 --> 00:28:25,957
你应该问他
what you should say is,

431
00:28:26,092 --> 00:28:32,426
（构成语言的）基本元素有哪些？
what I'd like you to tell me is what are the primitive elements?

432
00:28:37,454 --> 00:28:38,339
这门语言使用哪些基本元素？
What does the language come with?

433
00:28:38,990 --> 00:28:43,637
你是如何将这些元素组合在一起的？
Then, what are the ways you put those together?

434
00:28:43,795 --> 00:28:47,545
组合的方法是什么？
What are the means of combination?

435
00:28:50,166 --> 00:28:53,738
允许你将这些基本元素整合在一起
What are the things that allow you to take these primitive elements

436
00:28:54,314 --> 00:28:56,425
以构建更大的对象的又是什么？
and build bigger things out of them?

437
00:28:57,909 --> 00:28:59,293
把东西构建在一起的方法是什么？
What are the ways of putting things together?

438
00:29:01,238 --> 00:29:05,567
以及 抽象的方法是什么？
And then, what are the means of abstraction?

439
00:29:08,301 --> 00:29:16,763
我们如何利用这些元素并把它们封装成盒子？
How do we take those complicated things and draw those boxes around them?

440
00:29:16,804 --> 00:29:19,330
我们如何为它们命名使得我们可以
How do we name them so that we can now use them

441
00:29:19,546 --> 00:29:23,677
把它们当作基本元素来用于构建更复杂的东西？
as if they were primitive elements in making still more complex things?

442
00:29:23,883 --> 00:29:25,834
等等 等等 等等
And so on, and so on, and so on.

443
00:29:26,827 --> 00:29:27,894
因此 当有人告诉你
So when someone says to you, gee,

444
00:29:28,053 --> 00:29:29,476
嘿 我发明了一种新的计算机语言
I have a great new computer language,

445
00:29:30,759 --> 00:29:34,363
你不应该问 用你的语言编写求逆矩阵需要多少代码
you don't say, how many characters does it take to invert a matrix?

446
00:29:35,760 --> 00:29:37,078
这是风马牛不相及的
It's irrelevant.

447
00:29:37,307 --> 00:29:41,854
如果该语言没有内建了矩阵或者类似的东西
What you say is, if the language did not come with matrices built in

448
00:29:42,185 --> 00:29:43,207
那你就应该问他
or with something else built in,

449
00:29:43,375 --> 00:29:45,772
应该如何构建矩阵？
how could I then build that thing?

450
00:29:45,953 --> 00:29:48,027
如何通过组合来构建？
What are the means of combination which would allow me to do that?

451
00:29:48,621 --> 00:29:50,261
如何对其进行抽象
And then, what are the means of abstraction

452
00:29:51,632 --> 00:29:53,762
把它作为基本元素
which allow me then to use those as elements

453
00:29:53,963 --> 00:29:56,076
来构建更复杂的东西？
in making more complicated things yet?

454
00:29:58,867 --> 00:30:04,167
我们将了解到Lisp的一些基本数据和基本过程
Well, we're going to see that Lisp has some primitive data and some primitive procedures.

455
00:30:05,394 --> 00:30:07,355
好吧 这次是真的开始了
In fact, let's really start.

456
00:30:08,805 --> 00:30:14,097
这里有一个Lisp的基本数据 数字3
And here's a piece of primitive data in Lisp, number 3.

457
00:30:16,688 --> 00:30:19,428
事实上 如果打破沙锅问到底的话 这不是数字3
Actually, if I'm being very pedantic, that's not the number 3.

458
00:30:19,778 --> 00:30:24,909
这只是一个符号 用以代表柏拉图观念下的数字3的
That's some symbol that represents Plato's concept of the number 3.

459
00:30:27,758 --> 00:30:29,112
这又是另一个
And here's another.

460
00:30:30,559 --> 00:30:35,673
这个是Lisp中又一个基本数据 17.4
Here's some more primitive data in Lisp, 17.4.

461
00:30:35,937 --> 00:30:38,833
又或者说 代表17.4
Or actually, some representation of 17.4.

462
00:30:41,415 --> 00:30:43,890
这儿还有一个5
And here's another one, 5.

463
00:30:46,701 --> 00:30:51,793
然后这儿又有一个内建于Lisp的基本对象“+”
Here's another primitive object that's built in Lisp, addition.

464
00:30:52,066 --> 00:30:55,345
如果又要继续深究的话
Actually, to use the same kind of pedantic--

465
00:30:55,495 --> 00:31:00,020
这只是一个名字 代表对元素进行加和的基本方法而已
this is a name for the primitive method of adding things.

466
00:31:00,187 --> 00:31:02,428
就像这个是柏拉图式的3
Just like this is a name for Plato's number 3,

467
00:31:02,570 --> 00:31:08,879
这也只是一个代表柏拉图观念下的将某些元素加和起来
this is a name for Plato's concept of how you add things.

468
00:31:10,222 --> 00:31:11,532
这些都是基本元素
So those are some primitive elements.

469
00:31:11,882 --> 00:31:13,318
我可以将它们放在一起
I can put them together.

470
00:31:14,081 --> 00:31:17,775
我可以说 3加17.4加5的和是多少
I can say, gee, what's the sum of 3 and 17.4 and 5?

471
00:31:18,686 --> 00:31:20,834
这等同于说
And the way I do that is to say,

472
00:31:21,016 --> 00:31:27,473
让我们把求和运算符应用于这三个数
let's apply the sum operator to these three numbers.

473
00:31:27,653 --> 00:31:30,709
我可以得到什么呢 是8 是17 还是25.4
And I should get, what? 8, 17. 25.4.

474
00:31:34,434 --> 00:31:37,487
因此 我可以问Lisp这个的值是多少
So I should be able to ask Lisp what the value of this is,

475
00:31:38,938 --> 00:31:40,262
（表达式）返回25.4
and it will return 25.4.

476
00:31:43,467 --> 00:31:44,687
介绍一些术语吧
Let's introduce some names.

477
00:31:44,817 --> 00:31:53,297
我所写的这些东西就叫做组合式
This thing that I typed is called a combination.

478
00:31:56,806 --> 00:32:01,496
通常 一个组合式是由运算符 
And a combination consists, in general, of applying an operator-- 

479
00:32:03,557 --> 00:32:07,137
这些就是运算符
so this is an operator--

480
00:32:09,764 --> 00:32:13,368
和应用该运算符的运算对象组成
to some operands.

481
00:32:13,534 --> 00:32:14,329
这些是运算对象
These are the operands.

482
00:32:21,780 --> 00:32:23,348
当然 我可以完成更复杂的事
And of course, I can make more complex things.

483
00:32:23,644 --> 00:32:28,110
我可以使之更复杂是因为 这些运算对象
The reason I can get complexity out of this is because the operands themselves,

484
00:32:29,442 --> 00:32:30,864
通常来说 也可以是组合式
in general, can be combinations.

485
00:32:31,156 --> 00:32:44,026
比如 3加上5乘以6乘以8乘以2的积的和是多少
So for instance, I could say, what is the sum of 3 and the product of 5 and 6 and 8 and 2?

486
00:32:45,796 --> 00:32:52,401
而我应该得到 我算一下 30 40 43
And I should get-- let's see-- 30, 40, 43.

487
00:32:52,785 --> 00:32:54,557
因此Lisp会返回这个表达式的值是43
So Lisp should tell me that that's 43.

488
00:32:56,623 --> 00:33:02,540
后续我们将看到构造组合式是组合的基本需求
Forming combinations is the basic needs of combination that we'll be looking at.

489
00:33:04,715 --> 00:33:08,773
你所看到的这些语法
And then, well, you see some syntax here.

490
00:33:10,502 --> 00:33:12,883
就是Lisp用的所谓的前缀表示法
Lisp uses what's called prefix notation,

491
00:33:16,441 --> 00:33:24,766
意即操作符在操作数的左端
which means that the operator is written to the left of the operands.

492
00:33:25,503 --> 00:33:26,494
这只是个约定
It's just a convention.

493
00:33:27,721 --> 00:33:29,328
注意 这些都被括起来了
And notice, it's fully parenthesized.

494
00:33:29,994 --> 00:33:32,141
这些括号使得它们区别开来
And the parentheses make it completely unambiguous.

495
00:33:32,362 --> 00:33:37,354
因此只要看看这个 我就可以知道这个是运算符
So by looking at this, I can see that there's the operator,

496
00:33:37,572 --> 00:33:40,543
以及这有1个 2个 3个 4个运算对象
and there are 1, 2, 3, 4 operands.

497
00:33:42,802 --> 00:33:47,314
而且我也可以发现第二个运算对象是个组合式
And I can see that the second operand here is itself some combination

498
00:33:48,881 --> 00:33:51,101
该组合式有一个运算符和两个运算对象
that has one operator and two operands.

499
00:33:52,491 --> 00:33:54,164
Lisp中的括号 有点或者非常不同于
Parentheses in Lisp are a little bit,

500
00:33:54,620 --> 00:33:57,264
通常数学中的括号
or are very unlike parentheses in conventional mathematics.

501
00:33:57,754 --> 00:33:59,581
数学中 我们常将其用于分组
In mathematics, we sort of use them to mean grouping,

502
00:34:01,127 --> 00:34:03,305
如果有时你忘了闭合括号 但其他人能理解你的意图
and it sort of doesn't hurt if sometimes you leave out parentheses

503
00:34:03,771 --> 00:34:05,112
这也无关紧要
if people understand that that's a group.

504
00:34:05,758 --> 00:34:07,851
通常的 你多加了括号也无所谓
And in general, it doesn't hurt if you put in extra parentheses,

505
00:34:08,727 --> 00:34:10,587
因为这样只会使得分组更加明确
because that maybe makes the grouping more distinct.

506
00:34:10,831 --> 00:34:11,773
Lisp可不像这样
Lisp is not like that.

507
00:34:12,959 --> 00:34:14,676
Lisp中你既不能不闭合括号
In Lisp, you cannot leave out parentheses,

508
00:34:16,302 --> 00:34:17,881
亦不能添加多余的括号
and you cannot put in extra parentheses,

509
00:34:19,187 --> 00:34:21,036
因为加括号总是意味着
because putting in parentheses always means,

510
00:34:21,233 --> 00:34:26,607
确切的来说 所括之物是一个组合式
exactly and precisely, this is a combination which has meaning,

511
00:34:26,805 --> 00:34:28,512
表示将运算符应用于运算对象
applying operators to operands.

512
00:34:29,118 --> 00:34:32,378
如果我不闭合这个括号
And if I left this out, if I left those parentheses out,

513
00:34:32,586 --> 00:34:33,510
这个就变成其它的意思了
it would mean something else.

514
00:34:35,360 --> 00:34:37,538
事实上 我们可以这么来理解这个问题
In fact, the way to think about this,

515
00:34:37,717 --> 00:34:41,658
把我写的这些东西想作一个树
is really what I'm doing when I write something like this is writing a tree.

516
00:34:42,303 --> 00:34:46,858
这个组合式实际上是一个树 树具有一个“+”
So this combination is a tree that has a plus and

517
00:34:46,985 --> 00:34:54,349
以及 一个3和一些其它的东西和一个8 还有一个2
then a 3 and then a something else and an 8 and a 2.

518
00:34:54,544 --> 00:34:56,283
而这里的其它的东西
And then this something else here is 

519
00:34:56,443 --> 00:35:02,774
它本身是一个有一个“*”一个5和一个6的子树
itself a little subtree that has a star and a 5 and a 6.

520
00:35:03,837 --> 00:35:05,266
我们可以这样认为
And the way to think of that is, really,

521
00:35:05,401 --> 00:35:08,556
我们只是在构建这些树而已
what's going on are we're writing these trees,

522
00:35:09,136 --> 00:35:15,177
括号只是将这种二维结构写作线性字符串
and parentheses are just a way to write this two-dimensional structure

523
00:35:15,816 --> 00:35:17,451
的一种方法罢了
as a linear character string.

524
00:35:19,223 --> 00:35:23,720
因为至少在Lisp发明时 人们还在用电传打字机或者打孔卡
Because at least when Lisp first started and people had teletypes or punch cards or whatever,

525
00:35:24,143 --> 00:35:25,154
这种记法方便多了
this was more convenient.

526
00:35:25,357 --> 00:35:30,071
如果Lisp是在当下被发明的 语法可能会像树那样
Maybe if Lisp started today, the syntax of Lisp would look like that.

527
00:35:31,819 --> 00:35:34,621
那么 让我们看看在计算机里面它究竟是什么样
Well, let's look at what that actually looks like on the computer.

528
00:35:36,337 --> 00:35:39,181
这里有个Lisp解释套件
Here I have a Lisp interaction set up.

529
00:35:39,379 --> 00:35:40,942
这是个编辑器
There's a editor.

530
00:35:41,083 --> 00:35:44,418
我将要在上方写一些表达式并让Lisp对其求值
And on the top, I'm going to type some values and ask Lisp what they are.

531
00:35:45,063 --> 00:35:46,301
比如 我可以问Lisp
So for instance, I can say to Lisp,

532
00:35:46,475 --> 00:35:48,081
这个符号的值是多少
what's the value of that symbol?

533
00:35:49,398 --> 00:35:50,058
我键入3
That's 3.

534
00:35:50,556 --> 00:35:51,754
然后叫Lisp对其求值
And I ask Lisp to evaluate it.

535
00:35:51,960 --> 00:35:54,323
然后你就会看到Lisp在下面返回了一些信息
And there you see Lisp has returned on the bottom,

536
00:35:55,354 --> 00:35:56,391
这个值就是3
and said, oh yeah, that's 3.

537
00:35:57,832 --> 00:36:04,517
我也可以问 3加上4加上8的和是多少
Or I can say, what's the sum of 3 and 4 and 8?

538
00:36:06,551 --> 00:36:07,605
键入这个组合式
What's that combination?

539
00:36:08,972 --> 00:36:10,217
让Lisp对其求值
And ask Lisp to evaluate it.

540
00:36:14,669 --> 00:36:15,538
返回15
That's 15.

541
00:36:16,565 --> 00:36:18,439
我可以键入一些更复杂的东西
Or I can type in something more complicated.

542
00:36:19,240 --> 00:36:33,695
将3乘以7加19.5的和的乘积求和得多少
I can say, what's the sum of the product of 3 and the sum of 7 and 19.5?

543
00:36:35,860 --> 00:36:37,747
你会发现Lisp内建了一些功能
And you'll notice here that Lisp has something built in

544
00:36:37,976 --> 00:36:39,652
帮你跟踪这些括号
that helps me keep track of all these parentheses.

545
00:36:39,809 --> 00:36:41,835
看我键入下一个右圆括号
Watch as I type the next closed parentheses,

546
00:36:42,082 --> 00:36:44,561
用于闭合以“*”开头的那个组合式
which is going to close the combination starting with the star.

547
00:36:45,624 --> 00:36:46,852
开头的那个左括号会闪一下
The opening one will flash.

548
00:36:48,278 --> 00:36:49,241
我把这些括号擦去 再示范一次
Here, I'll rub those out and do it again.

549
00:36:50,185 --> 00:36:52,252
键入右括号 闭合了“+”组合式
Type close, and you see that closes the plus.

550
00:36:53,642 --> 00:36:55,823
再键入右括号 闭合了“*”组合式
Close again, that closes the star.

551
00:36:57,976 --> 00:37:00,314
现在我又回到了加 我将它们与4相加
Now I'm back to the sum, and maybe I'm going to add that all to 4.

552
00:37:01,749 --> 00:37:02,670
闭合了“+”组合式
That closes the plus.

553
00:37:02,896 --> 00:37:06,987
现在我补全了组合式 然后我问Lisp它们的值是多少
Now I have a complete combination, and I can ask Lisp for the value of that.

554
00:37:07,138 --> 00:37:11,272
这种内建于各种Lisp系统的
That kind of paren balancing is something that's built into

555
00:37:11,423 --> 00:37:12,847
括号匹配工具帮你跟进（括号匹配）
a lot of Lisp systems to help you keep track,

556
00:37:13,156 --> 00:37:16,106
因为手工闭合这些括号太辛苦了
because it is kind of hard just by hand doing all these parentheses.

557
00:37:16,766 --> 00:37:20,910
这又是另外一种保持括号跟进的约定
There's another kind of convention for keeping track of parentheses.

558
00:37:21,103 --> 00:37:23,291
我另外写一个复杂的组合式
Let me write another complicated combination.

559
00:37:24,812 --> 00:37:34,059
将3和5的积与某个元素求和
Let's take the sum of the product of 3 and 5 and add that to something.

560
00:37:34,219 --> 00:37:35,327
现在我将要缩进
And now what I'm going to do is

561
00:37:35,432 --> 00:37:39,561
使得这些运算对象都是垂直书写的
I'm going to indent so that the operands are written vertically.

562
00:37:40,117 --> 00:37:45,781
将这些加上47乘以
Which the sum of that and the product of 47 and--

563
00:37:47,280 --> 00:37:54,531
恩…… 47乘以20和6.8的差
let's say the product of 47 with a difference of 20 and 6.8.

564
00:37:54,713 --> 00:37:57,053
意即从20中减去6.8
That means subtract 6.8 from 20.

565
00:37:58,717 --> 00:37:59,997
然后 这个括号闭合了
And then you see the parentheses close.

566
00:38:00,283 --> 00:38:03,020
闭合“-” 闭合“*”
Close the minus. Close the star.

567
00:38:03,972 --> 00:38:05,382
现在 我们再写一个运算符
And now let's get another operator.

568
00:38:05,507 --> 00:38:09,470
Lisp编辑器自动缩进到正确的位置
You see the Lisp editor here is indenting to the right position automatically

569
00:38:10,356 --> 00:38:11,188
来帮助我保持跟进
to help me keep track.

570
00:38:13,103 --> 00:38:14,073
我再示范一次
I'll do that again.

571
00:38:14,211 --> 00:38:15,706
这样就又闭合了最后一个括号
I'll close that last parentheses again.

572
00:38:16,170 --> 00:38:17,263
它匹配了这个“+”（的括号）
You see it balances the plus.

573
00:38:20,404 --> 00:38:22,192
现在我想问 这个的值是多少
Now I can say, what's the value of that?

574
00:38:23,903 --> 00:38:29,297
因此 这两件事 缩进到正确的位置
So those two things, indenting to the right level,

575
00:38:29,438 --> 00:38:30,416
也就是所谓的美观的输出
which is called pretty printing,

576
00:38:31,497 --> 00:38:33,050
以及闭合提示
and flashing parentheses,

577
00:38:33,943 --> 00:38:37,441
是许多Lisp系统所内建用于帮你保持跟进的工具
are two things that a lot of Lisp systems have built in to help you keep track.

578
00:38:37,655 --> 00:38:38,565
你应该学习如何使用它们
And you should learn how to use them.

579
00:38:41,705 --> 00:38:42,685
好 这些都是基本的内容
Ok, those are the primitives.

580
00:38:44,652 --> 00:38:45,863
这就是一种组合的方法
There's a means of combination.

581
00:38:46,028 --> 00:38:47,565
现在让我们来看看抽象的方法
Now let's go up to the means of abstraction.

582
00:38:49,418 --> 00:38:53,394
我希望我能够写一些像这样的组合式
I'd like to be able to take the idea that I do some combination like this,

583
00:38:53,708 --> 00:38:55,328
将它抽象化并给它命名
and abstract it and give it a simple name,

584
00:38:55,600 --> 00:38:56,813
使得我可以将其作为一个（我们语言的）元素
so I can use that as an element.

585
00:38:57,049 --> 00:38:59,961
在Lisp中 我可以用“define”来实现
And I do that in Lisp with "define."

586
00:39:01,043 --> 00:39:01,988
比如说
So I can say, for example,

587
00:39:02,702 --> 00:39:15,990
定义A为5乘以5
define A to be the product of 5 and 5.

588
00:39:18,379 --> 00:39:22,067
现在我可以问Lisp
And now I could say, for example, to Lisp,

589
00:39:22,218 --> 00:39:25,302
A和A的乘积是多少
what is the product of A and A?

590
00:39:27,352 --> 00:39:29,319
这个是25所以这个就是625
And this should be 25, and this should be 625.

591
00:39:32,164 --> 00:39:35,568
但更重要的则是 我现在可以使用A
And then, crucial thing, I can now use A--

592
00:39:36,213 --> 00:39:37,474
我已经在这个组合式里面用过了
here I've used it in a combination--

593
00:39:38,371 --> 00:39:43,306
但我也可以在更复杂的组合式里面使用它
but I could use that in other more complicated things that I name in turn.

594
00:39:43,497 --> 00:39:50,757
我也可以说 定义B为
So I could say, define B to be the sum of,

595
00:39:51,009 --> 00:39:57,556
A与5乘以A的积的和
we'll say, A and the product of 5 and A.

596
00:39:59,811 --> 00:40:00,789
闭合“+”
And then close the plus.

597
00:40:03,501 --> 00:40:05,738
让我们来看看它在计算机中是怎样的吧
Let's take a look at that on the computer and see how that looks.

598
00:40:07,900 --> 00:40:10,232
我就像黑板上写的那样键入就可以了
So I'll just type what I wrote on the board.

599
00:40:10,838 --> 00:40:21,281
我告诉Lisp
I could say, define A to be the product of 5 and 5.

600
00:40:24,141 --> 00:40:24,931
定义A为5乘以5的积
And I'll tell that to Lisp.

601
00:40:25,698 --> 00:40:28,491
注意Lisp在下方回应了一个A
And notice what Lisp responded there with was an A in the bottom.

602
00:40:29,129 --> 00:40:30,935
通常来说 你如果在Lisp中键入了一个定义
In general, when you type in a definition in Lisp,

603
00:40:31,476 --> 00:40:34,570
它返回被定义的符号
it responds with the symbol being defined.

604
00:40:35,317 --> 00:40:38,952
现在我问Lisp A乘以A的积是多少
Now I could say to Lisp, what is the product of A and A?

605
00:40:43,199 --> 00:40:44,163
Lisp返回625
And it says that's 625.

606
00:40:46,249 --> 00:40:59,891
我也可以定义B为A加上5乘以A的积的和
I can define B to be the sum of A and the product of 5 and A.

607
00:41:00,634 --> 00:41:05,256
闭合“*” 闭合“+” 闭合“define”
Close a paren closes the star.  Close the plus. Close the "define."

608
00:41:07,841 --> 00:41:10,150
Lisp在下方正常返回B
Lisp says, OK, B, there on the bottom.

609
00:41:11,028 --> 00:41:12,798
现在我可以问Lisp B的值是多少
And now I can say to Lisp, what's the value of B?

610
00:41:17,377 --> 00:41:18,700
我也可以问一些更复杂的事
And I can say something more complicated,

611
00:41:18,876 --> 00:41:26,435
比如A加上B除以5的商的和是多少
like what's the sum of A and the quotient of B and 5?

612
00:41:26,643 --> 00:41:30,868
这个“/”是另一个基本运算符 代表除
That slash is divide, another primitive operator.

613
00:41:30,983 --> 00:41:32,337
我让B除以5 并加在A上
I've divided B by 5, added it to A.

614
00:41:33,631 --> 00:41:34,606
Lisp正常返回55
Lisp says, OK, that's 55.

615
00:41:36,573 --> 00:41:37,535
就像这样
So there's what it looks like.

616
00:41:39,883 --> 00:41:42,959
这是定义东西的基本方法
There's the basic means of defining something.

617
00:41:43,627 --> 00:41:48,572
这是最简单的命名方法 但并不是很强大
It's the simplest kind of naming, but it's not really very powerful.

618
00:41:49,927 --> 00:41:51,348
注意我们讨论的是通用方法
See, what I'd really like to name--

619
00:41:51,716 --> 00:41:53,018
因此我真正想定义的是
remember, we're talking about general methods--

620
00:41:53,418 --> 00:41:56,817
一种通用方法 可以
I'd like to name, oh, the general idea that, for example,

621
00:41:58,049 --> 00:42:17,832
得到 5乘5 6乘6 1001乘1001 1001.7乘1001.7
I could multiply 5 by 5, or 6 by 6, or 1,001 by 1,001, 1,001.7 by 1,001.7.

622
00:42:18,159 --> 00:42:23,981
我想给一个数与其自身相乘这种想法一个名字
I'd like to be able to name the general idea of multiplying something by itself.

623
00:42:28,427 --> 00:42:30,020
你应该知道 这叫做平方
Well, you know what that is. That's called squaring.

624
00:42:31,756 --> 00:42:34,925
而在Lisp中我应该这样实现
And the way I can do that in Lisp is I can say,

625
00:42:37,904 --> 00:42:57,672
定义 square某个叫x的东西 为 将x乘以x自己
define to square something x, multiply x by itself.

626
00:42:57,935 --> 00:43:00,847
定义完毕后 我可以问Lisp
And then having done that, I could say to Lisp,

627
00:43:01,237 --> 00:43:04,903
比如 10的平方是多少
for example, what's the square of 10?

628
00:43:06,667 --> 00:43:07,762
Lisp返回100
And Lisp will say 100.

629
00:43:10,684 --> 00:43:13,798
让我们深入讨论一下
So now let's actually look at that a little more closely.

630
00:43:15,225 --> 00:43:16,432
这儿是square的定义
Right, there's the definition of square.

631
00:43:17,341 --> 00:43:22,107
square某个元素 即是将该元素进行自乘
To square something, multiply it by itself.

632
00:43:23,716 --> 00:43:24,717
这里的x
You see this x here.

633
00:43:26,289 --> 00:43:27,368
应该算是一种代词
That x is kind of a pronoun,

634
00:43:27,687 --> 00:43:29,087
指代了我要做平方的元素
which is the something that I'm going to square.

635
00:43:31,341 --> 00:43:37,148
实际上我将其乘以x 即是乘以它自己
And what I do with it is I multiply x, I multiply it by itself.

636
00:43:42,258 --> 00:43:47,828
这些就是定义一个过程的记法
OK. So there's the notation for defining a procedure.

637
00:43:48,268 --> 00:43:49,844
这样说可能把你搞糊涂了
Actually, this is a little bit confusing,

638
00:43:50,680 --> 00:43:53,591
因为这就像我在用square一样
because this is sort of how I might use square.

639
00:43:53,821 --> 00:43:56,525
但如果我说x的平方根或者10的平方根
And I say square root of x or square root of 10,

640
00:43:57,565 --> 00:44:00,361
并没有说清楚我对什么做了定义
but it's not making it very clear that I'm actually naming something.

641
00:44:02,984 --> 00:44:04,882
所以让我换个方式来进行定义
So let me write this definition in another way

642
00:44:05,623 --> 00:44:07,807
这样可以清楚的看到定义的具体内容
that makes it a little bit more clear that I'm naming something.

643
00:44:08,444 --> 00:44:29,714
我“定义”square为(lambda (x) (* x x))
I'll say, "define" square to be lambda of x times xx.

644
00:44:36,567 --> 00:44:41,418
这里 我定义 square 就像我某命名为A一样
Here, I'm naming something square, just like over here, I'm naming something A.

645
00:44:43,357 --> 00:44:44,394
我定义square 
The thing that I'm naming square--

646
00:44:44,648 --> 00:44:47,948
这里 我把这个组合式的值命名为A
here, the thing I named A was the value of this combination.

647
00:44:49,260 --> 00:44:52,142
在这里 我把这个东西命名为square
Here, the thing that I'm naming square is this thing

648
00:44:52,321 --> 00:44:53,205
以lambda开头
that begins with lambda,

649
00:44:53,401 --> 00:44:56,321
lambda在Lisp中用以构建一个过程
and lambda is Lisp's way of saying make a procedure.

650
00:45:00,339 --> 00:45:02,506
请仔细看一下幻灯片上的内容
Let's look at that more closely on the slide.

651
00:45:04,393 --> 00:45:05,749
这个定义读作
The way I read that definition is to say,

652
00:45:05,886 --> 00:45:10,103
将square定义为一个由
I define square to be make a procedure--

653
00:45:12,721 --> 00:45:14,016
lambda构造的
that's what the lambda is--

654
00:45:14,158 --> 00:45:17,570
一个有带有参数x的过程
make a procedure with an argument named x.

655
00:45:19,259 --> 00:45:23,107
而该过程返回将x自乘的结果
And what it does is return the results of multiplying x by itself.

656
00:45:24,874 --> 00:45:32,935
一般来讲 这是最佳的定义方式
Now, in general, we're going to be using this top form of defining,

657
00:45:33,413 --> 00:45:34,994
因为这个更加方便一点
just because it's a little bit more convenient.

658
00:45:35,108 --> 00:45:38,520
但是也别忘了它实质上也是这个
But don't lose sight of the fact that it's really this.

659
00:45:38,769 --> 00:45:41,269
事实上 就Lisp解释器而言
In fact, as far as the Lisp interpreter's concerned,

660
00:45:41,396 --> 00:45:45,470
这两种方法没有区别
there's no difference between typing this to it and typing this to it.

661
00:45:46,446 --> 00:45:53,941
换句话说 这只是一种语法糖
And there's a word for that, sort of syntactic sugar.

662
00:45:54,396 --> 00:45:55,350
语法糖的意思就是
What syntactic sugar means,

663
00:45:55,526 --> 00:46:00,965
这种形式输入更方便一些
it's having somewhat more convenient surface forms for typing something.

664
00:46:01,233 --> 00:46:05,920
这只是这下面的有lambda的表达式的语法糖而已
So this is just really syntactic sugar for this underlying Greek thing with the lambda.

665
00:46:07,566 --> 00:46:10,693
你应该记住
And the reason you should remember that is don't forget that,

666
00:46:10,792 --> 00:46:13,422
当我这样写的时候 其实是在对某个东西进行命名
when I write something like this, I'm really naming something.

667
00:46:14,409 --> 00:46:15,905
我将其命名为square
I'm naming something square,

668
00:46:16,197 --> 00:46:19,916
square 代表构建一个过程
and the something that I'm naming square is a procedure that's getting constructed.

669
00:46:21,245 --> 00:46:23,485
让我们看看在计算机里面又是 怎样的吧
Well, let's look at that on the computer, too.

670
00:46:25,321 --> 00:46:38,901
定义(square x)为x乘以x的积
So I'll come and I'll say, define square of x to be times xx.

671
00:46:49,531 --> 00:46:52,168
将它送入Lisp
Now I'll tell Lisp that. 

672
00:46:53,655 --> 00:46:54,206
返回square
It says "square."

673
00:46:54,501 --> 00:46:55,844
现在 我已经将某个东西命名为square了
See, I've named something "square."

674
00:46:56,358 --> 00:47:02,435
完毕后 我就可以问Lisp 1001的平方是多少
Now, having done that, I can ask Lisp for, what's the square of 1,001?

675
00:47:05,174 --> 00:47:17,800
或者更通常的来说 我可以问 5加上7的和的平方是多少
Or in general, I could say, what's the square of the sum of 5 and 7?

676
00:47:23,090 --> 00:47:24,506
12的平方是144
The square of 12's 144.

677
00:47:25,185 --> 00:47:28,605
在某些组合式中我亦可把square当作一个元素
Or I can use square itself as an element in some combination.

678
00:47:28,898 --> 00:47:37,855
3的平方加上4的平方的和是多少
I can say, what's the sum of the square of 3 and the square of 4?

679
00:47:42,402 --> 00:47:43,988
9加上16得25
9 and 16 is 25.

680
00:47:45,107 --> 00:47:50,380
我可以将square作为元素用于更复杂的式子
Or I can use square as an element in some much more complicated thing.

681
00:47:50,577 --> 00:48:00,306
比如 1001的平方点的平方的平方是多少
I can say, what's the square of, the sqare of, the square of 1,001?

682
00:48:07,827 --> 00:48:10,183
这就是1001点的平方的平方的平方
And there's the square of the square of the square of 1,001.

683
00:48:11,194 --> 00:48:15,460
我也可以问Lisp square本身是什么
Or I can say to Lisp, what is square itself?

684
00:48:15,704 --> 00:48:16,714
它的值是是什么
What's the value of that?

685
00:48:17,468 --> 00:48:21,699
Lisp用一种约定的方法告诉我这是一个过程
And Lisp returns some conventional way of telling me that that's a procedure.

686
00:48:22,256 --> 00:48:23,669
它返回 复合过程square
It says, "compound procedure square."

687
00:48:24,296 --> 00:48:27,473
记住 square的值是一个过程
Remember, the value of square is this procedure,

688
00:48:29,060 --> 00:48:30,671
而那些用星号和括号的记法
and the thing with the stars and the brackets

689
00:48:31,028 --> 00:48:34,338
只是Lisp用来描述这个过程的约定
are just Lisp's conventional way of describing that.

690
00:48:37,134 --> 00:48:41,049
让我们再看两个关于define的例子
Let's look at two more examples of defining.

691
00:48:44,970 --> 00:48:47,152
这有两个过程
Here are two more procedures.

692
00:48:47,382 --> 00:48:52,399
定义x和y的平均值为x加上y的和除以2的商
I can define the average of x and y to be the sum of x and y divided by 2.

693
00:48:54,537 --> 00:49:01,132
以及定义好平方和平均值后 我可以定义均方
Or having had average and mean square, having had average and square,

694
00:49:01,534 --> 00:49:04,263
我可以用它们来讨论某元素的均方
I can use that to talk about the mean square of something,

695
00:49:04,924 --> 00:49:08,812
即x的平方与y的平方的平均值
which is the average of the square of x and the square of y.

696
00:49:10,850 --> 00:49:13,306
当定义好它们后 我可以问
So for example, having done that, I could say,

697
00:49:13,552 --> 00:49:24,114
2和3的均方是多少
what's the mean square of 2 and 3?

698
00:49:25,231 --> 00:49:29,797
我将会得到 4和9的平均值 即6.5
And I should get the average of 4 and 9, which is 6.5.

699
00:49:33,037 --> 00:49:36,600
关键点在于 定义了square后
The key thing here is that, having defined square,

700
00:49:36,793 --> 00:49:38,419
我可以把它当作一个基本元素来使用
I can use it as if it were primitive.

701
00:49:41,429 --> 00:49:43,121
因此在这里
So if we look here on the slide,

702
00:49:44,482 --> 00:49:45,629
我在讨论均方的时候
if I look at mean square,

703
00:49:47,214 --> 00:49:52,360
从这点来说 定义均方的人没有必要知道
the person defining mean square doesn't have to know, at this point, 

704
00:49:52,763 --> 00:49:56,169
究竟square是由语言内建支持
whether square was something built into the language

705
00:49:56,818 --> 00:49:58,732
还是自定义的过程
or whether it was a procedure that was defined.

706
00:49:59,627 --> 00:50:01,272
这是Lisp的关键之一
And that's a key thing in Lisp,

707
00:50:02,234 --> 00:50:07,170
你无法准确区别
that you do not make arbitrary distinctions between things

708
00:50:07,394 --> 00:50:11,379
哪些是语言的基本对象 哪些是语言的内建支持
that happen to be primitive in the language and things that happen to be built in.

709
00:50:12,756 --> 00:50:14,555
用户使用时则无需关心这些
A person using that shouldn't even have to know.

710
00:50:14,809 --> 00:50:18,340
你自己构建的东西看起来就像是语言自带的基本对象
So the things you construct get used with all the power and flexibility

711
00:50:18,556 --> 00:50:19,609
具有同样的能力和灵活性
as if they were primitives. 

712
00:50:19,765 --> 00:50:22,629
大家可以在课后上机做做测试
In fact, you can drive that home by looking on the computer one more time.

713
00:50:24,830 --> 00:50:26,572
我们接下来讨论一下“+”吧
We talked about plus.

714
00:50:26,827 --> 00:50:29,842
好的 让我们在计算机中看看
And in fact, if I come here on the computer screen and say,

715
00:50:30,074 --> 00:50:32,200
“+”的值是什么
what is the value of plus?

716
00:50:34,370 --> 00:50:36,900
注意Lisp在下面的输出
Notice what Lisp types out. On the bottom there, it typed out,

717
00:50:37,156 --> 00:50:38,705
复合过程“+”
"compound procedure plus."

718
00:50:39,856 --> 00:50:41,934
因为在此系统中
Because, in this system,

719
00:50:42,094 --> 00:50:45,292
“+”运算符是一个复合过程
it turns out that the addition operator is itself a compound procedure.

720
00:50:45,842 --> 00:50:47,788
但如果我不输入进去做下测试 你永远不会知道
And if I didn't just type that in, you'd never know that,

721
00:50:48,010 --> 00:50:49,326
所以这没什么不同
and it wouldn't make any difference anyway.

722
00:50:49,612 --> 00:50:50,291
我们并不关心这些
We don't care.

723
00:50:50,524 --> 00:50:52,945
它比我们日常处理的问题更加抽象一些
It's below the level of the abstraction that we're dealing with.

724
00:50:54,210 --> 00:50:58,668
其关键点在于你无法分辨出
So the key thing is you cannot tell, should not be able to tell, in general,

725
00:50:59,009 --> 00:51:03,370
内建元素与复合元素之间的不同
the difference between things that are built in and things that are compound.

726
00:51:03,638 --> 00:51:04,207
为什么会这样呢？
Why is that?

727
00:51:04,412 --> 00:51:07,625
因为复合元素经过了一次抽象封装 (以致于无法分辨)
Because the things that are compound have an abstraction wrapper wrapped around them.

728
00:51:08,954 --> 00:51:11,502
我们已经介绍了Lisp的大多数元素了
We've seen almost all the elements of Lisp now.

729
00:51:12,605 --> 00:51:14,080
还有一个需要进行讨论的
There's only one more we have to look at,

730
00:51:14,287 --> 00:51:16,086
就是如何进行分情况分析
and that is how to make a case analysis.

731
00:51:16,508 --> 00:51:17,259
举个例子
Let me show you what I mean.

732
00:51:18,794 --> 00:51:23,832
让我们考虑绝对值函数的数学定义
We might want to think about the mathematical definition of the absolute value functions.

733
00:51:24,089 --> 00:51:29,588
我或许会说x的绝对值这样是一个函数
I might say the absolute value of x is the function

734
00:51:30,113 --> 00:51:36,794
若x小于0 则为-x
which has the property that it's negative of x. For x less than 0,

735
00:51:37,884 --> 00:51:40,684
若x等于0 则为0
it's 0 for x equal to 0.

736
00:51:42,576 --> 00:51:46,173
若x大于0 则就是x
And it's x for x greater than 0.

737
00:51:49,222 --> 00:51:51,314
而Lisp则有一套分情况分析方法
And Lisp has a way of making case analyses.

738
00:51:51,569 --> 00:51:53,796
以绝对值定义为例 我给大家说明一下
Let me define for you absolute value.

739
00:51:55,595 --> 00:52:01,968
定义绝对值为 x是有多种情况的
Say define the absolute value of x is conditional.

740
00:52:03,160 --> 00:52:05,220
这就是分情况分析
This means case analysis, COND.

741
00:52:09,581 --> 00:52:20,114
如果x小于0 则结果为-x
If x is less than 0, the answer is negate x.

742
00:52:23,094 --> 00:52:24,434
我这里写的是一个子句
What I've written here is a clause.

743
00:52:24,907 --> 00:52:35,093
这整个是一个由两部分组成的条件表达式
This whole thing is a conditional clause, and it has two parts.

744
00:52:36,579 --> 00:52:44,257
这个部分叫做谓词或者条件
This part here is a predicate or a condition.

745
00:52:44,698 --> 00:52:45,938
这就是一个条件
That's a condition.

746
00:52:46,133 --> 00:52:48,251
用以表达条件的东西叫做谓词
And the condition is expressed by something called a predicate,

747
00:52:48,456 --> 00:52:50,607
Lisp中的谓词是一种
and a predicate in Lisp is some sort of thing

748
00:52:51,245 --> 00:52:52,423
可以返回true或者false的东西
that returns either true or false.

749
00:52:53,399 --> 00:52:55,682
比如说“小于”是Lisp中的一个基本过程 
And you see Lisp has a primitive procedure, less-than,

750
00:52:57,190 --> 00:52:58,631
它返回true或者false
that tests whether something is true or false.

751
00:53:00,492 --> 00:53:05,754
子句其余部分为一个动作或者需要做的事
And the other part of a clause is an action or a thing to do,

752
00:53:06,922 --> 00:53:07,901
本例中为true
in the case where that's true.

753
00:53:08,087 --> 00:53:09,619
在这里 我则是取x的相反数
And here, what I'm doing is negating x.

754
00:53:10,275 --> 00:53:13,967
有趣的是 Lisp中减运算符符与相反数运算符是同一个
The negation operator, the minus sign in Lisp is a little bit funny.

755
00:53:14,181 --> 00:53:17,984
如果有两个及两个以上的参数
If there's two or more arguments,

756
00:53:18,131 --> 00:53:22,401
正如我们看到的 假设刚好有两个参数 就从第一个中减去第二个
if there's two arguments it subtracts the second one from the first, and we saw that.

757
00:53:22,577 --> 00:53:23,684
如果只有一个参数 则取其相反数
And if there's one argument, it negates it.

758
00:53:24,991 --> 00:53:27,420
这与前面相符合
So this corresponds to that.

759
00:53:27,670 --> 00:53:29,248
这又是一个COND子句
And then there's another COND clause.

760
00:53:29,466 --> 00:53:35,246
这是说 在x等于0的时候 结果为0
It says, in the case where x is equal to 0, the answer is 0.

761
00:53:37,880 --> 00:53:44,308
在x大于0的时候 结果为x
And in the case where x is greater than 0, the answer is x.

762
00:53:45,371 --> 00:53:48,932
闭合子句 闭合COND 闭合define
Close that clause. Close the COND. Close the definition.

763
00:53:49,508 --> 00:53:50,994
这就是绝对值的定义
And there's the definition of absolute value.

764
00:53:51,191 --> 00:53:53,469
你会发现分情况分析
And you see it's the case analysis that looks very much

765
00:53:53,716 --> 00:53:55,591
与数学中所用的非常相似
like the case analysis you use in mathematics.

766
00:53:58,363 --> 00:54:02,850
当然还有一些不常用的受限的分情况分析方法
There's a somewhat different way of writing a restricted case analysis.

767
00:54:03,054 --> 00:54:06,131
很多时候 你在进行分情况分析时只有一种情况
Often, you have a case analysis where you only have one case,

768
00:54:06,862 --> 00:54:07,629
你首先进行测试
where you test something,

769
00:54:07,802 --> 00:54:10,302
然后根据返回的为true或false来决定如何处理
and then depending on whether it's true or false, you do something.

770
00:54:10,938 --> 00:54:15,451
这是另外一种定义绝对值的方法
And here's another definition of absolute value

771
00:54:15,605 --> 00:54:16,740
但看起来是几乎一样的
which looks almost the same,

772
00:54:17,765 --> 00:54:21,961
像这样 如果x小于0 结果则为x的相反数
which says, if x is less than 0, the result is negate x.

773
00:54:24,351 --> 00:54:25,602
否则 结果即为x
Otherwise, the answer is x.

774
00:54:25,824 --> 00:54:27,200
我们将会大量的使用“if”
And we'll be using "if" a lot.

775
00:54:27,349 --> 00:54:28,962
再次声明
But again, the thing to remember is that

776
00:54:29,095 --> 00:54:32,583
你们在这里看到的绝对值形式
this form of absolute value that you're looking at here,

777
00:54:34,231 --> 00:54:36,535
和我在黑板上写的那种
and then this one over here that I wrote on the board,

778
00:54:37,450 --> 00:54:38,662
本质上是一样的
are essentially the same.

779
00:54:39,077 --> 00:54:41,813
而“if”和“COND”则是
And "if" and COND are-- well, whichever way you like it.

780
00:54:42,044 --> 00:54:44,517
你可以把“COND”当做“if”的语法糖
You can think of COND as syntactic sugar for "if",

781
00:54:44,971 --> 00:54:46,568
或者“if”是“COND”的语法糖
or you can think of "if" as syntactic sugar for COND,

782
00:54:47,247 --> 00:54:48,209
这没什么区别
and it doesn't make any difference.

783
00:54:49,101 --> 00:54:50,902
Lisp系统的设计者会从中会选择一个
The person implementing a Lisp system will pick one

784
00:54:51,254 --> 00:54:52,880
然后依照这个来实现另外一个
and implement the other in terms of that.

785
00:54:53,136 --> 00:54:54,423
你首先实现哪一个都无所谓
And it doesn't matter which one you pick.

786
00:55:02,289 --> 00:55:04,914
让我们停下来 解决几点疑问
Why don't we break now, and then take some questions.

787
00:55:05,640 --> 00:55:09,771
为什么我有时用define时
How come sometimes when I write define,

788
00:55:11,000 --> 00:55:14,302
我在这里使用了一个左括号
I put an open paren here and say,

789
00:55:14,586 --> 00:55:16,204
输入 define (XXX
define open paren something or other,

790
00:55:16,735 --> 00:55:20,517
而有时我这样写时却没加左括号
and sometimes when I write this, I don't put an open paren?

791
00:55:22,007 --> 00:55:26,948
是因为你所见的
The answer is, this particular form of "define",

792
00:55:27,096 --> 00:55:29,358
这种 “define” 表达式
where you say define some expression,

793
00:55:29,534 --> 00:55:31,793
对于定义过程来讲是非常特殊
is this very special thing for defining procedures.

794
00:55:33,584 --> 00:55:39,768
再次强调 这实际上是说我定义这个叫square的符号为这个
But again, what it really means is I'm defining this symbol, square, to be that.

795
00:55:41,315 --> 00:55:45,399
你所知道的则是 你先写一个“define”
So the way you should think about it is what "define" does is you write "define",

796
00:55:47,055 --> 00:55:49,820
然后你再写一个符号 没有左括号
and the second thing you write is the symbol here-- no open paren--

797
00:55:50,130 --> 00:55:51,506
这是你将要定义的符号
the symbol you're defining

798
00:55:52,020 --> 00:55:53,254
这又是你要将其定义为什么
and what you're defining it to be.

799
00:55:54,607 --> 00:55:57,227
就像这儿和这儿
That's like here and like here.

800
00:55:57,618 --> 00:55:59,593
这是“define”的基本使用方法
That's sort of the basic way you use "define."

801
00:56:00,988 --> 00:56:03,306
然而 这种特殊的语法技巧
And then, there's this special syntactic trick

802
00:56:04,416 --> 00:56:06,154
使得你可以定义像这样的过程
which allows you to define procedures that look like this.

803
00:56:08,173 --> 00:56:11,215
因此区别就在于你是否定义了一个过程
So the difference is, it's whether or not you're defining a procedure.

804
00:56:12,962 --> 00:56:35,638
[音乐]
[JESU, JOY OF MAN'S DESIRING]

805
00:56:38,030 --> 00:56:41,633
信不信由你 你们已经学了足够多的Lisp的知识了
Well, believe it or not, you actually now know enough Lisp

806
00:56:42,664 --> 00:56:45,239
现在你基本上可以编写
to write essentially any numerical procedure

807
00:56:46,169 --> 00:56:49,517
FORTRAN、Basic或者其它语言中一样的
that you'd write in a language like FORTRAN or Basic or whatever,

808
00:56:49,676 --> 00:56:50,968
数值计算过程了
or, essentially, any other language.

809
00:56:52,072 --> 00:56:54,310
或许你会说 这不可能
And you're probably saying, that's not believable,

810
00:56:54,693 --> 00:56:56,428
因为你知道这些语言有
because you know that these languages have things

811
00:56:56,577 --> 00:56:59,773
像“for”语句和“do-until-whil”语句的东西
like "for statements", and "do until while" or something.

812
00:57:00,840 --> 00:57:04,359
实际上这些我们一点也用不着
But we don't really need any of that.

813
00:57:04,959 --> 00:57:06,680
本课中我们一点也不会使用这些东西
In fact, we're not going to use any of that in this course.

814
00:57:08,150 --> 00:57:09,870
我给你们来个下马威
Let me show you.

815
00:57:10,076 --> 00:57:13,262
回过头来看看平方根
Again, looking back at square root,

816
00:57:13,436 --> 00:57:18,586
让我们看看亚历山大的Heron提出的平方根算法
let's go back to this square root algorithm of Heron of Alexandria.

817
00:57:18,976 --> 00:57:19,840
想想它是怎么说的
Remember what that said.

818
00:57:19,970 --> 00:57:23,224
算法说 为了找到X的平方根的近似值
It said, to find an approximation to the square root of X,

819
00:57:24,981 --> 00:57:26,115
你做出猜测
you make a guess,

820
00:57:27,298 --> 00:57:31,437
然后通过取guess和X/guess的平均数来改进猜测
you improve that guess by averaging the guess and X over the guess.

821
00:57:32,850 --> 00:57:35,352
你不断改进猜测 直到这个猜测足够好
You keep improving that until the guess is good enough.

822
00:57:36,622 --> 00:57:38,144
我已经提到过这种想法
I already alluded to the idea.

823
00:57:38,330 --> 00:57:42,128
这种想法是说 如果你最初采用的猜测
The idea is that, if the initial guess that you took

824
00:57:42,905 --> 00:57:46,460
真真切切的等于X的平方根
was actually equal to the square root of X,

825
00:57:46,860 --> 00:57:49,781
那么G就会等于X/G
then G here would be equal to X/G.

826
00:57:52,742 --> 00:57:55,144
如果你算出平方根 对其取平均数并不会改变它
So if you hit the square root, averaging them wouldn't change it.

827
00:57:55,555 --> 00:57:59,179
如果你所采用的G比X的平方根大
If the G that you picked was larger than the square root of X,

828
00:58:00,225 --> 00:58:02,495
那么X/G就会比X的平方根小
then X/G will be smaller than the square root of X,

829
00:58:03,078 --> 00:58:05,228
因此当你取G与X/G的平均值时
so that when you average G and X/G,

830
00:58:05,564 --> 00:58:07,123
就得到了两者之间的某数
you get something in between.

831
00:58:08,923 --> 00:58:12,501
同理 若你采用的G过小 答案则会过大
So if you pick a G that's too small, your answer will be too large.

832
00:58:13,012 --> 00:58:15,049
如果你采用了一个太大的G
If you pick a G that's too large,

833
00:58:15,223 --> 00:58:18,250
如果你的G比X的平方根还要大的话
if your G is larger than the square root of X

834
00:58:18,363 --> 00:58:20,295
X/G就会比X的平方根还要小
and X/G will be smaller than the square root of X.

835
00:58:21,178 --> 00:58:23,050
因此取平均值使得你总可以得到两者间的某数
So averaging always gives you something in between.

836
00:58:24,410 --> 00:58:27,673
#TBD
And then, it's not quite trivial, but it's possible to show that,

837
00:58:27,843 --> 00:58:31,315
事实上 如果G只差X的平方根一点的话
in fact, if G misses the square root of X by a little bit,

838
00:58:31,540 --> 00:58:37,543
G和X/G的平均值就会慢慢的向X的平方根靠近
the average of G and X/G will actually keep getting closer to the square root of X.

839
00:58:37,675 --> 00:58:39,108
只要你不断的这样做
So if you keep doing this enough,

840
00:58:39,387 --> 00:58:40,898
最终就可以不断地靠近
you'll eventually get as close as you want.

841
00:58:41,012 --> 00:58:42,913
另外一个事实则是
And then there's another fact,

842
00:58:43,017 --> 00:58:47,293
你总可以使用1作为一个初始猜测值来开始计算
that you can always start out this process by using 1 as an initial guess.

843
00:58:48,280 --> 00:58:50,907
它总是朝X的平方根聚拢
And it'll always converge to the square root of X.

844
00:58:52,425 --> 00:58:56,761
这就是亚历山大的Heron的连续求平均值法
So that's this method of successive averaging due to Heron of Alexandria.

845
00:58:56,951 --> 00:58:58,765
让我们在Lisp中实现
Let's write it in Lisp.

846
00:59:00,128 --> 00:59:02,250
中心思想是
Well, the central idea is,

847
00:59:02,387 --> 00:59:06,742
尝试将guess作为X的平方根的一个猜想意味着什么
what does it mean to try a guess for the square root of X?

848
00:59:08,297 --> 00:59:09,332
我来编码
Let's write that.

849
00:59:09,522 --> 00:59:24,870
定义（try guess x）
So we'll say, define to try a guess for the square root of X,

850
00:59:26,334 --> 00:59:27,790
我们该如何做 我们会说
what do we do? We'll say,

851
00:59:28,081 --> 00:59:45,004
如果猜测精确到可以作为X的平方根
if the guess is good enough to be a guess for the square root of X,

852
00:59:46,561 --> 00:59:49,071
那么我们就可以将这个猜测作为答案
then, as an answer, we'll take the guess.

853
00:59:51,502 --> 00:59:56,568
否则 我们就会尝试改进猜测
Otherwise, we will try the improved guess.

854
00:59:58,630 --> 01:00:03,719
我们将通过改进这个猜测来作为X的平方根
We'll improve that guess for the square root of X,

855
01:00:05,183 --> 01:00:08,882
并尝试是否为X平方根
and we'll try that as a guess for the square root of X.

856
01:00:09,431 --> 01:00:12,779
闭合try 闭合if 闭合define
Close the "try." Close the "if." Close the "define."

857
01:00:13,224 --> 01:00:14,713
这就是我们如何尝试一个猜测
So that's how we try a guess.

858
01:00:15,767 --> 01:00:17,156
然后 这个过程的下一步是说
And then, the next part of the process said,

859
01:00:17,355 --> 01:00:21,458
为了计算平方根
in order to compute square roots, we'll say,

860
01:00:21,640 --> 01:00:30,290
定义计算X的平方根为
define to compute the square root of X,

861
01:00:30,768 --> 01:00:36,267
从1作为X的平方根的一个猜测开始尝试
we will try 1 as a guess for the square root of X.

862
01:00:37,448 --> 01:00:39,145
我们必须定义一些其它的东西
Well, we have to define a couple more things.

863
01:00:40,115 --> 01:00:42,703
我们必须说明 一个猜测如何才叫“足够好”
We have to say, how is a guess good enough?

864
01:00:43,803 --> 01:00:44,961
我们又该如何改进这个猜测
And how do we improve a guess?

865
01:00:45,831 --> 01:00:47,104
那么让我们来看看
So let's look at that.

866
01:00:47,334 --> 01:00:54,084
而改进一个X的平方根的一个猜测的算法则是
The algorithm to improve a guess for the square root of X,

867
01:00:54,745 --> 01:00:56,917
取平均数
we average-- that was the algorithm--

868
01:00:57,123 --> 01:01:02,176
我们取guess和X/guess的平均数
we average the guess with the quotient of dividing X by the guess.

869
01:01:03,098 --> 01:01:04,279
这就是我们如何改进一个猜测
That's how we improve a guess.

870
01:01:05,787 --> 01:01:08,443
为了确定一个猜测是否足够精确 我们需要做一下规定
And to tell whether a guess is good enough, well, we have to decide something.

871
01:01:08,670 --> 01:01:11,373
假设这个是X的平方根的一个猜测
This is supposed to be a guess for the square root of X,

872
01:01:11,582 --> 01:01:10,745
你可能做的一件事就是
so one possible thing you can do is say,

873
01:01:13,755 --> 01:01:15,628
当你采用这个猜测并将其平方
when you take that guess and square it,

874
01:01:16,641 --> 01:01:18,163
你会得到一个非常接近于X的数
do you get something very close to X?

875
01:01:18,406 --> 01:01:20,651
而表达这个想法的一种方式是
So one way to say that is to say,

876
01:01:20,768 --> 01:01:23,869
我们用X减去guess的平方
I square the guess, subtract X from that,

877
01:01:25,001 --> 01:01:26,706
并且确认所得结果的绝对值是否
and see if the absolute value of that

878
01:01:26,859 --> 01:01:31,438
比一个由你规定的很小的数还要小
whole thing is less than some small number, which depends on my purposes.

879
01:01:34,856 --> 01:01:40,977
因此 我们就有了计算X的平方根的一整套过程
So there's a complete procedure for how to compute the square root of X.

880
01:01:41,172 --> 01:01:43,511
我们再来深入观察一下这个结构
Let's look at the structure of that a little bit.

881
01:01:48,475 --> 01:01:49,145
我搞定了整件事
I have the whole thing.

882
01:01:49,310 --> 01:01:55,228
我有一个用于计算X的平方根的记号
I have the notion of how to compute a square root.

883
01:01:55,434 --> 01:01:56,718
这是一种模块
That's some kind of module.

884
01:01:56,969 --> 01:01:58,121
也是一种黑盒
That's some kind of black box.

885
01:01:58,479 --> 01:02:07,571
它的定义依赖于如何尝试将一个猜测值作为X的平方根
It's defined in terms of how to try a guess for the square root of X.

886
01:02:09,270 --> 01:02:13,658
定义try是用来
"Try" is defined in terms of, well,

887
01:02:13,812 --> 01:02:17,755
确认某数是否足够精确以及如何去改进该数
telling whether something is good enough and telling how to improve something.

888
01:02:18,711 --> 01:02:20,047
这是good-enogh?
So good enough.

889
01:02:20,342 --> 01:02:29,457
try的定义依赖于good-enough?和improve
"Try" is defined in terms of "good enough" and "improve".

890
01:02:30,929 --> 01:02:32,116
让我们来看看我填入了些什么
And let's see what else I fill in.

891
01:02:32,264 --> 01:02:33,844
如果我向下拓展这棵树
Well, I'll go down this tree.

892
01:02:34,658 --> 01:02:38,836
good-enough?的定义依赖于abs和square
"Good enough" was defined in terms of absolute value, and square.

893
01:02:40,867 --> 01:02:43,942
而improve的定义依赖于averaging
And improve was defined in terms of something called averaging

894
01:02:45,175 --> 01:02:46,315
而其它的都是一些基本运算符
and then some other primitive operator.

895
01:02:46,437 --> 01:02:48,533
平方根的定义依赖于try
Square root's defined in terms of "try".

896
01:02:48,653 --> 01:02:53,151
try的定义依赖于good-enough?和improve
"Try" is defined in terms of "good enough" and "improve",

897
01:02:53,865 --> 01:02:55,445
甚至依赖于try本身
but also "try" itself.

898
01:02:55,666 --> 01:03:00,583
因此try也按照它如何应用于自身而进行定义
So "try" is also defined in terms of how to try itself.

899
01:03:02,762 --> 01:03:04,458
额 这可能会使你有点糊涂
Well, that may give you some problems.

900
01:03:04,670 --> 01:03:07,663
你的高中几何老师或许告诉过你
Your high school geometry teacher probably told you

901
01:03:08,585 --> 01:03:11,847
用一个东西自己去定义自己是很不对的
that it's naughty to try and define things in terms of themselves,

902
01:03:12,843 --> 01:03:13,600
因为这根本行不通
because it doesn't make sense.

903
01:03:13,826 --> 01:03:14,610
这（种说法）是错的
But that's false.

904
01:03:16,482 --> 01:03:18,971
有时候用一个东西自己来定义自己非常有意义
Sometimes it makes perfect sense to define things in terms of themselves.

905
01:03:20,229 --> 01:03:23,933
我们来看看这个例子
And this is the case. And we can look at that.

906
01:03:24,103 --> 01:03:26,763
假设我问Lisp：2的平方根是多少
We could write down what this means, and say,

907
01:03:26,883 --> 01:03:29,483
我们可以写出它究竟是什么意思
suppose I asked Lisp what the square root of 2 is.

908
01:03:32,853 --> 01:03:34,225
2的平方根是什么意思
What's the square root of 2 mean?

909
01:03:35,950 --> 01:03:43,888
意思就是我将用1作为2的平方根的一个猜测
Well, that means I try 1 as a guess for the square root of 2.

910
01:03:46,914 --> 01:03:50,479
然后我考虑 对于2的平方根来说 1是一个足够好的猜测么
Now I look. I say, gee, is 1 a good enough guess for the square root of 2?

911
01:03:51,620 --> 01:03:53,244
这取决于good-enough?是如何判断的
And that depends on the test that "good enough" does.

912
01:03:54,733 --> 01:03:56,106
本例中 good-enough?会说
And in this case, "good enough" will say,

913
01:03:56,286 --> 01:03:58,602
不 对于2的平方根来说 1不是一个足够好的猜测
no, 1 is not a good enough guess for the square root of 2.

914
01:03:59,697 --> 01:04:07,779
因此我会继续说 我试试一个改进值
So that will reduce to saying, I have to try an improved--

915
01:04:08,658 --> 01:04:12,183
改进猜测值1
improve 1 as a guess for the square root of 2,

916
01:04:15,337 --> 01:04:17,014
然后将其作为2的平方根的一个猜测
and try that as a guess for the square root of 2.

917
01:04:19,334 --> 01:04:21,627
改进猜测值1用作2的平方根
Improving 1 as a guess for the square root of 2

918
01:04:21,807 --> 01:04:24,638
也就是说我取1和2/1的平均值
means I average 1 and 2 divided by 1.

919
01:04:27,396 --> 01:04:28,834
因此我们将取平均数
So this is going to be average.

920
01:04:29,471 --> 01:04:38,999
这段代码将会取1和2/1的平均数
This piece here will be the average of 1 and the quotient of 2 by 1.

921
01:04:40,928 --> 01:04:42,302
那么这段代码
That's this piece here.

922
01:04:43,883 --> 01:04:46,273
我算算 结果是1.5
And I'm gonna try... And this is 1.5.

923
01:04:49,413 --> 01:04:54,151
因此这个(sqrt 2)还原到(try 1 2)
So this square root of 2 reduces to trying 1 for the square root of 2,

924
01:04:54,364 --> 01:05:04,388
然后还原到(try 1.5 2)
which reduces to trying 1.5 as a guess for the square root of 2.

925
01:05:06,220 --> 01:05:07,780
因此这行得通
So that makes sense.

926
01:05:07,894 --> 01:05:09,675
让我们看下剩下的步骤
Let's look at the rest of the process.

927
01:05:09,870 --> 01:05:14,557
如果我尝试1.5 则会还原到
If I try 1.5, that reduces.

928
01:05:14,698 --> 01:05:19,126
1.5作为2的平方根的猜测 并不是足够好
1.5 turns out to be not good enough as a guess for the square root of 2.

929
01:05:20,052 --> 01:05:21,779
然后又还原到
So that reduces to trying the average of

930
01:05:21,910 --> 01:05:25,729
(try (average 1.5 (/ 2 1.5)))
1.5 and 2 divided by 1.5 as a guess for the square root of 2.

931
01:05:28,228 --> 01:05:29,920
平均值是1.333
That average turns out to be 1.333.

932
01:05:31,056 --> 01:05:34,794
然后整个事又还原到(try 1.3333 2)
So this whole thing reduces to trying 1.333 as a guess for the square root of 2.

933
01:05:35,026 --> 01:05:36,141
如此进行下去
And then so on.

934
01:05:37,945 --> 01:05:41,466
然后又还原到(good-enough? 1.4)或者其它的
That reduces to another called a "good enough", 1.4 something or other.

935
01:05:41,607 --> 01:05:44,024
然后这个（步骤）会持续进行到
And then it keeps going until the process finally stops

936
01:05:44,769 --> 01:05:47,717
good-enough?认为足够好了才停止
with something that "good enough" thinks is good enough, which,

937
01:05:47,825 --> 01:05:51,258
本例中 是1.4242或者其它的东西
in this case, is 1.4142 something or other.

938
01:05:52,652 --> 01:05:55,659
因此这个这个过程运行得非常完美
So the process makes perfect sense.

939
01:05:59,958 --> 01:06:02,494
这种定义方法叫做“递归定义”
This, by the way, is called a recursive definition.

940
01:06:14,449 --> 01:06:20,515
进行递归定义将会给你带来无穷威力
And the ability to make recursive definitions is a source of incredible power.

941
01:06:21,865 --> 01:06:23,071
之前我已提到过
And as you can already see I've hinted at,

942
01:06:23,309 --> 01:06:26,959
递归定义可以在不增加任何负担的前提下
it's the thing that effectively allows you to do these infinite computations

943
01:06:27,164 --> 01:06:28,381
仅仅通过调用过程 在达到条件之前
that go on until something is true,

944
01:06:29,704 --> 01:06:33,128
完成无限次的计算
without having any other constricts other than the ability to call a procedure.

945
01:06:35,914 --> 01:06:37,029
还有一点要说明的
Well, let's see, there's one more thing.

946
01:06:37,672 --> 01:06:43,762
我再在这里给你们演示另外一种平方根的定义方法
Let me show you a variant of this definition of square root here on the slide.

947
01:06:44,361 --> 01:06:47,544
这两种方法看起来像是一样的
Here's sort of the same thing.

948
01:06:48,437 --> 01:06:51,314
在这儿 我把improve、good-enough?、try的定义
What I've done here is packaged the definitions of

949
01:06:51,501 --> 01:06:55,422
全都封装在了sqrt里面
"improve" and "good enough" and "try" inside "square root".

950
01:06:56,689 --> 01:07:00,267
因此实际上 我们构建了一个平方根盒子
So, in effect, what I've done is I've built a square root box.

951
01:07:01,837 --> 01:07:08,087
我构建了一个其它人可以使用的平方根盒子
So I've built a box that's the square root procedure that someone can use.

952
01:07:08,276 --> 01:07:11,250
它们输入36 然后（盒子）输出6
They might put in 36 and get out 6.

953
01:07:11,928 --> 01:07:13,389
但是 盒子里面封装的过程
And then, packaged inside this box

954
01:07:14,055 --> 01:07:23,406
就是try、good-enough?和improve的定义
are the definitions of "try" and "good enough" and "improve."

955
01:07:26,972 --> 01:07:28,106
它们都隐藏在盒子里面
So they're hidden inside this box.

956
01:07:28,235 --> 01:07:30,315
这样做是因为
And the reason for doing that is that,

957
01:07:30,436 --> 01:07:32,361
如果有人正在使用这个平方根
if someone's using this square root,

958
01:07:33,301 --> 01:07:34,414
如果George正在使用这个平方根
if George is using this square root,

959
01:07:34,633 --> 01:07:36,912
George并不会关心
George probably doesn't care very much that,

960
01:07:38,577 --> 01:07:40,094
当我在实现平方根时
when I implemented square root,

961
01:07:40,193 --> 01:07:44,001
我定义了盒子内的那些try、good-enough?和improve过程
I had things inside there called "try" and "good enough" and "improve".

962
01:07:46,386 --> 01:07:49,084
事实上 Harry可能会实现一个也具有
And in fact, Harry might have a cube root procedure

963
01:07:49,205 --> 01:07:50,994
try、good-enough?和improve的立方根盒子
that has "try" and "good enough" and "improve".

964
01:07:51,159 --> 01:07:53,136
因此 为了不让整个系统变得混乱
And in order to not get the whole system confused,

965
01:07:53,255 --> 01:07:57,611
Harry最好把这些内部过程封装在它的立方根过程里
it'd be good for Harry to package his internal procedures inside his cube root procedure.

966
01:07:58,328 --> 01:08:00,080
这个叫做块结构
Well, this is called block structure,

967
01:08:00,328 --> 01:08:08,514
这是把东西打包到定义内部的一种方法
this particular way of packaging internals inside of a definition.

968
01:08:09,930 --> 01:08:12,817
让我们回过头来再看看
And let's go back and look at the slide again.

969
01:08:13,151 --> 01:08:18,631
读取这种过程的方法就是来定义平方根 #TBD 需要确认上下文
The way to read this kind of procedure is to say, to define "square root",

970
01:08:19,919 --> 01:08:21,624
那么 在其内部
well, inside that definition,

971
01:08:22,049 --> 01:08:24,976
我们已有improve的定义
I'll have the definition of an "improve" and

972
01:08:25,111 --> 01:08:28,259
我们已有good-enough?和try的定义
the definition of "good enough" and the definition of "try."

973
01:08:29,575 --> 01:08:31,938
以及这些定义的实体
And then, subject to those definitions,

974
01:08:32,457 --> 01:08:35,157
我求平方根的定义实体是从1开始尝试
the way I do square root is to try 1.

975
01:08:35,390 --> 01:08:39,163
注意这里 我不必将X当做参数传递
And notice here, I don't have to say 1 as a guess for the square root of X,

976
01:08:39,804 --> 01:08:42,148
因为它们都在平方根内部
because since it's all inside the square root,

977
01:08:42,391 --> 01:08:44,201
它相当于已知这个X了
it sort of has this X known.

978
01:08:54,627 --> 01:08:56,156
我来总结下
Let me summarize.

979
01:08:56,532 --> 01:08:59,041
我们从表述指令性知识
We started out with the idea that

980
01:08:59,065 --> 01:09:03,054
开始学习
what we're going to be doing is expressing imperative knowledge.

981
01:09:05,005 --> 01:09:09,481
事实上 如果从Lisp这边总结的话
And in fact, here's a slide that summarizes the way we looked at Lisp.

982
01:09:09,659 --> 01:09:14,679
我们从基本元素如“+”和“*”开始
We started out by looking at some primitive elements in addition and multiplication,

983
01:09:15,781 --> 01:09:19,459
一些用于测试某物小于或等于的谓词
some predicates for testing whether something is less-than or something's equal.

984
01:09:19,606 --> 01:09:22,811
事实上 我们正在使用的系统掩盖了很多细节
And in fact, we saw really sneakily in the system we're actually using,

985
01:09:22,974 --> 01:09:25,948
这些并不是系统的基本元素 但这无所谓
these aren't actually primitives, but it doesn't matter.

986
01:09:26,596 --> 01:09:28,518
重要的是我们会把它们当作是基本元素
What matters is we're going to use them as if they're primitives.

987
01:09:28,662 --> 01:09:29,639
我们不会去研究系统的内部
We're not going to look inside.

988
01:09:30,147 --> 01:09:32,704
我们也有一些基本数据和一些数
We also have some primitive data and some numbers.

989
01:09:34,458 --> 01:09:36,997
我们学习了合成的手段 组合的手段
We saw some means of composition, means of combination,

990
01:09:37,293 --> 01:09:41,194
用运算符和操作数合成函数和构建组合式
the basic one being composing functions and

991
01:09:41,320 --> 01:09:43,834
的基本方法
building combinations with operators and operands.

992
01:09:44,766 --> 01:09:47,980
还有一些像是“COND”、“if”和“define”的东西
And there were some other things, like COND and "if" and "define".

993
01:09:51,273 --> 01:09:53,566
具体来说 关于“define”的重点则是
But the main thing about "define," in particular,

994
01:09:53,680 --> 01:09:55,487
它是一种进行抽象的方法
was that it was the means of abstraction.

995
01:09:55,698 --> 01:09:57,252
它是我们为某物命名的方法
It was the way that we name things.

996
01:09:57,379 --> 01:09:59,890
我们之前提到过  从这里也可以看出来
You can also see from this slide not only where we've been,

997
01:10:01,655 --> 01:10:05,835
有时候 我们需要研究如何通过组合基本数据来得到复合数据
At some point, we'll have to talk about how you combine primitive data to get compound data,

998
01:10:06,430 --> 01:10:12,103
以及如何抽象数据 使得你可以在一个更大的环境中
and how you abstract data so you can use large globs of data

999
01:10:12,221 --> 01:10:13,067
将其当作基本数据使用
as if they were primitive.

1000
01:10:13,812 --> 01:10:15,247
这也是我们的目的所在
So that's where we're going.

1001
01:10:16,301 --> 01:10:21,487
在我们讨论这个问题之前 下节课我们首先将会讨论
But before we do that, for the next couple of lectures we're going to be talking about,

1002
01:10:23,352 --> 01:10:26,312
我们编写的过程与机器内部
first of all, how it is that you make a link

1003
01:10:26,720 --> 01:10:30,320
进程之间的联系
between these procedures we write and the processes that happen in the machine.

1004
01:10:32,014 --> 01:10:35,536
接着 我们将跳出小规模的计算问题
And then, how it is that you start using the power of Lisp

1005
01:10:36,290 --> 01:10:39,527
来学习如何发挥Lisp的威力
to talk not only about these individual little computations,

1006
01:10:39,637 --> 01:10:43,701
来解决更加通用的计算问题
but about general conventional methods of doing things.

1007
01:10:44,870 --> 01:10:45,727
好了 大家还有什么问题么
OK, are there any questions?

1008
01:10:46,649 --> 01:10:51,827
学生：在定义A时 如果我们用一个括号将A括起来
AUDIENCE: Yes. If we defined A using parentheses instead of as we did,

1009
01:10:52,010 --> 01:10:53,057
会与不使用括号不同么？
what would be the difference?

1010
01:10:53,393 --> 01:10:56,358
教授：如果我这样写
PROFESSOR: If I wrote this, if I wrote that,

1011
01:10:57,563 --> 01:11:01,522
我则会是定义一个过程并命名为A
what I would be doing is defining a procedure named A.

1012
01:11:03,124 --> 01:11:06,406
本例中 这个过程没有参数
In this case, a procedure of no arguments, which,

1013
01:11:06,503 --> 01:11:09,169
而当我运行它 则会返回5乘以5
when I ran it, would give me back 5 times 5.

1014
01:11:11,121 --> 01:11:11,845
学生：我的意思是
AUDIENCE: Right. I mean, you come up with the same thing,

1015
01:11:11,946 --> 01:11:13,473
#TBD 我没有看视频，也无法确切知道上下文
except for you really got a different--

1016
01:11:13,872 --> 01:11:16,185
教授：好 的确会有不同 之前的那一个
PROFESSOR: Right. And the difference would be, in the old one--

1017
01:11:16,369 --> 01:11:18,115
我还是在这里写清楚一点吧
Let me be a little bit clearer here.

1018
01:11:19,153 --> 01:11:23,275
我们还是把这个叫做A
Let's call this A, like here.

1019
01:11:24,082 --> 01:11:27,502
作为对比 我们假装这里有一个
And pretend here, just for contrast, I wrote,

1020
01:11:27,782 --> 01:11:37,117
我定义D为5乘以5
define D to be the product of 5 and 5.

1021
01:11:40,166 --> 01:11:41,310
这两者的区别则是
And the difference between those,

1022
01:11:41,513 --> 01:11:43,984
让我们看看它们在Lisp解释器中是怎样的
let's think about interactions with the Lisp interpreter.

1023
01:11:45,747 --> 01:11:48,680
我在Lisp中键入A 返回25
I could type in A and Lisp would return 25.

1024
01:11:52,830 --> 01:11:57,130
如果我仅仅键入D
I could type in D, if I just typed in D,

1025
01:11:58,407 --> 01:12:05,573
Lisp返回复合过程D
Lisp would return compound procedure D,

1026
01:12:07,562 --> 01:12:08,685
因为D就是一个过程
because that's what it is. It's a procedure.

1027
01:12:09,613 --> 01:12:12,365
我可以运行D 我可以问运行D的结果是什么
I could run D. I could say, what's the value of running D?

1028
01:12:12,646 --> 01:12:14,789
这是一个没有运算数的组合式
Here is a combination with no operands.

1029
01:12:16,583 --> 01:12:18,620
我考虑到它没有运算数 所以我在D后面没有键入任何东西
I see there are no operands. I didn't put any after D.

1030
01:12:19,348 --> 01:12:20,890
Lisp则会说结果是25
And it would say, oh, that's 25.

1031
01:12:22,972 --> 01:12:29,227
我再说周全一点 如果我键入 A的运行结果是多少
Or I could say, just for completeness, if I typed in, what's the value of running A?

1032
01:12:29,354 --> 01:12:30,120
只能得到一个错误
I get an error.

1033
01:12:31,677 --> 01:12:35,807
跟这里的错误一样
The error would be the same one as over there.

1034
01:12:35,926 --> 01:12:40,068
这个错误是因为 A的值——25
It'd be the error would say, sorry, 25, which is the value of A,

1035
01:12:40,319 --> 01:12:42,794
并不是我可以应用于某物的运算符
is not an operator that I can apply to something.

1036
01:12:44,973 --> 01:12:47,800
MIT OpenCourseWare
http://ocw.mit.edu

1037
01:12:48,050 --> 01:12:54,311
本项目主页
https://github.com/FoOTOo/Learning-SICP

