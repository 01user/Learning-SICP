1
00:00:00,000 --> 00:00:00,000
看这里 哦 这相当糟糕
And we see here, oh yes, there's horrible things

2
00:00:00,000 --> 00:00:00,000
这里是一个表达式与“0”的和
like here is the sum of an expression and 0.

3
00:00:00,000 --> 00:00:00,000
毋庸置疑这应该是该表达式本身
Well that's no reason to think of it as anything other than the expression itself.

4
00:00:00,000 --> 00:00:00,000
为什么这里还会有加号？
Why should the summation operation have made up this edition?

5
00:00:00,000 --> 00:00:00,000
这其实可以更智能点
It can be smarter than that.

6
00:00:00,000 --> 00:00:00,000
又比如说这里 是某表达式与“1”的积
Or here, for example, is a multiplication of something by 1.

7
00:00:00,000 --> 00:00:00,000
这和之前一个道理
It's another thing like that.

8
00:00:00,000 --> 00:00:00,000
又像这里 与“0”相乘显然是“0”
Or here is a product of something with 0, which is certainly 0.

9
00:00:00,000 --> 00:00:00,000
因此我们也不用去构造这些式子了
So we won't have to make this construction.

10
00:00:00,000 --> 00:00:00,000
我们为什么不这么做呢？
So why don't we just do that?

11
00:00:00,000 --> 00:00:00,000
我们需要去修改表示法 基本上就是那里了
We need to change the way the representation works, almost here.

12
00:00:00,000 --> 00:00:00,000
定义 MAKE-SUM 为
Make-sum to be.

13
00:00:00,000 --> 00:00:00,000
呃 现在就不是那么简单了
Well, now it's not something so simple.

14
00:00:00,000 --> 00:00:00,000
除非是有必要 否则我不会简单地把加号和式子组合成表
I'm not going to make a list containing the symbol plus and things unless I need to.

15
00:00:00,000 --> 00:00:00,000
那么 还有哪些可能呢？
Well, what are the possibilities?

16
00:00:00,000 --> 00:00:00,000
如果……这里有一些可能的情况
If...I have some sort of cases here.

17
00:00:00,000 --> 00:00:00,000
如果都是数值的话 如果A1是数值的话
If I have numbers, if a1 is a number--

18
00:00:00,000 --> 00:00:00,000
这个基本过程我刚刚提到过
and here's another primitive I've just introduced,

19
00:00:00,000 --> 00:00:00,000
也就是用来检测参数是否为数值
it's possible to tell whether something's number--

20
00:00:00,000 --> 00:00:00,000
并且A2也是数值的话 也就是A2不是符号表达式
and if number A2, meaning they're not symbolic expressions,

21
00:00:00,000 --> 00:00:00,000
那么我们就直接把它们加起来
then why not do the addition now?

22
00:00:00,000 --> 00:00:00,000
结果就是A1加上A2的和
The result is just a plus of A1 and A2.

23
00:00:00,000 --> 00:00:00,000
我并不是检查它们代表数值
I'm not asking if these represent numbers.

24
00:00:00,000 --> 00:00:00,000
这里所有的符号都代表数值
Of course all of these symbols represent numbers.

25
00:00:00,000 --> 00:00:00,000
就比如 我想要考察的是这个东西是否为数值3
I'm talking about whether the one I've got is the number 3 right now.

26
00:00:00,000 --> 00:00:00,000
另一种情况
And, for example,

27
00:00:00,000 --> 00:00:00,000
假设A1是数值 并且为0
supposing A1 is a number, and it's equal to 0,

28
00:00:00,000 --> 00:00:00,000
那么答案就是A2
well then the answer is just A2.

29
00:00:00,000 --> 00:00:00,000
不用再构造什么
There is no reason to make anything up.

30
00:00:00,000 --> 00:00:00,000
如果A2是数值 并且为0
And if A2 is a number, and equal A2 0,

31
00:00:00,000 --> 00:00:00,000
那么答案就是A1
then the result is A1.

32
00:00:00,000 --> 00:00:00,000
如果没有比这些更好的情况
And only if I can't figure out something better to do with this situation,

33
00:00:00,000 --> 00:00:00,000
我就需要构造一个表
well, I can construct a list.

34
00:00:00,000 --> 00:00:00,000
构造一个用于表示答案的表
Otherwise I want the representation to be the list

35
00:00:00,000 --> 00:00:00,000
其中有 '+、A1和A2
containing the quoted symbol plus, and A1, and A2.

36
00:00:00,000 --> 00:00:00,000
档案 积的导数也可以类比此法
And, of course, a very similar thing can be done for products.

37
00:00:00,000 --> 00:00:00,000
这里 我就不细讲了
And I think I'll avoid boring you with them.

38
00:00:00,000 --> 00:00:00,000
我就直接在黑板上写出结果
I was going to write it on the blackboard.

39
00:00:00,000 --> 00:00:00,000
这并不是很重要 你们已经了解它的思想了
I don't think it's necessary. You know what to do.

40
00:00:00,000 --> 00:00:00,000
非常简明
It's very simple.

41
00:00:00,000 --> 00:00:00,000
现在 我们来看看用这种方式改造程序后 效果如何
But now, let's just see the kind of results we get out of changing our program in this way.

42
00:00:00,000 --> 00:00:00,000
哦 这是修改表达式构造函数后的求导结果
Well, here's the derivatives after having just changed the constructors for expressions.

43
00:00:00,000 --> 00:00:00,000
对同样地FOO求导：AX^2+BX+C
The same foo, aX square plus bX plus c,

44
00:00:00,000 --> 00:00:00,000
我得到了 2AX+B
and what I get is nothing more than the derivative of that is 2aX plus B.

45
00:00:00,000 --> 00:00:00,000
虽然它并没有化到最简
Well, it's not completely simplified.

46
00:00:00,000 --> 00:00:00,000
我应该合并同类项和求和
I would like to collect common terms and sums.

47
00:00:00,000 --> 00:00:00,000
但这又是另外一回事了
Well, that's more work.

48
00:00:00,000 --> 00:00:00,000
当然啦 完成这个功能的代码就大而复杂了
And, of course, programs to do this sort of thing are huge and complicated.

49
00:00:00,000 --> 00:00:00,000
代数化简 是一项复杂的工作 #TBD
Algebraic simplification, it's a very complicated mess.

50
00:00:00,000 --> 00:00:00,000
你们可能听过MIT以前开发的一个非常出名的程序 MAXIMA
There's a very famous program you may have heard of called Maxima developed at MIT in the past,

51
00:00:00,000 --> 00:00:00,000
它有5000页的LISP代码
which is 5,000 pages of Lisp code,

52
00:00:00,000 --> 00:00:00,000
大部分是代数化简的操作
mostly the algebraic simplification operations.

53
00:00:00,000 --> 00:00:00,000
这里是FOO的导数
There we see the derivative of foo.

54
00:00:00,000 --> 00:00:00,000
#TBD 41：20
In fact, X is at something I wouldn't take off more than 1 point for on an elementary calculus class.

55
00:00:00,000 --> 00:00:00,000
以A为自变量 FOO的导数则是X*X
And the derivative of foo with respect to a, well it's gone down to X times X,

56
00:00:00,000 --> 00:00:00,000
看起来还不差
which isn't so bad.

57
00:00:00,000 --> 00:00:00,000
以B为自变量 FOO的导数则是X本身
And the derivative of foo with respect to b is just X itself.

58
00:00:00,000 --> 00:00:00,000
以C为自变量 FOO的导数则为“1”
And the derivative of foo with respect to c comes out 1.

59
00:00:00,000 --> 00:00:00,000
我对这些结果很满意
So I'm pretty pleased with this.

60
00:00:00,000 --> 00:00:00,000
你所看到的 都是精心设计、仔细规划的例子
What you've seen is, of course, a little bit contrived, carefully organized example

61
00:00:00,000 --> 00:00:00,000
用以展示如何操作代数表达式
to show you how we can manipulate algebraic expressions,

62
00:00:00,000 --> 00:00:00,000
我们如何不用具体的语法 而用抽象的语法抽象地进行
how we do that abstractly in terms of abstract syntax rather than concrete syntax

63
00:00:00,000 --> 00:00:00,000
以及我们如何使用抽象屏障控制构造这些表达式 #TBD 41：56
and how we can use the abstraction to control what goes on in building these expressions.

64
00:00:00,000 --> 00:00:00,000
真正的奥义并不是如此的简单
But the real story isn't just such a simple thing as that.

65
00:00:00,000 --> 00:00:00,000
实际上 真正的奥义在于我在操作这些表达式时
The real story is, in fact, that I'm manipulating these expressions.

66
00:00:00,000 --> 00:00:00,000
代数表达式和代码表达式——
And the expressions are the same expressions--

67
00:00:00,000 --> 00:00:00,000
回过头来看看幻灯片
going back to the slide--

68
00:00:00,000 --> 00:00:00,000
都是同一种LISP表达式
as the ones that are Lisp expressions.

69
00:00:00,000 --> 00:00:00,000
这样一语双关 一石二鸟
There's a pun here.

70
00:00:00,000 --> 00:00:00,000
#TBD 42：00
I've chosen my representation to be the same as the representation in my language of similar things.

71
00:00:00,000 --> 00:00:00,000
为了要这样做 我得付出点代价
By doing so, I've invoked a necessity.

72
00:00:00,000 --> 00:00:00,000
我需要使用类似于“引用”的东西
I created the necessity to have things like quotation

73
00:00:00,000 --> 00:00:00,000

because of the fact that my language is capable of writing expressions that talk about expressions of the language.

74
00:00:00,000 --> 00:00:00,000
我需要有某种东西指出 这个是我需要讨论的表达式
I need to have something that says, this is an expression I'm talking about

75
00:00:00,000 --> 00:00:00,000
而不是说 这个表达式的值 #TBD
rather than this expression is talking about something,

76
00:00:00,000 --> 00:00:00,000

and I want to talk about that.

77
00:00:00,000 --> 00:00:00,000
引用阻止表达式被求值 其语义为“就是表达式本身”
So quotation stops and says, I'm talking about this expression itself.

78
00:00:00,000 --> 00:00:00,000
有了这种能力以后
Now, given that power,

79
00:00:00,000 --> 00:00:00,000
如果我可以操作语言的表达式
if I can manipulate expressions of the language,

80
00:00:00,000 --> 00:00:00,000

I can begin to build even much more powerful layers upon layers of languages.

81
00:00:00,000 --> 00:00:00,000
因为我可以编写不仅仅是内嵌于LISP的语言
Because I can write languages that not only are embedded in Lisp

82
00:00:00,000 --> 00:00:00,000
或者是其它的语言
or whatever language you start with,

83
00:00:00,000 --> 00:00:00,000
我可以编写一种完全不同的语言
but languages that are completely different,

84
00:00:00,000 --> 00:00:00,000
而其实质上则是被LISP或其它语言所解释
that are just, if we say, interpreted in Lisp or something like that.

85
00:00:00,000 --> 00:00:00,000
我们以后还会对此有更深入的理解
We'll get to understand those words more in the future.

86
00:00:00,000 --> 00:00:00,000
我现在只是想让你们意识到 #TBD
But right now I just want to leave you with the fact that we've hit a line

87
00:00:00,000 --> 00:00:00,000
我们已经感触到了一种惊人的力量
which gives us tremendous power.

88
00:00:00,000 --> 00:00:00,000
现在我们有了方天画戟
And this point we've bought a sledgehammer.

89
00:00:00,000 --> 00:00:00,000
当我们使用它时 也得万分小心
We have to be careful to what flies when we apply it.

90
00:00:00,000 --> 00:00:00,000
谢谢大家
Thank you.

91
00:00:00,000 --> 00:00:06,293
哈尔滨工业大学 IBM技术中心
倾情制作

92
00:00:06,293 --> 00:00:09,413
压制&&特效：蔡钟毓（JohnTitor）
翻译&&时间轴：邓雄飞（Dysprosium）

93
00:00:09,413 --> 00:00:15,440
特别感谢：裘宗燕教授
校对：邓雄飞（Dysprosium）

94
00:00:15,440 --> 00:00:18,960
符号化求导系统

95
00:00:19,100 --> 00:00:23,413
教授：哈尔教授讲解了如何构造健壮的系统
PROFESSOR: Well, Hal just told us how you build robust systems.

96
00:00:23,800 --> 00:00:26,173
关键点就是
The key idea was--

97
00:00:26,813 --> 00:00:30,200
我确信你们大多数人到现在为止还不太明白
I'm sure that many of you don't really assimilate that yet--

98
00:00:30,200 --> 00:00:33,773
关键点就是 为了让系统具有健壮性
but the key idea is that in order to make a system that's robust,

99
00:00:33,933 --> 00:00:36,480
应该让它对小变化不敏感
it has to be insensitive to small changes,

100
00:00:36,600 --> 00:00:37,373
也就是说
that is,

101
00:00:37,373 --> 00:00:40,906
问题中的小改变只会导致解决方案的小改动
a small change in the problem should lead to only a small change in the solution.

102
00:00:41,320 --> 00:00:42,906
系统应该是连续的
There ought to be a continuity.

103
00:00:42,900 --> 00:00:45,946
在问题空间中 解的空间是连续的
The space of solutions ought to be continuous in this space of problems.

104
00:00:46,253 --> 00:00:48,760
Hal教授给你们解释过
The way he was explaining how to do that

105
00:00:49,460 --> 00:00:54,786

was instead of solving a particular problem at every level of decomposition of the problem at the subproblems,

106
00:00:55,080 --> 00:00:56,780

where you solve the class of problems,

107
00:00:56,780 --> 00:01:00,400

which are a neighborhood of the particular problem that you're trying to solve.

108
00:01:01,400 --> 00:01:04,760
解决之道便是在该层次上构造一门语言
The way you do that is by producing a language at that level of detail

109
00:01:04,760 --> 00:01:10,333
使得我们可以用这门语言来表述这类问题
in which the solutions to that class of problems is representable in that language.

110
00:01:11,373 --> 00:01:15,093
因此 当着手解决的问题再发生变动时
Therefore when you change makes more changes to the problem you're trying to solve,

111
00:01:15,090 --> 00:01:19,293
通常 你只需要在已构造好的解决方案上做出微小改动
you generally have to make only small local changes to the solution you've constructed,

112
00:01:19,293 --> 00:01:22,266
因为在你所考虑的层次上
because at the level of detail you're working,

113
00:01:22,266 --> 00:01:24,266
有一门语言可以
there's a language where you can express

114
00:01:24,800 --> 00:01:28,146
表达与该问题类似的其它问题的各种解法
the various solutions to alternate problems of the same type.

115
00:01:30,040 --> 00:01:33,746
呃... 这是一个重要思想的萌芽
Well that's the beginning of a very important idea,

116
00:01:34,400 --> 00:01:38,613
该思想的重要性也使得计算机科学比
the most important perhaps idea that makes computer science more powerful

117
00:01:38,613 --> 00:01:42,373
其它大多数工程学科还要强大
than most of the other kinds of engineering disciplines we know about.

118
00:01:43,386 --> 00:01:44,733
目前为止 我们学习的是
What we've seen so far

119
00:01:44,733 --> 00:01:48,786
类似于如何使用语言内置元素
is sort of how to use embedding of languages.

120
00:01:49,266 --> 00:01:53,360
当然 内置元素的力量一部分来源于
And, of course, the power of embedding languages partly comes from

121
00:01:54,120 --> 00:01:56,866
像这个一样的过程 我昨天给你们展示过了
procedures like this one that I showed you yesterday.

122
00:01:57,373 --> 00:02:02,133
这里 是一份求导程序 昨天给你们描述过了
What you see here is the derivative program that we described yesterday.

123
00:02:02,130 --> 00:02:05,920
这个过程以一个过程为参数
It's a procedure that takes a procedure as an argument

124
00:02:06,000 --> 00:02:07,920
并返回一个过程
and returns a procedure as a value.

125
00:02:09,613 --> 00:02:12,653
用这样的东西棒极了
And using such things is very nice.

126
00:02:12,653 --> 00:02:14,653
你可以压入组合子 #TBD
You can make things like push combinators

127
00:02:14,650 --> 00:02:16,866
还有你们上次看到的各种美妙的事
and all that sort of wonderful thing that you saw last time.

128
00:02:17,680 --> 00:02:20,546
然而 现在我要搅浑这滩水
However, now I'm going to really muddy the waters.

129
00:02:21,560 --> 00:02:25,906
这个程序混淆了过程和数据
See this confuses the issue of what's the procedure and what is data,

130
00:02:26,560 --> 00:02:27,813
虽然程度不算太重
but not very badly.

131
00:02:28,426 --> 00:02:30,906
而我们将要严重地混淆两者
What we really want to do is confuse it very badly.

132
00:02:31,186 --> 00:02:32,440
最好的做法就是
And the best way to do that

133
00:02:32,440 --> 00:02:37,626
参与到过程自身所描述的代数表达式的操作中
is to get involved with the manipulation of the algebraic expressions that the procedures themselves are expressed in.

134
00:02:39,733 --> 00:02:45,586
所以 这里我不会讨论这张幻灯片上的东西
So at this point, I want to talk about instead of things like on this slide,

135
00:02:45,893 --> 00:02:49,720
一个通过操作过程的求导程序
the derivative procedure being a thing that manipulates a procedure--

136
00:02:49,720 --> 00:02:51,946
这只是一个数值化方法而已
this is a numerical method you see here.

137
00:02:51,946 --> 00:02:58,933
你们所看到的是 通过数值方法来近似的求导程序
And what you're seeing is a representation of the numerical approximationto the derivative.

138
00:02:59,293 --> 00:03:00,440
也就是这里的东西了
That's what's here.

139
00:03:00,866 --> 00:03:04,933
事实上 我想讨论的是这些东西
In fact what I'd like to talk about is instead things that look like this.

140
00:03:06,053 --> 00:03:11,333
这是一份从微积分书中摘录的法则
And what we have here are rules from a calculus book.

141
00:03:12,093 --> 00:03:16,173
这对表达式求导的法则
These are rules for finding the derivatives of the expressions

142
00:03:16,706 --> 00:03:20,586
只不过是用代数语言书写的
that one might write in some algebraic language.

143
00:03:21,640 --> 00:03:24,413
法则说 常数的导数是0
It says things like a derivative of a constant is 0.

144
00:03:25,133 --> 00:03:29,093
而代表你所讨论的那个数的变量导数为1
The derivative of the valuable with respect to which you are taking the derivative is 1.

145
00:03:29,320 --> 00:03:31,933
常数乘以函数的导数
The derivative of a constant times the function

146
00:03:32,093 --> 00:03:34,373
其值是常数的值乘以函数导数的值
is the constant times the derivative of the function,

147
00:03:34,773 --> 00:03:36,040
就是这个意思
and things like that.

148
00:03:38,053 --> 00:03:41,386
这些都是精确的表达式 而非数值近似
These are exact expressions. These are not numerical approximations.

149
00:03:42,960 --> 00:03:44,520
我们还能编写程序吗？
Can we make programs?

150
00:03:44,520 --> 00:03:52,240
事实上 编写处理这些表达式的程序非常容易
And, in fact, it's very easy to make programs that manipulate these expressions.

151
00:03:56,386 --> 00:03:59,520
让我们仔细地看看这些法则
Well let's see. Let's look at these rules in some detail.

152
00:04:01,080 --> 00:04:05,226
你们曾经在初等微积分课上学过这些法则了
You all have seen these rules in your elementary calculus class at one time or another.

153
00:04:05,980 --> 00:04:12,120
你们知道 微积分中对多元表达式求导很容易
And you know from calculus that it's easy to produce derivatives of arbitrary expressions.

154
00:04:12,533 --> 00:04:16,053
在微积分课上 你们也知道计算积分不容易
You also know from your elementary calculus that it's hard to produce integrals.

155
00:04:16,986 --> 00:04:19,373
虽然积分和求导相对
Yet integrals and derivatives are opposites of each other.

156
00:04:19,520 --> 00:04:21,280
它俩互为逆运算
They're inverse operations.

157
00:04:21,613 --> 00:04:23,306
但它们有同样的法则
And they have the same rules.

158
00:04:24,160 --> 00:04:29,680
但这些法则中又有什么特殊的东西
What is special about these rules that makes it possible for one

159
00:04:29,680 --> 00:04:33,653
使得求导容易 求积分就困难呢？
to produce derivatives easily and integrals why it's so hard?

160
00:04:34,853 --> 00:04:36,986
我们浅显地想一想
Let's think about that very simply.

161
00:04:37,400 --> 00:04:38,386
仔细考察法则
Look at these rules.

162
00:04:39,360 --> 00:04:43,066
对于每条法则来说 你求导数时的方向
Every one of these rules, when used in the direction for taking derivatives,

163
00:04:43,060 --> 00:04:44,800
这个箭头的方向
which is in the direction of this arrow,

164
00:04:46,680 --> 00:04:49,160
法则的左边与你的表达式相匹配
the left side is matched against your expression,

165
00:04:49,160 --> 00:04:53,053
法则的右边就是表达式的导数
and the right side is the thing which is the derivative of that expression.

166
00:04:54,026 --> 00:04:55,653
箭头是这个方向的
The arrow is going that way.

167
00:04:57,373 --> 00:05:00,453
每条法则中
In each of these rules,

168
00:05:01,240 --> 00:05:03,720
法则右边的表达式
the expressions on the right-hand side of the rule

169
00:05:03,720 --> 00:05:06,560
都是求导过程中的子表达式
that are contained within derivatives are subexpressions,

170
00:05:06,560 --> 00:05:10,293
都是左边式子的合法子表达式
are proper subexpressions, of the expression on the left-hand side.

171
00:05:10,600 --> 00:05:13,253
这里 我们发现 和的导数
So here we see the derivative of the sum,

172
00:05:13,920 --> 00:05:16,133
也就是左边式子的导数
witch is the expression on the left-hand side

173
00:05:16,133 --> 00:05:18,386
就是两部分导数之和
is the sum of the derivatives of the pieces.

174
00:05:20,080 --> 00:05:24,493
法则从左至右的方向是“归约规则”
So the rule of moving to the right are reduction rules.

175
00:05:25,026 --> 00:05:26,613
问题变简单了
The problem becomes easier.

176
00:05:27,560 --> 00:05:31,480
我把一个复杂的问题 转化成了许多小点儿的问题
I make, I turn a big complicated problem it's lots of smaller problems

177
00:05:32,440 --> 00:05:35,760
然后把结果组合起来 这里用递归可以完美地解决
and then combine the results, a perfect place for recursion to work.

178
00:05:36,586 --> 00:05:40,853
但如果我从另外的方向来思考
If I'm going in the other direction like this,

179
00:05:41,813 --> 00:05:45,133
如果我想求积分的话 你会发现有很多问题
if I'm trying to produce integrals, well there are several problems you see here.

180
00:05:45,240 --> 00:05:49,093
就比如 如果我想求一个和的积分
First of all, if I try to integrate an expression like a sum,

181
00:05:49,213 --> 00:05:50,813
就会匹配多条法则
more than one rule matches.

182
00:05:50,810 --> 00:05:52,106
这条匹配
Here's one that matches.

183
00:05:52,480 --> 00:05:53,653
这条也匹配
Here's one that matches.

184
00:05:54,813 --> 00:05:57,093
我不知道该用哪个——它们之间可能不一样
I don't know which one to take. And they may be different.

185
00:05:57,706 --> 00:06:00,000
我得考察两者的不同之处
I may get to explore different things.

186
00:06:00,253 --> 00:06:03,640
所以 在这个方向上 表达式变复杂了
Also, the expressions become larger in that direction.

187
00:06:04,533 --> 00:06:06,306
当表达式变复杂时
And when the expressions become larger,

188
00:06:06,306 --> 00:06:10,560
就没法保证我所选的路径一定能终止了
then there's no guarantee that any particular path I choose will terminate,

189
00:06:10,946 --> 00:06:13,466
因为唯一的可能是偶然的约分
because we will only terminate by accidental cancellation.

190
00:06:14,240 --> 00:06:18,053
这也就是为什么 积分是一种复杂的搜索 而难以完成
So that's why integrals are complicated searches and hard to do.

191
00:06:19,120 --> 00:06:20,960
现在我不想处理这么复杂的东西
Right now I don't want to do anything as hard as that.

192
00:06:21,493 --> 00:06:23,066
我们先来讨论求导数
Let's work on derivatives for a while.

193
00:06:24,146 --> 00:06:28,133
好吧 我就假设你们都大致了解这些法则了
Well, these rules are ones you know for the most part hopefully.

194
00:06:28,786 --> 00:06:31,880
让我们来看看能不能用程序表达这些法则
So let's see if we can write a program which is these rules.

195
00:06:32,226 --> 00:06:33,720
这应该很容易
And that should be very easy.

196
00:06:34,893 --> 00:06:36,213
信手拈来
Just write the program.

197
00:06:36,690 --> 00:06:39,293
因为 我给你们展示的是“归约规则”
See, because while I showed you is that it's a reduction rule,

198
00:06:39,293 --> 00:06:41,293
这样用递归来编写会比较合适
it's something appropriate for a recursion.

199
00:06:43,080 --> 00:06:45,720
当然 对每条法则来说就是一种情况
And, of course, what we have for each of these rules is we have a case

200
00:06:46,666 --> 00:06:47,786
我们做“分情况分析”
in some case analysis.

201
00:06:48,586 --> 00:06:50,360
我就这么写了
So I'm just going to write this program down.

202
00:06:52,880 --> 00:06:57,693
当然 我得先让大家达成共识 对吧？
Now, of course, I'm going to be saying something you have to believe. Right?

203
00:06:57,690 --> 00:07:00,333
你们应该意识到到我可以表示这些代数式
What you have to believe is I can represent these algebraic expressions,

204
00:07:00,680 --> 00:07:03,880
我可以从中抽取式子 也可以将它们组合起来
that I can grab their parts, that I can put them together.

205
00:07:04,240 --> 00:07:06,493
我们发明了表结构来解决这个问题
We've invented list structures so that you can do that.

206
00:07:07,520 --> 00:07:09,146
但现在我们不必关心
But you don't want to worry about that now.

207
00:07:09,666 --> 00:07:12,453
现在 我要编写一个程序来封装这些法则
Right now I'm going to write the program that encapsulates these rules

208
00:07:12,760 --> 00:07:15,853
但它不依赖于代数表达式的表示法
independent of the representation of the algebraic expressions.

209
00:07:20,426 --> 00:07:28,840
(DERIV EXP VAR)表示表达式EXP关于变量VAR的导数
You have a derivative of an expression with respect to a variable.

210
00:07:30,506 --> 00:07:33,080
这和函数的导数是不一样的
This is a different thing than the derivative of the function.

211
00:07:34,826 --> 00:07:38,613
那个是我们上节课看到的数值近似
That's what we saw last time, that numerical approximation.

212
00:07:39,000 --> 00:07:40,826
并不能看到函数内部
It's something you can't open up a function.

213
00:07:40,820 --> 00:07:41,893
它只是一个数值
It's just the answers.

214
00:07:43,093 --> 00:07:45,186
表达式的导数与它的书写别无二致
The derivative of an expression is the way it's written.

215
00:07:45,746 --> 00:07:47,853
因此 这只是一个语法问题
And therefore it's a syntactic phenomenon.

216
00:07:48,293 --> 00:07:51,626
我们今天要做的大多数工作 就是讨论语法
And so a lot of what we're going to be doing today is worrying about syntax,

217
00:07:52,333 --> 00:07:54,120
表达式的语法或类似
syntax of expressions and things like that.

218
00:07:54,706 --> 00:07:55,933
首先是“分情况分析”
Well, there's a case analysis.

219
00:07:57,500 --> 00:08:01,080
任何时候我们处理复杂事物 需要递归求解时
Anytime we do anything complicated thereby a recursion,

220
00:08:01,080 --> 00:08:02,640
我们很可能需要“按情况分析”
we presumably need a case analysis.

221
00:08:03,626 --> 00:08:05,160
通常都是这样开始的
It's the essential way to begin.

222
00:08:05,160 --> 00:08:07,400
大一点的问题都是用“按情况分析” #TBD
And that's usually a conditional of some large kind.

223
00:08:08,080 --> 00:08:09,973
那么 有哪些可能（的情况）呢？
Well, what are their possibilities?

224
00:08:09,973 --> 00:08:12,533
第一条法则说 如果你遇到一个常数
the first rule that you saw is this something a constant?

225
00:08:16,506 --> 00:08:17,506
这里 我就是在判断
And what I'm asking is,

226
00:08:17,506 --> 00:08:22,226
表达式EXP是否是关于给定变量VAR的常数
is the expression a constant with respect to the variable given?

227
00:08:24,906 --> 00:08:27,080
是的话 结果就是0
If so, the result is 0,

228
00:08:27,506 --> 00:08:30,106
因为导数表征的是某物的变化率
because the derivative represents the rate of change of something.

229
00:08:31,760 --> 00:08:32,653
然而
If, however,

230
00:08:32,893 --> 00:08:40,693
如果我求导的表达式 与我关心的变量有关
the expression that I'm taking the derivative of is the variable I'm varying,

231
00:08:41,720 --> 00:08:50,426
如果判定表达式和变量相同
then this is the same variable, the expression var,

232
00:08:51,146 --> 00:08:54,520
那么关于变量VAR的表达式EXP的变化率就是1
then the rate of change of the expression with respect to the variable is 1.

233
00:08:55,506 --> 00:08:56,546
它俩相同 结果是1
It's the same 1.

234
00:08:58,906 --> 00:09:00,773
当然 还可能有其它的可能性
Well now there are a couple of other possibilities.

235
00:09:01,333 --> 00:09:03,146
比如说 它可能是一个和式
It could, for example, be a sum.

236
00:09:03,866 --> 00:09:05,880
呃 我现在还完全知道该如何表示和式
Well, I don't know how I'm going to express sums yet.

237
00:09:06,090 --> 00:09:08,253
事实上我可以 只是我还没有告诉你们
Actually I do. But I haven't told you yet.

238
00:09:10,346 --> 00:09:11,786
如果表达式是和式
But is it a sum?

239
00:09:12,480 --> 00:09:14,480
我就假想有一种方式可以判别（和式）
I'm imagining that there's some way of telling.

240
00:09:15,306 --> 00:09:19,440
这 我将做一个表达式的类型分派
I'm doing a dispatch on the type of the expression here,

241
00:09:20,773 --> 00:09:23,573
这是在构建语言时绝对必要的
absolutely essential in building languages.

242
00:09:24,720 --> 00:09:26,373
因为语言由不同的表达式构成
Cause languages are made out of different expressions.

243
00:09:26,480 --> 00:09:27,546
我们马上就将看到
And soon we're going to see that

244
00:09:27,840 --> 00:09:31,026
如何用更强大的方法 用语言去构建语言
in our more powerful methods of building languages on languages.

245
00:09:32,533 --> 00:09:34,026
表达式是和式吗？
Is an expression a sum?

246
00:09:35,453 --> 00:09:38,826
如果是的话 很好 我们已经知道和式的求导法则了
If it's a sum, well, we know the rule for derivative of the sum

247
00:09:38,826 --> 00:09:41,333
即是各部分导数之和
is the sum of the derivatives of the parts.

248
00:09:42,133 --> 00:09:44,320
其中一个叫做加数 另一个叫做被加数
One of them is called the addend and the other is the augend.

249
00:09:44,320 --> 00:09:46,800
黑板上没那么多空间写这么长的名字了
But I don't have enough space on the blackboard to such long names.

250
00:09:46,800 --> 00:09:48,400
我就姑且把它们叫做 A1和A2
So I'll call them A1 and A2.

251
00:09:49,040 --> 00:09:50,373
把它们求和
I want to make a sum.

252
00:09:53,133 --> 00:09:55,680
10 ：01
Do you remember which is the sum for end or the menu end?

253
00:09:57,146 --> 00:10:01,093

Or was it the dividend and the divisor or something like that?

254
00:10:01,653 --> 00:10:08,480
将A1的导数...加上
Make sum of the derivative of the A1, I'll call it.

255
00:10:08,480 --> 00:10:13,293
这是关于变量VAR的表达式的加数
It's the addend of the expression with respect to the variable,

256
00:10:14,840 --> 00:10:22,760
与A2的导数相加
and the derivative of the A2 of the expression,

257
00:10:24,120 --> 00:10:28,253
这两个参数的和 变量是VAR
those the two arguments, the addition. Respect to the variable.

258
00:10:32,360 --> 00:10:34,933
我们知道还有一条乘法的求导法则
And another rule that we know is product rule,

259
00:10:35,200 --> 00:10:37,440
也就是说 如果表达式是乘式
which is, if the expression is a product.

260
00:10:43,213 --> 00:10:46,106
顺便说下 当你定义过程时 有个好习惯
By the way, it's a good idea when you're defining things,

261
00:10:46,960 --> 00:10:48,320
就是在定义谓词时
when you're defining predicates,

262
00:10:48,853 --> 00:10:50,960
将谓词名以问号结尾
to give them a name that ends in a question mark.

263
00:10:51,080 --> 00:10:52,893
问号本身不代表什么
This question mark doesn't mean anything.

264
00:10:53,106 --> 00:10:54,506
但这是俗成的约定
It's for us as an agreement.

265
00:10:54,613 --> 00:10:58,946
这是人们之间约定的接口 以方便他人阅读你的脚本
It's a conventional interface between humans so you can read my programs more easily.

266
00:11:00,053 --> 00:11:01,960
我希望你在写程序的时候
So I want you to, when you write programs,

267
00:11:01,960 --> 00:11:03,733
当你定义谓词的时候
if you define a predicate procedure,

268
00:11:04,013 --> 00:11:05,773
就是那些返回TRUE或FALSE的过程
that's something that returns true of false,

269
00:11:05,946 --> 00:11:07,840
你应该使它们的名字以问号结尾
it should have a name which ends in question mark.

270
00:11:08,026 --> 00:11:10,346
这对Lisp无异 但对人类友好
The lisp doesn't care. I care.

271
00:11:11,626 --> 00:11:13,146
我需要求和
I want to make a sum.

272
00:11:13,146 --> 00:11:17,493
因为积的导数就是...
Because the product, the derivative of a product is the sum

273
00:11:17,940 --> 00:11:19,640
被乘数乘以乘数的导数
of the first times the derivative of the second plus

274
00:11:19,666 --> 00:11:20,706
加上乘数乘以被乘数的导数
the second times the derivative of the first.

275
00:11:23,546 --> 00:11:27,066
两者加起来
Make a sum of two things,

276
00:11:29,640 --> 00:11:38,333
求积... 呃 就用表达式中的M1来表示（被乘数）好了
a product of, well, I'm going to say the M1 of the expression,

277
00:11:39,853 --> 00:11:48,973
表达式中M2关于变量VAR的导数
and the derivative of the M2 of the expression with respect to the variable,

278
00:11:51,906 --> 00:12:06,280
以及 M1关于变量VAR的导数乘以
and the product of the derivative of M1,

279
00:12:07,106 --> 00:12:11,920
M1是这里的被乘数
the multiplier of the expression, with respect to the variable.

280
00:12:13,320 --> 00:12:18,053
乘数是表达式中的M2
And the product of that and the multiplicand, M2, of the expression.

281
00:12:20,640 --> 00:12:24,893
求积完毕、求和完毕、乘式分析完毕
Make that product. Make the sum. Close that case.

282
00:12:24,960 --> 00:12:28,026
当然 在这里我可以添加更多的情况
And, of course, I could add as many cases as I like here

283
00:12:28,320 --> 00:12:30,826
微积分书中的完整法则
for a complete set of rules you might find in a calculus book.

284
00:12:34,800 --> 00:12:39,453
我们就是这么来封装这些法则的
So this is what it takes to encapsulate those rules.

285
00:12:41,533 --> 00:12:43,906
如你所见 我们这里用到了大量的“按愿望思维”
And you see, you have to realize there's a lot of wishful thinking here.

286
00:12:44,546 --> 00:12:47,560
我们还没有说这些（表达式）是如何表示的
I haven't told you anything about how I'm going to make these representations.

287
00:12:48,466 --> 00:12:51,920
现在 一旦我将其定为我的一套法则
Now, once I've decided that this is my set of rules,

288
00:12:52,520 --> 00:12:55,200
我想是时候考虑表示法了
I think it's time to play with the representation.

289
00:12:55,533 --> 00:12:56,880
我们来拿捏拿捏
Let's attack that.

290
00:12:57,960 --> 00:13:00,000
Well, first of all, I'm going to play a pun.

291
00:13:00,906 --> 00:13:02,120
It's an important pun.

292
00:13:02,746 --> 00:13:06,560
它是一种强有力思想的关键
It's a key to a sort of powerful idea.

293
00:13:09,626 --> 00:13:14,413
如果我想表达诸如和、积、差、商的东西
If I want to represent sums, and products, and differences, and quotients, and things like that,

294
00:13:15,226 --> 00:13:18,626
为什么不用和我程序一样的语言呢？
why not use the same language as I'm writing my program in?

295
00:13:20,506 --> 00:13:23,640
我程序中 代数表达式是形如
I write my program it algebraic expressions that look like

296
00:13:23,986 --> 00:13:30,453
(+ (* A (* X X))
the sum of the product on a and the product of x and x,

297
00:13:32,600 --> 00:13:33,800
和与之类似的
and things like that.

298
00:13:34,280 --> 00:13:38,506
(* B X)以及C
And the product of b and x and c, whatever,

299
00:13:38,500 --> 00:13:39,973
把它们加起来
make that a sum of the product.

300
00:13:40,773 --> 00:13:44,093
现在 我的过程还不能处理多元参数
Right now I don't want to have procedures with unknown numbers of arguments,

301
00:13:44,933 --> 00:13:48,466
(+ (* B X) C)
a product of b and x and c.

302
00:13:51,426 --> 00:13:52,440
这是表结构
This is list structure.

303
00:13:54,120 --> 00:13:55,746
这么做很棒 是因为
And the reason why this is nice,

304
00:13:55,746 --> 00:13:58,480
是因为这些对象都有一种性质
is because any one of these objects has a property.

305
00:14:01,850 --> 00:14:03,146
CAR部分就是运算符
The car is the operator.
我知道它们的CAR部分是什么
I know where, know where the car is.

306
00:14:03,146 --> 00:14:03,253
CAR部分就是运算符
The car is the operator.

307
00:14:03,920 --> 00:14:06,386
运算数是相继的CDR部分
And the operands are the successive cdrs

308
00:14:07,226 --> 00:14:10,360
也就是不断取表CDR部分的CAR部分
the successive cars of the cdrs of the list that this is.

309
00:14:12,480 --> 00:14:13,880
这样就使它很方便了
It makes it very convenient.

310
00:14:14,013 --> 00:14:16,400
我需要去解析它 但它已经帮我完成了
Ir have to parse it. It's been done for me.

311
00:14:17,426 --> 00:14:20,013
我利用了Lisp中的内建元素
I'm using the embedding in Lisp to advantage.

312
00:14:22,666 --> 00:14:23,773
So, for example,

313
00:14:25,080 --> 00:14:33,973
我们用表结构来表示我所暗示的表示法吧！
Let's start using list structure to write down the representation that I'm implicitly assuming here.

314
00:14:35,253 --> 00:14:38,346
我需要定义一些东西 这都暗含在这种表示法中
Well I have to define various things that are implied in this representation.

315
00:14:38,546 --> 00:14:40,906
比如如何判定是否为常量
Like I have to find out how to do a constant,

316
00:14:41,210 --> 00:14:42,306
又怎么判断是同一个变量
how you do same variable.

317
00:14:42,400 --> 00:14:45,040
我们先完成这些吧 都相当简单
Let's do those first. That's pretty easy enough.

318
00:14:45,786 --> 00:14:47,706
这里 我要介绍一些基本过程
Now I'm going to be introducing lots of primitives here,

319
00:14:48,600 --> 00:14:50,506
因为它们都是与表结构相关的
because these are the primitives that come with list structure.

320
00:14:51,986 --> 00:14:53,466
CONSTANT?谓词定义为
OK, you define a constant.

321
00:15:02,253 --> 00:15:04,293
我所谓的常量
And what I mean by a constant,

322
00:15:04,293 --> 00:15:07,733
表达式关于变量VAR是一个常量
an expression is constant with respect to a variable.

323
00:15:09,053 --> 00:15:11,600
是一些简单的表达式
is that the expression is something simple.

324
00:15:11,600 --> 00:15:14,466
我无法再细化它 但它也不是我们关心的变量
I can't take it into pieces, and yet it isn't that variable.

325
00:15:16,586 --> 00:15:18,786
我无法分解它 但它也不是我们关心的变量
I can't break it up, and yet it isn't that variable.

326
00:15:18,900 --> 00:15:25,120
这也并不是说 存在一些复杂的常量表达式
That does not mean that there may be other expressions that are more complicated that are constants.

327
00:15:25,200 --> 00:15:28,920
#TBD
It's just that I'm going to look at the primitive constants in this way.

328
00:15:29,746 --> 00:15:33,413
因此 这个谓词是几个条件的合取
So what this is, is it says that's it's the and.

329
00:15:34,026 --> 00:15:37,826
AND语句允许用户组合返回TRUE或者FALSE的谓词
I can combine predicate expressions which return true or false with and.

330
00:15:38,626 --> 00:15:46,826
表达式是原子的么？这意味着它不能被细分
Something atomic, The expression is atomic, meaning it cannot be broken into parts.

331
00:15:46,820 --> 00:15:48,533
它没有CAR部分和CDR部分
It doesn't have a car and a cdr.

332
00:15:49,453 --> 00:15:50,213
它不是表
It's not a list.

333
00:15:50,760 --> 00:15:52,946
系统中内建有特殊测试
And it's a special test built into the system.

334
00:15:53,973 --> 00:16:04,666
并且表达式EXP和变量VAR在EQ?的语义下不相等
And it's not identically equal to that variable.

335
00:16:06,826 --> 00:16:13,360
我用不能被分解的符号来表示变量
I'm representing my variables by things that are symbols which cannot be broken into pieces,

336
00:16:13,906 --> 00:16:17,226
比如'X 'Y 和像这样的
things like x, and y, things like this.

337
00:16:19,746 --> 00:16:22,373
#TBD
Whereas, of course, something like this can be broken up into pieces.

338
00:16:24,746 --> 00:16:46,400
(SAME-VAR? EXP VAR)定义为
And the same variable of an expression with respect to a variable is,

339
00:16:46,400 --> 00:16:48,400
实际上 一条原子语句……
in fact, an atomic expression.

340
00:16:48,773 --> 00:16:59,613
I want to have an atomic expression, which is identical.

341
00:17:07,900 --> 00:17:11,680
#TBD
I don't want to look inside this, this stuff anymore.

342
00:17:12,520 --> 00:17:15,560
把这些当作基本过程
These are primitive maybe.

343
00:17:15,773 --> 00:17:17,080
这无关紧要
But it doesn't matter.

344
00:17:17,786 --> 00:17:21,746
我用的是语言内置的功能
I'm defining... I'm using things that are given to me with a language.

345
00:17:22,426 --> 00:17:24,040
我非常关心这些（具体实现）
I'm not terribly interest in them.

346
00:17:24,426 --> 00:17:26,040
现在 我们要如何处理和式呢？
Now how do we deal with sums?

347
00:17:26,600 --> 00:17:28,800
啊哈 好戏就要上演了#TBD
Ah, something very interesting will happen.

348
00:17:28,986 --> 00:17:33,120
和式不是原子的 它以‘+’号打头
A sum is something which is not atomic and begins with the plus symbol.

349
00:17:35,160 --> 00:17:36,173
就是这个意思
That's what it means.

350
00:17:36,653 --> 00:17:39,773
这里 我定义
So here, I will define.

351
00:17:45,466 --> 00:17:57,773
表达式为和式 当它不是原子表达式
An expression is a sum if and it's not atomic

352
00:18:04,573 --> 00:18:15,453
并且它的开头 表达式的CAR部分是个‘+’号
and it's head, it's beginning, its car of the expression is the symbol plus.

353
00:18:19,746 --> 00:18:24,040
我将要引入一个你们从未见过的东西——这个引号
Now you're about to see something you haven't seen before, this quotation.

354
00:18:25,893 --> 00:18:28,226
我这里为什么要用引号呢？
Why do I have that quotation there?

355
00:18:29,480 --> 00:18:30,520
教授：说你的名字
PROFESSOR: Say your name,

356
00:18:30,680 --> 00:18:31,410
观众：Susanna
AUDIENCE: Susanna.

357
00:18:31,410 --> 00:18:32,013
教授：大点声儿
PROFESSOR: Louder.

358
00:18:32,013 --> 00:18:32,720
观众：Susanna
AUDIENCE: Susanna

359
00:18:33,253 --> 00:18:34,213
教授：说“你的名字”
PROFESSOR: Say your name.

360
00:18:34,213 --> 00:18:34,853
观众：“你的名字”
AUDIENCE: Your name.

361
00:18:34,920 --> 00:18:35,680
教授：大点声儿
PROFESSOR: Louder.

362
00:18:35,773 --> 00:18:36,613
观众：“你的名字”
AUDIENCE: Your name.

363
00:18:36,826 --> 00:18:37,506
教授：对了
PROFESSOR: OK.

364
00:18:38,280 --> 00:18:44,560
在这里我想告诉大家 英语词汇是有歧义的
What I'm showing you here is that the words of English are ambiguous.

365
00:18:45,506 --> 00:18:50,760
我可能说 “说你的名字”
I was saying, say your name.

366
00:18:51,970 --> 00:18:57,213
我也可能说 “说‘你的名字’”
I was also possibly saying say, your name.

367
00:19:00,720 --> 00:19:02,986
光从说话上还无法分辨
But that cannot be distinguished in speech.

368
00:19:03,893 --> 00:19:08,013
然而书面上 我们有专门的记号——引号
However, we do have a notation in writing,

369
00:19:08,186 --> 00:19:12,466
用来区别这两种可能的意思
which is quotation for distinguishing these two possible meanings.

370
00:19:14,000 --> 00:19:15,640
具体来说 这里
In particular, over here,

371
00:19:16,493 --> 00:19:20,840
在Lisp中有用于区别这些语义的记号
in Lisp we have a notation for distinguishing these meanings.

372
00:19:21,346 --> 00:19:24,453
如果我只是写下一个加号
If I were to just write a plus here, a plus symbol,

373
00:19:24,640 --> 00:19:28,520
我会问系统 表达式的首元素
I would be asking, is the first element of the expression,

374
00:19:29,066 --> 00:19:33,613
也就是表达式的运算符 是加运算符么？
is the operator position of the expression, the addition operator?

375
00:19:34,653 --> 00:19:35,546
我并不知道
I don't know.

376
00:19:36,226 --> 00:19:38,160
我本应该在那里写一个加运算符的
I would have to have written the addition operator there,

377
00:19:39,373 --> 00:19:40,440
但我无法那样做
which I can't write.

378
00:19:41,340 --> 00:19:45,880
而这种方式则是问 这个符号对象是否为
However, this way I'm asking, is this the symbolic object plus,

379
00:19:45,986 --> 00:19:48,146
代表加运算符的符号
which normally stands for the addition operator?

380
00:19:49,573 --> 00:19:51,920
这才是我想要问和知道的问题
That's what I want. That's the question I want to ask.

381
00:19:52,920 --> 00:19:54,453
在我们深入讨论之前
Now before I go any further,

382
00:19:54,450 --> 00:19:57,813
我想要指出 “引用”是一个复杂的概念
I want to point out the quotation is a very complex concept,

383
00:19:58,853 --> 00:20:01,840
语言中引入这个概念将会造成许多麻烦
and adding it to a language causes a great deal of troubles.

384
00:20:03,573 --> 00:20:05,040
请看下面这张幻灯片
Consider the next slide.

385
00:20:06,386 --> 00:20:09,493
这里这个推论没有问题
Here's a deduction which we should all agree with.

386
00:20:11,626 --> 00:20:17,040
这是说 Alyssa聪明而Alyssa是George的妈妈
We have, Alyssa is smart and Alyssa is George's mother.

387
00:20:17,400 --> 00:20:20,600
is就是一个等式
This is an equality, is.

388
00:20:22,133 --> 00:20:26,306
我们可以从这两个陈述推论出 George妈妈很聪明
From those two, we can deduce that George's mother is smart.

389
00:20:27,320 --> 00:20:33,160
这是因为我们总可以在表达式中等价替换
Because we can always substitute equals for equals in expressions.

390
00:20:34,093 --> 00:20:35,160
真是这样吗？
Or can we?

391
00:20:36,520 --> 00:20:40,373
这个例子说 “Chicago”有七个字母
Here's a case where we have "Chicago" has seven letters.

392
00:20:41,120 --> 00:20:44,866
引用则是强调我讨论的是单词“Chicago”
The quotation means that I'm discussing the word Chicago,

393
00:20:44,866 --> 00:20:46,866
而不是单词所代表的意思
not what the word represents.

394
00:20:49,826 --> 00:20:52,773
这里说 Chicago是Illinois州最大的城市
Here I have that Chicago is the biggest city in Illinois.

395
00:20:54,613 --> 00:20:55,800
而（代换的）结果是……
As a consequence of this,

396
00:20:55,800 --> 00:20:59,093
我可能会得到 Illinois州最大的城市有七个字母
I would like to deduce that the biggest city in Illinois has seven letters.

397
00:20:59,320 --> 00:21:01,066
这显然是错的
But that's manifestly false.

398
00:21:01,346 --> 00:21:01,346
喔！手写笔好使了
Wow, it works.

399
00:21:09,293 --> 00:21:12,240
所以 一旦我们有了（引用）这样的东西
OK, so once we have things like that,

400
00:21:12,480 --> 00:21:14,493
我们的语言就会变得复杂
our language gets much more complicated.

401
00:21:14,493 --> 00:21:18,346
因为我们对于语言的一些操作就不再正确
Because it's no longer true that things we tend to like to do with languages,

402
00:21:18,346 --> 00:21:20,760
比如通过等价代换来得到正确答案
like substituting equals for equals and getting right answers,

403
00:21:21,293 --> 00:21:23,506
如果不小心地操作就会出错
are going to work without being very careful.

404
00:21:24,493 --> 00:21:27,346
在一个引用不透明的上下文中 我们无法进行代换
We can't substitute into what's called referentially opaque contexts,

405
00:21:27,893 --> 00:21:32,640
引用就是引用不透明上下文的典型
of which a quotation is the prototypical type of referentially opaque context.

406
00:21:33,173 --> 00:21:35,280
如果你知道那是什么意思……你可以成为一位哲学家
If you know what that means, you can consult a philosopher.

407
00:21:35,426 --> 00:21:37,026
或许我们之中就有一位
Presumably there is one in the room.

408
00:21:37,533 --> 00:21:41,320
言归正传 我们继续
In any case, let's continue now,

409
00:21:41,320 --> 00:21:44,986
现在我们对一个有2000年历史的问题至少有了操作上的理解
now that we at least have an operational understanding of a 2000-year-old issue

410
00:21:45,266 --> 00:21:48,133
关于名称、提及和等等类似的问题
that has to do with name, and mention, and all sorts of things like that.

411
00:21:52,320 --> 00:22:01,600
我得定义如何把两个数加起来 (DEFINE (MAKE-SUM A1 A2))
I have to define what I mean, how to make a sum of two things, an a1 and a2.

412
00:22:02,120 --> 00:22:03,626
我简单实现一下
And I'm going to do this very simply.

413
00:22:03,626 --> 00:22:11,960
'+、A1、A2构成列表
It's a list of the symbol plus, and a1, and a2.

414
00:22:13,866 --> 00:22:17,373
我可以决定如何取出第一个元素
And I can determine the first element.

415
00:22:21,840 --> 00:22:25,320
(DEFINE A1 CADR)
Define a1 to be cadr.

416
00:22:33,880 --> 00:22:35,906
这里又给大家介绍了一个基本过程
I've just introduced another primitive.

417
00:22:36,173 --> 00:22:39,106
这个是取出某物CDR部分的CAR部分
This is the car of the cdr of something.

418
00:22:39,800 --> 00:22:44,533
大家或许会好奇 这些基本过程为什么叫做CAR和CDR
You might want to know why car and cdr are names of these primitives,

419
00:22:44,666 --> 00:22:48,426
而且传承了下来 尽管叫做LEFT和RIGHT会好一点
and why they've survived, even though they're much better ideas like left and right.

420
00:22:48,760 --> 00:22:50,440
我们本可以那样叫的
We could have called them things like that.

421
00:22:51,280 --> 00:22:56,253
呃 其实 这个名字来自于很久以前 当发明Lisp时
Well, first of all, the names come from the fact that in the great past, when Lisp was invented,

422
00:22:56,360 --> 00:23:00,800
我想大概是58年的样子 是在类似于704之类的机子上实现的
I suppose in '58 or something, it was on a 704 or something like that,

423
00:23:00,800 --> 00:23:05,413
这个机器有个地址寄存器和减量寄存器
which had a machine. It was a machine that had an address register and a decrement register.

424
00:23:05,413 --> 00:23:08,173
而这些就是地址寄存器和减量寄存器的值
And these were the contents of the address register and the decrement register.

425
00:23:08,173 --> 00:23:09,373
所以这是历史遗留问题
So it's an historical accident.

426
00:23:09,640 --> 00:23:11,280
但是这些名字为什么又延续下来了呢？
Now why have these names survived?

427
00:23:11,746 --> 00:23:14,760
这是因为Lisp程序员喜欢用电话交流
It's because Lisp programmers like to talk to each other over the phone.

428
00:23:15,680 --> 00:23:19,600
要是你有一长串的CAR和CDR序列 你就可能说“CDADDEDR”
And if you want to have a long sequence of cars and cdrs you might say, cdaddedr,

429
00:23:21,013 --> 00:23:22,320
这是可以理解的
which can be understood.

430
00:23:22,320 --> 00:23:27,026
但是左边的右边的右边的左边就不是那么清楚了
But left of right or right of left is not so clear if you get good at it.

431
00:23:27,600 --> 00:23:30,026
这就是我们为什么有这些黑话
So that's why we have these words.

432
00:23:30,546 --> 00:23:34,146
典型的Lisp系统 默认定义到第四层
All of them up to four deep are defined typically in a Lisp system.

433
00:23:38,666 --> 00:23:47,053
而定义A2为……当然 如果我们考察这些表达式中的一个
A2 to be-- and, of course, you can see that if I looked at one of these expressions

434
00:23:47,360 --> 00:23:52,146
比如(+ 3 5)
like the sum of 3 and 5,

435
00:23:52,586 --> 00:24:10,453
这个实际上是一个包含有'+、数3和数5的表
what that is is a list containing the symbol plus, and a number 3, and a number 5.

436
00:24:11,720 --> 00:24:15,186
表的CAR部分是'+
Then the car is the symbol plus.

437
00:24:16,133 --> 00:24:18,213
CDR部分的CAR部分
The car of the cdr.

438
00:24:18,210 --> 00:24:20,210
也就是先取CDR部分 然后再取CAR部分
Well I take the cdr and then I take the car.

439
00:24:20,210 --> 00:24:22,210
这就是我如何取得3的 也就是第一个参数
And that's how I get to the 3. That's the first argument.

440
00:24:22,520 --> 00:24:25,693
CDR的CDR部分的CAR部分 就是这个……数5
And the car of the cdr of the cdr gets me to this one, the 5.

441
00:24:28,693 --> 00:24:33,666
当然类似地 对于乘式我可以这样定义
And similarly, of course, I can define what's going on with products.

442
00:24:35,226 --> 00:24:36,560
我快速地演示一下
Let's do that very quickly.

443
00:24:48,973 --> 00:24:50,640
(DEFINE (PRODUCT? EXP))
Is the expression a product?

444
00:24:51,053 --> 00:24:54,693
如果它不是原子的 而且
Yes if and if it's true, that's it's not atomic

445
00:25:01,413 --> 00:25:14,146
EXP的CAR部分与用于表示乘法的符号'*在 EQ?的语义下相等
and it's EQ quote, the asterisk symbol, which is the operator for multiplication.

446
00:25:15,640 --> 00:25:32,000
(DEFINE (MAKE-PRODUCT M1 M2))
Make product of an M1 and an M2 to be list,

447
00:25:34,426 --> 00:25:39,306
(LIST '* M1 M2)
quote, the asterisk operation and M1 and M2.

448
00:25:47,133 --> 00:25:56,813
并定义M1为CADR M2为CADDR
And I define M1 to be cadr and M2 to be caddr.

449
00:26:00,093 --> 00:26:02,386
#TBD
You get to be a good Lisp programmer because you start talking that way.

450
00:26:02,533 --> 00:26:05,533
你可以取表的CDR 也可以把它们组合起来
You can cdr thing down lists and cons them up and so on.

451
00:26:06,293 --> 00:26:10,106
现在 我们有了原理上完整的求导程序了
Now, now that we have essentially a complete program for finding derivatives,

452
00:26:10,106 --> 00:26:11,706
如果需要的话 你也可以添加更多的规则
you can add more rules if you like.

453
00:26:12,213 --> 00:26:13,933
它又要怎么用呢？
What kind of behavior do we get out of it?

454
00:26:14,640 --> 00:26:16,773
我先把这个笔迹清了
I'll have to clear that x.

455
00:26:17,800 --> 00:26:20,826
恩 假设我在这里定义FOO为
Well, supposing I define foo here

456
00:26:22,160 --> 00:26:30,386
定义FOO为A*X^2+B*X+C
to be the sum of the product of ax square and bx plus c.

457
00:26:30,540 --> 00:26:32,080
跟我们这里看到的是一样的
That's the same thing we see here

458
00:26:32,080 --> 00:26:36,360
这里是用更习见的记号书写的代数表达式
as the algebraic expression written in the more conventional notation over there.

459
00:26:37,840 --> 00:26:41,600
那么 表达式FOO关于X的导数 结果在这里
Well, the derivative of foo with respect to x, which we can see over here,

460
00:26:43,466 --> 00:26:45,266
真是乱得一团糟
is this horrible, horrendous mess.

461
00:26:46,160 --> 00:26:49,226
我期望答案是2*A*X+B
I would like it to be 2ax plus b.

462
00:26:50,680 --> 00:26:53,440
虽然与结果等价 但它并不是我们希望的结果
But it's not. It's equivalent to it.

463
00:26:54,586 --> 00:26:55,226
这是什么呢？
What is it?

464
00:26:55,973 --> 00:26:59,960
我们最初有什么？
I have here, what do I have?

465
00:27:00,506 --> 00:27:04,306
我求X*X的导数
I have the derivative of the product of x and x.

466
00:27:04,693 --> 00:27:10,533
答案是X*1+1*X 这当然没错
Over here is, of course, the sum of x times 1 and 1 times x.

467
00:27:12,733 --> 00:27:15,666
这就是乘数的导数乘以被乘数加上乘数乘以被乘数的导数
Now, well, it's the first times the derivative of the second plus the second times the derivative of the first. It's right.

468
00:27:17,226 --> 00:27:28,373
那就是2X、A*2X就是2AX、0X^2省去 再加上0和这里的一大堆0
That's 2x of course. a times 2x is 2ax plus 0X square doesn't count plus B over here plus a bunch of 0's.

469
00:27:28,960 --> 00:27:30,120
答案是对的
Well the answer is right.

470
00:27:30,120 --> 00:27:35,146
#TBD
But I give people take off points on an exam for that, sadly enough.

471
00:27:35,560 --> 00:27:37,266
我们下一节再考虑这个内容
Let's worry about that in the next segment.

472
00:27:37,680 --> 00:27:38,613
有疑问吗？
Are there any questions?

473
00:27:42,773 --> 00:27:43,453
请说
Yes?

474
00:27:43,893 --> 00:27:46,693
观众：写加号时不加引号
AUDIENCE: If you had left the quote when you put the plus,

475
00:27:46,693 --> 00:27:50,826
是表示引用加那个过程么？
then would that be referring to the procedure plus

476
00:27:50,826 --> 00:27:55,426
#TBD\and could you do a comparison between that procedure and some other procedure if you wanted to?

477
00:27:56,160 --> 00:27:57,080
教授：问得好！
PROFESSOR: Yes. Good question.

478
00:27:57,453 --> 00:28:02,266
如果我这里不用左引号将这个引住
If I had left this quotation off at this point,

479
00:28:03,880 --> 00:28:07,133
如果我这里不用引号
Okay? If I had left that quotation off at that point,

480
00:28:07,333 --> 00:28:14,200
那么这里我就会引用定义好的加法过程
then I would be referring here to the procedure which is the thing that plus is defined to be.

481
00:28:15,386 --> 00:28:24,880
实际上 我可以比较两个过程是否同一
And indeed, I could compare some procedures with each other for identity.

482
00:28:24,880 --> 00:28:27,453
现在很难从语义上解释
Now what that means is not clear right now.

483
00:28:27,853 --> 00:28:29,373
我现在不想考虑这个问题
I don't like to think about it.

484
00:28:29,893 --> 00:28:32,400
因为我不知道比较过程需要什么
Because I don't know exactly what it would need to compare procedures.

485
00:28:32,400 --> 00:28:34,400
这样做没有意义是有很多原因的
There are reasons why that may make no sense at all.

486
00:28:35,520 --> 00:28:37,533
然而 这些符号我们是可以理解的
However, the symbols, we understand.

487
00:28:38,546 --> 00:28:40,560
这也是我为什么我要将它们引住
And so that's why I put that quote in.

488
00:28:41,160 --> 00:28:43,706
我想讨论出现在这些代码中的符号
I want to talk about the symbol that's apparent on the page.

489
00:28:46,160 --> 00:28:46,920
还有什么问题么？
Any other questions?

490
00:28:48,520 --> 00:28:51,866
好吧 休息一下 谢谢大家
OK. Thank you. Let's take a break.

491
00:28:55,120 --> 00:29:00,666
[音乐]
[JESU, JOY OF MAN'S DESIRING]


492
00:29:00,680 --> 00:29:04,346
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

493
00:29:04,340 --> 00:29:06,680
讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
By: Prof. Harold Abelson && Gerald Jay Sussman

494
00:29:12,210 --> 00:29:19,173
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

495
00:29:20,093 --> 00:29:24,140
符号化导数系统、引用
Symbolic Differentiation: Quotation

496
00:29:29,866 --> 00:29:30,920
教授：好 我们继续
PROFESSOR: Well, let's see.

497
00:29:31,466 --> 00:29:37,760
我们编写了一个貌似可行的代数表达式求导程序
We've just developed a fairly plausible program for computing the derivatives of algebraic expressions.

498
00:29:38,200 --> 00:29:41,560
这个程序是不完整的 你需要添加一些规则
It's an incomplete program, if you would like to add more rules.

499
00:29:42,133 --> 00:29:49,706
#TBD
And perhaps you might extend it to deal with uses of addition with any number of arguments and multiplication with any of the number of arguments.

500
00:29:49,893 --> 00:29:51,386
这些都相当简单
And that's all rather easy.

501
00:29:52,733 --> 00:29:56,933
但这里面也有一些瑕疵
However, there was a little fly in that ointment.

502
00:29:57,480 --> 00:30:02,373
回到这张幻灯片来
We go back to this slide.

503
00:30:02,946 --> 00:30:08,600
我们发现 得到的表达式相当乱
We see that the expressions that we get are rather bad.

504
00:30:08,880 --> 00:30:11,013
这个表达式非常糟糕
This is a rather bad expression.

505
00:30:11,466 --> 00:30:13,106
我们是怎么得到这样的表达式的？
How do we get such an expression?

506
00:30:13,840 --> 00:30:15,506
为什么是这样呢？
Why do we have that expression?

507
00:30:16,840 --> 00:30:18,746
我们详细地分析一下这个表达式
Let's look at this expression in some detail.

508
00:30:18,920 --> 00:30:20,760
找出这些片段都是出自哪里
Let's find out where all the pieces come from.

509
00:30:21,693 --> 00:30:24,560
如我们所见 这里的和式
As we see here, we have a sum--

510
00:30:24,560 --> 00:30:26,560
也就是上一小节中给你们提到的
just what I showed you at the end of the last time--

511
00:30:27,120 --> 00:30:29,093
(+ (* X 1) (* 1 X))
of X times 1 plus 1 time X.

512
00:30:29,586 --> 00:30:31,386
是这个乘式的导数
That is a derivative of this product.

513
00:30:32,520 --> 00:30:36,413
也就是A乘上这个的积 这里A不是X的函数
The product of a times that, where a does not depend upon x,

514
00:30:36,410 --> 00:30:38,410
因此A关于X是一个常数
and therefore is constant with respect to x,

515
00:30:39,040 --> 00:30:44,533
导数为这个和式 从这里到这里 再到这里
is this sum, which goes from here all the way through here and through here.

516
00:30:44,800 --> 00:30:48,893
因为这个是乘数乘以被乘数的导数
Because it is the first thing times the derivative of the second

517
00:30:49,573 --> 00:30:54,453
加上被乘数乘以乘数的导数
plus the derivative of the first times the second

518
00:30:54,666 --> 00:30:59,066
#TBD
as the program we wrote on the blackboard indicated we should do.

519
00:31:00,653 --> 00:31:05,360
当然 这里B乘以X的积
And, of course, the product of bx over here

520
00:31:05,493 --> 00:31:09,813
被化成了 B*1+0*X
manifests itself as B times 1 plus 0 times X

521
00:31:10,813 --> 00:31:16,066
因为B不是X的函数
because we see that B does not depend upon X.

522
00:31:16,466 --> 00:31:18,560
因此B的导数为0
And so the derivative of B is this 0,

523
00:31:18,773 --> 00:31:21,480
而X对自己求导则为1
and the derivative of X with respect itself is the 1.

524
00:31:23,066 --> 00:31:28,640
这里的加法化成了 这两个导数的和#TBD
And, of course, the derivative of the sums over here turn into these two sums of the derivatives of the parts.

525
00:31:29,373 --> 00:31:33,506
所以 #TBD 31:40
So what we're seeing here is exactly the thing I was trying to tell you about

526
00:31:33,666 --> 00:31:35,893
with Fibonacci numbers a while ago,

527
00:31:37,773 --> 00:31:39,493
所谓的 “过程的形式”
that the form of the process

528
00:31:41,386 --> 00:31:46,440
就是通过局部的规则向低层次展开
is expanded as low as from the local rules that you see in the procedure,

529
00:31:48,053 --> 00:31:52,573
也就是过程代表了一系列用于演进过程局部规则 #TBD
that the procedure represents a set of local rules for the expansion of this process.

530
00:31:53,360 --> 00:32:00,093

And here, the process left behind some stuff, which is the answer.

531
00:32:00,253 --> 00:32:06,266

And it was constructed by the walk it takes of the tree structure, which is the expression.

532
00:32:08,413 --> 00:32:12,613

So every part in the answer we see here derives from some part of the problem.

533
00:32:14,466 --> 00:32:17,786
比如说 现在我们考察FOO的导数
Now, we can look at, for example, the derivative of foo,

534
00:32:17,786 --> 00:32:19,653
也就是AX^2+BX+C
which is ax square plus bx plus c,

535
00:32:19,840 --> 00:32:23,053
并另令自变量 比如像这里
with respect to other things, like here, for example,

536
00:32:24,146 --> 00:32:27,480
我们令A为自变量 求FOO的导数
we can see that the derivative of foo with respect to a.

537
00:32:28,106 --> 00:32:31,773
这都非常相似 实际上 它们是同样的代数表达式
And it's very similar. It's, in fact, the identical algebraic expression,

538
00:32:32,453 --> 00:32:35,240
只是它们之中0和1的位置不一样罢了
except for the fact that theses 0's and 1's are in different places.

539
00:32:36,066 --> 00:32:38,600
# TBD 32：40
Because the only degree of freedom we have in this tree walk

540
00:32:38,973 --> 00:32:43,853
is what's constant with respect to the variable we're taking the derivative with respect to

541
00:32:44,280 --> 00:32:45,813
and what's the same variable.

542
00:32:48,266 --> 00:32:52,093
回到黑板上来再看看
In other words, if we go back to this blackboard and we look,

543
00:32:52,653 --> 00:32:57,493
我们在求和式或乘式的导数时根本没有发挥的余地
we have no choice what to do when we take the derivative of the sum or a product.

544
00:32:58,080 --> 00:33:04,480
真正可以做文章的地方 则是表达式和自变量
The only interesting place here is, is the expression the variable,

545
00:33:04,800 --> 00:33:10,106
表达式是否为关于自变量的常数 #TBD 33：11
or is the expression a constant with respect to that variable for very, very small expressions?

546
00:33:10,360 --> 00:33:14,493

In which case we get various 1's and 0's, which if we go back to this slide,

547
00:33:15,120 --> 00:33:18,160
这里就出现了“0”
we can see that the 0's that appear here, for example,

548
00:33:18,373 --> 00:33:22,746
这里是求FOO(A)的导数时得到的“1”
this 1 over here in derivative of foo with respect to A,

549
00:33:22,960 --> 00:33:24,866

which gets us an X square,

550
00:33:24,960 --> 00:33:32,533

because that 1 gets the multiply of X and X into the answer, that 1 is 0.

551
00:33:32,640 --> 00:33:34,893

Over here, we're not taking the derivative of foo with respect to c.

552
00:33:36,786 --> 00:33:39,306
但是这些表达式的轮廓是一致的
But the shapes of these expressions are the same.

553
00:33:40,546 --> 00:33:43,960
看看这些轮廓 都是相同的
See all those shapes. They're the same.

554
00:33:50,373 --> 00:33:52,280
那么 难道是我们的规则出了问题？
Well is there anything wrong with our rules?

555
00:33:53,586 --> 00:33:55,026
不 这些规则都对
No. They're the right rules.

556
00:33:56,120 --> 00:33:57,773
我们曾经遇到过这种问题
We've been through this one before.

557
00:33:58,066 --> 00:34:03,533

One of the things you're going to begin to discover is that there aren't too many good ideas.

558
00:34:06,320 --> 00:34:09,746
昨天 我们在考察有理数时
When we were looking at rational numbers yesterday,

559
00:34:12,120 --> 00:34:14,480
想要得到3/4却得到6/8
the problem was that we got 6/8 rather then 3/4.

560
00:34:14,973 --> 00:34:16,493
答案没有化简
The answer was unsimplified.

561
00:34:18,093 --> 00:34:20,906
当然 当下的问题也非常类似
The problem, of course, is very similar.

562
00:34:21,186 --> 00:34:25,413

There are things I'd like to be identical by simplification that don't become identical.

563
00:34:27,573 --> 00:34:31,893
当然 有理数加法和乘法的规则依然正确
And yet the rules for doing addition a multiplication of rational numbers were correct.

564
00:34:33,973 --> 00:34:37,413
因此这里 我们依葫芦画瓢
So the way we might solve this problem is do the thing we did last time, which always works.

565
00:34:37,786 --> 00:34:39,893
上次能行的办法 这次也没问题
If something worked last time it ought to work again.

566
00:34:40,533 --> 00:34:42,053
也就是改换一下它的表示
It's changed representation.

567
00:34:43,133 --> 00:34:46,440
或许在将其表示出来时我们可以进行
Perhaps in the representation we could put in a simplification step

568
00:34:47,880 --> 00:34:49,786
一步产生简化表示的步骤
that produces a simplified representation.

569
00:34:50,173 --> 00:34:51,733
当然啦 这也不是万用万灵
This may not always work, of course.

570
00:34:52,493 --> 00:34:54,146
我也不想证明它是万能的
I'm not trying to say that it always works.

571
00:34:55,120 --> 00:35:00,440
但这也是控制复杂度的一着妙计
But it's one of the pieces of artillery we have in our war against complexity.

572
00:35:01,466 --> 00:35:03,853
我们小心翼翼地解决这些问题
You see, because we solved our problem very carefully.

573
00:35:04,306 --> 00:35:07,200
我们所做的 就是把问题划分为几个部分
What we've done, is we've divided the world in several parts.

574
00:35:07,573 --> 00:35:08,733
分别是求导规则
There are derivatives rules

575
00:35:11,320 --> 00:35:15,800
和在这种层面上的一般代数规则
and general rules for algebra of some sort at this level of detail.

576
00:35:16,380 --> 00:35:21,226
然后就有一道抽象屏障
and i have an abstraction barrier.

577
00:35:22,480 --> 00:35:33,493
这里是代数表达式的表示——表结构
And i have the representation of the algebraic expressions, list structure.

578
00:35:37,333 --> 00:35:42,560
在这道屏障中 我定义了接口过程
And in this barrier, I have the interface procedures.

579
00:35:43,253 --> 00:35:49,826
比如 CONSTANT? SAME-VAR?
I have constant, and things like same-var.

580
00:35:54,600 --> 00:35:58,720
又比如 SUM? MAKE-SUM
I have things like sum, make-sum.

581
00:36:02,226 --> 00:36:05,573
还有 A1 A2
I have A1, A2.

582
00:36:06,600 --> 00:36:08,586
还有 PRODUCT? 之类的东西
I have products and things like that,

583
00:36:08,746 --> 00:36:11,906
我所需要的、针对各式代数表达式的东西
all the other things I might need for various kinds of algebraic expressions.

584
00:36:12,946 --> 00:36:19,146
构筑这些屏障我可以随意地改换表示法
Making this barrier allows me to arbitrarily change the representation

585
00:36:20,146 --> 00:36:23,200
而不用改变在某种表示法下编写的规则
without changing the rules that are written in terms of that representation.

586
00:36:25,040 --> 00:36:29,080
如果我能通过改变表示法来解决问题
So if I can make the problem go away by changing representation,

587
00:36:30,386 --> 00:36:34,520
那么把问题分解为两个部分则帮了我大忙
the composition of the problem into these two parts has helped me a great deal.

588
00:36:35,653 --> 00:36:37,546
好吧 举一个非常简单的例子
So let's take a very simple case of this.

589
00:36:38,826 --> 00:36:40,080
我们的问题是什么？
What was one of the problems?

590
00:36:40,266 --> 00:36:43,613
回到这张幻灯片来
Let's go back to this transparency again.

