1
00:00:00,000 --> 00:00:00,000
你们曾经在初等微积分课上学过这些法则了
You all have seen these rules in your elementary calculus class at one time or another.

2
00:00:00,000 --> 00:00:00,000
微积分中
And you know from calculus

3
00:00:00,000 --> 00:00:00,000
对多元表达式求导很容易
that it's easy to produce derivatives of arbitrary expressions.

4
00:00:00,000 --> 00:00:00,000
在微积分课上 你们也知道计算积分不容易
You also know from your elementary calculus that it's hard to produce integrals.

5
00:00:00,000 --> 00:00:00,000
虽然积分和求导相对
Yet integrals and derivatives are opposites of each other.

6
00:00:00,000 --> 00:00:00,000
它俩互为逆运算
They're inverse operations.

7
00:00:00,000 --> 00:00:00,000
但它们有同样地法则
And they have the same rules.

8
00:00:00,000 --> 00:00:00,000
但这些法则中又有什么特殊的东西
What is special about these rules that makes it possible for one

9
00:00:00,000 --> 00:00:00,000
使得求导容易 求积分就困难呢？
to produce derivatives easily and integrals why it's so hard?

10
00:00:00,000 --> 00:00:00,000
我们浅显地想一想
Let's think about that very simply.

11
00:00:00,000 --> 00:00:00,000
仔细考察这些法则
Look at these rules.

12
00:00:00,000 --> 00:00:00,000
对于每条法则来说 你求导数时的方向
Every one of these rules, when used in the direction for taking derivatives,

13
00:00:00,000 --> 00:00:00,000
这个箭头的方向
which is in the direction of this arrow,

14
00:00:00,000 --> 00:00:00,000
法则的左边与你的表达式相匹配
the left side is matched against your expression,

15
00:00:00,000 --> 00:00:00,000
法则的右边就是表达式的导数
and the right side is the thing which is the derivative of that expression.

16
00:00:00,000 --> 00:00:00,000
箭头是这个方向的
The arrow is going that way.

17
00:00:00,000 --> 00:00:00,000
每条法则中
In each of these rules,

18
00:00:00,000 --> 00:00:00,000
法则右边的表达式
the expressions on the right-hand side of the rule

19
00:00:00,000 --> 00:00:00,000
都是求导过程中的子表达式
that are contained within derivatives are subexpressions,

20
00:00:00,000 --> 00:00:00,000
都是左边式子的合法的子表达式 #TBD
are proper subexpressions, of the expression on the left-hand side.

21
00:00:00,000 --> 00:00:00,000
这里 我们发现 和的导数
So here we see the derivative of the sum,

22
00:00:00,000 --> 00:00:00,000
也就是左边式子的导数
witch is the expression on the left-hand side

23
00:00:00,000 --> 00:00:00,000
就是两部分之和
is the sum of the derivatives of the pieces.

24
00:00:00,000 --> 00:00:00,000
法则从左至右的方向是“归约式规则”
So the rule of moving to the right are reduction rules.

25
00:00:00,000 --> 00:00:00,000
问题就变简单了
The problem becomes easier.

26
00:00:00,000 --> 00:00:00,000
我把一个复杂的问题 转化成了许多小点儿的问题
I turn a big complicated problem it's lots of smaller problems

27
00:00:00,000 --> 00:00:00,000
然后把结果组合起来 用递归的方法完美地解决了
and then combine the results, a perfect place for recursion to work.

28
00:00:00,000 --> 00:00:00,000
但如果我从另外的方向来思考
If I'm going in the other direction like this,

29
00:00:00,000 --> 00:00:00,000
如果我想求积分的话 你会发现有很多问题
if I'm trying to produce integrals, well there are several problems you see here.

30
00:00:00,000 --> 00:00:00,000
就比如 如果我想求一个和的积分
First of all, if I try to integrate an expression like a sum,

31
00:00:00,000 --> 00:00:00,000
就会有多条法则符合
more than one rule matches.

32
00:00:00,000 --> 00:00:00,000
这条符合
Here's one that matches.

33
00:00:00,000 --> 00:00:00,000
这条也符合
Here's one that matches.

34
00:00:00,000 --> 00:00:00,000
我不知道该用哪个——它们之间可能不一样
I don't know which one to take. And they may be different.

35
00:00:00,000 --> 00:00:00,000
我得考察两者的不同之处
I may get to explore different things.

36
00:00:00,000 --> 00:00:00,000
所以 在这个方向上 表达式变复杂了
Also, the expressions become larger in that direction.

37
00:00:00,000 --> 00:00:00,000
当表达式变复杂时
And when the expressions become larger,

38
00:00:00,000 --> 00:00:00,000
就没法保证我所选的路径一定能终止了
then there's no guarantee that any particular path I choose will terminate,

39
00:00:00,000 --> 00:00:00,000
因为唯一的可能是偶然的约分
because we will only terminate by accidental cancellation.

40
00:00:00,000 --> 00:00:00,000
这也就是为什么 积分是一种复杂的搜索 而难以完成
So that's why integrals are complicated searches and hard to do.

41
00:00:00,000 --> 00:00:00,000
现在我不想处理这么复杂的东西
Right now I don't want to do anything as hard as that.

42
00:00:00,000 --> 00:00:00,000
我们先来讨论求导数
Let's work on derivatives for a while.

43
00:00:00,000 --> 00:00:00,000
好吧 我就假设你们都了解这些法则了
Well, these rules are ones you know for the most part hopefully.

44
00:00:00,000 --> 00:00:00,000
让我们来看看能不能用程序表达这些法则
So let's see if we can write a program which is these rules.

45
00:00:00,000 --> 00:00:00,000
这应该很容易
And that should be very easy.

46
00:00:00,000 --> 00:00:00,000
信手拈来
Just write the program.

47
00:00:00,000 --> 00:00:00,000
因为 我给你们展示的是“归约式规则”
See, because while I showed you is that it's a reduction rule,

48
00:00:00,000 --> 00:00:00,000
这样用递归来编写会比较合适
it's something appropriate for a recursion.

49
00:00:00,000 --> 00:00:00,000
当然 对每条法则来说就是一种情况
And, of course, what we have for each of these rules is we have a case

50
00:00:00,000 --> 00:00:00,000
我们做“分情况分析”
in some case analysis.

51
00:00:00,000 --> 00:00:00,000
我就这么写了
So I'm just going to write this program down.

52
00:00:00,000 --> 00:00:00,000
当然 我得先让你们认识到点什么 对吧？
Now, of course, I'm going to be saying something you have to believe. Right?

53
00:00:00,000 --> 00:00:00,000
我希望你们认识到我可以表示这些代数式
What you have to believe is I can represent these algebraic expressions,

54
00:00:00,000 --> 00:00:00,000
我可以从中抽取式子 也可以将它们组合起来
that I can grab their parts, that I can put them together.

55
00:00:00,000 --> 00:00:00,000
我们发明了表结构来解决这个问题
We've invented list structures so that you can do that.

56
00:00:00,000 --> 00:00:00,000
但现在我们不必关心
But you don't want to worry about that now.

57
00:00:00,000 --> 00:00:00,000
现在 我要编写一个程序来封装这些法则
Right now I'm going to write the program that encapsulates these rules

58
00:00:00,000 --> 00:00:00,000
使它独立于代数表达式的表示法
independent of the representation of the algebraic expressions.

59
00:00:00,000 --> 00:00:00,000
(DERIV EXP VAR)表示表达式EXP对于变量VAR的导数
You have a derivative of an expression with respect to a variable.

60
00:00:00,000 --> 00:00:00,000
这和函数的导数是不一样的
This is a different thing than the derivative of the function.

61
00:00:00,000 --> 00:00:00,000
那个是我们上节课看到的数值近似
That's what we saw last time, that numerical approximation.

62
00:00:00,000 --> 00:00:00,000
这是由于你无法看到函数内部
It's something you can't open up a function.

63
00:00:00,000 --> 00:00:00,000
这只是一个数值
It's just the answers.

64
00:00:00,000 --> 00:00:00,000
表达式的导数与它的书写别无二致
The derivative of an expression is the way it's written.

65
00:00:00,000 --> 00:00:00,000
因此 这只是一个语法问题
And therefore it's a syntactic phenomenon.

66
00:00:00,000 --> 00:00:00,000
我们今天要做的大多数工作 就是讨论语法
And so a lot of what we're going to be doing today is worrying about syntax,

67
00:00:00,000 --> 00:00:00,000
表达式的语法或类似
syntax of expressions and things like that.

68
00:00:00,000 --> 00:00:00,000
这有一个CASE语句
Well, there's a case analysis.

69
00:00:00,000 --> 00:00:00,000
任何时候我们处理复杂事物都是通过递归
Anytime we do anything complicated thereby a recursion,

70
00:00:00,000 --> 00:00:00,000
我们很可能需要“按情况分析”
we presumably need a case analysis.

71
00:00:00,000 --> 00:00:00,000
通常都是这样开始的
It's the essential way to begin.

72
00:00:00,000 --> 00:00:00,000
大一点的问题都是用“按情况分析” #TBD
And that's usually a conditional of some large kind.

73
00:00:00,000 --> 00:00:00,000
那么 有哪些可能（的情况）呢？
Well, what are their possibilities?

74
00:00:00,000 --> 00:00:00,000
第一条法则说 如果你遇到一个常数
the first rule that you saw is this something a constant?

75
00:00:00,000 --> 00:00:00,000
这里 我就是在判断
And what I'm asking is,

76
00:00:00,000 --> 00:00:00,000
表达式EXP是否是关于给定变量VAR的常数
is the expression a constant with respect to the variable given?

77
00:00:00,000 --> 00:00:00,000
如果是的话 结果就是0
If so, the result is 0,

78
00:00:00,000 --> 00:00:00,000
因为导数表征的是某物的变化率
because the derivative represents the rate of change of something.

79
00:00:00,000 --> 00:00:00,000
然而
If, however,

80
00:00:00,000 --> 00:00:00,000
如果我求导的表达式 与我关心的变量有关
the expression that I'm taking the derivative of is the variable I'm varying,

81
00:00:00,000 --> 00:00:00,000
如果判定表达式和变量相同
then this is the same variable, the expression var,

82
00:00:00,000 --> 00:00:00,000
那么关于变量VAR的表达式EXP的变化率就是1
then the rate of change of the expression with respect to the variable is 1.

83
00:00:00,000 --> 00:00:00,000
它俩相同 结果是1
It's the same 1.

84
00:00:00,000 --> 00:00:00,000
当然 还可能有其它的可能性
Well now there are a couple of other possibilities.

85
00:00:00,000 --> 00:00:00,000
比如说 它可能是一个和式
It could, for example, be a sum.

86
00:00:00,000 --> 00:00:00,000
呃 我现在还完全知道该如何表示和式
Well, I don't know how I'm going to express sums yet.

87
00:00:00,000 --> 00:00:00,000
事实上 我可以
Actually I do.

88
00:00:00,000 --> 00:00:00,000
只是我还没有告诉你们
But I haven't told you yet.

89
00:00:00,000 --> 00:00:00,000
如果表达式是一个和式
But is it a sum?

90
00:00:00,000 --> 00:00:00,000
我就假想有一种方式可以判别（和式）
I'm imagining that there's some way of telling.

91
00:00:00,000 --> 00:00:00,000
我将在这里做一个表达式的类型分配
I'm doing a dispatch on the type of the expression here,

92
00:00:00,000 --> 00:00:00,000
这是在构建语言时绝对必要的
absolutely essential in building languages.

93
00:00:00,000 --> 00:00:00,000
语言由不同的表达式构成
Languages are made out of different expressions.

94
00:00:00,000 --> 00:00:00,000
不就我们就将看到
And soon we're going to see that

95
00:00:00,000 --> 00:00:00,000
如何用更强大的方法 用语言去构建语言
in our more powerful methods of building languages on languages.

96
00:00:00,000 --> 00:00:00,000
表达式是和式吗？
Is an expression a sum?

97
00:00:00,000 --> 00:00:00,000
如果是的话 很好 我们已经知道和式的求导法则了
If it's a sum, well, we know the rule for derivative of the sum

98
00:00:00,000 --> 00:00:00,000
即是各部分导数之和
is the sum of the derivatives of the parts.

99
00:00:00,000 --> 00:00:00,000
其中一个叫做加数 另一个叫做被加数
One of them is called the addend and the other is the augend.

100
00:00:00,000 --> 00:00:00,000
黑板上没那么多空间写这么长的名字了
But I don't have enough space on the blackboard to such long names.

101
00:00:00,000 --> 00:00:00,000
我就姑且把它们叫做 A1和A2
So I'll call them A1 and A2.

102
00:00:00,000 --> 00:00:00,000
将它们求和
I want to make a sum.

103
00:00:00,000 --> 00:00:00,000
10 ：01
Do you remember which is the sum for end or the menu end?

104
00:00:00,000 --> 00:00:00,000

Or was it the dividend and the divisor or something like that?

105
00:00:00,000 --> 00:00:00,000
将A1的导数...
Make sum of the derivative of the A1, I'll call it.

106
00:00:00,000 --> 00:00:00,000
这是关于VAR的表达式的加数
It's the addend of the expression with respect to the variable,

107
00:00:00,000 --> 00:00:00,000
与A2的导数相加
and the derivative of the A2 of the expression,

108
00:00:00,000 --> 00:00:00,000

because the two arguments, the addition with respect to the variable.

109
00:00:00,000 --> 00:00:00,000
我们知道还有一条乘法的求导法则
And another rule that we know is product rule,

110
00:00:00,000 --> 00:00:00,000
也就是说 如果表达式是积式
which is, if the expression is a product.

111
00:00:00,000 --> 00:00:00,000
顺便说下 当你定义过程时 有个好习惯
By the way, it's a good idea when you're defining things,

112
00:00:00,000 --> 00:00:00,000
就是在定义谓词时
when you're defining predicates,

113
00:00:00,000 --> 00:00:00,000
将谓词名以问号结尾
to give them a name that ends in a question mark.

114
00:00:00,000 --> 00:00:00,000
问号本身不代表什么
This question mark doesn't mean anything.

115
00:00:00,000 --> 00:00:00,000
但这是俗成的约定
It's for us as an agreement.

116
00:00:00,000 --> 00:00:00,000
这是人们之间约定的接口 以方便他人阅读你的脚本
It's a conventional interface between humans so you can read my programs more easily.

117
00:00:00,000 --> 00:00:00,000
我希望你在写程序的时候
So I want you to, when you write programs,

118
00:00:00,000 --> 00:00:00,000
当你定义谓词的时候
if you define a predicate procedure,

119
00:00:00,000 --> 00:00:00,000
就是那些返回TRUE或FALSE的过程
that's something that returns true of false,

120
00:00:00,000 --> 00:00:00,000
你应该使它们的名字以问号结尾
it should have a name which ends in question mark.

121
00:00:00,000 --> 00:00:00,000
这对Lisp无异 但对人类友好
The lisp doesn't care. I care.

122
00:00:00,000 --> 00:00:00,000
我需要求和
I want to make a sum.

123
00:00:00,000 --> 00:00:00,000
因为积的导数就是...
Because the derivative of a product is the sum

124
00:00:00,000 --> 00:00:00,000
被乘数乘以乘数的导数
of the first times the derivative of the second plus

125
00:00:00,000 --> 00:00:00,000
加上乘数乘以被乘数的导数
the second times the derivative of the first.

126
00:00:00,000 --> 00:00:00,000
两者加起来
Make a sum of two things,

127
00:00:00,000 --> 00:00:00,000
求积... 呃 就用表达式中的M1来表示（被乘数）好了
a product of, well, I'm going to say the M1 of the expression,

128
00:00:00,000 --> 00:00:00,000
表达式中M2关于变量VAR的导数
and the derivative of the M2 of the expression with respect to the variable,

129
00:00:00,000 --> 00:00:00,000
以及 M1的导数乘以
and the product of the derivative of M1,

130
00:00:00,000 --> 00:00:00,000
M1是这里的被乘数
the multiplier of the expression, with respect to the variable.

131
00:00:00,000 --> 00:00:00,000
12:17
It's the product of that and the multiplicand, M2, of the expression.

132
00:00:00,000 --> 00:00:00,000
Make that product. Make the sum. Close that case.

133
00:00:00,000 --> 00:00:00,000
And, of course, I could add as many cases as I like here

134
00:00:00,000 --> 00:00:00,000
for a complete set of rules you might find in a calculus book.

135
00:00:00,000 --> 00:00:00,000
So this is what it takes to encapsulate those rules.

136
00:00:00,000 --> 00:00:00,000
And you see, you have to realize there's a lot of wishful thinking here.

137
00:00:00,000 --> 00:00:00,000
I haven't told you anything about how I'm going to make these representations.

138
00:00:00,000 --> 00:00:00,000
Now, once I've decided that this is my set of rules,

139
00:00:00,000 --> 00:00:00,000
I think it's time to play with the representation.

140
00:00:00,000 --> 00:00:00,000
Let's attack that.

141
00:00:00,000 --> 00:00:00,000
Well, first of all, I'm going to play a pun.

142
00:00:00,000 --> 00:00:00,000
It's an important pun.

143
00:00:00,000 --> 00:00:00,000
It's a key to a sort of powerful idea.

144
00:00:00,000 --> 00:00:00,000
If I want to represent sums, and products, and differences, and quotients,

145
00:00:00,000 --> 00:00:00,000
and things like that,

146
00:00:00,000 --> 00:00:00,000
why not use the same language as I'm writing my program in?

147
00:00:00,000 --> 00:00:00,000
I write my program in algebraic expressions that look like

148
00:00:00,000 --> 00:00:00,000
the sum of the product on a and the product of x and x,

149
00:00:00,000 --> 00:00:00,000
and things like that.

150
00:00:00,000 --> 00:00:00,000
And the product of b and x and c, whatever,

151
00:00:00,000 --> 00:00:00,000
make that a sum of the product.

152
00:00:00,000 --> 00:00:00,000
Right now I don't want to have procedures with unknown numbers of arguments,

153
00:00:00,000 --> 00:00:00,000
a product of b and x and c.

154
00:00:00,000 --> 00:00:00,000
This is list structure.

155
00:00:00,000 --> 00:00:00,000
And the reason why this is nice,

156
00:00:00,000 --> 00:00:00,000
is because any one of these objects has a property.

157
00:00:00,000 --> 00:00:00,000
I know where the car is.

158
00:00:00,000 --> 00:00:00,000
The car is the operator.

159
00:00:00,000 --> 00:00:00,000
And the operands are the successive cdrs

160
00:00:00,000 --> 00:00:00,000
the successive cars of the cdrs of the list that this is.

161
00:00:00,000 --> 00:00:00,000
It makes it very convenient.

162
00:00:00,000 --> 00:00:00,000
I have to parse it. It's been done for me.

163
00:00:00,000 --> 00:00:00,000
I'm using the embedding and Lisp to advantage.

164
00:00:00,000 --> 00:00:00,000
So, for example,

165
00:00:00,000 --> 00:00:00,000
let's start using list structure to write down the representation

166
00:00:00,000 --> 00:00:00,000
that I'm implicitly assuming here.

167
00:00:00,000 --> 00:00:00,000
Well I have to define various things that are implied in this representation.

168
00:00:00,000 --> 00:00:00,000
Like I have to find out how to do a constant,

169
00:00:00,000 --> 00:00:00,000
how you do same variable.

170
00:00:00,000 --> 00:00:00,000
Let's do those first. That's pretty easy enough.

171
00:00:00,000 --> 00:00:00,000
Now I'm going to be introducing lots of primitives here,

172
00:00:00,000 --> 00:00:00,000
because these are the primitives that come with list structure.

173
00:00:00,000 --> 00:00:00,000
OK, you define a constant.

174
00:00:00,000 --> 00:00:00,000
And what I mean by a constant,

175
00:00:00,000 --> 00:00:00,000
an expression that's constant with respect to a veritable,

176
00:00:00,000 --> 00:00:00,000
is that the expression is something simple.

177
00:00:00,000 --> 00:00:00,000
I can't take it into pieces,

178
00:00:00,000 --> 00:00:00,000
and yet it isn't that variable.

179
00:00:00,000 --> 00:00:00,000
I can't break it up, and yet it isn't that variable.

180
00:00:00,000 --> 00:00:00,000
That does not mean that there may be other expressions

181
00:00:00,000 --> 00:00:00,000
that are more complicated that are constants.

182
00:00:00,000 --> 00:00:00,000
It's just that I'm going to look at the primitive constants in this way.

183
00:00:00,000 --> 00:00:00,000
So what this is, is it says that's it's the and.

184
00:00:00,000 --> 00:00:00,000
I can combine predicate expressions which return true or false with and.

185
00:00:00,000 --> 00:00:00,000
Something atomic, The expression is atomic,

186
00:00:00,000 --> 00:00:00,000
meaning it cannot be broken into parts.

187
00:00:00,000 --> 00:00:00,000
It doesn't have a car and a cdr.

188
00:00:00,000 --> 00:00:00,000
It's not a list.

189
00:00:00,000 --> 00:00:00,000
It adds a special test built into the system.

190
00:00:00,000 --> 00:00:00,000
And it's not identically equal to that variable.

191
00:00:00,000 --> 00:00:00,000
I'm representing my variables by things that are symbols which cannot be broken into pieces,

192
00:00:00,000 --> 00:00:00,000
things like x, and y, things like this.

193
00:00:00,000 --> 00:00:00,000
Whereas, of course, something like this can be broken up into pieces.

194
00:00:00,000 --> 00:00:00,000
And the same variable of an expression with respect to a variable is,

195
00:00:00,000 --> 00:00:00,000
in fact, an atomic expression.

196
00:00:00,000 --> 00:00:00,000
I want to have an atomic expression, which is identical.

197
00:00:00,000 --> 00:00:00,000
I don't want to look inside this stuff anymore.

198
00:00:00,000 --> 00:00:00,000
These are primitive maybe.

199
00:00:00,000 --> 00:00:00,000
But it doesn't matter.

200
00:00:00,000 --> 00:00:00,000
I'm using things that are given to me with a language.

201
00:00:00,000 --> 00:00:00,000
I'm not terribly interest in them.

202
00:00:00,000 --> 00:00:00,000
Now how do we deal with sums?

203
00:00:00,000 --> 00:00:00,000
Ah, something very interesting will happen.

204
00:00:00,000 --> 00:00:00,000
A sum is something which is not atomic and begins with the plus symbol.

205
00:00:00,000 --> 00:00:00,000
That's what it means.

206
00:00:00,000 --> 00:00:00,000
So here, I will define.

207
00:00:00,000 --> 00:00:00,000
An question is a sum if and it's not atomic

208
00:00:00,000 --> 00:00:00,000
and it's head, it's beginning,

209
00:00:00,000 --> 00:00:00,000
its car of the expression is the symbol plus.

210
00:00:00,000 --> 00:00:00,000
Now you're about to see something you haven't seen before, this quotation.

211
00:00:00,000 --> 00:00:00,000

Why do I have that quotation there?

212
00:00:00,000 --> 00:00:00,000
说你的名字
Say your name,

213
00:00:00,000 --> 00:00:00,000
观众：Susanna
AUDIENCE: Susanna.

214
00:00:00,000 --> 00:00:00,000
教授：大点声儿
PROFESSOR: Louder.

215
00:00:00,000 --> 00:00:00,000
观众：Susanna
AUDIENCE: Susanna

216
00:00:00,000 --> 00:00:00,000
教授：说“你的名字”
PROFESSOR: Say your name.

217
00:00:00,000 --> 00:00:00,000
观众：“你的名字”
AUDIENCE: Your name.

218
00:00:00,000 --> 00:00:00,000
教授：大点声儿
PROFESSOR: Louder.

219
00:00:00,000 --> 00:00:00,000
观众：“你的名字”
AUDIENCE: Your name.

220
00:00:00,000 --> 00:00:00,000
教授：对了
PROFESSOR: OK.

221
00:00:00,000 --> 00:00:00,000
我想在这里告诉你英语词汇是有歧义的
What I'm showing you here is that the words of English are ambiguous.

222
00:00:00,000 --> 00:00:00,000
我可能说 “说你的名字”
I was saying, say your name.

223
00:00:00,000 --> 00:00:00,000
我也可能说 “说‘你的名字’”
I was also possibly saying say, your name.

224
00:00:00,000 --> 00:00:00,000
光从说话上还无法辨别
But that cannot be distinguished in speech.

225
00:00:00,000 --> 00:00:00,000
然而我们在书写时却有专门的符号——引号
However, we do have a notation in writing,

226
00:00:00,000 --> 00:00:00,000
用来区别这两种可能的意思
which is quotation for distinguishing these two possible meanings.

227
00:00:00,000 --> 00:00:00,000
具体来说 这里
In particular, over here,

228
00:00:00,000 --> 00:00:00,000
在Lisp中有用于区别这些语义的符号
in Lisp we have a notation for distinguishing these meanings.

229
00:00:00,000 --> 00:00:00,000
如果我只是想写下一个加号——作为符号的加号
If I were to just write a plus here, a plus symbol,

230
00:00:00,000 --> 00:00:00,000
我会问系统 表达式的首元素
I would be asking, is the first element of the expression,

231
00:00:00,000 --> 00:00:00,000
也就是表达式的运算符 是加运算符么？
is the operator position of the expression, the addition operator?

232
00:00:00,000 --> 00:00:00,000
我并不知道
I don't know.

233
00:00:00,000 --> 00:00:00,000
我本应该在那里写一个加运算符的
I would have to have written the addition operator there,

234
00:00:00,000 --> 00:00:00,000
但我无法那样做
which I can't write.

235
00:00:00,000 --> 00:00:00,000
而这种方式则是问 这个符号对象是否为
However, this way I'm asking, is this the symbolic object plus,

236
00:00:00,000 --> 00:00:00,000
代表加运算符的加号符号
which normally stands for the addition operator?

237
00:00:00,000 --> 00:00:00,000
这才是我想要问和知道的问题
That's what I want. That's the question I want to ask.

238
00:00:00,000 --> 00:00:00,000
才我们深入讨论之前
Now before I go any further,

239
00:00:00,000 --> 00:00:00,000
我想要指出 “引用”是一个复杂的概念
I want to point out the quotation is a very complex concept,

240
00:00:00,000 --> 00:00:00,000
语言中引入这个概念将会造成许多麻烦
and adding it to a language causes a great deal of troubles.

241
00:00:00,000 --> 00:00:00,000
看看下面这张幻灯片
Consider the next slide.

242
00:00:00,000 --> 00:00:00,000
这里这个推论没有问题
Here's a deduction which we should all agree with.

243
00:00:00,000 --> 00:00:00,000
这是说 Alyssa聪明而Alyssa是George的母亲
We have, Alyssa is smart and Alyssa is George's mother.

244
00:00:00,000 --> 00:00:00,000
这是一个等式
This is an equality, is.

245
00:00:00,000 --> 00:00:00,000
从这两个陈述 我们可以推论George的母亲很聪明
From those two, we can deduce that George's mother is smart.

246
00:00:00,000 --> 00:00:00,000
这是因为我们可以在表达式中等价替换
Because we can always substitute equals for equals in expressions.

247
00:00:00,000 --> 00:00:00,000
真是这样吗？
Or can we?

248
00:00:00,000 --> 00:00:00,000
这个例子说 “Chicago”有七个字母
Here's a case where we have "Chicago" has seven letters.

249
00:00:00,000 --> 00:00:00,000
引用则是强调我讨论的是单词“Chicago”
The quotation means that I'm discussing the word Chicago,

250
00:00:00,000 --> 00:00:00,000
而不是单词所代表的意思
not what the word represents.

251
00:00:00,000 --> 00:00:00,000
这里说 Chicago是Illinois（州）最大的城市
Here I have that Chicago is the biggest city in Illinois.

252
00:00:00,000 --> 00:00:00,000
而（等价代换的）结果是……
As a consequence of this,

253
00:00:00,000 --> 00:00:00,000
我可能会得到 Illinois（州）最大的城市有七个字母
I would like to deduce that the biggest city in Illinois has seven letters.

254
00:00:00,000 --> 00:00:00,000
这显然是错的
But that's manifestly false.

255
00:00:00,000 --> 00:00:00,000
喔！这玩意儿好使了
Wow, it works.

256
00:00:00,000 --> 00:00:00,000
所以 一旦我们有了（引用）这样的东西
OK, so once we have things like that,

257
00:00:00,000 --> 00:00:00,000
我们的语言就会变得复杂
our language gets much more complicated.

258
00:00:00,000 --> 00:00:00,000
因为我们对于语言的一些操作
Because it's no longer true that things we tend to like to do with languages,

259
00:00:00,000 --> 00:00:00,000
比如通过等价代换来得到正确答案
like substituting equals for equals and getting right answers,

260
00:00:00,000 --> 00:00:00,000
如果不小心地操作就会出错
are going to work without being very careful.

261
00:00:00,000 --> 00:00:00,000
#TBD
We can't substitute into what's called referentially opaque contexts,

262
00:00:00,000 --> 00:00:00,000
of which a quotation is the prototypical type of referentially opaque context.

263
00:00:00,000 --> 00:00:00,000
如果你知道那是什么意思……你可以成为一位哲学家
If you know what that means, you can consult a philosopher.

264
00:00:00,000 --> 00:00:00,000
或许我们之中就有一位
Presumably there is one in the room.

265
00:00:00,000 --> 00:00:00,000
言归正传 我们继续
In any case, let's continue now,

266
00:00:00,000 --> 00:00:00,000
现在我们对一个有2000年历史的问题至少有了操作上的理解
now that we at least have an operational understanding of a 2000-year-old issue

267
00:00:00,000 --> 00:00:00,000
#TBD
that has to do with name, and mention, and all sorts of things like that.

268
00:00:00,000 --> 00:00:00,000
我得定义如何把两个数加起来 (DEFINE (MAKE-SUM A1 A2))
I have to define what I mean, how to make a sum of two things, an a1 and a2.

269
00:00:00,000 --> 00:00:00,000
我简单实现一下
And I'm going to do this very simply.

270
00:00:00,000 --> 00:00:00,000
这是一个由符号加、A1、A2构成的列表
It's a list of the symbol plus, and a1, and a2.

271
00:00:00,000 --> 00:00:00,000
我可以决定如何取出第一个元素
And I can determine the first element.

272
00:00:00,000 --> 00:00:00,000
(DEFINE A1 CADR)
Define a1 to be cadr.

273
00:00:00,000 --> 00:00:00,000
这里又给大家介绍了一个基本过程
I've just introduced another primitive.

274
00:00:00,000 --> 00:00:00,000
这个是取出某物CDR部分的CAR部分
This is the car of the cdr of something.

275
00:00:00,000 --> 00:00:00,000
你或许好奇于这些基本过程为什么叫做CAR和CDR
You might want to know why car and cdr are names of these primitives,

276
00:00:00,000 --> 00:00:00,000
而且传承了下来 尽管叫做LEFT和RIGHT会好一点
and why they've survived, even though they're much better ideas like left and right.

277
00:00:00,000 --> 00:00:00,000
我们本可以那样叫的
We could have called them things like that.

278
00:00:00,000 --> 00:00:00,000
呃 其实 这个名字来自于很久以前
Well, first of all, the names come from the fact that in the great past,

279
00:00:00,000 --> 00:00:00,000
当发明Lisp时
when Lisp was invented,

280
00:00:00,000 --> 00:00:00,000
我想大概是58年的样子 是在类似于704之类的机子上实现的
I suppose in '58 or something, it was on a 704 or something like that,

281
00:00:00,000 --> 00:00:00,000
这个机器有个地址寄存器和减量寄存器
which had a machine. It was a machine that had an address register and a decrement register.

282
00:00:00,000 --> 00:00:00,000
而这些就是地址寄存器和减量寄存器的值
And these were the contents of the address register and the decrement register.

283
00:00:00,000 --> 00:00:00,000
所以这是有历史遗留原因的
So it's an historical accident.

284
00:00:00,000 --> 00:00:00,000
但是这些名字为什么又延续下来了呢？
Now why have these names survived?

285
00:00:00,000 --> 00:00:00,000
这是因为Lisp程序员喜欢用电话交流
It's because Lisp programmers like to talk to each other over the phone.

286
00:00:00,000 --> 00:00:00,000
要是你有一长串的CAR和CDR序列 你就可能说“CDADDEDR”
And if you want to have a long sequence of cars and cdrs you might say, cdaddedr,

287
00:00:00,000 --> 00:00:00,000
这是可以理解的
which can be understood.

288
00:00:00,000 --> 00:00:00,000
但是左边的右边的右边的左边就不是那么清楚了
But left of right or right of left is not so clear if you get good at it.

289
00:00:00,000 --> 00:00:00,000
这就是我们为什么有这些术语
So that's why we have these words.

290
00:00:00,000 --> 00:00:00,000
Lisp系统中默认定义到第四层
All of them up to four deep are defined typically in a Lisp system.

291
00:00:00,000 --> 00:00:00,000
而定义A2为……当然 如果我们考察这些表达式中的一个
A2 to be-- and, of course, you can see that if I looked at one of these expressions

292
00:00:00,000 --> 00:00:00,000
比如(+ 3 5)
like the sum of 3 and 5,

293
00:00:00,000 --> 00:00:00,000
这个实际上是一个包含有符号加、数3和数5的列表
what that is is a list containing the symbol plus, and a number 3, and a number 5.

294
00:00:00,000 --> 00:00:00,000
它（列表）的CAR部分是符号加
Then the car is the symbol plus.

295
00:00:00,000 --> 00:00:00,000
CDR部分的CAR部分
The car of the cdr.

296
00:00:00,000 --> 00:00:00,000
也就是先取CDR部分 然后再取CAR部分
Well I take the cdr and then I take the car.

297
00:00:00,000 --> 00:00:00,000
这就是我如何取得3的 也就是第一个参数
And that's how I get to the 3. That's the first argument.

298
00:00:00,000 --> 00:00:00,000
CDR的CDR部分的CAR部分 就是这个……数5
And the car of the cdr of the cdr gets me to this one, the 5.

299
00:00:00,000 --> 00:00:00,000
当然 类似地 我可以这样定义乘法
And similarly, of course, I can define what's going on with products.

300
00:00:00,000 --> 00:00:00,000
我快速地演示一下
Let's do that very quickly.

301
00:00:00,000 --> 00:00:00,000
(DEFINE (PRODUCT? EXP))
Is the expression a product?

302
00:00:00,000 --> 00:00:00,000
如果它不是原子的 而且
Yes if and if it's true, that's it's not atomic

303
00:00:00,000 --> 00:00:00,000
EXP的CAR部分与用于表示乘法的符号*在 EQ?的语义下相等
and it's EQ quote, the asterisk symbol, which is the operator for multiplication.

304
00:00:00,000 --> 00:00:00,000
(DEFINE (MAKE-PRODUCT M1 M2))
Make product of an M1 and an M2 to be list,

305
00:00:00,000 --> 00:00:00,000
(LIST '* M1 M2)
quote, the asterisk operation and M1 and M2.

306
00:00:00,000 --> 00:00:00,000
并定义M1为CADR M2为CADDR
And I define M1 to be cadr and M2 to be caddr.

307
00:00:00,000 --> 00:00:00,000
你越按照行话说 你就越入行
You get to be a good Lisp programmer because you start talking that way.

308
00:00:00,000 --> 00:00:00,000
# TBD
I cdr down lists and console them up and so on.

309
00:00:00,000 --> 00:00:00,000
现在 我们有了原理上完整的求导程序了
Now, now that we have essentially a complete program for finding derivatives,

310
00:00:00,000 --> 00:00:00,000
如果需要的话 你也可以添加更多的规则
you can add more rules if you like.

311
00:00:00,000 --> 00:00:00,000
我们期望它如何运作呢？
What kind of behavior do we get out of it?

312
00:00:00,000 --> 00:00:00,000
#TBD
I'll have to clear that x.

313
00:00:00,000 --> 00:00:00,000
恩 假设我在这里定义FOO为
Well, supposing I define foo here

314
00:00:00,000 --> 00:00:00,000
定义FOO为a*x^2 + b*x + c
to be the sum of the product of ax square and bx plus c.

315
00:00:00,000 --> 00:00:00,000
跟我们这里看到的是一样的
That's the same thing we see here

316
00:00:00,000 --> 00:00:00,000
这里是用更习见的记号书写的代数表达式
as the algebraic expression written in the more conventional notation over there.

317
00:00:00,000 --> 00:00:00,000
那么 关于X的表达式FOO的导数 结果在这里
Well, the derivative of foo with respect to x, which we can see over here,

318
00:00:00,000 --> 00:00:00,000
真是乱得一团糟
is this horrible, horrendous mess.

319
00:00:00,000 --> 00:00:00,000
我期望答案是2*a*x + b
I would like it to be 2ax plus b.

320
00:00:00,000 --> 00:00:00,000
虽然与结果等价 但它并不是我们希望的结果
But it's not. It's equivalent to it.

321
00:00:00,000 --> 00:00:00,000
这是什么呢？
What is it?

322
00:00:00,000 --> 00:00:00,000
我们最初有什么？
I have here, what do I have?

323
00:00:00,000 --> 00:00:00,000
我求 x * x 的导数
I have the derivative of the product of x and x.

324
00:00:00,000 --> 00:00:00,000
答案是 x*1 + 1*x 当然这没错
Over here is, of course, the sum of x times 1 and 1 times x.

325
00:00:00,000 --> 00:00:00,000
现在
Now, well, it's the first times the derivative of the second plus the second times the derivative of the first.

326
00:00:00,000 --> 00:00:00,000
这是对的
It's right.

327
00:00:00,000 --> 00:00:00,000
#TBD
That's 2x of course. a times 2x is 2ax plus 0X square doesn't count plus B over here plus a bunch of 0's.

328
00:00:00,000 --> 00:00:00,000
Well the answer is right.

329
00:00:00,000 --> 00:00:00,000

But I give people take off points on an exam for that, sadly enough.

330
00:00:00,000 --> 00:00:00,000
我们在下一节再考虑这个内容
Let's worry about that in the next segment.

331
00:00:00,000 --> 00:00:00,000
有疑问吗？
Are there any questions?

332
00:00:00,000 --> 00:00:00,000
请说
Yes?

333
00:00:00,000 --> 00:00:00,000
观众：
AUDIENCE: If you had left the quote when you put the plus,

334
00:00:00,000 --> 00:00:00,000
then would that be referring to the procedure plus

335
00:00:00,000 --> 00:00:00,000
and could you do a comparison between that procedure and some other procedure if you wanted to?

336
00:00:00,000 --> 00:00:00,000
教授：问得好！
PROFESSOR: Yes. Good question.

337
00:00:00,000 --> 00:00:00,000
如果我用左引号将这个引住
If I had left this quotation off at this point,

338
00:00:00,000 --> 00:00:00,000
然后再用左引号那那个引住
if I had left that quotation off at that point,

339
00:00:00,000 --> 00:00:00,000
then I would be referring here to the procedure which is the thing that plus is defined to be.

340
00:00:00,000 --> 00:00:00,000

And indeed, I could compare some procedures with each other for identity.

341
00:00:00,000 --> 00:00:00,000
现在很难从语义上解释
Now what that means is not clear right now.

342
00:00:00,000 --> 00:00:00,000
我现在不想考虑这个问题
I don't like to think about it.

343
00:00:00,000 --> 00:00:00,000
因为我不知道比较过程究竟意味着什么
Because I don't know exactly what it would need to compare procedures.

344
00:00:00,000 --> 00:00:00,000
这样做没有意义是有很多原因的
There are reasons why that may make no sense at all.

345
00:00:00,000 --> 00:00:00,000
然而 这些符号我们是可以理解的
However, the symbols, we understand.

346
00:00:00,000 --> 00:00:00,000
这也是我为什么我要将它们引住
And so that's why I put that quote in.

347
00:00:00,000 --> 00:00:00,000

I want to talk about the symbol that's apparent on the page.

348
00:00:00,000 --> 00:00:00,000
还有什么问题么？
Any other questions?

349
00:00:00,000 --> 00:00:00,000
好吧 休息一下 谢谢大家
OK. Thank you. Let's take a break.

350
00:00:00,000 --> 00:00:00,000
[MUSIC PLAYING]

351
00:00:00,000 --> 00:00:00,000
教授：好 我们继续
PROFESSOR: Well, let's see.

352
00:00:00,000 --> 00:00:00,000
我们编写了一个貌似可行的代数表达式求导程序
We've just developed a fairly plausible program for computing the derivatives of algebraic expressions.

353
00:00:00,000 --> 00:00:00,000
这个程序是不完整的 你需要添加一些规则
It's an incomplete program, if you would like to add more rules.

354
00:00:00,000 --> 00:00:00,000
#TBD
And perhaps you might extend it to deal with uses of addition with any number of arguments and multiplication with any of the number of arguments.

355
00:00:00,000 --> 00:00:00,000
这些都相当简单
And that's all rather easy.

356
00:00:00,000 --> 00:00:00,000
但这里面也有一些瑕疵
However, there was a little fly in that ointment.

357
00:00:00,000 --> 00:00:00,000
回到这张幻灯片来
We go back to this slide.

358
00:00:00,000 --> 00:00:00,000
我们发现得到的表达式相当乱
We see that the expressions that we get are rather bad.

359
00:00:00,000 --> 00:00:00,000
这是一个非常糟糕的表达式
This is a rather bad expression.

360
00:00:00,000 --> 00:00:00,000
我们是怎么得到这样的表达式的？
How do we get such an expression?

361
00:00:00,000 --> 00:00:00,000
为什么这样呢？
Why do we have that expression?

362
00:00:00,000 --> 00:00:00,000
我们详细地分析一下这个表达式
Let's look at this expression in some detail.

363
00:00:00,000 --> 00:00:00,000
找出这些片段都是出自哪里
Let's find out where all the pieces come from.

364
00:00:00,000 --> 00:00:00,000
如我们所见 这里的加
As we see here, we have a sum--

365
00:00:00,000 --> 00:00:00,000
也就是上一小节中给你们提到的
just what I showed you at the end of the last time--

366
00:00:00,000 --> 00:00:00,000
(+ (* x 1) (* 1 x))
of X times 1 plus 1 time X.

367
00:00:00,000 --> 00:00:00,000
是这个积式的导数
That is a derivative of this product.

368
00:00:00,000 --> 00:00:00,000
也就是a乘上这个的积 这里a并不依赖于x
The product of a times that, where a does not depend upon x,

369
00:00:00,000 --> 00:00:00,000
因此它的导数为常数 #TBD
and therefore is constant with respect to x,

370
00:00:00,000 --> 00:00:00,000
导数为这个和式 从这里到这里 再到这里
is this sum, which goes from here all the way through here and through here.

371
00:00:00,000 --> 00:00:00,000
# TBD 30：49
Because it is the first thing times the derivative of the second

372
00:00:00,000 --> 00:00:00,000
plus the derivative of the first times the second

373
00:00:00,000 --> 00:00:00,000
as the program we wrote on the blackboard indicated we should do.

374
00:00:00,000 --> 00:00:00,000
当然 这里B乘以X的积
And, of course, the product of bx over here

375
00:00:00,000 --> 00:00:00,000
被化成了 B*1+0*X
manifests itself as B times 1 plus 0 times X

376
00:00:00,000 --> 00:00:00,000
因为B并不依赖于X
because we see that B does not depend upon X.

377
00:00:00,000 --> 00:00:00,000
因此B的导数为0
And so the derivative of B is this 0,

378
00:00:00,000 --> 00:00:00,000
而X对自己求导则为1
and the derivative of X with respect itself is the 1.

379
00:00:00,000 --> 00:00:00,000
这里的加法化成了 这两个导数的和式
And, of course, the derivative of the sums over here turn into these two sums of the derivatives of the parts.

380
00:00:00,000 --> 00:00:00,000
所以 #TBD 31:40
So what we're seeing here is exactly the thing I was trying to tell you about

381
00:00:00,000 --> 00:00:00,000
with Fibonacci numbers a while ago,

382
00:00:00,000 --> 00:00:00,000
所谓的 “过程的形式”
that the form of the process

383
00:00:00,000 --> 00:00:00,000

is expanded from the local rules that you see in the procedure,

384
00:00:00,000 --> 00:00:00,000
也就是过程代表了一系列用于演进过程局部规则 #TBD
that the procedure represents a set of local rules for the expansion of this process.

385
00:00:00,000 --> 00:00:00,000

And here, the process left behind some stuff, which is the answer.

386
00:00:00,000 --> 00:00:00,000

And it was constructed by the walk it takes of the tree structure,

387
00:00:00,000 --> 00:00:00,000
which is the expression.

388
00:00:00,000 --> 00:00:00,000
答案中的每一部分 都是问题中的某些部分
So every part in the answer we see here derives from some part of the problem.

389
00:00:00,000 --> 00:00:00,000
比如说 现在我们考察FOO的导数
Now, we can look at, for example, the derivative of foo,

390
00:00:00,000 --> 00:00:00,000
也就是AX^2+BX+C
which is ax square plus bx plus c,

391
00:00:00,000 --> 00:00:00,000
并另令自变量 比如像这里
with respect to other things, like here, for example,

392
00:00:00,000 --> 00:00:00,000
我们令A为自变量 求FOO的导数
we can see that the derivative of foo with respect to a.

393
00:00:00,000 --> 00:00:00,000
这都非常相似 实际上 它们是同样地代数表达式
And it's very similar. It's, in fact, the identical algebraic expression,

394
00:00:00,000 --> 00:00:00,000
只是它们之中0和1的位置不一样罢了
except for the fact that theses 0's and 1's are in different places.

395
00:00:00,000 --> 00:00:00,000
# TBD 32：40
Because the only degree of freedom we have in this tree walk

396
00:00:00,000 --> 00:00:00,000
is what's constant with respect to the variable we're taking the derivative with respect to

397
00:00:00,000 --> 00:00:00,000
and was the same variable.

398
00:00:00,000 --> 00:00:00,000
回到黑板上来再看看
In other words, if we go back to this blackboard and we look,

399
00:00:00,000 --> 00:00:00,000
我们在求和式或积式的导数时根本没有选择
we have no choice what to do when we take the derivative of the sum or a product.

400
00:00:00,000 --> 00:00:00,000
真正可以做文章的地方 则是表达式和自变量
The only interesting place here is, is the expression the variable,

401
00:00:00,000 --> 00:00:00,000
表达式是否为关于自变量的常数 #TBD 33：11
or is the expression a constant with respect to that variable for very, very small expressions?

402
00:00:00,000 --> 00:00:00,000

In which case we get various 1's and 0's, which if we go back to this slide,

403
00:00:00,000 --> 00:00:00,000
这里就出现了“0”
we can see that the 0's that appear here, for example,

404
00:00:00,000 --> 00:00:00,000
这里 求FOO(A)的导数时得到的“1”
this 1 over here in derivative of foo with respect to A,

405
00:00:00,000 --> 00:00:00,000

which gets us an X square,

406
00:00:00,000 --> 00:00:00,000

because that 1 gets the multiply of X and X into the answer, that 1 is 0.

407
00:00:00,000 --> 00:00:00,000

Over here, we're not taking the derivative of foo with respect to c.

408
00:00:00,000 --> 00:00:00,000
但是这些表达式的轮廓是一致的
But the shapes of these expressions are the same.

409
00:00:00,000 --> 00:00:00,000
看看这些轮廓 都是相同的
See all those shapes. They're the same.

410
00:00:00,000 --> 00:00:00,000
那么 难道是我们的规则出了问题？
Well is there anything wrong with our rules?

411
00:00:00,000 --> 00:00:00,000
不 这些规则都正确
No. They're the right rules.

412
00:00:00,000 --> 00:00:00,000
我们曾经遇到过这种问题
We've been through this one before.

413
00:00:00,000 --> 00:00:00,000

One of the things you're going to begin to discover is that there aren't too many good ideas.

414
00:00:00,000 --> 00:00:00,000
昨天 我们在考察有理数时
When we were looking at rational numbers yesterday,

415
00:00:00,000 --> 00:00:00,000
想要得到3/4却得到6/8
the problem was that we got 6/8 rather then 3/4.

416
00:00:00,000 --> 00:00:00,000
答案没有化简
The answer was unsimplified.

417
00:00:00,000 --> 00:00:00,000
当然 当下的问题也非常类似
The problem, of course, is very similar.

418
00:00:00,000 --> 00:00:00,000

There are things I'd like to be identical by simplification that don't become identical.

419
00:00:00,000 --> 00:00:00,000
当然 有理数加法和乘法的规则依然正确
And yet the rules for doing addition a multiplication of rational numbers were correct.

420
00:00:00,000 --> 00:00:00,000
因此这里 我们依葫芦画瓢
So the way we might solve this problem is do the thing we did last time, which always works.

421
00:00:00,000 --> 00:00:00,000
上次能行的办法 这次也没问题
If something worked last time it ought to work again.

422
00:00:00,000 --> 00:00:00,000
也就是改换一下它的表示
It's changed representation.

423
00:00:00,000 --> 00:00:00,000
或许在将其表示出来时我们可以进行
Perhaps in the representation we could put in a simplification step

424
00:00:00,000 --> 00:00:00,000
一步产生简化表示的步骤
that produces a simplified representation.

425
00:00:00,000 --> 00:00:00,000
当然啦 这也不是万用万灵
This may not always work, of course.

426
00:00:00,000 --> 00:00:00,000
我也不想证明它是万能的
I'm not trying to say that it always works.

427
00:00:00,000 --> 00:00:00,000
但这也是控制复杂度的一着妙计
But it's one of the pieces of artillery we have in our war against complexity.

428
00:00:00,000 --> 00:00:00,000
我们小心翼翼地解决这些问题
You see, because we solved our problem very carefully.

429
00:00:00,000 --> 00:00:00,000
我们所做的 就是把问题划分为几个部分
What we've done, is we've divided the world in several parts.

430
00:00:00,000 --> 00:00:00,000
分别是求导规则
There are derivatives rules

431
00:00:00,000 --> 00:00:00,000
和在这种层面上的一般代数规则
and general rules for algebra of some sort at this level of detail.

432
00:00:00,000 --> 00:00:00,000
然后就有一道抽象屏障
and i have an abstraction barrier.

433
00:00:00,000 --> 00:00:00,000
这里是代数表达式的表示——表结构
And i have the representation of the algebraic expressions, list structure.

434
00:00:00,000 --> 00:00:00,000
在这道屏障中 我定义了接口过程
And in this barrier, I have the interface procedures.

435
00:00:00,000 --> 00:00:00,000
比如 CONSTANT? SAME-VAR?
I have constant, and things like same-var.

436
00:00:00,000 --> 00:00:00,000
又比如 SUM? MAKE-SUM
I have things like sum, make-sum.

437
00:00:00,000 --> 00:00:00,000
还有 A1 A2
I have A1, A2.

438
00:00:00,000 --> 00:00:00,000
还有 PRODUCT? 之类的东西
I have products and things like that,

439
00:00:00,000 --> 00:00:00,000
我所需要的、针对各式代数表达式的东西
all the other things I might need for various kinds of algebraic expressions.

440
00:00:00,000 --> 00:00:00,000
构筑这些屏障我可以随意地改换表示法
Making this barrier allows me to arbitrarily change the representation

441
00:00:00,000 --> 00:00:00,000
而不用改变在某种表示法下编写的规则
without changing the rules that are written in terms of that representation.

442
00:00:00,000 --> 00:00:00,000
如果我能通过改变表示法来解决问题
So if I can make the problem go away by changing representation,

443
00:00:00,000 --> 00:00:00,000
那么把问题分解为两个部分则帮了我大忙
the composition of the problem into these two parts has helped me a great deal.

444
00:00:00,000 --> 00:00:00,000
好吧 举一个非常简单的例子
So let's take a very simple case of this.

445
00:00:00,000 --> 00:00:00,000
我们的问题是什么？
What was one of the problems?

446
00:00:00,000 --> 00:00:00,000
回到这张幻灯片来
Let's go back to this transparency again.

447
00:00:00,000 --> 00:00:00,000
看这里 哦 这相当糟糕
And we see here, oh yes, there's horrible things

448
00:00:00,000 --> 00:00:00,000
这里是一个表达式与“0”的和
like here is the sum of an expression and 0.

449
00:00:00,000 --> 00:00:00,000
毋庸置疑这应该是该表达式本身
Well that's no reason to think of it as anything other than the expression itself.

450
00:00:00,000 --> 00:00:00,000
为什么这里还会有加号？
Why should the summation operation have made up this edition?

451
00:00:00,000 --> 00:00:00,000
这其实可以更智能点
It can be smarter than that.

452
00:00:00,000 --> 00:00:00,000
又比如说这里 是某表达式与“1”的积
Or here, for example, is a multiplication of something by 1.

453
00:00:00,000 --> 00:00:00,000
这和之前一个道理
It's another thing like that.

454
00:00:00,000 --> 00:00:00,000
又像这里 与“0”相乘显然是“0”
Or here is a product of something with 0, which is certainly 0.

455
00:00:00,000 --> 00:00:00,000
因此我们也不用去构造这些式子了
So we won't have to make this construction.

456
00:00:00,000 --> 00:00:00,000
我们为什么不这么做呢？
So why don't we just do that?

457
00:00:00,000 --> 00:00:00,000
我们需要去修改表示法 基本上就是那里了
We need to change the way the representation works, almost here.

458
00:00:00,000 --> 00:00:00,000
定义 MAKE-SUM 为
Make-sum to be.

459
00:00:00,000 --> 00:00:00,000
呃 现在就不是那么简单了
Well, now it's not something so simple.

460
00:00:00,000 --> 00:00:00,000
除非是有必要 否则我不会简单地把加号和式子组合成表
I'm not going to make a list containing the symbol plus and things unless I need to.

461
00:00:00,000 --> 00:00:00,000
那么 还有哪些可能呢？
Well, what are the possibilities?

462
00:00:00,000 --> 00:00:00,000
如果……这里有一些可能的情况
If...I have some sort of cases here.

463
00:00:00,000 --> 00:00:00,000
如果都是数值的话 如果A1是数值的话
If I have numbers, if a1 is a number--

464
00:00:00,000 --> 00:00:00,000
这个基本过程我刚刚提到过
and here's another primitive I've just introduced,

465
00:00:00,000 --> 00:00:00,000
也就是用来检测参数是否为数值
it's possible to tell whether something's number--

466
00:00:00,000 --> 00:00:00,000
并且A2也是数值的话 也就是A2不是符号表达式
and if number A2, meaning they're not symbolic expressions,

467
00:00:00,000 --> 00:00:00,000
那么我们就直接把它们加起来
then why not do the addition now?

468
00:00:00,000 --> 00:00:00,000
结果就是A1加上A2的和
The result is just a plus of A1 and A2.

469
00:00:00,000 --> 00:00:00,000
我并不是检查它们代表数值
I'm not asking if these represent numbers.

470
00:00:00,000 --> 00:00:00,000
这里所有的符号都代表数值
Of course all of these symbols represent numbers.

471
00:00:00,000 --> 00:00:00,000
就比如 我想要考察的是这个东西是否为数值3
I'm talking about whether the one I've got is the number 3 right now.

472
00:00:00,000 --> 00:00:00,000
另一种情况
And, for example,

473
00:00:00,000 --> 00:00:00,000
假设A1是数值 并且为0
supposing A1 is a number, and it's equal to 0,

474
00:00:00,000 --> 00:00:00,000
那么答案就是A2
well then the answer is just A2.

475
00:00:00,000 --> 00:00:00,000
不用再构造什么
There is no reason to make anything up.

476
00:00:00,000 --> 00:00:00,000
如果A2是数值 并且为0
And if A2 is a number, and equal A2 0,

477
00:00:00,000 --> 00:00:00,000
那么答案就是A1
then the result is A1.

478
00:00:00,000 --> 00:00:00,000
如果没有比这些更好的情况
And only if I can't figure out something better to do with this situation,

479
00:00:00,000 --> 00:00:00,000
我就需要构造一个表
well, I can construct a list.

480
00:00:00,000 --> 00:00:00,000
构造一个用于表示答案的表
Otherwise I want the representation to be the list

481
00:00:00,000 --> 00:00:00,000
其中有 '+、A1和A2
containing the quoted symbol plus, and A1, and A2.

482
00:00:00,000 --> 00:00:00,000
档案 积的导数也可以类比此法
And, of course, a very similar thing can be done for products.

483
00:00:00,000 --> 00:00:00,000
这里 我就不细讲了
And I think I'll avoid boring you with them.

484
00:00:00,000 --> 00:00:00,000
我就直接在黑板上写出结果
I was going to write it on the blackboard.

485
00:00:00,000 --> 00:00:00,000
这并不是很重要 你们已经了解它的思想了
I don't think it's necessary. You know what to do.

486
00:00:00,000 --> 00:00:00,000
非常简明
It's very simple.

487
00:00:00,000 --> 00:00:00,000
现在 我们来看看用这种方式改造程序后 效果如何
But now, let's just see the kind of results we get out of changing our program in this way.

488
00:00:00,000 --> 00:00:00,000
哦 这是修改表达式构造函数后的求导结果
Well, here's the derivatives after having just changed the constructors for expressions.

489
00:00:00,000 --> 00:00:00,000
对同样地FOO求导：AX^2+BX+C
The same foo, aX square plus bX plus c,

490
00:00:00,000 --> 00:00:00,000
我得到了 2AX+B
and what I get is nothing more than the derivative of that is 2aX plus B.

491
00:00:00,000 --> 00:00:00,000
虽然它并没有化到最简
Well, it's not completely simplified.

492
00:00:00,000 --> 00:00:00,000
我应该合并同类项和求和
I would like to collect common terms and sums.

493
00:00:00,000 --> 00:00:00,000
但这又是另外一回事了
Well, that's more work.

494
00:00:00,000 --> 00:00:00,000
当然啦 完成这个功能的代码就大而复杂了
And, of course, programs to do this sort of thing are huge and complicated.

495
00:00:00,000 --> 00:00:00,000
代数化简 是一项复杂的工作 #TBD
Algebraic simplification, it's a very complicated mess.

496
00:00:00,000 --> 00:00:00,000
你们可能听过MIT以前开发的一个非常出名的程序 MAXIMA
There's a very famous program you may have heard of called Maxima developed at MIT in the past,

497
00:00:00,000 --> 00:00:00,000
它有5000页的LISP代码
which is 5,000 pages of Lisp code,

498
00:00:00,000 --> 00:00:00,000
大部分是代数化简的操作
mostly the algebraic simplification operations.

499
00:00:00,000 --> 00:00:00,000
这里是FOO的导数
There we see the derivative of foo.

500
00:00:00,000 --> 00:00:00,000
#TBD 41：20
In fact, X is at something I wouldn't take off more than 1 point for on an elementary calculus class.

501
00:00:00,000 --> 00:00:00,000
以A为自变量 FOO的导数则是X*X
And the derivative of foo with respect to a, well it's gone down to X times X,

502
00:00:00,000 --> 00:00:00,000
看起来还不差
which isn't so bad.

503
00:00:00,000 --> 00:00:00,000
以B为自变量 FOO的导数则是X本身
And the derivative of foo with respect to b is just X itself.

504
00:00:00,000 --> 00:00:00,000
以C为自变量 FOO的导数则为“1”
And the derivative of foo with respect to c comes out 1.

505
00:00:00,000 --> 00:00:00,000
我对这些结果很满意
So I'm pretty pleased with this.

506
00:00:00,000 --> 00:00:00,000
你所看到的 都是精心设计、仔细规划的例子
What you've seen is, of course, a little bit contrived, carefully organized example

507
00:00:00,000 --> 00:00:00,000
用以展示如何操作代数表达式
to show you how we can manipulate algebraic expressions,

508
00:00:00,000 --> 00:00:00,000
我们如何不用具体的语法 而用抽象的语法抽象地进行
how we do that abstractly in terms of abstract syntax rather than concrete syntax

509
00:00:00,000 --> 00:00:00,000
以及我们如何使用抽象屏障控制构造这些表达式 #TBD 41：56
and how we can use the abstraction to control what goes on in building these expressions.

510
00:00:00,000 --> 00:00:00,000
真正的奥义并不是如此的简单
But the real story isn't just such a simple thing as that.

511
00:00:00,000 --> 00:00:00,000
实际上 真正的奥义在于我在操作这些表达式时
The real story is, in fact, that I'm manipulating these expressions.

512
00:00:00,000 --> 00:00:00,000
代数表达式和代码表达式——
And the expressions are the same expressions--

513
00:00:00,000 --> 00:00:00,000
回过头来看看幻灯片
going back to the slide--

514
00:00:00,000 --> 00:00:00,000
都是同一种LISP表达式
as the ones that are Lisp expressions.

515
00:00:00,000 --> 00:00:00,000
这样一语双关 一石二鸟
There's a pun here.

516
00:00:00,000 --> 00:00:00,000
#TBD 42：00
I've chosen my representation to be the same as the representation in my language of similar things.

517
00:00:00,000 --> 00:00:00,000
为了要这样做 我得付出点代价
By doing so, I've invoked a necessity.

518
00:00:00,000 --> 00:00:00,000
我需要使用类似于“引用”的东西
I created the necessity to have things like quotation

519
00:00:00,000 --> 00:00:00,000

because of the fact that my language is capable of writing expressions that talk about expressions of the language.

520
00:00:00,000 --> 00:00:00,000
我需要有某种东西指出 这个是我需要讨论的表达式
I need to have something that says, this is an expression I'm talking about

521
00:00:00,000 --> 00:00:00,000
而不是说 这个表达式的值 #TBD
rather than this expression is talking about something,

522
00:00:00,000 --> 00:00:00,000

and I want to talk about that.

523
00:00:00,000 --> 00:00:00,000
引用阻止表达式被求值 其语义为“就是表达式本身”
So quotation stops and says, I'm talking about this expression itself.

524
00:00:00,000 --> 00:00:00,000
有了这种能力以后
Now, given that power,

525
00:00:00,000 --> 00:00:00,000
如果我可以操作语言的表达式
if I can manipulate expressions of the language,

526
00:00:00,000 --> 00:00:00,000

I can begin to build even much more powerful layers upon layers of languages.

527
00:00:00,000 --> 00:00:00,000
因为我可以编写不仅仅是内嵌于LISP的语言
Because I can write languages that not only are embedded in Lisp

528
00:00:00,000 --> 00:00:00,000
或者是其它的语言
or whatever language you start with,

529
00:00:00,000 --> 00:00:00,000
我可以编写一种完全不同的语言
but languages that are completely different,

530
00:00:00,000 --> 00:00:00,000
而其实质上则是被LISP或其它语言所解释
that are just, if we say, interpreted in Lisp or something like that.

531
00:00:00,000 --> 00:00:00,000
我们以后还会对此有更深入的理解
We'll get to understand those words more in the future.

532
00:00:00,000 --> 00:00:00,000
我现在只是想让你们意识到 #TBD
But right now I just want to leave you with the fact that we've hit a line

533
00:00:00,000 --> 00:00:00,000
我们已经感触到了一种惊人的力量
which gives us tremendous power.

534
00:00:00,000 --> 00:00:00,000
现在我们有了方天画戟
And this point we've bought a sledgehammer.

535
00:00:00,000 --> 00:00:00,000
当我们使用它时 也得万分小心
We have to be careful to what flies when we apply it.

536
00:00:00,000 --> 00:00:00,000
谢谢大家
Thank you.

537
00:00:00,000 --> 00:00:00,000
让我们来仔细地看看这些法则
Well let's see. Let's look at these rules in some detail.
哈尔滨工业大学 IBM技术中心
倾情制作

538
00:00:00,000 --> 00:00:06,293
哈尔滨工业大学 IBM技术中心
倾情制作

539
00:00:06,293 --> 00:00:09,413
压制&&特效：蔡钟毓（JohnTitor）
翻译&&时间轴：邓雄飞（Dysprosium）

540
00:00:09,413 --> 00:00:15,440
特别感谢：裘宗燕教授
校对：邓雄飞（Dysprosium）

541
00:00:15,440 --> 00:00:18,960
符号化求导系统

542
00:00:19,100 --> 00:00:23,413
教授：哈尔教授讲解了如何构造健壮的系统
PROFESSOR: Well, Hal just told us how you build robust systems.

543
00:00:23,800 --> 00:00:26,173
关键点就是
The key idea was--

544
00:00:26,813 --> 00:00:30,200
我确信你们大多数人到现在为止还不太明白
I'm sure that many of you don't really assimilate that yet--

545
00:00:30,200 --> 00:00:33,773
关键点就是 为了让系统具有健壮性
but the key idea is that in order to make a system that's robust,

546
00:00:33,933 --> 00:00:36,480
应该让它对小变化不敏感
it has to be insensitive to small changes,

547
00:00:36,600 --> 00:00:37,373
也就是说
that is,

548
00:00:37,373 --> 00:00:40,906
问题中的小改变只会导致解决方案的小改动
a small change in the problem should lead to only a small change in the solution.

549
00:00:41,320 --> 00:00:42,906
系统应该是连续的
There ought to be a continuity.

550
00:00:42,900 --> 00:00:45,946
在问题空间中 解的空间是连续的
The space of solutions ought to be continuous in this space of problems.

551
00:00:46,253 --> 00:00:48,760
Hal教授给你们解释过
The way he was explaining how to do that

552
00:00:49,460 --> 00:00:54,786

was instead of solving a particular problem at every level of decomposition of the problem at the subproblems,

553
00:00:55,080 --> 00:00:56,780

where you solve the class of problems,

554
00:00:56,780 --> 00:01:00,400

which are a neighborhood of the particular problem that you're trying to solve.

555
00:01:01,400 --> 00:01:04,760
解决之道便是在该层次上构造一门语言
The way you do that is by producing a language at that level of detail

556
00:01:04,760 --> 00:01:10,333
使得我们可以用这门语言来表述这类问题
in which the solutions to that class of problems is representable in that language.

557
00:01:11,373 --> 00:01:15,093
因此 当着手解决的问题再发生变动时
Therefore when you change makes more changes to the problem you're trying to solve,

558
00:01:15,090 --> 00:01:19,293
通常 你只需要在已构造好的解决方案上做出微小改动
you generally have to make only small local changes to the solution you've constructed,

559
00:01:19,293 --> 00:01:22,266
因为在你所考虑的层次上
because at the level of detail you're working,

560
00:01:22,266 --> 00:01:24,266
有一门语言可以
there's a language where you can express

561
00:01:24,800 --> 00:01:28,146
表达与该问题类似的其它问题的各种解法
the various solutions to alternate problems of the same type.

562
00:01:30,040 --> 00:01:33,746
呃... 这是一个重要思想的萌芽
Well that's the beginning of a very important idea,

563
00:01:34,400 --> 00:01:38,613
该思想的重要性也使得计算机科学比
the most important perhaps idea that makes computer science more powerful

564
00:01:38,613 --> 00:01:42,373
其它大多数工程学科还要强大
than most of the other kinds of engineering disciplines we know about.

565
00:01:43,386 --> 00:01:44,733
目前为止 我们学习的是
What we've seen so far

566
00:01:44,733 --> 00:01:48,786
类似于如何使用语言内置元素
is sort of how to use embedding of languages.

567
00:01:49,266 --> 00:01:53,360
当然 内置元素的力量一部分来源于
And, of course, the power of embedding languages partly comes from

568
00:01:54,120 --> 00:01:56,866
像这个一样的过程 我昨天给你们展示过了
procedures like this one that I showed you yesterday.

569
00:01:57,373 --> 00:02:02,133
这里 是一份求导程序 昨天给你们描述过了
What you see here is the derivative program that we described yesterday.

570
00:02:02,130 --> 00:02:05,920
这个过程以一个过程为参数
It's a procedure that takes a procedure as an argument

571
00:02:06,000 --> 00:02:07,920
并返回一个过程
and returns a procedure as a value.

572
00:02:09,613 --> 00:02:12,653
用这样的东西棒极了
And using such things is very nice.

573
00:02:12,653 --> 00:02:14,653
你可以压入组合子 #TBD
You can make things like push combinators

574
00:02:14,650 --> 00:02:16,866
还有你们上次看到的各种美妙的事
and all that sort of wonderful thing that you saw last time.

575
00:02:17,680 --> 00:02:20,546
然而 现在我要搅浑这滩水
However, now I'm going to really muddy the waters.

576
00:02:21,560 --> 00:02:25,906
这个程序混淆了过程和数据
See this confuses the issue of what's the procedure and what is data,

577
00:02:26,560 --> 00:02:27,813
虽然程度不算太重
but not very badly.

578
00:02:28,426 --> 00:02:30,906
而我们将要严重地混淆两者
What we really want to do is confuse it very badly.

579
00:02:31,186 --> 00:02:32,440
最好的做法就是
And the best way to do that

580
00:02:32,440 --> 00:02:37,626
参与到过程自身所描述的代数表达式的操作中
is to get involved with the manipulation of the algebraic expressions that the procedures themselves are expressed in.

581
00:02:39,733 --> 00:02:45,586
所以 这里我不会讨论这张幻灯片上的东西
So at this point, I want to talk about instead of things like on this slide,

582
00:02:45,893 --> 00:02:49,720
一个通过操作过程的求导程序
the derivative procedure being a thing that manipulates a procedure--

583
00:02:49,720 --> 00:02:51,946
这只是一个数值化方法而已
this is a numerical method you see here.

584
00:02:51,946 --> 00:02:58,933
你们所看到的是 通过数值方法来近似的求导程序
And what you're seeing is a representation of the numerical approximationto the derivative.

585
00:02:59,293 --> 00:03:00,440
也就是这里的东西了
That's what's here.

586
00:03:00,866 --> 00:03:04,933
事实上 我想讨论的是这些东西
In fact what I'd like to talk about is instead things that look like this.

587
00:03:06,053 --> 00:03:11,333
这是一份从微积分书中摘录的法则
And what we have here are rules from a calculus book.

588
00:03:12,093 --> 00:03:16,173
这对表达式求导的法则
These are rules for finding the derivatives of the expressions

589
00:03:16,706 --> 00:03:20,586
只不过是用代数语言书写的
that one might write in some algebraic language.

590
00:03:21,640 --> 00:03:24,413
法则说 常数的导数是0
It says things like a derivative of a constant is 0.

591
00:03:25,133 --> 00:03:29,093
而代表你所讨论的那个数的变量导数为1
The derivative of the valuable with respect to which you are taking the derivative is 1.

592
00:03:29,320 --> 00:03:31,933
常数乘以函数的导数
The derivative of a constant times the function

593
00:03:32,093 --> 00:03:34,373
其值是常数的值乘以函数导数的值
is the constant times the derivative of the function,

594
00:03:34,773 --> 00:03:36,040
就是这个意思
and things like that.

595
00:03:38,053 --> 00:03:41,386
这些都是精确的表达式 而非数值近似
These are exact expressions. These are not numerical approximations.

596
00:03:42,960 --> 00:03:44,520
我们还能编写程序吗？
Can we make programs?

597
00:03:44,520 --> 00:03:52,240
事实上 编写处理这些表达式的程序非常容易
And, in fact, it's very easy to make programs that manipulate these expressions.

