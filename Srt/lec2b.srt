1
00:00:00,000 --> 00:00:00,000
我除不除、在哪里除 都无所谓
it doesn't matter whether I take them out or not, or the place where I take them,

2
00:00:00,000 --> 00:00:00,000

because the idea is I'm going to divide through.

3
00:00:00,000 --> 00:00:00,000
嗯 这就是George的契约
But see, this is George's contract.

4
00:00:00,000 --> 00:00:00,000
我们要告诉Georg的就是 提供给我三个过程
So what we really say to George is your business is to go off and find us three procedures,

5
00:00:00,000 --> 00:00:00,000
MAKE-RAT NUMER 和 DENOM
make-RAT, and numerator, and denominator,

6
00:00:00,000 --> 00:00:00,000
使得无论N和D如何选择 都可以满足这个契约
that fulfill this contract for any choice of n and d.

7
00:00:00,000 --> 00:00:00,000
这也就是我所谓的我们可以用来作为有理数表示的基础
And that's what we mean by we can use that as the basis for a rational number representation.

8
00:00:00,000 --> 00:00:00,000
并且只要它们能满足契约
And other than that, it fulfills this contract.

9
00:00:00,000 --> 00:00:00,000
我们不关心他是如何实现的
We don't care how he does it.

10
00:00:00,000 --> 00:00:00,000
这不关我们的事儿 这在抽象层之下
It's not our business. It's below the layer of abstraction.

11
00:00:00,000 --> 00:00:00,000
事实上 如果我们想知道 有理数真正是什么
In fact, if we want to say, what is a rational number really?

12
00:00:00,000 --> 00:00:00,000

See, what's it really, without having to talk about going below the layer of abstraction,

13
00:00:00,000 --> 00:00:00,000

what we're forced into saying is a rational number really

14
00:00:00,000 --> 00:00:00,000
is sort of this axiom,

15
00:00:00,000 --> 00:00:00,000
就是MAKE-RAT NUMER 和 DENOM这三个满足这条公理的过程
is three procedures, make-RAT, numerator, and denominator, that satisfy this axiom.

16
00:00:00,000 --> 00:00:00,000
从某种抽象的意义来说 这就是真正的有理数
In some sense, abstractly, that's what a rational number is really.

17
00:00:00,000 --> 00:00:00,000
这听起来很容易 因为你脑中已经有了
That's sort of easy words to listen to, because what you have in your head, of course, is well,

18
00:00:00,000 --> 00:00:00,000
关于有理数是什么的只是
for all this thing about saying that's what a rational number is really,

19
00:00:00,000 --> 00:00:00,000
因为你已经看到了我们是如何构建有理数的
you actually just saw that we built rational numbers.

20
00:00:00,000 --> 00:00:00,000
对 我们是在序对的基础上构建有理数的
See, what we really did is we built rational numbers on top of pairs.

21
00:00:00,000 --> 00:00:00,000
因此 抽象地来说 我们可以认为有理数实际上就是这些公理
So for all I'm saying abstractly, we can say a rational number really is just this axiom.

22
00:00:00,000 --> 00:00:00,000
你可以很自然把有理数理解为序对 因为这正也是你们见到的
You can listen to that comfortably, because you're saying, well, yeah, but really it's actually pairs,

23
00:00:00,000 --> 00:00:00,000
我把它说得抽象后反而影响你理解
and I'm just annoying you by trying to be abstract.

24
00:00:00,000 --> 00:00:00,000
那么为了让你们 #TBD
Well, let me, as an antidote for that,

25
00:00:00,000 --> 00:00:00,000
我下面展示的东西 一定会吓到你
let me do something that I think is really going to terrify you.

26
00:00:00,000 --> 00:00:00,000
我是说 我会让你们对我们讨论的抽象
I mean, it's really going to bring you face to face

27
00:00:00,000 --> 00:00:00,000
#TBD
with the sort of existential reality of this abstraction that we're talking about.

28
00:00:00,000 --> 00:00:00,000
我们将讨论 序对 到底是什么？
And what I'm going to talk about is, what are pairs really?

29
00:00:00,000 --> 00:00:00,000
说说 我是怎么给你们讲“序对”的？
See, what did I tell you about pairs?

30
00:00:00,000 --> 00:00:00,000
我耍了你们 #TBD
I tricked you, right?

31
00:00:00,000 --> 00:00:00,000
我说 Lisp有一个叫CONS的基本过程可以构建序对
I said that Lisp has this primitive called cons that builds pairs.

32
00:00:00,000 --> 00:00:00,000
但我真正告诉你们什么呢？
But what did I really tell you about?

33
00:00:00,000 --> 00:00:00,000
如果你回过头来看 看这些幻灯片
If you go back and said, let's look on this slide,

34
00:00:00,000 --> 00:00:00,000
会发现我真正告诉你们的是序对应该具有这些属性
all I really told you about pairs is that there happens to be this property,

35
00:00:00,000 --> 00:00:00,000
这些CONS CAR 和 CDR构成的属性
these properties of cons, car, and cdr.

36
00:00:00,000 --> 00:00:00,000
而我说的“序对”
And all I really said about pairs

37
00:00:00,000 --> 00:00:00,000
只是说这里面有叫CONS 叫CAR 和叫CDR的东西
is that there's a thing called cons, and a thing called car, and a thing called cdr.

38
00:00:00,000 --> 00:00:00,000
在这个例子中 我构建了由X和Y构成的序对 取CAR部分得X
And it is the case that if I build cons of x, y and take car of it, I get x.

39
00:00:00,000 --> 00:00:00,000
构建由X和Y构成的序对 取CDR部分得Y
And if I build cons of x, y and get cdr of it, I get y.

40
00:00:00,000 --> 00:00:00,000
尽管如此 我也对你们谎称Lisp中有个东西能这么做
And even though I lulled you into thinking that there's something in Lisp that does that,

41
00:00:00,000 --> 00:00:00,000
因此你们也就假装确实有这么个东西
so you pretended you knew what it was,

42
00:00:00,000 --> 00:00:00,000
事实上 关于序对 我告诉你们的跟有理数一样多
in fact, I didn't tell you any more about pairs than this tells you about rational numbers.

43
00:00:00,000 --> 00:00:00,000
都是序对的一些公理
It's just some axiom for pairs.

44
00:00:00,000 --> 00:00:00,000
书归正传 我马上要大显身手了
Well, to drive that home, let me really scare you,

45
00:00:00,000 --> 00:00:00,000
我会用某个神秘的东西来构建序对
and show you what we might build pairs in terms of.

46
00:00:00,000 --> 00:00:00,000
你们将会看见 我们可以构建有理数
And what you're going to see is that we can build rational numbers,

47
00:00:00,000 --> 00:00:00,000
直线段、向量以及任何由序对构建起的东西
and line segments, and vectors, and all of this stuff in terms of pairs,

48
00:00:00,000 --> 00:00:00,000
我们在低于抽象层的这里看到 序对可以凭空产生
and we're going to see below here that pairs can be built out of nothing at all.

49
00:00:00,000 --> 00:00:00,000
这是纯粹的抽象
Pure abstraction.

50
00:00:00,000 --> 00:00:00,000
那么就让我在这张幻灯片中为你们展示CONS CAR和CDR的一种实现
So let me show you on this slide an implementation of cons, car, and cdr.

51
00:00:00,000 --> 00:00:00,000
等会儿我们会回来细看
And we'll look at it again in a second,

52
00:00:00,000 --> 00:00:00,000
但一定要注意过程CONS CAR和CDR的定义
but notice that their procedure definitions of cons, car, and cdr,

53
00:00:00,000 --> 00:00:00,000
这里你看不到任何数据 你只能看到一个lambda
you don't see any data in there, what you see is a lambda.

54
00:00:00,000 --> 00:00:00,000
这里的CONS将返回 一个返回值为新的过程的过程
So cons here is going to return-- is a procedure that returns a procedure,

55
00:00:00,000 --> 00:00:00,000
就像函数AVERAGE-ADPT
just like average-adpt.

56
00:00:00,000 --> 00:00:00,000
(CONS A B)返回一个具有单个参数的过程pick
Cons of a and b returns a procedure of an argument called pick,

57
00:00:00,000 --> 00:00:00,000
它的定义是
and it says,

58
00:00:00,000 --> 00:00:00,000
如果pick等于1 那么该过程返回a
if pick is equal to 1, I'm going to return a,

59
00:00:00,000 --> 00:00:00,000
而如果pick等于2 那么该过程返回b
and if pick is equal to 2, I'm going to return b,

60
00:00:00,000 --> 00:00:00,000
这就是CONS的定义
and that's what cons is going to be.

61
00:00:00,000 --> 00:00:00,000
取X的CAR部分 (CAR X)
Car of a thing x, car of a pair x,

62
00:00:00,000 --> 00:00:00,000
就是把X应用于1
is going to be x applied to 1.

63
00:00:00,000 --> 00:00:00,000
注意了 这完全行得通
And notice that makes sense.

64
00:00:00,000 --> 00:00:00,000
你现在还不太明白我为什么要这样做 但至少这样行得通
You might not understand why or how I'm doing such a thing, but at least it makes sense,

65
00:00:00,000 --> 00:00:00,000
因为我通过CONS构造出了一个过程
because the thing constructed by cons is a procedure,

66
00:00:00,000 --> 00:00:00,000
而CAR将其应用于1
and car applies that to 1.

67
00:00:00,000 --> 00:00:00,000
类似的 CDR将其应用于2
And similarly, cdr applies that thing to 2.

68
00:00:00,000 --> 00:00:00,000
好了 现在我已经给出了CONS CAR和CDR的一种表示法
OK, now I claimed that this is a representation of cons, car, and cdr,

69
00:00:00,000 --> 00:00:00,000
注意这里面没有任何数据
and notice there's no data in it.

70
00:00:00,000 --> 00:00:00,000
这就是“凭空”产生的 它们仅仅是过程
All right, it's built out of air. It's just procedures.

71
00:00:00,000 --> 00:00:00,000
这种表示法中没有任何数据对象
There's no data objects at all in that representation.

72
00:00:00,000 --> 00:00:00,000
那么 这又可能意味着什么呢？
Well, what could that possibly mean?

73
00:00:00,000 --> 00:00:00,000
嗯 如果你承认这些东西的话 #TBD
Well, if you really believe this stuff,

74
00:00:00,000 --> 00:00:00,000
那么接下来 一旦我证明了CONS CAR CDR的这种表示法
then you have to believe that in order to show that that's a representation for cons, car, and cdr,

75
00:00:00,000 --> 00:00:00,000
能满足我们的公理的话 你就对此不容置疑了 #TBD
all I have to do is show that it satisfies the axiom.

76
00:00:00,000 --> 00:00:00,000
那么 我来举一个例子
See, all I should have to convince you of is,

77
00:00:00,000 --> 00:00:00,000
例如 (CAR (CONS 37 49))应该返回37
for example, that gee, that car of cons of 37 and 49 is 37

78
00:00:00,000 --> 00:00:00,000

for arbitrary values of 37 and 49.

79
00:00:00,000 --> 00:00:00,000
CDR也是如此
And cdr the same way.

80
00:00:00,000 --> 00:00:00,000
#TBD
See, if I really can demonstrate to you that that weird procedure definition,

81
00:00:00,000 --> 00:00:00,000

in terms of the air, has the property that it satisfies this,

82
00:00:00,000 --> 00:00:00,000
then you just have to grant me that that is a possible implementation of cons, car, and cdr,

83
00:00:00,000 --> 00:00:00,000
on which I can build everything else.

84
00:00:00,000 --> 00:00:00,000
好了 让我们回过头来看看 这里将用到代换模型
Well, let's look at that. And this will be practice in the substitution model.

85
00:00:00,000 --> 00:00:00,000
我们该怎么来说清这个过程呢？ #TBD
How could we check this?

86
00:00:00,000 --> 00:00:00,000
我们好像知道点怎么做 这都是同一个代换模型
We sort of know how to do that. It's just the same substitution model.

87
00:00:00,000 --> 00:00:00,000
我们来瞧瞧 首先 我们考虑(CAR (CONS 37 49))是什么
Let's look. We start out, and we say, what's car of cons of 37 and 49?

88
00:00:00,000 --> 00:00:00,000
接下来该怎么做？ CONS只是一个过程
What do we do? Cons is some procedure.

89
00:00:00,000 --> 00:00:00,000
它的值也就是一个有A和B的过程
Its value is cons was a procedure of a and b.

90
00:00:00,000 --> 00:00:00,000
CONS返回的是一个过程体
The thing returned by cons is its procedure body

91
00:00:00,000 --> 00:00:00,000
该过程体的参数被37和49代换掉了
with 37 and 49 substituted for the parameters.

92
00:00:00,000 --> 00:00:00,000
用37代换a 用49代换b
It'll be 37 substituted for a and 49 substituted for b.

93
00:00:00,000 --> 00:00:00,000
所以这个表达式和这个表达式的意思是相同的
So this expression has the same meaning as this expression.

94
00:00:00,000 --> 00:00:00,000
CAR没变 而CONS被代换为了一个以LAMBDA开头的表达式
Its car of, and the body of cons was this thing that started with lambda.

95
00:00:00,000 --> 00:00:00,000
这里pick是另外一个变量 如果pick为1的话
And it says, so if pick is equal to 1, where pick is this other argument,

96
00:00:00,000 --> 00:00:00,000
如果pick等于1 那么就返回37 也就是a的值
if pick is equal to 1, it's 37, that's where a was,

97
00:00:00,000 --> 00:00:00,000
如果pick等于2 那么就返回49
and if pick is equal to 2, it's 49.

98
00:00:00,000 --> 00:00:00,000
这是代换的第一步
So that's the first step.

99
00:00:00,000 --> 00:00:00,000
我只是进行了机械地代换
I'm just going through mechanical substitution.

100
00:00:00,000 --> 00:00:00,000
注意了 这也是本课的一大要点
And remember, at this point in the course,

101
00:00:00,000 --> 00:00:00,000
当你搞不清楚情况的时候
if you're confused about what things mean,

102
00:00:00,000 --> 00:00:00,000
就按照代换模型进行机械地代换
go mechanically through the substitution model.

103
00:00:00,000 --> 00:00:00,000
那么 这又会被归约为什么呢？
Well, what is this reduced to?

104
00:00:00,000 --> 00:00:00,000
而CAR则是 把给定的参数 本例中也就是这些 应用于1
Car said, take your, take your argument, which in this case is this, and apply it to 1.

105
00:00:00,000 --> 00:00:00,000
这也就是CAR的定义
That was the definition of car.

106
00:00:00,000 --> 00:00:00,000

So if I look at car, if I do that, the answer is,

107
00:00:00,000 --> 00:00:00,000
这就是那个CAR的参数 将其应用于1
well, it's that argument, this was the argument to car, applied to 1.

108
00:00:00,000 --> 00:00:00,000
这又是什么意思呢？
Well, what does that mean?

109
00:00:00,000 --> 00:00:00,000
在这里的代码体中 我拿1来替换pick
I take 1, and I substitute it in the body here for this value of pick,

110
00:00:00,000 --> 00:00:00,000
也就是这个变量的名字 我们得到什么呢？
which is the name of the argument, what do I get?

111
00:00:00,000 --> 00:00:00,000
如果1等于1 那么就得到37
Well, I get the thing that says if 1 equals 1 it's 37,

112
00:00:00,000 --> 00:00:00,000
如果1等于2 那么就得到49 当然答案就是37
and if 1 equals 2 it's 49, so the answer's 37.

113
00:00:00,000 --> 00:00:00,000
类似的 如果是CDR的话 也就是将其应用于2 则得到49
And similarly, if I'd taken cdr, that would apply it to 2, and I'd get 49.

114
00:00:00,000 --> 00:00:00,000
正如你们所见 我给你们演示了
So you see, what I've demonstrated is that that completely weird implementation

115
00:00:00,000 --> 00:00:00,000
完全符合这些公理的CONS CAR CDR实现
of cons, car, and cdr, satisfies the axioms.

116
00:00:00,000 --> 00:00:00,000
事实上 用这种方法来构建Lisp中所有的数据对象 非常有效
So it's a perfectly valid way of building, in fact, all of the data objects we're going to see in Lisp.

117
00:00:00,000 --> 00:00:00,000
如果你愿意的话 这一切东西 都可以 #TBD
So they all, if you like, can be built on sort of existential nothing.

118
00:00:00,000 --> 00:00:00,000
[1.09.09]
And as far as you know, that's how it works.

119
00:00:00,000 --> 00:00:00,000
你无法分辨
You couldn't tell.

120
00:00:00,000 --> 00:00:00,000
If all you're ever going to do with pairs

121
00:00:00,000 --> 00:00:00,000
is construct them with cons and look at them with car and cdr,

122
00:00:00,000 --> 00:00:00,000
you couldn't possibly tell how this thing works.

123
00:00:00,000 --> 00:00:00,000

Now, it might give you a sort of warm feeling inside if I say,

124
00:00:00,000 --> 00:00:00,000
well, yeah, in fact, for various reasons there happens to be a primitive

125
00:00:00,000 --> 00:00:00,000
called cons, car, and cdr, and if it's too scary,

126
00:00:00,000 --> 00:00:00,000

if this kind of stuff is too scary, you don't have to look inside of it.

127
00:00:00,000 --> 00:00:00,000
So that might make you feel better,

128
00:00:00,000 --> 00:00:00,000
but the point is, it really could work this way,

129
00:00:00,000 --> 00:00:00,000
and it wouldn't make any difference to the system at all.

130
00:00:00,000 --> 00:00:00,000
So in some sense, we don't need data at all to build these data
abstractions.

131
00:00:00,000 --> 00:00:00,000
We can do everything in terms of procedures.

132
00:00:00,000 --> 00:00:00,000
OK, well, why did I terrify you in this way?

133
00:00:00,000 --> 00:00:00,000
First, I really want to reinforce this idea of abstraction,

134
00:00:00,000 --> 00:00:00,000
that you really can do these things abstractly.

135
00:00:00,000 --> 00:00:00,000
Secondly, I want to introduce an idea we're going to see more and more of in this course,

136
00:00:00,000 --> 00:00:00,000
which is we're going to blur the line between what's data and what's a procedure.

137
00:00:00,000 --> 00:00:00,000

See, in this funny implementation it turned out that cons of something

138
00:00:00,000 --> 00:00:00,000
happened to be represented in terms of a procedure, even though we think of it as data.

139
00:00:00,000 --> 00:00:00,000
While here that's sort of a mathematical trick,

140
00:00:00,000 --> 00:00:00,000
but one of the things we'll see is that a lot of the very important programming techniques

141
00:00:00,000 --> 00:00:00,000
that we're going to get to sort of depend very crucially

142
00:00:00,000 --> 00:00:00,000
on blurring this traditional line between what you consider a procedure and what you consider data.

143
00:00:00,000 --> 00:00:00,000
We're going to see more and more of that, especially next time.

144
00:00:00,000 --> 00:00:00,000
好了 有什么问题吗？
OK, questions?

145
00:00:00,000 --> 00:00:00,000
学生：如果让系统打印A 会输出什么呢？
AUDIENCE: If you asked the system to print a, what would be the result?

146
00:00:00,000 --> 00:00:00,000
教授：你想问 如果我让系统打印A
PROFESSOR: The question is, what would happen if I asked the system to print a.

147
00:00:00,000 --> 00:00:00,000
看看这种表示法 你就知道答案了
Given this representation, you already know the answer.

148
00:00:00,000 --> 00:00:00,000
像上次一样 这是一个复合过程A
The answer is compound procedure a, just like last time.

149
00:00:00,000 --> 00:00:00,000
系统返回“复合过程”
It'd say compound procedure.

150
00:00:00,000 --> 00:00:00,000
说着说得更详细一点 像“复合LAMBDA过程”等等
It might say a little bit more. It might say compound procedure lambda or something or other,

151
00:00:00,000 --> 00:00:00,000
这得看我是如何给它命名的 但它归根是个过程
depending on details of how I named it. But it's a procedure.

152
00:00:00,000 --> 00:00:00,000

And the only reason for that is I haven't told the system

153
00:00:00,000 --> 00:00:00,000
anything special about how to print such things.

154
00:00:00,000 --> 00:00:00,000
Now, it's in fact true that with the actual implementation of cons that to be built in the system,

155
00:00:00,000 --> 00:00:00,000
it would print something else.

156
00:00:00,000 --> 00:00:00,000
它会打印出这是个序对
It would print, say, this is a pair.

157
00:00:00,000 --> 00:00:00,000
学生：你定义CONS后
AUDIENCE: When you define cons,

158
00:00:00,000 --> 00:00:00,000
你给它传递了几个值
and then you pass it into values,

159
00:00:00,000 --> 00:00:00,000
它怎么知道该去哪里找这些值 毕竟你可以多次使用CONS
how does it know where to look for the cons, because you can use cons over and over again?

160
00:00:00,000 --> 00:00:00,000
它是怎么知道我们希望取出的a和b存储在哪里呢？
How does it know where to look to know which a and b it's supposed to pull back out?

161
00:00:00,000 --> 00:00:00,000
可能表达得不是很正确 我只是想问它都存放在哪儿？
I don't know if I'm expressing that quite right. Where is it stored?

162
00:00:00,000 --> 00:00:00,000
教授：嗯 来想想
PROFESSOR: OK, the question is,

163
00:00:00,000 --> 00:00:00,000
我先用37和49来构造一个序对 在用1和2又构造一个
I sort of have a cons with a 37 and a 49, and I might make another cons with a 1 and a 2,

164
00:00:00,000 --> 00:00:00,000
有一个参数为a 有一个参数为b
and I might have one called a, and I might have one called b.

165
00:00:00,000 --> 00:00:00,000
问题是 系统又是怎么知道的呢？它为什么没有弄混淆呢？
And the question is, how does it know? And why don't they get confused?

166
00:00:00,000 --> 00:00:00,000
这个问题非常好
And that's a very good question.

167
00:00:00,000 --> 00:00:00,000
首先 你需要认定过程是一种对象
See, you have to really believe that the procedures are objects.

168
00:00:00,000 --> 00:00:00,000
这就像是说——让我来换个更简单的例子
It's sort of like saying-- let's try another simpler example.

169
00:00:00,000 --> 00:00:00,000
我想去求3的平方根
Suppose I ask for the square root of 3.

170
00:00:00,000 --> 00:00:00,000
我这里用5的平方根来说好了
So I asked for the square root of 5,

171
00:00:00,000 --> 00:00:00,000
我也可以求20的平方根
and then I ask for the square of 20.

172
00:00:00,000 --> 00:00:00,000
You're probably not the least bit bothered that I can take square root and apply it to 5, and then I can take square root and apply it to 20.

173
00:00:00,000 --> 00:00:00,000
And there's sort of no issue, gee, doesn't it get confused about whether it's working on 5 or 20?

174
00:00:00,000 --> 00:00:00,000
There's no issue about that because you're thinking of a procedure which goes off and does something.

175
00:00:00,000 --> 00:00:00,000
从某种方面来说 你问了我一个同样的问题
Now, in some sense you're asking me the same question.

176
00:00:00,000 --> 00:00:00,000
但它使你困惑
But it's really bothering you,

177
00:00:00,000 --> 00:00:00,000

and it's bothering you for a really good reason.

178
00:00:00,000 --> 00:00:00,000
Because when I write that, you're saying gee, this is, I know, sort of a procedure.

179
00:00:00,000 --> 00:00:00,000
But it's not a procedure that's just running. It's just sort of a procedure sitting there.

180
00:00:00,000 --> 00:00:00,000
And how can it be that sometimes this procedure has 37 and 49,

181
00:00:00,000 --> 00:00:00,000
and there might be another one which has 5 and 6 in there, and why don't they get confused?

182
00:00:00,000 --> 00:00:00,000
So there's something very, very important that's bothering you.

183
00:00:00,000 --> 00:00:00,000
And it's really crucial to what's going on.

184
00:00:00,000 --> 00:00:00,000
It's, we're suddenly saying that procedures are not just the act of doing something.

185
00:00:00,000 --> 00:00:00,000
Procedures are conceptual entities, objects,

186
00:00:00,000 --> 00:00:00,000
and if I built cons of 37 and 49, that's a particular procedure that sits there.

187
00:00:00,000 --> 00:00:00,000
And it's different from cons of 3 and 4. That's another procedure that sits there.

188
00:00:00,000 --> 00:00:00,000
学生：它们都是独立存在的
AUDIENCE: Both of them exist independently.

189
00:00:00,000 --> 00:00:00,000
教授：对 独立存在
PROFESSOR: And exists independently.

190
00:00:00,000 --> 00:00:00,000
学生：可以通过car和cdr被引用
AUDIENCE: And they both can be referenced by car and cdr.

191
00:00:00,000 --> 00:00:00,000
教授：它们都可以通过car和cdr被引用。
PROFESSOR: And they both would be referenced by car and cdr.

192
00:00:00,000 --> 00:00:00,000
我可以增加这个 也可以增加那个
Just like I could increment this, and I could increment that.

193
00:00:00,000 --> 00:00:00,000
它们都是对象 #TBD
They're objects. And that's sort of where we're going.

194
00:00:00,000 --> 00:00:00,000
而你之所以这样问 正是体现了
See, the fact that you're asking the question shows that

195
00:00:00,000 --> 00:00:00,000
#TBD
you're really starting to think about the implications of what's going on.

196
00:00:00,000 --> 00:00:00,000
过程不仅仅只是说做某件事的行为
It's the difference between saying a procedure is just the act of doing something.

197
00:00:00,000 --> 00:00:00,000
任何过程都是一个存在着的真实对象
And a procedure is a real object that has existence.

198
00:00:00,000 --> 00:00:00,000
学生：也就是说过程在构建是
AUDIENCE: So when the procedure gets built,

199
00:00:00,000 --> 00:00:00,000
a和b的确切值就被代换进去了
the actual values are now substituted for a and b--

200
00:00:00,000 --> 00:00:00,000
教授：是的
PROFESSOR: That's right.

201
00:00:00,000 --> 00:00:00,000
学生：那些以lambda形式存在的过程
AUDIENCE: And then that procedure exists as lambda,

202
00:00:00,000 --> 00:00:00,000
而pick实际上已经被传递进去了
and pick is what's actually passed in.

203
00:00:00,000 --> 00:00:00,000
教授：是的 当cons过程被调用时
PROFESSOR: Yes, when cons gets called,

204
00:00:00,000 --> 00:00:00,000
cons就返回了一个新构造好的过程
and the result of cons is a new procedure that's constructed,

205
00:00:00,000 --> 00:00:00,000
而这个新过程有一个叫做pick的参数
that new procedure has an argument that's called pick.

206
00:00:00,000 --> 00:00:00,000
学生：但是就不再有a和b了
AUDIENCE: But it no longer has an a and b.

207
00:00:00,000 --> 00:00:00,000
a和b的确切值在那时就被传递进去了
The a and b are the actual values that are passed through.

208
00:00:00,000 --> 00:00:00,000
教授：根据代换模型 是这样的
PROFESSOR: And it has-- right, according to the substitution model,

209
00:00:00,000 --> 00:00:00,000
现在它不再具有这些可变的名字a和b #TBD
what it now has is not those arbitrary names a and b,

210
00:00:00,000 --> 00:00:00,000
取而代之的则是37和49
it somehow has that 37 and 49 in there.

211
00:00:00,000 --> 00:00:00,000
但你是对的 把这件事想清楚很困难
But you're right, that's a hard thing to think about it,

212
00:00:00,000 --> 00:00:00,000

and it's different from the way you've been thinking about procedures.

213
00:00:00,000 --> 00:00:00,000
学生：如果我再次调用(cons 37 49) 是否得到了一个不同的 #TBD
AUDIENCE: And if I have again cons of 37 and 49, it's a different [UNINTELLIGIBLE]?

214
00:00:00,000 --> 00:00:00,000
教授：如果你再次调用(cons 37 49)
PROFESSOR: And if you make another cons of 37 and 49,

215
00:00:00,000 --> 00:00:00,000
你就陷入了一个深刻的哲学问题
you're into a wonderful philosophical problem,

216
00:00:00,000 --> 00:00:00,000
这个将是我们整个课程中段将讨论的问题
which is going to be what the lecture about halfway through this course is about.

217
00:00:00,000 --> 00:00:00,000
也就是说 我调用(cons 37 49) 然后我再调用一次
Which is, if I cons 37 and 49, and I do it again,

218
00:00:00,000 --> 00:00:00,000
这两者是同一个东西还是不同的东西呢？
is that the same thing, or is it a different thing?

219
00:00:00,000 --> 00:00:00,000
And how could you tell? And when could it possibly matter?

220
00:00:00,000 --> 00:00:00,000
And that's sort of like saying, is that the same thing as this?

221
00:00:00,000 --> 00:00:00,000
Or is this the same thing as that?

222
00:00:00,000 --> 00:00:00,000
It's the same kind of question.

223
00:00:00,000 --> 00:00:00,000
这将是一个非常非常深刻的问题
And that's a very, very deep question.

224
00:00:00,000 --> 00:00:00,000
我没法在一小时内讲清楚 但我们以后会讨论
And I can't answer in less than an hour. But we will.

225
00:00:00,000 --> 00:00:00,000
系统只给了我们单个的数字
So we said that the system gives us individual numbers,
哈尔滨工业大学 IBM技术中心
倾情制作

226
00:00:00,000 --> 00:00:03,060
哈尔滨工业大学 IBM技术中心
倾情制作

227
00:00:03,220 --> 00:00:05,440
压制&&特效：蔡钟毓（JohnTitor）
字幕&&时间轴：邓雄飞（Dysprosium）

228
00:00:05,560 --> 00:00:07,440
特别感谢：裘宗燕教授
校对：曹竞帆（ChingfanTsou）

229
00:00:07,700 --> 00:00:10,320
复合过程

230
00:00:21,720 --> 00:00:25,020
到目前为止 我们这门课讨论的都是过程
Well, so far in this course we've been talking about procedures,

231
00:00:25,920 --> 00:00:27,900
而我想提醒大家的是 我们介绍的这个框架
and then just to remind you of this framework

232
00:00:29,040 --> 00:00:30,840
是用来讨论语言的
that we introduced for talking about languages,

233
00:00:30,840 --> 00:00:34,800
我们讨论内建于系统中的基本元素
we talked about the primitive things that are built into the system.

234
00:00:35,540 --> 00:00:37,620
我们介绍了一些组合的方法
We mentioned some means of combination

235
00:00:38,660 --> 00:00:41,540
这些方法用来组合基本元素使你能够构造更复杂的东西
by which you take the primitive thingsand you make more complicated things.

236
00:00:42,200 --> 00:00:43,960
然后我们讨论了抽象的方法
And then we talked about the means of abstraction,

237
00:00:43,960 --> 00:00:46,220
你如何去取用这些复杂的东西
how you can take those complicated things and name them

238
00:00:46,560 --> 00:00:48,220
并且给它们命名 使得可以像简单单元那样使用它  # TBD
so you can use them as simple building blocks.

239
00:00:49,320 --> 00:00:51,560
上节课的最后 我们甚至做了更超前的东西
And then last time you saw we went even beyond that.

240
00:00:51,560 --> 00:00:54,140
我们看到 通过使用高阶过程
We saw that by using higher order procedures,

241
00:00:55,200 --> 00:00:57,800
我们甚至可以表达计算的通用方法
you can actually express general methods for computing things.

242
00:00:57,800 --> 00:01:02,160
这就像求不动点的方法和牛顿法
Like the method of doing something by fixed points, or Newton's method,

243
00:01:02,940 --> 00:01:05,500
你可以通过组合这些抽象的方法
and so the incredible expressive power you can get

244
00:01:05,760 --> 00:01:08,280
来得到这种难以执行的表达力 # TBD
just by combining these means of abstraction.

245
00:01:08,280 --> 00:01:11,820
而这些的中心观点则是
And the crucial idea in all of this is

246
00:01:11,820 --> 00:01:14,220
我们要构建一个层次系统 # TBD
the one that we build a layered system.

247
00:01:14,900 --> 00:01:15,940
譬如说
So for instance,

248
00:01:16,180 --> 00:01:18,080
如果我们编写平方根过程
if we're writing the square root procedure,

249
00:01:20,880 --> 00:01:25,920
而这个平方根过程又用到了一个叫good-enough的过程
somewhere the square root procedure uses a procedure called good-enough,

250
00:01:31,080 --> 00:01:35,060
而这两者之间就有某种抽象边界 # TBD
and between those there is some sort of abstraction boundary.

251
00:01:37,640 --> 00:01:40,980
这大概就像是我们开始编写平方根程序
It's almost as if we go out and in writing square root,

252
00:01:40,980 --> 00:01:43,640
先要与George订好“契约”
we go and make a contract with George,

253
00:01:44,760 --> 00:01:46,940
告诉他 他的工作是编写good-enough过程
and tell George that his job is to write good-enough,

254
00:01:48,660 --> 00:01:50,320
因此只要good-enough按我们的预期运作
and so long as good-enough works,

255
00:01:50,320 --> 00:01:51,460
我们就不管是如果运作的
we don't care what it does.

256
00:01:52,320 --> 00:01:54,220
我们不关心（它的内部）实现
We don't care exactly how it's implemented.

257
00:01:54,220 --> 00:01:58,880
这里的实现层面是Goerge操心的 和我们无关
There are levels of detail here that are George's concern and not ours.

258
00:02:00,100 --> 00:02:00,900
譬如说
So for instance,

259
00:02:00,900 --> 00:02:05,440
George如果用了Harry写的绝对值过程
George might use an absolute value procedure that's written by Harry,

260
00:02:06,240 --> 00:02:07,440
我们不会去关心这些
and we don't much care about that

261
00:02:07,440 --> 00:02:09,940
我们甚至可能还不知道有Harry这号人
or even know that, maybe, Harry exists.

262
00:02:13,500 --> 00:02:16,320
关键点是当我们在构造东西时
So the crucial idea is that when we're building things,

263
00:02:16,320 --> 00:02:23,740
我们将构造整体的任务划分为了实现部件的任务
we divorce the task of building things from the task of implementing the parts.

264
00:02:26,340 --> 00:02:28,740
当然 在一个大型系统中
And in a large system, of course,

265
00:02:28,740 --> 00:02:30,580
我们有像这样的抽象屏障
we have abstraction barriers like this

266
00:02:30,920 --> 00:02:32,580
在很高很高很高层次上的抽象屏障
at lots, and lots, and lots of levels.

267
00:02:33,780 --> 00:02:35,980
这也是我们到目前为止一直在使用的思想
And that's the idea that we've been using so far

268
00:02:35,980 --> 00:02:37,740
贯彻到每次编写过程之中
over and over in implementing procedures.

269
00:02:37,740 --> 00:02:42,360
书归正传 我们将要在数据中看到同样的问题
Well, now what we're going to do is look at the same issues for data.

270
00:02:43,760 --> 00:02:46,100
我们将看到系统中有基本数据
We're going to see that the system has primitive data.

271
00:02:46,100 --> 00:02:47,180
实际上我们已经看到了
In fact, we've already seen that.

272
00:02:47,180 --> 00:02:48,960
我们已经看到了作为基本对象的数字
We've talked about numbers as primitive data.

273
00:02:49,940 --> 00:02:52,120
我们将看到适用于数据的组合方法
And then we're going to see their means of combination for data.

274
00:02:52,120 --> 00:02:55,620
有种“胶水” 让你把基本数据粘合在一起
There's glue that allows you to put primitive data together

275
00:02:56,040 --> 00:02:58,720
来构造一种更复杂的符合数据
to make more complicated, kind of compound data.

276
00:02:59,160 --> 00:03:03,700
然后我们将看到一种用于抽象的方法
And then we're going to see a methodology for abstraction

277
00:03:04,600 --> 00:03:06,040
这种方法十分好用 尤其是
that's a very good thing to use

278
00:03:06,040 --> 00:03:08,480
当你开始用简易的数据构造复杂数据时
when you start building up data in terms of simpler data.

279
00:03:08,480 --> 00:03:12,560
再次强调 中心思想是要建立层次化的系统
And again, the key idea is that you're going to build the system in layers

280
00:03:13,420 --> 00:03:17,860
建立抽象屏障将细节隔离在低层
and set up abstraction barriers that isolate the details at the lower layers

281
00:03:19,560 --> 00:03:21,280
将细节与你所工作的高层环境隔离开
from the thing that's going on at the upper layers.

282
00:03:21,280 --> 00:03:24,120
低层的细节 低层的思想 都不重要
The details at the lower layers, the ideas, they won't matter.

283
00:03:24,920 --> 00:03:26,260
那是George该操心的
They're going to be George's concern

284
00:03:26,520 --> 00:03:28,160
因为他跟我们“订好契约”
because he signed this contract with us

285
00:03:28,480 --> 00:03:30,560
他负责实现这些行为
for how the stuff that he implements behaves,

286
00:03:31,640 --> 00:03:34,120
怎么实现都是他的事
and how he implements the thing is his problem.

287
00:03:35,960 --> 00:03:37,360
好了 来看一个实例吧
All right, well let's look at an example.

288
00:03:37,480 --> 00:03:40,320
我们将会讨论一个系统
And the example I'm going to talk about is a system

289
00:03:40,400 --> 00:03:42,560
一个在有理数域上做算术运算的系统
that does arithmetic on rational numbers.

290
00:03:42,560 --> 00:03:44,300
我现在所想到的是
And what I have in mind is that

291
00:03:44,660 --> 00:03:46,520
计算机中应该有某种东西
we should have something in the computer

292
00:03:46,860 --> 00:03:50,340
使得我们可以查询
that allows us to ask it,

293
00:03:50,340 --> 00:03:55,160
比如说1/2加上1/4的和是多少
like, what's the sum of 1/2 and 1/4,

294
00:03:55,520 --> 00:04:01,220
系统就会说 是3/4
and somehow the system should say, yeah, that's 3/4.

295
00:04:02,520 --> 00:04:09,400
我们也可以查询3/4乘以2/3的积
Or we should be able to say what's 3/4 times 2/3,

296
00:04:10,720 --> 00:04:13,400
系统因该能够回答 结果是1/2
and the system should be able to say, yeah, that's 1/2.

297
00:04:16,100 --> 00:04:17,700
对吧？ 你知道我想表达的意思
Right? And you know what I have in mind.

298
00:04:17,700 --> 00:04:20,240
我不太确定你们是多久掌握这些运算的
And you also know how to do this from, I don't know,

299
00:04:20,240 --> 00:04:21,480
五年级或者六年级吧？
fifth grade or sixth grade.

300
00:04:21,900 --> 00:04:23,420
这有一些公式说
There are these formulas that say

301
00:04:23,420 --> 00:04:28,020
分数（有理数）是分子除以分母
if I have some fraction which is a numerator over a denominator,

302
00:04:28,200 --> 00:04:31,100
而如果我要将这个分数与另一个分数相加的话
and I want to add that to some other fraction

303
00:04:31,360 --> 00:04:34,600
当然 这个分数也是分子除以分母
which is another numerator over another denominator,

304
00:04:34,980 --> 00:04:38,380
那么结果将会是 第一个分数的分子
then the answer is the numerator of the first

305
00:04:39,020 --> 00:04:40,980
乘以第二个分数的分母
times the denominator of the second,

306
00:04:41,680 --> 00:04:46,300
加上第二个分数的分子乘以第一个分数的分母
plus the numerator of the second times the denominator of the first.

307
00:04:48,100 --> 00:04:49,380
当然 这只是答案的分子
That's the numerator of the answer,

308
00:04:49,380 --> 00:04:52,860
答案的分母是两个分数的分母之积
and the denominator is the product of the two denominators.

309
00:04:52,860 --> 00:04:57,040
对吧？ 这大概就是五、六年级课程的分数算术
Right? So there's something from fifth or sixth grade fraction arithmetic.

310
00:04:57,040 --> 00:04:59,360
与之相似的 如果我想要将两个数乘起来
And then similarly, if I want to multiply two things,

311
00:04:59,360 --> 00:05:04,600
n1除以d1的商 乘以 n2除以d2的商
n1 over d1 multiplied by n2 over d2

312
00:05:05,460 --> 00:05:10,600
就是两个分数的分子之积除以两个分母之积的商
is the product of the numerators over the product of the denominators.

313
00:05:14,020 --> 00:05:15,160
所以这些都不构成问题
So it's no problem at all,

314
00:05:16,380 --> 00:05:17,860
当然 理解这些
but it's absolutely no problem to

315
00:05:18,420 --> 00:05:20,580
你想进行的分数运算
think about what computation you want to make

316
00:05:20,580 --> 00:05:22,480
是完全没问题的
in adding and multiplying these fractions.

317
00:05:23,460 --> 00:05:26,840
但是当我们实现这个功能的时候 我们似乎错过了什么
But as soon as we go to implement it, we run up across something.

318
00:05:27,560 --> 00:05:31,560
我们连有理数都没有
We don't have what a rational number is.

319
00:05:32,960 --> 00:05:38,220
比如5和3
so we said that the system gives us individuals number so we can have 5 and 3,

320
00:05:38,840 --> 00:05:42,700
但我们没有去表达一个
but somehow we don't have a way of

321
00:05:43,180 --> 00:05:46,820
同时具有一个3和一个4的东西
saying there's a thing that has both a 3 and a 4 in it,

322
00:05:47,380 --> 00:05:49,340
或者一个2和一个3的东西
or both a 2 and a 3.

323
00:05:49,340 --> 00:05:53,220
但只要我们去想象
It's almost as if we'd like to imagine

324
00:05:53,380 --> 00:05:55,640
我们就会看到一些云彩
that somehow there are these clouds,

325
00:05:57,280 --> 00:06:01,840
某个云彩不知咋的同时具有分子和分母
and a cloud somehow has both a numerator and a denominator in it,

326
00:06:02,060 --> 00:06:03,960
这就是我们想有的语言形式 #TBD
and that's what we'd like to work in terms of.

327
00:06:06,500 --> 00:06:07,980
那么 我们要怎么解决这个问题呢？
Well, how are we going to solve that problem?

328
00:06:07,980 --> 00:06:13,100
我们将使用一种强大的设计策略来解决这个问题
We're going to solve that problem by using this incredibly powerful design strategy

329
00:06:13,520 --> 00:06:15,560
这种策略我们已经反复使用过了
that you've already seen us use over and over.

330
00:06:16,180 --> 00:06:18,160
这就是按愿望思维 #TBD
And that's the strategy of wishful thinking.

331
00:06:25,340 --> 00:06:27,340
就像我们之前并没有任何过程一样
Just like before when we didn't have a procedure,

332
00:06:27,340 --> 00:06:30,380
我们就想象确实存在着某个过程
we said, well, let's imagine that that procedure already exists.

333
00:06:30,980 --> 00:06:34,040
那么 我们就来想象我们有了（有理数）这些云彩吧
We'll say, well, let's imagine that we have these clouds.

334
00:06:35,720 --> 00:06:37,820
更准确一点来说
Now more precisely what I mean is

335
00:06:38,820 --> 00:06:43,180
让我们假设我们有了三个过程
let's imagine that we have three procedures，

336
00:06:43,960 --> 00:06:45,240
其一为MAKE-RAT
one called MAKE-RAT.

337
00:06:47,340 --> 00:06:53,120
MAKE-RAT有两个参数
MAKE-RAT is going to take as arguments two numbers,

338
00:06:54,200 --> 00:06:55,820
我们分别把它们叫作分子和分母
so I'll call them numerator and denominator,

339
00:06:57,620 --> 00:07:03,400
它给我们返回一朵云彩——我们需要的云彩
and it'll return for us a cloud-- one of these clouds.

340
00:07:04,860 --> 00:07:06,420
我并不知道云彩是什么
I don't really know what a cloud is.

341
00:07:06,660 --> 00:07:09,160
无论MAKE-RAT返回什么 那都是它的事
It's whatever MAKE-RAT returns, that's its business.

342
00:07:11,060 --> 00:07:11,960
并且我们将会说
And then we're going to say,

343
00:07:12,080 --> 00:07:13,520
假设我们有了一个这种云彩
suppose we've got one of these clouds,

344
00:07:13,780 --> 00:07:15,740
我们有个叫NUMER的过程
we have a procedure called NUMER,

345
00:07:16,720 --> 00:07:19,900
这个过程需要我们传递有n和a的云彩
which takes in a cloud that has an n and a d in it,

346
00:07:19,920 --> 00:07:21,820
不管这个云彩是什么 我不知道这个云彩是什么
whatever a cloud is, and I don't know what it is,

347
00:07:22,780 --> 00:07:24,440
但NUMBER过程会返回（云彩的）分子部分
and returns for us the numerator part.

348
00:07:26,760 --> 00:07:28,900
我们也会假设我们有个叫DENOM的过程
And then we'll assume we have a procedure DENOM,

349
00:07:30,820 --> 00:07:33,560
该过程需要我们传递一个云彩 不管云彩是什么
which again takes in a cloud, whatever a cloud is,

350
00:07:34,880 --> 00:07:37,480
并返回（云彩的）分母部分
and returns for us the denominator part.

351
00:07:37,480 --> 00:07:42,480
就像先前我们构造平方根过程一样
This is just like before, when if we're building a square root,

352
00:07:42,560 --> 00:07:43,860
我们假设我们有GOOD-ENOUGH过程
we assume that we have good-enough.

353
00:07:45,020 --> 00:07:48,520
对吧？ 我们会找到George 对他说
Right? And what we'll say is, we'll go find George, and we'll say to George,

354
00:07:48,700 --> 00:07:50,780
那么 你的任务就是实现这三个过程
well, it's your business to make us these procedures.

355
00:07:51,920 --> 00:07:54,440
你选择如何实现这些云彩 就是你的事了
And how you choose to implement these clouds, that's your problem.

356
00:07:54,660 --> 00:07:55,380
我们不想知道
We don't want to know.

357
00:07:58,500 --> 00:08:02,100
这样 把这些杂事都推给George后
Well, having pushed this task off onto George,

358
00:08:03,120 --> 00:08:05,080
完成其它部分就相当容易了
then it's pretty easy to do the other part.

359
00:08:05,080 --> 00:08:08,180
一旦我们有了这些云彩后 编写那些
Once we've got the clouds, it's pretty easy to write the thing

360
00:08:08,180 --> 00:08:10,500
把有理数加起来的程序就变得容易多了
that does say addition of rational numbers.

361
00:08:11,340 --> 00:08:17,980
你可以定义 这么说吧 定义+RAT
You can just say define, well, let's say +RAT.

362
00:08:22,080 --> 00:08:27,660
定义+RAT过程 该过程需要两个有理数参数 x和y
Define +RAT, which will take in two rational numbers, x and y.

363
00:08:27,760 --> 00:08:30,340
x和y就是这些云彩
x and y are each these clouds.

364
00:08:31,520 --> 00:08:32,460
这个过程干些啥呢？
And what does it do? Well

365
00:08:32,760 --> 00:08:35,580
它将返回给我们一个有理数
it's going to return for us a rational number.

366
00:08:39,980 --> 00:08:41,340
这个有理数是怎么得来的呢？
What rational number is it? Well,

367
00:08:41,880 --> 00:08:43,220
依据这里的公式
we've got the formulas there.

368
00:08:43,340 --> 00:08:45,760
结果的分子的一部分为
The numerator of it is the sum of

369
00:08:47,020 --> 00:08:56,340
x的分子与y的分母之积
the product of the numerator of x and the denominator of y.

370
00:09:02,220 --> 00:09:03,360
这只是结果的分子的一部分
It's one thing in the sum.

371
00:09:03,600 --> 00:09:06,180
结果的分子剩下的一部分是
And the other thing in the numerator is

372
00:09:06,260 --> 00:09:16,960
y的分子与x的分母之积
the product of the numerator of y and the denominator of x.

373
00:09:18,800 --> 00:09:20,080
闭合* 闭合+
The star, close the plus.

374
00:09:20,500 --> 00:09:23,380
好了 这是MAKE-RAT的第一个参数
Right, that's the first argument to MAKE-RAT,

375
00:09:23,380 --> 00:09:25,380
这是我将要构造的云彩的分子
which is the numerator of the thing I'm constructing.

376
00:09:26,220 --> 00:09:28,460
而MAKE-RAT剩下的参数
And then the rest of the thing goes into MAKE-RAT is

377
00:09:28,460 --> 00:09:30,340
则是结果的分母
the denominator of the answer,

378
00:09:30,380 --> 00:09:40,860
也就是x的分母乘以y的分母
which is the product of the denominator of x and the denominator of y.

379
00:09:41,960 --> 00:09:42,600
像这样
Like that.

380
00:09:45,440 --> 00:09:51,320
好 这就是对有理数加法的一个模拟
OK? So there is the analog of doing rational number addition.

381
00:09:51,380 --> 00:09:54,780
在假设我们有了这些云彩后 就变得完全没有问题
And it's no problem at all, assuming that we have these clouds.

382
00:09:59,000 --> 00:10:02,060
当然 我们可以用同样的方法把它们乘起来
And of course, we can do multiplication in the same way.

383
00:10:05,240 --> 00:10:11,900
我们把将两个有理数乘起来定义为*RAT
Define how to get the product of two rational numbers, call it *RAT.

384
00:10:12,800 --> 00:10:16,140
该过程需要两朵云彩 x和y
Takes in two of these clouds, x and y,

385
00:10:19,540 --> 00:10:21,540
返回一个用MAKE-RAT构造的有理数
it returns a rational number, MAKE-RAT,

386
00:10:24,280 --> 00:10:27,460
这个有理数的分子是
whose numerator is the product of the numerators--

387
00:10:30,040 --> 00:10:36,220
x的分子与y的分子之积
numerator of x times the numerator of y.

388
00:10:37,820 --> 00:10:40,780
而这个有理数的分母则是
And the denominator of the thing it's going to return

389
00:10:41,200 --> 00:10:42,780
x的分母与y的分母之积
is the product of the denominators.

390
00:10:57,120 --> 00:11:01,520
11:04 #TBD
Well, except that I haven't told you what these clouds are,

391
00:11:02,560 --> 00:11:04,860

that's all there is to it. See, what did I do?

392
00:11:04,960 --> 00:11:09,180
我按照我的期许假设我有一种新的数据类型
I assumed by wishful thinking that I had a new kind of data object.

393
00:11:09,940 --> 00:11:15,100
特别的 我假设我有创建这些数据类型的能力
And in particular, I assumed I had ways of creating these data objects.

394
00:11:15,920 --> 00:11:17,780
这里的MAKE-RAT就创建了一个新的数据类型
MAKE-RAT creates one of these things.

395
00:11:17,780 --> 00:11:18,940
这叫作“构造函数”
This is called a constructor.

396
00:11:25,300 --> 00:11:28,980
我现在有了可以构造这些数据类型的东西了
All right, I have a thing that constructs such data objects.

397
00:11:29,380 --> 00:11:34,200
然后我假设我有某些东西 有了这些东西后
And then I assume I have things that, having made these things,

398
00:11:34,200 --> 00:11:37,680
我就可以从中抽取部分信息的方法了 这些叫作选择函数”
I have ways of getting the parts out. Those are called selectors.

399
00:11:42,460 --> 00:11:44,540
把之前我所说的更加正式化一点 就是说
And so formally, what I said is I assumed

400
00:11:44,540 --> 00:11:48,660
我假设我有了用于处理这些数据类型的构造函数和选择函数
I had procedures that are constructors and selectors for these data objects,

401
00:11:48,660 --> 00:11:49,940
那我就可以使用它们 # TBD - Went off
and then I went off and used them.

402
00:11:51,700 --> 00:11:55,580
这就和我说我假设我有GOOD-ENOUGH?过程
That's no different in kind from saying I assume I have a procedure GOOD-ENOUGH?,

403
00:11:56,000 --> 00:11:57,800
并用它来实现平方根这种做法没有区别
and I go use it to implement square root.

404
00:12:00,420 --> 00:12:01,840
好 在我们继续之前
OK, well before we go on,

405
00:12:04,520 --> 00:12:08,020
让我们来想想 为什么我们首先就在这个地方实现了这些东西？
let's ask the question of why do we want to do this in the first place?

406
00:12:08,360 --> 00:12:12,200
为什么我们需要一个像+RAT一样的过程
See, why do we want a procedure like, like +RAT

407
00:12:13,260 --> 00:12:19,280
一个需要两个有理数作为参数并返回一个有理数的过程
that takes in two rational numbers and returns a rational number?

408
00:12:19,960 --> 00:12:22,620
换一种想法就是 我们实现的是这里的这个公式
See, another way to think about this is, well, here's this formula.

409
00:12:24,780 --> 00:12:28,760
这里我也实现了用于加和两个有理数的东西
And I've also got to implement something that adds rational numbers.

410
00:12:29,520 --> 00:12:31,680
再换一种想法就是 这有这么一个东西
One other way to think about is, well, there's this thing,

411
00:12:31,860 --> 00:12:35,660
可以让我输入四个数 n1 d1 n2 d2
and I type in four numbers, an n1, and a d1, and an n2, and a d2.

412
00:12:36,240 --> 00:12:38,020
然后这个东西就修改机器里的寄存器
And it sets some registers in the machine

413
00:12:38,300 --> 00:12:42,120
来代表分子和分母
to a, this numerator and this denominator.

414
00:12:42,120 --> 00:12:42,920
所以你大概会问
So I might say, well,

415
00:12:43,020 --> 00:12:45,600
你为什么不用四个分别代表分子和分母的数
why don't I just add rational numbers by I type in four numbers,

416
00:12:45,740 --> 00:12:46,880
来做有理数加法
numerators and denominators,

417
00:12:46,880 --> 00:12:49,340
这个加法返回两个数 分别代表分子和分母
and get out two numbers, which is a numerator and a denominator.

418
00:12:50,480 --> 00:12:54,840
我们为什么要关心像这样构造东西？ #TBD
Why are we worrying about building things like this anyway?

419
00:12:58,380 --> 00:12:59,700
呃 那是因为
Well, the answer is,

420
00:12:59,820 --> 00:13:05,720
假设你想表达像这样的东西
suppose you want to think about expressing something like this,

421
00:13:05,780 --> 00:13:11,740
假设我想表达“采用”两个有理数的思想
suppose I'd like to express the idea of taking two rational numbers,

422
00:13:12,980 --> 00:13:21,340
x加y的和乘以s加上t的和
x plus y, say, and multiplying that by the sum of two other rational numbers.

423
00:13:23,300 --> 00:13:27,380
然而 当我有了像+RAT和*RAT这样的东西后
Well, the way I do it, having things like +RAT and *RAT,

424
00:13:28,200 --> 00:13:33,520
我就会将其考虑为乘积
is I'd say, oh yeah, what that is is just the product.

425
00:13:33,600 --> 00:13:49,060
就是将*RAT应用于x和y的和以及s和t的和上
That's *RAT of the sum of x and y and the sum of s and t.

426
00:13:51,260 --> 00:13:55,320
除了语法 我还能得到一个表达式 # TBD
So except for syntax, I get an expression

427
00:13:55,620 --> 00:13:59,200
这个表达式看起来像是按照数学思想表达的
that looks like the way I want to think about it mathematically.

428
00:13:59,540 --> 00:14:03,420
我说这有两个数 这个东西代表了这两个数的和
I want to say there are two numbers. There's a thing which is the sum of them,

429
00:14:05,300 --> 00:14:07,360
然而这个东西又代表了另两个数的和
and there's a thing which is the sum of these two.

430
00:14:08,000 --> 00:14:10,440
就是这个和这个
That's this and this.

431
00:14:10,440 --> 00:14:11,700
然后我把它们乘起来
And then I multiply them.

432
00:14:12,200 --> 00:14:14,200
所以我有了一个和这里的表达式相匹配的表达式
So I get an expression that matches this expression.

433
00:14:14,200 --> 00:14:16,680
而如果我用其它的方式去表达
If I did the other thing, if I said, well,

434
00:14:16,680 --> 00:14:20,160
我表达为 我传递向机器传递四个数
the way I want to think about this is I type into my machine four numbers,

435
00:14:20,320 --> 00:14:22,860
四个分别代表x和y的分子、分母的数
which are the numerators and the denominators of x and y,

436
00:14:23,800 --> 00:14:28,000
然后又是四个分别代表s和t的分子、分母的数
and then four more numbers, which are the numerators and denominators of s and t.

437
00:14:28,780 --> 00:14:30,780

And then what I'd be sitting with is, well, what would I do?

438
00:14:31,000 --> 00:14:34,560
我把这些加起来 不知咋的我们就得到了两个临时变量
I'd add these, and somehow I'd have to have two temporary variables,

439
00:14:35,240 --> 00:14:37,440
分别代表了和的分子、分母
which are the numerators and denominators of this sum,

440
00:14:37,960 --> 00:14:39,600
我又得去找个地方把它们存储起来
and I'd go off and store them someplace.

441
00:14:42,140 --> 00:14:44,200
然后到了这里 我又传入了四个数
And then I'd go over here, I'd type in four more numbers,

442
00:14:44,200 --> 00:14:45,960
我又有了两个临时变量
I'd get two more temporary variables,

443
00:14:46,480 --> 00:14:48,720
分别代表了s和t之和的分子和分母
which are the numerators and denominators of s and t.

444
00:14:49,820 --> 00:14:52,860
最后 我通过把它们乘起来来将其结合在一起
And then finally, I put those together by multiplying them.

445
00:14:54,620 --> 00:14:56,120
如你所见 麻烦出来了
You see, what's starting to happen,

446
00:14:56,140 --> 00:14:57,700
这里满是临时变量
there are all these temporary variables,

447
00:14:58,180 --> 00:15:02,780
这些应该是这些有理数内部的“内脏”吧
which are sort of the guts of the internals of these rational numbers

448
00:15:02,780 --> 00:15:04,900
但却显露在我们的系统中
that start hanging out all over the system.

449
00:15:05,860 --> 00:15:08,240
当然 随着表达式变得越来越复杂
And of course, if I had more and more complicated expressions,

450
00:15:08,240 --> 00:15:11,500
这些“内脏”就会显露得越来越多 使我编程时感到困惑
there'd be more and more guts hanging out that confuse my programming.

451
00:15:12,620 --> 00:15:15,540
像这样写程序的人
And those of you who sort of programmed things like that,

452
00:15:15,540 --> 00:15:18,140
你只是在用汇编语言的思想来加和两数
where you're just adding numbers in assembly language,

453
00:15:18,140 --> 00:15:21,060

you sort of see you have to suddenly be concerned with these temporary variables.

454
00:15:22,680 --> 00:15:29,200
而这些对我大脑造成的困惑 要比对编程造成的困惑更严重
But more importantly than confusing my programming, they're going to confuse my mind.

455
00:15:29,620 --> 00:15:31,480

Because the whole name of this game

456
00:15:33,140 --> 00:15:35,420
我们希望程序设计语言能够表达
is that we'd like the programming language

457
00:15:36,820 --> 00:15:39,100
我们脑中的概念
to express the concepts that we have in our heads,

458
00:15:39,320 --> 00:15:41,780
有理数就是这些概念
like rational numbers are things hat you can add

459
00:15:42,620 --> 00:15:44,540
我们可以先把它们加起来然后再乘起来
tand then take that result and multiply them.

460
00:15:48,360 --> 00:15:49,300
有疑问吗？
Let's break for questions.

461
00:15:57,380 --> 00:15:57,780
恩
Yeah?

462
00:15:59,680 --> 00:16:01,480
学生：我不太明白为什么
AUDIENCE: Ya, I don't quite see the need-

463
00:16:01,480 --> 00:16:04,140
既然我们有MAKE-RAT过程了
when we had MAKE-RAT with the numerator and denominator,

464
00:16:04,140 --> 00:16:08,440
我们将传递两个参数作为分子和分母来构造一朵云彩
we had to have the numerator and denominator to pass as parameters to create the cloud,

465
00:16:08,440 --> 00:16:11,040
但最后我们又从中将这些东西给抽取出来
and then we extracted to get back what we had to have originally.

466
00:16:11,360 --> 00:16:11,980
教授：是这样的
PROFESSOR: That's right.

467
00:16:13,380 --> 00:16:16,600
我们的问题是 既然我们是用分子和分母构造云彩
So the question is, I sort of have the numerator and the denominator,

468
00:16:17,080 --> 00:16:21,720
但我为什么又想从云彩里面把它们取出来呢？
why am I worrying about having the cloud given that I have to get the pieces out?

469
00:16:23,280 --> 00:16:26,640
这个是我在后面提到过的 不过让我在说一次吧
That's sort of what I tried to say at the end, but let me try and say it again,

470
00:16:26,640 --> 00:16:28,040
这个问题非常关键
because that's really the crucial question.

471
00:16:29,260 --> 00:16:32,980
关键点就是 我想让分子和分母
The point is, I want to carry this numerator and denominator around

472
00:16:34,100 --> 00:16:35,220
总是在一起
together all the time.

473
00:16:36,840 --> 00:16:38,740

And it's almost as if I want to know,

474
00:16:38,740 --> 00:16:40,640
这里面有分子和分母
yeah, there's a numerator and denominator in there,

475
00:16:40,640 --> 00:16:44,940
同样的 我也想表达
but also, I would like to say, fine,

476
00:16:45,400 --> 00:16:48,640
但是 从另一个角度来看 这就是x
but from another point of view, that's x.

477
00:16:49,860 --> 00:16:52,460
我可以取用x 我给它命名为x hold # TBD
And I carry x around, and I name it as x, and I hold it.

478
00:16:52,680 --> 00:16:55,160
然后我就可以说 x加上y的和
And I can say things like, the sum of x and y,

479
00:16:55,800 --> 00:16:58,540
我只考虑一个x的时候 使用代表分子和分母的数并无大碍
rather than just have-- see, it's not so bad when I only think about x,

480
00:16:59,260 --> 00:17:01,300
但是当我有10个有理数时
but if I have a system with 10 rational numbers,

481
00:17:01,600 --> 00:17:03,500
如果我不把它们联系起来
suddenly I have 20 numerators and denominators,

482
00:17:03,920 --> 00:17:06,220
我一下子就有了20个不必要的分子和分母
which are not necessarily-- if I don't link them,

483
00:17:06,220 --> 00:17:09,900
它们只是20个没有以一种特定方式联系起来的任意数而已
then it's just 20 arbitrary numbers that are not linked in any particular way.

484
00:17:10,080 --> 00:17:13,100
这就像是说
It's a lot like saying, well,

485
00:17:13,100 --> 00:17:15,260
这里我有这些过程体的指令
I have these instructions that are the body of the procedures,

486
00:17:15,260 --> 00:17:17,220
为什么我把它们封装起来作为一个过程
why do I want to package them and say it's the procedure?

487
00:17:17,620 --> 00:17:18,820
这是一码子事儿
It's exactly the same idea.

488
00:17:30,800 --> 00:17:34,100
没问题了 好吧
No more? OK.

489
00:17:34,560 --> 00:17:36,460
那休息一下 活动一下吧 [听不清]
Let's break, let's just stretch and get somebody-- [INAUDIBLE]

490
00:17:37,880 --> 00:17:43,240
[音乐]
[JESU, JOY OF MAN'S DESIRING]

491
00:17:45,380 --> 00:17:50,320
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

492
00:17:50,580 --> 00:17:55,440
讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
By: Prof. Harold Abelson && Gerald Jay Sussman

493
00:18:09,000 --> 00:18:16,680
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

494
00:18:18,800 --> 00:18:22,020
复合数据
Compound Data

495
00:18:26,700 --> 00:18:30,460
好吧 回到我们的有理数算术系统来
OK, well, we've been working on this rational number arithmetic system,

496
00:18:31,700 --> 00:18:35,240
而我们所做的 最重要的则是
and then what we did, the important thing about what we did,

497
00:18:35,320 --> 00:18:38,300
我们我们把这个问题分解为了两部分
is we thought about the problem by breaking it into two pieces.

498
00:18:39,780 --> 00:18:42,460
我们假设我们跟George“订好契约”
We said, assume there is this contract with George,

499
00:18:43,040 --> 00:18:46,320
George已经给出了如何去构造这些云彩
and George has figured out the way to how to construct these clouds,

500
00:18:47,640 --> 00:18:51,260
他给我们提供了一个作为构造函数的MAKE-RAT过程
provided us procedures MAKE-RAT, which was a constructor,

501
00:18:51,740 --> 00:18:54,600
相应的 用于提取分子和分母的选择函数
and selectors, which are numerator and denominator.

502
00:18:54,660 --> 00:18:55,460
然后 我们用这些东西
And then in terms of that,

503
00:18:55,460 --> 00:18:59,060
我们实现了有理数的加法和乘法
we went off and implemented addition and multiplication of rational numbers.

504
00:19:00,220 --> 00:19:02,420
好了 我们来看看George面临的问题吧
Well, now let's go look at George's problem.

505
00:19:03,100 --> 00:19:07,200
我们如何来把分子和分母给封装起来
How can we go and package together a numerator and a denominator

506
00:19:07,200 --> 00:19:08,540
并把它们放在“云彩”里
and actually make one of these clouds?

507
00:19:09,020 --> 00:19:11,160
我们需要的是一种胶水
See, what we need is a kind of glue,

508
00:19:12,440 --> 00:19:16,940
一种可以让我们把数据结合在一起的胶水
kind of a glue that, a glue for data objects that allows us to put things together.

509
00:19:17,740 --> 00:19:20,460
Lisp提供了这样的胶水
And Lisp provides such a glue,

510
00:19:21,680 --> 00:19:24,160
我们把它叫作“表结构”
and that glue is called list structure.

511
00:19:30,000 --> 00:19:33,060
表结构是一种将数据粘合在一起的工具
List structure is a way of gluing things together,

512
00:19:35,200 --> 00:19:36,080
说得更准确一点
and more precisely,

513
00:19:36,280 --> 00:19:41,260
就是Lisp提供了一种叫序对的构造方法 #TBD
Lisp provides a way of constructing things called pairs.

514
00:19:44,660 --> 00:19:50,800
Lisp里面有一个叫CONS的基本过程
There's a primitive operator in Lisp called CONS.

515
00:19:52,120 --> 00:19:53,140
让我们来看一下
We can take a look at it.

516
00:19:54,900 --> 00:19:56,940
这个就是CONS
There's a thing called CONS.

517
00:19:59,620 --> 00:20:04,160
CONS是一个运算符 它需要两个参数X和Y
Cons is an operator which takes in two arguments called x and y,

518
00:20:06,180 --> 00:20:08,400
它返回给我们一个叫作“序对”的东西
and it returns for us a thing called a pair.

519
00:20:11,220 --> 00:20:17,760
而所谓的“序对” 就是指它有“首部分”和“次部分” #TBD
All right, so a thing called a pair that has a first part a second part.

520
00:20:21,540 --> 00:20:23,120
这也解释了为什么CONS需要两个参数
So CONS takes two objects.

521
00:20:25,080 --> 00:20:26,140
如果我们有一个序对的话
There's a thing called a pair.

522
00:20:26,460 --> 00:20:31,140
X就是首部分 而Y就是次部分
The first part of the cons is X, and the second part of the cons is Y.

523
00:20:31,140 --> 00:20:32,120
这就是它的构造方式
And that's what it builds.

524
00:20:33,760 --> 00:20:36,220
我们同样也有把东西取出来的方法
And then we also assume we have ways of getting things out.

525
00:20:36,520 --> 00:20:38,880
给定一个序对 我们有一个叫CAR的东西
If you're given a pair, there's a thing called CAR,

526
00:20:41,600 --> 00:20:45,240
使得 序对P的CAR就是序对P的首部分
and car of a pair, P, gives you out the first part of the pair, P.

527
00:20:46,320 --> 00:20:47,280
也有一个叫CDR的东西
And there's a thing called CDR,

528
00:20:47,780 --> 00:20:51,620
而序对P的CDR 就返回序对P的次部分
and CDR of the pair, P, gives you the second part of the pair, p.

529
00:20:54,440 --> 00:20:56,020
这些就是我们构造数据的方法
OK, so that's how we construct things.

530
00:20:56,460 --> 00:21:01,900
在将这些数据用图画表示时 我们也有一种俗成的方法
There's also a conventional way of drawing pictures of these things.

531
00:21:02,480 --> 00:21:11,260
Just like we write down that as the conventional way of writing Plato's idea of two,

532
00:21:13,440 --> 00:21:20,920
the way we could draw a diagram to represent cons of two and three is like this.

533
00:21:21,600 --> 00:21:22,580
先画个小盒子
We draw a little box.

534
00:21:23,860 --> 00:21:25,600
这个就是我们讨论的（序对）
And so here's the box we're talking about,

535
00:21:26,300 --> 00:21:28,320
它用两个从中放出的箭头 #TBD
and this box has two arrows coming out of it.

536
00:21:29,620 --> 00:21:34,560
我们说 这个序对的首部分是2
And say the first part of this pair is 2,

537
00:21:34,800 --> 00:21:36,520
而这个序对的次部分是3
and the second part of this pair is 3.

538
00:21:37,920 --> 00:21:44,960
这种记法叫作“盒子—指针”记法
And this notation has a name, it's called box and pointer notation.

539
00:21:55,220 --> 00:21:56,940
顺带一提 我现在就来说说
Ok, By the way, let me say right now

540
00:21:57,140 --> 00:21:58,400
that a lot of people get confused

541
00:21:58,400 --> 00:22:03,240
that there's some significance to the geometric way I drew these pointers, the directions.

542
00:22:03,240 --> 00:22:05,960
一些人可能会认为 如果我这样画箭头
Like some people think it'd be different if I took this pointer

543
00:22:05,960 --> 00:22:08,360
并把3放在这里 结果会不一样
and turned it up here, and put the 3 out here.

544
00:22:08,360 --> 00:22:10,660
这实际上是没区别的 能理解吗？
That has no significance. Right?

545
00:22:11,200 --> 00:22:14,700
It's merely you have a bunch of arrows, these pointers, and the boxes.

546
00:22:14,700 --> 00:22:16,840
唯一的区别就在于它们是如何链接的
The only issue is how they're connected,

547
00:22:16,840 --> 00:22:21,300
而不是我把它们怎么放置 譬如向上放 向下放 或者交叉放
not the geometric arrangement of whether I write the pointer across, or up, or down.

548
00:22:23,220 --> 00:22:24,720

Now it's completely un-obvious,

549
00:22:25,720 --> 00:22:27,680

probably, why that's called list structure.

550
00:22:28,500 --> 00:22:31,560
我们今天不会讨论这个问题 我们下次再讨论吧
We're not actually going to talk about that today. We'll see that next time.

551
00:22:37,620 --> 00:22:40,920
所以 我们可以用CONS构造序对
So those are pairs, there's CONS that constructs them.

552
00:22:41,480 --> 00:22:44,920

And what I'm going to know about CONS, and CAR, and CDR,

553
00:22:45,260 --> 00:22:49,320

is precisely that if I have any X and Y,

554
00:22:50,240 --> 00:22:52,280
对任意的X和Y
right, if I have any things X and Y,

555
00:22:53,680 --> 00:22:55,980
我可以用CONS来构造一个序对
and I use CONS to construct a pair,

556
00:22:59,000 --> 00:23:03,140
那么该序对的CAR就是X 就是我的构造时的一个输入
then the CAR of that pair is going to be X, the thing I put in,

557
00:23:03,600 --> 00:23:05,700
而该序对的CDR就是Y
and the CDR of that pair is going to be Y.

558
00:23:07,260 --> 00:23:10,660
这就是CONS、CAR、CDR这些运算符的行为
That's the behavior of these operators, CONS, CAR, and CDR.

559
00:23:12,020 --> 00:23:15,740
有了这些东西 George构造有理数就明了多了
Given them, it's pretty clear how George can go off and construct his rational numbers.

560
00:23:17,200 --> 00:23:18,480
言归正传
After all, all he has to do--

561
00:23:19,000 --> 00:23:22,720
记得吗 George的任务是实现MAKE-RAT、NUMER、DENOM过程
remember George's problem was to implement MAKE-RAT, numerator, and denom.

562
00:23:23,020 --> 00:23:36,180
George这样编写代码 定义用N和D来MAKE-RAT
So all George has to do is say define MAKE-RAT of some N and a D--

563
00:23:36,640 --> 00:23:38,640
就是将CONS应用于这二者
Well, all I have to do is CONS them.

564
00:23:40,580 --> 00:23:42,520
也就是(CONS N D)
That's CONS of N and D.

565
00:23:45,220 --> 00:23:46,900
而如果我想取出分子
And then if I want to get the numerator out,

566
00:23:47,440 --> 00:23:59,140
代码我这样写 定义有理数X的NUMER
I would say define the numerator, numer, of some rational number, X.

567
00:23:59,960 --> 00:24:02,000
如果我们是用序对来实现有理数的话
If the rational number's implemented as a pair,

568
00:24:02,440 --> 00:24:04,320
我只需要用CAR来获得X的首部分
then all I have to do is get out the CAR of X.

569
00:24:06,240 --> 00:24:18,860
类似的 DENOM就是用CDR运算符了
And then similarly, define the denom is going to be the cdr,

570
00:24:19,020 --> 00:24:21,000
也就是我用于构造序对的另一个数据
the other thing I put into the pair.

571
00:24:26,700 --> 00:24:27,640
我们现在就是在干这件事
Well, now we're in business.

572
00:24:28,400 --> 00:24:32,860
这就是有理数的一种实现
That's a complete implementation of rational numbers.

573
00:24:33,460 --> 00:24:34,900
我们来实践一下 假设我想要
Let's use it. Suppose I want to say,

574
00:24:35,780 --> 00:24:43,080
我想要求取1/2加上1/4 并观察系统是怎么运作的
so I want to think about how to add 1/2 plus 1/4 and watch the system work.

575
00:24:43,080 --> 00:24:50,340
那么 我或许会定义一个A
Well, the way I'd use that is I'd say, well, maybe define A.

576
00:24:50,380 --> 00:24:51,760
我需要构造一个1/2
I have to make a 1/2.

577
00:24:52,760 --> 00:24:56,780
也就是一个分子为1 分母为2的有理数
Well, that's a rational number with numerator 1 and denominator 2,

578
00:24:59,320 --> 00:25:02,540
也就是 A为(MAKE-RAT 1 2)
so a will be MAKE-RAT of 1 and 2.

579
00:25:05,280 --> 00:25:07,160
然后我来构造1/4
And then I'll construct the 1/4.

580
00:25:07,260 --> 00:25:20,220
我定义B为(MAKE-RAT 1 4)
I'll say define B to be MAKE-RAT of 1 and 4.

581
00:25:23,360 --> 00:25:24,860
如果我想解得答案的话
And if I'd like to look at the answer--

582
00:25:25,060 --> 00:25:28,100
先假设我们没有一个专门用于打印有理数的东西
well, assuming I don't have a special thing that prints rational numbers,

583
00:25:28,100 --> 00:25:29,020
我可以自己编写一个
or I could make one--

584
00:25:29,740 --> 00:25:31,380
比如说 我可以这样写
I could say, for instance,

585
00:25:31,380 --> 00:25:43,740
定义答案为(+RAT A B)
define the answer to be +RAT of A and B,

586
00:25:45,980 --> 00:25:47,100
那么我就可以问 答案是多少？
and now I can say, what's the answer?

587
00:25:47,100 --> 00:25:50,120
答案的分子和分母分别是多少？
What are the numerators and denominators of the answer?

588
00:25:50,640 --> 00:26:00,280
因此 我把1/2和1/4加起来后 我会问 答案的分子是多少？
So if I'm adding 1/2 and 1/4, I'll say, what is the numerator of the answer?

589
00:26:03,880 --> 00:26:10,260
这个系统就应该打印出 6
And the system is going to type out, well, 6.

590
00:26:10,560 --> 00:26:11,240
糟糕了
Bad news.

591
00:26:12,860 --> 00:26:14,960
而如果我问答案的分母是多少
And if I say what's the denominator of the answer,

592
00:26:22,340 --> 00:26:24,480
系统就应该打印出8
the system's going to type out 8.

593
00:26:26,100 --> 00:26:28,740
我们本来希望能得到
So instead of what I would really like,

594
00:26:29,560 --> 00:26:32,380
1/2加1/4是3/4
which is for it to say that 1/2 and 1/4 is 3/4,

595
00:26:35,200 --> 00:26:38,340
但这台愚蠢的机器却说 不 应该是6/8
this foolish machine is going to say, no, it's 6/8.

596
00:26:40,100 --> 00:26:41,480
恩 这的确有点糟糕
Well, that's sort of bad news.

597
00:26:43,040 --> 00:26:43,880
问题在哪里呢？
Where's the bug?

598
00:26:46,940 --> 00:26:48,400
是什么导致的呢？
Why does it do that, after all?

599
00:26:48,400 --> 00:26:51,040
问题出在+RAT上
Well, it's the way that we just had +RAT.

600
00:26:51,040 --> 00:26:56,620
+RAT只是把A的分子和B分母之积与
+RAT just took the-- it said you add the numerator times the denominator,

601
00:26:57,860 --> 00:27:00,100
B的分子和A的分母之积加在一起
you add that to the numerator times the denominator,

602
00:27:00,440 --> 00:27:02,420
并把它们除以两分母之积
and put that over the product of the two denominators,

603
00:27:02,420 --> 00:27:03,580
这就是为什么得到6/8的原因
and that's why you get 6/8.

604
00:27:05,560 --> 00:27:09,680
那么 我们的+RAT实现有什么问题呢？
So what was wrong with our implementation of +RAT?

605
00:27:10,260 --> 00:27:13,720
我们在此之前所做的有理数算术又有什么错误呢？
What's wrong with that rational number arithmetic stuff that we did before the break?

606
00:27:15,500 --> 00:27:17,940
当然 从一方面来看 这一点都没有错
Well, the answer is one way to look at it is absolutely nothing's wrong.

607
00:27:19,360 --> 00:27:21,120
这其实是一个相当好的实现
That's perfectly good implementation.

608
00:27:21,120 --> 00:27:26,900
这个实现完完全全遵守了分数加法法则
It follows the sixth grade, fifth grade mathematic for adding fractions.

609
00:27:29,620 --> 00:27:31,820
我们可以这样说 这就是George的问题了
One thing we can say is, well, that's George's problem.

610
00:27:32,980 --> 00:27:37,560

Like, boy, wasn't George dumb to say that he can make a rational number

611
00:27:37,800 --> 00:27:40,780

simply by sticking together the numerator and the denominator?

612
00:27:42,480 --> 00:27:46,460
在构造有理数时 如果George把这些东西化到最简
Wouldn't it be better for George, when he made a rational number,

613
00:27:47,640 --> 00:27:49,240
难道不是会跟好一点吗？
to reduce the stuff to lowest terms?

614
00:27:51,080 --> 00:27:55,540
我想说的是 对George来说
And what I mean is, wouldn't it be better for George,

615
00:27:55,540 --> 00:28:01,800
用这个版本的MAKE-RAT 难道会比幻灯片上的这个好么？
instead of using this version of MAKE-RAT, to use this one on the slide?

616
00:28:03,160 --> 00:28:06,660
不是简单的通过CONS 把N和D结合起来
Or instead of just saying CONS together N and D,

617
00:28:07,240 --> 00:28:11,680
我们先寻找N和D的最大公约数
what you do is compute the greatest common divisor of N and D,

618
00:28:12,420 --> 00:28:14,000
我们用GCD过程来找
and GCD is the procedure which,

619
00:28:14,700 --> 00:28:16,040
我们只需知道GCD是一个基本过程
well, for all we care is a primitive,

620
00:28:16,040 --> 00:28:18,520
它返回的是两个数的最大公约数
which computes the greatest common divisor of two numbers.

621
00:28:20,700 --> 00:28:22,900
因此 这种构造有理数的方法就是
So the way I can construct a rational number is

622
00:28:24,160 --> 00:28:26,520
先找到两数的最大公约数
get the greatest common divisor of the two numbers,

623
00:28:26,520 --> 00:28:27,580
先用G来表示吧
and I'm going to call that G,

624
00:28:29,920 --> 00:28:33,720
不是简单通过CONS结合N、D 而是先让它们除以G
and then instead of consing together N and D, I'll divide them through.

625
00:28:33,720 --> 00:28:38,940
然后我再用CONS结合N/G和D/G的商
I'll CONS together the quotient of N by the the GCD and the quotient of D by the GCD.

626
00:28:40,400 --> 00:28:42,600
这样就把我们的有理数化到了最简
And that will reduce the rational number to lowest terms.

627
00:28:43,740 --> 00:28:53,600
因此 当我在做加法时 当+RAT调用MAKE-RAT过程时
So that when, when I do this addition, when +RAT calls MAKE-RAT--

628
00:28:53,980 --> 00:28:56,320
+RAT的定义里面有对MAKE-RAT的调用
and for the definition of +RAT it had a MAKE-RAT in there--

629
00:28:57,400 --> 00:28:59,240
因此 当+RAT构造有理数时
just by the fact that it's constructing that,

630
00:28:59,240 --> 00:29:01,440
MAKE-RAT就自动将其化为最简了
the thing will get reduced to lowest terms automatically.

631
00:29:08,780 --> 00:29:13,460
好了 这就是一个完整的系统
OK, that is a complete system.

632
00:29:14,640 --> 00:29:16,900
让我们来看看我们完成的这个有理数算术系统吧
For rational number arithmetic, let's look at what we've done.

633
00:29:19,240 --> 00:29:22,480
好吧 我们说过我们想要构造一个有理数算术系统
All right, we said we want to build rational number arithmetic,

634
00:29:25,220 --> 00:29:27,920
我们实现了+RAT
and we had a thing called +RAT. We implemented that.

635
00:29:29,620 --> 00:29:33,200
我也给你们展示了*RAT的实现
And I showed you multiplying rational numbers, and

636
00:29:34,100 --> 00:29:35,200
虽然我并没有去实现-RAT
although I didn't put them up there,

637
00:29:35,200 --> 00:29:38,280
就姑且假设我们实现了-RAT吧
presumably we'd like to have something that subtracts rational numbers,

638
00:29:38,960 --> 00:29:40,500
事实上这些事我都不知道
and I don't know, all sorts of things.

639
00:29:40,500 --> 00:29:42,220

Things that test equality in division,

640
00:29:42,220 --> 00:29:45,140

and maybe things that print rational numbers in some particular way.

641
00:29:45,820 --> 00:29:49,960
我们用序对的方式实现了它们
And we implemented those in terms of pairs.

642
00:29:52,440 --> 00:29:54,600
序对、CONS、CAR和CDR 这些都是内建于Lisp中的
These pairs, CONS, CAR, and CDR that are built into Lisp.

643
00:29:55,560 --> 00:30:03,840
而两者之间最重要的则是
But the important thing is that between these and these,

644
00:30:04,680 --> 00:30:09,240
我们在其间构筑了一道抽象屏障 一个抽象层
we set up an abstraction barrier. We set up a layer of abstraction.

645
00:30:16,960 --> 00:30:18,640
那么 “抽象层”又是什么呢？
And what was that layer of abstraction?

646
00:30:18,640 --> 00:30:22,340
准确的说 构造函数和选择函数就是抽象层
That layer of abstraction was precisely the constructor and the selectors.

647
00:30:25,420 --> 00:30:34,360
MAKE-RAT、NUMER、DENOM也是抽象层
This layer was MAKE-RAT, and NUMER, and DENOM.

648
00:30:38,620 --> 00:30:42,920
这种方法学 也就是我们的做法
This methodology, another way to say what it's doing,

649
00:30:43,120 --> 00:30:51,000

is that we are separating, we are separating the way something is used,

650
00:30:53,240 --> 00:30:55,000
我们把数据对象的使用
separating the use of data objects,

651
00:30:56,140 --> 00:30:59,040
和它们的表示分离开来
from the representation of data objects.

652
00:31:07,060 --> 00:31:12,040
到此为止 我们有了使用有理数做计算的方法
So up here, we have the way that rational numbers are used, do arithmetic on them.

653
00:31:12,220 --> 00:31:14,760
在这儿 我们有它们表示的方法
Down here, we have the way that they're represented,

654
00:31:14,760 --> 00:31:16,300
它们通过这条边界分隔开
and they're separated by this boundary.

655
00:31:17,480 --> 00:31:19,500
这条边界就是构造函数和选择函数
The boundary is the constructors and selectors.

656
00:31:23,440 --> 00:31:25,420
这种方法学有个名字
And this methodology has a name.

657
00:31:25,420 --> 00:31:26,960
叫做数据抽象
This is called data abstraction.

658
00:31:35,880 --> 00:31:39,760
数据抽象是一种通过假定的构造函数和选择函数将数据对象
Data abstraction is sort of the programming methodology of setting up data objects

659
00:31:39,760 --> 00:31:44,080
与它的表示分隔开来的编程方法学
by postulating constructors and selectors to isolate use from representation.

660
00:31:47,140 --> 00:31:50,420
那么 这指什么呢 #TBD
Well, so what? I mean, after all, we didn't have to do it this way.

661
00:31:51,580 --> 00:31:55,000
当然就算不用任何复合对象
It's perfectly possible to do rational number addition

662
00:31:55,000 --> 00:31:56,800
做有理数加法也是完全可行的
without having any compound data objects,

663
00:31:56,800 --> 00:31:59,560
幻灯片上就是一个例子
and here on the slide is one example.

664
00:31:59,560 --> 00:32:02,620
我们当然可以这样定义+RAT
We certainly could have defined +RAT,

665
00:32:02,820 --> 00:32:05,920
它需要两个参数x和y
which takes in things x and y,

666
00:32:05,920 --> 00:32:08,940
而我们会问 这些有理数到底是什么呢？
and we'll say, well what are these rational numbers really?

667
00:32:09,380 --> 00:32:11,160
实质上 它们只是序对
So really, they're just pairs,

668
00:32:11,680 --> 00:32:13,960
分子是序对的car部分 分母是cdr部分
and the numerator's the car and the denominator's the cdr.

669
00:32:14,180 --> 00:32:18,800
我们要做的 就是取出x的car部分乘以y的cdr部分
So what we'll do is we'll take the car of x times the cdr of y,

670
00:32:21,920 --> 00:32:22,760
并把它们乘起来
multiply them.

671
00:32:23,020 --> 00:32:26,600
取出y的car部分和cdr部分相乘 再与之前的结果相加
Take the car of y times the cdr of x, multiply them.Add them.

672
00:32:28,340 --> 00:32:31,080
取出x的cdr部分乘以y的cdr部分
Take the cdr of x and the cdr of y, multiply them,

673
00:32:31,300 --> 00:32:32,540
并把最终结果构造起来
and then constitute together.

674
00:32:33,900 --> 00:32:36,700
这其实是一样的
Well, that sort of does the same thing.

675
00:32:41,080 --> 00:32:44,000
但这种方法忽略了把对象归约到最低阶项的问题
But this ignores the problem of reducing things to lowest terms,

676
00:32:44,000 --> 00:32:46,620
让我们花点时间仔细思考一下
but let's not worry about that for a minute.

677
00:32:47,400 --> 00:32:48,920
我们为什么不这样做呢？这又如何呢？
But so what? Why don't we do it that way?

678
00:32:50,420 --> 00:32:52,920
对吧 毕竟这样看起来会少定义很多过程
Right? After all, there are sort of fewer procedures to define,

679
00:32:52,920 --> 00:32:54,360
并且更加直白
and it's a lot more straightforward.

680
00:32:55,080 --> 00:33:00,600
它省去了所有的这些关于数据抽象的自以为是的BS #TBD
Ah It saves all this self-righteous BS about talking about data abstraction.

681
00:33:00,600 --> 00:33:01,660
我们就是这样做的 #TBD
We just sort of do it.

682
00:33:01,900 --> 00:33:04,660
我的意思是这样或许会稍微高效一点
I mean, who knows, maybe it's even marginally more efficient

683
00:33:04,660 --> 00:33:06,900

depending on whatever compiler were using for this.

684
00:33:07,460 --> 00:33:11,920
而将数据的使用与表示分离开来的意图是什么呢？
What's the point of isolating the use from the representation?

685
00:33:13,660 --> 00:33:16,840
这就将回到进行命名的记号了
Well, it goes back to this notion of naming.

686
00:33:16,840 --> 00:33:21,180
还记得吗 编程中最重要的原理
Remember, one of the most important principles in programming

687
00:33:21,180 --> 00:33:25,180
和魔法中最重要的原理是一样的 对吧？
is the same as one of the most important principles in sorcery, all right?

688
00:33:25,180 --> 00:33:28,600
这就是你知道某个精灵的名字 你便可以控制它
That's if you have the name of the spirit, you get control over it.

689
00:33:30,000 --> 00:33:31,860
如果你回过头来看幻灯片
And if you go back and look at the slide,

690
00:33:33,380 --> 00:33:35,680
你会发现这里我们就有一个+RAT
you see what's in there is we have this thing +RAT,

691
00:33:36,580 --> 00:33:40,900
如果我们有+RAT -RAT *RAT 或者和这些类似的过程
but nowhere in the system, if I have a +RAT and a -RAT and a *RAT,

692
00:33:40,900 --> 00:33:42,060
但在这个系统的任何地方
and things that look like that,

693
00:33:42,060 --> 00:33:50,460
我无法找出任何一个有理数
nowhere in the system do I have a thing that I can point at which is a rational number.

694
00:33:53,240 --> 00:33:55,900
在像这样的一个系统中 我并没有
I don't have, in a system like that,

695
00:33:56,800 --> 00:33:59,720
没有一个有理数的概念实体
the idea of rational number as a conceptual entity.

696
00:34:01,480 --> 00:34:02,960
那么 这样做的优势是什么呢？
Well, what's the advantage of that?

697
00:34:03,920 --> 00:34:08,000

What's the advantage of isolating the idea of rational numbers as a conceptual entity,

698
00:34:08,000 --> 00:34:11,420
然后用
and really naming it with make-RAT, numerator, and denominator.

699
00:34:13,000 --> 00:34:19,180
优点之一就是你可以使用其它的方法表示（数据）
Well, one advantage is you might want to have alternative representations.

700
00:34:20,420 --> 00:34:23,320

See, before I showed you that one way George can solve this

701
00:34:24,080 --> 00:34:26,560
things not reduced to lowest terms problem,

702
00:34:26,560 --> 00:34:28,180
is when you build a rational number,

703
00:34:28,780 --> 00:34:30,780
you divide up by the greatest common denominator.

704
00:34:30,780 --> 00:34:35,960
另一种解决办法在这里
Another way to do that is shown over here.

705
00:34:36,300 --> 00:34:38,840
我可以用另一种方法表示有理数
I can have an alternative representation for rational numbers

706
00:34:39,020 --> 00:34:41,560
也就是仅仅使用cons来构建有理数
where when you make a rational number, you just cons them.

707
00:34:43,120 --> 00:34:45,420
而当你在析取去分子时
However, when you go to select out the numerator,

708
00:34:45,720 --> 00:34:51,260
在那个时候再计算分子分母的最大公约数
at that point you compute the gcd of the stuff that's sitting in that pair,

709
00:34:52,000 --> 00:34:53,580
然后再用分子除以这个最大公约数
and divide out by the gcd.

710
00:34:57,480 --> 00:34:59,400
类似地 当我析取分母时
And similarly, when I get the denominator,

711
00:35:00,740 --> 00:35:04,760
当我在析取出分母时 我将它除以最大公约数
at that point when I go to get the denominator, I'll divide out by the gcd.

712
00:35:05,260 --> 00:35:07,360
所以在旧的表示法中
So the difference would be in the old representation,

713
00:35:08,540 --> 00:35:10,200
当ans在这里被构造时
when ans was constructed here,

714
00:35:11,080 --> 00:35:13,680
在第一种方法中 也就是6和8
say what's 6 and 8, in the first way,

715
00:35:14,100 --> 00:35:16,940
在6和8被装入表中时 它们已经被化到最简
the 6 and 8 would have got reduced when they got stuck into that pair,

716
00:35:16,940 --> 00:35:18,480
析取分子会得到3
numerator would select out 3.

717
00:35:20,040 --> 00:35:21,440
而在我给你们展示的方法中
And in the way I just showed you, well,

718
00:35:21,800 --> 00:35:24,300
我们放入的是6和8
ans would get 6 and 8 put in,

719
00:35:24,780 --> 00:35:26,880
然后在我析取分子时会进行一些计算
and then at the point where I said numerator,

720
00:35:27,320 --> 00:35:30,360
使得我得到3而非6
some computation would get done to put out 3 instead of 6.

721
00:35:32,280 --> 00:35:33,920
这就是我可以使用的两种不同方法
So those are two different ways I might do it.

722
00:35:33,920 --> 00:35:34,880
哪种更好呢？
Which one's better?

723
00:35:37,200 --> 00:35:38,320
这得看情况 对吧？
Well, it depends, right?

724
00:35:38,320 --> 00:35:41,640
如果我的系统中我经常构造有理数
If I'm making a system where I am mostly constructing rational numbers

725
00:35:41,640 --> 00:35:42,780
而不常去析取它们
and hardly ever looking at them,

726
00:35:42,780 --> 00:35:46,660
那么早构造它们时就最好不要化简
then it's probably better not to do that gcd computation when I construct them.

727
00:35:47,840 --> 00:35:51,500
如果在我的系统中 比起构造 我更经常去析取它们
If I'm doing a system where I look at things a lot more than I construct them,

728
00:35:51,720 --> 00:35:54,840
那在构造时就将它们化简就一劳永逸了
then it's probably better to do the work when I construct them.

729
00:35:56,940 --> 00:35:58,020
这得视情况做出选择
So there's a choice there.

730
00:35:58,020 --> 00:36:02,320
但真正的问题是 在你实现这些有理数时
But the real issue is that you might not be able to decide

731
00:36:04,220 --> 00:36:06,440
没法决定要用哪种表示法
at the moment you're worrying about these rational numbers.

732
00:36:07,320 --> 00:36:10,220
通常来说 作为一名系统设计师
See, in general, as systems designers,

733
00:36:13,040 --> 00:36:16,740
[36.25]
you're forced with the necessity to make decisions about how you're going to do things,

734
00:36:17,680 --> 00:36:20,340
and in general, the way you'd like to retain flexibility

735
00:36:20,500 --> 00:36:24,720
is to never make up your mind about anything until you're forced to do it.

736
00:36:26,560 --> 00:36:31,500

The problem is, there's a very, very narrow line between

737
00:36:31,500 --> 00:36:34,960
deferring decisions and outright procrastination.

738
00:36:38,500 --> 00:36:43,720

So you'd like to make progress, but also at the same time,

739
00:36:43,720 --> 00:36:46,080
never be bound by the consequences of your decisions.

740
00:36:48,280 --> 00:36:50,060

Data abstraction's one way of doing this.

741
00:36:50,160 --> 00:36:52,080
我的做的就是“按愿望思想”
What we did is we used wishful thinking.

742
00:36:54,100 --> 00:36:55,800
我们给结果命了个名字
See, we gave a name to the decision.

743
00:36:56,800 --> 00:37:02,040
我们让MAKE-RAT、NUMER、DENOM代表它们运作的结果
We said, make-RAT, numerator, and denominator will stand for however it's going to be done,

744
00:37:02,040 --> 00:37:03,740
但它们如何运作则是George的事
and however it's going to be done is George's problem.

745
00:37:03,740 --> 00:37:08,000

But really, what that was doing is giving a name to the decision of how we're going to do it,

746
00:37:09,980 --> 00:37:12,700

and then continuing as if we made the decision.

747
00:37:13,700 --> 00:37:16,820
And then eventually, when we really wanted it to work,

748
00:37:16,820 --> 00:37:18,820
coming back and facing what we really had to do.

749
00:37:20,320 --> 00:37:22,120
And in fact, we'll see a couple times from now

750
00:37:22,480 --> 00:37:25,640
that you may never have to choose any particular representation, ever, ever.

751
00:37:27,420 --> 00:37:29,600
不管如何 这都是一种非常有用的设计技术
Anyway, that's a very powerful design technique.

752
00:37:30,380 --> 00:37:32,240
这也是人们使用数据抽象的原因
It's the key to the reason people use data abstraction.

753
00:37:34,560 --> 00:37:36,660
我们会不断的看到这个理念
And we're going to see that idea again and again.

754
00:37:38,480 --> 00:37:39,680
有什么问题吗？
Let's stop for questions.

755
00:37:40,180 --> 00:37:44,360
学生：
AUDIENCE: What does this decision making through abstraction layers

756
00:37:44,820 --> 00:37:48,040
do to the axiom of do all your design before any of your code?

757
00:37:49,420 --> 00:37:51,840
教授：嗯 这只是少数人的信条
PROFESSOR: Well, that's someone's axiom,

758
00:37:51,840 --> 00:37:56,080
我打赌这是那些不经常实现大型计算机系统的家伙的信条
and I bet that's the axiom of someone who hasn't implemented very large computer systems very much.

759
00:38:00,880 --> 00:38:02,800
我曾说过计算机科学非常像是魔法
I said that computer science is a lot like magic,

760
00:38:03,560 --> 00:38:05,020
像魔法这一点非常好
and it's sort of good that it's like magic.

761
00:38:05,020 --> 00:38:07,580
但是计算机科学也非常像宗教 这就不好了
There's a bad part of computer science that's a lot like religion.

762
00:38:08,220 --> 00:38:15,120
通常来说 我认为那些
And in general, I think people who really believe that you design everything before you implement it

763
00:38:15,920 --> 00:38:18,140
大多都是一些没有设计过大规模系统的人
basically are people who haven't designed very many things.

764
00:38:20,980 --> 00:38:24,700
The real power is that you can pretend that you've made the decision

765
00:38:25,700 --> 00:38:27,920
and then later on figure out which one is right,

766
00:38:28,260 --> 00:38:29,800
which decision you ought to have made.

767
00:38:30,460 --> 00:38:32,480
And when you can do that, you have the best of both worlds.

768
00:38:35,660 --> 00:38:39,140
学生：您能解释一下let和define的区别吗？
AUDIENCE: Can you explain the difference between let and define?

769
00:38:39,860 --> 00:38:41,060
教授：好的
PROFESSOR: Oh, OK.

770
00:38:41,540 --> 00:38:48,900
let是用来建立一个局部的名字
Let is a way to establish local names.

771
00:38:53,100 --> 00:38:56,760
嗯 我就先大概给你说下
So there... Let me give you sort of the half answer.

772
00:38:57,200 --> 00:39:01,640
然后我们再来讨论这整个复杂的过程
And I'll say, later on we can talk about the whole very complicated thing.

773
00:39:02,620 --> 00:39:06,540
就现在来说 区别就在于 当你在Lisp中编程时
But the big difference for now is that, see, when you're typing at Lisp,

774
00:39:07,600 --> 00:39:10,920

you're typing in this environment where you're making definitions.

775
00:39:11,720 --> 00:39:19,100
当你想把A定义为5时 我写(DEFINE A 5)
And when you say define a to be 5, if I say define a to be 5,

776
00:39:20,420 --> 00:39:22,760
从此以后我们就会记得a就是5
then from then on the thing will remember that a is 5.

777
00:39:25,280 --> 00:39:29,840
let会建立一个包含一个定义的局部上下文
Let is a way to set up a local context where there's a definition.

778
00:39:30,800 --> 00:39:36,640
所以当我键入 比如(LET ((A
So if I type something like, saying let a--

779
00:39:36,640 --> 00:39:44,880
或者我写(LET ((Z 10)))
no, I shouldn't say a-- if I said let z be 10,

780
00:39:48,020 --> 00:39:53,660
然后在这个上下文中 我们计算Z加上Z的和
and within that context, tell me what the sum of z and z is.

781
00:39:54,000 --> 00:39:56,260
如果我在Lisp中这样写的话
So if I typed in this expression to Lisp,

782
00:39:58,220 --> 00:40:00,840
Lisp会输出20
and then this would put out 20.

783
00:40:01,960 --> 00:40:05,460
然而 如果我再问Z是什么
However, then if I said what's z,

784
00:40:06,140 --> 00:40:09,140
计算机会告诉我Z是一个未绑定的变量
the computer would say that's an unbound variable.

785
00:40:10,600 --> 00:40:14,040
因此let可以创建一个上下文 你可以在这个上下文中进行定义
So let is a way of setting up a context where you can make definitions.

786
00:40:15,840 --> 00:40:18,420
但是这些都是这个上下文中的局部定义
But those definitions are local to this context.

787
00:40:19,100 --> 00:40:27,720
当然啦 我把这个改为A的话 我依旧会得到20
And of course, if I'd said a in here, I'd still get 20.

788
00:40:27,720 --> 00:40:31,520
但是这个A与这个A一点也不冲突
But this a would not interfere at all with this one.

789
00:40:33,640 --> 00:40:36,040
所以我键入这个 再键入这个 再问A是什么
So if I type this, and then type this, and then say what's a?

790
00:40:36,040 --> 00:40:36,940
A还会是5
a will still be 5.

791
00:40:39,020 --> 00:40:42,120
因此在let和define之间有这另一种代换模型
So there's some other subtle differences between let and define,

792
00:40:42,120 --> 00:40:44,120
这也是最重要的
but that's the most important one.

793
00:40:44,120 --> 00:40:50,700

[音乐]
[JESU, JOY OF MAN'S DESIRING]

794
00:41:03,760 --> 00:41:07,420
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

795
00:41:07,580 --> 00:41:10,980
讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
By: Prof. Harold Abelson && Gerald Jay Sussman

796
00:41:11,460 --> 00:41:14,440
复合数据
Compound Data

797
00:41:19,780 --> 00:41:23,220
好了 我们已经看过作为数据抽象技术的示例
All right, well, we've looked at implementing this little system

798
00:41:23,500 --> 00:41:29,100
在有理数域上做算术的小型系统的实现
for doing arithmetic on rational numbers as an example of this methodology of data abstraction.

799
00:41:30,880 --> 00:41:35,000
这就是一种在大型系统中控制复杂度的方法
And that's a way of controlling complexity in large systems.

800
00:41:36,560 --> 00:41:38,660
就像定义过程
But, see, like procedure definition,

801
00:41:38,820 --> 00:41:41,680
以及我们谈论的所有的控制复杂度的方法
and like all the ways we're going to talk about for controlling complexity,

802
00:41:41,980 --> 00:41:47,100

the real power of these things show up not when you sort of do these things in themselves,

803
00:41:47,780 --> 00:41:51,220
我们构建的有理数运算系统并不是什么了不起的事
like it's not such a great thing that we've done rational number arithmetic,

804
00:41:52,140 --> 00:41:57,860
而是你可以将这些东西用于构建更复杂的东西
it's that you can use these as building blocks for making more complicated things.

805
00:42:00,340 --> 00:42:04,020

So it's no wonderful idea that you can just put two numbers together to form a pair.

806
00:42:04,020 --> 00:42:05,560

If that's all you ever wanted to do,

807
00:42:05,720 --> 00:42:07,400
there are tons of ways that you can do that.

808
00:42:08,200 --> 00:42:10,240
The real issue is can you do that in such a way

809
00:42:11,220 --> 00:42:12,420
so that the things that you build

810
00:42:12,700 --> 00:42:16,100
become building blocks for doing something even more complex?

811
00:42:16,900 --> 00:42:19,060
因此无论何时有人向你展示控制复杂度的方法
So whenever someone shows you a method for controlling complexity,

812
00:42:19,060 --> 00:42:21,600
你都应该说 嗯 这很不错 但我可以用它来构建什么呢？
you should say, yeah, that's great, but what can I build with it?

813
00:42:24,960 --> 00:42:25,760
举个例子吧
So for example,

814
00:42:27,540 --> 00:42:31,740
我举一个很像刚才那个有理数系统的例子
let me just run through another thing that's a lot like the rational number one.

815
00:42:31,740 --> 00:42:34,780
假设我们想要在平面中表示一个点
Suppose we would like to represent points in the plane.

816
00:42:35,300 --> 00:42:36,780
好吧 这里有一个点
You sort of say, well, there's a point,

817
00:42:37,440 --> 00:42:39,060
我们把它叫做点P
and we're going to call that point p.

818
00:42:40,520 --> 00:42:45,100
这个点可能会有一个坐标
And that point might have coordinates,

819
00:42:47,000 --> 00:42:50,020
比如点P就是(1,2)
like this might be the point 1 comma 2.

820
00:42:50,020 --> 00:42:53,500
X坐标为1 Y坐标为2
The x-coordinate might be 1, and it's y-coordinate might be 2.

821
00:42:54,220 --> 00:42:57,920
我们将要构建一个用于在平面中处理这些点的小型系统
And we'll make a little system for manipulating points in the plane.

822
00:43:00,080 --> 00:43:03,800
我们当然可以 可以像这样
And again, we can do that-- here's a little example of that.

823
00:43:06,680 --> 00:43:09,360
用向量来表示 就和点在平面中的表示是一样的
It can represent vectors, the same as points in the plane,

824
00:43:09,720 --> 00:43:11,260
我们也会说 嗯
and we'll say, yep,

825
00:43:11,620 --> 00:43:17,820
这里有一个叫做MAKE-VERCTOR的构造函数
there's a constructor called make-vector,

826
00:43:17,820 --> 00:43:19,420
函数MAKE-VERCTOR需要两个坐标
make-vector's going to take two coordinates,

827
00:43:20,700 --> 00:43:23,300
当然 如果我们愿意的话可以将其实现为序对
and here we can implement them if we like as pairs,

828
00:43:23,680 --> 00:43:25,540
但是最重点的是我们有一个构造函数
but the important thing is that there's a constructor.

829
00:43:26,780 --> 00:43:28,320
当我们传递了向量P后
And then given some vector, p,

830
00:43:29,200 --> 00:43:30,600
我们可以得到它的X坐标
we can find its x-coordinate,

831
00:43:31,980 --> 00:43:33,220
我们也可以得到它的Y坐标
or we can get its y-coordinate.

832
00:43:33,220 --> 00:43:36,900
所以这里就有了点在平面系统中的构造函数和选择函数
So there's a constructor and selectors for points in the plane.

833
00:43:38,660 --> 00:43:41,820
那么 我们有了平面中的点 就希望将它们用来构建事物
Well, given points in the plane, we might want to use them to build something.

834
00:43:42,060 --> 00:43:44,060
比如说 我们想要
So for instance, we might want to talk about,

835
00:43:44,680 --> 00:43:47,560
我们有一个点P 一个点Q
we might have a point, p, and a point, q,

836
00:43:48,140 --> 00:43:52,460
点P为(1,2) 点Q为(2,3)
and p might be the point 1, 2, and q might be the point 2, 3.

837
00:43:54,460 --> 00:44:00,120
我们想要得到从P开始 到Q截止的线段
And we might want to talk about the line segment that starts at p and ends at q.

838
00:44:01,660 --> 00:44:03,100
我们把它叫做线段S
And that might be the segment s.

839
00:44:04,920 --> 00:44:12,340
我们想用数字来表示点 并用点来构造向量
So we might want to build points for vectors in terms of numbers,

840
00:44:12,540 --> 00:44:13,940
用向量来表示线段
and segments in terms of vectors.

841
00:44:16,140 --> 00:44:19,000
因此我们也可以对线段如法炮制
So we can represent line segments in exactly the same way.

842
00:44:19,700 --> 00:44:21,420
因此 对于从P到Q的线段
All right, so the line segment from p to q,

843
00:44:21,420 --> 00:44:23,740
我们这里有一个构造函数MAKE-SEGMENT
we'll say there's a constructor, make-segment.

844
00:44:26,680 --> 00:44:29,160
然后是为选择函数取名
And make up names for the selectors,

845
00:44:29,160 --> 00:44:32,240
取得线段起始点的函数 和取得截止点的函数
the starting point of the segment and the ending point of the segment.

846
00:44:32,240 --> 00:44:35,400
当然了 我们可以将线段实现为两个点构造成的序对
And again, we can implement a segment using cons as a pair of points,

847
00:44:36,840 --> 00:44:40,340
CAR和CDR可以分别取得构成线段的两个点
and car and cdr get out the two points that we put together to get the segment.

848
00:44:44,540 --> 00:44:45,560
好了 我们已经完成这个系统了
Well, now having done that,

849
00:44:47,660 --> 00:44:49,160
我们可以进行一些此操作
we can have some operations on them.

850
00:44:51,440 --> 00:44:56,120
比如说 某个线段的中点是什么？
Like we could say, what's the midpoint of a line segment?

851
00:44:57,320 --> 00:44:59,560
这就是某个线段的中点
So here's the midpoint of a line segment,

852
00:44:59,880 --> 00:45:06,840
该点的X、Y坐标分别为起始点和截止点X、Y坐标和的一半
that's going to be the points whose coordinates are the averages of the coordinates of the endpoints.

853
00:45:07,740 --> 00:45:08,780
嗯 这就是中点
OK, there's the midpoint.

854
00:45:09,840 --> 00:45:12,100
因此 为了得到线段S的中点
So to get the midpoint of a line segment, s,

855
00:45:13,600 --> 00:45:17,020
我们先要取得该线段的起始点
we'll just say grab the starting point to the segment,

856
00:45:17,260 --> 00:45:18,680
取得该线段的截止点
grab the ending point of the segment,

857
00:45:19,960 --> 00:45:21,980
然后构建一个向量 也就是一个点
and now make a vector--make a point

858
00:45:22,680 --> 00:45:28,980
该点的X坐标为起、止点X坐标和的一半
whose coordinates are the average of the x-coordinate of the first point and the x-coordinate of the second point,

859
00:45:29,880 --> 00:45:32,300
Y坐标为起、止点Y坐标和的一半
and whose y-coordinate is the average of the y-coordinates.

860
00:45:33,480 --> 00:45:35,760
这就是函数MIDPOINT一种实现
So there's an implementation of midpoint.

861
00:45:37,440 --> 00:45:42,980
类似的 我们可以编写类似于求取线段长度的函数
And then similarly, we can build something like the length of the segment.

862
00:45:43,960 --> 00:45:51,780
线段的长度 可以根据勾股定理算得
The length of the segment is a thing whose-- use Pythagoras's rule,

863
00:45:51,780 --> 00:45:56,100
线段的长度是dX的平方加dY的平方的和的平方根
the length of the segment is the square root of the d x squared plus d y squared.

864
00:45:56,680 --> 00:45:59,000
当我们说计算某线段S的长度时
We'll say to get the length of a line segment,

865
00:45:59,920 --> 00:46:10,200
我们令dX为起、止点X坐标之差
we'll let dx be the difference of the x-coordinate of one endpoint and the x-coordinate of the other endpoint,

866
00:46:11,180 --> 00:46:14,500
令dY为起、止点Y坐标之差
and we'll let dy be the difference of the y-coordinates.

867
00:46:15,880 --> 00:46:19,960
然后我们求取dX、dY平方和的平方根
And then we'll take the square root of the sum of the squares of dx and dy,

868
00:46:19,960 --> 00:46:20,780
就是这样了
that's what this says.

869
00:46:22,020 --> 00:46:24,600
好了 这就是函数LENGTH的一种实现
All right, so there's an implementation of length.

870
00:46:25,840 --> 00:46:33,940
再次强调 我们构建的是一种层次系统
And again, what we built is a layered system.

871
00:46:35,340 --> 00:46:40,200
我们构建了一个有 呃 现在有线段
We built a system which has, well, say up here there's segments.

872
00:46:47,060 --> 00:46:48,620
这里就有了一道抽象屏障
And then there's an abstraction barrier.

873
00:46:50,160 --> 00:46:54,840
这道抽象屏障把
The abstraction barrier separates the implementation

874
00:46:56,480 --> 00:46:58,920
线段同向量、点的实现分离开来
of segments from the implementation of vectors and points,

875
00:46:59,120 --> 00:47:03,580
而这道抽象屏障 就是构造函数和选择函数
and what that abstraction barrier is are the constructors and selectors.

876
00:47:03,580 --> 00:47:14,860
也就是 MAKE-SEGMENT SEGMENT-START 和 SEGMENT-END
It's make-segment, and segment-start, and segment-end.

877
00:47:17,700 --> 00:47:18,600
这里是向量
And then there are vectors.

878
00:47:19,720 --> 00:47:24,080
而向量则是建立在序对和数的基础上
And vectors in turn are built on top of pairs and numbers.

879
00:47:25,080 --> 00:47:29,080
所以这里是序对和数
So I'll say pairs and numbers.

880
00:47:29,340 --> 00:47:31,760
这又是它们的抽象屏障
And that has its own abstraction barrier,

881
00:47:32,420 --> 00:47:42,620
也就是 MAKE-VECTOR X-COORDINATE 和 Y-COORDINATE
which is make-vector, and x-coordinate, and y-coordinate.

882
00:47:46,440 --> 00:47:48,520
如此可见 这就是一个层次系统
So we have, again, a layered system.

883
00:47:48,520 --> 00:47:51,460
你可以清楚的看出这些分明的层次
You're starting to see that there are layers here.

884
00:47:51,720 --> 00:47:58,920
我提一下 这里有一个非常重要但是又理所当然的东西
I ought to mention, there is a very important thing that I kind of took for granted.

885
00:48:00,240 --> 00:48:07,120
这点非常自然 但从另外一方面来说又非常重要
And it's sort of so natural, but on the other hand it's a very important thing.

886
00:48:07,120 --> 00:48:10,220
我们为了表示某线段S
Notice that in order to represent this segment s,

887
00:48:11,600 --> 00:48:13,940
我说这个线段就是由点构成的序对
I said this segment is a pair of points.

888
00:48:16,260 --> 00:48:17,980
而一个点又是由数构成的序对
And a point is a pair of numbers.

889
00:48:18,800 --> 00:48:22,320
如果要把这个结构的盒子—指针模型给画出来的话
And if I were going to draw the box and pointers structure for that,

890
00:48:23,620 --> 00:48:25,060
那么我会说 嗯 这个线段是
I would say, oh, the segment is,

891
00:48:26,000 --> 00:48:29,260
用我之前给你们说过的表示法来演示
given those particular representations that I showed you,

892
00:48:29,260 --> 00:48:32,500
线段就是一个序对
I'd say this segment s is a pair,

893
00:48:33,720 --> 00:48:38,520
序对的第一个元素是一个向量
and the first thing in the pair is a vector,

894
00:48:40,200 --> 00:48:43,800
向量是由数构成的序对
and the vector is a pair of numbers.

895
00:48:45,460 --> 00:48:46,720
这就是它 这就是点P
And that's this, that's p.

896
00:48:49,920 --> 00:48:52,380
线段中的另一个东西就是点Q
And the other thing in the segment is q,

897
00:48:52,960 --> 00:48:58,160
它本身就是一个由数构成的序对
which is itself a pair of numbers.

898
00:48:59,800 --> 00:49:02,520
当我说CONS可以让你把东西组合在一起的时候
So I almost took it for granted when I said that

899
00:49:03,260 --> 00:49:06,480
就把它视作理所当然了
cons allows you to put things together.

900
00:49:08,600 --> 00:49:13,020
但有一点也很容易搞不明白 请注意
But it's very easy to not appreciate that, because notice,

901
00:49:13,020 --> 00:49:18,380
我也可以把一些序对给组合在一起
some of the things I can put together can themselves be pairs.

902
00:49:20,360 --> 00:49:23,520
我以后会经常用一个术语来表示
And let me introduce a word that I'll talk about more next time,

903
00:49:24,100 --> 00:49:26,920
一个我最喜欢的术语 这称作“闭包”
it's one of my favorite words, called closure.

904
00:49:30,280 --> 00:49:35,460
这种所谓具有“闭包性质”的组合方法
And by closure I mean that the means of combination in your system

905
00:49:36,220 --> 00:49:39,320
就是哪些当你用它们把东西组合在一起时
are such that when you put things together using them,

906
00:49:39,320 --> 00:49:40,240
这就像我们构建序对的时候
like we make a pair,

907
00:49:41,760 --> 00:49:44,500
你可以继续用同样的方法把组合物继续进行组合
you can then put those together with the same means of combination.

908
00:49:44,940 --> 00:49:48,420
因此我不仅可以有由数构成的序对 也可有由序对构成的序对
So I can have not only a pair of numbers, but I can have a pair of pairs.

909
00:49:51,460 --> 00:49:59,220
比如说 在Fortran中的数组并不具有闭包性质
So for instance, making arrays in a language like Fortran is not a closed means of combination,

910
00:49:59,220 --> 00:50:00,800
因为我可以有元素为数的数组
because I can make an array of numbers,

911
00:50:01,560 --> 00:50:02,980
但不能有元素为数组的数组
but I can't make an array of arrays.

912
00:50:05,560 --> 00:50:07,000

And one of the things that you should ask,

913
00:50:07,420 --> 00:50:12,300
one of your tests of quality for a means of combination that someone shows you,

914
00:50:12,600 --> 00:50:17,120
is gee, are the things you make closed under that means of combination?

915
00:50:18,040 --> 00:50:22,280
如果序对仅仅只能是由数构成的序对的话 就不是那么有趣了
So pairs would not be nearly so interesting if all I could do was make a pair of numbers.

916
00:50:22,820 --> 00:50:24,400
我并不能用它构建出太多的结构
I couldn't build very much structure at all.

917
00:50:26,520 --> 00:50:27,780
好了 言归正传
OK, well, we'll come back to that.

918
00:50:28,080 --> 00:50:30,760
我现在只是提一下 后面我们还会详细讨论
I just wanted to mention it now. You'll hear a lot about closure later on.

919
00:50:31,780 --> 00:50:38,840
你也可以看到在我们有了层次系统后
You can also see the potential for losing control of complexity

920
00:50:38,840 --> 00:50:42,120
如果不使用数据抽象 系统复杂度会有失控的隐患
as you have a layered system if you don't use data abstraction.

921
00:50:43,680 --> 00:50:46,520
让我们回过头来看看LENGTH函数的幻灯片
Let's go back and look at this slide for length.

922
00:50:47,740 --> 00:50:51,880
LENGTH函数简单而有效是因为
Length works and is a simple thing because I can say,

923
00:50:52,840 --> 00:50:55,060
当我使用它时 我确信
when I want to get this value, I can say, oh,

924
00:50:55,300 --> 00:51:00,320
这个是第一个端点的X坐标
that is the x-coordinate of the first endpoint of the segment.

925
00:51:02,700 --> 00:51:06,560
这些东西 这些选择函数 X-COORDINATE 和 ENDPOINT
And each of these things, each of these selectors, x-coordinate and endpoint,

926
00:51:07,140 --> 00:51:10,960
都代表了一个决策选择 我不用关心它们的内部细节
stand for a decision choice whose details I don't have to look at.

927
00:51:11,940 --> 00:51:16,000
因此就和之前的有理数系统一样 我可以说
So I could perfectly well, again, just like rational numbers I did before,

928
00:51:16,000 --> 00:51:19,900
我可以认为 嗯 线段实际上就是由序对构成的序对
I could say, oh well, gee, a segment really is a pair of pairs.

929
00:51:20,800 --> 00:51:27,040
线段第一个端点的X坐标实际上是什么 是什么呢？
And the x-coordinate of the first endpoint or the segment really is the-- well, what is it?

930
00:51:27,040 --> 00:51:33,040
它的线段的CAR部分的CAR部分
It's the car of the car of the segment.

931
00:51:33,640 --> 00:51:36,640
所以我可以这样完美地重定义LENGTH
So I could perfectly well go and redefine length.

932
00:51:37,140 --> 00:51:46,420
我可以定义某线段S的长度为
I could say, define the length of some segment s.

933
00:51:48,640 --> 00:51:50,280
我这样来写
I can start off writing something like,

934
00:51:50,280 --> 00:51:56,000
我们令dX为 令dX为什么呢？
well, we'll let dx be-- well, what's it have to be?

935
00:51:56,000 --> 00:51:57,920
为两个坐标之差
It's got to be the difference of the two coordinates,

936
00:51:57,920 --> 00:52:05,820
坐标之一为(CAR (CAR S))
so that's the difference of, the first one is the car of the car of s,

937
00:52:08,140 --> 00:52:11,620
从第一个坐标中减去
subtracted from the first one,

938
00:52:11,620 --> 00:52:15,820
减去另一个点的坐标 也就是(CAR (CDR S))
the car of the other half of it, the cdr of s.

939
00:52:21,080 --> 00:52:24,920
好了 那么dY也就是 我看看
and then dy would be-- well, let's see,

940
00:52:25,920 --> 00:52:33,060
那么函数Y-COORDINATE也就是 (CDR (CAR S))
I'd get the y-coordinate, so it'd be the difference of the cdr of the car of s,

941
00:52:34,040 --> 00:52:41,260
减去(CDR (CDR S)) 诸如此类
and the cdr of the cdr of s, sort of go on.

942
00:52:43,760 --> 00:52:47,640
你可以发现同之前那个程序相比 这个更难度
You can see that's much harder to read than the program I had before.

943
00:52:47,920 --> 00:52:52,900
但比这个还糟的是 假设你这样实现了LENGTH函数
But worse than that, suppose you'd gone and implemented length?

944
00:52:56,520 --> 00:53:00,240
而第二天 George来和你说 抱歉 我改变主意了
And then the next day, George comes to you and says, I'm sorry, I changed my mind.

945
00:53:00,740 --> 00:53:03,940
我想把点的X坐标放在前面
I want to write points with the x-coordinate first.

946
00:53:04,860 --> 00:53:06,460
然后您回过头来看代码 找啊找啊
So you come back you stare at this code and say,

947
00:53:06,460 --> 00:53:10,100
那是什么呢 哦 是CAR
oh gee, what was that? That was the car,

948
00:53:10,100 --> 00:53:15,820
因此我要把这个改为CDR 把这个改为CDR
so I have to change this to cdr, and this is cdr,

949
00:53:17,020 --> 00:53:21,960
这个要改为CAR 这个也要改为CAR
and this now has to be car. And this has to be car.

950
00:53:23,480 --> 00:53:26,800
你也就这么做了 然后第二天George又跑来说 抱歉 抱歉
And you sort of do that, and then the next day George comes back and says, sorry,

951
00:53:27,120 --> 00:53:35,080
设计显示的那个家伙想要让线段指向反方向
Ah the guys designing the display would like lines to be painted in the opposite direction,

952
00:53:35,080 --> 00:53:37,260
因此我必须让截止点放到第一位
so I have to write the endpoint first in the order.

953
00:53:37,260 --> 00:53:38,820
然后你又回过头来审视这些代码
And then you come back and you stare at this code,

954
00:53:38,820 --> 00:53:42,040
哦 这又改怎么弄？
and say, gee, what was it talking about?

955
00:53:42,040 --> 00:53:44,080
嗯 把这个改为CDR
Oh yeah, well I've got to change this one to cdr,

956
00:53:45,020 --> 00:53:50,500
这个改为CAR 改为CAR 把这个改为CDR
and this one becomes car, this one comes car, and this becomes cdr.

957
00:53:50,500 --> 00:53:51,420
你又这么做了
And you go up and do that,

958
00:53:52,040 --> 00:53:53,820
第二天 George又跑过来说 太抱歉了
and then the next day, George comes back and says, I'm sorry,

959
00:53:53,820 --> 00:53:58,680
我其实只是想让线段总是在屏幕上从左向右描绘
what I really meant is that the segments always have to be painted from left to right on the screen.

960
00:53:59,220 --> 00:54:03,220
这时候 毫无疑问 你一定会给George一个耳光 #TBD
And then you sort of, it's clear, you just go and punch George in the mouth at that point.

961
00:54:03,220 --> 00:54:08,940
正如你所见 一旦我们有了一个10层的系统
But you see, as soon as we have a 10 layer system,

962
00:54:08,940 --> 00:54:11,040
复杂度也会像这里一样变得失控 #TBD
you see how that complexity immediately builds up

963
00:54:11,500 --> 00:54:14,240
 to the point where even something like this gets out of control.

964
00:54:15,940 --> 00:54:20,820
因此 为了避免发生这样的事 我们就要为精灵命名
So again, the way we've gotten out of that is we've named that spirit.

965
00:54:20,820 --> 00:54:24,400
我们构建一个系统 这个系统中有一个
We built a system where there is a thing,

966
00:54:25,140 --> 00:54:30,220

which is the representation choice for how you're going to talk about vectors.

967
00:54:31,180 --> 00:54:34,620
And choices about that representation are localized right there.

968
00:54:35,340 --> 00:54:37,460
They don't have their guts spilling over into things like

969
00:54:37,460 --> 00:54:39,460
how you compute the length and how you compute the midpoint.

970
00:54:41,000 --> 00:54:43,900
And that's the real power of this system.

971
00:54:45,320 --> 00:54:49,480
OK, we're explicit about them, so that we have control over them.

972
00:54:50,840 --> 00:54:51,460

好了 有疑问吗？
All right, questions?

973
00:54:51,600 --> 00:54:55,900
学生：在那些无法使用序对来表示的情况中会如何呢？
AUDIENCE: What happens in the case where you don't want to be treating objects in terms of pairs?

974
00:54:55,900 --> 00:55:01,180
比如说在三维空间里 一个序对无法表示三维坐标
For instance, in three-dimensional space, you'd have three coordinates.

975
00:55:01,180 --> 00:55:03,800
也就是说在n维空间中 我们该如何做呢？
Or even in the case where you have n-dimensional space, what happens?

976
00:55:03,800 --> 00:55:04,800
教授：啊 嗯
PROFESSOR: Right, OK.

977
00:55:04,800 --> 00:55:07,180
好吧 你提到了一点明天的内容
Well, this is a preview of what I'll say tomorrow.

978
00:55:08,020 --> 00:55:15,760
但关键点就是 一旦你有了二元的东西 就可以有多元的东西
But the point is, once you have two things, you have as many things as you want.

979
00:55:16,800 --> 00:55:18,640
能理解吗？ 如果我想要组合三个东西
All right? Because if I want to make three things,

980
00:55:19,040 --> 00:55:21,020
我构建一个序对
I could start making things like a pair

981
00:55:24,680 --> 00:55:25,980
该序对第一个元素是1
whose first thing is 1,

982
00:55:26,620 --> 00:55:32,380
第二个元素则又是一个序对 一个有2和3的序对
and whose second thing is another pair that, say, has 2 and 3 in it.

983
00:55:34,700 --> 00:55:36,620
以此类推 十个百个的东西 我可以把序对嵌套起来
And so on, a hundred things. I can nest them out of pairs.

984
00:55:37,180 --> 00:55:40,040
Here I made a pretty arbitrary decision about how to do it,

985
00:55:40,040 --> 00:55:42,320
and you can immediately see there are lots of ways to do that.

986
00:55:42,680 --> 00:55:45,920
What we'll start talking about next time are conventions for how to do things like that.

987
00:55:47,320 --> 00:55:50,360
只要注意到我可以构建由序对构成的序对就好了
But notice that what this really depends on is I can make pairs of pairs.

988
00:55:51,580 --> 00:55:53,900
因为我只能构建由数构成的序对的话 我就没法了
If all I could do was make pairs of numbers, I'd be stuck.

989
00:56:06,780 --> 00:56:10,040
好吧 休息
OK. Let's break.

990
00:56:11,060 --> 00:56:20,460
[音乐]
[JESU, JOY OF MAN'S DESIRING]

991
00:56:21,860 --> 00:56:28,000
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

992
00:56:38,000 --> 00:56:41,720
《计算机程序的构造和解释》
The Structure And Interpretation of Computer Programs

993
00:56:42,000 --> 00:56:45,600
讲师： 哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授
By: Prof. Harold Abelson && Gerald Jay Sussman

994
00:56:46,440 --> 00:56:49,940
复合数据
Compound Data

995
00:56:55,240 --> 00:56:57,340
好吧 我们刚才只是做了
All right, well, we've just gone off and done

996
00:56:59,240 --> 00:57:01,800
一个数据抽象的简单示例
a couple of simple examples of data abstraction.

997
00:57:03,620 --> 00:57:05,060
现在我想做点更复杂的事儿
Now I want to do something more complicated.

998
00:57:05,640 --> 00:57:07,120
稍后我会详细说明这意味着什么
We're going to talk about what it means.

999
00:57:07,900 --> 00:57:08,860
这也将更困难
And this will be harder,

1000
00:57:08,860 --> 00:57:12,940
因为在计算机程序设计中
because it's always much harder in computer programming

1001
00:57:12,940 --> 00:57:15,500
说明某件事的的意义远比实现它难 #TBD
to talk about what something means than to go off and do it.

1002
00:57:16,460 --> 00:57:21,600
让我们回到最最开始的地方
But let's go back to almost the very beginning.

1003
00:57:21,600 --> 00:57:24,640
还记得当时我说过的话么？
Let's go back to the point where I said,

1004
00:57:25,400 --> 00:57:27,900
我说 我们假设已经存在一些过程
we just assumed that there were procedures,

1005
00:57:29,800 --> 00:57:36,620
MAKE-RAT、NUMER以及DENOM
make-rat, and numer, and denom.

1006
00:57:38,120 --> 00:57:40,700
好吧 我们就回到那里 回到最开始的地方
Let's go back to where we had this, at the very beginning,

1007
00:57:41,740 --> 00:57:47,020
有构造函数和选择函数 以及定义有理数算术的地方
constructors and selectors, and when often defined the rational number arithmetic.

1008
00:57:47,020 --> 00:57:50,220

And remember, I said at that point we were sort of done, except for George.

1009
00:57:51,620 --> 00:57:54,340
那么 在那个时候我们实际上干了什么呢？
Well, what is it that we'd actually done at that point?

1010
00:57:55,580 --> 00:57:56,740
做了些什么东西呢？
What was it that was done?

1011
00:57:59,040 --> 00:58:00,100
我想说的就是
Well, what I want to say is,

1012
00:58:00,920 --> 00:58:05,240

what was done after we'd implemented the operations and terms of these,

1013
00:58:05,720 --> 00:58:12,000
我们用抽象数据来定义了有理数的表示
was that we had defined a rational number representation in terms of abstract data.

1014
00:58:18,060 --> 00:58:19,560
通过数据抽象我想表达什么？ #TBD
What do I mean by abstract data?

1015
00:58:20,700 --> 00:58:22,060
关键点就是
Well, the idea is that

1016
00:58:24,520 --> 00:58:27,140
在那个时候 当我们有了+RAT和*RAT
at that point, when we had our +RAT and our *RAT,

1017
00:58:28,580 --> 00:58:36,260
任何George提供给我们的MAKE-RAT NUMER和DENOM函数
that any implementation of make-RAT, and numerator, and denominator that George supplied us with,

1018
00:58:37,700 --> 00:58:39,840
都可以是有理数的表示基础
could be the basis for a rational number representation.

1019
00:58:40,620 --> 00:58:42,280
这是因为
Like, it wasn't our concern where you

1020
00:58:42,900 --> 00:58:46,460
#TBD
divided through to get the greatest common denominator, or any of that.

1021
00:58:48,540 --> 00:58:53,800
关键点就是 我们构建了一个有理数算术系统
So the idea is that what we built is a rational arithmetic system

1022
00:58:53,800 --> 00:58:56,200
一个可以基于任何表示方法的系统
that would sit on top of any representation.

1023
00:58:56,880 --> 00:58:58,360
“任何表示方法”又是什么意思呢？
What do I mean by any representation?

1024
00:58:59,620 --> 00:59:01,160
是指 当然这不会像
I mean, certainly it can't be the case

1025
00:59:01,820 --> 00:59:05,380

that all I mean is George can reach in a bag and pull out three arbitrary procedures

1026
00:59:07,140 --> 00:59:10,860

and say,well, fine, now that's the implementation.

1027
00:59:11,460 --> 00:59:12,740

That can't be what I mean.

1028
00:59:13,740 --> 00:59:19,000
我指的是这里有一种衡量方法
What I've got to mean is that there's some way of saying whether

1029
00:59:20,820 --> 00:59:25,760
可以判定这三个过程用于有理数的表示是否合适
three procedures are going to be suitable as a basis for rational number representation.

1030
00:59:25,760 --> 00:59:27,320
如果我们仔细思考这个问题
If we think about it,

1031
00:59:28,340 --> 00:59:31,800
我应该像这样定义 所谓的“合适”
what suitable might mean is if I have to assume something like this,

1032
00:59:31,800 --> 00:59:45,400
我会说 如果X是(MAKR-RAT N D)
I have to say that if x is the result of say, doing make-RAT of n and d,

1033
00:59:48,540 --> 01:00:07,060
那么(NUMER X)除以(DENOM X)等同于N除以D
then the numerator of x divided by the denominator of x is equal to n over d.

1034
01:00:09,360 --> 01:00:11,940
看到了吗 这就和George的契约
See, what that is is that's George's contract.

1035
01:00:13,400 --> 01:00:16,100
而我们契约中订好的有理数规则
What we mean by writing a contract for rational numbers,

1036
01:00:16,100 --> 01:00:17,680
你仔细想想的话 也是正确的
if you think about it, this is the right thing.

1037
01:00:18,480 --> 01:00:21,220

And the two ones we showed do the right thing.

1038
01:00:21,220 --> 01:00:23,220
这样的话 就算我要考虑最大公约数
See, if I'm taking out greatest common divisors,

