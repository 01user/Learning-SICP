MIT OpenCourseWare
http://ocw.mit.edu
6.001 Structure and Interpretation of Computer Programs, Spring 2005
Transcript – 2B: Compound Data

目前为止 我们这门课讨论的都是过程
Well, so far in this course we've been talking about procedures, 

而我想提醒大家的是 我们介绍的这个框架
and then just to remind you of this framework

是用来讨论语言的
that we introduced for talking about languages, 

我们讨论内建于系统中的基本元素
we talked about the primitive things that are built into the system.

我们介绍了一些组合的方法
We mentioned some means of combination

这些方法用来组合基本元素
by which you take the primitive things

使你能够构造更复杂的东西
and you make more complicated things.

然后我们讨论了抽象的方法
And then we talked about the means of abstraction,

你如何去取用这些复杂的东西
how you can take those complicated things 

并且给它们命名 使得可以像简单单元那样使用它  # TBD
and name them so you can use them as simple building blocks.

上节课的最后 我们甚至做了更超前的东西
And then last time you saw we went even beyond that.

我们看到 通过使用高阶过程
We saw that by using higher order procedures,

我们甚至可以表达计算的通用方法
you can actually express general methods for computing things.

这就像求不动点的方法和牛顿法
Like the method of doing something by fixed points, or Newton's method,

你可以通过组合这些抽象的方法
and so the incredible expressive power you can get

来得到这种难以执行的表达力 # TBD
just by combining these means of abstraction.

而这些的中心观点则是
And the crucial idea in all of this is the one

我们要构建一个层次系统 # TBD
hat we build a layered system.

譬如说
So for instance,

如果我们编写平方根过程
if we're writing the square root procedure,

而这个平方根过程又用到了一个叫good-enough的过程
somewhere the square root procedure uses a procedure called good-enough,

而这两者之间就有某种抽象边界 # TBD
and between those there is some sort of abstraction boundary.

这大概就像是我们开始编写平方根程序
It's almost as if we go out and in writing square root,

先要与George订好“合同”
we go and make a contract with George,

告诉他 他的工作是编写good-enough过程
and tell George that his job is to write good-enough,

因此只要good-enough按我们的预期运作
and so long as good-enough works,

我们就不管是如果运作的
we don't care what it does.

我们不关心（它的内部）实现
We don't care exactly how it's implemented.

这里的实现层面是Goerge操心的 和我们无关
There are levels of detail here that are George's concern and not ours.

譬如说
So for instance,

George如果用了Harry写的绝对值过程
George might use an absolute value procedure that's written by Harry,

我们不会去关心这些
and we don't much care about that

我们甚至可能还不知道有Harry这号人
or even know that, maybe, Harry exists.

关键点是当我们在构造东西时
So the crucial idea is that when we're building things,

我们将构造整体的任务划分为了实现部件的任务
we divorce the task of building things from the task of implementing the parts.

当然 在一个大型系统中
And in a large system, of course,

我们有像这样的抽象屏障
we have abstraction barriers like this

在很高很高很高层次上的抽象屏障
at lots, and lots, and lots of levels.

这也是我们到目前为止一直在使用的思想
And that's the idea that we've been using so far

贯彻到每次编写过程之中
over and over in implementing procedures.

书归正传 我们将要在数据中看到同样的问题
Well, now what we're going to do is look at the same issues for data.

我们将看到系统中有基本数据
We're going to see that the system has primitive data.

实际上我们已经看到了
In fact, we've already seen that.

我们已经看到了作为基本对象的数字
We've talked about numbers as primitive data.

我们将看到适用于数据的组合方法
And then we're going to see their means of combination for data.

有种“胶水” 让你把基本数据粘合在一起
There's glue that allows you to put primitive data together

来构造一种更复杂的符合数据
to make more complicated, kind of compound data.

然后我们将看到一种用于抽象的方法
And then we're going to see a methodology for abstraction

这种方法十分好用 尤其是
that's a very good thing to use

当你开始用简易的数据构造复杂数据时
when you start building up data in terms of simpler data.

再次强调 中心思想是要建立层次化的系统
And again, the key idea is that you're going to build the system in layers

建立抽象屏障将细节隔离在低层
and set up abstraction barriers that isolate the details at the lower layers

将细节与你所工作的高层环境隔离开
from the thing that's going on at the upper layers.

低层的细节 低层的思想 都不重要
The details at the lower layers, the ideas, they won't matter.

那是George该操心的
They're going to be George's concern

因为他跟我们“签了合同”
because he signed this contract with us

他负责实现这些行为
for how the stuff that he implements behaves,

怎么实现都是他的事
and how he implements the thing is his problem.

好了 来看一个实例吧
All right, well let's look at an example.

我们将会讨论一个系统
And the example I'm going to talk about is a system 

一个在有理数域上做算术运算的系统
that does arithmetic on rational numbers.

我现在所想到的是
And what I have in mind

计算机中应该有某种东西
is that we should have something in the computer

使得我们可以查询
that allows us to ask it,

比如说1/2加上1/4的和是多少
like, what's the sum of 1/2 and 1/4,

系统就会说 是3/4
and somehow the system should say, yeah, that's 3/4.

我们也可以查询3/4乘以2/3的积
Or we should be able to say what's 3/4 times 2/3,

系统因该能够回答 结果是1/2
and the system should be able to say, yeah, that's 1/2.

对吧？ 你知道我想表达的意思
Right? And you know what I have in mind.

我不太确定你们是多久掌握这些运算的
And you also know how to do this from, I don't know,

五年级或者六年级吧？
fifth grade or sixth grade.

这有一些公式说
There are these formulas that say

分数（有理数）是分子除以分母
if I have some fraction which is a numerator over a denominator,

而如果我要将这个分数与另一个分数相加的话
and I want to add that to some other fraction

当然 这个分数也是分子除以分母
which is another numerator over another denominator,

那么结果将会是 第一个分数的分子
then the answer is the numerator of the first

乘以第二个分数的分母
times the denominator of the second,

加上第二个分数的分子乘以第一个分数的分母
plus the numerator of the second times the denominator of the first.

当然 这只是答案的分子
That's the numerator of the answer,

答案的分母是两个分数的分母之积
and the denominator is the product of the two denominators.

对吧？ 这大概就是五、六年级课程的分数算术
Right? So there's something from fifth or sixth grade fraction arithmetic.

与之相似的 如果我想要将两个数乘起来
And then similarly, if I want to multiply two things,

n1除以d1的商 乘以 n2除以d2的商
n1 over d1 multiplied by n2 over d2

就是两个分数的分子之积除以两个分母之积的商
is the product of the numerators over the product of the denominators.

所以这些都不构成问题
So it's no problem at all,

当然 理解这些
but it's absolutely no problem to

你想进行的分数运算
think about what computation you want to make

是完全没问题的
in adding and multiplying these fractions.

但是当我们实现这个功能的时候 我们似乎错过了什么
But as soon as we go to implement it, we run up across something.

我们连有理数都没有
We don't have what a rational number is.

系统只给了我们单个的数字
So we said that the system gives us individual numbers,

比如5和3
so we can have 5 and 3,

但我们没有去表达一个
but somehow we don't have a way of saying

同时具有一个3和一个4的东西
there's a thing that has both a 3 and a 4 in it,

或者一个2和一个3的东西
or both a 2 and a 3. 

但只要我们去想象
It's almost as if we'd like to imagine

我们就会看到一些云彩
that somehow there are these clouds,

某个云彩不知咋的同时具有分子和分母
and a cloud somehow has both a numerator and a denominator in it,

这就是我们想有的语言形式 #TBD
and that's what we'd like to work in terms of.

那么 我们要怎么解决这个问题呢？
Well, how are we going to solve that problem?

我们将使用一种强大的设计策略来解决这个问题
We're going to solve that problem by using this incredibly powerful design strategy

这种策略我们已经反复使用过了
that you've already seen us use over and over.

这就是按愿望思维 #TBD
And that's the strategy of wishful thinking.

就像我们之前并没有任何过程一样
Just like before when we didn't have a procedure,

我们就想象确实存在着某个过程
we said, well, let's imagine that that procedure already exists.

那么 我们就来想象我们有了（有理数）这些云彩吧
We'll say, well, let's imagine that we have these clouds.

更准确一点来说
Now more precisely what I mean is

让我们假设我们有了三个过程
let's imagine that we have three procedures，

其一为MAKE-RAT
one called MAKE-RAT.

MAKE-RAT有两个参数
MAKE-RAT is going to take as arguments two numbers,

我们分别把它们叫作分子和分母
so I'll call them numerator and denominator,

它给我们返回一朵云彩——我们需要的云彩
and it'll return for us a cloud-- one of these clouds.

我并不知道云彩是什么
I don't really know what a cloud is.

无论MAKE-RAT返回什么 那都是它的事
It's whatever MAKE-RAT returns, that's its business.

并且我们将会说
And then we're going to say,

假设我们有了一个这种云彩
suppose we've got one of these clouds,

我们有个叫NUMBER的过程
we have a procedure called NUMBER,

这个过程需要我们传递有n和a的云彩
which takes in a cloud that has an n and a d in it,

不管这个云彩是什么 我不知道这个云彩是什么
whatever a cloud is, and I don't know what it is,

但NUMBER过程会返回（云彩的）分子部分
and returns for us the numerator part.

我们也会假设我们有个叫DENOM的过程
And then we'll assume we have a procedure DENOM,

该过程需要我们传递一个云彩 不管云彩是什么
which again takes in a cloud, whatever a cloud is,

并返回（云彩的）分母部分
and returns for us the denominator part.

就像先前我们构造平方根过程一样
This is just like before, when if we're building a square root,

我们假设我们有GOOD-ENOUGH过程
we assume that we have good-enough.

对吧？ 我们会找到George 对他说
Right? And what we'll say is, we'll go find George, and we'll say to George,

那么 你的任务就是实现这三个过程
well, it's your business to make us these procedures.

你选择如何实现这些云彩 就是你的事了
And how you choose to implement these clouds, that's your problem.

我们不想知道
We don't want to know.

这样 把这些杂事都推给George后
Well, having pushed this task off onto George,

完成其它部分就相当容易了
then it's pretty easy to do the other part.

一旦我们有了这些云彩后 编写那些
Once we've got the clouds, it's pretty easy to write the thing

把有理数加起来的程序就变得容易多了
that does say addition of rational numbers.

你可以定义 这么说吧 定义+RAT
You can just say define, well, let's say +RAT.

定义+RAT过程 该过程需要两个有理数参数 x和y
Define +RAT, which will take in two rational numbers, x and y.

x和y就是这些云彩
x and y are each these clouds.

这个过程干些啥呢？
And what does it do?

它将返回给我们一个有理数
Well, it's going to return for us a rational number.

这个有理数是怎么得来的呢？
What rational number is it?

依据我们这里的公式
Well, we've got the formulas there.

结果的分子的一部分为
The numerator of it is the sum of

x的分子与y的分母之积
the product of the numerator of x and the denominator of y.

这只是结果的分子的一部分
It's one thing in the sum.

结果的分子剩下的一部分是
And the other thing in the numerator is

y的分子与x的分母之积
the product of the numerator of y and the denominator of x.

闭合* 闭合+
The star, close the plus.

好了 这是MAKE-RAT的第一个参数
Right, that's the first argument to MAKE-RAT,

这是我将要构造的云彩的分子
which is the numerator of the thing I'm constructing.

而MAKE-RAT剩下的参数
And then the rest of the thing goes into MAKE-RAT is

则是结果的分母
the denominator of the answer,

也就是x的分母乘以y的分母
which is the product of the denominator of x and the denominator of y.

像这样
Like that.

好 这就是对有理数加法的一个模拟
OK? So there is the analog of doing rational number addition.

在假设我们有了这些云彩后 就变得完全没有问题
And it's no problem at all, assuming that we have these clouds.

当然 我们可以用同样的方法把它们乘起来
And of course, we can do multiplication in the same way.

我们把将两个有理数乘起来定义为*RAT
Define how to get the product of two rational numbers, call it *RAT.

该过程需要两朵云彩 x和y
Takes in two of these clouds, x and y,

返回一个用MAKE-RAT构造的有理数
it returns a rational number, MAKE-RAT,

这个有理数的分子是
whose numerator is the product of the numerators--

x的分子与y的分子之积
numerator of x times the numerator of y.

而这个有理数的分母则是
And the denominator of the thing it's going to return

x的分母与y的分母之积
is the product of the denominators.

11:04 #TBD
Well, except that I haven't told you what these clouds are,


that's all there is to it. See, what did I do?

我按照我的期许假设我有一种新的数据类型
I assumed by wishful thinking that I had a new kind of data object.

特别的 我假设我有创建这些数据类型的能力
And in particular, I assumed I had ways of creating these data objects.

这里的MAKE-RAT就创建了一个新的数据类型
MAKE-RAT creates one of these things.

这叫作“构造函数”
This is called a constructor.

我现在有了可以构造这些数据类型的东西了
All right, I have a thing that constructs such data objects.

然后我假设我有某些东西 有了这些东西后
And then I assume I have things that, having made these things,

我就可以从中抽取部分信息的方法了
I have ways of getting the parts out.

这些叫作“选择函数”
Those are called selectors.

把之前我所说的更加正式化一点 就是说
And so formally, what I said is I assumed

我假设我有了用于处理这些数据类型的构造函数和选择函数
I had procedures that are constructors and selectors for these data objects,

那我就可以使用它们 # TBD - Went off
and then I went off and used them.

这就和我说我假设我有GOOD-ENOUGH?过程
That's no different in kind from saying I assume I have a procedure GOOD-ENOUGH?,

并用它来实现平方根这种做法没有区别
and I go use it to implement square root.

好 在我们继续之前
OK, well before we go on,

让我们来想想 为什么我们首先就在这个地方实现了这些东西？
let's ask the question of why do we want to do this in the first place?

为什么我们需要一个像+RAT一样的过程
See, why do we want a procedure like +RAT

一个需要两个有理数作为参数并返回一个有理数的过程
that takes in two rational numbers and returns a rational number?

换一种想法就是 我们实现的是这里的这个公式
See, another way to think about this is, well, here's this formula.

这里我也实现了用于加和两个有理数的东西
And I've also got to implement something that adds rational numbers.

再换一种想法就是 这有这么一个东西
One other way to think about is, well, there's this thing,

可以让我输入四个数 n1 d1 n2 d2
and I type in four numbers, an n1, and a d1, and an n2, and a d2.

然后这个东西就修改机器里的寄存器
And it sets some registers in the machine

来代表分子和分母
to this numerator and this denominator.

所以你大概会问
So I might say, well,

你为什么不用四个分别代表分子和分母的数
why don't I just add rational numbers by I type in four numbers,

来做有理数加法
numerators and denominators,

这个加法返回两个数 分别代表分子和分母
and get out two numbers, which is a numerator and a denominator.

我们为什么要关心像这样构造东西？ #TBD
Why are we worrying about building things like this anyway?

呃 那是因为
Well, the answer is,

假设你想表达像这样的东西
suppose you want to think about expressing something like this,

假设我想表达“采用”两个有理数的思想
suppose I'd like to express the idea of taking two rational numbers,

x加y的和乘以s加上t的和
x plus y, say, and multiplying that by the sum of two other rational numbers.

然而 当我有了像+RAT和*RAT这样的东西后
Well, the way I do it, having things like +RAT and *RAT,

我就会将其考虑为乘积
is I'd say, oh yeah, what that is is just the product.

就是将*RAT应用于x和y的和以及s和t的和上
That's *RAT of the sum of x and y and the sum of s and t.

除了语法 我还能得到一个表达式 # TBD
So except for syntax, I get an expression

这个表达式看起来像是按照数学思想表达的
that looks like the way I want to think about it mathematically.

我说这有两个数
I want to say there are two numbers.

这个东西代表了这两个数的和
There's a thing which is the sum of them,

然而这个东西又代表了另两个数的和
and there's a thing which is the sum of these two.

就是这个和这个
That's this and this.

然后我把它们乘起来
And then I multiply them.

所以我有了一个和这里的表达式相匹配的表达式
So I get an expression that matches this expression.

而如果我用其它的方式去表达
If I did the other thing, if I said, well,

我表达为 我传递向机器传递四个数
the way I want to think about this is I type into my machine four numbers,

四个分别代表x和y的分子、分母的数
which are the numerators and the denominators of x and y,

然后又是四个分别代表s和t的分子、分母的数
and then four more numbers, which are the numerators and denominators of s and t.


And then what I'd be sitting with is, well, what would I do?

我把这些加起来 不知咋的我们就得到了两个临时变量
I'd add these, and somehow I'd have to have two temporary variables,

分别代表了和的分子、分母
which are the numerators and denominators of this sum,

我又得去找个地方把它们存储起来
and I'd go off and store them someplace.

然后到了这里 我又传入了四个数
And then I'd go over here, I'd type in four more numbers,

我又有了两个临时变量
I'd get two more temporary variables,

分别代表了s和t之和的分子和分母
which are the numerators and denominators of s and t.

最后 我通过把它们乘起来来将其结合在一起
And then finally, I put those together by multiplying them.

如你所见 麻烦出来了
You see, what's starting to happen,

这里满是临时变量
there are all these temporary variables,

这些应该是这些有理数内部的“内脏”吧
which are sort of the guts of the internals of these rational numbers

但却显露在我们的系统中
that start hanging out all over the system.

当然 随着表达式变得越来越复杂
And of course, if I had more and more complicated expressions,

这些“内脏”就会显露得越来越多 使我编程时感到困惑
there'd be more and more guts hanging out that confuse my programming.

像这样写程序的人
And those of you who sort of programmed things like that,

你只是在用汇编语言的思想来加和两数
where you're just adding numbers in assembly language,


you sort of see you have to suddenly be concerned with these temporary variables.

而这些对我大脑造成的困惑
But more importantly than confusing my programming,

要比对编程造成的困惑更严重
they're going to confuse my mind.


Because the whole name of this game is that

我们希望程序设计语言能够表达
we'd like the programming language to express

我们脑中的概念
the concepts that we have in our heads,

有理数就是这些概念
like rational numbers are things

我们可以先把它们加起来然后再乘起来
that you can add and then take that result and multiply them.

有疑问吗？
Let's break for questions.

恩
Yeah?

学生：我不太明白为什么
AUDIENCE: I don't quite see the need-

既然我们有MAKE-RAT过程了
when we had MAKE-RAT with the numerator and denominator,

我们将传递两个参数作为分子和分母来构造一朵云彩
we had to have the numerator and denominator to pass as parameters to create the cloud,

但最后我们又从中将这些东西给抽取出来
and then we extracted to get back what we had to have originally.

教授：非常正确
PROFESSOR: That's right.

我们的问题是 既然我们是用分子和分母构造云彩
So the question is, I sort of have the numerator and the denominator,

但我为什么又想从云彩里面把它们取出来呢？
why am I worrying about having the cloud given that I have to get the pieces
out?

这个是我在后面提到过的 不过让我在说一次吧
That's sort of what I tried to say at the end, but let me try and say it again,

这个问题非常关键 关键点就是
because that's really the crucial question. The point is,

我想让分子和分母总是在一起
I want to carry this numerator and denominator around together all the time.


And it's almost as if I want to know, yeah,

这里面有分子和分母
there's a numerator and denominator in there,

同样的 我也想表达
but also, I would like to say, fine,

但是 从另一个角度来看 这就是x
but from another point of view, that's x.

我可以取用x 我给它命名为x hold # TBD
And I carry x around, and I name it as x, and I hold it.

然后我就可以说 x加上y的和
And I can say things like, the sum of x and y,

我只考虑一个x的时候 使用代表分子和分母的数并无大碍
rather than just have-- see, it's not so bad when I only think about x,

但是当我有10个有理数时
but if I have a system with 10 rational numbers,

如果我不把它们联系起来
suddenly I have 20 numerators and denominators,

我一下子就有了20个不必要的分子和分母
which are not necessarily-- if I don't link them,

它们只是20个没有以一种特定方式联系起来的任意数而已
then it's just 20 arbitrary numbers that are not linked in any particular way.

这就像是说
It's a lot like saying, well,

这里我有这些过程体的指令
I have these instructions that are the body of the procedures,

为什么我把它们封装起来作为一个过程
why do I want to package them and say it's the procedure?

这是一码子事儿
It's exactly the same idea.

没问题了 好吧
No? OK.

那休息一下 活动一下吧 [听不清]
Let's break, let's just stretch and get somebody-- [INAUDIBLE]

[音乐]
[JESU, JOY OF MAN'S DESIRING]

好吧 回到我们的有理数算术系统来
OK, well, we've been working on this rational number arithmetic system,

而我们所做的 最重要的则是
and then what we did, the important thing about what we did,

我们我们把这个问题分解为了两部分
is we thought about the problem by breaking it into two pieces.

我们假设我们跟George“签了合同”
We said, assume there is this contract with George,

George已经给出了如何去构造这些云彩
and George has figured out the way to how to construct these clouds,

他给我们提供了一个作为构造函数的MAKE-RAT过程
provided us procedures MAKE-RAT, which was a constructor,

相应的 用于提取分子和分母的选择函数
and selectors, which are numerator and denominator.

然后 我们用这些东西
And then in terms of that,

我们实现了有理数的加法和乘法
we went off and implemented addition and multiplication of rational numbers.

好了 我们来看看George面临的问题吧
Well, now let's go look at George's problem.

我们如何来把分子和分母给封装起来
How can we go and package together a numerator and a denominator

并把它们放在“云彩”里
and actually make one of these clouds?

我们需要的是一种胶水
See, what we need is a kind of glue,

一种可以让我们把数据结合在一起的胶水
a glue for data objects that allows us to put things together.

Lisp提供了这样的胶水
And Lisp provides such a glue,

我们把它叫作“表结构”
and that glue is called list structure.

表结构是一种将数据粘合在一起的工具
List structure is a way of gluing things together,

说得更准确一点
and more precisely,

就是Lisp提供了一种叫序对的构造方法 #TBD
Lisp provides a way of constructing things called pairs.

Lisp里面有一个叫CONS的基本过程
There's a primitive operator in Lisp called CONS.

让我们来看一下
We can take a look at it.

这个就是CONS
There's a thing called CONS.

CONS是一个运算符 它需要两个参数X和Y
Cons is an operator which takes in two arguments called x and y,

它返回给我们一个叫作“序对”的东西
and it returns for us a thing called a pair.

而所谓的“序对” 就是指它有“首部分”和“次部分” #TBD
All right, so a thing called a pair that has a first part a second part.

这也解释了为什么CONS需要两个参数
So CONS takes two objects.

如果我们有一个序对的话
There's a thing called a pair.

X就是首部分 而Y就是次部分
The first part of the cons is X, and the second part of the cons is Y.

这就是它的构造方式        
And that's what it builds.

我们同样也有把东西取出来的方法
And then we also assume we have ways of getting things out.

给定一个序对 我们有一个叫CAR的东西
If you're given a pair, there's a thing called CAR,

使得 序对P的CAR就是序对P的首部分
and car of a pair, P, gives you out the first part of the pair, P.

也有一个叫CDR的东西
And there's a thing called CDR,

而序对P的CDR 就返回序对P的次部分
and CDR of the pair, P, gives you the second part of the pair, p.

这些就是我们构造数据的方法
OK, so that's how we construct things.

在将这些数据用图画表示时 我们也有一种俗成的方法
There's also a conventional way of drawing pictures of these things.

Just like we write down that as the conventional way of writing Plato's idea of two, the way we could draw a diagram to represent cons of two and three is like this.

先画个小盒子
We draw a little box.

这个就是我们讨论的（序对）
And so here's the box we're talking about,

它用两个从中放出的箭头 #TBD
and this box has two arrows coming out of it.

我们说 这个序对的首部分是2
And say the first part of this pair is 2,

而这个序对的次部分是3
and the second part of this pair is 3.

这种记法叫作“盒子—指针”记法
And this notation has a name, it's called box and pointer notation.

顺带一提 我现在就来说说
By the way, let me say right now

that a lot of people get confused

that there's some significance to the geometric way I drew these pointers, the directions.

一些人可能会认为 如果我这样画箭头
Like some people think it'd be different if I took this pointer 

并把3放在这里 结果会不一样
and turned it up here, and put the 3 out here.

这实际上是没区别的 能理解吗？
That has no significance. All right?

It's merely you have a bunch of arrows, these pointers, and the boxes.

唯一的区别就在于它们是如何链接的
The only issue is how they're connected,

而不是我把它们怎么放置 譬如向上放 向下放 或者交叉放
not the geometric arrangement of whether I write the pointer across, or up, or down.


Now it's completely un-obvious,


probably, why that's called list structure.

我们今天不会讨论这个问题
We're not actually going to talk about that today.

我们下次再讨论吧
We'll see that next time.
 
所以 我们可以用CONS构造序对
So those are pairs, there's CONS that constructs them.


And what I'm going to know about CONS, and CAR, and CDR,


is precisely that if I have any X and Y, all right,

对任意的X和Y
if I have any things X and Y,

我可以用CONS来构造一个序对
and I use CONS to construct a pair,

那么该序对的CAR就是X 就是我的构造时的一个输入
then the CAR of that pair is going to be X, the thing I put in,

而该序对的CDR就是Y
and the CDR of that pair is going to be Y.

这就是CONS、CAR、CDR这些运算符的行为
That's the behavior of these operators, CONS, CAR, and CDR.

有了这些东西 George构造有理数就明了多了
Given them, it's pretty clear how George can go off and construct his rational numbers.

言归正传 
After all, all he has to do--

记得吗 George的任务是实现MAKE-RAT、NUMER、DENOM过程
remember George's problem was to implement MAKE-RAT, numerator, and denom.

George这样编写代码 定义用N和D来MAKE-RAT
So all George has to do is say define MAKE-RAT of some N and a D--

就是将CONS应用于这二者
so all I have to do is CONS them.

也就是(CONS N D)
That's CONS of N and D.

而如果我想取出分子
And then if I want to get the numerator out,

代码我这样写 定义有理数X的NUMER
I would say define the numerator, numer, of some rational number, X.

如果我们是用序对来实现有理数的话
If the rational number's implemented as a pair,

我只需要用CAR来获得X的首部分
then all I have to do is get out the CAR of X.

类似的 DENOM就是用CDR运算符了
And then similarly, define the denom is going to be the cdr,

也就是我用于构造序对的另一个数据
the other thing I put into the pair.

我们现在就是在干这件事
Well, now we're in business.

这就是有理数的一种实现
That's a complete implementation of rational numbers.

我们来实践一下
Let's use it.

假设我想要
Suppose I want to say,

我想要求取1/2加上1/4 并观察系统是怎么运作的
so I want to think about how to add 1/2 plus 1/4 and watch the system work.

那么 我或许会定义一个A
Well, the way I'd use that is I'd say, well, maybe define A.

我需要构造一个1/2
I have to make a 1/2.

也就是一个分子为1 分母为2的有理数
Well, that's a rational number with numerator 1 and denominator 2,

也就是 A为(MAKE-RAT 1 2)
so a will be MAKE-RAT of 1 and 2.

然后我来构造1/4
And then I'll construct the 1/4.

我定义B为(MAKE-RAT 1 4)
I'll say define B to be MAKE-RAT of 1 and 4.

如果我想解得答案的话
And if I'd like to look at the answer--

先假设我们没有一个专门用于打印有理数的东西
well, assuming I don't have a special thing that prints rational numbers,

我可以自己编写一个
or I could make one--

比如说 我可以这样写
I could say, for instance,

定义答案为(+RAT A B)
define the answer to be +RAT of A and B,

那么我就可以问 答案是多少？
and now I can say, what's the answer?

答案的分子和分母分别是多少？
What are the numerators and denominators of the answer?

因此 我把1/2和1/4加起来后 我会问 答案的分子是多少？
So if I'm adding 1/2 and 1/4, I'll say, what is the numerator of the answer? 

这个系统就应该打印出 6
And the system is going to type out, well, 6. 

糟糕了
Bad news.

而如果我问答案的分母是多少
And if I say what's the denominator of the answer,

系统就应该打印出8
the system's going to type out 8.

我们本来希望能得到
So instead of what I would really like,

1/2加1/4是3/4
which is for it to say that 1/2 and 1/4 is 3/4,

但这台愚蠢的机器却说 不 应该是6/8
this foolish machine is going to say, no, it's 6/8.

恩 这的确有点糟糕
Well, that's sort of bad news.

问题在哪里呢？
Where's the bug?

是什么导致的呢？
Why does it do that, after all?

问题出在+RAT上
Well, it's the way that we just had +RAT.

+RAT只是把A的分子和B分母之积与
+RAT just took the-- it said you add the numerator times the denominator,

B的分子和A的分母之积加在一起
you add that to the numerator times the denominator,

并把它们除以两分母之积
and put that over the product of the two denominators,

这就是为什么得到6/8的原因
and that's why you get 6/8.

那么 我们的+RAT实现有什么问题呢？
So what was wrong with our implementation of +RAT?

我们在此之前所做的有理数算术又有什么错误呢？
What's wrong with that rational number arithmetic stuff that we did before the break?

当然 从一方面来看 这一点都没有错
Well, the answer is one way to look at it is absolutely nothing's wrong. 

这其实是一个相当好的实现
That's perfectly good implementation.

这个实现完完全全遵守了分数加法法则
It follows the sixth grade, fifth grade mathematic for adding fractions.

我们可以这样说 这就是George的问题了
One thing we can say is, well, that's George's problem.


Like, boy, wasn't George dumb to say that he can make a rational number 


simply by sticking together the numerator and the denominator?

在构造有理数时 如果George把这些东西化到最简
Wouldn't it be better for George, when he made a rational number,

难道不是会跟好一点吗？
to reduce the stuff to lowest terms?

我想说的是 对George来说
And what I mean is, wouldn't it be better for George,

用这个版本的MAKE-RAT 难道会比幻灯片上的这个好么？
instead of using this version of MAKE-RAT, to use this one on the slide?

不是简单的通过CONS 把N和D结合起来
Or instead of just saying CONS together N and D,

我们先寻找N和D的最大公约数
what you do is compute the greatest common divisor of N and D,

我们用GCD过程来找
and GCD is the procedure which,

我们只需知道GCD是一个基本过程
well, for all we care is a primitive,

它返回的是两个数的最大公约数
which computes the greatest common divisor of two numbers.

因此 这种构造有理数的方法就是
So the way I can construct a rational number is

先找到两数的最大公约数
get the greatest common divisor of the two numbers,

先用G来表示吧
and I'm going to call that G,

不是简单通过CONS结合N、D 而是先让它们除以G 
and then instead of consing together N and D, I'll divide them through.

然后我再用CONS结合N/G和D/G的商
I'll CONS together the quotient of N by the the GCD and the quotient of
D by the GCD.

这样就把我们的有理数化到了最简
And that will reduce the rational number to lowest terms.

因此 当我在做加法时 当+RAT调用MAKE-RAT过程时
So when I do this addition, when +RAT calls MAKE-RAT--

+RAT的定义里面有对MAKE-RAT的调用
and for the definition of +RAT it had a MAKE-RAT in there--

因此 当+RAT构造有理数时
just by the fact that it's constructing that,

MAKE-RAT就自动将其化为最简了
the thing will get reduced to lowest terms automatically.

好了 这就是一个完整的系统
OK, that is a complete system.

让我们来看看我们完成的这个有理数算术系统吧
For rational number arithmetic, let's look at what we've done.

好吧 我们说过我们想要构造一个有理数算术系统
All right, we said we want to build rational number arithmetic,

我们实现了+RAT
and we had a thing called +RAT. We implemented that.

我也给你们展示了*RAT的实现
And I showed you multiplying rational numbers,

虽然我并没有去实现-RAT
and although I didn't put them up there,

就姑且假设我们实现了-RAT吧
presumably we'd like to have something that subtracts rational numbers,

事实上这些事我都不知道
and I don't know, all sorts of things.


Things that test equality in division,


and maybe things that print rational numbers in some particular way.

我们用序对的方式实现了它们
And we implemented those in terms of pairs.

序对、CONS、CAR和CDR 这些都是内建于Lisp中的
These pairs, CONS, CAR, and CDR that are built into Lisp.

而两者之间最重要的则是
But the important thing is that between these and these,

我们在其间构筑了一道抽象屏障 一个抽象层
we set up an abstraction barrier. We set up a layer of abstraction.

那么 “抽象层”又是什么呢？
And what was that layer of abstraction?

准确的说 构造函数和选择函数就是抽象层
That layer of abstraction was precisely the constructor and the selectors.

MAKE-RAT、NUMER、DENOM也是抽象层
This layer was MAKE-RAT, and NUMER, and DENOM.

这种方法学 也就是我们的做法
This methodology, another way to say what it's doing,


is that we are separating the way something is used,

我们把数据对象的使用
separating the use of data objects,

和它们的表示分离开来
from the representation of data objects.

到此为止 我们有了使用有理数做计算的方法
So up here, we have the way that rational numbers are used, do arithmetic on them.

在这儿 我们有它们表示的方法
Down here, we have the way that they're represented,

它们通过这条边界分隔开
and they're separated by this boundary.

这条边界就是构造函数和选择函数
The boundary is the constructors and selectors.

这种方法学有个名字
And this methodology has a name.

叫做数据抽象
This is called data abstraction.

数据抽象是一种通过假定的构造函数和选择函数将数据对象
Data abstraction is sort of the programming methodology of setting up data objects

与它的表示分隔开来的编程方法学
by postulating constructors and selectors to isolate use from representation.

那么 这指什么呢 #TBD
Well, so why? I mean, after all, we didn't have to do it this way.

当然就算不用任何复合对象
It's perfectly possible to do rational number addition

做有理数加法也是完全可行的
without having any compound data objects,

幻灯片上就是一个例子
and here on the slide is one example.

我们当然可以这样定义+RAT
We certainly could have defined +RAT,

它需要两个参数x和y
which takes in things x and y,

而我们会问
and we'll say,

这些有理数到底是什么呢？
well what are these rational numbers really?

实质上 它们只是序对
So really, they're just pairs,

分子是序对的car部分 分母是cdr部分
and the numerator's the car and the denominator's the cdr.

我们要做的 就是取出x的car部分乘以y的cdr部分
So what we'll do is we'll take the car of x times the cdr of y,

并把它们乘起来
multiply them.

取出y的car部分和cdr部分相乘
Take the car of y times the cdr of x, multiply them.

再与之前的结果相加
Add them.

取出x的cdr部分乘以y的cdr部分
Take the cdr of x and the cdr of y, multiply them,

并把最终结果构造起来
and then constitute together.

这其实是一样的
Well, that sort of does the same thing.

但这种方法忽略了把对象归约到最低阶项的问题
But this ignores the problem of reducing things to lowest terms,

让我们花点时间仔细思考一下
but let's not worry about that for a minute.

我们为什么不这样做呢？这又如何呢？
But so what? Why don't we do it that way? 

对吧 毕竟这样看起来会少定义很多过程
Right? After all, there are sort of fewer procedures to define,

并且更加直白
and it's a lot more straightforward.

它省去了所有的这些关于数据抽象的自以为是的BS #TBD
It saves all this self-righteous BS about talking about data abstraction.

我们就是这样做的 #TBD
We just sort of do it.

我的意思是这样或许会稍微高效一点
I mean, who knows, maybe it's even marginally more efficient


depending on whatever compiler were using for this.

而将数据的使用与表示分离开来的意图是什么呢？
What's the point of isolating the use from the representation?

这就将回到进行命名的记号了
Well, it goes back to this notion of naming.

还记得吗 编程中最重要的原理
Remember, one of the most important principles in programming

和魔法中最重要的原理是一样的 对吧？
is the same as one of the most important principles in sorcery, all right?

这就是你知道某个精灵的名字 你便可以控制它
That's if you have the name of the spirit, you get control over it.

如果你回过头来看幻灯片
And if you go back and look at the slide,

你会发现这里我们就有一个+RAT
you see what's in there is we have this thing +RAT,

如果我们有+RAT -RAT *RAT 或者和这些类似的过程
but nowhere in the system, if I have a +RAT and a -RAT and a *RAT,

但在这个系统的任何地方
and things that look like that,

我无法找出任何一个有理数
nowhere in the system do I have a thing that I can point at which is a rational number.

在像这样的一个系统中 我并没有
I don't have, in a system like that,

没有一个有理数的概念实体
the idea of rational number as a conceptual entity.

那么 这样做的优势是什么呢？
Well, what's the advantage of that?


What's the advantage of isolating the idea of rational numbers as a conceptual entity,

然后用
and really naming it with make-RAT, numerator, and denominator.

优点之一就是你可以使用其它的方法表示（数据）
Well, one advantage is you might want to have alternative representations.


See, before I showed you that one way George can solve this

things not reduced to lowest terms problem,

is when you build a rational number,

you divide up by the greatest common denominator.

另一种解决办法在这里
Another way to do that is shown over here.

我可以用另一种方法表示有理数
I can have an alternative representation for rational numbers

也就是仅仅使用cons来构建有理数
where when you make a rational number, you just cons them.

而当你在析取去分子时
However, when you go to select out the numerator,

在那个时候再计算分子分母的最大公约数
at that point you compute the gcd of the stuff that's sitting in that pair,

然后再用分子除以这个最大公约数
and divide out by the gcd.

类似地 当我析取分母时
And similarly, when I get the denominator,

当我在析取出分母时 我将它除以最大公约数
at that point when I go to get the denominator, I'll divide out by the gcd.

所以在旧的表示法中
So the difference would be in the old representation,

当ans在这里被构造时
when ans was constructed here,

在第一种方法中 也就是6和8
say what's 6 and 8, in the first way,

在6和8被装入表中时 它们已经被化到最简
the 6 and 8 would have got reduced when they got stuck into that pair,

析取分子会得到3
numerator would select out 3.

而在我给你们展示的方法中
And in the way I just showed you,

我们放入的是6和8
well, ans would get 6 and 8 put in,

然后在我析取分子时会进行一些计算
and then at the point where I said numerator,

使得我得到3而非6
some computation would get done to put out 3 instead of 6.

这就是我可以使用的两种不同方法
So those are two different ways I might do it.

哪种更好呢？
Which one's better?

这得看情况 对吧？
Well, it depends, right?

如果我的系统中我经常构造有理数
If I'm making a system where I am mostly constructing rational numbers

而不常去析取它们
and hardly ever looking at them,

那么早构造它们时就最好不要化简
then it's probably better not to do that gcd computation when I construct them.

如果在我的系统中 比起构造 我更经常去析取它们
If I'm doing a system where I look at things a lot more than I construct them,

那在构造时就将它们化简就一劳永逸了
then it's probably better to do the work when I construct them.

这得视情况做出选择
So there's a choice there.

但真正的问题是 在你实现这些有理数时
But the real issue is that you might not be able to decide

没法决定要用哪种表示法
at the moment you're worrying about these rational numbers.

通常来说 作为一名系统设计师
See, in general, as systems designers,

[36.25]
you're forced with the necessity to make decisions about how you're going to do things,

and in general, the way you'd like to retain flexibility

is to never make up your mind about anything until you're forced to do it.


The problem is, there's a very, very narrow line between 

deferring decisions and outright procrastination.


So you'd like to make progress, but also at the same time,

never be bound by the consequences of your decisions.


Data abstraction's one way of doing this.

我的做的就是“按愿望思想”
What we did is we used wishful thinking.

我们给结果命了个名字
See, we gave a name to the decision.

我们让MAKE-RAT、NUMER、DENOM代表它们运作的结果
We said, make-RAT, numerator, and denominator will stand for however it's going to be done,

但它们如何运作则是George的事
and however it's going to be done is George's problem.


But really, what that was doing is giving a name to the decision of how we're going to do it,


and then continuing as if we made the decision.

And then eventually, when we really wanted it to work,

coming back and facing what we really had to do.

And in fact, we'll see a couple times from now that

you may never have to choose any particular representation, ever, ever.

不管如何 这都是一种非常有用的设计技术
Anyway, that's a very powerful design technique.

这也是人们使用数据抽象的原因
It's the key to the reason people use data abstraction.

我们会不断的看到这个理念
And we're going to see that idea again and again.

有什么问题吗？
Let's stop for questions.

学生：
AUDIENCE: What does this decision making through abstraction layers do

to the axiom of do all your design before any of your code?

教授：嗯 这只是少数人的信条
PROFESSOR: Well, that's someone's axiom,

我打赌这是那些不经常实现大型计算机系统的家伙的信条
and I bet that's the axiom of someone who hasn't implemented very large computer systems very much.

我曾说过计算机科学非常像是魔法
I said that computer science is a lot like magic,

像魔法这一点非常好
and it's sort of good that it's like magic.

但是计算机科学也非常像宗教 这就不好了
There's a bad part of computer science that's a lot like religion.

通常来说 我认为那些
And in general, I think people who really believe that you design everything before you implement it

大多都是一些没有设计过大规模系统的人
basically are people who haven't designed very many things.

The real power is that you can pretend that you've made the decision

and then later on figure out which one is right,

which decision you ought to have made.

And when you can do that, you have the best of both worlds.

学生：您能解释一下let和define的区别吗？
AUDIENCE: Can you explain the difference between let and define?

教授：好的 
PROFESSOR: Oh, OK. 

let是用来建立一个局部的名字
Let is a way to establish local names.

嗯 我就先大概给你说下
So there... Let me give you sort of the half answer.

然后我们再来讨论这整个复杂的过程
And I'll say, later on we can talk about the whole very complicated thing.

就现在来说 区别就在于 当你在Lisp中编程时
But the big difference for now is that, see, when you're typing at Lisp,


you're typing in this environment where you're making definitions.

当你想把A定义为5时 我写(DEFINE A 5)
And when you say define a to be 5, if I say define a to be 5,

从此以后我们就会记得a就是5
then from then on the thing will remember that a is 5.

let会建立一个包含一个定义的局部上下文
Let is a way to set up a local context where there's a definition.

所以当我键入 比如(LET ((A
So if I type something like, saying let a--

或者我写(LET ((Z 10)))
no, I shouldn't say a-- if I said let z be 10,

然后在这个上下文中 我们计算Z加上Z的和
and within that context, tell me what the sum of z and z is.

如果我在Lisp中这样写的话
So if I typed in this expression to Lisp,

Lisp会输出20
and then this would put out 20.

然而 如果我再问Z是什么
However, then if I said what's z,

计算机会告诉我Z是一个未绑定的变量
the computer would say that's an unbound variable.

因此let可以创建一个上下文 你可以在这个上下文中进行定义
So let is a way of setting up a context where you can make definitions.

但是这些都是这个上下文中的局部定义
But those definitions are local to this context.

当然啦 我把这个改为A的话 我依旧会得到20
And of course, if I'd said a in here, I'd still get 20.

但是这个A与这个A一点也不冲突
But this a would not interfere at all with this one.

所以我键入这个 再键入这个 再问A是什么
So if I type this, and then type this, and then say what's a?

A还会是5
a will still be 5.

因此在let和define之间有这另一种代换模型
So there's some other subtle differences between let and define,

这也是最重要的
but that's the most important one.


[音乐]
[JESU, JOY OF MAN'S DESIRING]

好了 我们已经看过作为数据抽象技术的示例
All right, well, we've looked at implementing this little system

在有理数域上做算术的小型系统的实现
for doing arithmetic on rational numbers as an example of this methodology of data abstraction.

这就是一种在大型系统中控制复杂度的方法
And that's a way of controlling complexity in large systems.

就像定义过程
But, see, like procedure definition,

以及我们谈论的所有的控制复杂度的方法
and like all the ways we're going to talk about for controlling complexity,


the real power of these things show up not when you sort of do these things in themselves,

我们构建的有理数运算系统并不是什么了不起的事
like it's not such a great thing that we've done rational number arithmetic,

而是你可以将这些东西用于构建更复杂的东西
it's that you can use these as building blocks for making more complicated things.


So it's no wonderful idea that you can just put two numbers together to form a pair.


If that's all you ever wanted to do,

there are tons of ways that you can do that.

The real issue is can you do that in such a way

so that the things that you build

become building blocks for doing something even more complex?

因此无论何时有人向你展示控制复杂度的方法
So whenever someone shows you a method for controlling complexity,

你都应该说 嗯 这很不错 但我可以用它来构建什么呢？
you should say, yeah, that's great, but what can I build with it?

举个例子吧
So for example,

我举一个很像刚才那个有理数系统的例子
let me just run through another thing that's a lot like the rational number one.

假设我们想要在平面中表示一个点
Suppose we would like to represent points in the plane.

好吧 这里有一个点
You sort of say, well, there's a point,

我们把它叫做点P
and we're going to call that point p.

这个点可能会有一个坐标
And that point might have coordinates, 

比如点P就是(1,2)
like this might be the point 1 comma 2.

X坐标为1 Y坐标为2
The x-coordinate might be 1, and it's y-coordinate might be 2.

我们将要构建一个用于在平面中处理这些点的小型系统
And we'll make a little system for manipulating points in the plane.

我们当然可以 可以像这样
And again, we can do that-- here's a little example of that.

用向量来表示 就和点在平面中的表示是一样的
It can represent vectors, the same as points in the plane,

我们也会说 嗯
and we'll say, yep,

这里有一个叫做MAKE-VERCTOR的构造函数
there's a constructor called make-vector,

函数MAKE-VERCTOR需要两个坐标
make-vector's going to take two coordinates,

当然 如果我们愿意的话可以将其实现为序对
and here we can implement them if we like as pairs,

但是最重点的是我们有一个构造函数
but the important thing is that there's a constructor.

当我们传递了向量P后
And then given some vector, p,

我们可以得到它的X坐标
we can find its x-coordinate,

我们也可以得到它的Y坐标
or we can get its y-coordinate.

所以这里就有了点在平面系统中的构造函数和选择函数
So there's a constructor and selectors for points in the plane.

那么 我们有了平面中的点 就希望将它们用来构建事物
Well, given points in the plane, we might want to use them to build something.

比如说 我们想要
So for instance, we might want to talk about,

我们有一个点P 一个点Q
we might have a point, p, and a point, q,

点P为(1,2) 点Q为(2,3)
and p might be the point 1, 2, and q might be the point 2, 3.

我们想要得到从P开始 到Q截止的线段
And we might want to talk about the line segment that starts at p and ends at q.

我们把它叫做线段S
And that might be the segment s.

我们想用数字来表示点 并用点来构造向量
So we might want to build points for vectors in terms of numbers,

用向量来表示线段
and segments in terms of vectors.

因此我们也可以对线段如法炮制
So we can represent line segments in exactly the same way.

因此 对于从P到Q的线段
All right, so the line segment from p to q,

我们这里有一个构造函数MAKE-SEGMENT
we'll say there's a constructor, make-segment.

然后是为选择函数取名
And make up names for the selectors,

取得线段起始点的函数 和取得截止点的函数
the starting point of the segment and the ending point of the segment.

当然了 我们可以将线段实现为两个点构造成的序对
And again, we can implement a segment using cons as a pair of
points,

CAR和CDR可以分别取得构成线段的两个点
and car and cdr get out the two points that we put together to get the segment.

好了 我们已经完成这个系统了
Well, now having done that,

我们可以进行一些此操作
we can have some operations on them. 

比如说 某个线段的中点是什么？
Like we could say, what's the midpoint of a line segment?

这就是某个线段的中点
So here's the midpoint of a line segment,

该点的X、Y坐标分别为起始点和截止点X、Y坐标和的一半
that's going to be the points whose coordinates are the averages of the coordinates of the endpoints.

嗯 这就是中点
OK, there's the midpoint.

因此 为了得到线段S的中点
So to get the midpoint of a line segment, s,

我们先要取得该线段的起始点
we'll just say grab the starting point to the segment,

取得该线段的截止点
grab the ending point of the segment,

然后构建一个向量 也就是一个点 
and now make a vector--make a point

该点的X坐标为起、止点X坐标和的一半
whose coordinates are the average of the x-coordinate of the first point and the x-coordinate of the second point,

Y坐标为起、止点Y坐标和的一半
and whose y-coordinate is the average of the y-coordinates.

这就是函数MIDPOINT一种实现
So there's an implementation of midpoint.

类似的 我们可以编写类似于求取线段长度的函数
And then similarly, we can build something like the length of the segment.

线段的长度 可以根据勾股定理算得
The length of the segment is a thing whose-- use Pythagoras's rule,

线段的长度是dX的平方加dY的平方的和的平方根
the length of the segment is the square root of the d x squared plus d y squared.

当我们说计算某线段S的长度时
We'll say to get the length of a line segment,

我们令dX为起、止点X坐标之差
we'll let dx be the difference of the x-coordinate of one endpoint and the x-coordinate of the other endpoint,

令dY为起、止点Y坐标之差
and we'll let dy be the difference of the y-coordinates.

然后我们求取dX、dY平方和的平方根
And then we'll take the square root of the sum of the squares of dx and dy,

就是这样了
that's what this says.

好了 这就是函数LENGTH的一种实现
All right, so there's an implementation of length.

再次强调 我们构建的是一种层次系统
And again, what we built is a layered system.

我们构建了一个有 呃 现在有线段
We built a system which has, well, say up here there's segments.

这里就有了一道抽象屏障
And then there's an abstraction barrier.

这道抽象屏障把
The abstraction barrier separates the implementation 

线段同向量、点的实现分离开来
of segments from the implementation of vectors and points,

而这道抽象屏障 就是构造函数和选择函数
and what that abstraction barrier is are the constructors and selectors.

也就是 MAKE-SEGMENT SEMENT-START 和 SEGMENT-END
It's make-segment, and segment-start, and segment-end.

这里是向量
And then there are vectors.

而向量则是建立在序对和数的基础上
And vectors in turn are built on top of pairs and numbers.

所以这里是序对和数
So I'll say pairs and numbers.

这又是它们的抽象屏障
And that has its own abstraction barrier,

也就是 MAKE-VECTOR X-COORDINATE 和 Y-COORDINATE
which is make-vector, and x-coordinate, and y-coordinate.

如此可见 这就是一个层次系统
So we have, again, a layered system.

你可以清楚的看出这些分明的层次
You're starting to see that there are layers here.

我提一下 这里有一个非常重要但是又理所当然的东西
I ought to mention, there is a very important thing that I kind of took for granted.

这点非常自然 但从另外一方面来说又非常重要
And it's sort of so natural, but on the other hand it's a very important thing.

我们为了表示某线段S
Notice that in order to represent this segment s,

我说这个线段就是由点构成的序对
I said this segment is a pair of points.

而一个点又是由数构成的序对
And a point is a pair of numbers.

如果要把这个结构的盒子—指针模型给画出来的话
And if I were going to draw the box and pointers structure for that,

那么我会说 嗯 这个线段是
I would say, oh, the segment is,

用我之前给你们说过的表示法来演示
given those particular representations that I showed you,

线段就是一个序对
I'd say this segment s is a pair,

序对的第一个元素是一个向量
and the first thing in the pair is a vector,

向量是由数构成的序对
and the vector is a pair of numbers.

这就是它 这就是点P
And that's this, that's p.

线段中的另一个东西就是点Q
And the other thing in the segment is q,

它本身就是一个由数构成的序对
which is itself a pair of numbers.

当我说CONS可以让你把东西组合在一起的时候
So I almost took it for granted when I said that

就把它视作理所当然了
cons allows you to put things together.

但有一点也很容易搞不明白 请注意
But it's very easy to not appreciate that, because notice,

我也可以把一些序对给组合在一起
some of the things I can put together can themselves be pairs.

我以后会经常用一个术语来表示
And let me introduce a word that I'll talk about more next time,

一个我最喜欢的术语 这称作“闭包”
it's one of my favorite words, called closure.

这种所谓具有“闭包性质”的组合方法
And by closure I mean that the means of combination in your system

就是哪些当你用它们把东西组合在一起时
are such that when you put things together using them,

这就像我们构建序对的时候
like we make a pair,

你可以继续用同样的方法把组合物继续进行组合
you can then put those together with the same means of combination.

因此我不仅可以有由数构成的序对 也可有由序对构成的序对
So I can have not only a pair of numbers, but I can have a pair of pairs.

比如说 在Fortran中的数组并不具有闭包性质
So for instance, making arrays in a language like Fortran is not a closed means of combination,

因为我可以有元素为数的数组
because I can make an array of numbers,

但不能有元素为数组的数组
but I can't make an array of arrays.


And one of the things that you should ask,

one of your tests of quality for a means of combination that someone shows you,

is gee, are the things you make closed under that means of combination?

如果序对仅仅只能是由数构成的序对的话 就不是那么有趣了
So pairs would not be nearly so interesting if all I could do was
make a pair of numbers.

我并不能用它构建出太多的结构
I couldn't build very much structure at all.

好了 书归正传
OK, well, we'll come back to that.

我现在只是提一下 后面我们还会详细讨论
I just wanted to mention it now. You'll hear a lot about closure later on.

你也可以看到在我们有了层次系统后
You can also see the potential for losing control of complexity 

如果不使用数据抽象 系统复杂度会有失控的隐患
as you have a layered system if you don't use data abstraction. 

让我们回过头来看看LENGTH函数的幻灯片
Let's go back and look at this slide for length.

LENGTH函数简单而有效是因为
Length works and is a simple thing because I can say,

当我使用它时 我确信
when I want to get this value, I can say, oh,

这个是第一个端点的X坐标
that is the x-coordinate of the first endpoint of the segment. 

这些东西 这些选择函数 X-COORDINATE 和 ENDPOINT
And each of these things, each of these selectors, x-coordinate and endpoint,

都代表了一个决策选择 我不用关心它们的内部细节
stand for a decision choice whose details I don't have to look at.

因此就和之前的有理数系统一样 我可以说
So I could perfectly well, again, just like rational numbers I did before,

我可以认为 嗯 线段实际上就是由序对构成的序对
I could say, oh well, gee, a segment really is a pair of pairs.

线段第一个端点的X坐标实际上是什么 是什么呢？
And the x-coordinate of the first endpoint or the segment really is the-- well, what is it?

它的线段的CAR部分的CAR部分
It's the car of the car of the segment.

所以我可以这样完美地重定义LENGTH
So I could perfectly well go and redefine length.

我可以定义某线段S的长度为
I could say, define the length of some segment s.

我这样来写
And I could start off writing something like,

我们令dX为 令dX为什么呢？
well, we'll let dx be-- well, what's it have to be?

为两个坐标之差
It's got to be the difference of the two coordinates,

坐标之一为(CAR (CAR S))
so that's the difference of, the first one is the car of the car of s,

从第一个坐标中减去
subtracted from the first one,

减去另一个点的坐标 也就是(CAR (CDR S))
the car of the other half of it, the cdr of s.

好了 那么dY也就是 我看看
All right, and then dy would be-- well, let's see,

那么函数Y-COORDINATE也就是 (CDR (CAR S))
I'd get the y-coordinate, so it'd be the difference of the cdr of the car of s,

减去(CDR (CDR S)) 诸如此类
and the cdr of the cdr of s, sort of go on.

你可以发现同之前那个程序相比 这个更难度
You can see that's much harder to read than the program I had before.

但比这个还糟的是 假设你这样实现了LENGTH函数
But worse than that, suppose you'd gone and implemented length?

而第二天 George来和你说 抱歉 我改变主意了
And then the next day, George comes to you and says, I'm sorry, I changed my mind.

我想把点的X坐标放在前面
I want to write points with the x-coordinate first.

然后您回过头来看代码 找啊找啊
So you come back you stare at this code and say,

那是什么呢 哦 是CAR
oh gee, what was that? That was the car,

因此我要把这个改为CDR 把这个改为CDR 
so I have to change this to cdr, and this is cdr,

这个要改为CAR 这个也要改为CAR
and this now has to be car. And this has to be car.

你也就这么做了 然后第二天George又跑来说 抱歉 抱歉
And you sort of do that, and then the next day George comes back and says, sorry, 

设计显示的那个家伙想要让线段指向反方向
the guys designing the display would like lines to be painted in the opposite direction,

因此我必须让截止点放到第一位
so I have to write the endpoint first in the order.

然后你又回过头来审视这些代码
And then you come back and you stare at this code,

哦 这又改怎么弄？
and say, gee, what was it talking about?

嗯 把这个改为CDR
Oh yeah, well I've got to change this one to cdr,

这个改为CAR 改为CAR 把这个改为CDR
and this one becomes car, this one comes car, and this becomes cdr.

你又这么做了
And you go up and do that,

第二天 George又跑过来说 太抱歉了
and then the next day, George comes back and says, I'm sorry,

我其实只是想让线段总是在屏幕上从左向右描绘
what I really meant is that the segments always have to be painted from left to right on the screen.

这时候 毫无疑问 你一定会给George一个耳光 #TBD
And then you sort of, it's clear, you just go and punch George in the mouth at that point.

正如你所见 一旦我们有了一个10层的系统
But you see, as soon as we have a 10 layer system,

复杂度也会像这里一样变得失控 #TBD
you see how that complexity immediately builds up to the point where even something like this gets out of control.

因此 为了避免发生这样的事 我们就要为精灵命名
So again, the way we've gotten out of that is we've named that spirit.

我们构建一个系统 这个系统中有一个
We built a system where there is a thing,


which is the representation choice for how you're going to talk about vectors.

And choices about that representation are localized right there. 

They don't have their guts spilling over into things like

how you compute the length and how you compute the midpoint.

And that's the real power of this system.

OK, we're explicit about them, so that we have control over them.


好了 有疑问吗？
All right, questions?

学生：在那些无法使用序对来表示的情况中会如何呢？
AUDIENCE: What happens in the case where you don't want to be treating objects in terms of pairs?

比如说在三维空间里 一个序对无法表示三维坐标
For instance, in three-dimensional space, you'd have three coordinates.

也就是说在n维空间中 我们该如何做呢？ 
Or even in the case where you have n-dimensional space, what happens?

教授：啊 嗯
PROFESSOR: Right, OK.

好吧 你提到了一点明天的内容
Well, this is a preview of what I'll say tomorrow.

但关键点就是 一旦你有了二元的东西 就可以有多元的东西
But the point is, once you have two things, you have as many things as you want.

能理解吗？ 如果我想要组合三个东西
All right? Because if I want to make three things,

我构建一个序对
I could start making things like a pair

该序对第一个元素是1
whose first thing is 1, 

第二个元素则又是一个序对 一个有2和3的序对
and whose second thing is another pair that, say, has 2 and 3 in it.

以此类推 十个百个的东西 我可以把序对嵌套起来
And so on, a hundred things. I can nest them out of pairs.


Here I made a pretty arbitrary decision about how to do it,

and you can immediately see there are lots of ways to do that.

What we'll start talking about next time are conventions for how to do things like that.

只要注意到我可以构建由序对构成的序对就好了
But notice that what this really depends on is I can make pairs of pairs.

因为我只能构建由数构成的序对的话 我就没法了
If all I could do was make pairs of numbers, I'd be stuck.

好吧 休息
OK. Let's break.

[音乐]
[JESU, JOY OF MAN'S DESIRING]

好吧 我们刚才只是做了
All right, well, we've just gone off and done 

一个数据抽象的简单示例
a couple of simple examples of data abstraction.

现在我想做点更复杂的事儿
Now I want to do something more complicated.

稍后我会详细说明这意味着什么
We're going to talk about what it means.

这也将更困难
And this will be harder, 

因为在计算机程序设计中
because it's always much harder in computer programming to 

说明某件事的的意义远比实现它难 #TBD
talk about what something means than to go off and do it.

让我们回到最最开始的地方
But let's go back to almost the very beginning.

还记得当时我说过的话么？
Let's go back to the point where I said,

我说 我们假设已经存在一些过程
we just assumed that there were procedures,

MAKE-RAT、NUMER以及DENOM
make-rat, and numer, and denom.

好吧 我们就回到那里 回到最开始的地方
Let's go back to where we had this, at the very beginning,

有构造函数和选择函数 以及定义有理数算术的地方
constructors and selectors, and when often defined the rational number arithmetic.


And remember, I said at that point we were sort of done, except for George.

那么 在那个时候我们实际上干了什么呢？
Well, what is it that we'd actually done at that point?

做了些什么东西呢？
What was it that was done?

我想说的就是
Well, what I want to say is,


what was done after we'd implemented the operations and terms of these,

我们用抽象数据来定义了有理数的表示
was that we had defined a rational number representation in terms of abstract data.

通过数据抽象我想表达什么？ #TBD
What do I mean by abstract data?

关键点就是
Well, the idea is that

在那个时候 当我们有了+RAT和*RAT
at that point, when we had our +RAT and our *RAT,

任何George提供给我们的MAKE-RAT NUMER和DENOM函数
that any implementation of make-RAT, and numerator, and denominator that George supplied us with,

都可以是有理数的表示基础
could be the basis for a rational number representation.

这是因为
Like, it wasn't our concern

#TBD
where you divided through to get the greatest common denominator, or any of that.

关键点就是 我们构建了一个有理数算术系统
So the idea is that what we built is a rational arithmetic system

一个可以基于任何表示方法的系统
that would sit on top of any representation.

“任何表示方法”又是什么意思呢？
What do I mean by any representation?

是指 当然这不会像
I mean, certainly it can't be the case


that all I mean is George can reach in a bag and pull out three arbitrary procedures


and say,well, fine, now that's the implementation.


That can't be what I mean.

我指的是这里有一种衡量方法
What I've got to mean is that there's some way of saying whether

可以判定这三个过程用于有理数的表示是否合适
three procedures are going to be suitable as a basis for rational number representation.

如果我们仔细思考这个问题
If we think about it,

我应该像这样定义 所谓的“合适”
what suitable might mean is if I have to assume something like this,

我会说 如果X是(MAKR-RAT N D)
I have to say that if x is the result of say, doing make-RAT of n and d,

那么(NUMER X)除以(DENOM X)等同于N除以D
then the numerator of x divided by the denominator of x is equal to n over d.

看到了吗 这就是George定下的合同
See, what that is is that's George's contract.

而我们合同中订好的有理数规则
What we mean by writing a contract for rational numbers,

你仔细想想的话 也是正确的
if you think about it, this is the right thing.


And the two ones we showed do the right thing.

这样的话 就算我要考虑最大公约数
See, if I'm taking out greatest common divisors,

我除不除、在哪里除 都无所谓
it doesn't matter whether I take them out or not, or the place where I take them,

 
because the idea is I'm going to divide through.

嗯 这就是George的合同
But see, this is George's contract.

我们要告诉Georg的就是 提供给我三个过程
So what we really say to George is your business is to go off and find us three procedures,

MAKE-RAT NUMER 和 DENOM
make-RAT, and numerator, and denominator,

使得无论N和D如何选择 都可以满足这个合同
that fulfill this contract for any choice of n and d.

这也就是我所谓的我们可以用来作为有理数表示的基础
And that's what we mean by we can use that as the basis for a rational number representation.

并且只要它们能满足合同
And other than that, it fulfills this contract.

我们不关心他是如何实现的
We don't care how he does it.

这不关我们的事儿 这在抽象层之下
It's not our business. It's below the layer of abstraction.

事实上 如果我们想知道 有理数真正是什么
In fact, if we want to say, what is a rational number really?


See, what's it really, without having to talk about going below the layer of abstraction,


what we're forced into saying is a rational number really

is sort of this axiom,

就是MAKE-RAT NUMER 和 DENOM这三个满足这条公理的过程
is three procedures, make-RAT, numerator, and denominator, that satisfy this axiom.

从某种抽象的意义来说 这就是真正的有理数
In some sense, abstractly, that's what a rational number is really.

这听起来很容易 因为你脑中已经有了
That's sort of easy words to listen to, because what you have in your head, of course, is well,

关于有理数是什么的只是
for all this thing about saying that's what a rational number is really,

因为你已经看到了我们是如何构建有理数的
you actually just saw that we built rational numbers.

对 我们是在序对的基础上构建有理数的
See, what we really did is we built rational numbers on top of pairs.

因此 抽象地来说 我们可以认为有理数实际上就是这些公理
So for all I'm saying abstractly, we can say a rational number really is just this axiom.

你可以很自然把有理数理解为序对 因为这正也是你们见到的
You can listen to that comfortably, because you're saying, well, yeah, but really it's actually pairs,

我把它说得抽象后反而影响你理解
and I'm just annoying you by trying to be abstract.

那么为了让你们 #TBD
Well, let me, as an antidote for that,

我下面展示的东西 一定会吓到你
let me do something that I think is really going to terrify you.

我是说 我会让你们对我们讨论的抽象
I mean, it's really going to bring you face to face

#TBD
with the sort of existential reality of this abstraction that we're talking about.

我们将讨论 序对 到底是什么？
And what I'm going to talk about is, what are pairs really?

说说 我是怎么给你们讲“序对”的？
See, what did I tell you about pairs?

我耍了你们 #TBD
I tricked you, right?

我说 Lisp有一个叫CONS的基本过程可以构建序对
I said that Lisp has this primitive called cons that builds pairs.

但我真正告诉你们什么呢？
But what did I really tell you about?

如果你回过头来看 看这些幻灯片
If you go back and said, let's look on this slide,

会发现我真正告诉你们的是序对应该具有这些属性
all I really told you about pairs is that there happens to be this property,

这些CONS CAR 和 CDR构成的属性
these properties of cons, car, and cdr.

而我说的“序对”
And all I really said about pairs

只是说这里面有叫CONS 叫CAR 和叫CDR的东西 
is that there's a thing called cons, and a thing called car, and a thing called cdr.

在这个例子中 我构建了由X和Y构成的序对 取CAR部分得X
And it is the case that if I build cons of x, y and take car of it, I get x.

构建由X和Y构成的序对 取CDR部分得Y
And if I build cons of x, y and get cdr of it, I get y.

尽管如此 我也对你们谎称Lisp中有个东西能这么做
And even though I lulled you into thinking that there's something in Lisp that does that,

因此你们也就假装确实有这么个东西
so you pretended you knew what it was,

事实上 关于序对 我告诉你们的跟有理数一样多
in fact, I didn't tell you any more about pairs than this tells you about rational numbers.

都是序对的一些公理
It's just some axiom for pairs.

书归正传 我马上要大显身手了
Well, to drive that home, let me really scare you,

我会用某个神秘的东西来构建序对
and show you what we might build pairs in terms of.

你们将会看见 我们可以构建有理数
And what you're going to see is that we can build rational numbers,

直线段、向量以及任何由序对构建起的东西
and line segments, and vectors, and all of this stuff in terms of pairs,

我们在低于抽象层的这里看到 序对可以凭空产生
and we're going to see below here that pairs can be built out of nothing at all.

这是纯粹的抽象
Pure abstraction.

那么就让我在这张幻灯片中为你们展示CONS CAR和CDR的一种实现
So let me show you on this slide an implementation of cons, car, and cdr.

等会儿我们会回来细看
And we'll look at it again in a second,

但一定要注意过程CONS CAR和CDR的定义
but notice that their procedure definitions of cons, car, and cdr,

这里你看不到任何数据 你只能看到一个lambda
you don't see any data in there, what you see is a lambda.

这里的CONS将返回 一个返回值为新的过程的过程
So cons here is going to return-- is a procedure that returns a procedure,

就像函数AVERAGE-ADPT
just like average-adpt.

(CONS A B)返回一个具有单个参数的过程pick
Cons of a and b returns a procedure of an argument called pick, 

它的定义是
and it says,

如果pick等于1 那么该过程返回a
if pick is equal to 1, I'm going to return a,

而如果pick等于2 那么该过程返回b
and if pick is equal to 2, I'm going to return b,

这就是CONS的定义
and that's what cons is going to be.

取X的CAR部分 (CAR X)
Car of a thing x, car of a pair x,

就是把X应用于1
is going to be x applied to 1.

注意了 这完全行得通
And notice that makes sense.

你现在还不太明白我为什么要这样做 但至少这样行得通
You might not understand why or how I'm doing such a thing, but at least it makes sense,

因为我通过CONS构造出了一个过程
because the thing constructed by cons is a procedure,

而CAR将其应用于1
and car applies that to 1.

类似的 CDR将其应用于2
And similarly, cdr applies that thing to 2.

好了 现在我已经给出了CONS CAR和CDR的一种表示法
OK, now I claimed that this is a representation of cons, car, and cdr,

注意这里面没有任何数据
and notice there's no data in it.

这就是“凭空”产生的 它们仅仅是过程
All right, it's built out of air. It's just procedures.

这种表示法中没有任何数据对象
There's no data objects at all in that representation.

那么 这又可能意味着什么呢？
Well, what could that possibly mean?

嗯 如果你承认这些东西的话 #TBD
Well, if you really believe this stuff,

那么接下来 一旦我证明了CONS CAR CDR的这种表示法
then you have to believe that in order to show that that's a representation for cons, car, and cdr,

能满足我们的公理的话 你就对此不容置疑了 #TBD
all I have to do is show that it satisfies the axiom.

那么 我来举一个例子
See, all I should have to convince you of is,

例如 (CAR (CONS 37 49))应该返回37
for example, that gee, that car of cons of 37 and 49 is 37


for arbitrary values of 37 and 49.

CDR也是如此
And cdr the same way.

#TBD
See, if I really can demonstrate to you that that weird procedure definition,


in terms of the air, has the property that it satisfies this,

then you just have to grant me that that is a possible implementation of cons, car, and cdr,

on which I can build everything else.

好了 让我们回过头来看看 这里将用到代换模型
Well, let's look at that. And this will be practice in the substitution model.

我们该怎么来说清这个过程呢？ #TBD
How could we check this?

我们好像知道点怎么做 这都是同一个代换模型
We sort of know how to do that. It's just the same substitution model.

我们来瞧瞧 首先 我们考虑(CAR (CONS 37 49))是什么
Let's look. We start out, and we say, what's car of cons of 37 and 49?

接下来该怎么做？ CONS只是一个过程
What do we do? Cons is some procedure.

它的值也就是一个有A和B的过程
Its value is cons was a procedure of a and b.

CONS返回的是一个过程体
The thing returned by cons is its procedure body

该过程体的参数被37和49代换掉了
with 37 and 49 substituted for the parameters.

用37代换a 用49代换b
It'll be 37 substituted for a and 49 substituted for b.

所以这个表达式和这个表达式的意思是相同的
So this expression has the same meaning as this expression.

CAR没变 而CONS被代换为了一个以LAMBDA开头的表达式
Its car of, and the body of cons was this thing that started with lambda.

这里pick是另外一个变量 如果pick为1的话
And it says, so if pick is equal to 1, where pick is this other argument,

如果pick等于1 那么就返回37 也就是a的值
if pick is equal to 1, it's 37, that's where a was,

如果pick等于2 那么就返回49
and if pick is equal to 2, it's 49.

这是代换的第一步
So that's the first step.

我只是进行了机械地代换
I'm just going through mechanical substitution.

注意了 这也是本课的一大要点
And remember, at this point in the course,

当你搞不清楚情况的时候
if you're confused about what things mean,

就按照代换模型进行机械地代换
go mechanically through the substitution model.

那么 这又会被归约为什么呢？
Well, what is this reduced to?

而CAR则是 把给定的参数 本例中也就是这些 应用于1
Car said, take your, take your argument, which in this case is this, and apply it to 1.

这也就是CAR的定义
That was the definition of car.


So if I look at car, if I do that, the answer is,

这就是那个CAR的参数 将其应用于1
well, it's that argument, this was the argument to car, applied to 1.

这又是什么意思呢？
Well, what does that mean?

[1.08.31]
I take 1, and I substitute it in the body here for this value of pick, which is the nameof the argument, what do I get? Well, I get the thing that says if 1 equals 1 it's 37, and if 1
equals 2 it's 49, so the answer's 37. And similarly, if I'd taken cdr, that would apply it to 2,
and I'd get 49.
So you see, what I've demonstrated is that that completely weird implementation of cons,
car, and cdr, satisfies the axioms. So it's a perfectly valid way of building, in fact, all of the
data objects we're going to see in Lisp. So they all, if you like, can be built on sort of
existential nothing. And as far as you know, that's how it works. You couldn't tell. If all
you're ever going to do with pairs is construct them with cons and look at them with car and
cdr, you couldn't possibly tell how this thing works.
Now, it might give you a sort of warm feeling inside if I say, well, yeah, in fact, for various
reasons there happens to be a primitive called cons, car, and cdr, and if it's too scary, if this
kind of stuff is too scary, you don't have to look inside of it. So that might make you feel
better, but the point is, it really could work this way, and it wouldn't make any difference to
the system at all. So in some sense, we don't need data at all to build these data
abstractions. We can do everything in terms of procedures.
OK, well, why did I terrify you in this way? First, I really want to reinforce this idea of
abstraction, that you really can do these things abstractly. Secondly, I want to introduce an
idea we're going to see more and more of in this course, which is we're going to blur the
line between what's data and what's a procedure.
See, in this funny implementation it turned out that cons of something happened to be
represented in terms of a procedure, even though we think of it as data. While here that's
sort of a mathematical trick, but one of the things we'll see is that a lot of the very
important programming techniques that we're going to get to sort of depend very crucially
on blurring this traditional line between what you consider a procedure and what you
consider data. We're going to see more and more of that, especially next time.
OK, questions?
AUDIENCE: If you asked the system to print a, what would happen?
PROFESSOR: The question is, what would happen if I asked the system to print a. Given
this representation, you already know the answer. The answer is compound procedure a,
just like last time. It'd say compound procedure. It might say a little bit more. It might say
compound procedure lambda or something or other, depending on details of how I named
it. But it's a procedure.
And the only reason for that is I haven't told the system anything special about how to print
such things. Now, it's in fact true that with the actual implementation of cons that to be
built in the system, it would print something else. It would print, say, this is a pair.
AUDIENCE: When you define cons, and then you pass it into values, how does it know
where to look for the cons, because you can use cons over and over again? How does it
know where to look to know which a and b it's supposed to pull back out? I don't know if
I'm expressing that quite right. Where is it stored?
PROFESSOR: OK, the question is, I sort of have a cons with a 37 and a 49, and I might
make another cons with a 1 and a 2, and I might have one called a, and I might have one
called b. And the question is, how does it know? And why don't they get confused? And
that's a very good question. See, you have to really believe that the procedures are objects.
It's sort of like saying-- let's try another simpler example. Suppose I ask for the square root
of 3. So I asked for the square root of 5, and then I ask for the square of 20. You're
probably not the least bit bothered that I can take square root and apply it to 5, and then I
can take square root and apply it to 20. And there's sort of no issue, gee, doesn't it get
confused about whether it's working on 5 or 20? There's no issue about that because you're
thinking of a procedure which goes off and does something.
Now, in some sense you're asking me the same question. But it's really bothering you, and
it's bothering you for a really good reason. Because when I write that, you're saying gee,
this is, I know, sort of a procedure. But it's not a procedure that's just running. It's just sort
of a procedure sitting there. And how can it be that sometimes this procedure has 37 and
49, and there might be another one which has 5 and 6 in there, and why don't they get
confused?
So there's something very, very important that's bothering you. And it's really crucial to
what's going on. We're suddenly saying that procedures are not just the act of doing
something. Procedures are conceptual entities, objects, and if I built cons of 37 and 49,
that's a particular procedure that sits there. And it's different from cons of 3 and 4. That's
another procedure that sits there.

学生：它们都是独立存在的
AUDIENCE: Both of them exist independently.

教授：对 独立存在
PROFESSOR: And exists independently.

学生：可以通过car和cdr被引用
AUDIENCE: And they both can be referenced by car and cdr.

教授：它们都可以通过car和cdr被引用。
PROFESSOR: And they both would be referenced by car and cdr.

我可以增加这个 也可以增加那个
Just like I could increment this, and I could increment that.

它们都是对象 #TBD
They're objects. And that's sort of where we're going.

而你之所以这样问 正是体现了
See, the fact that you're asking the question shows that

#TBD
you're really starting to think about the implications of what's going on.

过程不仅仅只是说做某件事的行为
It's the difference between saying a procedure is just the act of doing something.

任何过程都是一个存在着的真实对象
And a procedure is a real object that has existence.

学生：也就是说过程在构建是
AUDIENCE: So when the procedure gets built,

a和b的确切值就被代换进去了
the actual values are now substituted for a and b--

教授：是的
PROFESSOR: That's right.

学生：那些以lambda形式存在的过程
AUDIENCE: And then that procedure exists as lambda,

而pick实际上已经被传递进去了
and pick is what's actually passed in.

教授：是的 当cons过程被调用时
PROFESSOR: Yes, when cons gets called,

cons就返回了一个新构造好的过程
and the result of cons is a new procedure that's constructed,

而这个新过程有一个叫做pick的参数
that new procedure has an argument that's called pick.

学生：但是就不再有a和b了
AUDIENCE: But it no longer has an a and b.

a和b的确切值在那时就被传递进去了
The a and b are the actual values that are passed through.

教授：根据代换模型 是这样的
PROFESSOR: And it has-- right, according to the substitution model,

现在它不再具有这些可变的名字a和b #TBD
what it now has is not those arbitrary names a and b,

取而代之的则是37和49
it somehow has that 37 and 49 in there.

但你是对的 把这件事想清楚很困难
But you're right, that's a hard thing to think about it,


and it's different from the way you've been thinking about procedures.

学生：如果我再次调用(cons 37 49) 是否得到了一个不同的 #TBD
AUDIENCE: And if I have again cons of 37 and 49, it's a different [UNINTELLIGIBLE]?

教授：如果你再次调用(cons 37 49)
PROFESSOR: And if you make another cons of 37 and 49,

你就陷入了一个深刻的哲学问题
you're into a wonderful philosophical problem,

这个将是我们整个课程中段将讨论的问题
which is going to be what the lecture about halfway through this course is about.

也就是说 我调用(cons 37 49) 然后我再调用一次
Which is, if I cons 37 and 49, and I do it again,

这两者是同一个东西还是不同的东西呢？
is that the same thing, or is it a different thing?

And how could you tell? And when could it possibly matter?

And that's sort of like saying, is that the same thing as this?

Or is this the same thing as that?

It's the same kind of question.

这将是一个非常非常深刻的问题
And that's a very, very deep question.

我没法在一小时内讲清楚 但我们以后会讨论
And I can't answer in less than an hour. But we will.


MIT OpenCourseWare
http://ocw.mit.edu
