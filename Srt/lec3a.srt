1
00:00:00,000 --> 00:00:00,000
它得绘制出一个图像。你给定一个矩形，它就在这个矩形中绘制一些图像
That's got to be picture. It's got to be a thing that you hand it a rectangle, and it draws something in that rectangle.
[MUSIC PLAYING]

2
00:00:00,000 --> 00:00:18,980
[MUSIC PLAYING]

3
00:00:20,940 --> 00:00:23,860
上节课我们讨论了复合数据
PROFESSOR: Well, last time we talked about compound data,

4
00:00:24,700 --> 00:00:29,740
还举了两个例子
and there were two main points to that business.

5
00:00:29,740 --> 00:00:32,480
首先 有一种数据抽象的方法
First of all, there was a methodology of data abstraction,

6
00:00:32,940 --> 00:00:39,100
关键是要将数据的使用
and the point of that was that you could isolate the way that data objects are used

7
00:00:40,060 --> 00:00:41,500
和表示分离开来
from the way that they're represented:

8
00:00:41,550 --> 00:00:45,200
我们可以与George“签订契约”
this idea that there's this guy, George, and you go out make a contract with him;

9
00:00:45,200 --> 00:00:47,480
他负责数据的表示
and it's his business to represent the data objects;

10
00:00:47,480 --> 00:00:49,360
而我们使用它们的时候
and at the moment you are using them,

11
00:00:49,360 --> 00:00:51,360
不需要替George操心如何实现
you don't think about George's problem.

12
00:00:51,980 --> 00:00:58,440
其次 Lisp中有一种特殊的方式把对象连接在一起
And then secondly, there was this particular way that Lisp has of gluing together things

13
00:00:58,940 --> 00:01:00,520
就是构成“序对”
to form objects called pairs,

14
00:01:00,520 --> 00:01:03,540
这是通过CONS CAR CDR实现
and that's done with cons, car and cdr.

15
00:01:03,540 --> 00:01:07,160
CONS CAR CDR 都是独立实现的
And the way that cons, car and cdr are implemented is basically irrelevant.

16
00:01:07,160 --> 00:01:10,020
George的任务就是如何构建这些东西
That's sort of George's problem of how to build those things.

17
00:01:10,020 --> 00:01:11,160
可以将它们实现为基本过程
It could be done as primitives.

18
00:01:11,160 --> 00:01:13,800
也可以利用一些奇怪的过程来实现
It could be done using procedures in some weird way,

19
00:01:13,800 --> 00:01:15,220
但是不用我们操心这些
but we're not going to worry about that.

20
00:01:16,020 --> 00:01:19,660
举个例子 我们来看下有理数算术
And as an example, we looked at rational number arithmetic.

21
00:01:19,660 --> 00:01:21,500
看下向量
We looked at vectors,

22
00:01:21,500 --> 00:01:24,180
我们简单回顾一下向量
and here's just a review of vectors.

23
00:01:24,180 --> 00:01:27,640
这里有个对两个向量求和的运算符
Here's an operation that takes the sum of of two vectors,

24
00:01:27,640 --> 00:01:33,320
我们想要把向量v1和v2相加
so we want to add this vector, v1, and this vector, v2, and we get the sum.

25
00:01:34,460 --> 00:01:40,840
和也是一个向量 它的坐标是两个向量的坐标的和
And the sum is the vector whose coordinates are the sum of the coordinates of the pieces you're adding.

26
00:01:41,280 --> 00:01:45,660
定义(+VECT V1 V2)为
So I can say, to define make-vect, right, to add two vectors

27
00:01:45,660 --> 00:01:51,720
我创建一个向量 其X坐标是两向量X坐标的和
I make a vector, whose x coordinate is the sum of the two x coordinates,

28
00:01:52,100 --> 00:01:54,820
而Y坐标是两向量Y坐标的和
and whose y coordinate is the sum of the two y coordinates.

29
00:01:56,060 --> 00:02:04,100
同样 我们也可以定义一个缩放向量的运算符
And then similarly, we could have an operation that scales vectors,

30
00:02:04,940 --> 00:02:12,660
这里的SCALE过程是用数字S乘以向量V
so here's a procedure scale that multiplies a vector, v, by some number, s.

31
00:02:13,080 --> 00:02:20,240
这个是v v从这里到这里 我放大了v 这个向量跟v方向相同 只是更长了
So here's v, v goes from there to there and I scale v, and I get a vector in the same direction that's longer.

32
00:02:21,560 --> 00:02:24,260
要缩放向量 需要(用s)乘向量坐标
And again, to scale a vector, I multiply the successive coordinates.

33
00:02:24,260 --> 00:02:30,220
所以我创建了一个向量 它的x坐标是原来向量x坐标的缩放倍数(s倍)
So I make a vector, whose x coordinate is the scale factor times the x coordinate

34
00:02:30,560 --> 00:02:33,540
同时 它的y坐标是原来向量y坐标的缩放倍数(s倍)
and whose y coordinate is the scale factor times the y coordinate.

35
00:02:33,540 --> 00:02:40,280
所以这里实现了两个操作符用来表示(代表)向量
So those are two operations that are implemented using the representation of vectors.

36
00:02:40,280 --> 00:02:45,020
这种向量的表示方法，我们可以依据pairs来实现。
And the representation of vectors, for instance, is something that we can build
in terms of pairs.

37
00:02:45,340 --> 00:02:51,280
所以George实现了make-vector x坐标 y坐标 为我们使用#TBD may be these all funtion name
So George has gone out and implemented for us make-vector and x coordinate and y coordinate,

38
00:02:53,020 --> 00:02:57,980
他可以使用cons car cdr来实现(这三个函数)
and this could be done, for instance, using cons,car and cdr;

39
00:02:58,880 --> 00:03:06,780
但是注意 我这里写了一个完全不同的方式
and notice here, I wrote this in a slightly different way.

40
00:03:08,040 --> 00:03:16,220
这个过程我们之前看过(make-vector x y (cons x y))   #TBD maybe right
The procedures we've seen before, I've said something like say, make-vector of x and y: cons of x and y.

41
00:03:16,220 --> 00:03:17,980
这里我只写了make-vector cons
And here I just wrote make-vector cons.

42
00:03:17,980 --> 00:03:20,480
这表示他们完全不同
And that means something slightly different.

43
00:03:20,480 --> 00:03:26,220
之前我们说 定义make-vector过程用两个参数x y
Previously we'd say, define make-vector to be a procedure that takes two arguments, x and y,

44
00:03:26,220 --> 00:03:28,040
并且用cons把x y连接在一起
and does cons of x and y.

45
00:03:28,040 --> 00:03:34,120
这里需要说的是 用cons来定义make-vector是因为
And here I am saying define make-vector to be the thing that cons is,

46
00:03:35,180 --> 00:03:39,660
这跟其他我们写的代码的方式差不多
and that's almost the same as the other way we've been writing things.

47
00:03:39,660 --> 00:03:46,580
大家需要习惯过程也是对象 并且它可以命名(来使用)这种思想
And I just want you to get used to the idea that procedures can be objects, and
that you can name them.

48
00:03:48,700 --> 00:03:51,800
这代表一个向量
OK, well there's vector representation, and again,

49
00:03:51,800 --> 00:03:55,680
但如果我要说的就仅仅是这些 那就太无聊了
if that was all there was to it,this would all be pretty boring.

50
00:03:57,020 --> 00:04:02,160
重点是 要记住 大家可以用cons连接不仅仅是pair中的数字
And the point is, remember, that you can use cons to glue together not just numbers to form pairs,

51
00:04:02,160 --> 00:04:04,160
它可以连接任何东西
but to glue together arbitrary things.

52
00:04:05,200 --> 00:04:11,600
例如 如果我想表示一个线段
So for instance, if we'd like to represent a line segment,

53
00:04:11,600 --> 00:04:16,060
可以说 线段来自一个特定的向量
say the line segment that goes from a certain vector: say,

54
00:04:16,060 --> 00:04:28,300
这个线段从向量(2,3)的端点开始到向量(5,1)的端点
the segment from the vector 2,3 to the point represented by the vector 5,1.

55
00:04:28,300 --> 00:04:31,820
如果我们想表示这条线段
If we want to represent that line segment,

56
00:04:33,260 --> 00:04:36,200
那么我们可以构建一个pair的pair
then we can build that as a pair of pairs.

57
00:04:40,720 --> 00:04:42,940
这样我们就可以表示一个线段了
So again, we can represent line segments.

58
00:04:42,940 --> 00:04:47,340
我们可以做一个构造器 使用cons构造线段
We can make a constructor that makes a segment using cons,

59
00:04:47,340 --> 00:04:51,600
选择线段的起始点 选择线段的终止点
selects out the start of a segment, selects out the end point of the segment;

60
00:04:55,000 --> 00:05:02,100
实际上 如果撇开抽象层不管 我们可以说 这个(线段)就是pair的pair
and then if we actually look at that, if we peel away the abstraction layers, and say  what's that really is a pair of pairs,

61
00:05:04,660 --> 00:05:06,220
我们还称它是一个pair
we'd say well that's a pair.

62
00:05:06,220 --> 00:05:08,220
这就是一个线段
Here's the segment.

63
00:05:10,000 --> 00:05:16,720
这个线段的car是一个pair 它的cdr也是一个pair
It's car, right, it's car pointer is a pair, and it's cdr is also a pair,

64
00:05:18,320 --> 00:05:25,540
它的car是一个pair--(2,3)
and then what the car is--here's the car, that itself is a pair of 2 and 3.

65
00:05:25,900 --> 00:05:27,920
cdr是pair(2，3)
And similarly the cdr is a pair of 2 and 3.

66
00:05:27,920 --> 00:05:36,980
我再次提醒大家一次 好多人认为如果我画的这个箭头是向下的，有其它的含意
And let me remind you again, that a lot of people have some idea that if I'd taken this arrow and somehow written it to point down, that would mean something else.

67
00:05:36,980 --> 00:05:38,280
这个是不对的(箭头的指向毫无关系)
That's irrelevant.

68
00:05:38,280 --> 00:05:43,900
这个仅仅是这些(对象)是如何连接的，与箭头的水平还是竖直没有关系。
It's only how these are connected and not whether this arrow happens to go vertically or horizontally.

69
00:05:47,480 --> 00:05:52,180
还要提醒一下，这个(pair)概念是闭包。(数学概念)
And again just to remind you, there was this notion of closure.

70
00:05:52,940 --> 00:06:05,620
看，闭包可以让我们构建更复杂的事情,不必陷入pair细节
See, closure was the thing that allowed us to start building up complexity, that didn't trap us in pairs.

71
00:06:06,640 --> 00:06:15,240
特别的，我说的事情就是我们正在做的---使用cons构造一个pair
Particularly what I mean is the things that we make, having combined things using cons to get a pair,

72
00:06:16,440 --> 00:06:22,640
pair中的元素，也可以用cons来构造。这样可以构造出更加复杂的东西。
those things themselves can be combined using cons to make
more complicated things.

73
00:06:23,280 --> 00:06:31,980
数学家可能会说，在lisp中的数据集合在pair构造的操作中是封闭的.
Or as a mathematician might say, the set of data objects in Lisp is closed under the operation of forming pairs.

74
00:06:33,820 --> 00:06:36,340
这就允许我们做更加复杂的构造
That's the thing that allows us to build complexity.

75
00:06:36,340 --> 00:06:42,460
这个很显然，但是要记住，很多人们使用的计算机语言不是封闭的
And that seems obvious, but remember, a lot of the things in the computer languages that people use are not closed.

76
00:06:42,460 --> 00:06:52,180
举例来说，数组很基本，但是在Fortran中就不是封闭的操作，大家可以创建数字，字符串或者别的什么数组
So for example, forming arrays in basic and Fortran is not a closed operation, because you can make an array of numbers or character strings or something,

77
00:06:52,180 --> 00:06:54,180
但是大家不能创建数组的数组
but you can't make  an array of arrays.

78
00:06:54,640 --> 00:07:02,780
在对待组合的意义时 大家应该问自己在这种组合下是否是封闭的
And when you look at means of combination, you should be should be asking yourself whether things are closed under that means of combination.

79
00:07:05,060 --> 00:07:12,920
在任何情况下 因为我们可以构造pair的pair 我们可以使用各种各样的方式把对象连接起来
Well in any case, because we can form pairs of pairs, we can start using pairs to glue things together in all sorts of different ways.

80
00:07:14,020 --> 00:07:18,260
比如我要连接四个数 -- 1，2，3，4
So for instance if I'd like to glue together the four things, 1, 2, 3 and 4,

81
00:07:18,260 --> 00:07:19,820
我有很多方式可以做
there are a lot of ways I can do it.

82
00:07:20,660 --> 00:07:36,880
比如，像我们做的线段 我可以构造一个pair 它是((1 2) (3 4)) 对吧
I could, for example, like we did with that line segment, I could make a pair that had a 1 and a 2 and a 3 and a 4, right?

83
00:07:36,880 --> 00:07:40,060
如果我喜欢 我可以像这样做
Or if I liked, I could do something like this.

84
00:07:40,060 --> 00:07:55,080
我可以构造一个pair 它的第一个元素是pair 这个pair的car是1 它的cdr是一个pair (2 3) 我把4放在这里
I could make a pair, whose first thing is a pair, whose car is 1, and his cdr is itself a pair that has the 2 and the 3, and then I could put the 4 up here.

85
00:07:56,920 --> 00:08:02,160
大家看 把对象连接起来的方式有很多种
So you see, there are a lot of different ways that I can start using pairs to glue things together,

86
00:08:02,160 --> 00:08:07,740
所以有必要建立一些方便(的方式)
and so it'll be a good idea to establish some kind of conventions,right,

87
00:08:07,740 --> 00:08:11,580
这样我们就可以用一些便捷的方式处理数据
that allow us to deal with this thing in some conventional way,

88
00:08:11,580 --> 00:08:14,000
这样我们就不用总是做一些选择
so we're not constantly making an ad hoc choice.

89
00:08:15,860 --> 00:08:25,820
列表非常方便的表示一个序列 如pair链
And List has a particular convention for representing a sequence of things as, essentially, a chain of pairs,

90
00:08:26,780 --> 00:08:28,180
这个就叫做列表
and that's called a List.

91
00:08:34,720 --> 00:08:40,500
列表的本质其实就是代表序列的便捷方式
And what a List is is essentially just a convention for representing a sequence.

92
00:08:40,700 --> 00:08:47,380
我可以使用pair的序列来表示序列 1,2,3,4
I would represent the sequence 1, 2, 3 and 4 by a sequence of pairs.

93
00:08:48,260 --> 00:09:01,520
我把1放在这里 它的cdr指向另一个pair 这个pair的car是序列的下一个数(这里说的是2)
I'd put 1 here and then the cdr of this would point to another pair whose car was the next thing in the sequence,

94
00:09:01,520 --> 00:09:07,260
并且它的cdr指向了另一个pair 它的car是序列的再下一个数
and the cdr would point to another pair whose car was the next thing in the sequence--

95
00:09:07,260 --> 00:09:08,440
这个是数是3
so there's 3--

96
00:09:08,440 --> 00:09:09,740
以此类推
and then another one.

97
00:09:09,740 --> 00:09:13,220
所以 对于序列中的每一个元素 都是一个pair
So for each item in the sequence, I'll get a pair.

98
00:09:15,540 --> 00:09:22,560
现在这个序列中没有更多元素了 我用一个特殊的标记表示列表中没有元素了
And now there are no more, so I put a special marker that means there's nothing more in the List.

99
00:09:24,140 --> 00:09:34,640
好 所以这是一种非常方便的方式将序列中的元素连接在一起
OK, so that's a conventional way to glue things together if you want to represent a sequence, right.

100
00:09:34,640 --> 00:09:44,840
它其实就是一大堆pair 每个pair中的car就是大家想要连接到一起的元素
And what it is is a bunch of pairs, the successive cars of each pair are the items that you want to glue together,

101
00:09:46,000 --> 00:09:48,460
cdr指向的是下一个pair指针
and the cdr pointer points to the next pair.

102
00:09:50,020 --> 00:09:56,040
现在如果我真的想要构造它 我需要向Lisp中输入：
Now if I actually wanted to construct that, what I would type into Lisp is this:

103
00:09:56,040 --> 00:09:58,720
就像是我说的那样构造
I'd actually construct that as saying,

104
00:09:58,720 --> 00:10:15,280
(cons 1 (cons 2 (cons 3 (cons 4 nil))))
well this thing is the cons of 1 onto the cons of 2 onto the cons of 3 onto
the cons of 4 onto, well, this thing nil.

105
00:10:15,280 --> 00:10:20,000
nil是列表结束的标记符号
And what nil is is a name for the end of List marker.

106
00:10:20,800 --> 00:10:23,820
它是一个特殊的名字 意味着列表结束了
It's a special name, which means this is the end of the List.

107
00:10:26,240 --> 00:10:30,260
这就是我如何构造列表
OK, so that's how I would actually construct that.

108
00:10:37,340 --> 00:10:45,180
当然 构造列表的时候总是写cons非常费力
Of course, it's a terrible drag to constantly have to write something like the cons of 1 onto the cons of 2 onto the cons of 3, whenever you want to make this thing.

109
00:10:45,180 --> 00:10:57,720
所以列表有一个操作叫做list list其实是这种cons递归结构的缩写
So List has an operation that's called List, and List is just an abbreviation for this nest of conses.

110
00:10:57,720 --> 00:11:06,320
所以我可以说 我构造列表(list 1 2 3 4)
So I could say, I could construct that by saying that is the List of 1, 2, 3 and 4.

111
00:11:07,780 --> 00:11:14,760
所有的这些是一个语法糖 它是一串cons序列的缩写
And all this is is another way, a piece of syntactic sugar, a more convenient way for writing that chain of conses--

112
00:11:14,760 --> 00:11:17,840
(这个序列是)cons的cons的cons的cons
cons of cons of cons of cons of cons of cons onto nil.

113
00:11:18,480 --> 00:11:39,780
举例来说 我将定义列表(1 2 3 4)叫做1-TO-4
So for example, I could build this thing and say, I'll define 1-TO-4 to be the
List of 1, 2, 3 and 4.

114
00:11:47,960 --> 00:11:53,020
注意使用这种便捷写法的后果
OK, well notice some of the consequences of using this convention.

115
00:11:53,600 --> 00:12:00,260
首先 如果我有这个列表(1 2 3 4) 那么 列表的car就是这个列表的第一个元素
First of all if I have this List, this 1, 2, 3 and 4, the car of the whole thing is the first element in the List, right.

116
00:12:01,900 --> 00:12:05,280
那么，我们如何获得元素2呢？
How do I get 2?

117
00:12:05,280 --> 00:12:23,100
2应该是1-TO-4的cdr的car
Well, 2 would be the car of the cdr of this thing 1-TO-4, it would be 2, right.

118
00:12:23,460 --> 00:12:29,480
它的cdr是这个
I take this thing, I take the cdr of it, which is this much,

119
00:12:29,820 --> 00:12:31,680
而它的car是2.
and the car of that is 2,

120
00:12:32,580 --> 00:12:47,420
同理 1-TO-4的cdr的cdr的car
and then similarly, the car of the cdr of the cdr of 1-TO-4, cdr, cdr, car--

121
00:12:47,420 --> 00:12:51,360
是3 以此类推
would give me 3, and so on.

122
00:12:52,680 --> 00:12:55,840
我们看一下电脑屏幕
Let's take a look at that on the computer screen for a second.

123
00:12:57,500 --> 00:13:11,180
我定义一个列表(1 2 3 4)叫它1-TO-4
I could come up to List, and I could type define 1-TO-4 to be the List of 1, 2, 3 and 4, right.

124
00:13:13,780 --> 00:13:21,280
我这样写 计算机返回定义完成 这个就是1-TO-4的定义
And I'll tell that to List, and it says, fine, that's the definition of 1-TO-4.

125
00:13:22,300 --> 00:13:36,740
我问 比如 1-TO-4的cdr的cdr的car
And I could say, for instance, what's the car of the cdr of the cdr of 1-TO-4, close paren, close paren.

126
00:13:38,340 --> 00:13:42,420
嗯 它是3
Right, so the car of the cdr of the cdr would be 3.

127
00:13:44,080 --> 00:13:50,080
或者我问 1-TO-4是什么
Right, or I could say, what's 1-TO-4 itself.

128
00:13:51,260 --> 00:13:57,220
大家可以看到列表输出的是(1 2 3 4) (结果)用括号包围着
And you see what List typed out is 1, 2, 3, 4, enclosed in parentheses,

129
00:13:57,220 --> 00:14:02,120
这是一个标记 用括号将列表中的元素包围起来
and this notation, typing the elements of the List enclosed in parentheses

130
00:14:02,120 --> 00:14:08,900
是打印用pair构造出来的序列的一种传统方式
is List's conventional way for printing back this chain of pairs that represents a sequence.

131
00:14:08,900 --> 00:14:17,140
又比如 我问1-TO-4的cdr是什么
So for example, if I said, what's the cdr of 1-TO-4,

132
00:14:19,300 --> 00:14:21,120
那是列表的剩余元素(除去1之外)
that's going to be the rest of the List.

133
00:14:21,320 --> 00:14:26,960
它是列表的第一个pair指向的子序列 这个序列开始于2
That's the thing pointed to by the first pair, which is, again, a sequence  that starts off with 2.

134
00:14:28,520 --> 00:14:44,820
比如 1-TO-4的cdr的cdr是什么 返回(3 4)
Or for example, I go off and say, what's the cdr of the cdr of 1-TO-4; then that's 3,4.

135
00:14:44,820 --> 00:14:59,660
或者 1-TO-4的cdr的cdr的cdr的cdr是什么
Or if I say, what's the cdr of the cdr of the cdr of the cdr of 1-TO-4,

136
00:15:04,740 --> 00:15:10,460
我们看一下列表的尾指针 列表打印结果是()
and I'm down there looking at the end of List pointer itself, and List prints that as just open paren, close paren.

137
00:15:10,680 --> 00:15:13,760
大家可以看到列表中什么东西都没有
You can think of that as a List with nothing in there.

138
00:15:13,760 --> 00:15:25,200
1-TO-4的cdr的cdr的cdr的末尾(的打印结果) 是列表的尾指针它本身
All right, see at the end what I did there was I looked at the cdr of the cdr of the cdr of 1-TO-4, and I'm just left with the end of List pointer itself.

139
00:15:25,200 --> 00:15:27,200
它的输出是()
And that gets printed as open close.

140
00:15:34,140 --> 00:15:43,440
大家看到的用序列的cdr来操作列表是非常常见的方式
All right, well that's a conventional way you can see for working down a List by taking successive cdrs of things.

141
00:15:43,440 --> 00:15:45,440
这个叫做列表的cdring
It's called cdring down a List.

142
00:15:46,640 --> 00:15:49,780
当然手写这些cdr非常费劲
And of course it's pretty much of a drag to type all those cdrs by hand.

143
00:15:49,780 --> 00:15:52,240
大家没有必要这么做
You don't do that. 可以写一个过程来做这些。
You write procedures that do that.

144
00:15:52,960 --> 00:15:59,100
事实上 Lisp中非常普遍的事情是写一些过程
And in fact one very, very common thing to do in Lisp is to write procedures that, sort of,

145
00:15:59,100 --> 00:16:06,540
过程使用列表 对列表的每一个元素进行一些操作 并返回结果列表
take a List of things and do something to every element in List, and return you a List of the results.

146
00:16:07,280 --> 00:16:11,920
比如 我写一个过程叫做scale-list
So what I mean for example, is I might write a procedure called Scale-List,

147
00:16:16,800 --> 00:16:35,320
我要用scale-list将列表1-TO-4放大10倍 那么它应该返回列表(10 20 30 40)
and Scale-List I might say I want to scale by 10 the entire List 1-TO-4, and that would return for me the List 10, 20, 30, 40.

148
00:16:35,320 --> 00:16:37,660
不详
[UNINTELLIGIBLE PHRASE]

149
00:16:38,200 --> 00:16:49,300
没错 它返回一个列表 大家可以看到这里可以使用了一些递归策略来做处理
Right, it returns List, and well you can see that there's going to be some kind
of recursive strategy for doing it.

150
00:16:49,300 --> 00:16:51,300
我应该如何写这个过程呢？
How would I actually write that procedure?

151
00:16:52,520 --> 00:16:59,800
这个想法是:如果要构建一个每个元素都乘以10的列表
The idea would be, well if you'd like to build up a List where you've multiplied every element by 10,

152
00:17:00,440 --> 00:17:08,420
需要做的是--假设已经得到了结果列表的剩余元素--也就是列表的cdr
what you'd say is well you imagine that you'd taken the rest of the List--
right, the thing represented by the cdr of the List,

153
00:17:08,420 --> 00:17:14,160
这个子列表中的每个元素都是原来的元素乘以10
and suppose I'd already built a List where each of these was multiplied by 10--

154
00:17:16,060 --> 00:17:19,680
这是scale-list对列表cdr作用的结果
that would be Scale-List of the cdr of the List.

155
00:17:20,120 --> 00:17:27,300
我需要做的事情就只有用列表的car乘以10 然后用cons将它和剩余部分连接起来 返回这个列表。
And then all I have to do is multiply the car of the List by 10, and then cons that onto the rest, and I'll get a List.

156
00:17:28,780 --> 00:17:36,420
以此递归 缩放列表的cdr 我将缩放它(列表的cdr)的cdr 并且用2*10跟它连接起来
Right and then similarly, to have scaled the cdr of the List, I'll scale the cdr of that and cons onto that 2 multiplied by 10.

157
00:17:36,420 --> 00:17:41,160
最终 当我处理到列表的结尾的时候 我有列表的尾指针
And finally when I get all the way down to the end, and I only have this end
of List pointer.

158
00:17:41,720 --> 00:17:45,280
对，它叫做nil 我就直接返回列表尾指针
All right, this thing whose name is nil-- well I just returned an end of
List pointer.

159
00:17:45,540 --> 00:17:47,680
所以这就是这个过程的递归策略
So there's a recursive strategy for doing that.

160
00:17:47,680 --> 00:17:50,520
这个过程就是这样
Here's the actual procedure that does that.

161
00:17:50,960 --> 00:17:58,240
这就是使用cdr向下处理列表 用cons反向连接结果的总体策略
Right, this is an example of the general strategy of cdr-ing down a List and
so called cons-ing up the result, right.

162
00:17:58,240 --> 00:18:06,040
然后 对列表l进行缩放因子s的处理应该如何做呢？
So to Scale a List l by some scale factor s, what do I do?

163
00:18:06,040 --> 00:18:10,400
这里有个判断 列表有个判断叫做null
Well there's a test, and List has the predicate called null.

164
00:18:10,400 --> 00:18:17,560
null意思是这是列表的结尾 或者列表中还有元素
Null means is this thing the end of List pointer, or another way to think of that is are there any elements in this List, right.

165
00:18:17,560 --> 00:18:23,000
但是在任何情况下 如果我找列表的尾指针 那么就返回给我列表的尾指针
But in any case if I'm looking at the end of List pointer, then I just return the end of List pointer.

166
00:18:23,000 --> 00:18:35,140
我就是简单的返回nil 其他情况我用cons把列表中的第一个元素个我还需要处理的子列表连接起来 #TBD 这两句话需要重新考虑一下
I just return nil, otherwise I cons together the result of doing what I'm going to do to the first element in the List,

167
00:18:35,540 --> 00:18:46,340
就是说 我取l的car然后用它乘以s 然后我用cons递归连接正在缩放的剩余的列表
namely taking the car of l and multiplying it by s, and I cons that onto recursively scaling the rest of the List.

168
00:18:49,800 --> 00:18:56,480
再说一次 总体的思想是用cdr递归的处理列表的剩余元素
OK, so again, the general idea is that you recursively do something to the rest of the List, to the cdr of the List,

169
00:18:56,480 --> 00:19:01,160
然后用cons把列表的第一个元素的处理结果跟剩余元素连接起来
and then you cons that onto actually doing something to the first element of the List.

170
00:19:01,160 --> 00:19:11,360
当你向后处理到结尾的时候 返回列表的尾指针 这是一个处理列表的基本模式
When you get down to the end here, you return the end of List pointer, and that's a general pattern for doing something to a List.

171
00:19:16,140 --> 00:19:22,620
当然有一个通用的模式可以省去我写这个过程
Well of course you should know by now that the very fact that there's a general pattern there means I shouldn't be writing this procedure at all.

172
00:19:22,620 --> 00:19:24,900
我要做的事情就是写一个过程
What I should do is write a procedure

173
00:19:24,900 --> 00:19:30,420
这是一个通用模式 为列表的每一个元素做一些依据定义所做的事情
that's the general pattern itself that says, do something to everything in the List and define this thing in terms of that.

174
00:19:30,420 --> 00:19:35,180
对，创建了一个高阶过程 这就是我说的那个高阶过程 它叫做map
Right, make some higher order procedure, and here's the higher order procedure that does that.It's called MAP,

175
00:19:36,580 --> 00:19:43,600
map可以处理列表 把列表l传入 并且传入一个过程p
and what MAP does is it takes a List, takes a List l, and it takes a procedure p,

176
00:19:44,640 --> 00:19:51,260
然后它返回一个列表 列表中的每个元素都被过程p所应用(apply)
and it returns the List of the elements gotten by applying p to each successive element in the List.

177
00:19:51,800 --> 00:19:55,640
对(p v1) (p v2) 等等
All right, so p to v1, p to v2, p of en.

178
00:19:55,640 --> 00:20:01,540
我想说的是它把一个列表的每一个元素用p进行了转化
Right, so I think of taking this List and transforming it by applying p to each element.

179
00:20:02,520 --> 00:20:07,080
大家看到的这个过程是一个非常通用的策略 正如我上面提到的
And you see all this procedure is is exactly the general strategy I said.

180
00:20:07,080 --> 00:20:09,080
我们用它写乘以10的过程
Instead of multiply by 10, it's do the procedure.

181
00:20:09,080 --> 00:20:11,860
如果列表是空的 返回nil
If the List is empty,return nil.

182
00:20:11,860 --> 00:20:16,600
否则 对列表的第一个元素应用p
Otherwise, apply p to the first element of the List.

183
00:20:17,040 --> 00:20:25,400
对(p (car l)) 然后连接它和列表中其他将要应用p的子列表--列表的cdr
Right, apply p to car of l, and cons that onto the result of applying p to everything in the cdr of the List,

184
00:20:25,400 --> 00:20:29,060
这个通用的过程叫做map
so that's a general procedure called MAP.

185
00:20:29,060 --> 00:20:39,040
我们可以依据map来定义scale-list
And I could define Scale-List in terms of MAP.

186
00:20:39,040 --> 00:20:41,040
我给大家展示一下
Let me show you that first.

187
00:20:43,460 --> 00:20:52,500
scale-list仅仅是map这个列表和一个过程的的命名
But I could say Scale-List is another way to define it is just MAP along the List by the procedure,

188
00:20:52,500 --> 00:20:55,540
这个过程需要一个参数 返回给定参数乘以s的结果
which takes an item and multiplies it by s.

189
00:20:58,780 --> 00:21:07,400
这就是我缩放列表的真实想法 构建一个递归到这个通用策略中 省去我为每一个过程都要写(一个框架)
Right, so this is really the way I should think about scaling the List, build that actual recursion into the general strategy, not to every particular procedure I write.

190
00:21:07,400 --> 00:21:11,700
当然，这样做的意义之一是 看到了其中的共性
And of course, one of the values of doing this is that you start to see commonality.

191
00:21:12,160 --> 00:21:15,020
大家正在掌握使用通用模式
Right, again you're capturing general patterns of usage.

192
00:21:15,960 --> 00:21:31,180
比如，求列表的平方 我给map传递一个平方过程 列表1-TO-4 然后它返回给我的是(1 4 9 16)
For instance, if I said MAP, the square procedure, down this List 1-TO-4, then I'd end up with 1, 4, 9 and 16.

193
00:21:32,480 --> 00:21:58,560
我说 map这个列表(lambda (x) (+ x 10))如果我对1-TO-4应用这个map 列表的每一个元素都增加了10 那么结果是(11 12  13 14)
Right, or if I said MAP down this List, lambda of x plus x 10, if I MAP that down 1-TO-4, then I'd get the List where everything had 10 added to it: right, so I'd get 11,12, 13, 14.

194
00:22:00,560 --> 00:22:05,760
大家可以看到一个非常非常通用的想法：对列表的每一个元素进行一些处理
And you can see that's going to be a very, very common idea: doing something to every element in the List.

195
00:22:08,660 --> 00:22:12,220
大家需要做的只是构建map的递归模式
One thing you might think about is writing MAP in an iterative style.

196
00:22:12,220 --> 00:22:19,100
我写的恰巧是一个递归的演化版本 但是我们也可以很容易的把它改成迭代过程
The one I wrote happens to evolve a recursive process, but we could just as easily have made one that evolves an iterative process.

197
00:22:19,100 --> 00:22:23,400
有趣的事情是 一旦大家开始用map来思考
But see the interesting thing about it is that once you start thinking in terms of MAP--

198
00:22:24,020 --> 00:22:29,000
比如 一旦说缩放仅仅是一个map 而不在考虑map是迭代还是递归
see, once you say scale is just MAP, you stop thinking about whether it's iterative or recursive,

199
00:22:29,000 --> 00:22:31,820
你可以说 有这样一种策略 给定这个列表
and you just say, well there's this aggregate, there's this List,

200
00:22:32,220 --> 00:22:38,360
要做的事情就是对列表的每一个元素进行转化 它使我不用去考虑特别的控制流程
and what I do is transform every item in the List, and I stop thinking about the particular control structure in order.

201
00:22:38,880 --> 00:22:46,480
这是非常非常重要的想法 我猜这个想法来自APL
That's a very, very important idea, and it, I guess it really comes out of APL.

202
00:22:46,480 --> 00:22:53,920
这个是APL中非常重要的思想：不要去想控制结构 让你关注于策略操作
It's, sort of, the really important idea in APL that you stop thinking about control structures, and you start thinking about operations on aggregates,

203
00:22:54,800 --> 00:23:02,640
在课程一半的时候 我们将讨论叫做流过程的事情 用那个视角看世界是那么的美丽
and then about halfway through this course,we'll see when we talk about something called stream processing, how that view of the world really comes into its glory.

204
00:23:02,640 --> 00:23:05,300
这个是一种很聪明的思想
This is just us a, sort of, cute idea.

205
00:23:05,300 --> 00:23:08,700
我们可以在以后看到更过的应用
But we'll see much more applications of that later on.

206
00:23:09,360 --> 00:23:16,840
还有一些非常有用的过程也非常像map
Well let me mention that there's something that's very similar to MAP that's also a useful idea, and that's--

207
00:23:17,560 --> 00:23:25,620
map可以说是 给我一个列表 map对每一个元素进行应用 然后返回相应的值的一个列表
see, MAP says I take a List, I apply something to each item, and I return a List of the successive values.

208
00:23:25,980 --> 00:23:36,180
我还想做一些其他事情 和这个非常非常相似 它是给定一个列表 一些想要的(操作)行为 然后对序列的每一个元素都进行处理
There's another thing I might do, which is very, very similar, which is take a List and some action you want to do and then do it to each item in the List in sequence.

209
00:23:36,180 --> 00:23:45,100
这不是创建一个新的列表 仅仅是做一些特殊的操作 这个过程非常像map
Don't make a List of the values, just do this particular action, and that's something that's
very much like MAP.

210
00:23:45,100 --> 00:23:54,380
这个称作for-each 它需要一个过程和一个列表 它要做的事情就是对每一个元素应用(传入的过程)
It's called for-each, and for-each takes a procedure and a List, and what it's going to do is do something to every item in the List.

211
00:23:54,380 --> 00:24:11,840
通常它会：如果列表不是空的 我应用这个过程到列表的第一个元素 然后对列表的剩余元素做同样的事情
So basically what it does: it says if the List is not empty, right, if the List is not null, then what I do is, I apply my procedure to the first item in the List, and then I do this thing to the rest of the List.

212
00:24:12,300 --> 00:24:15,340
(for-each (cdr l))
I apply for-each to the cdr of the List.

213
00:24:15,340 --> 00:24:18,820
对，我对列表的第一个元素进行处理 然后对列表的剩余元素进行处理
All right, so I do it to the first of the List, do it to the rest of the List,

214
00:24:19,320 --> 00:24:23,920
当然 当我使用递归时 这讲对列表的剩余列表的剩余列表进行处理 依次类推
and of course, when I call it recursively, that's going to do it to the rest of the rest of the List and so on.

215
00:24:23,920 --> 00:24:32,400
最终 当我结束的时候 我说我做完了 所以我返回“done” 所以这非常像map
And finally, when I get done, I have to just do something to say I'm done, so we'll return the message "done." So that's very, very similar to MAP.

216
00:24:32,800 --> 00:24:35,120
他们之间的差别仅仅是返回值
It's mostly different in what it returns.

217
00:24:35,120 --> 00:24:45,960
举一个例子 如果我有一个过程可以在屏幕上输出对象 如果我想打印列表中的对象 我可以调用for-each打印这个列表
And so for example, if I had some procedure that printed things on the screen, if I wanted to print everything in the List, I could say for-each, print this List.

218
00:24:46,780 --> 00:24:54,860
如果我有一个图形的列表 我想画出他们 我可以用for-each把它们画出来
Or if I had a List of figures, and I wanted to draw them on the display, I could say for-each, display on the screen this figure.

219
00:24:57,920 --> 00:24:59,320
大家提问吧
Let's take questions.

220
00:25:00,620 --> 00:25:07,540
学生：它创建的是一个新对象副本么 如果不明确的告诉它这样做的时候? 是么？
AUDIENCE: Does it create a new copy with something done to it, unless you explicitly tell it to do that? Is that correct?

221
00:25:07,540 --> 00:25:09,180
对
PROFESSOR: Right.

222
00:25:09,180 --> 00:25:10,940
就是这样
Yeah, that's right.

223
00:25:10,940 --> 00:25:15,140
for-each不创建新列表 它只是对列表的每一个元素进行处理
For-each does not create a List. It just sort of does something.

224
00:25:15,140 --> 00:25:24,600
所以如果你有一堆事情想要做 并且你并不关心这个值 比如打印 绘图 或者在终端中响铃等等
So if you have a bunch of things you want to do and you're not worried about values like printing something, or drawing something on the screen, or ringing the bell on the terminal,or for something,

225
00:25:24,600 --> 00:25:32,420
for-each对列表的每一个元素做这件事情 而map其实构建了一个新的集合 这个集合也许是你想要用的
you can say for-each, you know, do this for-each of those things in the List, whereas MAP actually builds you this new collection of values that you might want to use.

226
00:25:32,420 --> 00:25:34,160
这就是他们之间的微妙关系
It's just a subtle difference between them.

227
00:25:34,160 --> 00:25:40,160
学生:你可以用for-each写map么?这样就可以用cons或者别的为这个列表做备份
AUDIENCE: Could you write MAP using for-each, so that you did some sort of cons or something to build the List back up?

228
00:25:40,180 --> 00:25:44,460
老师:某种程度上 我也许可以
PROFESSOR: Well, sort of. I mean, I probably could.

229
00:25:44,460 --> 00:25:49,980
我不知道如何随手写出它 但是我可以给一些思路
I can't think of how to do it right offhand, but yeah, I could arrange something.

230
00:25:50,480 --> 00:26:00,620
学生:map和for-each的关键区别在于一个是递归 而另一个不是 你上一节课定义了它
AUDIENCE: The vital difference between MAP and for-each is one is recursive and the other is not in the sense you defined early yesterday,I believe.

231
00:26:01,240 --> 00:26:03,860
是的 关于map和for-each和递归
PROFESSOR: Yeah, about MAP and for-each and recursion.

232
00:26:03,860 --> 00:26:05,480
这个观点很好
Yeah, that's a good point.

233
00:26:05,480 --> 00:26:13,080
我写的map过程恰巧是一个递归过程
For the MAP procedure I wrote, that happens to be a recursive process.

234
00:26:13,080 --> 00:26:21,460
原因是当你处理完这个事情 你在等着返回的值 你要用列表的开始元素跟它连接在一起
And the reason for that is that when you've done this thing to the rest of the List, you're waiting for that value so that you can stick it on to the beginning of the List,

235
00:26:21,460 --> 00:26:24,840
但是for-each不需要等待返回值
whereas for-each doesn't really have any values to wait for.

236
00:26:24,840 --> 00:26:26,660
所以它变成了一个迭代的过程
So that turns out to be an iterative process.

237
00:26:26,660 --> 00:26:27,720
这个不是基本原则
That's not fundamental.

238
00:26:27,720 --> 00:26:32,080
我已经定义了map所以它可以变成一个迭代过程
I could have defined MAP so that it's evolved by an iterative process.

239
00:26:32,080 --> 00:26:34,080
是我没有那么做
I just didn't happen to.

240
00:26:34,240 --> 00:26:42,900
学生：如果你用cons连接列表生成列表的列表 我想这个应该是可行的
AUDIENCE: If you were to cons for each with a List that had embedded Lists, I imagine it would work, right?

241
00:26:42,900 --> 00:26:48,100
它会返回这些内部列表的内部元素么?
It would give you the internal elements of each of those internal Lists?

242
00:26:48,700 --> 00:26:50,400
老师：问题是如果我[不详]
PROFESSOR: OK, the question is if I [UNINTELLIGIBLE]

243
00:26:50,400 --> 00:27:00,600
对于for-each和map元素是列表的列表 虽然我们还没有讲过这个 但是那是可行的
for-each or MAP, for that matter, with a List that had Lists in it--although we haven't really looked at that yet--would that work.

244
00:27:01,020 --> 00:27:06,560
答案是肯定的 我的意思是这么做是可行的 但跟你想的不同
The answer is yes in the sense I mean work and no in the sense that you mean work,

245
00:27:06,560 --> 00:27:21,460
因为如果我给你一个列表你知道列表中的元素不一定是数字 也许是另一个列表 cons或者是别的什么东西
because all that-- see if I give you a List, where hanging off here is, you know, is something that's not a number, maybe another List or you know, another cons or something,

246
00:27:21,460 --> 00:27:24,540
for-each只是对这个列表中的每一个元素做一些事情(不会考虑元素是否还是列表)
for-each just says do something to each item in this List.

247
00:27:24,540 --> 00:27:26,960
for-each连续的向后找cdr
It goes down successively looking at the cdrs.

248
00:27:26,960 --> 00:27:27,200
学生：嗯
AUDIENCE: OK.

249
00:27:27,200 --> 00:27:31,060
老师：它所关心的是 列表的第一个元素是不是会停在这里。#TBD
PROFESSOR: And as far as it's concerned, the first item in this List is whatever is hanging off here.

250
00:27:31,060 --> 00:27:31,650
学生：唔
AUDIENCE: Mhm.

251
00:27:31,650 --> 00:27:33,940
老师：这也许是对的 也许不是
PROFESSOR: That might or might not be the right thing.

252
00:27:33,940 --> 00:27:35,570
学生：所以不能进入(列表的元素中)
AUDIENCE: So it wouldn't go down into the--

253
00:27:35,570 --> 00:27:36,910
老师：绝对不能
PROFESSOR: Absolutely not.

254
00:27:36,910 --> 00:27:38,510
我可以写一些别的东西
I could certainly write something else.

255
00:27:38,510 --> 00:27:47,940
这里有一个你正在寻找的通用模式 叫做树递归 当你给它一个列表 它进入树的叶子节点
There's another, what you're looking for is a common pattern of usage called tree recursion, where you take a List, and you actually go all the way down to the what's called the leaves of the tree.

256
00:27:47,940 --> 00:27:51,050
你可以写出来这个过程 但是它不是for-each 也不是map
And you could write such a thing, but that's not for-each and it's not MAP.

257
00:27:52,420 --> 00:27:55,050
记住for-each和map都很简单
Remember, these things are really being very simple minded.

258
00:27:55,770 --> 00:27:57,110
好 还有问题么？
OK, no more questions?

259
00:27:57,110 --> 00:27:59,110
好的 大家休息一下吧
All right, let's break.

260
00:27:59,110 --> 00:28:41,940
[MUSIC PLAYING]

261
00:28:41,940 --> 00:28:48,650
老师：我现在要在这节课的剩下时间要做的事情是一个示例
PROFESSOR: What I'd like to do now is spend the rest of this time talking about one example,

262
00:28:48,650 --> 00:28:54,650
这个示例 可以充分的总结我们现在所学的所有东西
and this example, I think, pretty much summarizes everything that we've done up until now:

263
00:28:54,650 --> 00:29:04,600
对 这个是列表结构和抽象议题 还有高阶函数的表示 捕获通用性
all right, and that's List structure and issues of abstraction, and representation and capturing commonality with higher order procedures,

264
00:29:04,600 --> 00:29:13,620
还有介绍我们没有谈论太多的事情--这个是这个课程的第三个主题
and also is going to introduce something we haven't really talked about a lot yet-- what I said is the major third theme in this course:

265
00:29:13,620 --> 00:29:25,800
原语言抽象 它的思想来自为复杂的工程设计构建一个合适的强悍的语言
meta-linguistic abstraction, which is the idea that one of the ways of tackling complexity in engineering design is to build a suitable powerful language.

266
00:29:27,910 --> 00:29:34,740
你可以回想 我要告诉大家的在这个课上非常重要的事情
You might recall what I said was pretty much the very most important thing that we're going to tell you in this course is that

267
00:29:34,740 --> 00:29:41,170
当你思考一个语言 你想它依据什么基本元素
when you think about a language,you think about it in terms of what are the primitives;

268
00:29:41,170 --> 00:29:47,280
意思是(用什么进行)组合----
what are the means of combination--

269
00:29:47,280 --> 00:29:53,220
什么基本元素可以让你构建更大事物
right, what are the things that allow you to build bigger things;

270
00:29:53,220 --> 00:29:55,880
第二 抽象的意义
and then what are the means of abstraction.

271
00:30:00,970 --> 00:30:11,710
如何处理那些大对象？围绕这个对象构建一些黑盒 把这个对象当作参数 然后去做更复杂的事情
How do you take those bigger things that you've built and put black boxes around them and use them as elements in making something even more complicated?

272
00:30:13,250 --> 00:30:23,010
我的朋友Peter Handerson发明了一个特别语言
Now the particular language I'm going to talk about is an example that was made up by a friend of ours called Peter Henderson.

273
00:30:27,850 --> 00:30:31,940
他在苏格兰的斯特灵大学
Peter Henderson is at the University of Stirling in Scotland.

274
00:30:31,940 --> 00:30:41,280
这个语言的是像这样画图用的
And what this language is about is making figures that sort of look like this.

275
00:30:41,280 --> 00:30:46,910
这个是一个Escher做的木板画 叫做"方块极限"
This is this is a woodcut by Escher called "Square Limit."

276
00:30:49,140 --> 00:30:58,450
它很复杂 里面有图像的递归
You, sort of, see it has this complicated, kind of, recursive, sort of,
是一种图像的递归，
recursive kind of figure,

277
00:30:58,450 --> 00:31:05,050
中间的这个鱼的模式不断以更小的图案出现在原来的图案旁边
where there's this fish pattern in the middle and things sort of bleed out smaller and smaller in self similar ways.

278
00:31:08,140 --> 00:31:18,280
总之Peter Hendersion的语言是用来表述这些图形 并且设计新的图形 像这样 并将它画在显示器上
Anyway, Peter Henderson's language was for describing figures that look like that and designing new ones that look like that and drawing them on a display screen.

279
00:31:19,880 --> 00:31:32,020
我们从这个示例中可以看到另外一个主题 这个是我跟Gerry已经多次提到的：
There's another theme that we'll see illustrated by this example, and that's the issue of what Gerry and I have already mentioned a lot:

280
00:31:32,020 --> 00:31:36,650
通常 过程跟数据之间没有真正的区别
that there's no real difference, in some sense, between procedures and data.

281
00:31:36,650 --> 00:31:47,600
我希望今天早晨结束后 我希望大家彻底“混消”(不要区别对待)过程跟数据的差别
And anyway I hope by the end of this morning, if you're not already, you will be completely confused about what the difference between procedures and data are,

282
00:31:47,600 --> 00:31:50,050
如果你还没有"混消"(那么就开始吧)
if you're not confused about that already.

283
00:31:50,050 --> 00:31:55,280
好的 让我们开始表述一下Peter的语言
Well in any case, let's start describing Peter's language.

284
00:31:55,280 --> 00:31:57,970
我将要开始告诉你基本元素是什么
I should start by telling you what the primitives are.

285
00:31:57,970 --> 00:32:01,370
这个语言非常简单 因为它的基本元素就只有一个
This language is very simple because there's only one primitive.

286
00:32:03,050 --> 00:32:06,680
这个基本元素不是大家想象的那样
A primitive is not quite what you think it is.

287
00:32:06,680 --> 00:32:12,110
只有一个基本元素叫做"图像" 但是这个图像不是我们平时认为的图像
There's only one primitive called a picture, and a picture is not quite what you think it is.

288
00:32:12,110 --> 00:32:14,170
举一个例子
Here's an example.

289
00:32:14,170 --> 00:32:15,480
这里有一个George的图像
This is a picture of George.

290
00:32:18,770 --> 00:32:31,850
基本想法是:在这个语言中的图像是绘制通过缩放填充到指定矩行区域的一个图形产生的
The idea is that a picture in this language is going to be something that draws a figure scaled to fit a rectangle that you specify.

291
00:32:32,680 --> 00:32:34,420
所以大家看「不明」
So here you see in [? Saint ?] [? Lawrence's ?]

292
00:32:34,420 --> 00:32:42,620
这个矩形的轮廓 这个不是图像的一部分 但是图像--
outline of a rectangle, that's not really part of the picture, but the picture--

293
00:32:42,620 --> 00:32:47,170
一旦指定一个矩形区域 图像可以绘制这个图形来填充这个矩形区域
you'll give it a rectangle, and it will draw this figure scaled to fit the rectangle.

294
00:32:47,170 --> 00:32:52,770
比如 这个是George 在这里 这个也是George
So for example, there's George, and here, this is also George.

295
00:32:52,770 --> 00:32:56,940
他们是同一个图像 只是经过不同的缩放填充这个矩形而已
It's the same picture, right, just scaled to fit a different rectangle.

296
00:32:56,940 --> 00:32:59,480
这是一个George的“胖”版本
Here's George as a fat kid.

297
00:32:59,480 --> 00:33:03,680
这个也是George
That's the same George.

298
00:33:03,680 --> 00:33:05,140
这是同一个图形
It's all the same figure.

299
00:33:05,140 --> 00:33:08,570
在这个语言中 这三个东西是同一个图像
All of these three things are the same picture in this language.

300
00:33:08,570 --> 00:33:13,250
仅仅是给了不同的矩形让他们来填充
I'm just giving it different rectangles to scale itself in.

301
00:33:16,080 --> 00:33:20,650
这就是这个语言的基本原则
OK, those are the primitives.
就这一个原则。
That is the primitive.

302
00:33:20,650 --> 00:33:25,600
现在我们开始讨论一下元素组合和操作
Now let's start talking about the means of combination and the operations.

303
00:33:25,600 --> 00:33:30,170
比如 这里有一个操作叫做旋转
There is, for example, an operation called Rotate.

304
00:33:30,170 --> 00:33:40,300
旋转要做的是事情是:给一个图像 比如一个图像 这个图像在我给定的矩行中绘制"A"
And what Rotate does is, if I have a picture, say a picture that draws an "A" in some rectangle that I give it,

305
00:33:41,570 --> 00:33:50,650
旋转操作就是--旋转90度 如果我给一个矩形区域 它绘制同样的图案
the Rotate of that--say the Rotate by 90 degrees would, if I give it a rectangle, draw the same image,

306
00:33:50,650 --> 00:33:54,140
但是 对这个图形进行了旋转
but again, scaled to fit that rectangle.

307
00:33:56,110 --> 00:33:58,340
这个就是旋转90度
So that's Rotate by 90 degrees.

308
00:33:58,340 --> 00:34:04,240
这里还有一个操作叫做翻转 水平或者竖直方向进行翻转
There's another operation called Flip that can flip something, either horizontally or vertically.

309
00:34:04,240 --> 00:34:10,400
好 这些就是操作 大家也可以把他们理解为对一个元素进行组合
All right, so those are, sort of, operations, or you can think of those as means of combination of one element.

310
00:34:10,400 --> 00:34:12,820
我可以把他们混合起来
I can put things together.

311
00:34:12,820 --> 00:34:25,140
这里有一个操作叫做beside 它做的事情是：给定两个图像 比如 A和B ---
There's a means of combination called Beside, and what Beside does: it'll take two pictures, let's say A and B--

312
00:34:29,020 --> 00:34:33,250
然后它将在一个特殊的矩形中绘制一个图像
and by picture I mean something that's going to draw an image in a specified rectangle--

313
00:34:34,050 --> 00:34:36,510
beside会--
and what Beside will do--

314
00:34:37,850 --> 00:34:44,080
让B靠在A的旁边 还有一个数字S #TBD
I have to say, Beside of A and B, the side of two pictures and some number, s.

315
00:34:45,340 --> 00:34:48,080
s是一个在0到1之间的数
And s will be a number between zero and one.

316
00:34:50,510 --> 00:34:52,570
beside会像这样画一个图像出来
And Beside will draw a picture that looks like this.

317
00:34:52,570 --> 00:34:56,710
你给定一个矩形区域和图形的缩放比例s
It will take the rectangle you give it and scale its base by s.

318
00:34:56,710 --> 00:34:58,710
这里s是0.5
Say s is 0.5.

319
00:34:59,970 --> 00:35:12,650
在这里它会画--它会在这里画第一个图案 在这里画第二个图案
And then over here it will draw-- it'll put the first picture, and over here it'll put the second picture.

320
00:35:13,820 --> 00:35:23,950
如果我给一个不同的s 如果我给s不同的值 如果我说 应用beside(使用S)为0.25
Or for instance if I gave it a different value of s, if I said Beside with a 0.25,

321
00:35:25,940 --> 00:35:29,340
它将做同样的事情 只是A更瘦了
it would do the same thing,except the A would be much skinnier.

322
00:35:34,050 --> 00:35:36,280
(beside)就是这样画图的
So it would draw something like that.

323
00:35:37,820 --> 00:35:46,050
这就是beside的组合 很简单 也有一个操作叫做above 也是做同样的事情 就是将水平方向的操作用竖直方向的操作替换
So there's a means of combination Beside, and similarly there's an Above, which does the same thing except it puts them vertically instead of horizontally.

324
00:35:47,310 --> 00:35:49,570
我们看一下它
Well let's look at that.

325
00:35:50,740 --> 00:36:11,740
对 这个就似乎George和他的"兄弟" 它的构造是通过在George应用一次beside和above--
All right, there's George and his kid brother, which is, right, constructed by taking George and putting him Beside the Above--

326
00:36:11,740 --> 00:36:16,140
系统中有个东西叫做空图案 很明显--
taking the empty picture, and there's a thing called the empty picture, which does the obvious thing--

327
00:36:16,140 --> 00:36:19,140
空图像放在了George副本的上面
putting the empty picture above a copy of George,

328
00:36:19,140 --> 00:36:21,140
然后这个合成的图像放在了George的旁边
and then putting that whole thing Beside George.

329
00:36:28,770 --> 00:36:54,080
给beside然后flipping图像George的过程起一个名字叫做P 它水平扩展 然后先旋转整个图像180度 然后将基本的矩形区域分成两半 将原图和现在这个图拼接在一起 我叫它P
Here's something called P which is, again, George Beside Flipping George, I think, horizontally in this case, and then Rotating the whole result 180 degrees and putting them Beside one another with the basic rectangle divided at 0.5, right, and I can call that P.

330
00:36:55,880 --> 00:37:05,050
我把P作用在翻转上面 给它起一个名字叫做Q #TBD这里翻译有问题,估计
And then I can take P, and put it above the Flipped copy of itself, and I can call that Q.

331
00:37:09,200 --> 00:37:21,050
我们构建一个复杂情况需要多少时间？ 15秒，你就可以从George得到Q 这个是为什么呢？
Notice how rapidly that we've built up complexity, just in, you know, 15 seconds, you've gotten from George to that thing Q. Why is that?

332
00:37:22,050 --> 00:37:24,550
为什么我们可以如此迅速的做呢?
How are how we able to do that so fast?

333
00:37:25,850 --> 00:37:28,020
答案是闭包属性
The answer is the closure property.

334
00:37:28,020 --> 00:37:38,250
事实是 一个图形 我可以用它来做beside的参数 生成一个图像 然后我可以用这个图像继续进行rotage flip或者above等操作
See, it's the fact that when I take a picture and put it Beside another picture, that's then, again, a picture that I can go and Rotate and Flip or put Above something else.

335
00:37:39,170 --> 00:37:45,220
当我对那个图像进行P操作 得到的还是一个图像
Right, and when I take that element P, which is the Beside or the Flip or the Rotate of something, that's, again, a picture.

336
00:37:45,220 --> 00:37:50,600
也就是说 对于图像而言 这些组合是封闭的
Right, the world of pictures is closed under those means of combination.

337
00:37:50,600 --> 00:37:55,600
所以只要给我一个图像 我可以立刻把它作为一个可以在其它地方使用的元素
So whenever I have something, I can turn right around and use that as an element in something else.

338
00:37:55,600 --> 00:38:03,280
也许(这个案例)比列表和线段更好 给大家展示了如何快速构建复杂的系统 根本原因是这些操作是封闭的
So maybe better than List and segments, that just gives you an image for how fast you can build up complexity, because operations are closed.

339
00:38:07,220 --> 00:38:15,280
在构建更多东西之前 我们谈谈这个语言要如何实现
OK, well before we go on with building more things, let's talk about how this language is actually implemented.

340
00:38:16,910 --> 00:38:28,280
在这个桌子下面的基本元素叫做矩形区域 矩形区域是： #TBD 需要修改
The basic element that sits under the table here is a thing called a rectangle, and what a rectangle is going to be,

341
00:38:28,280 --> 00:38:40,180
它有指定的原点 用来说明这个矩形区域从哪里开始的
it's a thing that specified by an origin that's going to be some vector that says where the rectangle starts.

342
00:38:40,180 --> 00:38:59,580
还有其他向量 我叫它矩形区域的水平向量 另一个是矩形区域的竖直向量
And then there's going to be some other vector that I'm going to call the horizontal part of the rectangle, and another vector called the vertical part of the rectangle.

343
00:39:00,310 --> 00:39:09,970
它们三个是三个元素:底坐标在哪里 这里如何获得下一个坐标 这里如何获得下一个坐标
And those three pieces are the elements: where the lower vertex is, how you get to the next vertex over here, and how you get to the vertex over there.

344
00:39:09,970 --> 00:39:12,370
这三个向量确定了一个矩形
The three vectors specify a rectangle.

345
00:39:15,770 --> 00:39:39,650
现在为了构建了矩形 我们假定我们已经有了一个构造器 叫做make rectangle 或者make-rect 它的水平，竖直，原点的选择器是horiz, vert, origin
Now to actually build rectangles, what I'll assume is that we have a constructor called "make rectangle," or "make-rect," and selectors for horiz and vert and origin that get out the pieces of that rectangle.

346
00:39:39,650 --> 00:39:42,540
大家知道有很多方法可以实现它
And well, you know a lot of ways you can do this now.

347
00:39:42,540 --> 00:39:47,620
大家可以用pair或者列表或者别的什么东西来做
You can do it by using pairs in some way or other standard List or not.

348
00:39:47,620 --> 00:39:51,400
但是，实现这个是George该去想的问题
But in any case, the implementation of these things, that's George's problem.

349
00:39:51,400 --> 00:39:53,170
这就是一个数据抽象问题
It's just a data representation problem.

350
00:39:53,170 --> 00:39:55,470
现在我们假设已经有了这三个矩形
So let's assume we have these rectangles to work with.

351
00:40:02,050 --> 00:40:05,080
记住要做什么
OK. Now the idea of this, remember what's got to happen.

352
00:40:05,080 --> 00:40:16,600
我们需要操心的是:给定一个图案 对它进行缩放来填充给定的矩形 这个是我们需要做的
Somehow we have to worry about taking the figure and scaling it to fit some rectangle that you give it, that's the basic thing you have to arrange,

353
00:40:16,600 --> 00:40:18,600
that these pictures can do.

354
00:40:22,220 --> 00:40:23,650
我们要怎么做呢？
How do we think about that?

355
00:40:23,650 --> 00:40:38,850
其中的一种方法是任何时候给定一个矩行
Well, one way to think about that is that any time I give you a rectangle,

356
00:40:39,250 --> 00:40:45,770
定义 在某种意义上 把一个正方形转化成矩形.
that defines,in some sense, a transformation from the standard square into that rectangle.

357
00:40:45,770 --> 00:40:46,540
我们来看一下我所说的
Let me say what I mean.

358
00:40:46,540 --> 00:40:59,040
一个标准的正方形 它的坐标是(0,0)(1,0)(1,1)
By the standard square, I'll mean something, which is a square whose coordinates are 0,0, and 1,0, and 0,1 and 1,1.

359
00:41:01,400 --> 00:41:10,340
有一些显然的缩放变换 可以把这个变成那个 把这个变成那个
And there's some sort of the obvious scaling transformation, which maps this to that and this to that,

360
00:41:10,340 --> 00:41:12,080
还有一些对每一个向量进统一拉伸的方法
and sort of, stretches everything uniformly.

361
00:41:12,170 --> 00:41:32,680
我们像这样做一个线段 并且做它的映射像这样 所以点(x,y)变成了另外一个点
So we take a line segment like this and end up mapping it to a line segment like that, so some point (x,y) goes to some other point up there.

362
00:41:32,680 --> 00:41:39,370
虽然这个不重要 就是一点点的代数几何 大家可以容易的把公式写出来
And although it's not important,with a little vector algebra, you could write that formula.

363
00:41:39,370 --> 00:41:50,670
点(x,y)会变到 用矩阵的原点和它做向量加法 --
The thing that (x,y) goes to, the point that (x,y) goes to is gotten by taking the origin of the rectangle and then adding that as a vector to--

364
00:41:50,670 --> 00:42:01,970
x坐标 这个值在0到1之间 乘以矩阵的水平向量
well, take x, the x coordinate, which is something between zero and one, multiply that by the horizontal vector of the rectangle;

365
00:42:07,220 --> 00:42:16,280
y坐标 这个值也在0到1之间 乘以矩阵的竖直向量
and take the y coordinate, which is also something between zero and one and multiply that by the vertical vector of the rectangle.

366
00:42:16,740 --> 00:42:19,310
这个是简单地线性代数
That's just a little linear algebra.

367
00:42:19,310 --> 00:42:28,510
这个公式明显正确的把正方形中的元素转换成了矩阵的内部元素
Anyway, that's the formula, which is the right obvious transformation that takes things into the unit square, into the interior of that rectangle.

368
00:42:31,340 --> 00:42:34,020
好，我们把它看作是一个过程
OK well, let's actually look at that as a procedure.

369
00:42:35,050 --> 00:42:42,850
所以我们要做的事情是定义一个矩形的转化过程
So what we want is the thing which tells us that particular transformation that a rectangle defines.

370
00:42:43,800 --> 00:42:45,220
就是这个过程
So here's the procedure.

371
00:42:45,220 --> 00:42:47,220
我叫它coordinate-map
I'll call it coordinate-map.

372
00:42:47,770 --> 00:42:57,850
coordinate-map需要一个矩形作为参数，它返回需要一个点坐标作为参数的过程
Coordinate-map is the thing that takes as its argument a rectangle and returns for you a procedure on points.

373
00:43:00,450 --> 00:43:06,820
所以对每一个矩形，你都有个转换函数将一个点(x,y)转换到这个矩形里面
Right, so for each rectangle you get a way of transforming a point (x,y) into that rectangle.

374
00:43:06,820 --> 00:43:08,020
如何做呢？
And how do you get it?

375
00:43:08,020 --> 00:43:10,920
我只是--在黑板上用列表实现  #TBD 这个是list 还是lisp 不确定
Well I just--  writing in List what I wrote there on the blackboard--

376
00:43:10,920 --> 00:43:20,200
矩形的原点--
I add to the origin of the rectangle the result of adding--

377
00:43:20,220 --> 00:43:25,020
我用矩形的水平向量
I take the horizontal part of the rectangle;

378
00:43:25,020 --> 00:43:27,680
来对点point的x坐标缩放
I scale that by the x coordinate of the point.

379
00:43:29,650 --> 00:43:32,620
我用矩形的竖直向量，
I take the vertical vector of the rectangle.

380
00:43:33,510 --> 00:43:37,140
来对point的y坐标进行缩放
I scale that by the y coordinate of the point,

381
00:43:37,140 --> 00:43:39,140
然后把他们三个加到一起
and then add all those three things up.

382
00:43:39,340 --> 00:43:41,340
这就是这个过程
That's the procedure.

383
00:43:41,340 --> 00:43:44,540
这就是我将要应用在point上的过程
That is the procedure that I'm going to apply to a point.

384
00:43:46,540 --> 00:43:52,170
每一个矩形都可以产生这样一个过程
And this whole thing is generated for each rectangle.

385
00:43:52,170 --> 00:43:57,250
所以任何一个矩形定义一个coordinate-map,返回一个作用在point上的过程
So any rectangle defines a coordinate MAP, which is a procedure on points.

386
00:44:06,510 --> 00:44:28,170
比如，原始的George，在这个正方形单元中有一些线段，只要我指定一个矩行,就可以把这些线段映射过来.
All right, so for example, George here, my original George, might have been something that I specified by segments in the unit square, and then for each rectangle I give this thing, I'm going to draw those segments inside that rectangle.

387
00:44:28,170 --> 00:44:30,170
我实际是怎么做的呢?
How actually do I do that?

388
00:44:30,170 --> 00:44:44,450
我把原来在George中的每一个线段的原点和结束点应用到coordinate-map上。#TBD
Well I take each segment in my original reference George that was specified, and to each of the end points of those segments, I applied the coordinate MAP of the particular rectangle I want to draw it in.

389
00:44:44,450 --> 00:44:51,250
比如，这个矮矩形，图像George用coordinate-map变换后变成一个胖子
So for example, this lower rectangle, this George as a fat kid rectangle, has its coordinate MAP.

390
00:44:51,250 --> 00:45:05,340
如果我要绘制这个图像，我要做的就是对这里的每一个线段，用coordinate-map映射线段的段点
And if I want to draw this image, what I do is for each segment here, say for this segment, I transformed that point by the coordinate MAP, transform that point by the coordinate MAP.

391
00:45:05,340 --> 00:45:09,220
它将给我这个点和那个点，并且在这两个点中画一个线段
That will give me this point and that point and draw the segment between them.

392
00:45:09,710 --> 00:45:11,520
对，基本想法就是这样
Right, that's the idea.

393
00:45:12,660 --> 00:45:18,140
像这样如果我给一个不同的矩形，那么(会产生)不同的coordinate-map,因此我得到这些线段的不同图像
Right, and if I give it a different rectangle like this one, that's a different coordinate MAP, so I get a different image of those line segments.

394
00:45:19,280 --> 00:45:22,140
我们如何获得最开始的图像呢?
Well how do we actually get a picture to start with?

395
00:45:22,140 --> 00:45:26,520
我们可以用线段列表获得最初的图像.
I can build a picture to start with out of a List of line segments initially.

396
00:45:27,500 --> 00:45:37,520
这是一个我构建最基本图像的过程，意思是，我没有用beside，rotate等构建图像
Here's a procedure that builds what I'll call a primitive picture, meaning one I, sort of, got that didn't come out of Beside or Rotate or something.

397
00:45:37,520 --> 00:45:44,040
我用线段的列表，他们按照我说的来工作
It starts with a List of line segments, and now it does what I said.

398
00:45:44,040 --> 00:45:45,580
图像会是什么样子呢？
What's a picture have to be?

399
00:45:45,580 --> 00:45:49,440
首先，它是一个根据矩形定义的过程
First of all it's a procedure that's defined on rectangles.

400
00:45:51,700 --> 00:45:53,000
这个过程做什么呢？
What does it do?

401
00:45:53,000 --> 00:46:07,300
线段构成的列表中的每一个元素s,它自己画一条线段.
It says for each-- this is going to be a List of line segments-- for each segment, for each s, which is a segment in this List of segments, well it draws a line.

402
00:46:07,300 --> 00:46:08,820
它画什么样的线段呢？
What line does it draw?

403
00:46:10,460 --> 00:46:18,320
线段的起点，通过在特定矩形的coordinate-map变换
It gets the start point of that segment, transforms that by the coordinate MAP of the rectangle.

404
00:46:19,540 --> 00:46:21,760
这个就是第一个想要的新的点
That's the first new point it wants to do.

405
00:46:21,760 --> 00:46:27,920
线段的终点，通过这个矩形的coordinate-map变换得到新点，在新起点和新终点之间画一个线段
Then it takes the endpoint of the segment, transforms that by the coordinate MAP of the rectangle, and then draws a line between.

406
00:46:27,920 --> 00:46:33,220
我们假设画线是一个基本的操作，已经在系统中实现了.
Let's assume drawline is some primitive that's built into the system that actually draws a line on the display.

407
00:46:33,960 --> 00:46:44,220
通过矩形的坐标映射变换了线段两段点，在新段点间画一个线段.线段列表的每一个线段s都会进行这样的操作
All right, so it transforms the endpoints by the coordinate MAP of the rectangle, draws a line between them, does that for each s in this List of segments.

408
00:46:45,960 --> 00:46:51,400
现在要记住，一个图像就是一个用矩形作为参数的过程.
And now remember again, a picture is a procedure that takes a rectangle as argument.

409
00:46:51,400 --> 00:46:56,360
所以当你有一个矩形的时候，它所做的事情就是：画这些线段.
So when you hand it a rectangle, this is what it does: draws those lines.

410
00:46:56,360 --> 00:47:01,220
好，我应该如何使用它呢？
All right, so there's-- how would I actually use this thing?

411
00:47:01,220 --> 00:47:04,080
我来说的具体一点
Let's make it a little bit more concrete.

412
00:47:05,600 --> 00:47:29,180
举例来说，定义R是make-rectangle的过程，我需要用make-vector来生成一些向量
Right, I would say for instance, define R to be make-rectangle of some stuff, and I'd have to specify some vectors here using make-vector.

413
00:47:29,840 --> 00:47:46,180
然后，定义G为make-picture的过程
And then I could say, define say, G to be make-picture, and then some stuff.

414
00:47:46,680 --> 00:47:55,280
这里声明一个线段列表,叫做make-segment
And what I'd have to specify here is a List of line segments, right, using make segment.

415
00:47:55,280 --> 00:47:58,700
make-segment由向量构成，向量由点构成
Make-segment might be made out of vectors, and vectors might be made out of points.

416
00:47:59,260 --> 00:48:11,720
如果我想看G里面矩形的图像，它是一个用这个矩形作为参数的过程
And then if I actually wanted to see the image of G inside a rectangle, well a picture is a procedure that takes a rectangle as argument.

417
00:48:11,920 --> 00:48:23,620
所以，如果用R作为参数调用G，图像G将会在矩形R来绘制出来.
So if I then called G with an input of R, that would cause whatever image G is worrying about to be drawn inside the rectangle R.

418
00:48:23,620 --> 00:48:25,620
这就是大家如何使用它
Right, so that's how you'd use that.

419
00:48:25,620 --> 00:49:07,280
[MUSIC PLAYING]

420
00:49:07,720 --> 00:49:12,480
老师：为什么我说这个例子很好呢？
PROFESSOR: Well why is it that I say this example is nice?

421
00:49:12,480 --> 00:49:13,740
大家也许不觉得它很好.
You probably don't think it's nice.

422
00:49:13,740 --> 00:49:15,420
大家可能觉得它很奇怪
You probably think it's more weird than nice.

423
00:49:15,420 --> 00:49:20,920
对，这些图像用过程来表示，用矩形来做一些复杂的事情(变换)
Right, representing these pictures as procedures, which do complicated things with rectangles.

424
00:49:20,920 --> 00:49:22,720
那么,它好在哪里呢？
So why is it nice?

425
00:49:25,020 --> 00:49:35,220
它很好的原因是，一旦你是实现了其中的基本元素---把过程的实现跟组合分离出来.
The reason it's nice is that once you've implemented the primitives in this way, the means of combination just fall out by implementing procedures.

426
00:49:35,980 --> 00:49:37,480
我来展示一下我的想法.
Let me show you what I mean.

427
00:49:37,480 --> 00:49:39,480
假如我想实现beside
Suppose we want to implement Beside.

428
00:49:41,560 --> 00:49:47,360
所以我要做---假设我有一个图像,把它叫做P1
So I'd like to--  suppose I've got a picture.Let's call it P1.

429
00:49:47,360 --> 00:49:50,620
P1是--现在要明白真正的图像是什么(一个过程)
P1 is going to be-- and now remember what a picture really is.

430
00:49:50,620 --> 00:50:01,920
如果你给P1一个矩形，它会在你给定的矩形中绘制图像.
It's a thing that if you can hand it some rectangle, it will cause an image to be drawn in whatever rectangle you hand it.

431
00:50:03,140 --> 00:50:09,640
假设P2，是另外的图像，你用一个矩形处理它，
And suppose P2 two is some other picture, and you hand that a rectangle.

432
00:50:09,640 --> 00:50:12,540
无论你给它什么矩形，它都会绘制一些图案.
And whatever rectangle you hand it, it draws some picture.

433
00:50:14,660 --> 00:50:28,380
现在，我想实现beside,用P1，P2，还有一个缩放因子a, 那会发生什么呢？
And now if I'd like to implement Beside of P1 and P2 with a scale factor A, well what does that have to be?

434
00:50:34,620 --> 00:50:40,300
所以，如果把Beside放到矩形里，---我们在这个矩行中处理它.
So if hand Beside this rectangle-- let's hand it a rectangle.

435
00:50:41,500 --> 00:50:42,740
要做什么呢？
Well what's it going to do?

436
00:50:42,760 --> 00:50:55,380
它将把这个矩形切分成两部分，一部分比例是a,另一部分比例是(1-a). 那是说，现在我们有两个矩形
It's going to take this rectangle and split it into two at a ratio of A and one minus A. And it will say, oh sure, now I've got two rectangles.

437
00:51:02,020 --> 00:51:09,840
现在(beside)进入P1，对P1说，在这个矩形中绘制你自己，然后进入P2，对P2说，
And now it goes off to P1 and says P1, well draw yourself in this rectangle, and goes off to P2, and says, P2,

438
00:51:09,840 --> 00:51:11,840
在这个矩形中绘制你自己
fine, draw yourself in this rectangle.

439
00:51:13,280 --> 00:51:16,880
它所做的所有计算就是计算出有多少个矩形.
The only computation it has to do is figure out what these rectangles are.

440
00:51:17,360 --> 00:51:26,380
要记住，一个矩形是原点，水平向量，竖直向量组成的，它要做的就是把他们找出来
Remember a rectangle is specified by an origin and a horizontal vector and a vertical vector, so it's got to figure out what these things are.

441
00:51:27,300 --> 00:51:38,000
所以对第一个矩形来说，原点变成了矩形的原点，竖直向量和原始的矩形保持不变
So for this first rectangle, the origin turns out to be the origin of the original rectangle, and the vertical vector is the same as the vertical vector of the original rectangle.

442
00:51:38,700 --> 00:51:46,600
水平向量是原始矩形的竖直向量缩放a得到的
The horizontal vector is the horizontal vector of the original rectangle scaled by A.

443
00:51:47,380 --> 00:51:49,260
这就是第一个矩形
And that's the first rectangle.

444
00:51:49,460 --> 00:52:00,060
第二个矩形的原点是原来的矩形的原点加上矩形的水平向量缩放a,
The second rectangle, the origin is the original origin plus that horizontal vector scaled by A.

445
00:52:00,900 --> 00:52:11,660
第二个矩形的水平向量，是矩形的水平向量减去第一个的水平向量，是(1-a)*h
The horizontal vector of the second rectangle is the rest of the horizontal vector of the first one, which is 1 minus A times the original H,

446
00:52:11,660 --> 00:52:14,360
它的竖直向量还是v
and the vertical vector is still v.

447
00:52:15,220 --> 00:52:26,560
基本上,它构造了两个矩形,更重要的是,构造的这两个矩形p1,在这里让它绘制它自己,矩形p2，让它在这里绘制它自己。这就是beside所做的事情
But basically it goes and constructs these two rectangles, and the important point is having constructed the rectangles, it says OK, p1, you draw yourself in there, and p2, you draw yourself in there, and that's all Beside has to do.

448
00:52:27,680 --> 00:52:29,860
我们看一下代码
All right, let's look at that piece of code.

449
00:52:34,200 --> 00:52:53,760
用一个缩放比例来对一个图像和另一个图像应用biside, 首先，这个图像也是一个过程，接受一个矩形作为它的参数
Beside of a picture and another picture with some scaling ratio is first of all, since it's a picture, a procedure that's going to take a rectangle as argument.

450
00:52:55,380 --> 00:52:56,760
它做什么呢？
What's it going to do?

451
00:52:56,760 --> 00:53:02,320
p1在一些矩形中绘制它自己，p2在另外的一些矩形中绘制它自己
It says, p1 draw yourself in some rectangle and p2 draw yourself in some other rectangle.

452
00:53:02,900 --> 00:53:04,460
现在这些矩形是什么呢?
And now what are those rectangles?

453
00:53:04,460 --> 00:53:05,480
这里就是计算
Well here's the computation.

454
00:53:05,480 --> 00:53:10,400
它创建了一个矩形，这个是我刚才在黑板上写的几何公式--- 原点
It makes a rectangle, and this is the algebra I just did on the board: the origin, something;

455
00:53:10,400 --> 00:53:11,840
水平向量；
the horizontal vector, something;

456
00:53:11,840 --> 00:53:13,440
竖直向量
and the vertical vector, something.

457
00:53:13,800 --> 00:53:19,780
对于p2,矩形需要不同的原点，水平向量和竖直向量
And for p2, the rectangle it wants has some other origin and horizontal vector and vertical vector.

458
00:53:19,780 --> 00:53:27,180
但是最重要的是，p1,在一个矩形中做你指定的事情，而p2在另一个矩形中做你指定的事情
But the important point is that all it's saying is, p1, go do your thing in one rectangle, and p2, go do your thing in another rectangle.

459
00:53:27,740 --> 00:53:29,420
这个就是beside做的
That's all the Beside has to do.

460
00:53:30,620 --> 00:53:35,620
好，rotate也很类似
OK, similarly Rotate--

461
00:53:36,960 --> 00:53:52,320
我有这个图像a,我想看图像a旋转90度,这意味着,给定这个矩形
see if I have this picture A, and I want to look at say rotating A by 90 degrees, what that should mean is, well take this rectangle,

462
00:53:53,760 --> 00:54:09,320
这个矩形的原始原点，水平向量，竖直向量，现在假设已经有了这样的矩形，这个矩形的原点，水平向量，在这，竖直向量在这
which is origin and horizontal vector and vertical vector, and now pretend that it's really the rectangle that looks like this, which has an origin and a horizontal vector up here, and a vertical vector there,

463
00:54:09,600 --> 00:54:12,460
然后在矩形里各自绘制自己.
and now draw yourself with respect to that rectangle.

464
00:54:13,260 --> 00:54:15,040
我来展示这个过程
Let me show you that as a procedure.

465
00:54:16,760 --> 00:54:26,340
我们对这个图像旋转90度，因为过程也是一个图像，它可以在特定的矩形中绘制自己
All right, so we'll Rotate 90 of the picture, because again, a procedure for rectangle, which says, OK picture, draw yourself in some rectangle;

466
00:54:27,100 --> 00:54:30,660
并且这个几何公式就是这个矩形的变换规则
and then this algebra is the transformation on the rectangle.

467
00:54:30,660 --> 00:54:34,160
It's the one which makes it look like the rectangle is sideways,

468
00:54:34,160 --> 00:54:40,060
原点在别的地方；竖直向量在别的地方；水平向量在别的地方;竖直向量在别的地方
the origin is someplace else and the vertical vector is someplace else, and the horizontal vector is someplace else, and vertical vector is someplace else.

469
00:54:46,760 --> 00:55:01,260
再次注意，这里的关键是使用过程来做图片的表示，这个过程本身有闭包的特性，
OK, again notice, the crucial thing that's going on here is you're using the representation of pictures as procedures to automatically get the closure property,

470
00:55:01,740 --> 00:55:05,220
beside对于p1,
because what happens is, Beside just has this thing p1.

471
00:55:05,220 --> 00:55:12,900
beside不关心那个是不是主要的图像，或者是线段，或者这个是不是由above, beside,rotate生成的，//
Beside doesn't care if that's a primitive picture or it's line segments or if p1 is, itself, the result of doing Aboves or Besides or Rotates.

472
00:55:12,900 --> 00:55:20,000
beside所知道的就是,如果你给p1一个矩形，它会在这个矩形中绘制(p1)
All Beside has to know about, say, p1 is that if you hand p1 a rectangle, it will cause something to be drawn.

473
00:55:20,820 --> 00:55:26,100
在这个层面上，beside不关心p1是如何绘制自己的
And above that level, Beside just doesn't-- it's none of its business how p1 accomplishes that drawing.

474
00:55:27,420 --> 00:55:32,540
对，这就是使用过程表示图像保证了这个(系统)闭包的
All right, so you're using the procedural representation to ensure this closure.

475
00:55:35,640 --> 00:55:43,840
所以用过程来实现图片,使得组合的意义非常简单，并且优美
So implementing pictures as procedures makes these means of combination, you know, both pretty simple and also, I think, elegant.

476
00:55:45,920 --> 00:55:48,220
但是这个不是真正的至理名言
But that's not the real punchline.

477
00:55:49,280 --> 00:55:53,520
真正的来自当你用这种语言看待抽象的意义的时候
The real punchline comes when you look at the means of abstraction in this language.

478
00:55:54,700 --> 00:55:56,240
因为我们做的什么？
Because what have we done?

479
00:55:56,240 --> 00:56:03,720
我们用组合实现了过程
We've implemented the means of combination themselves as procedures.

480
00:56:05,640 --> 00:56:21,620
这个的意思是，当我们在这个语言进行抽象的时候，Lisp提供的一切操作过程，都可以用在这个图片语言中
And what that means is that when we go to abstract in this language, everything that Lisp supplies us for manipulating procedures is automatically available to do things in this picture language.

481
00:56:21,920 --> 00:56:32,800
我可以使用的语言不仅仅是Lisp本身的,也包括这种非常优雅的嵌入到Lisp中的语言.
The technical term I want to say is not only is this language implemented in Lisp, obviously it is, but the language is nicely embedded in Lisp.

482
00:56:37,640 --> 00:56:48,860
我的意思是，通过这种方式嵌入语言，Lisp的强悍特点就自然的表现出来了，它可以为你做任何事情
What I mean is by embedding the language in this way, all the power of Lisp is automatically available as an extension to whatever you want to do.

483
00:56:50,060 --> 00:56:51,680
我的意思是
And what do I mean by that?

484
00:56:51,680 --> 00:57:07,060
比如说，我想做一个图像，它有四个图片做为参数a, b ,c ,d.并且想这样做配置.
Example: say, suppose I want to make a thing that takes four pictures A, B, C and D, and makes a configuration that looks like this.

485
00:57:12,500 --> 00:57:16,960
恩，大家可以叫它，four-pictures或者,four-pict的配置
Well you might call that, you know, four pictures or something, four-pict configuration.

486
00:57:16,960 --> 00:57:17,700
我如何做到这样的呢？
How do I do that?

487
00:57:17,700 --> 00:57:18,680
我可以很容易的做到这些
Well I can obviously do that.

488
00:57:18,680 --> 00:57:27,880
我就是写一个过程，把b放在d上面，把a放在c上面，然后把这两部分用beside连接起来
I just write a procedure that takes B above D and A above C and puts those things beside each other.

489
00:57:28,240 --> 00:57:31,820
我天生就有Lisp的能力来做过程组合.
So I automatically have Lisp's ability to do procedure composition.

490
00:57:32,920 --> 00:57:35,820
这不需要我专门为图像语言在做什么特殊的事情.
And I didn't have to make that specifically in the picture language.

491
00:57:35,820 --> 00:57:39,920
事实上，这些组合本身就是过程.
It's automatic from the fact that the means of combination are themselves procedures.

492
00:57:40,960 --> 00:57:44,180
假设我想做一些更复杂的事情
Or suppose I wanted to do something a little bit more complicated.

493
00:57:44,180 --> 00:57:50,080
我想为这里的每一个传递一个参数，我可以独立的做旋转90度的操作
I wanted to put in a parameter so that for each of these, I could independently specify a rotation by 90 degrees.

494
00:57:50,080 --> 00:57:52,760
这只需要我在这个过程中加入一个参数
That's just putting a parameter in the procedure.

495
00:57:52,760 --> 00:57:54,760
It's automatically there.

496
00:57:54,800 --> 00:57:57,840
对，它自动就嵌入进去了
Right, it automatically comes from the embedding.

497
00:57:58,160 --> 00:58:05,360
甚至，假设我想使用递归
Or even more, suppose I wanted to, you know, use recursion.

498
00:58:06,160 --> 00:58:10,780
我们看一下图片组合的递归
Let's look at a recursive means of combination on pictures.

499
00:58:10,780 --> 00:58:19,140
我来定义--我们来看，如果你可以理解这个是什么 -- 假设我定义right-push一个图片.
I could say define-- let's see if you can figure out what this one is-- suppose I say define what it means to right-push a picture,

500
00:58:22,840 --> 00:58:29,800
right-push需要一个图片,一个整数N,一个缩放因数A.
right-push a picture and some integer N and some scale factor A.

501
00:58:31,460 --> 00:58:41,220
如果n等于0，那么我的定义就返回这个图片本身
I'll define this to say if N equals 0, then the answer is the picture.

502
00:58:42,200 --> 00:58:54,020
否则，就-- oops，这里是p(教授笔误)
Otherwise I'm going to put-- oops, name change: P.

503
00:58:55,880 --> 00:59:18,520
否则，我用P，把它放到beside的返回值中，这个返回值递归的进行(right-push P (- n 1) a) .
Otherwise, I'm going to take P and put it beside the results of recursively right-pushing P with N minus 1 and A and use a scale factor of A. OK,

504
00:59:24,720 --> 00:59:31,120
所以，如果n等于0，那么就返回P，否则就对P进行a 倍缩放
so if N 0 , it's P. Otherwise I put P with a scale factor of A--

505
00:59:31,120 --> 00:59:32,800
对不起，我不能把这些代码写成一行---
I'm sorry I didn't align this right--

506
00:59:32,800 --> 00:59:38,500
递归的调用(right-push p (- n 1) a),并将结果(递归的)用beside连接
recursively beside the result of right-pushing P, N minus 1 times with a scale factor of A.

507
00:59:38,500 --> 00:59:42,000
这就是一个递归组合方法
There's a recursive means of combination.

508
00:59:43,600 --> 00:59:44,760
它看起来像什么呢？
What's that look like?

509
00:59:44,760 --> 00:59:46,040
我们来看看
Well, here's what it looks like.

510
00:59:46,040 --> 00:59:56,140
这是对George图片应用过程right-pushed 2次，放缩因数是0.75的结果
There's George right-pushed against himself twice with a scale factor of 0.75.

511
00:59:59,260 --> 01:00:00,720
这个是从什么地方来的呢？
Where'd that come from?

512
01:00:00,720 --> 01:00:02,340
我是如何想象的出来这些递归的呢？
How did I get all this fancy recursion?

513
01:00:02,340 --> 01:00:05,240
答案是无意识的，绝对是无意识的
And the answer is just automatic, absolutely automatic.

514
01:00:05,240 --> 01:00:09,800
因为他们都是过程,而且嵌入在(现有的Lisp中)，我当然可以定义递归过程
Since these are procedures, the embedding says, well sure, I can define recursive procedures.

515
01:00:10,160 --> 01:00:11,800
我没有特意去做这个.
I didn't have to arrange that.

516
01:00:13,560 --> 01:00:16,420
当然，我们可以根据这些做更加复杂的事情
And of course, we can do more complicated things of the same sort.

517
01:00:16,420 --> 01:00:18,420
我可以定义过程叫做up-push.
I could make something that does an up-push.

518
01:00:18,420 --> 01:00:22,600
对，它可以递归的把图片放在原来的上面
Right, that sort of goes like this, by recursively putting something above.

519
01:00:22,600 --> 01:00:26,560
或者我也可以用这种策略来做一些其它事情
Or I could make something that, sort of, was this scheme.

520
01:00:26,560 --> 01:00:39,300
我可以用一个图片开始，然后递归的把它放在原始图片的旁边和上面，这里可以放一些别的
I might start out with a picture and then, sort of, recursively both push it aside and above, and that might put something there.

521
01:00:39,300 --> 01:00:44,200
然后在这个上面，我递归的做同样的事情。我可以像这样结束它
And then up here I put the same recursive thing, and I might end up with something like this.

522
01:00:45,400 --> 01:00:52,500
对，这个过程比right-push复杂一点，但是也没有复杂很多
Right, so there's a procedure that's a little bit more complicated than right-push but not much.

523
01:00:53,640 --> 01:00:58,140
我就是做了above和beside,而不仅仅是beside.
I just do an Above and a Beside, rather than just a Beside.

524
01:01:01,120 --> 01:01:14,240
现在，如果我利用把四个图片放在一起的想法,我确实可以这样做,我把它应用在Q上,这个我们之前定义过
Now if I take that and apply that with the idea of putting four pictures together, which I can surely do; and I go and I apply that to Q, which we defined before, right,

525
01:01:15,900 --> 01:01:25,540
生成的结果是: 两次"正方形极限".
what I end up with this is this thing, which is, sort of, the square limit of Q, done twice.

526
01:01:28,180 --> 01:01:34,740
好，我们现在来对比一下Escher的"正方形极限",大家可以看到，这都是基于同样的思想.
Right, and then we can compare that with Escher's "Square Limit." And you see, it's sort of the same idea.

527
01:01:34,740 --> 01:01:36,940
Escher的图像，当然更加漂亮一些
Escher's is, of course, much, much prettier.

528
01:01:36,940 --> 01:01:44,260
如果我们会过头看George,
If we go back and look at George, right, if we go look at George here--

529
01:01:44,260 --> 01:01:49,260
看，我最开始使用的是一个非常随意的设计,这张George的图片,并且用这个图片做了一些事情
see, I started with a fairly arbitrary design, this picture of George and did things with it.

530
01:01:51,040 --> 01:01:53,280
对，我们回头看Escher的图片，
Right, whereas if we go look at the Escher picture, right,

531
01:01:54,080 --> 01:01:56,140
Escher的图片不是随意设计的
the Escher picture is not an arbitrary design.

532
01:01:56,140 --> 01:02:05,340
它是一个非常非常聪明的图案，当你把这个鱼身体旋转，并且对它进行放缩，它变换成另一个非常好看的图像
It's this very, very clever thing, so that when you take this fish body and Rotate it and shrink it down, it bleeds into the next one really nicely.

533
01:02:07,400 --> 01:02:11,480
当然用George，我没有做像上面做的那些事情
And of course with George, I didn't really do anything like that.

534
01:02:12,120 --> 01:02:18,640
如果我仔细看George, 它也有一些地方可以匹配的，但是不够好。它确实很随意(意思是图片进行变换后很突兀，不能融为一体)
So if we look at George, right, there's a little bit of match up, but not very nice, and it's pretty arbitrary.

535
01:02:18,640 --> 01:02:27,540
顺便说一下，这是一个非常好的项目，可以写一些过程把一些基本的图形传入进去，就像George一样
One very nice project, by the way, would be to write a procedure that could take some basic figure like this George thing

536
01:02:27,540 --> 01:02:34,140
然后开始对图像中的每一条线进行移动,你完全可以获得一个非常漂亮的图案。就像"正方形极限"这个过程一样
and start moving the ends of the lines around, so you got a really nice one when you went and did that "Square Limit" process.

537
01:02:34,140 --> 01:02:36,740
这是一个非常值得思考的事情.
That'd be a really nice thing to think about.

538
01:02:38,080 --> 01:02:39,720
同时，我还可以进行组合.
Well so, we can combine things.

539
01:02:39,720 --> 01:02:41,040
我们还可以使用递归过程
We can recursive procedures.

540
01:02:41,040 --> 01:02:43,640
我们可以做任何事情，并且他们都是自然而然的
We can do all kinds of things, and that's all automatic.

541
01:02:44,500 --> 01:02:50,440
对，重点是，其中的区别仅仅是在一个语言中实现一些东西还是在一个语言中嵌入一些东西
Right, the important point, the difference between merely implementing something in a language and embedding something in the language,

542
01:02:50,440 --> 01:02:57,620
(嵌入到语言中)可以让你不丢失原有语言的能力，Lisp很强大的地方就是，Lisp是一个强悍的语言可以处理任何特殊问题.
so that you don't lose the original power of the language, and what Lisp is great at, see Lisp is a lousy language for doing any particular problem.

543
01:02:57,620 --> 01:03:02,100
把你想要的语言嵌入到Lisp中才是真的好
What it's good for is figuring out the right language that you want and embedding that in Lisp.

544
01:03:02,100 --> 01:03:05,440
这才是设计这个方法的真正的力量
That's the real power of this approach to design.

545
01:03:05,440 --> 01:03:06,820
当然，我门可以继续下去
Of course, we can go further.

546
01:03:06,820 --> 01:03:17,520
看，大家看，我们可以用列表做的事情是 -- 抽取做事情的通用方法，就像高阶过程一样
See, you saw the other thing that we can do in List is capture general methods of doing things as higher order procedures.

547
01:03:18,860 --> 01:03:26,720
大家刚才跟着我画了这个图像可能已经理解了我的想法：right-push和类似的过程，你放一些东西在上面，上面。。。
And you probably just from me drawing it got the idea that right-push and the analogous thing where you push something up and up and up and up

548
01:03:26,720 --> 01:03:33,820
在这个角落放所有一般化(通用)的想法
and this corner push thing are all generalizations of a common kind of idea.

549
01:03:34,540 --> 01:03:47,520
大家仔细想象一下然后自己再实践一下使用复杂的高阶过程，我来给大家展示一下把组合放进去递归的基本思想
So just to illustrate and give you practice in looking at a fairly convoluted use of higher order procedures, let me show you the general idea of pushing some means of combination to recursively repeat it.

550
01:03:48,300 --> 01:03:50,900
这是一个很好的解惑的例子
So here's a good one to puzzle out.

551
01:03:51,220 --> 01:04:00,700
我们用组合方法来定义这个push方法
We'll define it what it means to push using a means of combination.

552
01:04:01,360 --> 01:04:05,060
comb是像beside或者above一样的过程
Comb is going to be something like the Beside or Above.

553
01:04:05,880 --> 01:04:07,060
我们来看看它要做什么
Well what's that going to be.

554
01:04:07,060 --> 01:04:12,060
它是一个过程，记得beside其实也是一个过程
That's going to be a procedure, remember what Beside actually was, right.

555
01:04:13,120 --> 01:04:18,240
它使用一个图片，(不)用两个图片和一个缩放因子
It took a picture, took two pictures and a scale factor.

556
01:04:18,480 --> 01:04:24,280
利用这个过程，我创造了一个带一个数字，一个图片和一个缩放因子的(过程)
Using that I produced something that took a level number and a picture and a scale factor,

557
01:04:24,280 --> 01:04:25,660
我把它定义为right-push.
that I called right-push.

558
01:04:26,160 --> 01:04:33,660
它需要一个图片，一个数字，和一个缩放因子来进行处理
So this is going to be something that takes a picture, a level number and a scale factor, and it's going to say--

559
01:04:36,160 --> 01:04:39,120
我使用了一些重复的操作
I'm going to do some repeated operation.

560
01:04:39,120 --> 01:04:59,420
我将重复的应用这个过程，这个过程需要一个图片，和一个组合方法,还有原始图片,和在这里的缩放因子
I'm going to repeatedly apply the procedure which takes a picture and applies the means of combination to the picture and the original picture and the one I took in here and the scale factor,

561
01:05:02,100 --> 01:05:16,420
还有我要循环的次数n.我把整个事情都作用在原始图像上面
and I do the thing which repeats this procedure N times, and I apply that whole thing to my original picture.

562
01:05:19,360 --> 01:05:34,320
这里进行循环，这种情况大家还没有看到，是另一个高阶过程需要一个过程和一个数字;它返回另一个过程。返回的过程对这个过程应用n次
Repeated here, in case you haven't seen it, is another higher order procedure that takes a procedure and a number and returns for you another procedure that applies this procedure N times.

563
01:05:35,860 --> 01:05:43,220
我想大家已经写过循环作为练习了，如果还没有，这是一个非常好的例子用来思考高阶过程
And I think some of you have already written repeated as an exercise, but if you haven't, it's a very good exercise in thinking about higher order procedures.

564
01:05:43,720 --> 01:05:46,980
但是在任何情况下，这个循环的结果都是我应用到图片的过程
But in any case, the result of this repeated is what I apply to picture.

565
01:05:49,260 --> 01:06:13,300
做完这些，可以提取出来的是--我从beside的基本想法到right-push的基本想法。所以做完这个,我可以说,定义right-push来表示对beside做push.
And having done that, that's going to capture-- that is the thing, the way I got from the idea of Beside to the idea of right-push So having done that, I could say define right-push to be push of Beside.

566
01:06:17,420 --> 01:06:26,860
如果我说，定义个up-push来对beside做push, 我使用几何公式,或者定义corner-push来push那些相似的东西，比如beside和above,或者我可以push任何东西
Or if I say, define up-push to be push of Beside, I'd get the analogous thing or define corner-push to be push of some appropriate thing that did both the Beside and Above, or I could push anything.

567
01:06:28,080 --> 01:06:34,760
无论如何，如果你对lambda还不太熟悉，这个是一个非常好的练习来让大家体会这其中的意义
Anyway this is, if you're having trouble with lambdas, this is an excellent exercise in figuring out what this means.

568
01:06:38,840 --> 01:06:41,200
从这个例子以引申出很多的练习
OK, well there's a lot to learn from this example.

569
01:06:42,100 --> 01:06:49,800
我想要介绍的主要是在一个语言中嵌入另一个语言
The main point I've been welling on is the notion of nicely embedding a language inside another language.

570
01:06:50,540 --> 01:07:00,420
这样所有这门语言的能力，像围绕着Lisp的语言，可以被别的语言访问，可以作为天然的扩展
Right, so that all the power of this language like Lisp of the surrounding language is still accessible to you and appears as a natural extension of the language that you built.

571
01:07:00,420 --> 01:07:04,100
这个例子很好的展示了这点
That's one thing that this example shows very well.

572
01:07:07,900 --> 01:07:10,940
另一个事情是，如果你回头去想
Another thing is, if you go back and think about that,

573
01:07:10,940 --> 01:07:12,280
什么是过程什么是数据
what's procedures and what's data.

574
01:07:12,280 --> 01:07:16,200
到现在， 天啊， 到底发生了什么
You know, by the time we get up to here, my God, what's going on.

575
01:07:16,200 --> 01:07:19,660
我的意思是，这是一个过程，它需要一个图片和一个参数
I mean, this is some procedure, and it takes a picture and an argument,

576
01:07:19,660 --> 01:07:20,360
但是，什么是图片呢
and what's a picture.

577
01:07:20,360 --> 01:07:23,820
图片本身，你记得，也是一个过程，它需要一个矩形
Well, a picture itself, as you remember, was a procedure, and that took a rectangle.

578
01:07:23,820 --> 01:07:25,820
这个矩形是某种抽象
And a rectangle is some abstraction.

579
01:07:25,820 --> 01:07:33,740
我希望到现在大家可以完全丢掉在这个系统中什么是过程，什么是数据的疑问
And I hope now that by now you're completely lost as to the question of what in the system is procedure and what's data.

580
01:07:33,740 --> 01:07:34,780
大家可以看到，这没有任何区别
You see, there isn't any difference.

581
01:07:35,080 --> 01:07:36,780
真的没有区别
There really isn't.

582
01:07:37,680 --> 01:07:41,840
你可以认为有时候图片是一个过程，有时候是数据
And you might think of a picture sometimes as a procedure and sometimes as data,

583
01:07:41,840 --> 01:07:44,900
但是，你知道，那仅仅是让你感觉舒服一点点的方式
but that's just, sort of, you know, making you feel comfortable.

584
01:07:44,900 --> 01:07:47,640
这有一定道理，也没有道理
It's really both in some sense or neither in some sense.

585
01:07:49,920 --> 01:08:14,200
还有更普遍关于创造一门语言系统结构的观点：通过看工程师设计的过程来创造一门语言，或者创造一些语言的层级
OK, there's a more general point about the structure of the system as creating a language, viewing the engineering design process as one of creating language or rather one of creating a sort of sequence of layers of language.

586
01:08:14,560 --> 01:08:24,900
你看，这里有一个方法论，或者我应该说是神话，姑且叫做”软件工程“
You see, there's this methodology, or maybe I should say mythology, that's, sort of, charitably called software, quote, engineering.

587
01:08:25,040 --> 01:08:28,040
它所说的很好，你来处理你的任务，
All right, and what does it say, it's says well, you go and you figure out your task,

588
01:08:28,040 --> 01:08:30,040
你仅仅解决你要做的事情
and you figure out exactly what you want to do.

589
01:08:30,400 --> 01:08:34,540
一但你弄明白你要做的东西，你发现它变成了三个子问题，
And once you figure out exactly what you want to do, you find out that it breaks out into three sub-tasks,

590
01:08:34,540 --> 01:08:38,940
然后你开始继续做---你开始处理这些子问题，然后你明确的发现它是什么
and you go and you start working on-- and you work on this sub-task, and you figure out exactly what that is.

591
01:08:38,940 --> 01:08:43,040
这些子问题就分裂成三个子问题，你完全把它们处理完.
And you find out that that breaks down into three sub-tasks, and you specify them completely,

592
01:08:43,040 --> 01:08:47,320
然后你继续处理剩下的两个，然后你处理这个子问题，然后处理这个.
and you go and you work on those two, and you work on this sub-one, and you specify that exactly.

593
01:08:47,320 --> 01:08:51,100
然后你最终完成了你要做的，你回到了这里，然后你开始处理你的第二个子问题
And then finally when you're done, you come back way up here, and you work on your second sub-task,

594
01:08:51,100 --> 01:08:53,400
然后把它详细的实现出来
and specify that out and work it out.

595
01:08:53,400 --> 01:08:57,640
然后你结束-- 你完成了这个美丽的大厦
And then you end up with-- you end up at the end with this beautiful edifice.

596
01:08:57,640 --> 01:09:08,240
对，你完成了这个不寻常的树，你把问题分成子问题的时候，然后你把这些子问题分成了更小的子问题，然后把他们又分成了更小的问题.
Right, you end up with a marvelous tree, where you've broken your task into sub-tasks and broken each of these into sub-tasks and broken those into sub-tasks, right.

597
01:09:09,880 --> 01:09:18,640
然后非常准确的定义了这些节点，他们都是构建这个大厦的完美任务.
And each of these nodes is exactly and precisely defined to do the wonderful, beautiful task to make it fit into the whole edifice, right.

598
01:09:18,640 --> 01:09:21,140
这个就是我说的神话
That's this mythology.

599
01:09:21,140 --> 01:09:26,160
只有计算机科学家才可能相信你构建的复杂系统想这个样子
See only a computer scientist could possibly believe that you build a complex system like that, right.

600
01:09:27,860 --> 01:09:32,800
我们用Henderson的例子来做对比,
Contrast that with this Henderson example.

601
01:09:32,800 --> 01:09:34,300
它不是这样工作的
It didn't work like that.

602
01:09:35,060 --> 01:09:39,900
事实是：这里有一个语言层次的序列
What happened was that there was a sequence of layers of language.

603
01:09:40,920 --> 01:09:42,180
它是什么？
What happened?

604
01:09:42,180 --> 01:09:48,760
这里有一层允许我们构建基本图像
There was a layer of a thing that allowed us to build primitive pictures.

605
01:09:51,500 --> 01:09:56,240
这个是基本图像，这就是个语言
There's primitive pictures and that was a language.

606
01:09:56,240 --> 01:09:58,020
我这里不多说了
I didn't say much about it.

607
01:09:58,020 --> 01:10:05,180
我们说一下如何构造George.这是一个语言,这个语言中有向量，线段，点，和它们做存在其中的正方形单元.
We talked about how to construct George, but that was a language where you talked about vectors and line segments and points and where they sat in the unit square.

608
01:10:06,160 --> 01:10:08,740
在那的上面
And then on top of that, right, on top of that--

609
01:10:09,840 --> 01:10:14,280
这个是这个语言的基本图片
so this is the language of primitive pictures.

610
01:10:16,680 --> 01:10:20,560
谈论的图片中的线段在这个正方体单元中,
Right, talking about line segments in particular pictures in the unit square.

611
01:10:21,400 --> 01:10:23,800
在这个上面是整个的语言
On top of that was a whole language.

612
01:10:23,800 --> 01:10:46,500
有一个几何组合的语言，几何位置的语言，它讨论的是像above和beside，right-push，rotate这样的东西
There was a language of geometric combinators, a language of geometric positions, which talks about things like Above and Beside and right-push and Rotate.

613
01:10:48,040 --> 01:10:55,700
这些事情恰巧与我们在这个语言中谈论的事情有关
And those things, sort of, happened with reference to the things that are talked about in this language.

614
01:10:55,700 --> 01:11:15,100
只要我们愿意，我们可以在这个语言之上创造很多语言规则的组合
And then if we like, we saw that above that there was sort of a language of schemes of combination.

615
01:11:20,980 --> 01:11:27,880
比如push,用一个放缩因子重复的做一个事情.
For example, push, which talked about repeatedly doing something over with a scale factor.

616
01:11:28,380 --> 01:11:34,540
我们正在讨论的在那个语言中的东西正是我这里写下来的东西.
And the things that were being discussed in that language were, sort of, the things that happened down here.

617
01:11:36,060 --> 01:11:47,300
在每个层次上都存在已经讨论过的对象，这些对象可以从前一个层级构建出来
So what you have is, at each level, the objects that are being talked about are the things that were erected the previous level.

618
01:11:48,080 --> 01:11:52,060
这个和这个有什么区别呢？
What's the difference between this thing and this thing?

619
01:11:53,100 --> 01:12:05,460
答案是：在这个树里,实际上,每一个节点的每一次分解，都是为了特殊的任务在做设计,
The answer is that over here in the tree, each node, and in fact, each decomposition down here, is being designed to do a specific task,

620
01:12:07,220 --> 01:12:15,120
而在这里,你有在每个层级上的完完全全的语言层面的能力.
whereas in the other scheme, what you have is a full range of linguistic power at each level.

621
01:12:15,820 --> 01:12:22,940
看看这里会发生什么 在任何一个层次，这里都不是建立一个特殊的任务
See what's happening there, at any level, it's not being set up to do a particular task.

622
01:12:22,940 --> 01:12:26,740
它是建立要做事情整个范围
It's being set up to talk about a whole range of things.

623
01:12:27,500 --> 01:12:35,940
结论是：这种设计方法更加健壮，
The consequence of that for design is that something that's designed in that method is likely to be more robust,

624
01:12:36,380 --> 01:12:45,200
健壮，我的意思是,在你的描述中做一些改变，可以提取出相关的变化，
where by robust, I mean that if you go and make some change in your description, it's more likely to be captured by a corresponding change,

625
01:12:45,200 --> 01:12:56,620
使用这种方式，语言可以在下一个层级实现，因为你已经把这个层级的事情做完了
in the way that the language is implemented at the next level up, right, because you've made these levels full.

626
01:12:56,620 --> 01:12:59,660
所以你不需要讨论像beside这样的特殊东西
So you're not talking about a particular thing like Beside.

627
01:12:59,660 --> 01:13:07,020
你创造了如何去表达事情的词汇，所以如果明确的改变你的定义，
You've given yourself a whole vocabulary to express things of that sort, so if you go and change your specifications a little bit,

628
01:13:07,020 --> 01:13:15,020
很可能你的方法论需要随之更改来适应这种变化 因为这种设计不够健壮
it's more likely that your methodology will able to adapt to capture that change, whereas a design like this is not going to be robust,

629
01:13:15,020 --> 01:13:21,800
因为如果我在这里改变一些东西 这将影响它向下的路径中的所有分解出来的东西 (影响它)下面的树
because if I go and change something that's in here, that might affect the entire way that I decomposed everything down, further down the tree.

630
01:13:23,000 --> 01:13:29,740
最大的不同就是分解 语言分层级还是严格的分层
Right, so very big difference in outlook in decomposition, levels of language rather than, sort of, a strict hierarchy.

631
01:13:30,220 --> 01:13:38,740
不仅这个如此 当你有一个多层的语言的时候 你会为不同的层次起不同的词汇
Not only that, but when you have levels of language you've given yourself a different vocabularies for talking about the design at different levels.

632
01:13:38,740 --> 01:13:48,680
所以如果我们回头再看一次George 如果我想改变这个图像George 看 我有完全不同的方式来表述这个变化
So if we go back and look at George one last time, if I wanted to change this picture George, see suddenly I have a whole different ways of describing the change.

633
01:13:48,680 --> 01:13:56,080
比如 我也许想要在基本的设计中修改一些向量的端点
Like for example, I may want to go to the basic primitive design and move the endpoint of some vector.

634
01:13:57,760 --> 01:14:00,760
这个变化在最低的层次
That's a change that I would discuss at the lowest level.

635
01:14:00,760 --> 01:14:02,760
我可以说端点在某个地方
I would say the endpoint is somewhere else.

636
01:14:03,100 --> 01:14:10,940
或许我可以上来说 我想做的下一个事情是：这个重复的元素 我想用其他方式来实现
Or I might come up and say, well the next thing I wanted to do, this little replicated element, I might want to do by something else.

637
01:14:10,940 --> 01:14:13,840
我可能想把一个放缩因子放入那个beside中
I might want to put a scale factor in that Beside.

638
01:14:13,840 --> 01:14:19,340
这个变化我可以在为下一个层次的设计时讨论---组合的层次
That's a change that I would discuss at the next level of design, the level of combinators.

639
01:14:19,340 --> 01:14:30,640
或者我想说 我想改变这个基本的方法 我用这个模式然后做一些递归分解 也许不会 #TBD 后面的不知道怎么翻译
Or I might want to say, I might want to change the basic way that I took this pattern and made some recursive decomposition, maybe not bleeding out toward the corners or something else.

640
01:14:31,160 --> 01:14:34,180
这个会改变我所讨论的最高的层次
That would be a change that I would discuss at the highest level.

641
01:14:34,180 --> 01:14:42,480
因为我是用这种方式构建系统的 我有全部的词汇来用不同的方式实现(我说的)并且有很大的灵活性来让我决定那个更合适
And because I've structured the system to be this way, I have all these vocabularies for talking about change in different ways and a lot of flexibility to decide which one's appropriate.

642
01:14:44,560 --> 01:14:54,380
在软件方法学中的一个很大的不同是--来自于Lisp 全部来自于概念
OK, well that's sort of a big point about the difference in software methodology that comes out from Lisp, and it all comes, again, out of the notion that really,

643
01:14:54,380 --> 01:14:59,620
在设计的过程中 没有那么多的实现的程序作为实现的语言
the design process is not so much implementing programs as implementing languages.

644
01:14:59,620 --> 01:15:04,020
这就是Lisp的力量 好的 谢谢
And that's really the powerful of Lisp. OK, thank you.

