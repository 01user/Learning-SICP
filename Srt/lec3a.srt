1
00:00:00,000 --> 00:00:00,000
它得绘制出一个图像。你给定一个矩形，它就在这个矩形中绘制一些图像
That's got to be picture. It's got to be a thing that you hand it a rectangle, and it draws something in that rectangle.
[MUSIC PLAYING]

2
00:00:00,000 --> 00:00:18,980
[MUSIC PLAYING]

3
00:00:20,940 --> 00:00:23,860
上节课我们讨论了复合数据
PROFESSOR: Well, last time we talked about compound data,

4
00:00:24,700 --> 00:00:29,740
还举了两个例子
and there were two main points to that business.

5
00:00:29,740 --> 00:00:32,480
首先 有一种数据抽象的方法
First of all, there was a methodology of data abstraction,

6
00:00:32,940 --> 00:00:39,100
关键是要将数据的使用
and the point of that was that you could isolate the way that data objects are used

7
00:00:40,060 --> 00:00:41,500
和表示分离开来
from the way that they're represented:

8
00:00:41,550 --> 00:00:45,200
我们可以与George“签订契约”
this idea that there's this guy, George, and you go out make a contract with him;

9
00:00:45,200 --> 00:00:47,480
他负责数据的表示
and it's his business to represent the data objects;

10
00:00:47,480 --> 00:00:49,360
而我们使用它们的时候
and at the moment you are using them,

11
00:00:49,360 --> 00:00:51,360
不需要替George操心如何实现
you don't think about George's problem.

12
00:00:51,980 --> 00:00:58,440
其次 Lisp中有一种特殊的方式把对象连接在一起
And then secondly, there was this particular way that Lisp has of gluing together things

13
00:00:58,940 --> 00:01:00,520
就是构成“序对”
to form objects called pairs,

14
00:01:00,520 --> 00:01:03,540
这是通过CONS CAR CDR实现
and that's done with cons, car and cdr.

15
00:01:03,540 --> 00:01:07,160
CONS CAR CDR 都是独立实现的
And the way that cons, car and cdr are implemented is basically irrelevant.

16
00:01:07,160 --> 00:01:10,020
George的任务就是如何构建这些东西
That's sort of George's problem of how to build those things.

17
00:01:10,020 --> 00:01:11,160
可以将它们实现为基本过程
It could be done as primitives.

18
00:01:11,160 --> 00:01:13,800
也可以利用一些奇怪的过程来实现
It could be done using procedures in some weird way,

19
00:01:13,800 --> 00:01:15,220
但是不用我们操心这些
but we're not going to worry about that.

20
00:01:16,020 --> 00:01:19,660
举个例子 我们来看下有理数算术
And as an example, we looked at rational number arithmetic.

21
00:01:19,660 --> 00:01:21,500
看下向量
We looked at vectors,

22
00:01:21,500 --> 00:01:24,180
我们简单回顾一下向量
and here's just a review of vectors.

23
00:01:24,180 --> 00:01:27,640
这里有个对两个向量求和的运算符
Here's an operation that takes the sum of of two vectors,

24
00:01:27,640 --> 00:01:33,320
我们想要把向量v1和v2相加
so we want to add this vector, v1, and this vector, v2, and we get the sum.

25
00:01:34,460 --> 00:01:40,840
和也是一个向量 它的坐标是两个向量的坐标的和
And the sum is the vector whose coordinates are the sum of the coordinates of the pieces you're adding.

26
00:01:41,280 --> 00:01:45,660
定义(+VECT V1 V2)为
So I can say, to define make-vect, right, to add two vectors

27
00:01:45,660 --> 00:01:51,720
我创建一个向量 其X坐标是两向量X坐标的和
I make a vector, whose x coordinate is the sum of the two x coordinates,

28
00:01:52,100 --> 00:01:54,820
而Y坐标是两向量Y坐标的和
and whose y coordinate is the sum of the two y coordinates.

29
00:01:56,060 --> 00:02:04,100
同样 我们也可以定义一个缩放向量的运算符
And then similarly, we could have an operation that scales vectors,

30
00:02:04,940 --> 00:02:12,660
这里的SCALE过程是用数字S乘以向量V
so here's a procedure scale that multiplies a vector, v, by some number, s.

31
00:02:13,080 --> 00:02:16,140
向量V从这里到这里
So here's v, v goes from there to there

32
00:02:16,320 --> 00:02:20,220
我放大V 得到了与原来同向但更长的向量
and I scale v, and I get a vector in the same direction that's longer.

33
00:02:21,560 --> 00:02:24,260
缩放向量 我需要通过缩放坐标来实现
And again, to scale a vector, I multiply the successive coordinates.

34
00:02:24,260 --> 00:02:30,220
所以我构建了一个向量 它的X坐标是原向量X坐标的S倍
So I make a vector, whose x coordinate is the scale factor times the x coordinate

35
00:02:30,560 --> 00:02:33,540
同时 它的Y坐标是原来向量Y坐标的S倍
and whose y coordinate is the scale factor times the y coordinate.

36
00:02:33,540 --> 00:02:40,280
上述两个运算符的实现依赖于向量的表示
So those are two operations that are implemented using the representation of vectors.

37
00:02:40,280 --> 00:02:45,020
这种向量的表示方法 我们可以用序对来实现
And the representation of vectors, for instance, is something that we can build in terms of pairs.

38
00:02:45,340 --> 00:02:51,280
因此George需要为我们提供MAKE-VECTOR、XCOR和YCOR
So George has gone out and implemented for us make-vector and x coordinate and y coordinate,

39
00:02:53,020 --> 00:02:57,980
他可以使用CONS CAR CDR来实现
and this could be done, for instance, using cons,car and cdr;

40
00:02:58,880 --> 00:03:06,780
但是注意 我这里用了一个略微不同的方式
and notice here, I wrote this in a slightly different way.

41
00:03:08,040 --> 00:03:11,000
这个过程我们之前看过
The procedures we've seen before, I've said something like

42
00:03:11,140 --> 00:03:16,220
(MAKE-VECTOR X Y)也就是(CONS X Y)
say, make-vector of x and y: cons of x and y.

43
00:03:16,220 --> 00:03:17,980
这里我简单定义MAKE-VECTOR为CONS
And here I just wrote make-vector cons.

44
00:03:17,980 --> 00:03:20,480
这就与之前有些不同了
And that means something slightly different.

45
00:03:20,480 --> 00:03:26,220
之前我们我们把MAKE-VECTOR定义为需要两个参数的过程
Previously we'd say, define make-vector to be a procedure that takes two arguments, x and y,

46
00:03:26,220 --> 00:03:28,040
效果是(CONS X Y)
and does cons of x and y.

47
00:03:28,040 --> 00:03:34,120
这里 我就把MAKE-VECTOR定义为CONS
And here I am saying define make-vector to be the thing that cons is,

48
00:03:35,180 --> 00:03:39,660
这跟我们写的其它代码的方式差不多
and that's almost the same as the other way we've been writing things.

49
00:03:39,660 --> 00:03:46,580
大家要习惯于“过程也是可以被命名的对象”这种想法
And I just want you to get used to the idea that procedures can be objects, and that you can name them.

50
00:03:48,700 --> 00:03:51,800
这些就是向量的表示方法了
OK, well there's vector representation, and again,

51
00:03:51,800 --> 00:03:55,680
如果仅仅是那样 那就太无趣了
if that was all there was to it,this would all be pretty boring.

52
00:03:57,020 --> 00:04:02,160
要记住 重点是通过使用CONS 我们不仅可以将数字组合成序对
And the point is, remember, that you can use cons to glue together not just numbers to form pairs,

53
00:04:02,160 --> 00:04:04,160
也可以组合任何东西
but to glue together arbitrary things.

54
00:04:05,200 --> 00:04:11,600
例如 如果我想表示一个线段
So for instance, if we'd like to represent a line segment,

55
00:04:11,600 --> 00:04:15,640
可以说 线段来自一个特定的向量
say the line segment that goes from a certain vector:

56
00:04:16,060 --> 00:04:28,300
这个线段从向量(2,3)到向量(5,1)
say, the segment from the vector 2,3 to the point represented by the vector 5,1.

57
00:04:28,300 --> 00:04:31,820
如果我们想表示这条线段
If we want to represent that line segment,

58
00:04:33,260 --> 00:04:36,200
那么我们可以构建一个序对的序对
then we can build that as a pair of pairs.

59
00:04:40,720 --> 00:04:42,940
这样我们就可以表示一条线段了
So again, we can represent line segments.

60
00:04:42,940 --> 00:04:47,340
我们可以编写一个使用CONS构造线段的构造函数
We can make a constructor that makes a segment using cons,

61
00:04:47,980 --> 00:04:51,600
以及 析取出线段起点、终点的选择函数
selects out the start of a segment, selects out the end point of the segment;

62
00:04:55,240 --> 00:04:59,760
实际上 如果我们剥开抽象层一探究竟
and then if we actually look at that, if we peel away the abstraction layers,

63
00:04:59,880 --> 00:05:02,100
就会发现线段不过是 序对组成的序对
and see what's that really is a pair of pairs,

64
00:05:04,660 --> 00:05:06,220
它还是一个序对
we'd say well that's a pair.

65
00:05:06,220 --> 00:05:08,220
这就是一个线段
Here's the segment.

66
00:05:10,000 --> 00:05:16,720
它的CAR部分是个序对 CDR部分也是个序对
It's car, right, it's car pointer is a pair, and it's cdr is also a pair,

67
00:05:18,320 --> 00:05:25,540
它的CAR部分是由2和3构成的序对
and then what the car is--here's the car, that itself is a pair of 2 and 3.

68
00:05:26,020 --> 00:05:28,080
CDR部分则由5和1构成的序对（译注：口误）
And similarly the cdr is a pair of 2 and 3.

69
00:05:28,160 --> 00:05:29,240
我再强调一下
And let me remind you again

70
00:05:29,320 --> 00:05:33,460
好多人认为如果我箭头向下画的话
that a lot of people have some idea that if I'd taken this arrow and somehow

71
00:05:33,800 --> 00:05:36,900
会有其它的含意
written it to point down, that would mean something else.

72
00:05:36,980 --> 00:05:38,280
这是不对的
That's irrelevant.

73
00:05:38,580 --> 00:05:43,900
我们关心的是对象间如何连接 与水平或竖直都无关紧要
It's only how these are connected and not whether this arrow happens to go vertically or horizontally.

74
00:05:47,480 --> 00:05:52,180
还要提醒一下 序对是具有闭包性质的
And again just to remind you, there was this notion of closure.

75
00:05:52,940 --> 00:06:05,620
闭包性质使我们可以构建更复杂的东西
See, closure was the thing that allowed us to start building up complexity, that didn't trap us in pairs.

76
00:06:06,640 --> 00:06:15,240
换句话说 我们用CONS来构建序对
Particularly what I mean is the things that we make, having combined things using cons to get a pair,

77
00:06:16,440 --> 00:06:22,640
构造出来的序对也可以使用CONS来构造更复杂的序对
those things themselves can be combined using cons to make more complicated things.

78
00:06:23,280 --> 00:06:31,980
数学家会说 Lisp中的数据关于CONS运算封闭
Or as a mathematician might say, the set of data objects in Lisp is closed under the operation of forming pairs.

79
00:06:33,820 --> 00:06:36,340
这就允许我们做更加复杂的构造
That's the thing that allows us to build complexity.

80
00:06:36,340 --> 00:06:38,040
这个很显然 但是要记住
And that seems obvious, but remember

81
00:06:39,060 --> 00:06:42,460
人们使用的编程语言大多不是封闭的
a lot of the things in the computer languages that people use are not closed.

82
00:06:42,460 --> 00:06:48,060
举例来说 Basic和Fortran中的数组就不具有闭包性质
So for example, forming arrays in Basic and Fortran is not a closed operation,

83
00:06:48,080 --> 00:06:51,940
因为 虽然你可以建立数字、字符或字符串等的数组
because you can make an array of numbers or character strings or something,

84
00:06:52,040 --> 00:06:54,180
但是你不能创建数组的数组
but you can't make  an array of arrays.

85
00:06:54,640 --> 00:06:56,680
在考察某种组合的方法时
And when you look at means of combination

86
00:06:57,600 --> 00:07:02,780
你应该关心它是否封闭
you should be should be asking yourself whether things are closed under that means of combination.

87
00:07:05,060 --> 00:07:08,260
在任何情况下 因为我们可以构造序对的序对
Well in any case, because we can form pairs of pairs,

88
00:07:08,860 --> 00:07:12,780
我们就可以将数据组合成各种各样的序对
we can start using pairs to glue things together in all sorts of different ways.

89
00:07:14,020 --> 00:07:18,260
比如我想要组合四个数 —— 1 2 3 4
So for instance if I'd like to glue together the four things, 1, 2, 3 and 4,

90
00:07:18,260 --> 00:07:19,820
我有很多方法
there are a lot of ways I can do it.

91
00:07:20,740 --> 00:07:26,120
比如 像构造线段那样 我可以构造一个序对
I could, for example, like we did with that line segment, i could make a pair

92
00:07:29,020 --> 00:07:36,880
它是((1 2) (3 4)) 对吧？
that had a 1 and a 2 and a 3 and a 4, right?

93
00:07:36,880 --> 00:07:40,060
如果我喜欢 我可以像这样做
Or if I liked, I could do something like this.

94
00:07:40,060 --> 00:07:45,520
我构造一个序对 它的CAR部分也是序对
I could make a pair, whose first thing is a pair,

95
00:07:46,440 --> 00:07:53,200
它的CAR部分为1 而CDR部分为由2、3构成的序对
whose car is 1, and his cdr is itself a pair that has the 2 and the 3

96
00:07:53,260 --> 00:07:55,080
最后 我把4放在这里
and then I could put the 4 up here.

97
00:07:56,920 --> 00:08:02,160
看到了吧 组合对象的方式有很多种
So you see, there are a lot of different ways that I can start using pairs to glue things together,

98
00:08:02,160 --> 00:08:07,740
所以有必要建立一些方便的方式
and so it'll be a good idea to establish some kind of conventions,right,

99
00:08:07,740 --> 00:08:11,580
这样我们就可以用一些便捷的方式处理数据
that allow us to deal with this thing in some conventional way,

100
00:08:11,580 --> 00:08:14,000
这样我们就不用总是做一些选择
so we're not constantly making an ad hoc choice.

101
00:08:15,940 --> 00:08:19,040
Lisp里面有专门的表示法
And Lisp has a particular convention

102
00:08:20,740 --> 00:08:25,820
用于将序列表示为序对的链
for representing a sequence of things as, essentially, a chain of pairs,

103
00:08:26,780 --> 00:08:28,180
这个称为“表”
and that's called a List.

104
00:08:34,720 --> 00:08:40,500
表的本质上就是序列的简便表示
And what a list is is essentially just a convention for representing a sequence.

105
00:08:40,700 --> 00:08:47,380
我可以使用序对的序列来表示序列 1 2 3 4
I would represent the sequence 1, 2, 3 and 4 by a sequence of pairs.

106
00:08:48,260 --> 00:08:54,680
我把1放在这里 它的CDR指向另一个序对
I'd put 1 here and then the cdr of this would point to another pair

107
00:08:59,200 --> 00:09:01,400
这个序对的CAR部分是序列的下一个数
whose car was the next thing in the sequence,

108
00:09:01,520 --> 00:09:03,420
并且它的CDR指向了另一个序对
and the cdr would point to another pair

109
00:09:05,440 --> 00:09:07,300
它的CAR部分是序列的再下一个数
whose car was the next thing in the sequence--

110
00:09:07,360 --> 00:09:08,440
这个是3
so there's 3--

111
00:09:08,440 --> 00:09:09,740
以此类推
and then another one.

112
00:09:09,740 --> 00:09:13,220
所以 对于序列中的每一个元素都是一个序对
So for each item in the sequence, I'll get a pair.

113
00:09:15,820 --> 00:09:18,320
现在这个序列中没有其它元素了
And now there are no more, so I put a special marker

114
00:09:20,720 --> 00:09:22,740
我用一个特殊的标记 表示列表中没有元素了
that means there's nothing more in the List.

115
00:09:24,140 --> 00:09:34,640
好 这是将序列中的元素组合起来的简便方式
OK, so that's a conventional way to glue things together if you want to represent a sequence, right.

116
00:09:34,640 --> 00:09:37,980
它其实就是一大堆序对
And what it is is a bunch of pairs,

117
00:09:39,400 --> 00:09:44,800
每个序对中的CAR部分就是我们想要组合到一起的元素
the successive cars of each pair are the items that you want to glue together,

118
00:09:46,000 --> 00:09:48,460
CDR部分指向下一个序对
and the cdr pointer points to the next pair.

119
00:09:50,020 --> 00:09:56,040
现在 如果我想要构造它 我需要向Lisp中输入
Now if I actually wanted to construct that, what I would type into Lisp is this:

120
00:09:56,620 --> 00:09:58,760
我会像这样来构造
I'd actually construct that as saying, well this thing is

121
00:09:59,220 --> 00:10:15,280
(CONS 1 (CONS 2 (CONS 3 (CONS 4 NIL))))
the cons of 1 onto the cons of 2 onto the cons of 3 onto
the cons of 4 onto, well, this thing nil.

122
00:10:15,280 --> 00:10:20,000
NIL是表结束的记号
And what nil is is a name for the end of List marker.

123
00:10:20,800 --> 00:10:23,240
它是一个特殊的名字 意味着表结束了
It's a special name, which means this is the end of the List.

124
00:10:26,240 --> 00:10:30,260
这就是我如何构造表
OK, so that's how I would actually construct that.

125
00:10:37,340 --> 00:10:45,180
#TBD 当然 构造列表的时候总是写cons非常费力
Of course, it's a terrible drag to constantly have to write something like the cons of 1 onto the cons of 2 onto the cons of 3, whenever you want to make this thing.

126
00:10:45,180 --> 00:10:50,100
所以表有一个叫做LIST的操作
So List has an operation that's called List,

127
00:10:53,700 --> 00:10:57,720
LIST其实是这种嵌套CONS的缩写
and List is just an abbreviation for this nest of conses.

128
00:10:58,960 --> 00:11:06,320
所以我可以用(LIST 1 2 3 4)来构造表
So I could say, I could construct that by saying that is the List of 1, 2, 3 and 4.

129
00:11:07,780 --> 00:11:11,740
这些都是一个语法糖
And all this is is another way, a piece of syntactic sugar,

130
00:11:11,940 --> 00:11:14,760
用来简便地书写嵌套的CONS
a more convenient way for writing that chain of conses--

131
00:11:14,760 --> 00:11:17,840
(CONS (CONS (CONS (CONS NIL))))
cons of cons of cons of cons of cons of cons onto nil.

132
00:11:18,480 --> 00:11:39,780
举例来说 我将表(1 2 3 4)叫做1-TO-4
So for example, I could build this thing and say, I'll define 1-TO-4 to be the List of 1, 2, 3 and 4.

133
00:11:47,960 --> 00:11:53,020
注意使用这种简便写法的后果
OK, well notice some of the consequences of using this convention.

134
00:11:53,800 --> 00:11:56,920
首先 如果我有这个表(1 2 3 4)
First of all if I have this List, this 1, 2, 3 and 4,

135
00:11:57,360 --> 00:12:02,640
表的CAR把部分就是这个表的第一个元素 对吧？
the car of the whole thing is the first element in the List, right.

136
00:12:04,060 --> 00:12:05,280
那么 如何获得元素2呢？
How do I get 2?

137
00:12:05,280 --> 00:12:23,940
2应该是1-TO-4的CDR部分的CAR部分
Well, 2 would be the car of the cdr of this thing 1-TO-4, it would be 2, right.

138
00:12:23,980 --> 00:12:29,480
它的CDR是这个
I take this thing, I take the cdr of it, which is this much,

139
00:12:29,820 --> 00:12:31,680
而它的CAR部分是2
and the car of that is 2,

140
00:12:32,580 --> 00:12:47,420
同理 1-TO-4的CDR的CDR的CAR部分
and then similarly, the car of the cdr of the cdr of 1-TO-4, cdr, cdr, car--

141
00:12:47,420 --> 00:12:51,360
是3 以此类推
would give me 3, and so on.

142
00:12:52,680 --> 00:12:55,840
我们来看下屏幕
Let's take a look at that on the computer screen for a second.

143
00:12:57,500 --> 00:13:11,180
我定义一个列表(1 2 3 4)叫它1-TO-4
I could come up to List, and I could type define 1-TO-4 to be the List of 1, 2, 3 and 4, right.

144
00:13:13,780 --> 00:13:21,280
我这样写 计算机返回定义完成 这个就是1-TO-4的定义
And I'll tell that to List, and it says, fine, that's the definition of 1-TO-4.

145
00:13:22,300 --> 00:13:36,740
我问 比如 1-TO-4的cdr的cdr的car
And I could say, for instance, what's the car of the cdr of the cdr of 1-TO-4, close paren, close paren.

146
00:13:38,340 --> 00:13:42,420
嗯 它是3
Right, so the car of the cdr of the cdr would be 3.

147
00:13:44,080 --> 00:13:50,080
或者我问 1-TO-4是什么
Right, or I could say, what's 1-TO-4 itself.

148
00:13:51,260 --> 00:13:57,220
Lisp输出的是用括号包围的 (1 2 3 4)
And you see what Lisp typed out is 1, 2, 3, 4, enclosed in parentheses,

149
00:13:57,220 --> 00:14:02,120
用括号将表中的元素包围起来的这种记号
and this notation, typing the elements of the List enclosed in parentheses

150
00:14:02,120 --> 00:14:08,900
通常用来用来打印用表示序列的序对链
is Lisp's conventional way for printing back this chain of pairs that represents a sequence.

151
00:14:08,900 --> 00:14:17,140
又比如 我问1-TO-4的CDR部分是什么
So for example, if I said, what's the cdr of 1-TO-4,

152
00:14:19,300 --> 00:14:21,120
结果是表的剩余部分
that's going to be the rest of the List.

153
00:14:21,320 --> 00:14:26,960
这是原表首元素所指向的序对 新序列从2开始
That's the thing pointed to by the first pair, which is, again, a sequence that starts off with 2.

154
00:14:28,520 --> 00:14:37,746
比如 1-TO-4的CDR的CDR部分是什么
Or for example, I go off and say, what's the cdr of the cdr of 1-TO-4;

155
00:14:43,240 --> 00:14:44,680
返回(3 4)
then that's 3,4.

156
00:14:44,820 --> 00:14:59,660
或者 1-TO-4的CDR的CDR的CDR的CDR部分是什么
Or if I say, what's the cdr of the cdr of the cdr of the cdr of 1-TO-4,

157
00:15:04,740 --> 00:15:10,460
我们看一下表的尾指针 Lisp返回()
and I'm down there looking at the end of List pointer itself, and Lisp prints that as just open paren, close paren.

158
00:15:10,960 --> 00:15:13,480
你们可以认为这是一个空表
You can think of that as a List with nothing in there.

159
00:15:14,120 --> 00:15:21,386
我求取 1-TO-4的CDR的CDR的CDR部分
All right, see at the end what I did there was I looked at the cdr of the cdr of the cdr of 1-TO-4,

160
00:15:21,426 --> 00:15:25,200
这就只剩下表尾指针本身
and I'm just left with the end of List pointer itself.

161
00:15:25,200 --> 00:15:27,200
它的输出是()
And that gets printed as open close.

162
00:15:34,140 --> 00:15:39,986
好了 这是处理表的一种常见方式
All right, well that's a conventional way you can see for working down a List

163
00:15:41,506 --> 00:15:43,440
也就是不断地取CDR部分
by taking successive cdrs of things.

164
00:15:43,440 --> 00:15:45,000
这个叫做表的CDRING
It's called cdring down a List.

165
00:15:46,640 --> 00:15:49,780
当然手写这些CDR非常费劲
And of course it's pretty much of a drag to type all those cdrs by hand.

166
00:15:49,780 --> 00:15:52,240
我们没必要这么做 我们编写程序来这么做
You don't do that. You write procedures that do that.

167
00:15:52,960 --> 00:15:59,100
事实上 Lisp中非常普遍的事情是写一些过程
And in fact one very, very common thing to do in Lisp is to write procedures that,

168
00:15:59,853 --> 00:16:06,540
表中所有元素进行某种操作 得到的是由结果构成的表
sort of, take a List of things and do something to every element in List, and return you a List of the results.

169
00:16:07,426 --> 00:16:11,920
比如 我写一个SCALE-LIST的过程
So what I mean for example, is I might write a procedure called Scale-List,

170
00:16:16,800 --> 00:16:25,240
我要用SCALE-List将表1-TO-4放大10倍
and Scale-List I might say I want to scale by 10 the entire List 1-TO-4,

171
00:16:26,666 --> 00:16:35,320
那么它应该返回表(10 20 30 40)
and that would return for me the List 10, 20, 30, 40.

172
00:16:38,253 --> 00:16:40,253
没错 它返回一个表
Right, it returns List, and

173
00:16:44,493 --> 00:16:49,300
我们可以猜想到这当中采用了某种递归策略
well you can see that there's going to be some kind of recursive strategy for doing it.

174
00:16:49,300 --> 00:16:51,300
我应该如何编写这个过程呢？
How would I actually write that procedure?

175
00:16:52,520 --> 00:16:59,800
如果要构建一个每个元素都乘以10的列表
The idea would be, well if you'd like to build up a List where you've multiplied every element by 10,

176
00:17:00,440 --> 00:17:04,840
需要做的是—假设已经得到了结果表的剩余元素
what you'd say is well you imagine that you'd taken the rest of the List--

177
00:17:05,866 --> 00:17:08,420
也就是表的CDR部分
right, the thing represented by the cdr of the List,

178
00:17:08,420 --> 00:17:14,160
这个子表中的每个元素都是原来元素乘以10
and suppose I'd already built a List where each of these was multiplied by 10--

179
00:17:16,060 --> 00:17:19,680
这是SCALE-LIST对表CDR部分作用的结果
that would be Scale-List of the cdr of the List.

180
00:17:20,120 --> 00:17:23,826
我需要做的 就只有用表的CAR部分乘以10
And then all I have to do is multiply the car of the List by 10,

181
00:17:24,893 --> 00:17:27,240
然后用CONS将它和剩余部分连接起来 并返回这个列表
and then cons that onto the rest, and I'll get a List.

182
00:17:29,026 --> 00:17:33,093
类似地 为了缩放子表 我得先缩放子表的CDR部分
Right and then similarly, to have scaled the cdr of the List, I'll scale the cdr of that

183
00:17:33,306 --> 00:17:36,200
并将其与2*10连接起来
cons onto that 2 multiplied by 10.

184
00:17:36,420 --> 00:17:41,160
最终 当我处理到表尾时 这里就只剩表尾指针了
And finally when I get all the way down to the end, and I only have this end of List pointer.

185
00:17:41,720 --> 00:17:45,280
它叫做NIL 我就直接返回表尾指针
All right, this thing whose name is nil-- well I just returned an end of List pointer.

186
00:17:45,540 --> 00:17:47,680
所以这就是这个过程的递归策略
So there's a recursive strategy for doing that.

187
00:17:47,680 --> 00:17:50,520
这个过程就是这样
Here's the actual procedure that does that.

188
00:17:50,960 --> 00:17:55,040
这个例子就是对表做CDRING操作的通用策略
Right, this is an example of the general strategy of cdr-ing down a List and

189
00:17:55,666 --> 00:17:58,240
也就是所谓的“通过CONS组合结果”
so called cons-ing up the result, right.

190
00:17:58,240 --> 00:18:06,040
那么 对表L缩放S倍 我该如何做呢？
So to Scale a List l by some scale factor s, what do I do?

191
00:18:06,040 --> 00:18:10,400
首先得做判断 Lisp中有个叫NULL?的谓词
Well there's a test, and Lisp has the predicate called null.

192
00:18:10,400 --> 00:18:13,226
NULL?判断对象是否为表尾
Null means is this thing the end of List pointer,

193
00:18:13,906 --> 00:18:17,160
或者说 对象是否为空表
or another way to think of that is are there any elements in this List, right.

194
00:18:18,173 --> 00:18:23,000
任何情况下 当我处理到表尾时 我就将其返回
But in any case if I'm looking at the end of List pointer, then I just return the end of List pointer.

195
00:18:23,653 --> 00:18:24,600
简单地返回NIL
I just return nil,

196
00:18:24,946 --> 00:18:35,140
其他情况我用cons把列表中的第一个元素个我还需要处理的子列表连接起来 #TBD
otherwise I cons together the result of doing what I'm going to do to the first element in the List,

197
00:18:35,540 --> 00:18:39,293
就是说 取L的CAR部分 然后用它乘以S
namely taking the car of l and multiplying it by s,

198
00:18:40,360 --> 00:18:46,340
然后用CONS递归连接正在缩放的剩余的表
and I cons that onto recursively scaling the rest of the List.

199
00:18:49,986 --> 00:18:52,186
再说一次 总体的思想是
OK, so again, the general idea is that you

200
00:18:52,226 --> 00:18:56,093
用CDR递归地处理表中的剩余元素
you recursively do something to the rest of the List, to the cdr of the List,

201
00:18:56,480 --> 00:19:01,160
#TBD
and then you cons that onto actually doing something to the first element of the List.

202
00:19:01,160 --> 00:19:05,186
当你处理到结尾的时候 返回表尾指针
When you get down to the end here, you return the end of List pointer,

203
00:19:07,346 --> 00:19:11,360
这是处理表的基本模式
and that's a general pattern for doing something to a list.

204
00:19:16,140 --> 00:19:19,520
现在 你们应该清楚知道这样一个事实
Well of course you should know by now that the very fact

205
00:19:19,533 --> 00:19:22,620
也就是我不必额外为这种基本模式额外编写过程
that there's a general pattern there means I shouldn't be writing this procedure at all.

206
00:19:22,620 --> 00:19:24,900
我要做的事情就是写一个过程
What I should do is write a procedure

207
00:19:24,900 --> 00:19:26,320
这是这个基本模式
that's the general pattern itself

208
00:19:26,800 --> 00:19:30,306
对表中的元素执行操作 并以表的形式返回结果
that says, do something to everything in the List and define this thing in terms of that.

209
00:19:30,680 --> 00:19:32,306
好了 我们定义一些高阶过程
Right, make some higher order procedure,

210
00:19:32,320 --> 00:19:35,180
我们定义一个叫MAP的高阶过程 来完成这些操作
and here's the higher order procedure that does that. It's called MAP,

211
00:19:36,733 --> 00:19:43,170
MAP以表L和过程P为参数
and what MAP does is it takes a List, takes a List l, and it takes a procedure p,

212
00:19:44,920 --> 00:19:51,080
并返回对表L中每个元素应用过程P后得到的新表
and it returns the List of the elements gotten by applying p to each successive element in the List.

213
00:19:51,813 --> 00:19:55,400
从(P E1) (P E2) 到(P En)
All right, so p of e1, p of e2, p of en.

214
00:19:55,640 --> 00:20:01,540
#TBD
Right, so I think of taking this List and transforming it by applying p to each element.

215
00:20:02,520 --> 00:20:07,080
你们看到的这些过程正是我提到的通用策略
And you see all this procedure is is exactly the general strategy I said.

216
00:20:07,080 --> 00:20:09,080
我们用它写乘以10的过程
Instead of multiply by 10, it's do the procedure.

217
00:20:09,080 --> 00:20:11,640
如果表是空的 则返回NIL
If the List is empty, return nil.

218
00:20:11,860 --> 00:20:16,600
否则 对表的首元素应用P
Otherwise, apply p to the first element of the List.

219
00:20:17,146 --> 00:20:18,746
将P应用于L的CAR部分
Right, apply p to car of l,

220
00:20:19,306 --> 00:20:25,400
然后连接它和将P应用于表CDR部分中的剩余元素得到的子表连接起来
and cons that onto the result of applying p to everything in the cdr of the List,

221
00:20:25,613 --> 00:20:28,840
这就是一个通用过程——MAP
so that's a general procedure called MAP.

222
00:20:29,866 --> 00:20:39,040
我们可以用MAP来定义SCALE-LIST
And I could define Scale-List in terms of MAP.

223
00:20:39,040 --> 00:20:41,040
我给你们展示一下
Let me show you that first.

224
00:20:43,460 --> 00:20:52,500
SCALE-LIST就是对表MAP一个特定的过程
But I could say Scale-List is another way to define it is just MAP along the List by the procedure,

225
00:20:52,500 --> 00:20:55,540
这个过程需要一个参数 返回给定参数乘以S的结果
which takes an item and multiplies it by s.

226
00:20:58,960 --> 00:21:01,906
这才是缩放表的关键点
Right, so this is really the way I should think about scaling the List,

227
00:21:02,120 --> 00:21:07,400
#TBD
build that actual recursion into the general strategy, not to every particular procedure I write.

228
00:21:07,400 --> 00:21:11,280
当然 这样做的意义之一是 我们可以发现它们的共性
And of course, one of the values of doing this is that you start to see commonality.

229
00:21:12,160 --> 00:21:15,020
我们正在掌握使用通用模式
Right, again you're capturing general patterns of usage.

230
00:21:15,960 --> 00:21:31,180
比如 (MAP SQUARE 1-TO-4) 返回(1 4 9 16)
For instance, if I said MAP, the square procedure, down this List 1-TO-4, then I'd end up with 1, 4, 9 and 16.

231
00:21:32,480 --> 00:21:37,173
对这个表做映射
Right, or if I said MAP down this List,

232
00:21:37,573 --> 00:21:46,320
用(LAMBDA (X) (+ X 10))映射表1-TO-4
lambda of x plus x 10, if I MAP that down 1-TO-4,

233
00:21:49,680 --> 00:21:52,866
我让表的每个元素都加了10
then I'd get the List where everything had 10 added to it:

234
00:21:53,346 --> 00:21:58,173
也就是得到了(11 12  13 14)
right, so I'd get 11,12, 13, 14.

235
00:22:00,560 --> 00:22:05,760
我们看到对表中每个元素做操作是一种非常普遍的想法
And you can see that's going to be a very, very common idea: doing something to every element in the List.

236
00:22:08,660 --> 00:22:12,220
而大家需要思考如何编写MAP的迭代版本
One thing you might think about is writing MAP in an iterative style.

237
00:22:12,220 --> 00:22:16,040
我碰巧写的是一个递归版本
The one I wrote happens to evolve a recursive process,

238
00:22:16,360 --> 00:22:19,100
但是我们也可以很容易地把它改成迭代过程
but we could just as easily have made one that evolves an iterative process.

239
00:22:19,100 --> 00:22:23,160
有趣的是 一旦你开始用MAP来思考
But see the interesting thing about it is that once you start thinking in terms of MAP--

240
00:22:24,020 --> 00:22:29,000
比如 一旦把缩放看作是一种MAP 就不用关心是迭代还是递归实现
see, once you say scale is just MAP, you stop thinking about whether it's iterative or recursive,

241
00:22:29,000 --> 00:22:31,820
你可以说 有这样一种策略 给定这个表 #TBD
and you just say, well there's this aggregate, there's this List,

242
00:22:32,220 --> 00:22:34,520
我要做的是转化表中的每个元素
and what I do is transform every item in the List,

243
00:22:34,560 --> 00:22:38,360
而不去考虑特别的控制流程或顺序
and I stop thinking about the particular control structure in order.

244
00:22:38,880 --> 00:22:41,093
这是个非常非常重要的想法
That's a very, very important idea,

245
00:22:42,360 --> 00:22:46,480
我猜这个想法来自APL语言
and it, I guess it really comes out of APL.

246
00:22:46,480 --> 00:22:49,100
它是APL中非常重要的思想
It's, sort of, the really important idea in APL

247
00:22:49,120 --> 00:22:51,133
即不要去考虑控制结构
that you stop thinking about control structures,

248
00:22:51,413 --> 00:22:53,920
而是关注于策略操作
and you start thinking about operations on aggregates,

249
00:22:55,013 --> 00:23:00,013
在课程一半的时候 我们将讨论叫做流 #TBD
and then about halfway through this course,we'll see when we talk about something called stream processing,

250
00:23:00,266 --> 00:23:02,640
看看用流来处理又会是怎样
how that view of the world really comes into its glory.

251
00:23:02,640 --> 00:23:05,300
这是一种很聪明的思想
This is just us a, sort of, cute idea.

252
00:23:05,300 --> 00:23:08,700
我们可以在以后看到更多应用
But we'll see much more applications of that later on.

253
00:23:09,360 --> 00:23:16,840
还有一些非常有用也非常像MAP的过程
Well let me mention that there's something that's very similar to MAP that's also a useful idea, and that's--

254
00:23:17,560 --> 00:23:22,546
MAP是将某个过程应用于表中每个元素
see, MAP says I take a List, I apply something to each item,

255
00:23:22,986 --> 00:23:25,620
并返回相应结果构成的表
and I return a List of the successive values.

256
00:23:25,980 --> 00:23:28,693
还有一种与此非常非常相似的操作
There's another thing I might do, which is very, very similar,

257
00:23:29,320 --> 00:23:35,866
也就是给定一个列表和操作 依次将其应用于表中每个元素
which is take a List and some action you want to do and then do it to each item in the List in sequence.

258
00:23:36,293 --> 00:23:39,400
而不会建立由结果构成的表 只是为了完成操作
Don't make a List of the values, just do this particular action,

259
00:23:40,026 --> 00:23:45,100
这个过程非常像MAP
and that's something that's very much like MAP.

260
00:23:45,100 --> 00:23:46,746
这叫做FOR-EACH
It's called for-each,

261
00:23:46,746 --> 00:23:49,480
它接受一个过程和一个表
and for-each takes a procedure and a List,
这叫做FOR-EACH
It's called for-each,

262
00:23:49,480 --> 00:23:49,626
这叫做FOR-EACH
It's called for-each,

263
00:23:49,626 --> 00:23:53,866
它实际上是对表中每个元素执行此操作
and what it's going to do is do something to every item in the List.
这叫做FOR-EACH
It's called for-each,

264
00:23:53,866 --> 00:23:54,380
这叫做FOR-EACH
It's called for-each,

265
00:23:55,160 --> 00:23:58,533
通常是这样 如果表非空
So basically what it does: it says if the List is not empty,

266
00:23:59,746 --> 00:24:01,120
也就是不是空表
if the List is not null,

267
00:24:01,906 --> 00:24:06,253
然后对表中其余元素做同样的事情
and then I do this thing to the rest of the List.
我讲这个过程应用于表的第一个元素
then what I do is, I apply my procedure to the first item in the List,

268
00:24:12,300 --> 00:24:15,340
我讲FOR-EACH也应用于表的CDR部分
I apply for-each to the cdr of the List.

269
00:24:15,880 --> 00:24:18,733
我对表的首元素进行处理 然后对表的其余元素进行处理
All right, so I do it to the first of the List, do it to the rest of the List,

270
00:24:19,320 --> 00:24:23,920
当然 以此类推 递归地调用 又会对表其余元素的其余部分进行处理
and of course, when I call it recursively, that's going to do it to the rest of the rest of the List and so on.

271
00:24:23,920 --> 00:24:28,120
最终 过程结束时 我应该告知系统
And finally, when I get done, I have to just do something to say I'm done,

272
00:24:28,160 --> 00:24:32,400
所以就返回“DONE” 所以这非常像MAP
so we'll return the message "done." So that's very, very similar to MAP.

273
00:24:32,800 --> 00:24:35,120
它们之间只是返回值不同
It's mostly different in what it returns.

274
00:24:35,480 --> 00:24:39,906
比如说 如果我有一个可以在屏幕上打印对象的过程
And so for example, if I had some procedure that printed things on the screen,

275
00:24:40,560 --> 00:24:45,813
如果我想打印表中的所有元素 可以调用(FOR-EACH PRINT LIST)
if I wanted to print everything in the List, I could say for-each, print this List.

276
00:24:46,780 --> 00:24:51,333
如果我有一系列图表构成的表 想把它们输出在屏幕上
Or if I had a List of figures, and I wanted to draw them on the display,

277
00:24:51,626 --> 00:24:54,860
我可以对这个调用(FOR-EACH DISPLAY FIGURES)
I could say for-each, display on the screen this figure.

278
00:24:58,186 --> 00:24:59,320
有问题么？
Take questions.

279
00:25:00,620 --> 00:25:04,266
学生：如果不是明确地指出 #TBD
AUDIENCE: Does it create a new copy with something done to it,

280
00:25:04,306 --> 00:25:07,540
Lisp会创建对象的副本 是这样么？
unless you explicitly tell it to do that? Is that correct?

281
00:25:07,540 --> 00:25:09,180
教授：对
PROFESSOR: Right. Ah.

282
00:25:09,933 --> 00:25:10,940
就是这样
Yeah, that's right.

283
00:25:10,940 --> 00:25:15,140
FOR-EACH不创建新列表 它只是对列表的每一个元素进行处理
For-each does not create a List. It just sort of does something.

284
00:25:15,140 --> 00:25:17,293
所以如果你有一堆事情等着做
So if you have a bunch of things you want to do

285
00:25:18,026 --> 00:25:21,560
并且你并不关心这些值 比如打印 绘图
and you're not worried about values like printing something, or drawing something on the screen,

286
00:25:21,893 --> 00:25:24,600
或者在终端中响铃等等
or ringing the bell on the terminal,or for something,

287
00:25:24,600 --> 00:25:27,640
FOR-EACH对表中每个元素做这些事
you can say for-each, you know, do this for-each of those things in the List,

288
00:25:28,213 --> 00:25:32,420
而MAP其实构建了一个新集合 这个集合也许是你想要用的
whereas MAP actually builds you this new collection of values that you might want to use.

289
00:25:32,420 --> 00:25:34,160
这就是它们之间的微妙关系
It's just a subtle difference between them.

290
00:25:34,160 --> 00:25:36,306
学生：你可以用FOR-EACH替代MAP么？
AUDIENCE: Could you write MAP using for-each,

291
00:25:36,320 --> 00:25:40,160
#TBD
so that you did some sort of cons or something to build the List back up?

292
00:25:40,180 --> 00:25:44,460
教授：某种程度上 我也许可以
PROFESSOR: Well, sort of. I mean, I probably could.

293
00:25:44,460 --> 00:25:49,980
我不知道如何随手写出它 但是我可以给一些思路
I can't think of how to do it right offhand, but yeah, I could arrange something.

294
00:25:50,480 --> 00:26:00,620
学生：map和for-each的关键区别在于一个是递归 而另一个不是 你上一节课定义了它
AUDIENCE: The vital difference between MAP and for-each is one is recursive and the other is not in the sense you defined early yesterday,I believe.

295
00:26:01,240 --> 00:26:03,860
教授：是的 关于MAP和FOR-EACH和递归
PROFESSOR: Yeah, about MAP and for-each and recursion.

296
00:26:03,860 --> 00:26:05,480
这个观点很好
Yeah, that's a good point.

297
00:26:05,480 --> 00:26:13,080
我写的MAP过程恰巧是一个递归过程
For the MAP procedure I wrote, that happens to be a recursive process.

298
00:26:13,826 --> 00:26:17,066
这是因为 你需要得到处理完表的剩余部分后的值
And the reason for that is that when you've done this thing to the rest of the List,

299
00:26:17,080 --> 00:26:20,960
使其与表的开头部分相连
you're waiting for that value so that you can stick it on to the beginning of the List,

300
00:26:21,733 --> 00:26:24,533
但是FOR-EACH不需要等待返回值
whereas for-each doesn't really have any values to wait for.

301
00:26:24,840 --> 00:26:26,660
所以它变成了一个迭代的过程
So that turns out to be an iterative process.

302
00:26:26,660 --> 00:26:27,720
这不是本质
That's not fundamental.

303
00:26:27,720 --> 00:26:31,800
我可以用迭代的方式定义MAP过程
I could have defined MAP so that it's evolved by an iterative process.

304
00:26:31,826 --> 00:26:32,826
只是我没那么做
I just didn't happen to.

305
00:26:34,240 --> 00:26:42,900
学生：如果用CONS连接列表生成列表的列表 我想这个应该是可行的#TBD
AUDIENCE: If you were to cons for each with a List that had embedded Lists, I imagine it would work, right?

306
00:26:42,900 --> 00:26:48,100
它会返回这些内部列表的内部元素么？
It would give you the internal elements of each of those internal Lists?

307
00:26:48,700 --> 00:26:50,400
教授：问题是 如果我调用
PROFESSOR: OK, the question is if I call

308
00:26:50,400 --> 00:26:52,280
FOR-EACH或者MAP
for-each or map, for that matter

309
00:26:52,810 --> 00:26:55,280
参数是一个嵌套有一个表的表
with a List that had Lists in it

310
00:26:56,693 --> 00:27:00,600
虽然我们还没有讲过这个 但是那是可行的
although we haven't really looked at that yet--would that work.

311
00:27:01,020 --> 00:27:06,560
答案是肯定的 不过我俩对“可行”的定义可能有些不同
The answer is yes in the sense I mean work and no in the sense that you mean work,

312
00:27:06,866 --> 00:27:10,653
来看一下 如果我们给定一个表
because all that-- see if I give you a List,

313
00:27:12,800 --> 00:27:14,200
而在这里挂着的是
where hanging off here is,

314
00:27:16,066 --> 00:27:21,460
不是一个数 而是一个表 或者序对 或者是其它东西
you know, is something that's not a number, maybe another List or you know, another cons or something,

315
00:27:21,960 --> 00:27:24,540
FOR-EACH对表中的每个元素做处理
for-each just says do something to each item in this List.

316
00:27:24,540 --> 00:27:26,960
不断地处理CDR部分
It goes down successively looking at the cdrs.

317
00:27:26,960 --> 00:27:27,200
学生：嗯
AUDIENCE: OK.

318
00:27:27,200 --> 00:27:31,060
教授：它所关心的是 表中的第一个元素#TBD
PROFESSOR: And as far as it's concerned, the first item in this List is whatever is hanging off here.

319
00:27:31,060 --> 00:27:31,650
学生：唔
AUDIENCE: Mhm.

320
00:27:31,650 --> 00:27:33,940
教授：这也许是对的 也许不是
PROFESSOR: That might or might not be the right thing.

321
00:27:33,940 --> 00:27:35,570
学生：所以不能进入子表中
AUDIENCE: So it wouldn't go down into the--

322
00:27:35,570 --> 00:27:36,910
教授：绝对不能
PROFESSOR: Absolutely not.

323
00:27:36,910 --> 00:27:38,510
当然我也可以那样写程序
I could certainly write something else.

324
00:27:38,510 --> 00:27:42,973
你所说的是另一种公共模式 叫做树递归
There's another, what you're looking for is a common pattern of usage called tree recursion,

325
00:27:43,013 --> 00:27:47,940
当你给它一个表 它会不断向深度递归 直到遇到所谓的“树叶”
where you take a List, and you actually go all the way down to the what's called the leaves of the tree.

326
00:27:47,940 --> 00:27:51,050
你可以写出来这个过程 但是它既不是FOR-EACH也不是MAP
And you could write such a thing, but that's not for-each and it's not MAP.

327
00:27:52,420 --> 00:27:55,050
FOR-EACH和MAP都很简单
Remember, these things are really being very simple minded.

328
00:27:55,770 --> 00:27:56,893
好 还有问题么？
OK, no more questions?

329
00:27:57,680 --> 00:27:58,573
好的 大家休息一下吧
All right, let's break.

330
00:27:59,110 --> 00:28:41,940
[MUSIC PLAYING]

331
00:28:41,940 --> 00:28:48,650
教授：我将在本节课余下的时间中 讨论一个实例
PROFESSOR: What I'd like to do now is spend the rest of this time talking about one example,

332
00:28:50,040 --> 00:28:53,920
这个实例 可以充分地总结我们所学的所有东西
and this example, I think, pretty much summarizes everything that we've done up until now:

333
00:28:54,746 --> 00:28:56,293
比如 表结构
all right, and that's List structure

334
00:28:57,173 --> 00:28:59,480
以及抽象的技术
and issues of abstraction,

335
00:28:59,546 --> 00:29:00,826
数据的表示
and representation

336
00:29:01,600 --> 00:29:04,600
和用高阶过程描绘共性
and representation and capturing commonality with higher order procedures,

337
00:29:04,600 --> 00:29:09,800
也会介绍目前为止还没怎么谈论过的
and also is going to introduce something we haven't really talked about a lot yet-- what I said is the major third theme in this course:

338
00:29:09,853 --> 00:29:13,466
也就是这门课的第三大主题
what I said is the major third theme in this course:

339
00:29:13,960 --> 00:29:15,533
元语言抽象
meta-linguistic abstraction,

340
00:29:15,540 --> 00:29:21,906
这种在工程设计中控制复杂度的思想
which is the idea that one of the ways of tackling complexity in engineering design

341
00:29:22,866 --> 00:29:25,800
也就是建立一个合适而强大的语言
is to build a suitable powerful language.

342
00:29:28,173 --> 00:29:34,740
#TBD
You might recall what I said was pretty much the very most important thing that we're going to tell you in this course is that

343
00:29:34,740 --> 00:29:41,170
当我们考察一门语言时 关心的是它的基本元素
when you think about a language,you think about it in terms of what are the primitives;

344
00:29:42,986 --> 00:29:46,693
关心组合它们的方式
what are the means of combination--

345
00:29:49,720 --> 00:29:52,800
是什么让你能够构建更大的东西
right, what are the things that allow you to build bigger things;

346
00:29:53,613 --> 00:29:55,240
以及 如何对它们进行抽象
and then what are the means of abstraction.

347
00:30:00,970 --> 00:30:05,160
如何取用这些你构造出来的“大东西”
How do you take those bigger things that you've built

348
00:30:05,560 --> 00:30:07,973
并将它们放入“黑盒”中
put black boxes around them

349
00:30:08,453 --> 00:30:11,710
然后用它们来构建更复杂的东西
and use them as elements in making something even more complicated?

350
00:30:13,530 --> 00:30:18,720
我将要介绍的一种语言 就是元语言抽象的一个例子
Now the particular language I'm going to talk about is an example

351
00:30:18,733 --> 00:30:22,706
这是我朋友Peter Handerson发明的
that was made up by a friend of ours called Peter Henderson.

352
00:30:28,240 --> 00:30:31,746
他在苏格兰的斯特灵大学
Peter Henderson is at the University of Stirling in Scotland.

353
00:30:32,786 --> 00:30:40,986
这个语言是用来画这样的图
And what this language is about is making figures that sort of look like this.

354
00:30:41,866 --> 00:30:46,666
这是埃舍尔的木版画 《方极限》
This is this is a woodcut by Escher called "Square Limit."

355
00:30:49,330 --> 00:30:57,946
正如大家所见 这里面有着很复杂的...图像的递归
You, sort of, see it has this complicated, kind of, recursive, sort of, recursive kind of figure,

356
00:30:58,450 --> 00:31:05,050
#TBD 中间的这个鱼的模式不断以更小的图案出现在原来的图案旁边
where there's this fish pattern in the middle and things sort of bleed out smaller and smaller in self similar ways.

357
00:31:08,490 --> 00:31:12,800
总之 Peter Hendersion的语言是用来表述这类图形
Anyway, Peter Henderson's language was for describing figures that look like that

358
00:31:13,373 --> 00:31:18,280
并且设计类似的图形 将它画在显示器上
and designing new ones that look like that and drawing them on a display screen.

359
00:31:20,240 --> 00:31:27,480
这个例子还展示了另外一个主题
There's another theme that we'll see illustrated by this example,

360
00:31:28,093 --> 00:31:32,020
这也是我跟Gerry多次提到的
and that's the issue of what Gerry and I have already mentioned a lot:

361
00:31:32,020 --> 00:31:36,173
也就是过程跟数据之间没有本质的区别
that there's no real difference, in some sense, between procedures and data.

362
00:31:37,266 --> 00:31:42,400
不管如何 我希望今早课程结束后
And anyway I hope by the end of this morning, if you're not already,

363
00:31:42,586 --> 00:31:47,600
你们能将过程和数据当作一回事儿
you will be completely confused about what the difference between procedures and data are,

364
00:31:47,960 --> 00:31:49,586
即使现在你们还将它们区别对待
if you're not confused about that already.

365
00:31:50,800 --> 00:31:55,280
好 先让我们看一下Peter的语言
Well in any case, let's start describing Peter's language.

366
00:31:55,280 --> 00:31:57,266
我先告诉你们基本元素是什么
I should start by telling you what the primitives are.

367
00:31:58,293 --> 00:32:00,920
这个语言非常简单 因为它的基本元素只有一个
This language is very simple because there's only one primitive.

368
00:32:03,333 --> 00:32:06,306
这个基本元素不是大家想象的那样
A primitive is not quite what you think it is.

369
00:32:07,080 --> 00:32:09,186
唯一的基本元素叫做"图像"
There's only one primitive called a picture,

370
00:32:09,706 --> 00:32:12,110
但此“图像”非彼“图像”
and a picture is not quite what you think it is.

371
00:32:12,110 --> 00:32:14,170
具体地来说
Here's an example.

372
00:32:14,170 --> 00:32:15,173
这是George的图像
This is a picture of George.

373
00:32:19,013 --> 00:32:20,373
我们的想法是
The idea is that

374
00:32:22,333 --> 00:32:31,466
#TBD 在这个语言中的图像是绘制通过缩放填充到指定矩行区域的一个图形产生的
a picture in this language is going to be something that draws a figure scaled to fit a rectangle that you specify.

375
00:32:33,000 --> 00:32:34,420
这里大家看到的强调线
So here you see emphasis line

376
00:32:34,420 --> 00:32:37,706
是这个矩形的轮廓 但不是图像的一部分
is outline of a rectangle, that's not really part of the picture,

377
00:32:40,493 --> 00:32:47,170
但是一旦指定一个矩形区域 图像会以以填充的方式绘制满区域
but the picture-- you'll give it a rectangle, and it will draw this figure scaled to fit the rectangle.

378
00:32:47,170 --> 00:32:52,160
比如 这个是George 在这里 这个也是George
So for example, there's George, and here, this is also George.

379
00:32:53,213 --> 00:32:56,653
它是同一个图像 只是缩放程度不同
It's the same picture, right, just scaled to fit a different rectangle.

380
00:32:57,400 --> 00:32:59,280
这是“胖”George的版本
Here's George as a fat kid.

381
00:33:00,013 --> 00:33:03,440
这个也是George
That's the same George.

382
00:33:03,813 --> 00:33:05,140
这是同一个图形
It's all the same figure.

383
00:33:05,140 --> 00:33:09,573
这个语言中 这三个都是同一个图像
All of these three things are the same picture in this language.

384
00:33:09,586 --> 00:33:13,040
仅仅是给了不同的矩形区域让它来填充
I'm just giving it different rectangles to scale itself in.

385
00:33:16,080 --> 00:33:20,650
这就是基本元素
OK, those are the primitives. That is the primitive.

386
00:33:21,440 --> 00:33:25,253
现在 我们来讨论元素组合和操作
Now let's start talking about the means of combination and the operations.

387
00:33:25,906 --> 00:33:30,170
比如 这里有一个叫做旋转的操作
There is, for example, an operation called Rotate.

388
00:33:31,093 --> 00:33:33,666
如果我有一个图像 “旋转”操作就是
And what Rotate does is, if I have a picture,

389
00:33:35,373 --> 00:33:39,933
先假定有一个里面有个“A”的矩形
say a picture that draws an "A" in some rectangle that I give it,

390
00:33:41,840 --> 00:33:45,733
而旋转90度的操作则会
the Rotate of that--say the Rotate by 90 degrees would,

391
00:33:47,026 --> 00:33:50,650
在一个给定的矩形内 绘制同样的图像
if I give it a rectangle, draw the same image,

392
00:33:50,650 --> 00:33:53,880
但是 会缩放图像以适应矩形
but again, scaled to fit that rectangle.

393
00:33:56,110 --> 00:33:58,340
这个就是旋转90度
So that's Rotate by 90 degrees.

394
00:33:58,340 --> 00:34:03,200
另一个操作是“翻转” 可以水平翻转也可以竖直翻转
There's another operation called Flip that can flip something, either horizontally or vertically.

395
00:34:04,773 --> 00:34:06,000
就是这些操作了
All right, so those are, sort of, operations,

396
00:34:06,013 --> 00:34:10,400
#TBD
or you can think of those as means of combination of one element.

397
00:34:10,893 --> 00:34:12,426
我可以把它们混合起来
I can put things together.

398
00:34:13,440 --> 00:34:15,546
我们有一种叫BESIDE的操作
There's a means of combination called Beside,

399
00:34:16,466 --> 00:34:24,786
它做的事情是 给定两个图像A、B
and what Beside does: it'll take two pictures, let's say A and B--

400
00:34:29,020 --> 00:34:33,250
#TBD 然后它将在一个指定的矩形中绘制一个图像
and by picture I mean something that's going to draw an image in a specified rectangle--

401
00:34:34,050 --> 00:34:36,510
BESIDE则会
and what Beside will do--

402
00:34:37,850 --> 00:34:44,080
类似于调用(BESIDE A B S) 其中S是一个数
I have to say, Beside of A and B, the side of two pictures and some number, s.

403
00:34:45,340 --> 00:34:48,080
是一个在0到1之间的数
And s will be a number between zero and one.

404
00:34:50,510 --> 00:34:52,570
BESIDE绘制像这样的图像
And Beside will draw a picture that looks like this.

405
00:34:52,570 --> 00:34:56,710
以给定的矩形为基础 但会将基底缩放S
It will take the rectangle you give it and scale its base by s.

406
00:34:56,710 --> 00:34:58,710
这里S是0.5
Say s is 0.5.

407
00:35:00,186 --> 00:35:07,173
在这里 它会在这里画第一个图案
And then over here it will draw-- it'll put the first picture, and over here it'll put the second picture.

408
00:35:07,813 --> 00:35:12,650
在这里画第二个图案
and over here it'll put the second picture.

409
00:35:13,820 --> 00:35:16,440
又比如说 我令设一个S的值
Or for instance if I gave it a different value of s,

410
00:35:16,813 --> 00:35:23,026
比如调用(BESIDE A B 0.25)
Or for instance if I gave it a different value of s, if I said Beside with a 0.25,

411
00:35:25,940 --> 00:35:29,093
效果相同 只不过A更瘦了
it would do the same thing, except the A would be much skinnier.

412
00:35:34,050 --> 00:35:36,280
而B是这样的
So it would draw something like that.

413
00:35:37,820 --> 00:35:40,293
这就是组合手段之一——BESIDE
So there's a means of combination Beside,

414
00:35:40,680 --> 00:35:46,050
类似地 ABOVE方法在竖直方向上做这种操作
and similarly there's an Above, which does the same thing except it puts them vertically instead of horizontally.

415
00:35:47,840 --> 00:35:48,893
我们来看一下
Well let's look at that.

416
00:35:50,740 --> 00:35:56,000
这是通过将George
which is, right, constructed by taking George and putting him Beside the Above--
这是George和他的"弟弟"
All right, there's George and his kid brother,

417
00:35:56,000 --> 00:36:11,740
这是通过将George
which is, right, constructed by taking George and putting him Beside the Above--

418
00:36:11,740 --> 00:36:16,140
系统中有个东西叫做空图案 很明显--
taking the empty picture, and there's a thing called the empty picture, which does the obvious thing--

419
00:36:16,140 --> 00:36:19,140
空图像放在了George副本的上面
putting the empty picture above a copy of George,

420
00:36:19,140 --> 00:36:21,140
然后这个合成的图像放在了George的旁边
and then putting that whole thing Beside George.

421
00:36:28,770 --> 00:36:54,080
给beside然后flipping图像George的过程起一个名字叫做P 它水平扩展 然后先旋转整个图像180度 然后将基本的矩形区域分成两半 将原图和现在这个图拼接在一起 我叫它P
Here's something called P which is, again, George Beside Flipping George, I think, horizontally in this case, and then Rotating the whole result 180 degrees and putting them Beside one another with the basic rectangle divided at 0.5, right, and I can call that P.

422
00:36:55,880 --> 00:37:05,050
我把P作用在翻转上面 给它起一个名字叫做Q #TBD这里翻译有问题,估计
And then I can take P, and put it above the Flipped copy of itself, and I can call that Q.

423
00:37:09,200 --> 00:37:21,050
我们构建一个复杂情况需要多少时间？ 15秒，你就可以从George得到Q 这个是为什么呢？
Notice how rapidly that we've built up complexity, just in, you know, 15 seconds, you've gotten from George to that thing Q. Why is that?

424
00:37:22,050 --> 00:37:24,550
为什么我们可以如此迅速的做呢?
How are how we able to do that so fast?

425
00:37:25,850 --> 00:37:28,020
答案是闭包属性
The answer is the closure property.

426
00:37:28,020 --> 00:37:38,250
事实是 一个图形 我可以用它来做beside的参数 生成一个图像 然后我可以用这个图像继续进行rotage flip或者above等操作
See, it's the fact that when I take a picture and put it Beside another picture, that's then, again, a picture that I can go and Rotate and Flip or put Above something else.

427
00:37:39,170 --> 00:37:45,220
当我对那个图像进行P操作 得到的还是一个图像
Right, and when I take that element P, which is the Beside or the Flip or the Rotate of something, that's, again, a picture.

428
00:37:45,220 --> 00:37:50,600
也就是说 对于图像而言 这些组合是封闭的
Right, the world of pictures is closed under those means of combination.

429
00:37:50,600 --> 00:37:55,600
所以只要给我一个图像 我可以立刻把它作为一个可以在其它地方使用的元素
So whenever I have something, I can turn right around and use that as an element in something else.

430
00:37:55,600 --> 00:38:03,280
也许(这个案例)比列表和线段更好 给大家展示了如何快速构建复杂的系统 根本原因是这些操作是封闭的
So maybe better than List and segments, that just gives you an image for how fast you can build up complexity, because operations are closed.

431
00:38:07,220 --> 00:38:15,280
在构建更多东西之前 我们谈谈这个语言要如何实现
OK, well before we go on with building more things, let's talk about how this language is actually implemented.

432
00:38:16,910 --> 00:38:28,280
在这个桌子下面的基本元素叫做矩形区域 矩形区域是： #TBD 需要修改
The basic element that sits under the table here is a thing called a rectangle, and what a rectangle is going to be,

433
00:38:28,280 --> 00:38:40,180
它有指定的原点 用来说明这个矩形区域从哪里开始的
it's a thing that specified by an origin that's going to be some vector that says where the rectangle starts.

434
00:38:40,180 --> 00:38:59,580
还有其他向量 我叫它矩形区域的水平向量 另一个是矩形区域的竖直向量
And then there's going to be some other vector that I'm going to call the horizontal part of the rectangle, and another vector called the vertical part of the rectangle.

435
00:39:00,310 --> 00:39:09,970
它们三个是三个元素:底坐标在哪里 这里如何获得下一个坐标 这里如何获得下一个坐标
And those three pieces are the elements: where the lower vertex is, how you get to the next vertex over here, and how you get to the vertex over there.

436
00:39:09,970 --> 00:39:12,370
这三个向量确定了一个矩形
The three vectors specify a rectangle.

437
00:39:15,770 --> 00:39:39,650
现在为了构建了矩形 我们假定我们已经有了一个构造器 叫做make rectangle 或者make-rect 它的水平，竖直，原点的选择器是horiz, vert, origin
Now to actually build rectangles, what I'll assume is that we have a constructor called "make rectangle," or "make-rect," and selectors for horiz and vert and origin that get out the pieces of that rectangle.

438
00:39:39,650 --> 00:39:42,540
大家知道有很多方法可以实现它
And well, you know a lot of ways you can do this now.

439
00:39:42,540 --> 00:39:47,620
大家可以用pair或者列表或者别的什么东西来做
You can do it by using pairs in some way or other standard List or not.

440
00:39:47,620 --> 00:39:51,400
但是，实现这个是George该去想的问题
But in any case, the implementation of these things, that's George's problem.

441
00:39:51,400 --> 00:39:53,170
这就是一个数据抽象问题
It's just a data representation problem.

442
00:39:53,170 --> 00:39:55,470
现在我们假设已经有了这三个矩形
So let's assume we have these rectangles to work with.

443
00:40:02,050 --> 00:40:05,080
记住要做什么
OK. Now the idea of this, remember what's got to happen.

444
00:40:05,080 --> 00:40:16,600
我们需要操心的是:给定一个图案 对它进行缩放来填充给定的矩形 这个是我们需要做的
Somehow we have to worry about taking the figure and scaling it to fit some rectangle that you give it, that's the basic thing you have to arrange,

445
00:40:16,600 --> 00:40:18,600
that these pictures can do.

446
00:40:22,220 --> 00:40:23,650
我们要怎么做呢？
How do we think about that?

447
00:40:23,650 --> 00:40:38,850
其中的一种方法是任何时候给定一个矩行
Well, one way to think about that is that any time I give you a rectangle,

448
00:40:39,250 --> 00:40:45,770
定义 在某种意义上 把一个正方形转化成矩形.
that defines,in some sense, a transformation from the standard square into that rectangle.

449
00:40:45,770 --> 00:40:46,540
我们来看一下我所说的
Let me say what I mean.

450
00:40:46,540 --> 00:40:59,040
一个标准的正方形 它的坐标是(0,0)(1,0)(1,1)
By the standard square, I'll mean something, which is a square whose coordinates are 0,0, and 1,0, and 0,1 and 1,1.

451
00:41:01,400 --> 00:41:10,340
有一些显然的缩放变换 可以把这个变成那个 把这个变成那个
And there's some sort of the obvious scaling transformation, which maps this to that and this to that,

452
00:41:10,340 --> 00:41:12,080
还有一些对每一个向量进统一拉伸的方法
and sort of, stretches everything uniformly.

453
00:41:12,170 --> 00:41:32,680
我们像这样做一个线段 并且做它的映射像这样 所以点(x,y)变成了另外一个点
So we take a line segment like this and end up mapping it to a line segment like that, so some point (x,y) goes to some other point up there.

454
00:41:32,680 --> 00:41:39,370
虽然这个不重要 就是一点点的代数几何 大家可以容易的把公式写出来
And although it's not important,with a little vector algebra, you could write that formula.

455
00:41:39,370 --> 00:41:50,670
点(x,y)会变到 用矩阵的原点和它做向量加法 --
The thing that (x,y) goes to, the point that (x,y) goes to is gotten by taking the origin of the rectangle and then adding that as a vector to--

456
00:41:50,670 --> 00:42:01,970
x坐标 这个值在0到1之间 乘以矩阵的水平向量
well, take x, the x coordinate, which is something between zero and one, multiply that by the horizontal vector of the rectangle;

457
00:42:07,220 --> 00:42:16,280
y坐标 这个值也在0到1之间 乘以矩阵的竖直向量
and take the y coordinate, which is also something between zero and one and multiply that by the vertical vector of the rectangle.

458
00:42:16,740 --> 00:42:19,310
这个是简单地线性代数
That's just a little linear algebra.

459
00:42:19,310 --> 00:42:28,510
这个公式明显正确的把正方形中的元素转换成了矩阵的内部元素
Anyway, that's the formula, which is the right obvious transformation that takes things into the unit square, into the interior of that rectangle.

460
00:42:31,340 --> 00:42:34,020
好，我们把它看作是一个过程
OK well, let's actually look at that as a procedure.

461
00:42:35,050 --> 00:42:42,850
所以我们要做的事情是定义一个矩形的转化过程
So what we want is the thing which tells us that particular transformation that a rectangle defines.

462
00:42:43,800 --> 00:42:45,220
就是这个过程
So here's the procedure.

463
00:42:45,220 --> 00:42:47,220
我叫它coordinate-map
I'll call it coordinate-map.

464
00:42:47,770 --> 00:42:57,850
coordinate-map需要一个矩形作为参数，它返回需要一个点坐标作为参数的过程
Coordinate-map is the thing that takes as its argument a rectangle and returns for you a procedure on points.

465
00:43:00,450 --> 00:43:06,820
所以对每一个矩形，你都有个转换函数将一个点(x,y)转换到这个矩形里面
Right, so for each rectangle you get a way of transforming a point (x,y) into that rectangle.

466
00:43:06,820 --> 00:43:08,020
如何做呢？
And how do you get it?

467
00:43:08,020 --> 00:43:10,920
我只是--在黑板上用列表实现  #TBD 这个是list 还是lisp 不确定
Well I just--  writing in List what I wrote there on the blackboard--

468
00:43:10,920 --> 00:43:20,200
矩形的原点--
I add to the origin of the rectangle the result of adding--

469
00:43:20,220 --> 00:43:25,020
我用矩形的水平向量
I take the horizontal part of the rectangle;

470
00:43:25,020 --> 00:43:27,680
来对点point的x坐标缩放
I scale that by the x coordinate of the point.

471
00:43:29,650 --> 00:43:32,620
我用矩形的竖直向量，
I take the vertical vector of the rectangle.

472
00:43:33,510 --> 00:43:37,140
来对point的y坐标进行缩放
I scale that by the y coordinate of the point,

473
00:43:37,140 --> 00:43:39,140
然后把他们三个加到一起
and then add all those three things up.

474
00:43:39,340 --> 00:43:41,340
这就是这个过程
That's the procedure.

475
00:43:41,340 --> 00:43:44,540
这就是我将要应用在point上的过程
That is the procedure that I'm going to apply to a point.

476
00:43:46,540 --> 00:43:52,170
每一个矩形都可以产生这样一个过程
And this whole thing is generated for each rectangle.

477
00:43:52,170 --> 00:43:57,250
所以任何一个矩形定义一个coordinate-map,返回一个作用在point上的过程
So any rectangle defines a coordinate MAP, which is a procedure on points.

478
00:44:06,510 --> 00:44:28,170
比如，原始的George，在这个正方形单元中有一些线段，只要我指定一个矩行,就可以把这些线段映射过来.
All right, so for example, George here, my original George, might have been something that I specified by segments in the unit square, and then for each rectangle I give this thing, I'm going to draw those segments inside that rectangle.

479
00:44:28,170 --> 00:44:30,170
我实际是怎么做的呢?
How actually do I do that?

480
00:44:30,170 --> 00:44:44,450
我把原来在George中的每一个线段的原点和结束点应用到coordinate-map上。#TBD
Well I take each segment in my original reference George that was specified, and to each of the end points of those segments, I applied the coordinate MAP of the particular rectangle I want to draw it in.

481
00:44:44,450 --> 00:44:51,250
比如，这个矮矩形，图像George用coordinate-map变换后变成一个胖子
So for example, this lower rectangle, this George as a fat kid rectangle, has its coordinate MAP.

482
00:44:51,250 --> 00:45:05,340
如果我要绘制这个图像，我要做的就是对这里的每一个线段，用coordinate-map映射线段的段点
And if I want to draw this image, what I do is for each segment here, say for this segment, I transformed that point by the coordinate MAP, transform that point by the coordinate MAP.

483
00:45:05,340 --> 00:45:09,220
它将给我这个点和那个点，并且在这两个点中画一个线段
That will give me this point and that point and draw the segment between them.

484
00:45:09,710 --> 00:45:11,520
对，基本想法就是这样
Right, that's the idea.

485
00:45:12,660 --> 00:45:18,140
像这样如果我给一个不同的矩形，那么(会产生)不同的coordinate-map,因此我得到这些线段的不同图像
Right, and if I give it a different rectangle like this one, that's a different coordinate MAP, so I get a different image of those line segments.

486
00:45:19,280 --> 00:45:22,140
我们如何获得最开始的图像呢?
Well how do we actually get a picture to start with?

487
00:45:22,140 --> 00:45:26,520
我们可以用线段列表获得最初的图像.
I can build a picture to start with out of a List of line segments initially.

488
00:45:27,500 --> 00:45:37,520
这是一个我构建最基本图像的过程，意思是，我没有用beside，rotate等构建图像
Here's a procedure that builds what I'll call a primitive picture, meaning one I, sort of, got that didn't come out of Beside or Rotate or something.

489
00:45:37,520 --> 00:45:44,040
我用线段的列表，他们按照我说的来工作
It starts with a List of line segments, and now it does what I said.

490
00:45:44,040 --> 00:45:45,580
图像会是什么样子呢？
What's a picture have to be?

491
00:45:45,580 --> 00:45:49,440
首先，它是一个根据矩形定义的过程
First of all it's a procedure that's defined on rectangles.

492
00:45:51,700 --> 00:45:53,000
这个过程做什么呢？
What does it do?

493
00:45:53,000 --> 00:46:07,300
线段构成的列表中的每一个元素s,它自己画一条线段.
It says for each-- this is going to be a List of line segments-- for each segment, for each s, which is a segment in this List of segments, well it draws a line.

494
00:46:07,300 --> 00:46:08,820
它画什么样的线段呢？
What line does it draw?

495
00:46:10,460 --> 00:46:18,320
线段的起点，通过在特定矩形的coordinate-map变换
It gets the start point of that segment, transforms that by the coordinate MAP of the rectangle.

496
00:46:19,540 --> 00:46:21,760
这个就是第一个想要的新的点
That's the first new point it wants to do.

497
00:46:21,760 --> 00:46:27,920
线段的终点，通过这个矩形的coordinate-map变换得到新点，在新起点和新终点之间画一个线段
Then it takes the endpoint of the segment, transforms that by the coordinate MAP of the rectangle, and then draws a line between.

498
00:46:27,920 --> 00:46:33,220
我们假设画线是一个基本的操作，已经在系统中实现了.
Let's assume drawline is some primitive that's built into the system that actually draws a line on the display.

499
00:46:33,960 --> 00:46:44,220
通过矩形的坐标映射变换了线段两段点，在新段点间画一个线段.线段列表的每一个线段s都会进行这样的操作
All right, so it transforms the endpoints by the coordinate MAP of the rectangle, draws a line between them, does that for each s in this List of segments.

500
00:46:45,960 --> 00:46:51,400
现在要记住，一个图像就是一个用矩形作为参数的过程.
And now remember again, a picture is a procedure that takes a rectangle as argument.

501
00:46:51,400 --> 00:46:56,360
所以当你有一个矩形的时候，它所做的事情就是：画这些线段.
So when you hand it a rectangle, this is what it does: draws those lines.

502
00:46:56,360 --> 00:47:01,220
好，我应该如何使用它呢？
All right, so there's-- how would I actually use this thing?

503
00:47:01,220 --> 00:47:04,080
我来说的具体一点
Let's make it a little bit more concrete.

504
00:47:05,600 --> 00:47:29,180
举例来说，定义R是make-rectangle的过程，我需要用make-vector来生成一些向量
Right, I would say for instance, define R to be make-rectangle of some stuff, and I'd have to specify some vectors here using make-vector.

505
00:47:29,840 --> 00:47:46,180
然后，定义G为make-picture的过程
And then I could say, define say, G to be make-picture, and then some stuff.

506
00:47:46,680 --> 00:47:55,280
这里声明一个线段列表,叫做make-segment
And what I'd have to specify here is a List of line segments, right, using make segment.

507
00:47:55,280 --> 00:47:58,700
make-segment由向量构成，向量由点构成
Make-segment might be made out of vectors, and vectors might be made out of points.

508
00:47:59,260 --> 00:48:11,720
如果我想看G里面矩形的图像，它是一个用这个矩形作为参数的过程
And then if I actually wanted to see the image of G inside a rectangle, well a picture is a procedure that takes a rectangle as argument.

509
00:48:11,920 --> 00:48:23,620
所以，如果用R作为参数调用G，图像G将会在矩形R来绘制出来.
So if I then called G with an input of R, that would cause whatever image G is worrying about to be drawn inside the rectangle R.

510
00:48:23,620 --> 00:48:25,620
这就是大家如何使用它
Right, so that's how you'd use that.

511
00:48:25,620 --> 00:49:07,280
[MUSIC PLAYING]

512
00:49:07,720 --> 00:49:12,480
老师：为什么我说这个例子很好呢？
PROFESSOR: Well why is it that I say this example is nice?

513
00:49:12,480 --> 00:49:13,740
大家也许不觉得它很好.
You probably don't think it's nice.

514
00:49:13,740 --> 00:49:15,420
大家可能觉得它很奇怪
You probably think it's more weird than nice.

515
00:49:15,420 --> 00:49:20,920
对，这些图像用过程来表示，用矩形来做一些复杂的事情(变换)
Right, representing these pictures as procedures, which do complicated things with rectangles.

516
00:49:20,920 --> 00:49:22,720
那么,它好在哪里呢？
So why is it nice?

517
00:49:25,020 --> 00:49:35,220
它很好的原因是，一旦你是实现了其中的基本元素---把过程的实现跟组合分离出来.
The reason it's nice is that once you've implemented the primitives in this way, the means of combination just fall out by implementing procedures.

518
00:49:35,980 --> 00:49:37,480
我来展示一下我的想法.
Let me show you what I mean.

519
00:49:37,480 --> 00:49:39,480
假如我想实现beside
Suppose we want to implement Beside.

520
00:49:41,560 --> 00:49:47,360
所以我要做---假设我有一个图像,把它叫做P1
So I'd like to--  suppose I've got a picture.Let's call it P1.

521
00:49:47,360 --> 00:49:50,620
P1是--现在要明白真正的图像是什么(一个过程)
P1 is going to be-- and now remember what a picture really is.

522
00:49:50,620 --> 00:50:01,920
如果你给P1一个矩形，它会在你给定的矩形中绘制图像.
It's a thing that if you can hand it some rectangle, it will cause an image to be drawn in whatever rectangle you hand it.

523
00:50:03,140 --> 00:50:09,640
假设P2，是另外的图像，你用一个矩形处理它，
And suppose P2 two is some other picture, and you hand that a rectangle.

524
00:50:09,640 --> 00:50:12,540
无论你给它什么矩形，它都会绘制一些图案.
And whatever rectangle you hand it, it draws some picture.

525
00:50:14,660 --> 00:50:28,380
现在，我想实现beside,用P1，P2，还有一个缩放因子a, 那会发生什么呢？
And now if I'd like to implement Beside of P1 and P2 with a scale factor A, well what does that have to be?

526
00:50:34,620 --> 00:50:40,300
所以，如果把Beside放到矩形里，---我们在这个矩行中处理它.
So if hand Beside this rectangle-- let's hand it a rectangle.

527
00:50:41,500 --> 00:50:42,740
要做什么呢？
Well what's it going to do?

528
00:50:42,760 --> 00:50:55,380
它将把这个矩形切分成两部分，一部分比例是a,另一部分比例是(1-a). 那是说，现在我们有两个矩形
It's going to take this rectangle and split it into two at a ratio of A and one minus A. And it will say, oh sure, now I've got two rectangles.

529
00:51:02,020 --> 00:51:09,840
现在(beside)进入P1，对P1说，在这个矩形中绘制你自己，然后进入P2，对P2说，
And now it goes off to P1 and says P1, well draw yourself in this rectangle, and goes off to P2, and says, P2,

530
00:51:09,840 --> 00:51:11,840
在这个矩形中绘制你自己
fine, draw yourself in this rectangle.

531
00:51:13,280 --> 00:51:16,880
它所做的所有计算就是计算出有多少个矩形.
The only computation it has to do is figure out what these rectangles are.

532
00:51:17,360 --> 00:51:26,380
要记住，一个矩形是原点，水平向量，竖直向量组成的，它要做的就是把他们找出来
Remember a rectangle is specified by an origin and a horizontal vector and a vertical vector, so it's got to figure out what these things are.

533
00:51:27,300 --> 00:51:38,000
所以对第一个矩形来说，原点变成了矩形的原点，竖直向量和原始的矩形保持不变
So for this first rectangle, the origin turns out to be the origin of the original rectangle, and the vertical vector is the same as the vertical vector of the original rectangle.

534
00:51:38,700 --> 00:51:46,600
水平向量是原始矩形的竖直向量缩放a得到的
The horizontal vector is the horizontal vector of the original rectangle scaled by A.

535
00:51:47,380 --> 00:51:49,260
这就是第一个矩形
And that's the first rectangle.

536
00:51:49,460 --> 00:52:00,060
第二个矩形的原点是原来的矩形的原点加上矩形的水平向量缩放a,
The second rectangle, the origin is the original origin plus that horizontal vector scaled by A.

537
00:52:00,900 --> 00:52:11,660
第二个矩形的水平向量，是矩形的水平向量减去第一个的水平向量，是(1-a)*h
The horizontal vector of the second rectangle is the rest of the horizontal vector of the first one, which is 1 minus A times the original H,

538
00:52:11,660 --> 00:52:14,360
它的竖直向量还是v
and the vertical vector is still v.

539
00:52:15,220 --> 00:52:26,560
基本上,它构造了两个矩形,更重要的是,构造的这两个矩形p1,在这里让它绘制它自己,矩形p2，让它在这里绘制它自己。这就是beside所做的事情
But basically it goes and constructs these two rectangles, and the important point is having constructed the rectangles, it says OK, p1, you draw yourself in there, and p2, you draw yourself in there, and that's all Beside has to do.

540
00:52:27,680 --> 00:52:29,860
我们看一下代码
All right, let's look at that piece of code.

541
00:52:34,200 --> 00:52:53,760
用一个缩放比例来对一个图像和另一个图像应用biside, 首先，这个图像也是一个过程，接受一个矩形作为它的参数
Beside of a picture and another picture with some scaling ratio is first of all, since it's a picture, a procedure that's going to take a rectangle as argument.

542
00:52:55,380 --> 00:52:56,760
它做什么呢？
What's it going to do?

543
00:52:56,760 --> 00:53:02,320
p1在一些矩形中绘制它自己，p2在另外的一些矩形中绘制它自己
It says, p1 draw yourself in some rectangle and p2 draw yourself in some other rectangle.

544
00:53:02,900 --> 00:53:04,460
现在这些矩形是什么呢?
And now what are those rectangles?

545
00:53:04,460 --> 00:53:05,480
这里就是计算
Well here's the computation.

546
00:53:05,480 --> 00:53:10,400
它创建了一个矩形，这个是我刚才在黑板上写的几何公式--- 原点
It makes a rectangle, and this is the algebra I just did on the board: the origin, something;

547
00:53:10,400 --> 00:53:11,840
水平向量；
the horizontal vector, something;

548
00:53:11,840 --> 00:53:13,440
竖直向量
and the vertical vector, something.

549
00:53:13,800 --> 00:53:19,780
对于p2,矩形需要不同的原点，水平向量和竖直向量
And for p2, the rectangle it wants has some other origin and horizontal vector and vertical vector.

550
00:53:19,780 --> 00:53:27,180
但是最重要的是，p1,在一个矩形中做你指定的事情，而p2在另一个矩形中做你指定的事情
But the important point is that all it's saying is, p1, go do your thing in one rectangle, and p2, go do your thing in another rectangle.

551
00:53:27,740 --> 00:53:29,420
这个就是beside做的
That's all the Beside has to do.

552
00:53:30,620 --> 00:53:35,620
好，rotate也很类似
OK, similarly Rotate--

553
00:53:36,960 --> 00:53:52,320
我有这个图像a,我想看图像a旋转90度,这意味着,给定这个矩形
see if I have this picture A, and I want to look at say rotating A by 90 degrees, what that should mean is, well take this rectangle,

554
00:53:53,760 --> 00:54:09,320
这个矩形的原始原点，水平向量，竖直向量，现在假设已经有了这样的矩形，这个矩形的原点，水平向量，在这，竖直向量在这
which is origin and horizontal vector and vertical vector, and now pretend that it's really the rectangle that looks like this, which has an origin and a horizontal vector up here, and a vertical vector there,

555
00:54:09,600 --> 00:54:12,460
然后在矩形里各自绘制自己.
and now draw yourself with respect to that rectangle.

556
00:54:13,260 --> 00:54:15,040
我来展示这个过程
Let me show you that as a procedure.

557
00:54:16,760 --> 00:54:26,340
我们对这个图像旋转90度，因为过程也是一个图像，它可以在特定的矩形中绘制自己
All right, so we'll Rotate 90 of the picture, because again, a procedure for rectangle, which says, OK picture, draw yourself in some rectangle;

558
00:54:27,100 --> 00:54:30,660
并且这个几何公式就是这个矩形的变换规则
and then this algebra is the transformation on the rectangle.

559
00:54:30,660 --> 00:54:34,160
It's the one which makes it look like the rectangle is sideways,

560
00:54:34,160 --> 00:54:40,060
原点在别的地方；竖直向量在别的地方；水平向量在别的地方;竖直向量在别的地方
the origin is someplace else and the vertical vector is someplace else, and the horizontal vector is someplace else, and vertical vector is someplace else.

561
00:54:46,760 --> 00:55:01,260
再次注意，这里的关键是使用过程来做图片的表示，这个过程本身有闭包的特性，
OK, again notice, the crucial thing that's going on here is you're using the representation of pictures as procedures to automatically get the closure property,

562
00:55:01,740 --> 00:55:05,220
beside对于p1,
because what happens is, Beside just has this thing p1.

563
00:55:05,220 --> 00:55:12,900
beside不关心那个是不是主要的图像，或者是线段，或者这个是不是由above, beside,rotate生成的，//
Beside doesn't care if that's a primitive picture or it's line segments or if p1 is, itself, the result of doing Aboves or Besides or Rotates.

564
00:55:12,900 --> 00:55:20,000
beside所知道的就是,如果你给p1一个矩形，它会在这个矩形中绘制(p1)
All Beside has to know about, say, p1 is that if you hand p1 a rectangle, it will cause something to be drawn.

565
00:55:20,820 --> 00:55:26,100
在这个层面上，beside不关心p1是如何绘制自己的
And above that level, Beside just doesn't-- it's none of its business how p1 accomplishes that drawing.

566
00:55:27,420 --> 00:55:32,540
对，这就是使用过程表示图像保证了这个(系统)闭包的
All right, so you're using the procedural representation to ensure this closure.

567
00:55:35,640 --> 00:55:43,840
所以用过程来实现图片,使得组合的意义非常简单，并且优美
So implementing pictures as procedures makes these means of combination, you know, both pretty simple and also, I think, elegant.

568
00:55:45,920 --> 00:55:48,220
但是这个不是真正的至理名言
But that's not the real punchline.

569
00:55:49,280 --> 00:55:53,520
真正的来自当你用这种语言看待抽象的意义的时候
The real punchline comes when you look at the means of abstraction in this language.

570
00:55:54,700 --> 00:55:56,240
因为我们做的什么？
Because what have we done?

571
00:55:56,240 --> 00:56:03,720
我们用组合实现了过程
We've implemented the means of combination themselves as procedures.

572
00:56:05,640 --> 00:56:21,620
这个的意思是，当我们在这个语言进行抽象的时候，Lisp提供的一切操作过程，都可以用在这个图片语言中
And what that means is that when we go to abstract in this language, everything that Lisp supplies us for manipulating procedures is automatically available to do things in this picture language.

573
00:56:21,920 --> 00:56:32,800
我可以使用的语言不仅仅是Lisp本身的,也包括这种非常优雅的嵌入到Lisp中的语言.
The technical term I want to say is not only is this language implemented in Lisp, obviously it is, but the language is nicely embedded in Lisp.

574
00:56:37,640 --> 00:56:48,860
我的意思是，通过这种方式嵌入语言，Lisp的强悍特点就自然的表现出来了，它可以为你做任何事情
What I mean is by embedding the language in this way, all the power of Lisp is automatically available as an extension to whatever you want to do.

575
00:56:50,060 --> 00:56:51,680
我的意思是
And what do I mean by that?

576
00:56:51,680 --> 00:57:07,060
比如说，我想做一个图像，它有四个图片做为参数a, b ,c ,d.并且想这样做配置.
Example: say, suppose I want to make a thing that takes four pictures A, B, C and D, and makes a configuration that looks like this.

577
00:57:12,500 --> 00:57:16,960
恩，大家可以叫它，four-pictures或者,four-pict的配置
Well you might call that, you know, four pictures or something, four-pict configuration.

578
00:57:16,960 --> 00:57:17,700
我如何做到这样的呢？
How do I do that?

579
00:57:17,700 --> 00:57:18,680
我可以很容易的做到这些
Well I can obviously do that.

580
00:57:18,680 --> 00:57:27,880
我就是写一个过程，把b放在d上面，把a放在c上面，然后把这两部分用beside连接起来
I just write a procedure that takes B above D and A above C and puts those things beside each other.

581
00:57:28,240 --> 00:57:31,820
我天生就有Lisp的能力来做过程组合.
So I automatically have Lisp's ability to do procedure composition.

582
00:57:32,920 --> 00:57:35,820
这不需要我专门为图像语言在做什么特殊的事情.
And I didn't have to make that specifically in the picture language.

583
00:57:35,820 --> 00:57:39,920
事实上，这些组合本身就是过程.
It's automatic from the fact that the means of combination are themselves procedures.

584
00:57:40,960 --> 00:57:44,180
假设我想做一些更复杂的事情
Or suppose I wanted to do something a little bit more complicated.

585
00:57:44,180 --> 00:57:50,080
我想为这里的每一个传递一个参数，我可以独立的做旋转90度的操作
I wanted to put in a parameter so that for each of these, I could independently specify a rotation by 90 degrees.

586
00:57:50,080 --> 00:57:52,760
这只需要我在这个过程中加入一个参数
That's just putting a parameter in the procedure.

587
00:57:52,760 --> 00:57:54,760
It's automatically there.

588
00:57:54,800 --> 00:57:57,840
对，它自动就嵌入进去了
Right, it automatically comes from the embedding.

589
00:57:58,160 --> 00:58:05,360
甚至，假设我想使用递归
Or even more, suppose I wanted to, you know, use recursion.

590
00:58:06,160 --> 00:58:10,780
我们看一下图片组合的递归
Let's look at a recursive means of combination on pictures.

591
00:58:10,780 --> 00:58:19,140
我来定义--我们来看，如果你可以理解这个是什么 -- 假设我定义right-push一个图片.
I could say define-- let's see if you can figure out what this one is-- suppose I say define what it means to right-push a picture,

592
00:58:22,840 --> 00:58:29,800
right-push需要一个图片,一个整数N,一个缩放因数A.
right-push a picture and some integer N and some scale factor A.

593
00:58:31,460 --> 00:58:41,220
如果n等于0，那么我的定义就返回这个图片本身
I'll define this to say if N equals 0, then the answer is the picture.

594
00:58:42,200 --> 00:58:54,020
否则，就-- oops，这里是p(教授笔误)
Otherwise I'm going to put-- oops, name change: P.

595
00:58:55,880 --> 00:59:18,520
否则，我用P，把它放到beside的返回值中，这个返回值递归的进行(right-push P (- n 1) a) .
Otherwise, I'm going to take P and put it beside the results of recursively right-pushing P with N minus 1 and A and use a scale factor of A. OK,

596
00:59:24,720 --> 00:59:31,120
所以，如果n等于0，那么就返回P，否则就对P进行a 倍缩放
so if N 0 , it's P. Otherwise I put P with a scale factor of A--

597
00:59:31,120 --> 00:59:32,800
对不起，我不能把这些代码写成一行---
I'm sorry I didn't align this right--

598
00:59:32,800 --> 00:59:38,500
递归的调用(right-push p (- n 1) a),并将结果(递归的)用beside连接
recursively beside the result of right-pushing P, N minus 1 times with a scale factor of A.

599
00:59:38,500 --> 00:59:42,000
这就是一个递归组合方法
There's a recursive means of combination.

600
00:59:43,600 --> 00:59:44,760
它看起来像什么呢？
What's that look like?

601
00:59:44,760 --> 00:59:46,040
我们来看看
Well, here's what it looks like.

602
00:59:46,040 --> 00:59:56,140
这是对George图片应用过程right-pushed 2次，放缩因数是0.75的结果
There's George right-pushed against himself twice with a scale factor of 0.75.

603
00:59:59,260 --> 01:00:00,720
这个是从什么地方来的呢？
Where'd that come from?

604
01:00:00,720 --> 01:00:02,340
我是如何想象的出来这些递归的呢？
How did I get all this fancy recursion?

605
01:00:02,340 --> 01:00:05,240
答案是无意识的，绝对是无意识的
And the answer is just automatic, absolutely automatic.

606
01:00:05,240 --> 01:00:09,800
因为他们都是过程,而且嵌入在(现有的Lisp中)，我当然可以定义递归过程
Since these are procedures, the embedding says, well sure, I can define recursive procedures.

607
01:00:10,160 --> 01:00:11,800
我没有特意去做这个.
I didn't have to arrange that.

608
01:00:13,560 --> 01:00:16,420
当然，我们可以根据这些做更加复杂的事情
And of course, we can do more complicated things of the same sort.

609
01:00:16,420 --> 01:00:18,420
我可以定义过程叫做up-push.
I could make something that does an up-push.

610
01:00:18,420 --> 01:00:22,600
对，它可以递归的把图片放在原来的上面
Right, that sort of goes like this, by recursively putting something above.

611
01:00:22,600 --> 01:00:26,560
或者我也可以用这种策略来做一些其它事情
Or I could make something that, sort of, was this scheme.

612
01:00:26,560 --> 01:00:39,300
我可以用一个图片开始，然后递归的把它放在原始图片的旁边和上面，这里可以放一些别的
I might start out with a picture and then, sort of, recursively both push it aside and above, and that might put something there.

613
01:00:39,300 --> 01:00:44,200
然后在这个上面，我递归的做同样的事情。我可以像这样结束它
And then up here I put the same recursive thing, and I might end up with something like this.

614
01:00:45,400 --> 01:00:52,500
对，这个过程比right-push复杂一点，但是也没有复杂很多
Right, so there's a procedure that's a little bit more complicated than right-push but not much.

615
01:00:53,640 --> 01:00:58,140
我就是做了above和beside,而不仅仅是beside.
I just do an Above and a Beside, rather than just a Beside.

616
01:01:01,120 --> 01:01:14,240
现在，如果我利用把四个图片放在一起的想法,我确实可以这样做,我把它应用在Q上,这个我们之前定义过
Now if I take that and apply that with the idea of putting four pictures together, which I can surely do; and I go and I apply that to Q, which we defined before, right,

617
01:01:15,900 --> 01:01:25,540
生成的结果是: 两次"正方形极限".
what I end up with this is this thing, which is, sort of, the square limit of Q, done twice.

618
01:01:28,180 --> 01:01:34,740
好，我们现在来对比一下Escher的"正方形极限",大家可以看到，这都是基于同样的思想.
Right, and then we can compare that with Escher's "Square Limit." And you see, it's sort of the same idea.

619
01:01:34,740 --> 01:01:36,940
Escher的图像，当然更加漂亮一些
Escher's is, of course, much, much prettier.

620
01:01:36,940 --> 01:01:44,260
如果我们会过头看George,
If we go back and look at George, right, if we go look at George here--

621
01:01:44,260 --> 01:01:49,260
看，我最开始使用的是一个非常随意的设计,这张George的图片,并且用这个图片做了一些事情
see, I started with a fairly arbitrary design, this picture of George and did things with it.

622
01:01:51,040 --> 01:01:53,280
对，我们回头看Escher的图片，
Right, whereas if we go look at the Escher picture, right,

623
01:01:54,080 --> 01:01:56,140
Escher的图片不是随意设计的
the Escher picture is not an arbitrary design.

624
01:01:56,140 --> 01:02:05,340
它是一个非常非常聪明的图案，当你把这个鱼身体旋转，并且对它进行放缩，它变换成另一个非常好看的图像
It's this very, very clever thing, so that when you take this fish body and Rotate it and shrink it down, it bleeds into the next one really nicely.

625
01:02:07,400 --> 01:02:11,480
当然用George，我没有做像上面做的那些事情
And of course with George, I didn't really do anything like that.

626
01:02:12,120 --> 01:02:18,640
如果我仔细看George, 它也有一些地方可以匹配的，但是不够好。它确实很随意(意思是图片进行变换后很突兀，不能融为一体)
So if we look at George, right, there's a little bit of match up, but not very nice, and it's pretty arbitrary.

627
01:02:18,640 --> 01:02:27,540
顺便说一下，这是一个非常好的项目，可以写一些过程把一些基本的图形传入进去，就像George一样
One very nice project, by the way, would be to write a procedure that could take some basic figure like this George thing

628
01:02:27,540 --> 01:02:34,140
然后开始对图像中的每一条线进行移动,你完全可以获得一个非常漂亮的图案。就像"正方形极限"这个过程一样
and start moving the ends of the lines around, so you got a really nice one when you went and did that "Square Limit" process.

629
01:02:34,140 --> 01:02:36,740
这是一个非常值得思考的事情.
That'd be a really nice thing to think about.

630
01:02:38,080 --> 01:02:39,720
同时，我还可以进行组合.
Well so, we can combine things.

631
01:02:39,720 --> 01:02:41,040
我们还可以使用递归过程
We can recursive procedures.

632
01:02:41,040 --> 01:02:43,640
我们可以做任何事情，并且他们都是自然而然的
We can do all kinds of things, and that's all automatic.

633
01:02:44,500 --> 01:02:50,440
对，重点是，其中的区别仅仅是在一个语言中实现一些东西还是在一个语言中嵌入一些东西
Right, the important point, the difference between merely implementing something in a language and embedding something in the language,

634
01:02:50,440 --> 01:02:57,620
(嵌入到语言中)可以让你不丢失原有语言的能力，Lisp很强大的地方就是，Lisp是一个强悍的语言可以处理任何特殊问题.
so that you don't lose the original power of the language, and what Lisp is great at, see Lisp is a lousy language for doing any particular problem.

635
01:02:57,620 --> 01:03:02,100
把你想要的语言嵌入到Lisp中才是真的好
What it's good for is figuring out the right language that you want and embedding that in Lisp.

636
01:03:02,100 --> 01:03:05,440
这才是设计这个方法的真正的力量
That's the real power of this approach to design.

637
01:03:05,440 --> 01:03:06,820
当然，我门可以继续下去
Of course, we can go further.

638
01:03:06,820 --> 01:03:17,520
看，大家看，我们可以用列表做的事情是 -- 抽取做事情的通用方法，就像高阶过程一样
See, you saw the other thing that we can do in List is capture general methods of doing things as higher order procedures.

639
01:03:18,860 --> 01:03:26,720
大家刚才跟着我画了这个图像可能已经理解了我的想法：right-push和类似的过程，你放一些东西在上面，上面。。。
And you probably just from me drawing it got the idea that right-push and the analogous thing where you push something up and up and up and up

640
01:03:26,720 --> 01:03:33,820
在这个角落放所有一般化(通用)的想法
and this corner push thing are all generalizations of a common kind of idea.

641
01:03:34,540 --> 01:03:47,520
大家仔细想象一下然后自己再实践一下使用复杂的高阶过程，我来给大家展示一下把组合放进去递归的基本思想
So just to illustrate and give you practice in looking at a fairly convoluted use of higher order procedures, let me show you the general idea of pushing some means of combination to recursively repeat it.

642
01:03:48,300 --> 01:03:50,900
这是一个很好的解惑的例子
So here's a good one to puzzle out.

643
01:03:51,220 --> 01:04:00,700
我们用组合方法来定义这个push方法
We'll define it what it means to push using a means of combination.

644
01:04:01,360 --> 01:04:05,060
comb是像beside或者above一样的过程
Comb is going to be something like the Beside or Above.

645
01:04:05,880 --> 01:04:07,060
我们来看看它要做什么
Well what's that going to be.

646
01:04:07,060 --> 01:04:12,060
它是一个过程，记得beside其实也是一个过程
That's going to be a procedure, remember what Beside actually was, right.

647
01:04:13,120 --> 01:04:18,240
它使用一个图片，(不)用两个图片和一个缩放因子
It took a picture, took two pictures and a scale factor.

648
01:04:18,480 --> 01:04:24,280
利用这个过程，我创造了一个带一个数字，一个图片和一个缩放因子的(过程)
Using that I produced something that took a level number and a picture and a scale factor,

649
01:04:24,280 --> 01:04:25,660
我把它定义为right-push.
that I called right-push.

650
01:04:26,160 --> 01:04:33,660
它需要一个图片，一个数字，和一个缩放因子来进行处理
So this is going to be something that takes a picture, a level number and a scale factor, and it's going to say--

651
01:04:36,160 --> 01:04:39,120
我使用了一些重复的操作
I'm going to do some repeated operation.

652
01:04:39,120 --> 01:04:59,420
我将重复的应用这个过程，这个过程需要一个图片，和一个组合方法,还有原始图片,和在这里的缩放因子
I'm going to repeatedly apply the procedure which takes a picture and applies the means of combination to the picture and the original picture and the one I took in here and the scale factor,

653
01:05:02,100 --> 01:05:16,420
还有我要循环的次数n.我把整个事情都作用在原始图像上面
and I do the thing which repeats this procedure N times, and I apply that whole thing to my original picture.

654
01:05:19,360 --> 01:05:34,320
这里进行循环，这种情况大家还没有看到，是另一个高阶过程需要一个过程和一个数字;它返回另一个过程。返回的过程对这个过程应用n次
Repeated here, in case you haven't seen it, is another higher order procedure that takes a procedure and a number and returns for you another procedure that applies this procedure N times.

655
01:05:35,860 --> 01:05:43,220
我想大家已经写过循环作为练习了，如果还没有，这是一个非常好的例子用来思考高阶过程
And I think some of you have already written repeated as an exercise, but if you haven't, it's a very good exercise in thinking about higher order procedures.

656
01:05:43,720 --> 01:05:46,980
但是在任何情况下，这个循环的结果都是我应用到图片的过程
But in any case, the result of this repeated is what I apply to picture.

657
01:05:49,260 --> 01:06:13,300
做完这些，可以提取出来的是--我从beside的基本想法到right-push的基本想法。所以做完这个,我可以说,定义right-push来表示对beside做push.
And having done that, that's going to capture-- that is the thing, the way I got from the idea of Beside to the idea of right-push So having done that, I could say define right-push to be push of Beside.

658
01:06:17,420 --> 01:06:26,860
如果我说，定义个up-push来对beside做push, 我使用几何公式,或者定义corner-push来push那些相似的东西，比如beside和above,或者我可以push任何东西
Or if I say, define up-push to be push of Beside, I'd get the analogous thing or define corner-push to be push of some appropriate thing that did both the Beside and Above, or I could push anything.

659
01:06:28,080 --> 01:06:34,760
无论如何，如果你对lambda还不太熟悉，这个是一个非常好的练习来让大家体会这其中的意义
Anyway this is, if you're having trouble with lambdas, this is an excellent exercise in figuring out what this means.

660
01:06:38,840 --> 01:06:41,200
从这个例子以引申出很多的练习
OK, well there's a lot to learn from this example.

661
01:06:42,100 --> 01:06:49,800
我想要介绍的主要是在一个语言中嵌入另一个语言
The main point I've been welling on is the notion of nicely embedding a language inside another language.

662
01:06:50,540 --> 01:07:00,420
这样所有这门语言的能力，像围绕着Lisp的语言，可以被别的语言访问，可以作为天然的扩展
Right, so that all the power of this language like Lisp of the surrounding language is still accessible to you and appears as a natural extension of the language that you built.

663
01:07:00,420 --> 01:07:04,100
这个例子很好的展示了这点
That's one thing that this example shows very well.

664
01:07:07,900 --> 01:07:10,940
另一个事情是，如果你回头去想
Another thing is, if you go back and think about that,

665
01:07:10,940 --> 01:07:12,280
什么是过程什么是数据
what's procedures and what's data.

666
01:07:12,280 --> 01:07:16,200
到现在， 天啊， 到底发生了什么
You know, by the time we get up to here, my God, what's going on.

667
01:07:16,200 --> 01:07:19,660
我的意思是，这是一个过程，它需要一个图片和一个参数
I mean, this is some procedure, and it takes a picture and an argument,

668
01:07:19,660 --> 01:07:20,360
但是，什么是图片呢
and what's a picture.

669
01:07:20,360 --> 01:07:23,820
图片本身，你记得，也是一个过程，它需要一个矩形
Well, a picture itself, as you remember, was a procedure, and that took a rectangle.

670
01:07:23,820 --> 01:07:25,820
这个矩形是某种抽象
And a rectangle is some abstraction.

671
01:07:25,820 --> 01:07:33,740
我希望到现在大家可以完全丢掉在这个系统中什么是过程，什么是数据的疑问
And I hope now that by now you're completely lost as to the question of what in the system is procedure and what's data.

672
01:07:33,740 --> 01:07:34,780
大家可以看到，这没有任何区别
You see, there isn't any difference.

673
01:07:35,080 --> 01:07:36,780
真的没有区别
There really isn't.

674
01:07:37,680 --> 01:07:41,840
你可以认为有时候图片是一个过程，有时候是数据
And you might think of a picture sometimes as a procedure and sometimes as data,

675
01:07:41,840 --> 01:07:44,900
但是，你知道，那仅仅是让你感觉舒服一点点的方式
but that's just, sort of, you know, making you feel comfortable.

676
01:07:44,900 --> 01:07:47,640
这有一定道理，也没有道理
It's really both in some sense or neither in some sense.

677
01:07:49,920 --> 01:08:14,200
还有更普遍关于创造一门语言系统结构的观点：通过看工程师设计的过程来创造一门语言，或者创造一些语言的层级
OK, there's a more general point about the structure of the system as creating a language, viewing the engineering design process as one of creating language or rather one of creating a sort of sequence of layers of language.

678
01:08:14,560 --> 01:08:24,900
你看，这里有一个方法论，或者我应该说是神话，姑且叫做”软件工程“
You see, there's this methodology, or maybe I should say mythology, that's, sort of, charitably called software, quote, engineering.

679
01:08:25,040 --> 01:08:28,040
它所说的很好，你来处理你的任务，
All right, and what does it say, it's says well, you go and you figure out your task,

680
01:08:28,040 --> 01:08:30,040
你仅仅解决你要做的事情
and you figure out exactly what you want to do.

681
01:08:30,400 --> 01:08:34,540
一但你弄明白你要做的东西，你发现它变成了三个子问题，
And once you figure out exactly what you want to do, you find out that it breaks out into three sub-tasks,

682
01:08:34,540 --> 01:08:38,940
然后你开始继续做---你开始处理这些子问题，然后你明确的发现它是什么
and you go and you start working on-- and you work on this sub-task, and you figure out exactly what that is.

683
01:08:38,940 --> 01:08:43,040
这些子问题就分裂成三个子问题，你完全把它们处理完.
And you find out that that breaks down into three sub-tasks, and you specify them completely,

684
01:08:43,040 --> 01:08:47,320
然后你继续处理剩下的两个，然后你处理这个子问题，然后处理这个.
and you go and you work on those two, and you work on this sub-one, and you specify that exactly.

685
01:08:47,320 --> 01:08:51,100
然后你最终完成了你要做的，你回到了这里，然后你开始处理你的第二个子问题
And then finally when you're done, you come back way up here, and you work on your second sub-task,

686
01:08:51,100 --> 01:08:53,400
然后把它详细的实现出来
and specify that out and work it out.

687
01:08:53,400 --> 01:08:57,640
然后你结束-- 你完成了这个美丽的大厦
And then you end up with-- you end up at the end with this beautiful edifice.

688
01:08:57,640 --> 01:09:08,240
对，你完成了这个不寻常的树，你把问题分成子问题的时候，然后你把这些子问题分成了更小的子问题，然后把他们又分成了更小的问题.
Right, you end up with a marvelous tree, where you've broken your task into sub-tasks and broken each of these into sub-tasks and broken those into sub-tasks, right.

689
01:09:09,880 --> 01:09:18,640
然后非常准确的定义了这些节点，他们都是构建这个大厦的完美任务.
And each of these nodes is exactly and precisely defined to do the wonderful, beautiful task to make it fit into the whole edifice, right.

690
01:09:18,640 --> 01:09:21,140
这个就是我说的神话
That's this mythology.

691
01:09:21,140 --> 01:09:26,160
只有计算机科学家才可能相信你构建的复杂系统想这个样子
See only a computer scientist could possibly believe that you build a complex system like that, right.

692
01:09:27,860 --> 01:09:32,800
我们用Henderson的例子来做对比,
Contrast that with this Henderson example.

693
01:09:32,800 --> 01:09:34,300
它不是这样工作的
It didn't work like that.

694
01:09:35,060 --> 01:09:39,900
事实是：这里有一个语言层次的序列
What happened was that there was a sequence of layers of language.

695
01:09:40,920 --> 01:09:42,180
它是什么？
What happened?

696
01:09:42,180 --> 01:09:48,760
这里有一层允许我们构建基本图像
There was a layer of a thing that allowed us to build primitive pictures.

697
01:09:51,500 --> 01:09:56,240
这个是基本图像，这就是个语言
There's primitive pictures and that was a language.

698
01:09:56,240 --> 01:09:58,020
我这里不多说了
I didn't say much about it.

699
01:09:58,020 --> 01:10:05,180
我们说一下如何构造George.这是一个语言,这个语言中有向量，线段，点，和它们做存在其中的正方形单元.
We talked about how to construct George, but that was a language where you talked about vectors and line segments and points and where they sat in the unit square.

700
01:10:06,160 --> 01:10:08,740
在那的上面
And then on top of that, right, on top of that--

701
01:10:09,840 --> 01:10:14,280
这个是这个语言的基本图片
so this is the language of primitive pictures.

702
01:10:16,680 --> 01:10:20,560
谈论的图片中的线段在这个正方体单元中,
Right, talking about line segments in particular pictures in the unit square.

703
01:10:21,400 --> 01:10:23,800
在这个上面是整个的语言
On top of that was a whole language.

704
01:10:23,800 --> 01:10:46,500
有一个几何组合的语言，几何位置的语言，它讨论的是像above和beside，right-push，rotate这样的东西
There was a language of geometric combinators, a language of geometric positions, which talks about things like Above and Beside and right-push and Rotate.

705
01:10:48,040 --> 01:10:55,700
这些事情恰巧与我们在这个语言中谈论的事情有关
And those things, sort of, happened with reference to the things that are talked about in this language.

706
01:10:55,700 --> 01:11:15,100
只要我们愿意，我们可以在这个语言之上创造很多语言规则的组合
And then if we like, we saw that above that there was sort of a language of schemes of combination.

707
01:11:20,980 --> 01:11:27,880
比如push,用一个放缩因子重复的做一个事情.
For example, push, which talked about repeatedly doing something over with a scale factor.

708
01:11:28,380 --> 01:11:34,540
我们正在讨论的在那个语言中的东西正是我这里写下来的东西.
And the things that were being discussed in that language were, sort of, the things that happened down here.

709
01:11:36,060 --> 01:11:47,300
在每个层次上都存在已经讨论过的对象，这些对象可以从前一个层级构建出来
So what you have is, at each level, the objects that are being talked about are the things that were erected the previous level.

710
01:11:48,080 --> 01:11:52,060
这个和这个有什么区别呢？
What's the difference between this thing and this thing?

711
01:11:53,100 --> 01:12:05,460
答案是：在这个树里,实际上,每一个节点的每一次分解，都是为了特殊的任务在做设计,
The answer is that over here in the tree, each node, and in fact, each decomposition down here, is being designed to do a specific task,

712
01:12:07,220 --> 01:12:15,120
而在这里,你有在每个层级上的完完全全的语言层面的能力.
whereas in the other scheme, what you have is a full range of linguistic power at each level.

713
01:12:15,820 --> 01:12:22,940
看看这里会发生什么 在任何一个层次，这里都不是建立一个特殊的任务
See what's happening there, at any level, it's not being set up to do a particular task.

714
01:12:22,940 --> 01:12:26,740
它是建立要做事情整个范围
It's being set up to talk about a whole range of things.

715
01:12:27,500 --> 01:12:35,940
结论是：这种设计方法更加健壮，
The consequence of that for design is that something that's designed in that method is likely to be more robust,

716
01:12:36,380 --> 01:12:45,200
健壮，我的意思是,在你的描述中做一些改变，可以提取出相关的变化，
where by robust, I mean that if you go and make some change in your description, it's more likely to be captured by a corresponding change,

717
01:12:45,200 --> 01:12:56,620
使用这种方式，语言可以在下一个层级实现，因为你已经把这个层级的事情做完了
in the way that the language is implemented at the next level up, right, because you've made these levels full.

718
01:12:56,620 --> 01:12:59,660
所以你不需要讨论像beside这样的特殊东西
So you're not talking about a particular thing like Beside.

719
01:12:59,660 --> 01:13:07,020
你创造了如何去表达事情的词汇，所以如果明确的改变你的定义，
You've given yourself a whole vocabulary to express things of that sort, so if you go and change your specifications a little bit,

720
01:13:07,020 --> 01:13:15,020
很可能你的方法论需要随之更改来适应这种变化 因为这种设计不够健壮
it's more likely that your methodology will able to adapt to capture that change, whereas a design like this is not going to be robust,

721
01:13:15,020 --> 01:13:21,800
因为如果我在这里改变一些东西 这将影响它向下的路径中的所有分解出来的东西 (影响它)下面的树
because if I go and change something that's in here, that might affect the entire way that I decomposed everything down, further down the tree.

722
01:13:23,000 --> 01:13:29,740
最大的不同就是分解 语言分层级还是严格的分层
Right, so very big difference in outlook in decomposition, levels of language rather than, sort of, a strict hierarchy.

723
01:13:30,220 --> 01:13:38,740
不仅这个如此 当你有一个多层的语言的时候 你会为不同的层次起不同的词汇
Not only that, but when you have levels of language you've given yourself a different vocabularies for talking about the design at different levels.

724
01:13:38,740 --> 01:13:48,680
所以如果我们回头再看一次George 如果我想改变这个图像George 看 我有完全不同的方式来表述这个变化
So if we go back and look at George one last time, if I wanted to change this picture George, see suddenly I have a whole different ways of describing the change.

725
01:13:48,680 --> 01:13:56,080
比如 我也许想要在基本的设计中修改一些向量的端点
Like for example, I may want to go to the basic primitive design and move the endpoint of some vector.

726
01:13:57,760 --> 01:14:00,760
这个变化在最低的层次
That's a change that I would discuss at the lowest level.

727
01:14:00,760 --> 01:14:02,760
我可以说端点在某个地方
I would say the endpoint is somewhere else.

728
01:14:03,100 --> 01:14:10,940
或许我可以上来说 我想做的下一个事情是：这个重复的元素 我想用其他方式来实现
Or I might come up and say, well the next thing I wanted to do, this little replicated element, I might want to do by something else.

729
01:14:10,940 --> 01:14:13,840
我可能想把一个放缩因子放入那个beside中
I might want to put a scale factor in that Beside.

730
01:14:13,840 --> 01:14:19,340
这个变化我可以在为下一个层次的设计时讨论---组合的层次
That's a change that I would discuss at the next level of design, the level of combinators.

731
01:14:19,340 --> 01:14:30,640
或者我想说 我想改变这个基本的方法 我用这个模式然后做一些递归分解 也许不会 #TBD 后面的不知道怎么翻译
Or I might want to say, I might want to change the basic way that I took this pattern and made some recursive decomposition, maybe not bleeding out toward the corners or something else.

732
01:14:31,160 --> 01:14:34,180
这个会改变我所讨论的最高的层次
That would be a change that I would discuss at the highest level.

733
01:14:34,180 --> 01:14:42,480
因为我是用这种方式构建系统的 我有全部的词汇来用不同的方式实现(我说的)并且有很大的灵活性来让我决定那个更合适
And because I've structured the system to be this way, I have all these vocabularies for talking about change in different ways and a lot of flexibility to decide which one's appropriate.

734
01:14:44,560 --> 01:14:54,380
在软件方法学中的一个很大的不同是--来自于Lisp 全部来自于概念
OK, well that's sort of a big point about the difference in software methodology that comes out from Lisp, and it all comes, again, out of the notion that really,

735
01:14:54,380 --> 01:14:59,620
在设计的过程中 没有那么多的实现的程序作为实现的语言
the design process is not so much implementing programs as implementing languages.

736
01:14:59,620 --> 01:15:04,020
这就是Lisp的力量 好的 谢谢
And that's really the powerful of Lisp. OK, thank you.

