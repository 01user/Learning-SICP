1
00:00:00,000 --> 00:000:00,000
哈尔滨工业大学 IBM技术中心
倾情制作

2
00:00:00,000 --> 00:000:00,000
压制&&特效：（Tacitus）
字幕&&时间轴：曹竞帆（ChingfanTsou）

3
00:00:00,000 --> 00:000:00,000
特别感谢：裘宗燕

4
00:00:00,000 --> 00:000:00,000
[音乐]
[MUSIC PLAYING BY J.S. BACH]

5
00:00:00,000 --> 00:000:00,000
教授 大家好
PROFESSOR: Hi.

6
00:00:00,000 --> 00:000:00,000
大家都已经知道 程序员的工作
You've seen that the job of a programmer

7
00:00:00,000 --> 00:000:00,000
就是设计出能够达成特定目标的程序
is to design processes that accomplish particular goals,

8
00:00:00,000 --> 00:000:00,000
比如求出一个数的平方根
such as finding the square roots of numbers,

9
00:00:00,000 --> 00:000:00,000
或者其它一些你想要做的事
or other sorts of things you might want to do.

10
00:00:00,000 --> 00:000:00,000
目前为止我们还没介绍别的什么东西
We haven't introduced anything else yet.

11
00:00:00,000 --> 00:000:00,000
当然了
Of course,

12
00:00:00,000 --> 00:000:00,000
程序员完成工作的方式就是构造“咒语”
the way in which a programmer does this is by constructing spells,

13
00:00:00,000 --> 00:000:00,000
通过过程和表达式构造出来的“咒语”
which are constructed out of procedures and expressions.

14
00:00:00,000 --> 00:000:00,000
这些“咒语”一定程度上指明了
And that these spells are somehow direct a process

15
00:00:00,000 --> 00:000:00,000
程序员想要的达成目标的方式
to accomplish the goal that was intended by the programmer.

16
00:00:00,000 --> 00:000:00,000
程序员为了使整个过程变得高效
In order for the programmer to do this effectively,

17
00:00:00,000 --> 00:000:00,000
必须理解他写下的代码
he has to understand the relationship

18
00:00:00,000 --> 00:000:00,000
这些“咒语”
between the particular things that he writes,

19
00:00:00,000 --> 00:000:00,000
和他想要控制的程序的行为
these particular spells,

20
00:00:00,000 --> 00:000:00,000
之间的联系
and the behavior of the process that he's attempting to control.

21
00:00:00,000 --> 00:000:00,000
所以我们在这门课中要做的就是试图
So what we're doing this lecture is attempt to

22
00:00:00,000 --> 00:000:00,000
以尽可能清晰的方式建立这样的联系
establish that connection in as clear a way as possible.

23
00:00:00,000 --> 00:000:00,000
我们尤其要理解
What we will particularly do is understand

24
00:00:00,000 --> 00:000:00,000
特定过程和表达式的模式
how particular patterns of procedures and expressions

25
00:00:00,000 --> 00:000:00,000
将会导致怎样的特定程序执行模式
cause particular patterns of execution,

26
00:00:00,000 --> 00:000:00,000
和计算过程的特定的行为
particular behaviors from the processes.

27
00:00:00,000 --> 00:000:00,000
让我们开始吧
Let's get down to that.

28
00:00:00,000 --> 00:000:00,000
我将会从一个非常简单的程序开始
I'm going to start with a very simple program.

29
00:00:00,000 --> 00:000:00,000
这是一个计算两个数的平方和的程序
This is a program to compute the sum of the squares of two numbers.

30
00:00:00,000 --> 00:000:00,000
我们将x和y的平方和定义为
And we'll define the sum of the squares of x and y to be

31
00:00:00,000 --> 00:000:00,000
x的平方
the sum of the square of x

32
00:00:00,000 --> 00:000:00,000
我这么写
-- I'm going to write it that way--

33
00:00:00,000 --> 00:000:00,000
和y的平方的和
and the square of y,

34
00:00:00,000 --> 00:000:00,000
x的平方是指x和x的乘积
where the square of x is the product of x and x.

35
00:00:00,000 --> 00:000:00,000
现在 设想这么一件事
Now,supposing I were to say something to this,

36
00:00:00,000 --> 00:000:00,000
比如 在这个程序这么定义好之后
like,to the system after having defined these things,

37
00:00:00,000 --> 00:000:00,000
跟据定义的形式 求3和4的平方和
of the form,the sum of the squares of 3 and 4,

38
00:00:00,000 --> 00:000:00,000
我希望得到25
I am hoping that I will get out a 25.

39
00:00:00,000 --> 00:000:00,000
因为3的平方是9
Because the square of 3 is 9,

40
00:00:00,000 --> 00:000:00,000
4的平方是16
and the square of 4 is 16,

41
00:00:00,000 --> 00:000:00,000
它们的和是25
and 25 is the sum of those.

42
00:00:00,000 --> 00:000:00,000
但这都是怎么回事呢
But how does that happen?

43
00:00:00,000 --> 00:000:00,000
如果我们要理解程序的执行以及它的控制方法
If we're going to understand processes and how we control them,

44
00:00:00,000 --> 00:000:00,000
那么我们就得把过程的机制
then we have to have a mapping from the mechanisms of this procedure

45
00:00:00,000 --> 00:000:00,000
与过程执行时所产生的行为对应起来
into the way in which these processes behave.

46
00:00:00,000 --> 00:000:00,000
我们将要得到的是一个正式的
What we're going to have is a formal,

47
00:00:00,000 --> 00:000:00,000
或者说半正式的机械的模型
or semi-formal mechanical model,

48
00:00:00,000 --> 00:000:00,000
你要理解计算机如何事实上 大体上实现这个机制
whereby you understand how a machine could,in fact,in principle,do this.

49
00:00:00,000 --> 00:000:00,000
不论实际的计算机究竟是怎么实现的
Whether or not the actual machine really does

50
00:00:00,000 --> 00:000:00,000
我此刻要告诉你们的都与实际的实现完全没有关系
what I'm about to tell you is completely irrelevant at this moment.

51
00:00:00,000 --> 00:000:00,000
实际上 这是一个工程模型
In fact,this is an engineering model

52
00:00:00,000 --> 00:000:00,000
就好像电阻
in the same way that,electrical resistor,

53
00:00:00,000 --> 00:000:00,000
我们写出一个模型V=IR
we write down a model v equals i r,

54
00:00:00,000 --> 00:000:00,000
这基本上是正确的
it's approximately true.

55
00:00:00,000 --> 00:000:00,000
但不是完全正确的
It's not really true.

56
00:00:00,000 --> 00:000:00,000
当电流通过电阻时 电阻会增加
If I put up current through the resistor it goes boom.

57
00:00:00,000 --> 00:000:00,000
所以电压并不总与电流成线性关系
So the voltage is not always proportional to the current,

58
00:00:00,000 --> 00:000:00,000
但是对于部分情况来说这个模型是适用的
but for some purposes the model is appropriate.

59
00:00:00,000 --> 00:000:00,000
比如我们将要介绍的这个模型
In particular,the model we're going to describe right now,

60
00:00:00,000 --> 00:000:00,000
我把这个模型称作代换模型
which I call the substitution model,

61
00:00:00,000 --> 00:000:00,000
这是我们能接触到的最简单的模型
is the simplest model that we have

62
00:00:00,000 --> 00:000:00,000
它可以帮助我们理解过程和程序执行的原理
for understanding how procedures work and how processes work.

63
00:00:00,000 --> 00:000:00,000
以及过程如何使得程序执行
How procedures yield processes.

64
00:00:00,000 --> 00:000:00,000
代换模型 对接下来几天
And that substitution model will be accurate

65
00:00:00,000 --> 00:000:00,000
我们将要接触到的东西都是适用的
for most of the things we'll be dealing with in the next few days.

66
00:00:00,000 --> 00:000:00,000
但最终 幻想总会破灭
But eventually,it will become impossible to sustain the illusion

67
00:00:00,000 --> 00:000:00,000
如果你认为计算机实际就是这么工作的
that that's the way the machine works,

68
00:00:00,000 --> 00:000:00,000
并且我们将要学习其它的更特殊的模型
and we'll go to other more specific and particular models

69
00:00:00,000 --> 00:000:00,000
届时会讨论更多的细节
that will show more detail.

70
00:00:00,000 --> 00:000:00,000
好了 接下来 我们来看下
OK,well,the first thing,of course,is we say,

71
00:00:00,000 --> 00:000:00,000
黑板上的这些内容
what are the things we have here?

72
00:00:00,000 --> 00:000:00,000
这里已经有了一些神秘的符号
We have some cryptic symbols.

73
00:00:00,000 --> 00:000:00,000
这些神秘的符号是由几块组成的
And these cryptic symbols are made out of pieces.

74
00:00:00,000 --> 00:000:00,000
还有几种表达式
There are kinds of expressions.

75
00:00:00,000 --> 00:000:00,000
现在我们看一看都有哪些类型的表达式
So let's write down here the kinds of expressions there are.

76
00:00:00,000 --> 00:000:00,000
有
And we have--

77
00:00:00,000 --> 00:000:00,000
首先有数字
and so far I see things like numbers.

78
00:00:00,000 --> 00:000:00,000
有像那样的符号
I see things like symbols like that.

79
00:00:00,000 --> 00:000:00,000
我们之前见过Lambda表达式
We have seen things before like lambda expressions,

80
00:00:00,000 --> 00:000:00,000
当然了没出现在黑板上
but they're not here.

81
00:00:00,000 --> 00:000:00,000
先撇开不谈
I'm going to leave them out.

82
00:00:00,000 --> 00:000:00,000
Lambda表达式
Lambda expressions,

83
00:00:00,000 --> 00:000:00,000
稍后再讨论
we'll worry about them later.

84
00:00:00,000 --> 00:000:00,000
还有定义
Things like definitions.

85
00:00:00,000 --> 00:000:00,000
还有条件表达式
Things like conditionals.

86
00:00:00,000 --> 00:000:00,000
最后还有组合式
And finally,things like combinations.

87
00:00:00,000 --> 00:000:00,000
这些表达式
These kinds of expressions are

88
00:00:00,000 --> 00:000:00,000
我们稍后再讨论 它们是特殊形式
-- I'll worry about later-- these are special forms.

89
00:00:00,000 --> 00:000:00,000
它们有一些专门的规则
There are particular rules for each of these.

90
00:00:00,000 --> 00:000:00,000
然而我要告诉你们的是 
I'm going to tell you,however,

91
00:00:00,000 --> 00:000:00,000
处理通常情况的规则
the rules for doing a general case.

92
00:00:00,000 --> 00:000:00,000
通常是怎样对一个组合式求值的
How does one evaluate a combination?

93
00:00:00,000 --> 00:000:00,000
因为 实际上 在黑板的那边 
Because,in fact,over here,

94
00:00:00,000 --> 00:000:00,000
全都是一些组合式以及一些符号和数字
all I really have are combinations and some symbols and numbers.

95
00:00:00,000 --> 00:000:00,000
而简单的 比如一个数字
And the simple things like a number,well,

96
00:00:00,000 --> 00:000:00,000
求值的结果就是这个数字所代表的数值
it will evaluate to itself.

97
00:00:00,000 --> 00:000:00,000
在我将要介绍的模型中
In the model I will have for you,

98
00:00:00,000 --> 00:000:00,000
符号的概念将不会出现
the symbols will disappear.

99
00:00:00,000 --> 00:000:00,000
只有当你需要了解
They won't be there at the time when you need them,

100
00:00:00,000 --> 00:000:00,000
当你需要真正理解它的时候才讨论
when you need to get at them.

101
00:00:00,000 --> 00:000:00,000
所以我只需要向大家讲解
So the only thing I really have to explain to you is,

102
00:00:00,000 --> 00:000:00,000
如何对组合式求值
how do we evaluate combinations?

103
00:00:00,000 --> 00:000:00,000
好吧 继续
OK,let's see

104
00:00:00,000 --> 00:000:00,000
先看下第一张幻灯片
So first I want to get the first slide.

105
00:00:00,000 --> 00:000:00,000
这是对一个表达式求值的规则
Here is the rule for evaluating an application.

106
00:00:00,000 --> 00:000:00,000
我们看到这条规则指出
What we have is a rule that says,

107
00:00:00,000 --> 00:000:00,000
要对一个组合式求值
to evaluate a combination,

108
00:00:00,000 --> 00:000:00,000
主要有三个部分
there are two parts,three parts to the rule.

109
00:00:00,000 --> 00:000:00,000
组合式有若干个部分
The combination has several parts.

110
00:00:00,000 --> 00:000:00,000
有运算符和运算对象
It has operators and it has operands.

111
00:00:00,000 --> 00:000:00,000
运算符返回一个过程
The operator returns into a procedure.

112
00:00:00,000 --> 00:000:00,000
也就是说如果我们对运算符求值
If we evaluate the operator,

113
00:00:00,000 --> 00:000:00,000
结果是一个过程
we will get a procedure.

114
00:00:00,000 --> 00:000:00,000
比如你们也看到了
And you saw,for example,

115
00:00:00,000 --> 00:000:00,000
我向计算机输入一个“+”
how I'll type "+" at the machine

116
00:00:00,000 --> 00:000:00,000
然后产生了一些复合的过程以及其它的一些东西
and out came compound procedure something or other.

117
00:00:00,000 --> 00:000:00,000
而对运算对象求值就会得到参数
And the operands produce arguments.

118
00:00:00,000 --> 00:000:00,000
一旦我们完成了对运算符的求值得到了一个过程
Once we've gotten the operator evaluated to get a procedure,

119
00:00:00,000 --> 00:000:00,000
并且对运算对象也完成求值得到了参数
and the argument is evaluated to get argument

120
00:00:00,000 --> 00:000:00,000
也就是运算对象作为参数的值
-- the operand's value to get arguments--

121
00:00:00,000 --> 00:000:00,000
我们通过复制过程体
we apply the procedure to these arguments

122
00:00:00,000 --> 00:000:00,000
来将其应用到这些参数上
by copying the body of the procedure,

123
00:00:00,000 --> 00:000:00,000
用术语来说 过程体指的就是定义这个过程的表达式
which is the expression that the procedure is defined in terms of.

124
00:00:00,000 --> 00:000:00,000
接下来要做的是
What is it supposed to do?

125
00:00:00,000 --> 00:000:00,000
用求得的实际参数代换过程的形式参数
Substituting the argument supplied for the formal parameters of the procedure,

126
00:00:00,000 --> 00:000:00,000
形式参数就是
the formal parameters being the names

127
00:00:00,000 --> 00:000:00,000
过程定义中声明的变量名
defined by the declaration of the procedure.

128
00:00:00,000 --> 00:000:00,000
然后我们对产生的新过程体求值
Then we evaluate the resulting new body,

129
00:00:00,000 --> 00:000:00,000
这个新过程体是由将代换模型应用到之前的过程体而产生的
the body resulting from copying the old body with the substitutions made.

130
00:00:00,000 --> 00:000:00,000
这个规则非常简单
It's a very simple rule,

131
00:00:00,000 --> 00:000:00,000
并且我们会非常形式化地应用这个规则一段时间
and we're going to do it very formally for a little while.

132
00:00:00,000 --> 00:000:00,000
因为接下来几节课
Because for the next few lectures,

133
00:00:00,000 --> 00:000:00,000
我想让各位做的是
what I want you to do is to say,

134
00:00:00,000 --> 00:000:00,000
如果有什么不能理解的
if I don't understand something,if I don't understand something,

135
00:00:00,000 --> 00:000:00,000
就直接机械化地应用这个规则
be very mechanical and do this.

136
00:00:00,000 --> 00:000:00,000
接下来
So let's see.

137
00:00:00,000 --> 00:000:00,000
考虑这么一个求值过程
Let's consider a particular evaluation,

138
00:00:00,000 --> 00:000:00,000
之前讨论过的
the one we were talking about before.

139
00:00:00,000 --> 00:000:00,000
3和4的平方和
The sum of the squares of 3 and 4.

140
00:00:00,000 --> 00:000:00,000
这是什么意思呢
What does that mean?

141
00:00:00,000 --> 00:000:00,000
这是说
It says,take

142
00:00:00,000 --> 00:000:00,000
其实 我已经知道求平方的过程是怎样的
-- well,I could find out what's on the square--

143
00:00:00,000 --> 00:000:00,000
是某个过程
it's some procedure,

144
00:00:00,000 --> 00:000:00,000
但我并不关心这个过程的具体表述
and I'm not going to worry about the representation,

145
00:00:00,000 --> 00:000:00,000
并且我也不会在黑板上写出来
and I'm not going to write it on the blackboard for you.

146
00:00:00,000 --> 00:000:00,000
还有3 代表某个数字
And I have that 3,represents some number,

147
00:00:00,000 --> 00:000:00,000
但如果要我重复这个数字
but if I have to repeat that number,

148
00:00:00,000 --> 00:000:00,000
我并不知道这个数字是什么
I can't tell you the number.

149
00:00:00,000 --> 00:000:00,000
这个数字本身是抽象的
The number itself is some abstract thing.

150
00:00:00,000 --> 00:000:00,000
只知道有个数词能代表它
There's a numeral which represents it,

151
00:00:00,000 --> 00:000:00,000
我把这个它叫作3
which I'll call 3,

152
00:00:00,000 --> 00:000:00,000
并且会在代换中用到它
and I'll use that in my substitution.

153
00:00:00,000 --> 00:000:00,000
4也是个数字
And 4 is also a number.

154
00:00:00,000 --> 00:000:00,000
我在这个过程体中用3代换x 用4代换y
I'm going to substitute 3 for x and 4 for y in the body of this procedure

155
00:00:00,000 --> 00:000:00,000
看黑板这里
that you see over here.

156
00:00:00,000 --> 00:000:00,000
这是过程体
Here's the body of the procedure.

157
00:00:00,000 --> 00:000:00,000
它关联到这个组合式
It corresponds to this combination,

158
00:00:00,000 --> 00:000:00,000
这个组合式是个求和过程
which is an addition.

159
00:00:00,000 --> 00:000:00,000
而它就转化成这样一个过程
So what that reduces to,

160
00:00:00,000 --> 00:000:00,000
我们把这个转化
as a reduction step,

161
00:00:00,000 --> 00:000:00,000
称为归约
we call it,

162
00:00:00,000 --> 00:000:00,000
这样就变成了求3和4的平方和
it's the sum of the square of 3 and the square of 4.

163
00:00:00,000 --> 00:000:00,000
接下来我要做的是
Now,what's the next step I have to do here?

164
00:00:00,000 --> 00:000:00,000
对它求值
I say,well,I have to evaluate this.

165
00:00:00,000 --> 00:000:00,000
根据之前给出的求值规则
According to my rule,

166
00:00:00,000 --> 00:000:00,000
就是各位刚刚在幻灯片上看到的
which you just saw on that overhead or slide,

167
00:00:00,000 --> 00:000:00,000
我们要对运算对象求值
what we had was that we have to evaluate the operands

168
00:00:00,000 --> 00:000:00,000
就是这些运算对象
-- and here are the operands,

169
00:00:00,000 --> 00:000:00,000
这是第一个运算对象 这是第二个运算对象
here's one and here's the next operand--

170
00:00:00,000 --> 00:000:00,000
我们还得对运算符求值
and how we have to evaluate procedure.

171
00:00:00,000 --> 00:000:00,000
对它们求值的顺序无关紧要
The order doesn't matter.

172
00:00:00,000 --> 00:000:00,000
然后我们要应用这个过程
And then we're going to apply the procedure,

173
00:00:00,000 --> 00:000:00,000
即求和过程
which is plus,

174
00:00:00,000 --> 00:000:00,000
然后很神奇的 不知怎么回事就能得到答案
and magically somehow that's going to produce the answer.

175
00:00:00,000 --> 00:000:00,000
我不会深究求和过程的实现
I'm not to open up plus and look inside of it.

176
00:00:00,000 --> 00:000:00,000
然而 为了对运算对象求值
However,in order to evaluate the operand,

177
00:00:00,000 --> 00:000:00,000
我们采用任意一种顺序来求值
let's pick some arbitrary order and do them.

178
00:00:00,000 --> 00:000:00,000
我会从右到左求值
I'm going to go from right to left.

179
00:00:00,000 --> 00:000:00,000
好了 为了对这个运算对象求值
Well,in order to evaluate this operand,

180
00:00:00,000 --> 00:000:00,000
我得用同样的规则对这运算对象的每个部分求值
I have to evaluate the parts of it by the same rule.

181
00:00:00,000 --> 00:000:00,000
首先需要弄清楚求平方是什么
And the parts are I have to find out what square is--

182
00:00:00,000 --> 00:000:00,000
是某个过程
it's some procedure,

183
00:00:00,000 --> 00:000:00,000
有个形式参数x
which has a formal parameter x.

184
00:00:00,000 --> 00:000:00,000
然后还有个运算对象是4
And also,I have an operand which is 4,

185
00:00:00,000 --> 00:000:00,000
用4代换求平方过程的形式参数x
which I have to substitute for x in the body of square.

186
00:00:00,000 --> 00:000:00,000
接下来基本上可以这么说
So the next step is basically to say that

187
00:00:00,000 --> 00:000:00,000
这就变成了求3的平方以及4与4乘积的和
this is the sum of the square of 3 and the product of 4 and 4.

188
00:00:00,000 --> 00:000:00,000
当然了 还可以接着深入分析乘法
Of course,I could open up asterisk if I liked

189
00:00:00,000 --> 00:000:00,000
这个求乘积的操作
-- the multiplication operation--

190
00:00:00,000 --> 00:000:00,000
但现在这个不重要
but I'm not going to do that.

191
00:00:00,000 --> 00:000:00,000
先把乘法过程看作是基本过程
I'm going to consider that primitive.

192
00:00:00,000 --> 00:000:00,000
其实 如果你深究计算机的抽象层次
And,of course,at any level of detail,if you look inside this machine,

193
00:00:00,000 --> 00:000:00,000
你会发现无论在具体哪一个层次
you're going to find that

194
00:00:00,000 --> 00:000:00,000
在其下都还有若干个你不清楚的抽象层次
there's multiple levels below that that you don't know about.

195
00:00:00,000 --> 00:000:00,000
但我们必须明白要学会忽略细节
But one of the things we have to learn how to do is ignore details.

196
00:00:00,000 --> 00:000:00,000
理解复杂事物的关键是
The key to understanding complicated things

197
00:00:00,000 --> 00:000:00,000
避免不必要的观察 计算和思考
is to know what not to look at and what not compute and what not to think.

198
00:00:00,000 --> 00:000:00,000
所以对这个乘法过程的细节我们不深入研究
So we're going to stop this one here and say,

199
00:00:00,000 --> 00:000:00,000
就直接看作两个数的乘积
oh,yes,this is the product of two things.

200
00:00:00,000 --> 00:000:00,000
现在把两个4乘起来
We're going to do it now.

201
00:00:00,000 --> 00:000:00,000
于是就有3的平方与16的和
So this is nothing more than the sum of the square of 3 and 16.

202
00:00:00,000 --> 00:000:00,000
还有一个求平方的表达式要求值
And now I have another thing I have to evaluate,

203
00:00:00,000 --> 00:000:00,000
注意这是3的平方
but that square of 3,

204
00:00:00,000 --> 00:000:00,000
这与之前求4的平方是一个过程
well,it's the same thing.

205
00:00:00,000 --> 00:000:00,000
于是整个表达式就变成了求3和3乘积与16的和
That's the sum of the product of 3 and 3 and 16,

206
00:00:00,000 --> 00:000:00,000
也就是求9和16的和 结果是25
which is the sum of 9 and 16,which is 25.

207
00:00:00,000 --> 00:000:00,000
大家现在看到了应用代换模型的基本方法
So now you see the basic method of doing substitutions.

208
00:00:00,000 --> 00:000:00,000
但我提醒大家
And I warn you that

209
00:00:00,000 --> 00:000:00,000
代换模型并不能准确描述计算机实际的运行方式
this is not a perfect description of what the computer does.

210
00:00:00,000 --> 00:000:00,000
但这个模型对于接下来几节课我们要讨论的问题
But it's a good enough description

211
00:00:00,000 --> 00:000:00,000
已经能描述得足够清楚
for the problems that we're going to have in the next few lectures

212
00:00:00,000 --> 00:000:00,000
你可以先认为这是正确的
that you should think about this religiously.

213
00:00:00,000 --> 00:000:00,000
认为计算机就是这么运行的
And this is how the machine works for now.

214
00:00:00,000 --> 00:000:00,000
之后我们的讨论会变得更加严谨
Later we'll get more detailed.

215
00:00:00,000 --> 00:000:00,000
好了 现在可以看到
Now,of course,

216
00:00:00,000 --> 00:000:00,000
我在这个例子中采用了从右到左的求值顺序
I made a specific choice of the order of evaluation here.

217
00:00:00,000 --> 00:000:00,000
当然还有别的选择
There are other possibilities.

218
00:00:00,000 --> 00:000:00,000
如果我们回过头来再看幻灯片
If we go back to the telestrator here

219
00:00:00,000 --> 00:000:00,000
上所写的代换模型应用规则
and look at the substitution rule,

220
00:00:00,000 --> 00:000:00,000
可以发现刚才我对运算符求值得到了一个过程
we see that I evaluated the operator to get the procedures,

221
00:00:00,000 --> 00:000:00,000
对运算对象求值得到了过程的实际参数
and I evaluated the operands to get the arguments first,

222
00:00:00,000 --> 00:000:00,000
然后才将参数应用到过程
before I do the application.

223
00:00:00,000 --> 00:000:00,000
这样做是完全可行的
It's entirely possible,

224
00:00:00,000 --> 00:000:00,000
还有别的求值顺序比如正则序求值
and there are alternate rules called normal order evaluation

225
00:00:00,000 --> 00:000:00,000
应用正则序你可以先用表达式去代换
whereby you can do the substitution of the expressions

226
00:00:00,000 --> 00:000:00,000
将其作为过程的形式参数的运算对象 然后再求值
which are the operands for the formal parameters inside the body first.

227
00:00:00,000 --> 00:000:00,000
这么做会得到同样的答案
And you'll get also the same answer.

228
00:00:00,000 --> 00:000:00,000
但是现在 考虑到实际情况
But right now,for concreteness,

229
00:00:00,000 --> 00:000:00,000
因为计算机实际是这么运行的
and because this is the way our machine really does it,

230
00:00:00,000 --> 00:000:00,000
我还是会给出在黑板上演示的方式
I'm going to give you this rule,

231
00:00:00,000 --> 00:000:00,000
这种方式给出了明确的顺序
which has a particular order.

232
00:00:00,000 --> 00:000:00,000
当然了这些顺序一定程度上也是灵活可变的
But that order is to some extent arbitrary,too.

233
00:00:00,000 --> 00:000:00,000
长远来看
In the long run,

234
00:00:00,000 --> 00:000:00,000
你采用哪种求值顺序来理解都有各自的理由
there are some reasons why you might pick one order or another,

235
00:00:00,000 --> 00:000:00,000
以后我们会继续讨论这个问题
and we'll get to that later in the subject.

236
00:00:00,000 --> 00:000:00,000
好了 为了让大家理解这都是怎么回事
OK,well now the only other thing I have to tell you

237
00:00:00,000 --> 00:000:00,000
还需要给大家介绍一个东西
about just to understand what's going on is

238
00:00:00,000 --> 00:000:00,000
来看幻灯片上对条件表达式的解释
let's look at the rule for conditionals.

239
00:00:00,000 --> 00:000:00,000
条件表达式很简单
Conditionals are very simple,

240
00:00:00,000 --> 00:000:00,000
我给大家详细解释一下
and I'd like to examine this.

241
00:00:00,000 --> 00:000:00,000
条件表达式就是if表达式
A conditional is something that is if

242
00:00:00,000 --> 00:000:00,000
当然还有cond表达式
-- there's also cond of course--

243
00:00:00,000 --> 00:000:00,000
我会把条件表达式各部分的名称都写下来
but I'm going to give names to the parts of the expression.

244
00:00:00,000 --> 00:000:00,000
首先有一个predicate表达式
There's a predicate,

245
00:00:00,000 --> 00:000:00,000
这是个求值结果为真或假的表达式
which is a thing that is either true or false.

246
00:00:00,000 --> 00:000:00,000
然后有一个consequent表达式
And there's a consequent,

247
00:00:00,000 --> 00:000:00,000
当predicate表达式的结果为真就对这个表达式求值
which is the thing you do if the predicate is true.

248
00:00:00,000 --> 00:000:00,000
还有个alternative表达式
And there's an alternative,

249
00:00:00,000 --> 00:000:00,000
当predicate表达式结果为假就对这个表达式求值
which is the thing you do if the predicate is false.

250
00:00:00,000 --> 00:000:00,000
顺便提一句
It's important,by the way,

251
00:00:00,000 --> 00:000:00,000
知道事物各部分的名称
to get names for,to get names for,

252
00:00:00,000 --> 00:000:00,000
或者表达式各部分的名称
the parts of things,

253
00:00:00,000 --> 00:000:00,000
很重要
or the parts of expressions.

254
00:00:00,000 --> 00:000:00,000
每个“魔法师”都会告诉你
One of the things that every sorcerer will tell you is

255
00:00:00,000 --> 00:000:00,000
如果你能叫出一个“精灵”的名字
if you have the name of a spirit,

256
00:00:00,000 --> 00:000:00,000
你就有控制它的能力
you have power over it.

257
00:00:00,000 --> 00:000:00,000
所以你得掌握这些名称
So you have to learn these names

258
00:00:00,000 --> 00:000:00,000
以便之后的讨论
so that we can discuss these things.

259
00:00:00,000 --> 00:000:00,000
现在我们有了一个predicate表达式
So here we have a predicate,

260
00:00:00,000 --> 00:000:00,000
一个consequent表达式
a consequent,

261
00:00:00,000 --> 00:000:00,000
还有个alternative表达式
and an alternative.

262
00:00:00,000 --> 00:000:00,000
用这些名称 我们发现对于一个if表达式
And,using such words,we see that an if expression,

263
00:00:00,000 --> 00:000:00,000
关键的问题是对predicate表达式的求值
the problems you evaluate to the predicate expression,

264
00:00:00,000 --> 00:000:00,000
如果结果为真
if that yields true,

265
00:00:00,000 --> 00:000:00,000
就对consequent表达式求值
then you then go on to evaluate the consequent.

266
00:00:00,000 --> 00:000:00,000
否则
Otherwise,

267
00:00:00,000 --> 00:000:00,000
就对alternative表达式求值
you evaluate the alternative expression.

268
00:00:00,000 --> 00:000:00,000
我想通过一个具体的程序
So I'd like to illustrate that

269
00:00:00,000 --> 00:000:00,000
来进一步说明这个问题
now in the context of a particular little program.

270
00:00:00,000 --> 00:000:00,000
就写一个我们会经常遇到的程序吧
Going to write down a program which we're going to see many times.

271
00:00:00,000 --> 00:000:00,000
这是由皮亚诺算术定义的求x和y之和的过程
This is the sum of x and y done by what's called Peano arithmetic,

272
00:00:00,000 --> 00:000:00,000
其实就是加1和减1
which is all we're doing is incrementing and decrementing.

273
00:00:00,000 --> 00:000:00,000
来看看这个
And we're going to see this for a little bit.

274
00:00:00,000 --> 00:000:00,000
这是个非常重要的程序
It's a very important program.

275
00:00:00,000 --> 00:000:00,000
如果x等于0
If x equals 0,

276
00:00:00,000 --> 00:000:00,000
那么结果就是y
then the result is y.

277
00:00:00,000 --> 00:000:00,000
否则
Otherwise,

278
00:00:00,000 --> 00:000:00,000
结果就是x减1与y加1的和
this is the sum of the decrement of x and the increment of y.

279
00:00:00,000 --> 00:000:00,000
以后我们会继续研究这个加法过程
We're going to look at this a lot more in the future.

280
00:00:00,000 --> 00:000:00,000
现在看前面
Let's look at the overhead.

281
00:00:00,000 --> 00:000:00,000
现在有了这么个过程
So here we have this procedure,

282
00:00:00,000 --> 00:000:00,000
我们看看怎么应用代换模型
and we're going to look at how we do the substitutions,

283
00:00:00,000 --> 00:000:00,000
以及代换的顺序
the sequence of substitutions.

284
00:00:00,000 --> 00:000:00,000
我现在想要求3和4的和
Well,I'm going to try and add together 3 and 4.

285
00:00:00,000 --> 00:000:00,000
根据我演示给大家步骤
Well,using the first rule that I showed you,

286
00:00:00,000 --> 00:000:00,000
第一步 在过程体中
we substitute 3 for x and 4 four y

287
00:00:00,000 --> 00:000:00,000
用3代换x 用4代换y
in the body of this procedure.

288
00:00:00,000 --> 00:000:00,000
过程体
The body of the procedure is the thing

289
00:00:00,000 --> 00:000:00,000
由if表达式开始 在这儿结束
that begins with if and finishes over here.

290
00:00:00,000 --> 00:000:00,000
于是我们就有了
So what we get is,

291
00:00:00,000 --> 00:000:00,000
如果3是0
of course,if 3 is 0,

292
00:00:00,000 --> 00:000:00,000
那么结果就是4
then the result is 4.

293
00:00:00,000 --> 00:000:00,000
否则
Otherwise,

294
00:00:00,000 --> 00:000:00,000
结果就是3减1
it's the sum of the decrement of 3

295
00:00:00,000 --> 00:000:00,000
与4加1的和
and the increment of 4.

296
00:00:00,000 --> 00:000:00,000
但这部份我不会去管它
But I'm not going to worry about these yet

297
00:00:00,000 --> 00:000:00,000
因为3不等于0
because 3 is not 0.

298
00:00:00,000 --> 00:000:00,000
于是答案不是4
So the answer is not 4.

299
00:00:00,000 --> 00:000:00,000
因此
Therefore,

300
00:00:00,000 --> 00:000:00,000
于是整个if表达式就可以归约成
this if reduces to

301
00:00:00,000 --> 00:000:00,000
对这个表达式的求值
an evaluation of the expression,

302
00:00:00,000 --> 00:000:00,000
求3减1
the sum to the decrement of 3

303
00:00:00,000 --> 00:000:00,000
与4加1的和
and the increment of 4.

304
00:00:00,000 --> 00:000:00,000
继续求值
Continuing with my evaluation,

305
00:00:00,000 --> 00:000:00,000
先认为加1的过程是基本过程
the increment I presume to be primitive,

306
00:00:00,000 --> 00:000:00,000
然后就有了5
and so I get a 5 there.

307
00:00:00,000 --> 00:000:00,000
同样把减1也认为是基本过程
OK,and then the decrement is also primitive,

308
00:00:00,000 --> 00:000:00,000
然后就有了2
and I get a 2.

309
00:00:00,000 --> 00:000:00,000
于是我把问题化简了
And so I change the problem into a simpler problem.

310
00:00:00,000 --> 00:000:00,000
不是3加4的问题了
Instead of adding 3 to 4,

311
00:00:00,000 --> 00:000:00,000
而是2加5的问题了
I'm adding 2 to 5.

312
00:00:00,000 --> 00:000:00,000
为什么这样就变简单了呢
The reason why this is a simpler problem

313
00:00:00,000 --> 00:000:00,000
因为我在减小x
is because I'm counting down on x,

314
00:00:00,000 --> 00:000:00,000
最终x会变为0
and eventually,then,x will be 0.

315
00:00:00,000 --> 00:000:00,000
这就是代换模型了
So,so much for the substitution rule.

316
00:00:00,000 --> 00:000:00,000
通常来讲
In general,

317
00:00:00,000 --> 00:000:00,000
在对if表达式使用代换模型的时候
I'm not going to write down intermediate steps

318
00:00:00,000 --> 00:000:00,000
我不会写下所有中间步骤
when using substitutions having to do with ifs,

319
00:00:00,000 --> 00:000:00,000
因为这么做只能把事情复杂化
because they just expand things to become complicated.

320
00:00:00,000 --> 00:000:00,000
我们要做的是
What we will be doing is saying,

321
00:00:00,000 --> 00:000:00,000
把求3和4的和
oh,yes,the sum of 3 and 4

322
00:00:00,000 --> 00:000:00,000
归约到求2和5的和
results in the sum of 2 and 5

323
00:00:00,000 --> 00:000:00,000
在那之后
and reduces to the sum of 2 and 5.

324
00:00:00,000 --> 00:000:00,000
归约到求1和6的和
which,in fact,reduces to the sum of 1 and 6,

325
00:00:00,000 --> 00:000:00,000
最后归约到求0和7的和
which reduces to the sum of 0 and 7

326
00:00:00,000 --> 00:000:00,000
看这儿
over here,

327
00:00:00,000 --> 00:000:00,000
最后归约到7
which reduces to a 7.

328
00:00:00,000 --> 00:000:00,000
这就是我们想要的结果
That's what we're going to be seeing.

329
00:00:00,000 --> 00:000:00,000
现在 各位对第一部分的内容有疑问么
Are there any questions for the first segment yet?

330
00:00:00,000 --> 00:000:00,000
请
Yes?

331
00:00:00,000 --> 00:000:00,000
学生 你用了1+过程和-1+过程
STUDENT: You're using 1 plus and minus 1 plus

332
00:00:00,000 --> 00:000:00,000
它们都是基本过程么
Are those primitive operations?

333
00:00:00,000 --> 00:000:00,000
教授 是的
PROFESSOR: Yes

334
00:00:00,000 --> 00:000:00,000
你们在这门课中要明白的是
One of the things you're going to be seeing in this subject

335
00:00:00,000 --> 00:000:00,000
我绝对不会考虑
is I'm going to,without thinking about it,

336
00:00:00,000 --> 00:000:00,000
给大家介绍越来越多的基本过程
introduce more and more primitive operations

337
00:00:00,000 --> 00:000:00,000
可以假定
There's presumably some large library

338
00:00:00,000 --> 00:000:00,000
有一些庞大的基本过程的程序库
of primitive operations somewhere.

339
00:00:00,000 --> 00:000:00,000
不用过分追究这些基本过程
But it doesn't matter that they're primitive--

340
00:00:00,000 --> 00:000:00,000
可能有一些手册有这些基本过程的索引便于我们查找
there may be some manual that lists them all.

341
00:00:00,000 --> 00:000:00,000
如果我向你解释基本过程的作用 你应该说
If I tell you what they do,you should say,

342
00:00:00,000 --> 00:000:00,000
啊 是这样 我明白它们的作用了
oh,yes,I know what they do.

343
00:00:00,000 --> 00:000:00,000
比如 这个减1的过程
So one of them is the decrementor

344
00:00:00,000 --> 00:000:00,000
-1+
-- minus 1 plus--

345
00:00:00,000 --> 00:000:00,000
另一个加1的过程
and the other operation is increment,

346
00:00:00,000 --> 00:000:00,000
1+
which is 1 plus.

347
00:00:00,000 --> 00:000:00,000
谢谢大家
Thank you.

348
00:00:00,000 --> 00:000:00,000
第一部分结束
That's the end of the first segment.

349
00:00:00,000 --> 00:000:00,000
[音乐]
[MUSIC PLAYING BY J.S. BACH]

350
00:00:00,000 --> 00:000:00,000
教授 现在我们有了一个合理的 机械的方式
PROFESSOR: Now that we have a reasonably mechanical way

351
00:00:00,000 --> 00:000:00,000
去理解一个由过程
of understanding how a program made out of procedures

352
00:00:00,000 --> 00:000:00,000
和表达式组成的程序是如何演化成计算过程的
and expressions evolves a process,

353
00:00:00,000 --> 00:000:00,000
我想要大家培养出一些直觉
I'd like to develop some intuition

354
00:00:00,000 --> 00:000:00,000
有关程序如何演化成计算过程的直觉
about how particular programs evolve particular processes,

355
00:00:00,000 --> 00:000:00,000
有关程序到底是什么“形状”的直觉
what the shapes of programs have to be

356
00:00:00,000 --> 00:000:00,000
这样才能产生特定“形状”的计算过程
in order to get particular shaped processes.

357
00:00:00,000 --> 00:000:00,000
这让我想到了 画面预览
This is a question about,really,pre-visualizing.

358
00:00:00,000 --> 00:000:00,000
这是个摄影专业术语
That's a word from photography.

359
00:00:00,000 --> 00:000:00,000
我曾经对摄影十分着迷
I used to be interested in photography a lot,

360
00:00:00,000 --> 00:000:00,000
你会发现
and one of the things you discover

361
00:00:00,000 --> 00:000:00,000
初学摄影的时候
when you start trying to learn about photography

362
00:00:00,000 --> 00:000:00,000
你很想成为一名有创意的摄影师
is that you say,gee,I'd like to be a creative photographer.

363
00:00:00,000 --> 00:000:00,000
我知道怎么做 按快门
Now,I know the rules,I push buttons,

364
00:00:00,000 --> 00:000:00,000
调整光圈什么的
and I adjust the aperture and things like that.

365
00:00:00,000 --> 00:000:00,000
但要想有创意
But the key to being a creative person,partly,

366
00:00:00,000 --> 00:000:00,000
一定程度上靠的是能在一定层次上进行分析
is to be able to do analysis at some level.

367
00:00:00,000 --> 00:000:00,000
比如 在按下快门前
To say,how do I know what it is

368
00:00:00,000 --> 00:000:00,000
我怎么知道交卷上最终是怎样的画面呢
that I'm going to get on the film before I push the button.

369
00:00:00,000 --> 00:000:00,000
我能在心中
Can I imagine in my mind

370
00:00:00,000 --> 00:000:00,000
非常准确清晰地刻画出拍好的照片么
the resulting image very precisely and clearly

371
00:00:00,000 --> 00:000:00,000
那精心地取景
as a consequence of the particular framing,

372
00:00:00,000 --> 00:000:00,000
仔细地调整光圈
of the aperture I choose,

373
00:00:00,000 --> 00:000:00,000
仔细地对焦
of the focus,

374
00:00:00,000 --> 00:000:00,000
而拍出来的照片
and things like that?

375
00:00:00,000 --> 00:000:00,000
一定程度来说 这就是摄影的艺术
That's part of the art of doing this sort of thing.

376
00:00:00,000 --> 00:000:00,000
而要掌握摄影的艺术牵涉到许多方面
And learning a lot of that

377
00:00:00,000 --> 00:000:00,000
比如曝光试验片
involves things like test strips.

378
00:00:00,000 --> 00:000:00,000
比如拍摄非常几张简单的画面
You take very simple images

379
00:00:00,000 --> 00:000:00,000
每张都有不同的影像密度
that have varying degrees of density in them,for example,

380
00:00:00,000 --> 00:000:00,000
然后把它们打印在一张纸上
and examine what those look like on a piece of paper

381
00:00:00,000 --> 00:000:00,000
观察它们都有什么不同
when you print them out.

382
00:00:00,000 --> 00:000:00,000
你能发现实际可见的对比度
You find out what is the range of contrasts

383
00:00:00,000 --> 00:000:00,000
都是怎样的范围内
that you can actually see.

384
00:00:00,000 --> 00:000:00,000
还能发现 从实际角度来讲
And what,in a real scene,

385
00:00:00,000 --> 00:000:00,000
都是哪些因素与同一张照片中不同层次
would correspond to the various levels

386
00:00:00,000 --> 00:000:00,000
不同区块的影像密度的产生有关
and zones that you have of density in an image.

387
00:00:00,000 --> 00:000:00,000
今天这节课我就想让大家看一些特别的“曝光试验片”
Well,today I want to look at some very particular test strips,

388
00:00:00,000 --> 00:000:00,000
下面通过幻灯片来看第一张
and I suppose one of them I see here is up on the telestrator,

389
00:00:00,000 --> 00:000:00,000
请看
so we should switch to that.

390
00:00:00,000 --> 00:000:00,000
有两个非常非常重要的程序
There's a very important,very important pair of programs

391
00:00:00,000 --> 00:000:00,000
用来理解在程序执行时
for understanding what's going on in the evolution of a process

392
00:00:00,000 --> 00:000:00,000
计算过程中的求值都是怎样的
by the execution of a program.

393
00:00:00,000 --> 00:000:00,000
大家看到的是两个几乎相同的过程
What we have here are two procedures that are almost identical.

394
00:00:00,000 --> 00:000:00,000
基本上没有区别
Almost no difference between them at all.

395
00:00:00,000 --> 00:000:00,000
只有几个字符不同
It's a few characters that distinguish them.

396
00:00:00,000 --> 00:000:00,000
这两个过程表示的是两种不同的求两数之和的方法
These are two ways of adding numbers together.

397
00:00:00,000 --> 00:000:00,000
第一个
The first one,

398
00:00:00,000 --> 00:000:00,000
看这里
which you see here,

399
00:00:00,000 --> 00:000:00,000
是求两数之和
the first one is the sum of two numbers

400
00:00:00,000 --> 00:000:00,000
和我们上节课讲到的一样
-- just what we did before--

401
00:00:00,000 --> 00:000:00,000
如果第一个参数是0
is if the first one is 0,

402
00:00:00,000 --> 00:000:00,000
第二个参数就是答案
it's the answer of the second one.

403
00:00:00,000 --> 00:000:00,000
否则
Otherwise,

404
00:00:00,000 --> 00:000:00,000
就是第一个参数减1
it's the sum of the decrement of the first

405
00:00:00,000 --> 00:000:00,000
和第二个参数加1的和
and the increment of the second.

406
00:00:00,000 --> 00:000:00,000
你可以这么考虑 有两堆弹珠
And you may think of that as having two piles.

407
00:00:00,000 --> 00:000:00,000
把这两堆加在一块儿形成新的一堆的办法就是
And the way I'm adding these numbers together to make a third pile is by

408
00:00:00,000 --> 00:000:00,000
把弹珠从一堆挪到另一堆去
moving marbles from one to the other.

409
00:00:00,000 --> 00:000:00,000
仅此而已
Nothing more than that.

410
00:00:00,000 --> 00:000:00,000
最终 有一堆会被搬空
And eventually,when I run out of one

411
00:00:00,000 --> 00:000:00,000
另一堆就是加和的结果了
then the other is the sum.

412
00:00:00,000 --> 00:000:00,000
然而 第二个过程不是这样做的
However,the second procedure here doesn't do it that way.

413
00:00:00,000 --> 00:000:00,000
它是这样做的 如果第一个参数是0
It says if the first number is 0,

414
00:00:00,000 --> 00:000:00,000
答案就是第二个
then the answer is the second.

415
00:00:00,000 --> 00:000:00,000
否则 
Otherwise,

416
00:00:00,000 --> 00:000:00,000
答案就是 第一个参数减1
it's the increment of the sum

417
00:00:00,000 --> 00:000:00,000
和第二个参数的和
of the decrement of the first number

418
00:00:00,000 --> 00:000:00,000
然后再加1
and the second.

419
00:00:00,000 --> 00:000:00,000
这种方式就是
So what this says is

420
00:00:00,000 --> 00:000:00,000
把第一个参数减1和第二个数加起来
add together the decrement of the first number and the second

421
00:00:00,000 --> 00:000:00,000
毫无疑问 简化了问题
-- a simpler problem,no doubt--

422
00:00:00,000 --> 00:000:00,000
然后把这个和再加1
and then change that result to increment it.

423
00:00:00,000 --> 00:000:00,000
这就意味着如果你用两堆弹珠的方式来思考
And so this means that if you think about this in terms of piles,

424
00:00:00,000 --> 00:000:00,000
就是说 我左手右手各有一堆弹珠
it means I'm holding in my hand the things to be added later.

425
00:00:00,000 --> 00:000:00,000
然后我要把它们加在一起
And then I'm going to add them in.

426
00:00:00,000 --> 00:000:00,000
然后我慢慢地把其中一堆搬空
As I slowly decrease one pile to 0,

427
00:00:00,000 --> 00:000:00,000
然后把这些拿出来的弹珠
I've got what's left here,

428
00:00:00,000 --> 00:000:00,000
再放回另一堆弹珠中
and then I'm going to add them back.

429
00:00:00,000 --> 00:000:00,000
两种不同的加法
Two different ways of adding.

430
00:00:00,000 --> 00:000:00,000
关于这两个程序 有趣的是
The nice thing about these two programs

431
00:00:00,000 --> 00:000:00,000
它们几乎一样
is that they're almost identical.

432
00:00:00,000 --> 00:000:00,000
唯一的区别是把加1这个过程放哪儿
The only thing is where I put the increment.

433
00:00:00,000 --> 00:000:00,000
把几个字符挪挪地方
A couple of characters moved around.

434
00:00:00,000 --> 00:000:00,000
现在我想弄明白
Now I want to understand the kind of behavior

435
00:00:00,000 --> 00:000:00,000
我们会从这两个程序中看到怎样的行为
we're going to get from each of these programs.

436
00:00:00,000 --> 00:000:00,000
加深大家对这个问题的印象
Just to get them firmly in your mind

437
00:00:00,000 --> 00:000:00,000
我通常不想这么谨慎
-- I usually don't want to be this careful--

438
00:00:00,000 --> 00:000:00,000
但是还是要加深大家的印象
but just to get them firmly in your mind,

439
00:00:00,000 --> 00:000:00,000
我在黑板上把程序再写一遍
I'm going to write the programs again on the blackboard,

440
00:00:00,000 --> 00:000:00,000
然后我会演化出一个计算过程
and then I'm going to evolve a process.

441
00:00:00,000 --> 00:000:00,000
大家都注意观察 看看是怎么回事
And you're going to see what happens.

442
00:00:00,000 --> 00:000:00,000
看看过程演化是怎样的“形状”
We're going to look at the shape of the process

443
00:00:00,000 --> 00:000:00,000
这是程序导致的一个结果
as a consequence of the program.

444
00:00:00,000 --> 00:000:00,000
我们从这个程序开始
So the program we started with is this:

445
00:00:00,000 --> 00:000:00,000
求x与y的和
the sum of x and y says

446
00:00:00,000 --> 00:000:00,000
如果x等于0
if x is 0,

447
00:00:00,000 --> 00:000:00,000
那么答案就是y
then the result is y.

448
00:00:00,000 --> 00:000:00,000
否则 
Otherwise,

449
00:00:00,000 --> 00:000:00,000
答案就是x减1和y加1的和
it's the sum of the decrement of x and the increment of y.

450
00:00:00,000 --> 00:000:00,000
现在 假设我们要求3与4的和
Now,supposing we wish to do this addition of 3 and 4,

451
00:00:00,000 --> 00:000:00,000
3与4的和
the sum of 3 and 4,

452
00:00:00,000 --> 00:000:00,000
接下来呢
well,what is that?

453
00:00:00,000 --> 00:000:00,000
我要代换这两个参数
It says that I have to substitute the arguments

454
00:00:00,000 --> 00:000:00,000
代换过程定义中的形式参数
for the formal parameters in the body.

455
00:00:00,000 --> 00:000:00,000
我在脑海中想像这个过程
I'm doing that in my mind.

456
00:00:00,000 --> 00:000:00,000
然后说 啊 这样
And I say,oh,yes,

457
00:00:00,000 --> 00:000:00,000
3代换了x
3 is substituted for x,

458
00:00:00,000 --> 00:000:00,000
但3不是0
but 3 is not 0,

459
00:00:00,000 --> 00:000:00,000
于是直接进入这一部分
so I'm going to go directly to this part

460
00:00:00,000 --> 00:000:00,000
然后只用关心这一部分就行
and write down the simplified consequent here.

461
00:00:00,000 --> 00:000:00,000
因为我只关心加法过程的行为
Because I'm really interested in the behavior of addition.

462
00:00:00,000 --> 00:000:00,000
好了 接下来
Well,what is that?

463
00:00:00,000 --> 00:000:00,000
就变成了求2和5的过程
That therefore turns into the sum of 2 and 5.

464
00:00:00,000 --> 00:000:00,000
换句话说
In other words,

465
00:00:00,000 --> 00:000:00,000
我把这个问题归约成这个问题
I've reduced this problem to this problem.

466
00:00:00,000 --> 00:000:00,000
然后我又把这个问题化归约成求1和6的和
Then I reduce this problem to the sum of 1 and 6,

467
00:00:00,000 --> 00:000:00,000
再接着归约
and then,going around again once,

468
00:00:00,000 --> 00:000:00,000
就有了0和7的和
I get the sum of 0 and 7.

469
00:00:00,000 --> 00:000:00,000
于是x就等于0了
And that's one where x equals 0

470
00:00:00,000 --> 00:000:00,000
答案是y
so the result is y,

471
00:00:00,000 --> 00:000:00,000
也就是7
and so I write down here a 7.

472
00:00:00,000 --> 00:000:00,000
这就是这个程序把3和4相加
So this is the behavior of the process evolved

473
00:00:00,000 --> 00:000:00,000
而演化出的计算过程的行为
by trying to add together 3 and 4 with this program.

474
00:00:00,000 --> 00:000:00,000
另一个程序
For the other program,

475
00:00:00,000 --> 00:000:00,000
写在这边
which is over here,

476
00:00:00,000 --> 00:000:00,000
如此定义x与y的和
I will define the sum of x and y.

477
00:00:00,000 --> 00:000:00,000
怎么定义的呢
And what is it?

478
00:00:00,000 --> 00:000:00,000
如果x是0
If x is 0,

479
00:00:00,000 --> 00:000:00,000
答案就是y
then the result is y

480
00:00:00,000 --> 00:000:00,000
这和上一个程序一样
-- almost the same--

481
00:00:00,000 --> 00:000:00,000
否则就是x减1与y的和
otherwise the increment of the sum

482
00:00:00,000 --> 00:000:00,000
再加上1
of the decrement of x and y.

483
00:00:00,000 --> 00:000:00,000
写错了 黑板不能自动匹配括号
No.I don't have my balancer in front of me.

484
00:00:00,000 --> 00:000:00,000
好了 接下来
OK,well,let's do it now.

485
00:00:00,000 --> 00:000:00,000
求3与4的和
The sum of 3 and 4.

486
00:00:00,000 --> 00:000:00,000
其实这样更有趣 来看
Well,this is actually a little more interesting.

487
00:00:00,000 --> 00:000:00,000
3当然不等于0 和之前一样
Of course,3 is not 0 as before,

488
00:00:00,000 --> 00:000:00,000
于是答案就是 x减1与y的和再加1
so that results in the increment of the sum of the decrement of x,

489
00:00:00,000 --> 00:000:00,000
也就是2与4的和
which is 2 and 4,

490
00:00:00,000 --> 00:000:00,000
接着变成 1与
which is the increment of the sum of 1 and--

491
00:00:00,000 --> 00:000:00,000
噢 弄错了 加1再加1
whoops: the increment of the increment.

492
00:00:00,000 --> 00:000:00,000
现在要做的是计算这一部分
What I have to do now is compute what this means.

493
00:00:00,000 --> 00:000:00,000
我要对这一部分求值
I have to evaluate this.

494
00:00:00,000 --> 00:000:00,000
也就是
Or what that is,

495
00:00:00,000 --> 00:000:00,000
用2和4代换x和y的结果
the result of substituting 2 and 4 for x and y here.

496
00:00:00,000 --> 00:000:00,000
变成了1与4的和再加1
But that is the increment of the sum of 1 and 4,

497
00:00:00,000 --> 00:000:00,000
现在我得展开这部份
which is-- well,now I have to expand this.

498
00:00:00,000 --> 00:000:00,000
啊 然后就变成了0与4的和加1加1
Ah,but that's the increment of the increment

499
00:00:00,000 --> 00:000:00,000
再加1
of the increment of the sum of 0 and 4.

500
00:00:00,000 --> 00:000:00,000
现在来看看都能做些什么
Ah,but now I'm beginning to find things I can do.

501
00:00:00,000 --> 00:000:00,000
加1加1再加1
The increment of the increment of the increment of--

502
00:00:00,000 --> 00:000:00,000
0和4的和是4
well,the sum of 0 and 4 is 4.

503
00:00:00,000 --> 00:000:00,000
4加1是5
The increment of 4 is 5.

504
00:00:00,000 --> 00:000:00,000
这就变成了5加1再加1
So this is the increment of the increment of 5,

505
00:00:00,000 --> 00:000:00,000
也就是6再加1
which is the increment of 6,

506
00:00:00,000 --> 00:000:00,000
最后答案就是7
which is 7.

507
00:00:00,000 --> 00:000:00,000
两种不同的求和方法
Two different ways of computing sums.

508
00:00:00,000 --> 00:000:00,000
现在来看看
Now,let's see.

509
00:00:00,000 --> 00:000:00,000
这两种计算过程有不同的“形状”
These processes have very different shapes.

510
00:00:00,000 --> 00:000:00,000
我想让各位去感受这些“形状”
I want you to feel these shapes.

511
00:00:00,000 --> 00:000:00,000
这种感觉很关键
It's the feeling for the shapes that matters.

512
00:00:00,000 --> 00:000:00,000
从这里我们能发现什么
What's some things we can see about this?

513
00:00:00,000 --> 00:000:00,000
不知怎么回事 这个有点“直”
Well somehow this is sort of straight.

514
00:00:00,000 --> 00:000:00,000
就这样一路直着下来
It goes this way-- straight.

515
00:00:00,000 --> 00:000:00,000
右边界并没有特别的变化
This right edge doesn't vary particularly in size.

516
00:00:00,000 --> 00:000:00,000
而这边这个呢
Whereas this one,

517
00:00:00,000 --> 00:000:00,000
右边界先变大又变小
I see that this thing gets bigger and then it gets smaller.

518
00:00:00,000 --> 00:000:00,000
我还不知道这意味着什么
So I don't know what that means yet,

519
00:00:00,000 --> 00:000:00,000
我们看到的是什么
but what are we seeing?

520
00:00:00,000 --> 00:000:00,000
是不知怎么回事
We're seeing here that somehow

521
00:00:00,000 --> 00:000:00,000
这些加1的过程先展开后收缩
these increments are expanding out and then contracting back.

522
00:00:00,000 --> 00:000:00,000
我构造出一个推迟进行的操作的链条
I'm building up a bunch of them to do later.

523
00:00:00,000 --> 00:000:00,000
我不能马上求值
I can't do them now.

524
00:00:00,000 --> 00:000:00,000
有的过程需要推迟
There's things to be deferred.

525
00:00:00,000 --> 00:000:00,000
好了 我们继续
Well,let's see,

526
00:00:00,000 --> 00:000:00,000
我可以想象一个抽象的计算机
I can imagine an abstract machine.

527
00:00:00,000 --> 00:000:00,000
也许能制造一些实际的计算机
There's some physical machine,

528
00:00:00,000 --> 00:000:00,000
能像我这样求值
perhaps,that could be built to do it,

529
00:00:00,000 --> 00:000:00,000
能像我演示给大家的一样执行程序
which,in fact,executes these programs exactly as I tell you,

530
00:00:00,000 --> 00:000:00,000
像这样代换字符串
substituting character strings in like this.

531
00:00:00,000 --> 00:000:00,000
这样的计算机
Such a machine,

532
00:00:00,000 --> 00:000:00,000
计算中的步骤与计算所花费的时间近似相等
the number of such steps is an approximation of the amount of time it takes.

533
00:00:00,000 --> 00:000:00,000
用纵轴表示时间
So this way is time.

534
00:00:00,000 --> 00:000:00,000
横轴的宽度表示
And the width of the thing is

535
00:00:00,000 --> 00:000:00,000
进行计算需要保存的信息量
how much I have to remember in order to continue the process.

536
00:00:00,000 --> 00:000:00,000
也就是表示进行计算所需要的空间
And this much is space.

537
00:00:00,000 --> 00:000:00,000
我们看到的是一个计算过程
And what we see here is a process

538
00:00:00,000 --> 00:000:00,000
其时间消耗正比于参数x
that takes a time which is proportional to the argument x.

539
00:00:00,000 --> 00:000:00,000
因为如果我让x增大一倍
Because if I made x larger by 1,

540
00:00:00,000 --> 00:000:00,000
就得把这个表示时间的纵轴再加长一倍
then I'd had an extra line.

541
00:00:00,000 --> 00:000:00,000
于是这就是个计算过程 它的空间 抱歉 时间
So this is a process which is space-- sorry-- time.

542
00:00:00,000 --> 00:000:00,000
这个计算过程消耗的时间为O(x)
The time of this process is what we say order of x.

543
00:00:00,000 --> 00:000:00,000
也就是正比于x
That means it is proportional to x by some constant of proportionality

544
00:00:00,000 --> 00:000:00,000
不要刻意追究这个常比例系数是多少
and I'm not particularly interested in what the constant is.

545
00:00:00,000 --> 00:000:00,000
我们还会发现
The other thing we see here is that

546
00:00:00,000 --> 00:000:00,000
这个计算过程消耗的空间是固定不变的
the amount of space this takes up is constant.

547
00:00:00,000 --> 00:000:00,000
即与1成正比
it's proportional to 1.

548
00:00:00,000 --> 00:000:00,000
于是这个计算过程的空间复杂度就是O(1)的
So the space complexity of this is order of 1.

549
00:00:00,000 --> 00:000:00,000
对这样的计算过程我们有个名字
We have a name for such a process.

550
00:00:00,000 --> 00:000:00,000
叫迭代计算过程
Such a process is called an iteration.

551
00:00:00,000 --> 00:000:00,000
关键的地方
And what matters here

552
00:00:00,000 --> 00:000:00,000
不是什么我设计的
is not that some particular machine I designed here

553
00:00:00,000 --> 00:000:00,000
之前提到的
and talked to you about

554
00:00:00,000 --> 00:000:00,000
代换字符计算机
and called a substitution machine

555
00:00:00,000 --> 00:000:00,000
或者 代换模型
or whatever-- substitution model--

556
00:00:00,000 --> 00:000:00,000
怎么设法在常数空间复杂度内完成计算过程
managed to do this in constant space.

557
00:00:00,000 --> 00:000:00,000
关键的地方是这给出了一个界限
What really matters is this tells us a bound.

558
00:00:00,000 --> 00:000:00,000
任何计算机都应该在常数空间复杂度内完成计算过程
Any machine could do this in constant space.

559
00:00:00,000 --> 00:000:00,000
这个过程代表的算法
This algorithm represented by this procedure

560
00:00:00,000 --> 00:000:00,000
在常数空间复杂度内是可执行的
is executable in constant space.

561
00:00:00,000 --> 00:000:00,000
当然了这种说法忽略了一些细节
Now,of course,the model is ignoring some things,

562
00:00:00,000 --> 00:000:00,000
却量化了一些东西
standard sorts of things.

563
00:00:00,000 --> 00:000:00,000
忽略了比如数值越大越消耗空间等等
Like numbers that are bigger take up more space and so on.

564
00:00:00,000 --> 00:000:00,000
但那确实是抽象过程中我要忽略的一个层次
But that's a level of abstraction at which I'm cutting off.

565
00:00:00,000 --> 00:000:00,000
如何表示数值
How do you represent numbers?

566
00:00:00,000 --> 00:000:00,000
我假定所有的数值都占用同样大小的存储空间
I'm considering every number to be the same size.

567
00:00:00,000 --> 00:000:00,000
事实上数值的增大和它们占用的存储空间的增加都非常缓慢
And numbers grow slowly for the amount of space they take up and their size.

568
00:00:00,000 --> 00:000:00,000
而这个算法的复杂度就不同了
Now,this algorithm is different in its complexity.

569
00:00:00,000 --> 00:000:00,000
我们看到
As we can see here,

570
00:00:00,000 --> 00:000:00,000
这个算法时间复杂度
this algorithm has a time complexity

571
00:00:00,000 --> 00:000:00,000
也是正比于输入参数x的
which is also proportional to the input argument x.

572
00:00:00,000 --> 00:000:00,000
因为如果我把这个3再加1
That's because if I were to add 1 to 3,

573
00:00:00,000 --> 00:000:00,000
如果我把问题规模扩大
if I made a larger problem

574
00:00:00,000 --> 00:000:00,000
扩大了1
which is larger by 1 here,

575
00:00:00,000 --> 00:000:00,000
那我就要在上面再加一行
then I'd add a line at the top

576
00:00:00,000 --> 00:000:00,000
在底下再加一行
and I'd add a line at the bottom.

577
00:00:00,000 --> 00:000:00,000
而且事实上这是个常量
And the fact that it's a constant amount,

578
00:00:00,000 --> 00:000:00,000
就像这个计算过程的步骤数是那个的两倍
like this is twice as many lines as that

579
00:00:00,000 --> 00:000:00,000
我不会关心这个层次的细节 也不会关心那个常量
is not interesting at the level of detail I'm talking about right now.

580
00:00:00,000 --> 00:000:00,000
所以这个计算过程的时间复杂度也是O(x)
So this is a time complexity order of the input argument x.

581
00:00:00,000 --> 00:000:00,000
而空间复杂度呢
And space complexity,

582
00:00:00,000 --> 00:000:00,000
这个比较有趣
well,this is more interesting.

583
00:00:00,000 --> 00:000:00,000
有一些东西是固定不变的
I happen to have some overhead,

584
00:00:00,000 --> 00:000:00,000
比如这些
which you see over here,

585
00:00:00,000 --> 00:000:00,000
是近似保持不变的
which is constant approximately.

586
00:00:00,000 --> 00:000:00,000
是常量的
Constant overhead.

587
00:00:00,000 --> 00:000:00,000
但也有一些增加和减少
But then I have something which increases and decreases

588
00:00:00,000 --> 00:000:00,000
是正比于参数x的
and is proportional to the input argument x.

589
00:00:00,000 --> 00:000:00,000
输入参数x是3
The input argument x is 3.

590
00:00:00,000 --> 00:000:00,000
也就是这里为何有3个推迟操作的加1过程
That's why there are three deferred increments sitting around here.

591
00:00:00,000 --> 00:000:00,000
发现了么
See?

592
00:00:00,000 --> 00:000:00,000
于是这个计算过程的空间复杂度也是O(x)的
So the space complexity here is also order x.

593
00:00:00,000 --> 00:000:00,000
这种计算过程
And this kind of process,

594
00:00:00,000 --> 00:000:00,000
给它取个名字
named for the kind of process,

595
00:00:00,000 --> 00:000:00,000
是递归计算过程
this is a recursion.

596
00:00:00,000 --> 00:000:00,000
更准确地来说
A linear recursion

597
00:00:00,000 --> 00:000:00,000
是线性递归计算过程
I will call it.

598
00:00:00,000 --> 00:000:00,000
因为它的时间和空间复杂度
because of the fact that it's proportional

599
00:00:00,000 --> 00:000:00,000
都是正比于输入参数的
to the input argument in both time and space.

600
00:00:00,000 --> 00:000:00,000
那么这个就可以称为一个线性迭代过程
This could have been a linear iteration.

601
00:00:00,000 --> 00:000:00,000
那么 这两种计算过程的本质是什么
So then what's the essence of this matter?

602
00:00:00,000 --> 00:000:00,000
不太容易看出来
This matter isn't so obvious.

603
00:00:00,000 --> 00:000:00,000
可能还有别的模型
Maybe there are other models

604
00:00:00,000 --> 00:000:00,000
可以用来描述
by which we can describe the differences

605
00:00:00,000 --> 00:000:00,000
迭代和递归计算过程的不同之处
between iterative and recursive processes.

606
00:00:00,000 --> 00:000:00,000
但这就有些困难了
Because this is hard now.

607
00:00:00,000 --> 00:000:00,000
记住
Remember,

608
00:00:00,000 --> 00:000:00,000
这两种计算过程都是递归定义的
we have-- those are both recursive definitions.

609
00:00:00,000 --> 00:000:00,000
我们看到的是
What we're seeing there

610
00:00:00,000 --> 00:000:00,000
两种过程在定义上都使用了递归
are both recursive definitions,

611
00:00:00,000 --> 00:000:00,000
也就是两个过程的定义中都引用了该过程本身
definitions that refer to the thing being defined in the definition.

612
00:00:00,000 --> 00:000:00,000
但是它们却产生了不同“形状”的计算过程
But they lead to different shape processes.

613
00:00:00,000 --> 00:000:00,000
过程定义是递归的
There's nothing special about the fact

614
00:00:00,000 --> 00:000:00,000
而产生的计算过程也是递归的
that the definition is recursive

615
00:00:00,000 --> 00:000:00,000
这没什么特别的
that leads to a recursive process.

616
00:00:00,000 --> 00:000:00,000
好了 来看看另一种有趣的解释
OK.Let's think of another model.

617
00:00:00,000 --> 00:000:00,000
我会和大家谈谈 官僚主义
I'm going to talk to you about bureaucracy.

618
00:00:00,000 --> 00:000:00,000
官僚主义 挺有趣儿的
Bureaucracy is sort of interesting.

619
00:00:00,000 --> 00:000:00,000
在幻灯片上我们看到有关迭代计算过程的解释
Here we see on a slide an iteration.

620
00:00:00,000 --> 00:000:00,000
迭代是一种挺好玩儿的计算过程
An iteration is sort of a fun kind of process.

621
00:00:00,000 --> 00:000:00,000
想象一下有个叫GJS的家伙
Imagine that there's a fellow called GJS

622
00:00:00,000 --> 00:000:00,000
也就是我
-- that stands for me--

623
00:00:00,000 --> 00:000:00,000
遇到了一个问题
and he's got a problem:

624
00:00:00,000 --> 00:000:00,000
他想求3与4的和
he wants to add together 3 and 4.

625
00:00:00,000 --> 00:000:00,000
这个家伙想把3和4加一块儿
This fella here wants to add together 3 and 4.

626
00:00:00,000 --> 00:000:00,000
他打算这么办
Well,the way he's going to do it

627
00:00:00,000 --> 00:000:00,000
他挺懒的
-- he's lazy--

628
00:00:00,000 --> 00:000:00,000
他想找别人帮忙
is he's going to find somebody else to help him do it.

629
00:00:00,000 --> 00:000:00,000
他是这样找人帮忙的
The way he finds someone else to--

630
00:00:00,000 --> 00:000:00,000
他找了个人帮忙 对他说
he finds someone else to help him do it and says,

631
00:00:00,000 --> 00:000:00,000
算出3和4的和
well,give me the answer to 3 and 4

632
00:00:00,000 --> 00:000:00,000
然后把答案返回给我
and return the result to me.

633
00:00:00,000 --> 00:000:00,000
他写了一张小纸递给这个人条然后说
He makes a little piece of paper and says,

634
00:00:00,000 --> 00:000:00,000
给 这是一张纸条
here,here's a piece of paper--

635
00:00:00,000 --> 00:000:00,000
你去解决这个问题
you go ahead and solve this problem

636
00:00:00,000 --> 00:000:00,000
然后把答案返回给我
and give the result back to me.

637
00:00:00,000 --> 00:000:00,000
而这个找来帮忙的家伙呢
And this guy,

638
00:00:00,000 --> 00:000:00,000
也很懒
of course,is lazy,too.

639
00:00:00,000 --> 00:000:00,000
他可不想再看见这张小纸条了
He doesn't want to see this piece of paper again.

640
00:00:00,000 --> 00:000:00,000
他说 啊 好吧
He says,oh,yes,

641
00:00:00,000 --> 00:000:00,000
然后出了个新问题
produce a new problem

642
00:00:00,000 --> 00:000:00,000
是求2和5的和
which is the sum of 2 ad 5

643
00:00:00,000 --> 00:000:00,000
并把答案返回给GJS
and return the result back to GJS.

644
00:00:00,000 --> 00:000:00,000
我不想再看见这张纸条了
I don't want to see it again.

645
00:00:00,000 --> 00:000:00,000
这个家伙不想再看见这张纸条了
This guy does not want to see this piece of paper.

646
00:00:00,000 --> 00:000:00,000
于是就出了一个新问题
And then this fellow makes a new problem,

647
00:00:00,000 --> 00:000:00,000
也就是求1与6的和的问题
which is the addition of the sum of 1 and 6,

648
00:00:00,000 --> 00:000:00,000
他又把纸条传给了这个家伙 并说到
and he give it to this fella and says,

649
00:00:00,000 --> 00:000:00,000
算出答案然后把答案告诉GJS
produce that answer and returned it to GJS.

650
00:00:00,000 --> 00:000:00,000
那个家伙又接着出了个新问题
And that produces a problem,

651
00:00:00,000 --> 00:000:00,000
求0与7的和
which is to add together 0 and 7

652
00:00:00,000 --> 00:000:00,000
然后把答案返回给GJS
and give the result to GJS.

653
00:00:00,000 --> 00:000:00,000
最后这个家伙直接说
This fella finally just says,

654
00:00:00,000 --> 00:000:00,000
啊 好吧 答案是7
oh,yeah,the answer is 7,

655
00:00:00,000 --> 00:000:00,000
然后把答案返回给了GJS
and sends it back to GJS.

656
00:00:00,000 --> 00:000:00,000
迭代计算过程就是这样的
That's what an iteration is.

657
00:00:00,000 --> 00:000:00,000
相对而言
By contrast,

658
00:00:00,000 --> 00:000:00,000
递归计算过程就有些不同了
a recursion is a slightly different kind of process.

659
00:00:00,000 --> 00:000:00,000
它更加“官僚主义”
This one involves more bureaucracy.

660
00:00:00,000 --> 00:000:00,000
它使得更多的人变得忙碌
It keeps more people busy.

661
00:00:00,000 --> 00:000:00,000
更多的人被雇佣
It keeps more people employed.

662
00:00:00,000 --> 00:000:00,000
当然了也许能增加就业使这种方法更好
Perhaps it's better for that reason.

663
00:00:00,000 --> 00:000:00,000
请看幻灯片
But here it is:

664
00:00:00,000 --> 00:000:00,000
我想要知道3与4的和
I want the answer to the problem 3 and 4.

665
00:00:00,000 --> 00:000:00,000
于是写了张纸条 说到
So I make a piece of paper that says,

666
00:00:00,000 --> 00:000:00,000
把答案返回给我
give the result back to me.

667
00:00:00,000 --> 00:000:00,000
然后我把纸条给了这个家伙
Give it to this fella.

668
00:00:00,000 --> 00:000:00,000
这个家伙说
This fellow says,

669
00:00:00,000 --> 00:000:00,000
好吧我会记得
oh,yes,I will remember

670
00:00:00,000 --> 00:000:00,000
一会儿要加1
that I have to add later,

671
00:00:00,000 --> 00:000:00,000
而我又得知道2加4的和是多少
and I want to get the answer the problem 2 plus 4,

672
00:00:00,000 --> 00:000:00,000
于是把这个问题给了Harry
give that one to Harry,

673
00:00:00,000 --> 00:000:00,000
然后把结果返回给我 Joe
and have the results sent back to me-- I'm Joe.

674
00:00:00,000 --> 00:000:00,000
一旦Harry返回了答案
When the answer comes back from Harry,

675
00:00:00,000 --> 00:000:00,000
也就是6
which is a 6,

676
00:00:00,000 --> 00:000:00,000
我就会把答案加1
I will then do the increment

677
00:00:00,000 --> 00:000:00,000
然后把结果返回给GJS
and give that 7 back to GJS.

678
00:00:00,000 --> 00:000:00,000
大家可以发现 在递归计算过程中 需要保留的纸条
So there are more pieces of paper outstanding

679
00:00:00,000 --> 00:000:00,000
比迭代计算过程的多
in the recursive process than the iteration.

680
00:00:00,000 --> 00:000:00,000
还有一种方法可以用来理解迭代计算过程
There's another way to think about what an iteration is

681
00:00:00,000 --> 00:000:00,000
以及迭代计算过程和递归计算过程的不同之处
and the difference between an iteration and a recursion.

682
00:00:00,000 --> 00:000:00,000
问题的关键在于
You see,the question is,

683
00:00:00,000 --> 00:000:00,000
有多少东西是不可见的
how much stuff is under the table?

684
00:00:00,000 --> 00:000:00,000
如果我要停止
If I were to stop--

685
00:00:00,000 --> 00:000:00,000
假设我现在要关闭计算机
supposing I were to kill this computer right now,OK?

686
00:00:00,000 --> 00:000:00,000
此时我丢失了事务的状态
And at this point I lose the state of affairs,

687
00:00:00,000 --> 00:000:00,000
但我能接着进行运算
well,I could continue the computation from this point

688
00:00:00,000 --> 00:000:00,000
因为继续运算所需要的所有信息都在参数变量中
cause everything I need to continue the computation is in the variables

689
00:00:00,000 --> 00:000:00,000
即程序员编写过程时定义的变量
that were defined in the procedure that the programmer wrote for me.

690
00:00:00,000 --> 00:000:00,000
迭代计算过程能用明确的变量保存计算过程中的状态
An iteration is a system that has all of its state in explicit variables.

691
00:00:00,000 --> 00:000:00,000
这一点递归计算过程就不同
Whereas the recursion is not quite the same.

692
00:00:00,000 --> 00:000:00,000
如果我弄丢了这堆垃圾
If I were to lose this pile of junk over here

693
00:00:00,000 --> 00:000:00,000
那就只剩下求1与4的和了
and all I was left with was the sum of 1 and 4,

694
00:00:00,000 --> 00:000:00,000
这些信息不足以继续
that's not enough information to continue the process

695
00:00:00,000 --> 00:000:00,000
从初始的求3与4的和的问题
of computing out the 7 from the original problem

696
00:00:00,000 --> 00:000:00,000
求出7的计算过程
of adding together 3 of 4.

697
00:00:00,000 --> 00:000:00,000
除了保存在过程中的
Besides the information that's in the variables

698
00:00:00,000 --> 00:000:00,000
形式参数变量中的信息
of the formal parameters of the program,

699
00:00:00,000 --> 00:000:00,000
计算机还保存了一些不可见的信息
there is also information under the table belonging to the computer,

700
00:00:00,000 --> 00:000:00,000
也就是都有哪些过程被推迟计算了
which is what things have been deferred for later.

701
00:00:00,000 --> 00:000:00,000
当然了
And,of course,

702
00:00:00,000 --> 00:000:00,000
有个实际的比喻
there's a physical analogy to this,

703
00:00:00,000 --> 00:000:00,000
比如微分方程
which is in differential equations,for example,

704
00:00:00,000 --> 00:000:00,000
当我们说到画一个圆的时候
when we talk about something like drawing a circle.

705
00:00:00,000 --> 00:000:00,000
试图画一个圆
Try to draw a circle,

706
00:00:00,000 --> 00:000:00,000
你从一个微分方程中解得它
you make that out of a differential equation

707
00:00:00,000 --> 00:000:00,000
即状态的改变是我当前状态的一个函数
which says the change in my state as a function of my current state.

708
00:00:00,000 --> 00:000:00,000
于是如果我当前的状态由y和x的特定值表征
So if my current state corresponds to particular values of y and x

709
00:00:00,000 --> 00:000:00,000
那么我就能求出一个导数 表征状态如何改变
then I can compute from them a derivative which says how the state must change.

710
00:00:00,000 --> 00:000:00,000
并且 实际上
And,in fact

711
00:00:00,000 --> 00:000:00,000
大家可以看出这是一个圆
you can see this was a circle

712
00:00:00,000 --> 00:000:00,000
因为如果碰巧
because if I happen to be,

713
00:00:00,000 --> 00:000:00,000
在这个点
say,at this place over here,

714
00:00:00,000 --> 00:000:00,000
比如在(1,0)这个点
at (1,0),for example

715
00:00:00,000 --> 00:000:00,000
在这个图像上
on this graph,

716
00:00:00,000 --> 00:000:00,000
那就是说y的导数是x
then it means that the derivative of y is x,

717
00:00:00,000 --> 00:000:00,000
我们也看见了
which we see over here.

718
00:00:00,000 --> 00:000:00,000
是1
That's 1,

719
00:00:00,000 --> 00:000:00,000
接着向上走
so I'm going up.

720
00:00:00,000 --> 00:000:00,000
x的导数是-y
And the derivative of x is minus y,

721
00:00:00,000 --> 00:000:00,000
意味着要走回来
which means I'm going backwards.

722
00:00:00,000 --> 00:000:00,000
实际在这点什么也没做
I'm actually doing nothing at this point,

723
00:00:00,000 --> 00:000:00,000
然后开始走回来使y增加
then I start going backwards as y increases.

724
00:00:00,000 --> 00:000:00,000
这样就画出了一个圆
So that's how you make a circle.

725
00:00:00,000 --> 00:000:00,000
有趣的是
And the interesting thing to see is

726
00:00:00,000 --> 00:000:00,000
这儿有一个程序能用这种方法画出一个圆
a little program that will draw a circle by this method.

727
00:00:00,000 --> 00:000:00,000
实际上 不会画一出一个圆
Actually,this won't draw a circle

728
00:00:00,000 --> 00:000:00,000
因为这个程序实际是一个积分器
because it's a forward or integrator

729
00:00:00,000 --> 00:000:00,000
并且最终会陷入死循环
and will eventually spiral out and all that.

730
00:00:00,000 --> 00:000:00,000
但陷入死循环前还是能画出一个圆的
But it'll draw a circle for a while before it starts spiraling.

731
00:00:00,000 --> 00:000:00,000
然而 我们在这儿看到的是两个表征状态的变量
However,what we see here is two state variables,

732
00:00:00,000 --> 00:000:00,000
x和y
x and y.

733
00:00:00,000 --> 00:000:00,000
还有个迭代计算过程表明
And there's an iteration that says,

734
00:00:00,000 --> 00:000:00,000
要画一个圆
in order to circle,

735
00:00:00,000 --> 00:000:00,000
已经有了x和y
given an x and y,

736
00:00:00,000 --> 00:000:00,000
我想要的是x和y的下一组取值以用来画圆
what I want is to circle with the next values of x and y

737
00:00:00,000 --> 00:000:00,000
也就是x原有的值减去y和dt的乘积
being the old value of x decrement by y times dt

738
00:00:00,000 --> 00:000:00,000
dt就是时间变化
where dt is the time step

739
00:00:00,000 --> 00:000:00,000
还有y原有的值加上x的dt的乘积
and the old value of y being implemented by x times dt,

740
00:00:00,000 --> 00:000:00,000
然后就得到了x和y的新的取值
giving me the new values of x and y.

741
00:00:00,000 --> 00:000:00,000
好了 现在大家对于两种不同的计算过程的感觉
So now you have a feeling

742
00:00:00,000 --> 00:000:00,000
应该都有了一个直观的感觉
for at least two different kinds of processes

743
00:00:00,000 --> 00:000:00,000
而这两种计算过程却可能是由几乎相同的程序产生的
that can be evolved by almost the same program.

744
00:00:00,000 --> 00:000:00,000
像这样做了一点扰动分析之后
And with a little bit of perturbation analysis like this,

745
00:00:00,000 --> 00:000:00,000
如何小小地修改一下程序观察计算过程是怎样变化的
how you change a program a little bit and see how the process changes,

746
00:00:00,000 --> 00:000:00,000
这样才能有直观的感受
that's how we get some intuition.

747
00:00:00,000 --> 00:000:00,000
之后我们就会用到这样的直观感受
Pretty soon we're going to use that intuition

748
00:00:00,000 --> 00:000:00,000
来构建大型的 恼人的 复杂的系统
to build big,hairy,complicated systems.

749
00:00:00,000 --> 00:000:00,000
谢谢
Thank you.

750
00:00:00,000 --> 00:000:00,000
[音乐]
[MUSIC PLAYING BY J.S.BACH]

751
00:00:00,000 --> 00:000:00,000
教授 好了
PROFESSOR: Well,

752
00:00:00,000 --> 00:000:00,000
各位之前已经见过一个对若干程序的简单的扰动分析
you've just seen a simple perturbational analysis of some programs.

753
00:00:00,000 --> 00:000:00,000
我拿一个程序与另一个很相似的程序进行比较
I took a program that was very similar to another program

754
00:00:00,000 --> 00:000:00,000
观察他们如何演化出计算过程
and looked at them both and saw how they evolved processes.

755
00:00:00,000 --> 00:000:00,000
我想再给大家介绍点不同的东西
I want to show you some variety

756
00:00:00,000 --> 00:000:00,000
向大家展示程序可能具有的别的一些计算过程和“形状”
by showing you some other processes and shapes they may have.

757
00:00:00,000 --> 00:000:00,000
同样地 我们将要举例非常简单的程序
Again,we're going to take very simple things,

758
00:00:00,000 --> 00:000:00,000
简单到你都不想写的程序
programs that you wouldn't want to ever write.

759
00:00:00,000 --> 00:000:00,000
那可能是最糟糕的方式
They would be probably the worst way

760
00:00:00,000 --> 00:000:00,000
去进行一些计算过程
of computing some of the things we're going to compute.

761
00:00:00,000 --> 00:000:00,000
但我还是要展示给大家
But I'm just going to show you these things

762
00:00:00,000 --> 00:000:00,000
是想要展现
for the purpose of feeling out

763
00:00:00,000 --> 00:000:00,000
一个程序如何
how a program represents itself

764
00:00:00,000 --> 00:000:00,000
在计算过程的求值中表现出自己的相应规则
as the rule for the evolution of a process.

765
00:00:00,000 --> 00:000:00,000
考虑一个有趣的问题
So let's consider a fun thing,

766
00:00:00,000 --> 00:000:00,000
斐波那契数列
the Fibonacci numbers.

767
00:00:00,000 --> 00:000:00,000
大家可能已经知道斐波那契数列了
You probably know about the Fibonacci numbers.

768
00:00:00,000 --> 00:000:00,000
我记不清是谁了
Somebody,I can't remember who,

769
00:00:00,000 --> 00:000:00,000
有一个人对兔群的繁殖问题很感兴趣
was interested in the growth of piles of rabbits.

770
00:00:00,000 --> 00:000:00,000
不管怎样
And for some reason or other,

771
00:00:00,000 --> 00:000:00,000
我们都知道兔群趋向于指数式增长
the piles of rabbits tend to grow exponentially,as we know.

772
00:00:00,000 --> 00:000:00,000
对于这个过程我们有个不错的模型来解释
And we have a nice model for this process,

773
00:00:00,000 --> 00:000:00,000
由两个数开始算起
is that we start with two numbers,

774
00:00:00,000 --> 00:000:00,000
0和1
0 and 1.

775
00:00:00,000 --> 00:000:00,000
之后的每个数都是前两个数之和
And then every number after this is the sum of the two previous.

776
00:00:00,000 --> 00:000:00,000
于是接下来就是1
So we have here a 1.

777
00:00:00,000 --> 00:000:00,000
然后这两数之和就是2
Then the sum of these two is 2.

778
00:00:00,000 --> 00:000:00,000
那两数之和是3
The sum of those two is 3.

779
00:00:00,000 --> 00:000:00,000
那两数之和是5
The sum of those two is 5.

780
00:00:00,000 --> 00:000:00,000
那两数之和是8
The sum of those two is 8.

781
00:00:00,000 --> 00:000:00,000
那两数之和是13
The sum of those two is 13.

782
00:00:00,000 --> 00:000:00,000
这是21
This is 21.

783
00:00:00,000 --> 00:000:00,000
34 55
34.55.

784
00:00:00,000 --> 00:000:00,000
等等
Et cetera.

785
00:00:00,000 --> 00:000:00,000
如果给这些数字标上序号
If we start numbering these numbers,

786
00:00:00,000 --> 00:000:00,000
第0个
say this is the zeroth one,

787
00:00:00,000 --> 00:000:00,000
第1个
the first one,

788
00:00:00,000 --> 00:000:00,000
第2个
the second one,

789
00:00:00,000 --> 00:000:00,000
第3个
the third one,

790
00:00:00,000 --> 00:000:00,000
第4个
the fourth one,

791
00:00:00,000 --> 00:000:00,000
等等
et cetera.

792
00:00:00,000 --> 00:000:00,000
这是第10个
This is the 10th one,

793
00:00:00,000 --> 00:000:00,000
第10个斐波那契数
the 10th Fibonacci number.

794
00:00:00,000 --> 00:000:00,000
这些数字增长很快
These numbers grow very fast

795
00:00:00,000 --> 00:000:00,000
就像兔子们一样
Just like rabbits.

796
00:00:00,000 --> 00:000:00,000
为什么兔群是这样增长的呢
Why rabbits grow this way

797
00:00:00,000 --> 00:000:00,000
我不会瞎猜
I'm not going to hazard a guess.

798
00:00:00,000 --> 00:000:00,000
接下来我要为大家展示
Now,I'm going to try to write for you

799
00:00:00,000 --> 00:000:00,000
写一个极简单的程序来计算斐波那契数
the very simplest program that computes Fibonacci numbers.

800
00:00:00,000 --> 00:000:00,000
我想要的是一个程序
What I want is a program that,

801
00:00:00,000 --> 00:000:00,000
输入一个n
given an n,

802
00:00:00,000 --> 00:000:00,000
就能输出第n个斐波那契数
will produce for me Fibonacci event.

803
00:00:00,000 --> 00:000:00,000
我就写在这儿了
OK?I'll write it right here.

804
00:00:00,000 --> 00:000:00,000
想要得到第n个斐波那契数
I want the Fibonacci of n,

805
00:00:00,000 --> 00:000:00,000
也就是说 这是那个n
which means the-- this is the n,

806
00:00:00,000 --> 00:000:00,000
这是第n个斐波那契数
and this is Fibonacci of n.

807
00:00:00,000 --> 00:000:00,000
我这么写
And here's the story.

808
00:00:00,000 --> 00:000:00,000
如果n小于2
If n is less than 2,

809
00:00:00,000 --> 00:000:00,000
那么答案就是n
then the result is n.

810
00:00:00,000 --> 00:000:00,000
因为此时斐波那契数和序号相等
Because that's what these are.

811
00:00:00,000 --> 00:000:00,000
这是最开始的规定
That's how you start it up.

812
00:00:00,000 --> 00:000:00,000
否则
Otherwise,

813
00:00:00,000 --> 00:000:00,000
答案就是第n-1个斐波那契数
the result is the sum of Fib of n minus 1

814
00:00:00,000 --> 00:000:00,000
和第n-2个斐波那契数的和
and the Fibonacci number,n minus 2.

815
00:00:00,000 --> 00:000:00,000
这是个很简单的
So this is a very simple,

816
00:00:00,000 --> 00:000:00,000
很直接的
direct specification

817
00:00:00,000 --> 00:000:00,000
求斐波那契数的实现
of the description of Fibonacci numbers

818
00:00:00,000 --> 00:000:00,000
就是根据斐波那契数的定义直接写出这个过程
that I gave you when I introduced those numbers.

819
00:00:00,000 --> 00:000:00,000
用最简单可行的方式直接描述了定义中的递归关系
It represents the recurrence relation in the simplest possible way.

820
00:00:00,000 --> 00:000:00,000
现在 我们又如何解释这个过程呢
Now,how do we use such a thing?

821
00:00:00,000 --> 00:000:00,000
我们来分析一下这个过程所演化出的计算过程
Let's draw this process.

822
00:00:00,000 --> 00:000:00,000
让我们来看看这个过程都做了些什么
Let's figure out what this does.

823
00:00:00,000 --> 00:000:00,000
举一个简单的例子 求第4个斐波那契数
Let's consider something very simple by computing Fibonacci of 4.

824
00:00:00,000 --> 00:000:00,000
要求第4个斐波那契数
To compute Fibonacci of 4,

825
00:00:00,000 --> 00:000:00,000
我应该怎么做呢
what do I do?

826
00:00:00,000 --> 00:000:00,000
根据过程的定义 4并不比2小
Well,it says I have-- it's not less than 2.

827
00:00:00,000 --> 00:000:00,000
因此答案就是两个数之和
Therefore it's the sum of two things

828
00:00:00,000 --> 00:000:00,000
然后 我又要求出
Well,in order to compute that I have to compute,then,

829
00:00:00,000 --> 00:000:00,000
第3个和第2个斐波那契数
Fibonacci of 3 and Fibonacci of 2

830
00:00:00,000 --> 00:000:00,000
要求出第3个斐波那契数
In order to compute Fibonacci of 3,

831
00:00:00,000 --> 00:000:00,000
我就得求出第2个斐波那契数和第1个斐波那契数
I have to compute Fibonacci of 2 and Fibonacci of 1.

832
00:00:00,000 --> 00:000:00,000
而为了求出第2个斐波那契数
In order to compute Fibonacci of 2,

833
00:00:00,000 --> 00:000:00,000
就得求出第1个和第0个斐波那契数
I have to compute Fibonacci of 1 and Fibonacci of 0.

834
00:00:00,000 --> 00:000:00,000
要求第1个斐波那契数
In order to compute Fibonacci of 1,

835
00:00:00,000 --> 00:000:00,000
答案就是1
well,the answer is 1.

836
00:00:00,000 --> 00:000:00,000
这正是递归的边界条件
That's from the base case of this recursion.

837
00:00:00,000 --> 00:000:00,000
而第0个斐波那契数
And in order to compute Fibonacci of 0,

838
00:00:00,000 --> 00:000:00,000
是0
well,that answer is 0,

839
00:00:00,000 --> 00:000:00,000
也是递归的边界条件
from the same base.

840
00:00:00,000 --> 00:000:00,000
然后这儿有个1
And here is a 1.

841
00:00:00,000 --> 00:000:00,000
第2个斐波那契数就是第1个斐波那契数
And Fibonacci of 2 is really the sum of Fibonacci of 1.

842
00:00:00,000 --> 00:000:00,000
和第0个斐波那契数的和
And Fib of 0,

843
00:00:00,000 --> 00:000:00,000
分别求出它们
in order to compute that,

844
00:00:00,000 --> 00:000:00,000
就有了一个1
I get a 1,

845
00:00:00,000 --> 00:000:00,000
和一个0
and here I've got a 0.

846
00:00:00,000 --> 00:000:00,000
我画出了一棵树
I've built a tree.

847
00:00:00,000 --> 00:000:00,000
通过这棵树我们能看出一些结果
Now,we can observe some things about this tree.

848
00:00:00,000 --> 00:000:00,000
我们能发现为何
We can see why

849
00:00:00,000 --> 00:000:00,000
这是个非常糟糕的
this is an extremely bad way

850
00:00:00,000 --> 00:000:00,000
求斐波那契数的办法
to compute Fibonacci numbers.

851
00:00:00,000 --> 00:000:00,000
因为 为了求第4个斐波那契数
Because in order to compute Fibonacci of 4,

852
00:00:00,000 --> 00:000:00,000
就得求两次第2个斐波那契数
I had to compute Fibonacci of 2's sub-tree twice.

853
00:00:00,000 --> 00:000:00,000
实际上 如果再多求一个斐波那契数
In fact,in order to add one more,

854
00:00:00,000 --> 00:000:00,000
假设我想要求第5个斐波那契数
supposing I want to do Fibonacci of 5,

855
00:00:00,000 --> 00:000:00,000
那我要做的就是
what I really have to do then

856
00:00:00,000 --> 00:000:00,000
求第4个斐波那契数和第3个斐波那契数的和
is compute Fibonacci of 4 plus Fibonacci of 3.

857
00:00:00,000 --> 00:000:00,000
但第3个斐波那契数已经求过一遍了
But Fibonacci of 3's sub-tree has already been built.

858
00:00:00,000 --> 00:000:00,000
整个递归树描述了一个指数时间复杂度的递归计算过程
This is a prescription for a process that's exponential in time.

859
00:00:00,000 --> 00:000:00,000
只要多求一个斐波那契数
To add 1,

860
00:00:00,000 --> 00:000:00,000
时间复杂度就得乘上一个数
I have to multiply by something

861
00:00:00,000 --> 00:000:00,000
因为多求一个斐波那契数 需要把已经计算过的过程
because I take a proportion

862
00:00:00,000 --> 00:000:00,000
再计算一次
of the existing thing

863
00:00:00,000 --> 00:000:00,000
时间复杂度就成比例地急剧增长
and add it to itself to add one more step.

864
00:00:00,000 --> 00:000:00,000
于是这个过程的时间复杂度就是
So this is a thing whose time complexity is order of

865
00:00:00,000 --> 00:000:00,000
实际上就是O(Fib(n)) （Fib(n)指第n个斐波那契数）
-- actually,it turns out to be Fibonacci-- of n.

866
00:00:00,000 --> 00:000:00,000
这个过程的时间复杂度就是按斐波那契数列增长
There's a thing that grows exactly at Fibonacci numbers.

867
00:00:00,000 --> 00:000:00,000
这很恐怖
It's a horrible thing.

868
00:00:00,000 --> 00:000:00,000
你都不想这么求斐波那契数
You wouldn't want to do it.

869
00:00:00,000 --> 00:000:00,000
时间复杂度这么增长
The reason why the time has to grow that way

870
00:00:00,000 --> 00:000:00,000
是因为在这个模型中
is because we're presuming in the model

871
00:00:00,000 --> 00:000:00,000
之前给出的代换模型
--the substitution model that I gave you,

872
00:00:00,000 --> 00:000:00,000
我没在这儿形式化地应用代换模型
which I'm not doing formally here,

873
00:00:00,000 --> 00:000:00,000
只是简单地表示了一下
I sort of now spit it out in a simple way--

874
00:00:00,000 --> 00:000:00,000
我们假设所有事情都是按顺序完成的
but presuming that everything is done sequentially.

875
00:00:00,000 --> 00:000:00,000
即这个递归树中每个节点都会被检查
That every one of these nodes in this tree has to be examined.

876
00:00:00,000 --> 00:000:00,000
于是 由于树的节点数
And so since the number of nodes

877
00:00:00,000 --> 00:000:00,000
是按指数增长的
in this tree grows exponentially,

878
00:00:00,000 --> 00:000:00,000
因为要多求一个斐波那契数
because I add a proportion of the existing nodes

879
00:00:00,000 --> 00:000:00,000
就要把已经遍历过的节点再遍历一遍
to the nodes I already have to add 1,

880
00:00:00,000 --> 00:000:00,000
然后就发现时间复杂度呈爆炸式的指数增长
then I know I've got an exponential explosion here.

881
00:00:00,000 --> 00:000:00,000
现在 再来考虑
Now,let's see if we can think of

882
00:00:00,000 --> 00:000:00,000
这个过程的空间复杂度
how much space this takes up.

883
00:00:00,000 --> 00:000:00,000
空间复杂度不算太高
Well,it's not so bad.

884
00:00:00,000 --> 00:000:00,000
它主要取决于我们要记录多少信息
It depends on how much we have to remember

885
00:00:00,000 --> 00:000:00,000
才能使整个计算过程得以持续进行
in order to continue this thing running.

886
00:00:00,000 --> 00:000:00,000
这个并不难
Well,that's not so hard.

887
00:00:00,000 --> 00:000:00,000
从这里看出
It says,gee,

888
00:00:00,000 --> 00:000:00,000
想要知道我现在处于树中的什么位置
in order to know where I am in this tree,

889
00:00:00,000 --> 00:000:00,000
就要记录一条回到根节点的路径
I have to have a path back to the root.

890
00:00:00,000 --> 00:000:00,000
也就是说
In other words,

891
00:00:00,000 --> 00:000:00,000
为了
in order to--

892
00:00:00,000 --> 00:000:00,000
考虑一下路径
let's consider the path.

893
00:00:00,000 --> 00:000:00,000
我要把这个过程执行一遍
I would have to execute this.

894
00:00:00,000 --> 00:000:00,000
我说 啊 好吧
I'd say,oh,yes

895
00:00:00,000 --> 00:000:00,000
我向下走到这儿
I'm going to go down here.

896
00:00:00,000 --> 00:000:00,000
不用管方向
I don't care which direction I go.

897
00:00:00,000 --> 00:000:00,000
我这么走
I have to do this.

898
00:00:00,000 --> 00:000:00,000
这么走
I have to then do this.

899
00:00:00,000 --> 00:000:00,000
用一种有趣的方式遍历这棵树
I have to traverse this tree in a sort of funny way.

900
00:00:00,000 --> 00:000:00,000
又接着走这条有趣的小路
I'm going to walk this nice little path.

901
00:00:00,000 --> 00:000:00,000
回到了这里
I come back to here.

902
00:00:00,000 --> 00:000:00,000
好了我已经记住接下来要去哪儿了
Well,I've got to remember where I'm going to be next.

903
00:00:00,000 --> 00:000:00,000
我记在心里了
I've got to keep that in mind.

904
00:00:00,000 --> 00:000:00,000
于是我得知道已经遍历过的节点
So I have to know what I've done.

905
00:00:00,000 --> 00:000:00,000
还得知道未遍历的节点
I have to know what's left.

906
00:00:00,000 --> 00:000:00,000
为了计算出第4个斐波那契数
In order to compute Fibonacci of 4,

907
00:00:00,000 --> 00:000:00,000
某一时刻我会向下走到这儿
at some point I'm going to have to be down here.

908
00:00:00,000 --> 00:000:00,000
我还要记得
And I have to remember

909
00:00:00,000 --> 00:000:00,000
要回到这儿
that I have to go back to here

910
00:00:00,000 --> 00:000:00,000
又回到这儿做一次加法
and then go back to here to do an addition.

911
00:00:00,000 --> 00:000:00,000
然后又走到这儿做一次加法
And then go back to here to do an addition

912
00:00:00,000 --> 00:000:00,000
之前还需要检查这个尚未检查的节点
to something I haven't touched yet.

913
00:00:00,000 --> 00:000:00,000
消耗的空间就是路径的长度
The amount of space that takes up is the path,

914
00:00:00,000 --> 00:000:00,000
最长路径的长度
the longest path.

915
00:00:00,000 --> 00:000:00,000
它有多长
How long it is.

916
00:00:00,000 --> 00:000:00,000
长度就是n
And that grows as n.

917
00:00:00,000 --> 00:000:00,000
于是消耗的空间
So the space

918
00:00:00,000 --> 00:000:00,000
因为那是树的最长下降深度
-- because that's the length of the deepest line through the tree--

919
00:00:00,000 --> 00:000:00,000
空间复杂度就是O(n)
the space is order of n.

920
00:00:00,000 --> 00:000:00,000
可以看出这个过程时空效率都很低
It's a pretty bad process.

921
00:00:00,000 --> 00:000:00,000
我想让各位获得的是
Now,one thing I want to see from this

922
00:00:00,000 --> 00:000:00,000
一种直观的感觉
is a feeling

923
00:00:00,000 --> 00:000:00,000
关于整个计算过程的直观感觉
of what's going on here.

924
00:00:00,000 --> 00:000:00,000
为何
Why are there--

925
00:00:00,000 --> 00:000:00,000
这个程序是如何与整个计算过程联系起来的
how is this program related to this process?

926
00:00:00,000 --> 00:000:00,000
在这儿 我们看到了什么
Well,what are we seeing here?

927
00:00:00,000 --> 00:000:00,000
这个程序实际上
There really are

928
00:00:00,000 --> 00:000:00,000
只做了两件事
only two sorts of things this program does.

929
00:00:00,000 --> 00:000:00,000
这个程序由两条规则组成
This program consists of two rules,

930
00:00:00,000 --> 00:000:00,000
假如你也这么认为的话
if you will.

931
00:00:00,000 --> 00:000:00,000
第一条规则是 第n个斐波那契数
One rule that says Fibonacci of n

932
00:00:00,000 --> 00:000:00,000
就是这里求和过程的结果
is this sum that you see over here,

933
00:00:00,000 --> 00:000:00,000
对应递归树中这样的一个节点
which is a node that's shaped like this.

934
00:00:00,000 --> 00:000:00,000
它指出要把整个过程分为两部分
It says that I break up something into two parts.

935
00:00:00,000 --> 00:000:00,000
在有的情况下
Under some condition

936
00:00:00,000 --> 00:000:00,000
看这里 n比2大
over here that n is greater than 2,

937
00:00:00,000 --> 00:000:00,000
递归树中对应节点就分为两部分
then the node breaks up into two parts.

938
00:00:00,000 --> 00:000:00,000
比2小
Less than 2.

939
00:00:00,000 --> 00:000:00,000
不 比2大 是的
No.Greater than 2.Yes.

940
00:00:00,000 --> 00:000:00,000
还有一种可能
The other possibility is that

941
00:00:00,000 --> 00:000:00,000
有的归约导致节点没有分成两部分
I have a reduction that looks like this.

942
00:00:00,000 --> 00:000:00,000
也就是这样的情况
And that's this case.

943
00:00:00,000 --> 00:000:00,000
如果比2小
If it's less than 2,

944
00:00:00,000 --> 00:000:00,000
答案就是n本身
the answer is n itself.

945
00:00:00,000 --> 00:000:00,000
我们在这儿看到的是
So what we're seeing here is that

946
00:00:00,000 --> 00:000:00,000
构建起的计算过程
the process that got built

947
00:00:00,000 --> 00:000:00,000
局部来看 每个节点
locally at every place

948
00:00:00,000 --> 00:000:00,000
都是这条规则的实际体现
is an instance of this rule.

949
00:00:00,000 --> 00:000:00,000
这里是规则的一次实际体现
Here's one instance of the rule.

950
00:00:00,000 --> 00:000:00,000
这里是规则的又一次实际体现
Here is another instance of the rule.

951
00:00:00,000 --> 00:000:00,000
人们之所以认为
And the reason why people think of

952
00:00:00,000 --> 00:000:00,000
编程很难 确实挺难的
programming as being hard,of course,

953
00:00:00,000 --> 00:000:00,000
是因为编程实际是在编写一种通用规则
is because you're writing down a general rule,

954
00:00:00,000 --> 00:000:00,000
这种通用规则会被应用于很多实际情况
which is going to be used for lots of instances,

955
00:00:00,000 --> 00:000:00,000
而某一个特定的实际情况
that a particular instance--

956
00:00:00,000 --> 00:000:00,000
而编写好的程序会为你处理每种特定的实际情况
it's going to control each particular instance for you.

957
00:00:00,000 --> 00:000:00,000
你必须写出这样的程序
You've got to write down something

958
00:00:00,000 --> 00:000:00,000
它是通用的 并且考虑到变量
that's a general and in terms of variables,

959
00:00:00,000 --> 00:000:00,000
你要考虑那些变量
and you have to think of all the things

960
00:00:00,000 --> 00:000:00,000
所有可能的取值
that could possibly fit in those variables,

961
00:00:00,000 --> 00:000:00,000
所有这些最终都必须通向
and all those have to lead to

962
00:00:00,000 --> 00:000:00,000
你想要实现的计算过程
the process you want to work.

963
00:00:00,000 --> 00:000:00,000
局部看来 你又得把计算过程分成
Locally,you have to break up your process

964
00:00:00,000 --> 00:000:00,000
可以表示出来的若干部分
into things that can be represented

965
00:00:00,000 --> 00:000:00,000
考虑到这些非常特定的局部规则
in terms of these very specific local rules.

966
00:00:00,000 --> 00:000:00,000
好了 来看一下
Well,let's see.

967
00:00:00,000 --> 00:000:00,000
斐波那契数 当然了 不太有趣
Fibonaccis are,of course,not much fun.

968
00:00:00,000 --> 00:000:00,000
不 其实还是挺有趣的
Yes,they are.

969
00:00:00,000 --> 00:000:00,000
大家还会学习黄金分割等概念
You get something called the golden ratio,

970
00:00:00,000 --> 00:000:00,000
并且说不定什么时候我们还有可能接触更多的类似的东西
and we may even see a lot of that some time.

971
00:00:00,000 --> 00:000:00,000
好了 下面来讨论另一件事
Well,let's talk about another thing.

972
00:00:00,000 --> 00:000:00,000
有个很有名的游戏叫汉诺塔
There's a famous game called the Towers of Hanoi,

973
00:00:00,000 --> 00:000:00,000
举这个例子是因为我教会大家
because I want to teach you

974
00:00:00,000 --> 00:000:00,000
如何递归地思考问题
how to think about things recursively.

975
00:00:00,000 --> 00:000:00,000
游戏是这样的
The problem is this one:

976
00:00:00,000 --> 00:000:00,000
我有一堆盘子
I have a bunch of disks,

977
00:00:00,000 --> 00:000:00,000
又有几根柱子
I have a bunch of spikes,

978
00:00:00,000 --> 00:000:00,000
传说在遥远的东方某地
and it's rumored that somewhere in the Orient

979
00:00:00,000 --> 00:000:00,000
有一个有64个盘子的汉诺塔
there is a 64-high tower,

980
00:00:00,000 --> 00:000:00,000
僧侣们每天的工作就是
and the job of various monks or something

981
00:00:00,000 --> 00:000:00,000
移动盘子从一个柱子到另一个
is to move these spikes

982
00:00:00,000 --> 00:000:00,000
移动的规则很复杂
in some complicated pattern

983
00:00:00,000 --> 00:000:00,000
然后最终这些盘子
so eventually-- these disks--

984
00:00:00,000 --> 00:000:00,000
最终我把所有的盘子
so eventually I moved all of the disks

985
00:00:00,000 --> 00:000:00,000
从一个柱子移到了另一个柱子
from one spike to the other.

986
00:00:00,000 --> 00:000:00,000
如果有64个盘子
And if it's 64 high,

987
00:00:00,000 --> 00:000:00,000
就要移动2的64次方（减1 译者注）次
and it's going to take 2 to the 64th moves,

988
00:00:00,000 --> 00:000:00,000
要花费很长时间
then it's a long time.

989
00:00:00,000 --> 00:000:00,000
僧侣们声称盘子移完之时即是宇宙终结之时
They claim that the universe ends when this is done.

990
00:00:00,000 --> 00:000:00,000
好了
Well,let's see.

991
00:00:00,000 --> 00:000:00,000
构造一个递归过程的方法其实很简单
The way in which you would construct a recursive process

992
00:00:00,000 --> 00:000:00,000
就是“想当然”
is by wishful thinking.

993
00:00:00,000 --> 00:000:00,000
你们要相信
You have to believe.

994
00:00:00,000 --> 00:000:00,000
这个主意
So,the idea.

995
00:00:00,000 --> 00:000:00,000
假如我想把这一堆盘子从这儿移到这儿
Supposing I want to move this pile from here to here,

996
00:00:00,000 --> 00:000:00,000
从1号柱移动到2号柱
from spike one to spike two,

997
00:00:00,000 --> 00:000:00,000
好吧 其实不怎么难
well,that's not so hard.

998
00:00:00,000 --> 00:000:00,000
假如 不知怎么回事
See,supposing somehow,

999
00:00:00,000 --> 00:000:00,000
好像有魔法在作用
by some magic--

1000
00:00:00,000 --> 00:000:00,000
因为有个更简单的问题
because I've got a simpler problem

1001
00:00:00,000 --> 00:000:00,000
我把3个盘子移到这里
-- I move a three-high pile to here--

1002
00:00:00,000 --> 00:000:00,000
一次只能移动一个盘子
I can only move one disk at a time,

1003
00:00:00,000 --> 00:000:00,000
不管我是怎么做到的
so I don't even think how I did it.

1004
00:00:00,000 --> 00:000:00,000
但假设我做到了
But supposing I could do that,

1005
00:00:00,000 --> 00:000:00,000
那我只用拿起这个盘子
well,then I could just pick up this disk

1006
00:00:00,000 --> 00:000:00,000
把它移到这里
and move it here.

1007
00:00:00,000 --> 00:000:00,000
现在问题就简单了
And now I have a simple problem,

1008
00:00:00,000 --> 00:000:00,000
把这3个盘子移到这里
I have to move a three-high tower to here,

1009
00:00:00,000 --> 00:000:00,000
之前已经做过了
which is no problem.

1010
00:00:00,000 --> 00:000:00,000
于是通过两次对3个盘子的移动
So by two moves of a three high tower

1011
00:00:00,000 --> 00:000:00,000
再加上1次对一个盘子的移动
plus one move of a single object.

1012
00:00:00,000 --> 00:000:00,000
我就能把整堆盘子从这儿移动到这儿
I can move the tower from here to here.

1013
00:00:00,000 --> 00:000:00,000
不管怎样
Now,whether or not--

1014
00:00:00,000 --> 00:000:00,000
不管探究到什么程度
this is not obvious

1015
00:00:00,000 --> 00:000:00,000
都不能明显看出整个过程是正确的
in any deep way that this works.

1016
00:00:00,000 --> 00:000:00,000
还有 为什么呢
And why?

1017
00:00:00,000 --> 00:000:00,000
为什么我就能假设
Now why is it the case that I can presume,maybe,

1018
00:00:00,000 --> 00:000:00,000
假设我能把成功移动这三个盘子
that I can move the three-high tower.

1019
00:00:00,000 --> 00:000:00,000
好吧 这是因为
Well the answer is because

1020
00:00:00,000 --> 00:000:00,000
我总能减小问题的规模
I'm always counting down,

1021
00:00:00,000 --> 00:000:00,000
然后最终是0个盘子的移动问题
and eventually I get down to zero-high tower,

1022
00:00:00,000 --> 00:000:00,000
0个盘子不需要移动
and a zero-high tower requires no moves.

1023
00:00:00,000 --> 00:000:00,000
现在可以写出整个过程的算法了
So let's write the algorithm for that.

1024
00:00:00,000 --> 00:000:00,000
很简单
Very easy.

1025
00:00:00,000 --> 00:000:00,000
我会给这些柱子编号
I'm going to label these towers with numbers,

1026
00:00:00,000 --> 00:000:00,000
但它们各自编号成什么无关紧要
but it doesn't matter what they're labelled with.

1027
00:00:00,000 --> 00:000:00,000
问题就是把n个盘子
And the problem is to move an n-high tower

1028
00:00:00,000 --> 00:000:00,000
从一个起始柱移到终点柱
from a spike called From to a spike called To

1029
00:00:00,000 --> 00:000:00,000
另一个柱子作为中转 称作中转柱
with a particular spike called Spare.

1030
00:00:00,000 --> 00:000:00,000
这就是主要的过程
That's what we're going to do.

1031
00:00:00,000 --> 00:000:00,000
用这个我非形式化描述的算法
Using the algorithm I informally described to you,

1032
00:00:00,000 --> 00:000:00,000
把n个盘子从起始柱移到终点柱 另一个柱子作为中转
move of a n-high tower from From to To with a Spare.

1033
00:00:00,000 --> 00:000:00,000
接着就有两种情况了
Well,I've got two cases,

1034
00:00:00,000 --> 00:000:00,000
就要分析都是怎样的情况
and this is a case analysis,

1035
00:00:00,000 --> 00:000:00,000
就像之前所做的分析一样
just like it is in all the other things we've done.

1036
00:00:00,000 --> 00:000:00,000
如果n等于0 那么
If n is 0,then

1037
00:00:00,000 --> 00:000:00,000
我会输出一些东西 输出"Done"
-- I'm going to put out some answers-- Done,we'll say.

1038
00:00:00,000 --> 00:000:00,000
我不知道那代表什么意思
I don't know what that means

1039
00:00:00,000 --> 00:000:00,000
因为我们也不会遇到这样的情况
Because we'll never use that answer for anything.

1040
00:00:00,000 --> 00:000:00,000
我们还是会移动盘子的
We're going to do these moves.

1041
00:00:00,000 --> 00:000:00,000
否则
Else.

1042
00:00:00,000 --> 00:000:00,000
就移动一次
I'm going to do a move.

1043
00:00:00,000 --> 00:000:00,000
移动少于n个盘子
Move a tower of height less than n,

1044
00:00:00,000 --> 00:000:00,000
也就是n-1个盘子
the decrement of n height.

1045
00:00:00,000 --> 00:000:00,000
把它们移到中转柱上
Now,I'm going to move it to the Spare tower.

1046
00:00:00,000 --> 00:000:00,000
整体的思想就是
The whole idea now

1047
00:00:00,000 --> 00:000:00,000
把它们从这里移到这里
is to move this from here to here,

1048
00:00:00,000 --> 00:000:00,000
移到中转柱
to the Spare tower

1049
00:00:00,000 --> 00:000:00,000
从起始柱到中转柱
-- so from From to Spare--

1050
00:00:00,000 --> 00:000:00,000
用终点柱作为中转
using To as a spare tower.

1051
00:00:00,000 --> 00:000:00,000
之后某个时候
Later,somewhere later,

1052
00:00:00,000 --> 00:000:00,000
我就会移动之前的那n个盘子
I'm going to move that same n-high tower,

1053
00:00:00,000 --> 00:000:00,000
在那之前已经完成了这个盘子的移动
after I've done this.

1054
00:00:00,000 --> 00:000:00,000
要移动n个盘子同样的道理就要上面的n-1个盘子
Going to move that same n minus one-high tower

1055
00:00:00,000 --> 00:000:00,000
从中转柱移到终点柱
from the Spare tower to the To tower

1056
00:00:00,000 --> 00:000:00,000
用起始柱作为中转
using the From tower as my spare.

1057
00:00:00,000 --> 00:000:00,000
编写成代码就是从中转柱移动到终点柱
So the Spare tower to the To tower

1058
00:00:00,000 --> 00:000:00,000
用起始柱作为中转
using the From as the spare.

1059
00:00:00,000 --> 00:000:00,000
当进行到这种情况
All I have to do now is

1060
00:00:00,000 --> 00:000:00,000
剩下要做的事情就是
when I've gotten it in this condition,

1061
00:00:00,000 --> 00:000:00,000
现在就是这种情况
between these two moves of a whole tower

1062
00:00:00,000 --> 00:000:00,000
在两次移动同一堆盘子之间
-- I've got it into that condition--

1063
00:00:00,000 --> 00:000:00,000
只需移动一个盘子
now I just have to move one disk.

1064
00:00:00,000 --> 00:000:00,000
所以我想要说的就是
So I'm going to say that

1065
00:00:00,000 --> 00:000:00,000
有个什么过程输出一条信息表示做了一次盘子的移动
some things are printing a move

1066
00:00:00,000 --> 00:000:00,000
不管这个过程具体怎么实现的
and I don't care how it works.

1067
00:00:00,000 --> 00:000:00,000
把盘子从起始柱移动到终点柱
From to To.

1068
00:00:00,000 --> 00:000:00,000
现在大家就能明白为何我在这个时候举这样一个例子
Now,you see the reason why I'm bringing this up

1069
00:00:00,000 --> 00:000:00,000
是因为在某种程度上
at this moment is this is an almost identical program

1070
00:00:00,000 --> 00:000:00,000
这个程序和之前这个程序几乎一样
to this one in some sense.

1071
00:00:00,000 --> 00:000:00,000
尽管它们所求解的问题不一样
It's not computing the same mathematical quantity,

1072
00:00:00,000 --> 00:000:00,000
演化出的递归树也不尽相同
it's not exactly the same tree,

1073
00:00:00,000 --> 00:000:00,000
但不管怎样都会在计算过程中演化出一棵递归树
but it's going to produce a tree.

1074
00:00:00,000 --> 00:000:00,000
移动这些盘子的过程
The general way of making these moves

1075
00:00:00,000 --> 00:000:00,000
会导致生成一棵指数树
is going to lead to an exponential tree.

1076
00:00:00,000 --> 00:000:00,000
好了 接下来试着来移动4个盘子
Well,let's do this four-high.

1077
00:00:00,000 --> 00:000:00,000
我还是得看着小抄来移盘子
I have my little crib sheet here

1078
00:00:00,000 --> 00:000:00,000
不然会弄错
otherwise I get confused.

1079
00:00:00,000 --> 00:000:00,000
好了 下面形式化地提出这个问题
Well,what I'm going to put in is the question of

1080
00:00:00,000 --> 00:000:00,000
把4个摞在一起的盘子
move a tower of height four

1081
00:00:00,000 --> 00:000:00,000
从1号柱子移动到2号
from one to spike two

1082
00:00:00,000 --> 00:000:00,000
用3号柱子作为中转
using spike three as a spare.

1083
00:00:00,000 --> 00:000:00,000
这就是接下来我要做的
That's all I'm really going to do.

1084
00:00:00,000 --> 00:000:00,000
好吧 开始吧
You know,let's just do it.

1085
00:00:00,000 --> 00:000:00,000
我不打算写出
I'm not going to worry about

1086
00:00:00,000 --> 00:000:00,000
过程执行的具体步骤
writing out the trace of this.

1087
00:00:00,000 --> 00:000:00,000
你自己可以做到
You can do that yourself

1088
00:00:00,000 --> 00:000:00,000
因为那很简单
because it's very simple.

1089
00:00:00,000 --> 00:000:00,000
我要把1号柱子上的一个盘子移动到3号柱子上
I'm going to move disk one to disk three.

1090
00:00:00,000 --> 00:000:00,000
这是怎么回事呢
And how do I get to move disk one to disk three?

1091
00:00:00,000 --> 00:000:00,000
我怎么知道要这么做呢
How do I know that?

1092
00:00:00,000 --> 00:000:00,000
好吧 我想还是得查看一下程序执行的具体步骤
Well,I suppose I have to look at the trace a little bit.

1093
00:00:00,000 --> 00:000:00,000
才能明白我这是在做什么
What am I doing here?

1094
00:00:00,000 --> 00:000:00,000
好吧 这个不等于
Well,and this is not--

1095
00:00:00,000 --> 00:000:00,000
n不等于0
n is not zero.

1096
00:00:00,000 --> 00:000:00,000
那我看一下这里过程的定义
So I'm going to look down here.

1097
00:00:00,000 --> 00:000:00,000
这得需要两次移动
This is going to require doing two moves.

1098
00:00:00,000 --> 00:000:00,000
只观察第一次吧
I'm only going to look at the first one.

1099
00:00:00,000 --> 00:000:00,000
第一次是说把
It's going to require moving--

1100
00:00:00,000 --> 00:000:00,000
我怎么写成了移动一座塔
why do I have move tower?

1101
00:00:00,000 --> 00:000:00,000
塔可不好移
It makes it harder for me to move.

1102
00:00:00,000 --> 00:000:00,000
我要移动摞成一摞的3个盘子
I'm going to move a three-high tower

1103
00:00:00,000 --> 00:000:00,000
从起始柱
from the From place,

1104
00:00:00,000 --> 00:000:00,000
也就是4号柱（教授不小心犯错 译者注）
which is four,

1105
00:00:00,000 --> 00:000:00,000
移动到中转柱
to the Spare,

1106
00:00:00,000 --> 00:000:00,000
即2号柱
which is two,

1107
00:00:00,000 --> 00:000:00,000
用3号柱
using three as my

1108
00:00:00,000 --> 00:000:00,000
不 用 用
-- no,using,using--

1109
00:00:00,000 --> 00:000:00,000
学生 [听不清]
STUDENT: [INAUDIBLE PHRASE]

1110
00:00:00,000 --> 00:000:00,000
教授 啊 是这样 抱歉
PROFESSOR: Yes,I'm sorry.

1111
00:00:00,000 --> 00:000:00,000
从2号柱 
From two--

1112
00:00:00,000 --> 00:000:00,000
从1号柱到3号柱用2号柱作为中转
from one to three using two as my spare.

1113
00:00:00,000 --> 00:000:00,000
这就对了
That's right.

1114
00:00:00,000 --> 00:000:00,000
之后这儿还有一次移动
And then there's another move over here afterwards.

1115
00:00:00,000 --> 00:000:00,000
现在可以说
So now I say,

1116
00:00:00,000 --> 00:000:00,000
啊 是的
oh,yes,

1117
00:00:00,000 --> 00:000:00,000
接下来还得把之上两个盘子
that requires me moving a two-high tower

1118
00:00:00,000 --> 00:000:00,000
从1号柱移动到2号柱 用3号柱作为中转
from one to two using three as a spare.

1119
00:00:00,000 --> 00:000:00,000
同样的还得再移一次
And so,are the same,

1120
00:00:00,000 --> 00:000:00,000
接下来 又要移动
and that's going to require me moving

1121
00:00:00,000 --> 00:000:00,000
一个盘子 从1号柱到2号柱
a one-high tower from one to three

1122
00:00:00,000 --> 00:000:00,000
用2号柱作为中转
using two as a spare.

1123
00:00:00,000 --> 00:000:00,000
好了 当然之后还得再移一次
Well,and then there's lots of other things to be done.

1124
00:00:00,000 --> 00:000:00,000
于是我把1个盘子
So I move my one-high tower

1125
00:00:00,000 --> 00:000:00,000
从1号柱移动到3号柱 用2号柱作为中转
from one to three using two as a spare,

1126
00:00:00,000 --> 00:000:00,000
实际上没用到2号柱
which I didn't do anything with.

1127
00:00:00,000 --> 00:000:00,000
好了 整个过程还是非常简单的
Well,this thing just proceeds very simply.

1128
00:00:00,000 --> 00:000:00,000
接下来我把这个盘子从1号柱移到2号柱
I move this from one to two.

1129
00:00:00,000 --> 00:000:00,000
然后把这个盘子从3号柱移动到2号柱
And I move this disk from three to two.

1130
00:00:00,000 --> 00:000:00,000
其实我不想移了
And I don't really want to do it,

1131
00:00:00,000 --> 00:000:00,000
但还得继续 从1到3
but I move from one to three.

1132
00:00:00,000 --> 00:000:00,000
然后从2到1
Then I move two to one.

1133
00:00:00,000 --> 00:000:00,000
从2到3
Then I move two to three.

1134
00:00:00,000 --> 00:000:00,000
从1到3
Then one to three.

1135
00:00:00,000 --> 00:000:00,000
1到2
One to two.

1136
00:00:00,000 --> 00:000:00,000
3到2
Three to two.

1137
00:00:00,000 --> 00:000:00,000
3到1
Three to one.

1138
00:00:00,000 --> 00:000:00,000
当然了这是因为我之前已经准备好了
This all got worked out beforehand,of course.

1139
00:00:00,000 --> 00:000:00,000
2到1
Two to one.

1140
00:00:00,000 --> 00:000:00,000
3到2
Three to two.

1141
00:00:00,000 --> 00:000:00,000
1到3
One to three.

1142
00:00:00,000 --> 00:000:00,000
学生 [听不清]
STUDENT: [INAUDIBLE PHRASE].

1143
00:00:00,000 --> 00:000:00,000
教授 噢 从1到3
PROFESSOR: Oh,one to three.

1144
00:00:00,000 --> 00:000:00,000
抱歉 谢谢提醒
Excuse me.Thank you.

1145
00:00:00,000 --> 00:000:00,000
1到2
One to two.

1146
00:00:00,000 --> 00:000:00,000
然后3到2 呼
And then three to two.Whew.

1147
00:00:00,000 --> 00:000:00,000
现在请大家思考
Now what I'd like you to think about,

1148
00:00:00,000 --> 00:000:00,000
你们刚才看到的是解决这个问题的递归算法
you just saw a recursive algorithm for doing this,

1149
00:00:00,000 --> 00:000:00,000
显然要耗费指数级的时间
and it takes exponential time,of course.

1150
00:00:00,000 --> 00:000:00,000
不知道是否有别的算法
Now,I don't know if there's any algorithm

1151
00:00:00,000 --> 00:000:00,000
不用耗费指数级的时间 它一定会耗费指数级的时间
that doesn't take exponential time-- it has to.

1152
00:00:00,000 --> 00:000:00,000
因为我每次只能移动一个盘子
As I'm doing one operation

1153
00:00:00,000 --> 00:000:00,000
每次只能移动一个盘子
-- I can only move one thing at a time--

1154
00:00:00,000 --> 00:000:00,000
没有什么算法不用耗费指数级的时间
there's no algorithm that's not going to take exponential time.

1155
00:00:00,000 --> 00:000:00,000
但是 你能写出迭代的算法
But can you write an iterative algorithm

1156
00:00:00,000 --> 00:000:00,000
而不是递归的算法么
rather than a recursive algorithm for doing this?

1157
00:00:00,000 --> 00:000:00,000
我一直爱琢磨
One of the sort of little things I like to think about

1158
00:00:00,000 --> 00:000:00,000
能否给出一个算法
Can you write one that,

1159
00:00:00,000 --> 00:000:00,000
不是像我描述的这样
in fact,doesn't break this problem

1160
00:00:00,000 --> 00:000:00,000
把一个问题分解成两个子问题
into two sub-problems the way I described,

1161
00:00:00,000 --> 00:000:00,000
而是用一个更局部的规则
but rather proceeds a step at a time

1162
00:00:00,000 --> 00:000:00,000
一次演化出整个计算过程
using a more local rule.

1163
00:00:00,000 --> 00:000:00,000
那可能会很有趣
That might be fun.

1164
00:00:00,000 --> 00:000:00,000
谢谢大家 第三部分结束
Thank you so much for the third segment.

1165
00:00:00,000 --> 00:000:00,000
有什么问题要问么
Are there questions?

1166
00:00:00,000 --> 00:000:00,000
学生 我想知道有没有什么办法
STUDENT: I wonder if there's a way

1167
00:00:00,000 --> 00:000:00,000
能减小递归过程的代价
to reduce a tree or recursion problem,

1168
00:00:00,000 --> 00:000:00,000
能否把中间过程
how do you save the intermediate work

1169
00:00:00,000 --> 00:000:00,000
计算出的斐波那契数保存下来
you have done in computing the Fibonacci number?

1170
00:00:00,000 --> 00:000:00,000
教授 呃 好吧 实际上
PROFESSOR: Oh,well,in fact,

1171
00:00:00,000 --> 00:000:00,000
你刚才说的就是一种办法
one of the ways to do is what you just said.

1172
00:00:00,000 --> 00:000:00,000
你说  把中间过程的结果保存下来 是吧
You said,I save the intermediate work.OK?

1173
00:00:00,000 --> 00:000:00,000
好的 我告诉你
Well,let me tell you

1174
00:00:00,000 --> 00:000:00,000
再次说一下 我们后面会见到
-- this,again,we'll see later--

1175
00:00:00,000 --> 00:000:00,000
但现在假设就是这种情形
but suppose it's the case that

1176
00:00:00,000 --> 00:000:00,000
不论何时做怎样的计算
anytime I compute anything,

1177
00:00:00,000 --> 00:000:00,000
所有的这些斐波那契数
any one of these Fibonacci numbers,

1178
00:00:00,000 --> 00:000:00,000
我记录一个表
I remember the table

1179
00:00:00,000 --> 00:000:00,000
在表中查询
that takes only linear time

1180
00:00:00,000 --> 00:000:00,000
只用线性的时间
to look up the answer.

1181
00:00:00,000 --> 00:000:00,000
如果我已经计算过了
Then if I ever see it again,

1182
00:00:00,000 --> 00:000:00,000
就不再递归地求解了
instead of doing the expansional tree,

1183
00:00:00,000 --> 00:000:00,000
是直接在表中查询
I look it up.

1184
00:00:00,000 --> 00:000:00,000
我把问题
I've just transformed my problem

1185
00:00:00,000 --> 00:000:00,000
变得简单多了
into a problem that's much simpler.

1186
00:00:00,000 --> 00:000:00,000
当然
Now,of course,

1187
00:00:00,000 --> 00:000:00,000
这种方法已经被使用了
there are the way to do this,as well.

1188
00:00:00,000 --> 00:000:00,000
这种方法叫作记忆化
That one's called memoization,

1189
00:00:00,000 --> 00:000:00,000
这学期你们就会遇到
and you'll see it sometime later in this term.

1190
00:00:00,000 --> 00:000:00,000
但我认为还有个方法是线性时间复杂度的
But I suppose there's a very simple linear time and,

1191
00:00:00,000 --> 00:000:00,000
实际上 是用迭代模型计算斐波那契数
in fact,iterative model for computing Fibonaccis,

1192
00:00:00,000 --> 00:000:00,000
这也是需要各位坐下来仔细思考的
and that's another thing you should sit down and work out.

1193
00:00:00,000 --> 00:000:00,000
这很重要
That's important.

1194
00:00:00,000 --> 00:000:00,000
明白怎么运用迭代模型很重要
It's important to see how to do this.

1195
00:00:00,000 --> 00:000:00,000
希望大家多练习一下
I want you to practice.

1196
00:00:00,000 --> 00:000:00,000
MIT OpenCourseWare
http://ocw.mit.edu

