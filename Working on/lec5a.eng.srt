1
00:00:00,000 --> 00:00:16,830
[MUSIC PLAYING]

2
00:00:16,830 --> 00:00:24,850
PROFESSOR: Well, so far we've invented enough programming to do some very complicated things.

4
00:00:24,850 --> 00:00:29,760
And you surely learned a lot about programming at this point.

6
00:00:29,760 --> 00:00:36,610
You've learned almost all the most important tricks that usually don't get taught to people until they have had a lot of experience.

9
00:00:36,610 --> 00:00:42,755
For example, data directed programming is a major trick, and yesterday you also saw an interpreted language.

12
00:00:45,300 --> 00:00:54,020
We did this all in a computer language, at this point, where there was no assignment statement.

14
00:00:54,020 --> 00:01:02,040
And presumably, for those of you who've seen your Basic or Pascal or whatever, that's usually considered the most important thing.

17
00:01:02,040 --> 00:01:03,580
Well today, we're going to do some thing horrible.

18
00:01:03,580 --> 00:01:07,370
We're going to add an assignment statement.

19
00:01:07,370 --> 00:01:11,110
And since we can do all these wonderful things without it, why should we add it?

21
00:01:11,110 --> 00:01:23,636
An important thing to understand is that today we're going to, first of all, have a rule, which is going to always be obeyed, which is the only reason we ever add a feature to our language is because there is a good reason.

25
00:01:23,636 --> 00:01:36,630
And the good reason is going to boil down to the ability, you now get an ability to break a problem into pieces that are different sets of pieces then you could have broken it down without that, give you another means of decomposition.

31
00:01:38,350 --> 00:01:39,490
However, let's just start.

32
00:01:39,490 --> 00:01:48,240
Let me quick begin by reviewing the kind of language that we have now.

34
00:01:48,240 --> 00:01:51,310
We've been writing what's called functional programs.

35
00:01:51,310 --> 00:01:58,890
And functional programs are a kind of encoding of mathematical truths.

37
00:01:58,890 --> 00:02:07,090
For example, when we look at the factorial procedure that you see on the slide here, it's basically two clauses.

39
00:02:07,090 --> 00:02:11,230
If n is one, the result is one, otherwise n times factorial n minus one.

41
00:02:11,230 --> 00:02:12,990
That's factorial of n.

42
00:02:12,990 --> 00:02:14,960
Well, that is factorial of n.

43
00:02:14,960 --> 00:02:32,680
And written down in some other obscure notation that you might have learned in calculus classes, mathematical logic, what you see there is if n equals one, for the result of n factorial is one, otherwise, greater than one, n factorial is n times n minus one factorial.

48
00:02:32,680 --> 00:02:37,000
True statements, that's the kind of language we've been using.

50
00:02:37,000 --> 00:02:51,390
And whenever we have true statements of that sort, there is a kind of, a way of understanding how they work which is that such processes can be involved by substitution.

54
00:02:51,390 --> 00:03:12,430
And so we see on the second slide here, that the way we understand the execution implied by those statements in arranged in that order, is that you do successive substitutions of arguments for formal parameters in the body of a procedure.

59
00:03:12,430 --> 00:03:14,710
This is basically a sequence of equalities.

60
00:03:14,710 --> 00:03:17,390
Factorial four is four times factorial three.

61
00:03:17,390 --> 00:03:21,290
That is four times three times factorial of two and so on.

62
00:03:21,290 --> 00:03:23,325
We're always preserving truth.

64
00:03:26,580 --> 00:03:38,640
Even though we're talking about true statements, there might be more than one organization of these true statements to describe the computation of a particular function, the computation of the value of a particular function.

69
00:03:38,640 --> 00:03:42,460
So, for example, looking at the next one here.

70
00:03:42,460 --> 00:03:49,780
Here is a way of looking at the sum of n and m.

71
00:03:49,780 --> 00:03:52,930
And we did this one by a recursive process.

72
00:03:52,930 --> 00:04:00,130
It's the increment of the sum of the decrement of n and m.

73
00:04:00,130 --> 00:04:06,240
And, of course, there is some piece of mathematical logic here that describes that.

75
00:04:06,240 --> 00:04:13,120
It's the increment of the sum of the decrement of n and m, just like that.

77
00:04:13,120 --> 00:04:16,440
So there's nothing particularly magic about that.

78
00:04:16,440 --> 00:04:25,310
And, of course, if we can also look at an iterative process for the same, a program that evolves an iterative process, for the same function.

81
00:04:25,310 --> 00:04:29,930
These are two things that compute the same answer.

82
00:04:29,930 --> 00:04:36,720
And we have equivalent mathematical truths that are arranged there.

84
00:04:36,720 --> 00:04:40,430
And just the way you arrange those truths determine the particular process.

86
00:04:40,430 --> 00:04:44,400
In the way choose and arrange them determines the process that's evolved.

88
00:04:44,400 --> 00:04:50,410
So we have the flexibility of talking about both the function to be computed, and the method by which it's computed.

91
00:04:50,410 --> 00:04:53,580
So it's not clear we need more.

92
00:04:53,580 --> 00:04:55,440
However, today I'm going to this awful thing.

93
00:04:55,440 --> 00:04:59,070
I'm going to introduce this assignment operation.

94
00:04:59,070 --> 00:05:02,890
Now, what is this?

95
00:05:02,890 --> 00:05:18,570
Well, first of all, there is going to be another kind of kind of statement, if you will, in a programming language called Set!  Things that do things like assignment, I'm going to put exclamation points after.

101
00:05:18,570 --> 00:05:20,990
We'll talk about what that means in a second.

102
00:05:20,990 --> 00:05:28,090
The exclamation point, again like question mark, is an arbitrary thing we attach to the symbol which is the name, has no significance to the system.

105
00:05:28,090 --> 00:05:35,910
The only significance is to me and you to alert you that this is an assignment of some sort.

107
00:05:35,910 --> 00:05:39,960
But we're going to set a variable to a value.

109
00:05:43,800 --> 00:05:48,600
And what that's going to mean is that there is a time at which something happens.

111
00:05:48,600 --> 00:05:50,100
Here's a time.

112
00:05:50,100 --> 00:05:55,030
If I have time going this way, it's a time access.

113
00:05:55,030 --> 00:05:58,650
Time progresses by walking down the page.

114
00:05:58,650 --> 00:06:06,670
Then an assignment is the first thing we have that produces the difference between a before and an after.

116
00:06:06,670 --> 00:06:14,590
All the other programs that we've written, that have no assignments in them, the order in which they were evaluated didn't matter.

119
00:06:14,590 --> 00:06:17,990
But assignment is special, it produces a moment in time.

120
00:06:17,990 --> 00:06:43,320
So there is a moment before the set occurs and after, such that after this moment in time, the variable has the value, value.

124
00:06:49,310 --> 00:06:57,660
Independent of what value it had before, set! changes the value of the variable.

126
00:06:57,660 --> 00:07:03,150
Until this moment, we had nothing that changed.

127
00:07:03,150 --> 00:07:13,740
So, for example, one of the things we can think of is that the procedures we write for something like factorial are in fact pretty much identical to the function factorial.

130
00:07:13,740 --> 00:07:23,040
Factorial of four, if I write fact4, independent of what context it's in, and independent of how many times I write it, I always get the same answer.

133
00:07:23,040 --> 00:07:25,430
It's always 24.

134
00:07:25,430 --> 00:07:30,360
It's a unique map from the argument to the answer.

135
00:07:30,360 --> 00:07:33,580
And all the programs we've written so far are like that.

136
00:07:33,580 --> 00:07:37,020
However, once I have assignment, that isn't true.

137
00:07:37,020 --> 00:07:50,070
So, for example, if I were to define count to be one.

138
00:07:50,070 --> 00:08:03,870
And then I'm going to define also a procedure, a simple procedure called demo, which takes argument x and does the following operations.

141
00:08:03,870 --> 00:08:09,650
It first sets x to x plus one.

142
00:08:09,650 --> 00:08:14,410
My gosh, this looks just like FORTRAN, right-- in a funny syntax.

145
00:08:16,910 --> 00:08:24,330
And then add to x count, Oh, I just made a mistake.

146
00:08:24,330 --> 00:08:27,010
I want to say, set! count to one plus count.

148
00:08:30,310 --> 00:08:31,730
It's this thing defined here.

150
00:08:34,350 --> 00:08:36,369
And then plus x count.

152
00:08:40,409 --> 00:08:42,559
Then I can try this procedure.

153
00:08:42,559 --> 00:08:43,880
Let's run it.

154
00:08:43,880 --> 00:08:48,125
So, suppose I get a prompt and I say, demo three.

156
00:08:52,210 --> 00:08:53,540
Well, what happens here?

157
00:08:53,540 --> 00:08:57,020
The first thing that happens is count is currently one.

158
00:08:57,020 --> 00:08:59,130
Currently, there is a time.

159
00:08:59,130 --> 00:09:00,710
We're talking about time.

160
00:09:00,710 --> 00:09:02,960
x gets three.

161
00:09:02,960 --> 00:09:08,690
At this moment, I say, oh yes, count is incremented, so count is two.

163
00:09:08,690 --> 00:09:10,710
two plus three is five.

164
00:09:10,710 --> 00:09:14,460
So the answer I get out is five.

165
00:09:14,460 --> 00:09:23,640
Then I say, demo of say, three again.

166
00:09:23,640 --> 00:09:24,830
What do I get?

167
00:09:24,830 --> 00:09:30,760
Well, now count is two, it's not one anymore, because I have incremented it.

169
00:09:30,760 --> 00:09:38,160
But now I go through this process, three goes into x, count becomes one plus count, so that's three now.

171
00:09:38,160 --> 00:09:42,130
The sum of those two is six, so the answer is six.

172
00:09:42,130 --> 00:09:52,170
And what we see is the same expression leads to two different answers, depending upon time.

174
00:09:52,170 --> 00:09:56,290
So demo is not a function, does not compute a mathematical function.

177
00:10:00,020 --> 00:10:07,780
In fact, you could also see why now, of course, this is the first place where the substitution model isn't going to work.

180
00:10:07,780 --> 00:10:11,410
This kills the substitution model dead.

181
00:10:11,410 --> 00:10:25,150
You know, with quotation there were some little problems that a philosopher might notice with the substitutions, because you have to worry about what deductions you can make when you substitute into quotes, if you're allowed to do that at all.

186
00:10:25,150 --> 00:10:29,810
But here the substitution model is dead, can't do anything at all.

188
00:10:29,810 --> 00:10:37,560
Because, supposing I wanted to use a substitution model to consider substituting for count?

190
00:10:37,560 --> 00:10:44,540
Well, my gosh, if I substitute for here and here, they're different ones.

192
00:10:44,540 --> 00:10:46,570
It's not the same count any more.

193
00:10:46,570 --> 00:10:47,880
I get the wrong answer.

194
00:10:47,880 --> 00:10:55,560
The substitution model is a static phenomenon that describes things that are true and not things that change.

196
00:10:55,560 --> 00:10:56,810
Here, we have truths that change.

198
00:11:01,860 --> 00:11:07,870
OK, Well, before I give you any understanding of this, this is very bad.

200
00:11:07,870 --> 00:11:11,520
Now, we've lost our model of computation.

201
00:11:11,520 --> 00:11:15,030
Pretty soon, I'm going to have to build you a new model of computation.

203
00:11:15,030 --> 00:11:18,710
But ours plays with this, just now, in an informal sense.

204
00:11:18,710 --> 00:11:37,810
Of course, what you already see is that when I have something like assignment, the model that we're going to need is different from the model that we had before in that the variables, those symbols like count, or x are no longer going to refer to the values they have, but rather to some sort of place where the value restored.

210
00:11:37,810 --> 00:11:40,330
We're going to have to think that way for a while.

211
00:11:40,330 --> 00:11:44,590
And it's going to be a very bad thing and cause a lot of trouble.

213
00:11:44,590 --> 00:11:53,510
And so, as I said, the very fact that we're inventing this bad thing, means that there had better be a good reason for it, otherwise, just a waste of time and a lot of effort.

217
00:11:53,510 --> 00:11:56,090
Let's just look at some of it just to play.

218
00:11:56,090 --> 00:12:04,430
Supposing we write down the functional version, functional meaning in the old style, of factorial by an iterative process.

222
00:12:09,780 --> 00:12:46,930
Factorial of n, we're going to iterate of m and i, which says if i is greater than n, then the result is m, otherwise, the result of iterating the product of i and m.

225
00:12:46,930 --> 00:12:51,690
So m is going to be the product that I'm accumulating.

226
00:12:51,690 --> 00:12:52,940
m is the product.

228
00:12:58,170 --> 00:12:59,990
And the count I'm going to increase by one.

230
00:13:04,810 --> 00:13:12,060
Plus, ITER, ELSE, COND, define.

231
00:13:12,060 --> 00:13:13,310
I'm going to start this up.

233
00:13:17,000 --> 00:13:21,020
And these days, you should have no trouble reading something like this.

235
00:13:21,020 --> 00:13:26,750
What I have here is a product there being accumulated and a counter.

237
00:13:26,750 --> 00:13:29,050
I start them up both at one.

238
00:13:29,050 --> 00:13:34,800
I'm going to buzz the counter up, i goes to i plus one every time around.

240
00:13:34,800 --> 00:13:42,840
But that's only our putting a time on the process, each of this is just a set of truths, true rules.

242
00:13:42,840 --> 00:13:52,750
And m is going to get a new values of i and m, i times m each time around, and eventually i is going to be bigger than n, in which case, the answer's going to be m.

245
00:13:52,750 --> 00:13:55,760
Now, I'm speaking to you, use time in this.

246
00:13:55,760 --> 00:13:58,210
That's just because I know how the computer works.

247
00:13:58,210 --> 00:13:59,090
But I didn't have to.

248
00:13:59,090 --> 00:14:05,280
This could be a purely mathematical description at this point, because substitution will work for this.

251
00:14:05,280 --> 00:14:11,975
But let's set right down a similar sort of program, using the same algorithm, but with assignments.

254
00:14:15,296 --> 00:14:16,940
So this is called the functional version.

256
00:14:23,840 --> 00:14:25,255
I want to write down an imperative version.

258
00:14:34,150 --> 00:14:36,010
Factorial of n.

259
00:14:36,010 --> 00:14:37,510
I'm going to create my two variables.

261
00:14:40,120 --> 00:14:50,930
Let i initialize itself to one, and m be initialized to one, similar.

263
00:14:50,930 --> 00:15:07,360
We'll create a loop which has COND greater than i, and if i is greater than n, we're done.

265
00:15:07,360 --> 00:15:10,910
And the result is m, the product I'm accumulating.

266
00:15:10,910 --> 00:15:19,320
Otherwise, I'm going to write down three things to do.

267
00:15:19,320 --> 00:15:40,610
I'm going to set! m to the product of i and m, set! i to the sum of i and one, and go around the loop again.

270
00:15:40,610 --> 00:15:44,890
Looks very familiar to you FORTRAN programmers.

271
00:15:44,890 --> 00:15:47,760
ELSE, COND, define, funny syntax though.

273
00:15:51,270 --> 00:15:59,320
Start the loop up, and that's the program.

274
00:15:59,320 --> 00:16:02,790
Now, this program, how do we think about it?

275
00:16:02,790 --> 00:16:04,690
Well, let's just say what we're seeing here.

276
00:16:04,690 --> 00:16:10,810
There are two local variables, i and m, that have been initialized to one.

278
00:16:10,810 --> 00:16:19,240
Every time around the loop, I test to see if i is greater than n, which is the input argument, and if so, the result is the product being accumulated in m.

281
00:16:19,240 --> 00:16:29,130
However, if it's not the end of the loop, if I'm not done, then what I'm going to do is change the product to be the result of multiplying i times the current product.

284
00:16:29,130 --> 00:16:31,530
Which is sort of what we were doing here.

285
00:16:31,530 --> 00:16:33,386
Except here I wasn't changing.

286
00:16:33,386 --> 00:16:46,710
I was making another copy, because the substitution model says, you copy the body of the procedure with the arguments substituted for the formal parameters.

289
00:16:46,710 --> 00:16:51,990
Here I'm not worried about copying, here I've changed the value of m.

291
00:16:51,990 --> 00:16:58,300
I also then change the value of i to i plus one, and go buzzing around.

293
00:16:58,300 --> 00:17:06,160
Seems like essentially the same program, but there are some ways of making errors here that didn't exist until today.

296
00:17:06,160 --> 00:17:20,339
For example, if I were to do the horrible thing of not being careful in writing my program and interchange those two assignments, the program wouldn't compute the same function.

300
00:17:20,339 --> 00:17:27,460
I get a timing error because there's a dependency that m depends upon having the last value of i.

302
00:17:27,460 --> 00:17:36,060
If I try to i first, then I've got the wrong value of i when I multiply by m.

304
00:17:36,060 --> 00:17:40,660
It's a bug that wasn't available until this moment, until we introduced something that had time in it.

307
00:17:43,470 --> 00:17:52,800
So, as I said, first we need a new model of computation, and second, we have to be damn good reason for doing this kind of ugly thing.

310
00:17:52,800 --> 00:17:54,050
Are there any questions?

312
00:17:58,800 --> 00:18:00,505
Speak loudly, David.

313
00:18:00,505 --> 00:18:07,630
AUDIENCE: I'm confused about, we've introduced set now, but we had let before and define before.

315
00:18:07,630 --> 00:18:09,980
I'm confused about the difference between the three.

316
00:18:09,980 --> 00:18:15,280
Wouldn't define work in the same situation as set if you introduced it a bit?

318
00:18:15,280 --> 00:18:20,230
PROFESSOR: No, define is intended for setting something once the first time, for making it.

321
00:18:22,790 --> 00:18:31,970
You've never seen me write on a blackboard two defines in a row whose intention was to change the old value of some variable to a new one.

324
00:18:31,970 --> 00:18:38,120
AUDIENCE: Is that by convention or-- PROFESSOR: No, it's intention.

326
00:18:38,120 --> 00:18:49,850
The answer is that, for example, internal to a procedure, two defines in a row are illegal, two defines in a row of the same variable.

329
00:18:49,850 --> 00:18:51,890
x can't be defined twice.

330
00:18:51,890 --> 00:19:00,840
Whether or not a system catches that error is a different question, but I legislate to you that define happens once on anything.

333
00:19:00,840 --> 00:19:11,610
Now, indeed, in interactive debugging, we intend that you interacting with your computer will redefine things, and so there's a special exception made for interactive debugging.

337
00:19:11,610 --> 00:19:22,460
But define is intended to mean to set up something which will be forever that value after that point.

339
00:19:22,460 --> 00:19:26,490
It's as if all the defines were done at the beginning.

340
00:19:26,490 --> 00:19:37,855
In fact, the only legal place to put a define in Scheme, internal to a procedure, is just at the beginning of a lambda expression, the beginning of the body of a procedure.

345
00:19:41,750 --> 00:19:46,670
Now, let of course does nothing like either of that.

346
00:19:46,670 --> 00:19:52,220
I mean, if you look at what's happening with a let, this happens again exactly once.

348
00:19:52,220 --> 00:19:56,820
It sets up a context where i and m are values one and one.

349
00:19:56,820 --> 00:20:02,880
That context exists throughout this scope, this region of the program.

352
00:20:05,080 --> 00:20:11,110
However, you don't think of that let as setting i again.

353
00:20:11,110 --> 00:20:12,350
It doesn't change it.

354
00:20:12,350 --> 00:20:15,390
i never changes because of the let.

355
00:20:15,390 --> 00:20:18,690
i gets created because of let.

356
00:20:18,690 --> 00:20:22,300
In fact, the let is a very simple idea.

357
00:20:22,300 --> 00:21:16,820
Let does nothing more, Let a variable one to have value one; I'll write this down a little bit more neatly; Let's write, var one have value, the value of expression e1, and variable two, have this value of the expression e2, in an expression e3, is the same thing as a procedure of var one and var two, the formal parameters, and e3 being the body, where var one is bound to the value of e1, and var two gets the value of e2.

366
00:21:19,590 --> 00:21:24,930
So this is, in fact, a perfectly understandable thing from a substitution point of view.

368
00:21:24,930 --> 00:21:28,550
This is really the same expression written in two different ways.

371
00:21:31,820 --> 00:21:37,311
In fact, the way the actual system works is this gets translated into this before anything happens.

373
00:21:37,311 --> 00:21:41,360
AUDIENCE: OK, I'm still unclear as then what makes the difference between a let and a define.

375
00:21:41,360 --> 00:21:49,520
They could-- PROFESSOR: A define is a syntactic sugar, whereby, essentially a bunch of variables get created by lets and then set up once.

380
00:21:57,170 --> 00:21:58,790
OK, time for the first break, I think.

381
00:21:58,790 --> 00:22:00,040
Thank you.

383
00:22:03,480 --> 00:23:04,430
[MUSIC PLAYING]

384
00:23:04,430 --> 00:23:06,530
Well let's see.

385
00:23:06,530 --> 00:23:17,600
I now have to rebuild the model of computation, so you understand how some such mechanical mechanism could work that can do what we've just talked about.

388
00:23:17,600 --> 00:23:22,730
I just recently destroyed your substitution model.

389
00:23:22,730 --> 00:23:26,380
Unfortunately, this model is significantly more complicated than the substitution model.

391
00:23:26,380 --> 00:23:29,010
It's called the environment model.

392
00:23:29,010 --> 00:23:34,660
And I'm going to have to introduce some terminology, which is very good terminology for you to know anyway.

394
00:23:34,660 --> 00:23:36,640
It's about names.

395
00:23:36,640 --> 00:23:42,720
And we're going to give names to the kinds of names things have and the way those names are used.

397
00:23:42,720 --> 00:23:48,290
So this is a meta-description, if you will.

398
00:23:48,290 --> 00:23:54,770
Anyway, there is a pile of an unfortunate terminology here, but we're going to need this to understand what's called the environment model.

401
00:23:54,770 --> 00:23:58,250
We're about to do a little bit of boring, dog-work here.

402
00:23:58,250 --> 00:24:02,280
Let's look at the first transparency.

403
00:24:02,280 --> 00:24:08,880
And we see a description of a word called bound.

404
00:24:08,880 --> 00:24:25,440
And we're going to say that a variable, v, is bound in an expression, e, if the meaning of e is unchanged by the uniform replacement of a variable w, not occurring in e, for every occurrence of v in e.

408
00:24:25,440 --> 00:24:33,490
Now that's a long sentence, so, I think, I'm going to have to say a little bit about that before we even fool around at all here.

411
00:24:33,490 --> 00:24:35,260
Bound variables we're talking about here.

413
00:24:44,030 --> 00:24:46,710
And you've seen lots of them.

414
00:24:46,710 --> 00:24:48,170
You may not know that you've seen lots of them.

415
00:24:48,170 --> 00:24:59,860
Well, I suppose in your logic you saw a logical variables like, for every x there exists a y such that p is true of x and y from your calculus class.

419
00:25:02,960 --> 00:25:16,640
This variable, x, and this variable, y, are bound, because the meaning of this expression does not depend upon the particular letters I used to describe x and y.

422
00:25:16,640 --> 00:25:29,540
If I were to change the w for x, then said for every w there exists a y such that p is true of w and y, it would be the same sentence.

425
00:25:29,540 --> 00:25:30,390
That's what it means.

426
00:25:30,390 --> 00:25:42,415
Or another case of this that you've seen is integral say, from 0 to one of dx over one plus x square.

429
00:25:46,080 --> 00:25:47,440
Well that's something you see all the time.

430
00:25:47,440 --> 00:25:52,270
And this x is a bound variable.

431
00:25:52,270 --> 00:25:58,170
If I change that to a t, the expression is still the same thing.

433
00:25:58,170 --> 00:26:04,850
This is a 1/4 of the arctan of one or something like that.

434
00:26:04,850 --> 00:26:06,620
Yes, that's the arctan of one.

435
00:26:06,620 --> 00:26:13,690
So bound variables are actually fairly common, for those of you who have played a bit with mathematics.

437
00:26:13,690 --> 00:26:19,100
Well, let's go into the programming world.

438
00:26:19,100 --> 00:26:27,570
Instead of the quantifier being something like, for every, or there exists, or integral, a quantifier is a symbol that binds a variable.

441
00:26:27,570 --> 00:26:33,970
And we are going to use the quantifier lambda as being the essential thing that binds variables.

443
00:26:33,970 --> 00:26:44,370
And so we have some nice examples here like that procedure of one argument y which does the following thing.

446
00:26:44,370 --> 00:26:54,145
It calls the procedure of one argument x, which multiplies x by y, and applies that to three.

449
00:26:58,810 --> 00:27:04,790
That procedure has the property there of two bound variables in it, x and y.

451
00:27:04,790 --> 00:27:12,120
This quantifier, lambda here, binds this y, and this quantifier, lambda, binds that x.

453
00:27:12,120 --> 00:27:26,240
Because, if I were to take an arbitrary symbol does not occur in this expression like w and replace all y's with w's in this expression, the expression is still the same, the same procedure.

457
00:27:26,240 --> 00:27:27,430
And this is an important idea.

458
00:27:27,430 --> 00:27:31,500
The reason why we had such things like that is a kind of modularity.

460
00:27:31,500 --> 00:27:42,490
If two people are writing programs, and they work together, it shouldn't matter what names they use internal to their own little machines that they're building.

463
00:27:42,490 --> 00:28:01,200
And so, what I'm really telling you there, is that, for example, this is equivalent to that procedure of one argument y which uses that procedure of one argument d which multiplies z by y.

467
00:28:01,200 --> 00:28:03,570
Because nobody cares what I used in here.

469
00:28:06,270 --> 00:28:08,880
It's a nice example.

470
00:28:08,880 --> 00:28:15,320
On the other hand, I have some variables that are not bound.

471
00:28:15,320 --> 00:28:27,390
For example, that procedure of one argument x which multiplies x by y.

473
00:28:27,390 --> 00:28:32,370
In this case, y is not bound.

474
00:28:32,370 --> 00:28:44,910
Supposing y had the value three, and z had the value four, then this procedure would be the thing that multiplies its argument by three.

477
00:28:44,910 --> 00:28:53,491
If I were to replace every instance of y with z, I would have a different procedure which multiplies every argument that's given by four.

480
00:28:53,491 --> 00:28:57,810
And, in fact, we have a name for such a variable.

481
00:28:57,810 --> 00:29:13,120
Here, we say that a variable, v, is free in the expression, e, if the meaning of the expression, e, is changed by the uniform replacement of a variable, w, not occurring in e for every occurrence of v and e.

485
00:29:13,120 --> 00:29:22,525
So that's why this variable over here, y, is a free variable.

488
00:29:29,010 --> 00:29:52,790
And so free variables in this expression-- And other examples of that is that procedure of one argument y, which is just what we had before, which uses that procedure of one argument x that multiplies x by y--  use that on three.

495
00:29:56,940 --> 00:30:01,795
This procedure has a free variable in it which is asterisk.

498
00:30:05,010 --> 00:30:17,020
See, because, if that has a normal meaning of multiplication, then if I were to replace uniformly all asterisks with pluses, then the meaning of this expression would change.

503
00:30:19,360 --> 00:30:22,850
That's what you mean by a free variable.

504
00:30:22,850 --> 00:30:29,020
So, so far you've learned some logician words which describe the way names are used.

506
00:30:29,020 --> 00:30:35,200
Now, we have to do a little bit more playing around here, a little bit more.

508
00:30:35,200 --> 00:30:39,850
I want to tell you about the regions are over which variables are defined.

511
00:30:42,270 --> 00:30:55,170
You see, we've been very informal about this up till now, and, of course, many of you have probably understood very clearly or most of you, that the x that's being declared here is defined only in here.

516
00:30:58,250 --> 00:31:04,830
This x is the defined only in here, and this y is defined only in here.

519
00:31:07,080 --> 00:31:08,400
We have a name for such an idea.

520
00:31:08,400 --> 00:31:11,660
It's called a scope.

521
00:31:11,660 --> 00:31:14,710
And let me give you another piece of terminology.

522
00:31:14,710 --> 00:31:16,050
It's a long story.

523
00:31:16,050 --> 00:31:20,560
If x is a bound variable in e, then there is a lambda expression where it is bound.

525
00:31:20,560 --> 00:31:24,970
So the only way you can get a bound variable ultimately is by lambda expression.

527
00:31:24,970 --> 00:31:29,670
Then you may worry, does define quite an exception to this?

529
00:31:29,670 --> 00:31:33,100
And it turns out, we could always arrange things so you don't need any defines.

531
00:31:33,100 --> 00:31:34,070
And we'll see that in a while.

532
00:31:34,070 --> 00:31:36,900
It's a very magical thing.

533
00:31:36,900 --> 00:31:39,000
So define really can go away.

534
00:31:39,000 --> 00:31:42,650
The really, only thing that makes names is lambda .

535
00:31:42,650 --> 00:31:44,350
That's its job.

536
00:31:44,350 --> 00:31:48,740
And what's so amazing about a lot of things is you can compute with only lambda.

538
00:31:48,740 --> 00:31:55,880
But, in any case, a lambda expression has a place where it declares a variable.

540
00:31:55,880 --> 00:32:08,730
We call it the formal parameter list or the bound variable list. We say that the lambda expression binds-- so it's a verb-- binds the variables declared in it's found variable list.

544
00:32:08,730 --> 00:32:20,400
In addition, those parts of the expression where the variable is defined, which was declared by some declaration, is called the scope of that variable.

547
00:32:20,400 --> 00:32:22,270
So these are scopes.

548
00:32:22,270 --> 00:32:23,630
This is the scope of y.

550
00:32:27,140 --> 00:32:34,280
And this is the scope of x--  that sort of thing.

554
00:32:41,460 --> 00:33:03,950
OK, well, now we have enough terminology to begin to understand how to make a new model for computation, because the key thing going on here is that we destroyed the substitution model, and we now have to have a model that represents the names as referring to places.

559
00:33:03,950 --> 00:33:09,660
Because if we are going to change something, then we have a place where it's stored.

561
00:33:09,660 --> 00:33:19,280
You see, if a name only refers to a value, and if I tried to change the name's meaning, well, that's not clear.

563
00:33:19,280 --> 00:33:25,030
There's nothing that is the place that that name referred to.

565
00:33:25,030 --> 00:33:25,960
How am I really saying it?

566
00:33:25,960 --> 00:33:29,840
There is nothing shared among all of the instances of that name.

568
00:33:29,840 --> 00:33:34,440
And what we really mean, by a name, is that we fan something out.

570
00:33:34,440 --> 00:33:41,130
We've given something a name, and you have it, and you have it, because I'm given you a reference to it, and I've given you a reference to it.

573
00:33:41,130 --> 00:33:43,580
And we'll see a lot about that.

574
00:33:43,580 --> 00:33:45,986
So let me tell you about environments.

575
00:33:45,986 --> 00:33:52,140
I need the overhead projection machine, thank you.

576
00:33:52,140 --> 00:34:01,590
And so here is a bunch of environment structures.

577
00:34:01,590 --> 00:34:06,490
An environment is a way of doing substitutions virtually.

578
00:34:06,490 --> 00:34:11,409
It represents a place where something is stored which is the substitutions that you haven't done.

581
00:34:14,540 --> 00:34:28,090
It's a place where everything accumulates, where the names of the variables are associated with the values they have such that when you say, what dose this name mean, you look it up in an environment.

585
00:34:28,090 --> 00:34:33,290
So an environment is a function, or a table, or something like that.

587
00:34:33,290 --> 00:34:35,790
But it's a structured sort of table.

588
00:34:35,790 --> 00:34:37,125
It's made out of things called frames.

590
00:34:41,050 --> 00:34:53,940
Frames are pieces of environment, and they are chained together, in some nice ways, by what's called parent links or something like that.

593
00:34:53,940 --> 00:35:05,250
So here, we have an environment structure consisting of three environments, basically, a, b, and c.

596
00:35:05,250 --> 00:35:11,480
d is also an environment, but it's the same one, they share.

597
00:35:11,480 --> 00:35:14,550
And that's the essence of assignment.

598
00:35:14,550 --> 00:35:23,750
If I change a variable, a value of a valuable that lives here, like that one, it should be visible from all places that you're looking at it from.

601
00:35:23,750 --> 00:35:24,990
Take this one, x.

602
00:35:24,990 --> 00:35:30,340
If I change the x to four, it's visible from other places.

604
00:35:30,340 --> 00:35:32,270
But I'm not going to worry about that right now.

605
00:35:32,270 --> 00:35:34,590
We're going to talk a lot about that in a little while.

606
00:35:34,590 --> 00:35:36,830
What do we have here?

607
00:35:36,830 --> 00:35:37,990
Well, these are called frames.

608
00:35:37,990 --> 00:35:43,270
Here is a frame, here's a frame, and here's a frame.

609
00:35:43,270 --> 00:35:52,570
a is an environment which consists of the table which is frame two, followed by the table labeled frame one.

611
00:35:52,570 --> 00:36:04,150
And, in this environment, in say this environment, frame two, x and y are bound.

613
00:36:04,150 --> 00:36:05,920
They have values.

614
00:36:05,920 --> 00:36:20,940
Sorry, in frame one-- In frame two, z is bound, and x is bound, and y is bound, but the value of x that we see, looking from this point of view, is this x.

618
00:36:20,940 --> 00:36:24,940
It's x is seven, rather than this one which is three.

619
00:36:24,940 --> 00:36:27,660
We say that this x shadows this x.

621
00:36:31,070 --> 00:36:42,155
From environment three-- from frame three, from environment b, which refers to frame three, we have variables n and y bound and also x.

625
00:36:44,740 --> 00:36:48,630
This y shadow this one.

626
00:36:48,630 --> 00:36:53,410
So the value, looking from this point of view, of y is two.

628
00:36:53,410 --> 00:36:56,500
The value for looking from this point of view and m is one.

630
00:36:56,500 --> 00:36:58,870
And the value, looking from this point of view, of x is three.

633
00:37:02,310 --> 00:37:06,340
So there we have a very simple environment structure made out of frames.

635
00:37:06,340 --> 00:37:10,990
These correspond to the applications of procedures.

636
00:37:10,990 --> 00:37:14,390
And we'll see that in a second.

637
00:37:14,390 --> 00:37:18,110
So now I have to make you some other nice little structure that we build.

640
00:37:20,870 --> 00:37:27,850
Next slide, we see an object, which I'm going to draw procedures.

642
00:37:27,850 --> 00:37:30,190
This is a procedure.

643
00:37:30,190 --> 00:37:33,150
A procedure is made out of two parts.

644
00:37:33,150 --> 00:37:34,515
It's sort of like a cons.

646
00:37:37,210 --> 00:37:38,460
However, it's the two parts.

648
00:37:40,820 --> 00:37:48,940
The first part refers to some code, something that can be executed, a set of instructions, if you will.

650
00:37:48,940 --> 00:37:50,750
You can think of it that way.

651
00:37:50,750 --> 00:37:53,830
And the second part is the environment.

652
00:37:53,830 --> 00:37:57,250
The procedure is the whole thing.

653
00:37:57,250 --> 00:38:06,250
And we're going to have to use this to capture the values of the free variables that occur in the procedure.

655
00:38:06,250 --> 00:38:11,170
If a variable occurs in the procedure it's either bound in that procedure or free.

657
00:38:11,170 --> 00:38:16,930
If it's bound, then the value will somehow be easy to find.

658
00:38:16,930 --> 00:38:19,070
It will be in some easy environment to get at.

659
00:38:19,070 --> 00:38:27,100
If it's free, we're going to have to have something that goes with the procedure that says where we'll go look for its value.

662
00:38:27,100 --> 00:38:32,290
And the reasons why are not obvious yet, but will be soon.

663
00:38:32,290 --> 00:38:33,760
So here's a procedure object.

664
00:38:33,760 --> 00:38:42,750
It's a composite object consisting of a piece of code and a environment structure.

666
00:38:42,750 --> 00:38:47,650
Now I will tell you the new rules, the complete new rules, for evaluation.

669
00:38:50,690 --> 00:38:53,250
The first rule is-- there's only two of them.

670
00:38:53,250 --> 00:38:57,250
These correspond to the substitution model rules.

671
00:38:57,250 --> 00:39:02,570
And the first one has to do with how do you apply a procedure to its arguments?

674
00:39:05,610 --> 00:39:11,270
And a procedural object is applied to a set of arguments by constructing a new frame.

676
00:39:11,270 --> 00:39:21,490
That frame will contain the mapping of the former parameters to the actual parameters of the arguments that were supplied in the call.

679
00:39:21,490 --> 00:39:34,290
As you know, when we make up a call to a procedure like lambda x times x y, and we call that with the argument three, then we're going to need some mapping of x to three.

683
00:39:34,290 --> 00:39:41,990
It's the same thing as later substituting, if you will, the three for the x in the old model.

685
00:39:41,990 --> 00:39:46,550
So I'm going to build a frame which contains x equals three as the information in that frame.

688
00:39:49,230 --> 00:39:54,170
Now, the body of the procedure will then have to be evaluated which is this.

690
00:39:54,170 --> 00:40:13,100
I will be evaluated in an environment which is constructed by adjoining the new frame that we just made to the environment which was part of the procedure that we applied.

694
00:40:13,100 --> 00:40:15,670
So I'm going to make a little example of that here.

696
00:40:19,220 --> 00:40:25,110
Supposing I have some environment.

697
00:40:25,110 --> 00:40:27,980
Here's a frame which represents it.

698
00:40:27,980 --> 00:40:42,710
And some procedure-- which I'm going to draw with circles here because it's easier than little triangles-- Sorry, those are rhombuses, rhomboidal little pieces of fruit jelly or something.

702
00:40:42,710 --> 00:40:45,960
So here's a procedure which takes this environment.

703
00:40:45,960 --> 00:40:58,010
And the procedure has a piece of code, which is a lambda expression, which binds x and y and then executes an expression, e.

706
00:40:58,010 --> 00:40:59,345
And this is the procedure.

707
00:40:59,345 --> 00:41:01,470
We'll call it p.

708
00:41:01,470 --> 00:41:06,490
I wish to apply that procedure to three and four.

709
00:41:06,490 --> 00:41:09,790
So I want to do p of three and four.

710
00:41:09,790 --> 00:41:13,210
What I'm going to do, of course, is make a new frame.

711
00:41:13,210 --> 00:41:21,740
I build a frame which contains x equals three, and y equals four.

713
00:41:21,740 --> 00:41:27,680
I'm going to connect that frame to this frame over here.

714
00:41:27,680 --> 00:41:34,880
And then this environment, with I will call b, is the environment in which I will evaluate the body of e.

717
00:41:39,940 --> 00:41:46,890
Now, e may contain references to x and y and other things.

718
00:41:46,890 --> 00:41:50,790
x and y will have values right here.

719
00:41:50,790 --> 00:41:55,040
Other things will have their values here.

720
00:41:55,040 --> 00:41:56,920
How do we get this frame?

721
00:41:56,920 --> 00:42:01,980
That we do by the construction of procedures which is the other rule.

723
00:42:01,980 --> 00:42:05,500
And I think that's the next slide.

724
00:42:05,500 --> 00:42:18,300
Rule two, when a lambda expression is evaluated, relative to a particular environment--  See, the way I get a procedure is by evaluating the lambda expression.

729
00:42:18,300 --> 00:42:20,110
Here's a lambda expression.

730
00:42:20,110 --> 00:42:25,170
By evaluating it, I get a procedure which I can apply to three.

732
00:42:25,170 --> 00:42:31,820
Now this lambda expression is evaluated in an environment where y is defined.

734
00:42:31,820 --> 00:42:36,680
And I want the body of this which contains a free version of y.

736
00:42:36,680 --> 00:42:43,350
y is free in here, it's bound over the whole thing, but it's free over here.

738
00:42:43,350 --> 00:42:47,440
I want that y to be this one.

739
00:42:47,440 --> 00:42:55,470
I evaluate this body of this procedure in the environment where y was created.

741
00:42:55,470 --> 00:42:59,140
That's this kind of thing, because that was done by application.

743
00:42:59,140 --> 00:43:04,370
Now, if I ever want to look up the value of y, I have to know where it is.

745
00:43:04,370 --> 00:43:18,110
Therefore, this procedural was created, the creation of the procedure which is the result of evaluating that lambda expression had better capture a pointer or remember the frame in which y was bound.

749
00:43:18,110 --> 00:43:22,100
So that's what this rule is telling us.

750
00:43:22,100 --> 00:43:43,020
So, for example, if I happen to be evaluating a lambda expression, lambda expression in e, lambda of say, x and y, let's call it g in e, evaluating that.

753
00:43:43,020 --> 00:43:47,190
Well, all that means is I now construct a procedure object.

754
00:43:47,190 --> 00:43:48,990
e is some environment.

755
00:43:48,990 --> 00:43:51,920
e is something which has a pointer to it.

756
00:43:51,920 --> 00:44:03,180
I construct a procedure object that points up to that environment, where the code of that is a lambda expression or whatever that translates into.

760
00:44:06,330 --> 00:44:07,580
And this is the procedure.

762
00:44:12,380 --> 00:44:32,950
So this produces for me-- this object here, this environment pointer, captures the place where this lambda expression was evaluated, where the definition was used, where the definition was used to make a procedure, to make the procedure.

767
00:44:32,950 --> 00:44:44,990
So it picks up the environment from the place where that procedure was defined, stores it in the procedure itself, and then when the procedure is used, the environment where it was defined is extended with the new frame.

772
00:44:48,740 --> 00:44:53,090
So this gives us a locus for putting where a variable has a value.

774
00:44:53,090 --> 00:45:01,430
And, for example, if there are lots of guys pointing in at that environment, then they share that place.

776
00:45:01,430 --> 00:45:03,810
And we'll see more of that shortly.

777
00:45:03,810 --> 00:45:14,970
Well, now you have a new model for understanding the execution of programs. I suppose I'll take questions now, and then we'll go on and use that for something.

781
00:45:17,802 --> 00:45:24,580
AUDIENCE: Is it right to say then, the environment is that linked chain of frames-- PROFESSOR: That's right.

784
00:45:24,580 --> 00:45:27,076
AUDIENCE: starting with-- working all the way back?

786
00:45:27,076 --> 00:45:32,470
PROFESSOR: Yes, the environment is a sequence of frames linked together.

788
00:45:32,470 --> 00:45:39,400
And the way I like to think about it, it's the pointer to the first one, because once you've got that you've got them all.

792
00:45:44,080 --> 00:45:44,995
Anybody else?

793
00:45:44,995 --> 00:45:53,600
AUDIENCE: Is it possible to evaluate a procedure or to define a procedure in two different environments such that it will behave differently, and have pointers to both-- PROFESSOR: Oh, yes.

798
00:45:53,600 --> 00:45:57,290
The same procedure is not going to have two different environments.

800
00:45:57,290 --> 00:46:03,430
The same code, the same lambda expression can be evaluated in two environments producing two different procedures.

803
00:46:06,220 --> 00:46:08,690
Each procedure-- AUDIENCE: Their definition has the same name.

805
00:46:08,690 --> 00:46:12,570
Their operation-- PROFESSOR: The definition is written the same, with the same characters.

808
00:46:12,570 --> 00:46:21,340
I can evaluate that set of characters, whatever, that list structure that defines, that is the textual representation.

811
00:46:21,340 --> 00:46:25,650
I can evaluate that in two different environments producing two different procedures.

813
00:46:25,650 --> 00:46:33,490
Each of those procedures has its own local sets of variables, and we'll see that right now.

816
00:46:36,770 --> 00:46:38,020
Anybody else?

818
00:46:42,670 --> 00:46:43,280
OK, thank you.

819
00:46:43,280 --> 00:46:44,530
Let's take a break.

821
00:46:48,750 --> 00:47:22,870
[MUSIC PLAYING]

822
00:47:22,870 --> 00:47:26,670
Well, now I've done this terrible thing to you.

823
00:47:26,670 --> 00:47:43,270
I've introduced a very complicated thing, assignment, which destroys most of the interesting mathematical properties of our programs. Why should I have done this?

826
00:47:43,270 --> 00:47:46,590
What possible good could this do?

827
00:47:46,590 --> 00:47:52,490
Clearly not a nice thing, so I better have a good excuse.

828
00:47:52,490 --> 00:47:58,870
Well, let's do a little bit of playing, first of all, with some very interesting programs that have assignment.

830
00:47:58,870 --> 00:48:04,820
Understand something special about them that makes them somewhat valuable.

832
00:48:04,820 --> 00:48:10,670
Start with a very simple program which I'm going to call make-counter.

834
00:48:10,670 --> 00:48:50,120
I'm going to define make-counter to be a procedure of one argument n which returns as its value a procedure of no arguments-- a procedure that produces a procedure-- which sets n to the increment of n and returns that value of n.

841
00:48:55,520 --> 00:48:57,560
Now we're going to investigate the behavior of this.

842
00:48:57,560 --> 00:48:59,840
It's a sort of interesting thing.

843
00:48:59,840 --> 00:49:06,380
In order to investigate the behavior, I have to make an environment model, because we can't understand this any other way.

847
00:49:08,630 --> 00:49:10,040
So let's just do that.

848
00:49:10,040 --> 00:49:16,240
We start out with some sort of-- let's say there is a global environment that the machine is born with.

851
00:49:16,240 --> 00:49:19,720
Global we'll call it.

852
00:49:19,720 --> 00:49:24,530
And it's going to have in it a bunch of initial things.

853
00:49:24,530 --> 00:49:25,820
We all know what it's got.

854
00:49:25,820 --> 00:49:42,960
It's got things in it like say, plus, and times, and quotient, and difference, and CAR, and et cetera, lots of things.

857
00:49:42,960 --> 00:49:51,290
I don't know what they are, some various squiggles that are the things the machine is born with.

859
00:49:51,290 --> 00:49:57,390
And by doing the definition here, what I plan to do-- Well, what am I doing?

861
00:49:57,390 --> 00:49:59,780
I'm doing this relative to the global environment.

862
00:49:59,780 --> 00:50:03,580
So here's my environment pointer.

863
00:50:03,580 --> 00:50:08,270
In order to do that I have to evaluate this lambda expression.

865
00:50:08,270 --> 00:50:11,490
That means I make a procedure object.

866
00:50:11,490 --> 00:50:13,190
So I'm going to make a procedure object here.

868
00:50:17,400 --> 00:50:23,820
And the procedure object has, as the place it's defined, the global environment.

870
00:50:23,820 --> 00:50:35,340
The procedure object contains some code that represents a procedure of one argument n which returns a procedure of no arguments which does something.

874
00:50:38,320 --> 00:50:55,470
And the define is a way of changing this environment, so that I now add to it a make-counter, a special rule for the special thing defined.

877
00:50:55,470 --> 00:51:03,840
But what that is, is it gives me that pointer to that procedure.

879
00:51:03,840 --> 00:51:06,370
So now the global environment contains make-counter as well.

881
00:51:09,330 --> 00:51:11,800
Now, we're going to do some operations.

882
00:51:11,800 --> 00:51:14,596
I'm going to use this to make some counters.

883
00:51:14,596 --> 00:51:17,140
We'll see what a counter is.

884
00:51:17,140 --> 00:51:26,700
So let's define c1 to be a counter beginning at 0.

886
00:51:35,440 --> 00:51:39,660
Well, we know how to do this now, according to the model.

887
00:51:39,660 --> 00:51:47,900
I have to evaluate the expression make-counter in the global environment, make-counter of 0.

889
00:51:47,900 --> 00:51:50,785
Well, I look up make-counter and see that it's a procedure.

891
00:51:53,630 --> 00:51:56,010
I'm going to have to apply that procedure.

892
00:51:56,010 --> 00:51:59,820
The way I apply the procedure is by constructing a frame.

894
00:52:02,400 --> 00:52:18,810
So I construct a frame which has a value for n in it which is 0, and the parent environment is the one which is the environment of definition of make-counter.

898
00:52:23,890 --> 00:52:28,400
So I've made an environment by applying make-counter to 0.

900
00:52:31,580 --> 00:52:37,455
Now, I have to evaluate the body of make-counter, which is this lambda expression, in that environment.

903
00:52:40,730 --> 00:52:46,360
Well evaluating this body, this body is a lambda expression.

905
00:52:46,360 --> 00:52:49,570
Evaluate a lambda expression means make a procedure object.

906
00:52:49,570 --> 00:52:50,820
So I'm going to make a procedure object.

908
00:52:56,840 --> 00:53:07,656
And that procedure object has the environment it was defined in being that, where n was defined to be 0.

910
00:53:07,656 --> 00:53:17,622
And it has some code, which is the procedure of no arguments which does something, that sets something, and returns n.

912
00:53:17,622 --> 00:53:26,020
And this thing is going to be the object, which in the global environment, will have the name c1.

914
00:53:26,020 --> 00:53:32,625
So we construct a name here, c1, and say that equals that.

916
00:53:35,560 --> 00:53:53,868
Now, but also make another counter, c2 to be make-counter say, starting with 10.

918
00:53:53,868 --> 00:53:57,270
Then I do essentially the same thing.

919
00:53:57,270 --> 00:54:05,690
I apply the make-counter procedure, which I got from here, to make another frame with n being 10.

921
00:54:05,690 --> 00:54:10,050
That frame has the global environment as its parent.

922
00:54:10,050 --> 00:54:18,000
I then construct a procedure which has that as it's frame of definition.

925
00:54:20,440 --> 00:54:25,390
The code of it is the procedure of no arguments which does something.

927
00:54:25,390 --> 00:54:28,700
And it does a set, and so on.

928
00:54:28,700 --> 00:54:31,510
And n comes out.

929
00:54:31,510 --> 00:54:36,950
And c2 is this.

930
00:54:36,950 --> 00:54:40,200
Well, you're already beginning to see something fairly interesting.

932
00:54:40,200 --> 00:54:42,880
There are two n's here.

933
00:54:42,880 --> 00:54:46,330
They are not one n.

934
00:54:46,330 --> 00:54:52,520
Each time I called make-counter, I made another instance of n.

936
00:54:52,520 --> 00:54:54,370
These are distinct and separate from each other.

938
00:54:57,880 --> 00:55:00,783
Now, let's do some execution, use those counters.

939
00:55:00,783 --> 00:55:02,735
I'm going to use those counters.

941
00:55:05,990 --> 00:55:15,900
Well, what happens if I say, c1 at this point?

942
00:55:15,900 --> 00:55:20,840
Well, I go over here, and I say, oh yes, c1 is a procedure.

944
00:55:20,840 --> 00:55:25,060
I'm going to call this procedure on no arguments, but it has no parameters.

946
00:55:25,060 --> 00:55:27,020
That's right.

947
00:55:27,020 --> 00:55:28,080
What's its body?

948
00:55:28,080 --> 00:55:30,130
Well, I have to look over here, because I didn't write it down.

950
00:55:30,130 --> 00:55:39,050
It said, set n to one plus n and return n, increment n.

951
00:55:39,050 --> 00:55:42,970
Well, the n it sees is this one.

952
00:55:42,970 --> 00:55:45,490
So I increment that n.

953
00:55:45,490 --> 00:55:50,040
That becomes one, and I return the value one.

955
00:55:53,050 --> 00:55:58,220
Supposing I then called c2.

956
00:55:58,220 --> 00:55:59,820
Well, what do I do?

957
00:55:59,820 --> 00:56:05,450
I say c2 is this procedure which does the same thing, but here's the n.

959
00:56:05,450 --> 00:56:11,140
It becomes 11.

960
00:56:11,140 --> 00:56:15,980
And so I have an 11 which is the value.

961
00:56:15,980 --> 00:56:18,130
I then can say, let's try c1 again.

963
00:56:21,580 --> 00:56:29,660
c1 is this, that's two, so the answer is two.

964
00:56:29,660 --> 00:56:39,980
And c2 gives me a 12 by the same method, by walking down here looking at that and saying, here's the n, I'm incrementing.

968
00:56:41,630 --> 00:56:44,920
So what I have are computational objects.

969
00:56:44,920 --> 00:56:51,060
There are two counters, each with its own independent local state.

972
00:56:55,540 --> 00:56:56,650
Let's talk about this a little.

973
00:56:56,650 --> 00:56:58,510
This is a strange thing.

975
00:57:01,270 --> 00:57:04,140
What's an object?

976
00:57:04,140 --> 00:57:07,560
It's not at all obvious what an object is.

977
00:57:07,560 --> 00:57:14,800
We like to think about objects, because it's economical to think that way.

979
00:57:14,800 --> 00:57:18,670
It's an intellectual economy.

980
00:57:18,670 --> 00:57:21,120
I am an object.

981
00:57:21,120 --> 00:57:23,610
You are an object.

982
00:57:23,610 --> 00:57:25,030
We are not the same object.

984
00:57:27,600 --> 00:57:45,750
I can divide the world into two parts, me and you, and there's other things as well, such that most of the things I might want to discuss about my workings do not involve you, and most of the things I want to discuss about your workings don't involve me.

989
00:57:45,750 --> 00:58:12,770
I have a blood pressure, a temperature, a respiration rate, a certain amount of sugar in my blood, and numerous, thousands, of state variables-- millions actually, or I don't know how many-- huge numbers of state variables in the physical sense which represent the state of me as a particle, and you have gazillions of them as well.

996
00:58:12,770 --> 00:58:17,290
And most of mine are uncoupled to most of yours.

997
00:58:17,290 --> 00:58:23,940
So we can compute the properties of me without worrying too much about the properties of you.

999
00:58:23,940 --> 00:58:32,760
If we had to work about both of us together, than the number of states that we have to consider is the product of the number of states you have and the number of states I have. But this way it's almost a sum.

1003
00:58:32,760 --> 00:58:36,110
Now, indeed there are forces that couple us.

1004
00:58:36,110 --> 00:58:38,420
I'm talking to you and your state changes.

1005
00:58:38,420 --> 00:58:41,680
I'm looking at you and my state changes.

1006
00:58:41,680 --> 00:58:46,190
Some of my state variables, a very few of them, therefore, are coupled to yours.

1008
00:58:46,190 --> 00:58:49,720
If you were to suddenly yell very loud, my blood pressure would go up.

1011
00:58:54,320 --> 00:59:02,260
However, and it may not be always appropriate to think about the world as being made out of independent states and independent particles.

1014
00:59:02,260 --> 00:59:22,300
Lots of the bugs that occur in things like quantum mechanics, or the bugs in our minds that occur when we think about things like quantum mechanics, are due the fact that we are trying to think about things being broken up into independent pieces, when in fact there's more coupling than we see on the surface, or that we want to believe in, because we want to compute efficiently and effectively.

1021
00:59:22,300 --> 00:59:23,780
We've been trained to think that way.

1023
00:59:29,336 --> 00:59:31,440
Well, let's see.

1024
00:59:31,440 --> 00:59:35,140
How would we know if we had objects at all?

1025
00:59:35,140 --> 00:59:37,690
How can we tell if we have objects?

1026
00:59:37,690 --> 00:59:41,770
Consider some possible optical illusions.

1027
00:59:41,770 --> 00:59:44,805
This could be done.

1028
00:59:44,805 --> 00:59:52,130
These pieces of chalk are not appropriately identical, but supposing you couldn't tell the difference of them by looking at them.

1031
00:59:52,130 --> 00:59:55,725
Well, there's a possibility that this all a game I'm playing with mirrors.

1033
00:59:55,725 --> 01:00:01,660
It's really the same piece of chalk, but you're seeing two of them.

1035
01:00:01,660 --> 01:00:05,160
How would you know if you're seeing one or two?

1036
01:00:05,160 --> 01:00:07,430
Well, there's only one way I know.

1037
01:00:07,430 --> 01:00:11,360
You grab one of them and change it and see if the other one changed.

1040
01:00:13,580 --> 01:00:16,180
And it didn't, so there's two of them.

1042
01:00:19,070 --> 01:00:22,580
And, on the other hand, there is some other screwy properties of things like that.

1044
01:00:22,580 --> 01:00:25,040
Like, how do we know if something changed?

1045
01:00:25,040 --> 01:00:28,760
We have to look at it before and after the change.

1046
01:00:28,760 --> 01:00:32,200
The change is an assignment, it's a moment in time.

1047
01:00:32,200 --> 01:00:36,540
But that means we have to know it was the same one that we're looking at.

1049
01:00:36,540 --> 01:00:47,380
So some very strange, and unusual, and obscure, and-- I don't understand the problems associated with assignment, and change, and objects.

1052
01:00:47,380 --> 01:00:51,420
These could get very, very bad.

1053
01:00:51,420 --> 01:00:57,650
For example, here I am, I am a particular person, a particular object.

1055
01:00:57,650 --> 01:01:02,430
Now, I can take out my knife, and cut my fingernail.

1056
01:01:02,430 --> 01:01:06,030
A piece of my fingernail has fallen off onto the table.

1057
01:01:06,030 --> 01:01:14,490
I believe I am the same person I was a second ago, but I'm not physically the same in the slightest.

1059
01:01:14,490 --> 01:01:15,620
I have changed.

1060
01:01:15,620 --> 01:01:18,180
Why am I the same?

1061
01:01:18,180 --> 01:01:21,070
What is the identity of me?

1062
01:01:21,070 --> 01:01:22,320
I don't know.

1064
01:01:25,170 --> 01:01:29,770
Except for the fact that I have some sort of identity.

1065
01:01:29,770 --> 01:01:43,510
And so, I think by introducing assignment and objects, we have opened ourselves up to all the horrible questions of philosophy that have been plaguing philosophers for some thousands of years about this sort of thing.

1069
01:01:43,510 --> 01:01:45,880
It's why mathematics is a lot cleaner.

1070
01:01:45,880 --> 01:01:50,840
Let's look at the best things I know to say about actions and identity.

1073
01:01:52,500 --> 01:02:05,100
We say that an action, a, had an effect on an object, x, or equivalently, that x was changed by a, if some property, p, which was true of x before a, became false of x after a.

1077
01:02:05,100 --> 01:02:10,950
Let's test. It still means I have to have the x before and after.

1079
01:02:10,950 --> 01:02:19,580
Or, the other way of saying this is, we say that two objects x and y are the same for any action which has an effect on x has the same effect on y.

1082
01:02:19,580 --> 01:02:24,650
However, objects are very useful, as I said, for intellectual economy.

1084
01:02:24,650 --> 01:02:35,050
One of the things that's incredibly useful about them, is that the world is, we like to think about, made out of independent objects with independent local state.

1087
01:02:35,050 --> 01:02:39,730
We like to think that way, although it isn't completely true.

1089
01:02:39,730 --> 01:02:58,720
When we want to make very complicated programs that deal with such a world, if we want those programs to be understandable by us and also to be changeable, so that if we change the world we change the program only a little bit, then we want there to be connections, isomorphism, between the objects in the world and the objects in our mental model.

1096
01:02:58,720 --> 01:03:02,400
The modularity of the world can give us the modularity in our programming.

1098
01:03:02,400 --> 01:03:09,950
So we invent things called object-oriented programming and things like that to provide us with that power.

1100
01:03:09,950 --> 01:03:10,990
But it's even easier.

1101
01:03:10,990 --> 01:03:12,310
Let's play a little game.

1102
01:03:12,310 --> 01:03:22,960
I want to play a little game, show you an even easier example of where modularity can be enhanced by using an assignment statement, judiciously.

1105
01:03:22,960 --> 01:03:32,180
One thing I want to enforce and impress on you, is don't use assignment statements the way you use it in FORTRAN or Basic or something or Pascal, to do the things you don't have to do with it.

1110
01:03:34,200 --> 01:03:37,010
It's not the right way to think for most things.

1111
01:03:37,010 --> 01:03:39,810
Sometimes it's essential, or maybe it's essential.

1112
01:03:39,810 --> 01:03:42,320
We'll see more about that too.

1113
01:03:42,320 --> 01:03:44,330
OK, let me show you a fun game here.

1115
01:03:47,270 --> 01:03:58,450
There was mathematician by the name of Cesaro-- or Cesaro, Cesaro I suppose it is-- who figured out a clever way of computing pi.

1118
01:03:58,450 --> 01:04:13,920
It turns out that if I take to random numbers, two integers at random, and compute the greatest common divisor, their greatest common divisor is either one or it's not one.

1121
01:04:13,920 --> 01:04:15,445
If it's one, then they have no common divisors.

1123
01:04:18,240 --> 01:04:29,580
If their greatest common divisor is one-- the probability that two random numbers, two numbers chosen at random, has as greatest common divisor one is related to pi.

1127
01:04:29,580 --> 01:04:40,110
In fact-- yes, it's very strange-- of course there are other ways of computing pi, like dropping pins on flags, and things like that, and sort of the same kind of thing.

1132
01:04:40,110 --> 01:04:55,660
So the probability of that the GCD of number one and number two, two random numbers chosen, is 6 over pi squared.

1134
01:04:55,660 --> 01:04:57,240
I'm not going to try to prove that.

1135
01:04:57,240 --> 01:05:01,120
It's actually not too hard and sort of fun.

1136
01:05:01,120 --> 01:05:03,590
How would we estimate such probability?

1137
01:05:03,590 --> 01:05:13,570
Well, the way we do that, the way we estimate probabilities, is by doing lots of experiments, and then computing the ratios of the ones that come out one way to the total number of experiments we do.

1142
01:05:16,320 --> 01:05:26,360
It's called Monte Carlo, and it's useful in other contexts for doing things like integrals where you have lots and lots of variables-- the space which is limiting the dimensions you are doing you integral in.

1147
01:05:26,360 --> 01:06:03,990
But going back to here, Let's look at this slide, We can use Cesaro's method for estimating pi with n trials by taking the square root of six over a Monte Carlo, a Monte Carlo experiment with n trials, using Cesaro's experiment, where Cesaro's experiment is the test of whether the GCD of two random numbers-- And you can see that I've already got some assignments in here, just by what I wrote.

1155
01:06:03,990 --> 01:06:20,400
The fact that this word rand, in parentheses, therefore, that procedure call, yields a different value than this one, at least that's what I'm assuming by writing this this way, indicates that this is not a function, that there's internal state in it which is changing.

1161
01:06:25,110 --> 01:06:31,530
If the GCD of those two random numbers is equal to one, that's the experiment.

1163
01:06:31,530 --> 01:06:36,560
So here I have an experimental method for estimating the value of pi.

1165
01:06:36,560 --> 01:06:40,160
Where, I can easily divide this problem into two parts.

1166
01:06:40,160 --> 01:06:49,320
One is the specific Monte Carlo experiment of Cesaro, which you just saw, and the other is the general technique of doing Monte Carlo experiments.

1169
01:06:49,320 --> 01:06:51,190
And that's what this is.

1170
01:06:51,190 --> 01:07:10,230
If I want to do Monte Carlo experiments with n trials, a certain number of trials, and a particular experiment, the way I do that is I make a little iterative procedure which has variable the number of trials remaining and the number trials that have been passed, that I've gotten true.

1175
01:07:10,230 --> 01:07:19,150
And if the number remaining is 0, then the answer is the number past divided by this whole number of trials, was the estimate of the probability.

1178
01:07:19,150 --> 01:07:22,870
And if it's not, if I have more trials to do, then let's do one.

1180
01:07:22,870 --> 01:07:23,860
We do an experiment.

1181
01:07:23,860 --> 01:07:27,350
We call the procedure which is experiment on no arguments.

1182
01:07:27,350 --> 01:07:38,650
We do the experiment and then, if that turned out to be true, we go around the loop decrementing the number of experiments we have to do by one and incrementing the number that were passed.

1186
01:07:38,650 --> 01:07:48,910
And if the experiment was false, we just go around the loop decrementing the number of experiments remaining and keeping the number passed the same.

1189
01:07:48,910 --> 01:07:57,730
We start this up iterating over the total number of trials with 0 experiments past. A very elegant little program.

1192
01:07:57,730 --> 01:08:03,390
And I don't have to just do this with Cesaro's experiment, it could be lots of Monte Carlo experiments I might do.

1194
01:08:03,390 --> 01:08:07,440
Of course, this depends upon the existence of some sort of random number generator.

1196
01:08:07,440 --> 01:08:11,210
And random number generators generally look something like this.

1199
01:08:13,570 --> 01:08:25,710
There is a random number generator-- is in fact a procedure which is going to do something just like the counter.

1202
01:08:25,710 --> 01:08:41,689
It's going to update an x to the result of applying some function to x, where this function is some screwy kind of function that you might find out in Knuth's books on the details of programming.

1206
01:08:41,689 --> 01:08:51,720
He does these wonderful books that are full of the details of programming, because I can't remember how to make a random number generator, but I can look it up there, and I can find out.

1210
01:08:51,720 --> 01:08:58,319
And then, eventually, I return the value of x which is the state variable internal to the random number generator.

1212
01:08:58,319 --> 01:09:03,479
That state variable is initialized somehow, and has a value.

1214
01:09:03,479 --> 01:09:10,450
And this procedure is defined in the context where that variable is bound.

1216
01:09:10,450 --> 01:09:15,930
So this is a hidden piece of local state that you see here.

1217
01:09:15,930 --> 01:09:21,720
And this procedure is defined in that context.

1218
01:09:21,720 --> 01:09:24,103
Now, that's a very simple thing to do.

1219
01:09:24,103 --> 01:09:26,020
And it's very nice.

1220
01:09:26,020 --> 01:09:29,080
Supposing, I didn't want to use assignments.

1221
01:09:29,080 --> 01:09:32,840
Supposing, I wanted to write this program without assignments.

1223
01:09:32,840 --> 01:09:35,580
What problems would I have?

1224
01:09:35,580 --> 01:09:37,890
Well, let's see.

1225
01:09:37,890 --> 01:09:44,540
I'd like to use the overhead machine here, thank you.

1226
01:09:44,540 --> 01:09:45,870
First of all, let's look at the whole thing.

1227
01:09:45,870 --> 01:09:48,140
It's a big story.

1228
01:09:48,140 --> 01:09:51,720
Unfortunately, which tells you there is something wrong.

1229
01:09:51,720 --> 01:09:54,255
It's at least that big, and it's monolithic.

1231
01:09:57,020 --> 01:10:02,120
You don't have to understand or look at the text there right now to see that it's monolithic.

1233
01:10:02,120 --> 01:10:05,090
It isn't a thing which is Cesaro's experiment.

1234
01:10:05,090 --> 01:10:10,050
It's not pulled out from the Monte Carlo process.

1235
01:10:10,050 --> 01:10:10,890
It's not separated.

1236
01:10:10,890 --> 01:10:12,140
Let's look why.

1238
01:10:14,350 --> 01:10:23,070
Remember, the constraint here is that every procedure return the same value for the same arguments.

1240
01:10:23,070 --> 01:10:26,800
Every procedure represents a function.

1241
01:10:26,800 --> 01:10:28,275
That's a different kind of constraint.

1242
01:10:28,275 --> 01:10:31,840
Because when I have assignments, I can change some internal state variable.

1244
01:10:31,840 --> 01:10:35,060
So let's see how that causes things to go wrong.

1245
01:10:35,060 --> 01:10:38,510
Well, start at the beginning.

1246
01:10:38,510 --> 01:10:42,950
The estimate of pi looks sort of the same.

1247
01:10:42,950 --> 01:10:52,990
What I'm doing is I take the square root of six over the random GCD test applied to n, whereas that's what this is.

1249
01:10:52,990 --> 01:10:55,390
But here, we are beginning to see something funny.

1250
01:10:55,390 --> 01:11:10,870
The random GCD test of a certain number of trials is just like we had before, an iteration on the number of trials remaining, the number of trials that have been passed, and another variable x.

1254
01:11:10,870 --> 01:11:12,370
What's that x?

1255
01:11:12,370 --> 01:11:14,950
That x is the state of the random number generator.

1257
01:11:18,950 --> 01:11:21,150
And it is now going to be used here.

1258
01:11:21,150 --> 01:11:31,710
The same random update function that I have over here is the one I would have used in a random number generator if I were building it the other way, the one I get out of Knuth's books.

1262
01:11:31,710 --> 01:11:34,950
x is going to get transformed into x1, I need two random numbers.

1264
01:11:34,950 --> 01:11:39,550
And x1 is going to get transformed into x2, I have two random numbers.

1266
01:11:39,550 --> 01:11:42,620
I then have to do exactly what I did before.

1267
01:11:42,620 --> 01:11:43,870
I take the GCD of x1 x2.

1268
01:11:43,870 --> 01:11:49,520
If that's one, then I go around the loop with x2 being the next value of x.

1271
01:11:54,850 --> 01:12:01,495
You see what's happened here is that the state of the random number generator is no longer confined to the insides of the random number generator.

1274
01:12:01,495 --> 01:12:03,450
It has leaked out.

1275
01:12:03,450 --> 01:12:10,720
It has leaked out into my procedure that does the Monte Carlo experiment.

1277
01:12:10,720 --> 01:12:18,090
But what's worse than that, is it's also, because it was contained inside my experiment itself, Cesaro, it leaked out of that too.

1280
01:12:18,090 --> 01:12:36,490
Because Cesaro called twice, has to have a different value each time, if I going to have a legitimate experimental test. So Cesaro can't be a function either, unless I pass it the seed of the random number generator that is going to go wandering around.

1285
01:12:36,490 --> 01:12:45,465
So unfortunately, the seed of random number generator has leaked out into Cesaro, from the random number generator, that's leaked into the Monte Carlo experiment.

1288
01:12:45,465 --> 01:12:50,310
And, unfortunately, my Monte Carlo experiment here is no longer general.

1290
01:12:50,310 --> 01:12:54,405
The Monte Carlo experiment here knows how many random numbers I need to do the experiment.

1293
01:12:58,530 --> 01:13:00,230
That's sort of horrible.

1294
01:13:00,230 --> 01:13:22,770
I lost an ability to decompose a problem into pieces, because I wasn't willing to accept the little loop of information, the feedback process, that happens inside the random number generator before that was made by having an assignment to a state variable that was confined to the random number generator.

1300
01:13:22,770 --> 01:13:34,290
So the fact that the random number generator is an object, with an internal state variable, it's affected by nothing, but it'll give you something, and it will apply it's force to you, that was what we're missing now.

1305
01:13:38,140 --> 01:13:45,510
OK, well I think we've seen enough reason for doing this, and it all sort of looks very wonderful.

1307
01:13:45,510 --> 01:13:55,440
Wouldn't it be nice if assignment was a good thing and maybe it's worth it, but I'm not sure.

1309
01:13:55,440 --> 01:14:01,940
As Mr. Gilbert and Sullivan said, things are seldom what they seem, skim milk masquerades as cream.

1311
01:14:01,940 --> 01:14:03,655
Are there any questions?

1313
01:14:17,010 --> 01:14:20,120
Are there any philosophers here?

1314
01:14:20,120 --> 01:14:21,930
Anybody want to argue about objects?

1316
01:14:24,590 --> 01:14:25,840
You're just floored, right?

1318
01:14:29,840 --> 01:14:30,805
And you haven't done your homework yet.

1319
01:14:30,805 --> 01:14:32,055
You haven't come up with a good question.

1321
01:14:36,790 --> 01:14:38,040
Oh, well.

1323
01:14:40,110 --> 01:14:41,120
Sure, thank you.

1324
01:14:41,120 --> 01:14:42,370
Let's take the long break now.

