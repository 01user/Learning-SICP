1
00:00:18,550 --> 00:00:22,230
PROFESSOR: Well, last time Gerry really let the cat out of the bag.

3
00:00:22,230 --> 00:00:26,350
He introduced the idea of assignment.

4
00:00:26,350 --> 00:00:33,405
Assignment and state.

6
00:00:37,620 --> 00:00:45,350
And as we started to see, the implications of introducing assignment and state into the language are absolutely frightening.

9
00:00:45,350 --> 00:00:48,865
First of all, the substitution model of evaluation breaks down.

11
00:00:48,865 --> 00:00:58,130
And we have to use this much more complicated environment model and this very mechanistic thing with diagrams, even to say what statements in the programming language mean.

15
00:00:58,130 --> 00:01:00,260
And that's not a mere technical point.

16
00:01:00,260 --> 00:01:05,870
See, it's not that we had this particular substitution model and, well, it doesn't quite work, so we have to do something else.

19
00:01:05,870 --> 00:01:10,730
It's that nothing like the substitution model can work.

20
00:01:10,730 --> 00:01:18,080
Because suddenly, a variable is not just something that stands for a value.

22
00:01:18,080 --> 00:01:23,630
A variable now has to somehow specify a place that holds a value.

24
00:01:23,630 --> 00:01:25,885
And the value that's in that place can change.

26
00:01:30,280 --> 00:01:40,410
Or for instance, an expression like f of x might have a side effect in it.

28
00:01:40,410 --> 00:01:49,730
So if we say f of x and it has some value, and then later we say f of x again, we might get a different value depending on the order.

31
00:01:49,730 --> 00:01:54,030
So suddenly, we have to think not only about values but about time.

34
00:01:57,970 --> 00:02:02,520
And then things like pairs are no longer just their CARs and their CDRs.

36
00:02:02,520 --> 00:02:08,449
A pair now is not quite its CAR and its CDR. It's rather its identity.

38
00:02:08,449 --> 00:02:11,650
So a pair has identity.

39
00:02:11,650 --> 00:02:12,900
It's an object.

41
00:02:21,330 --> 00:02:30,900
And two pairs that have the same CAR and CDR might be the same or different, because suddenly we have to worry about sharing.

45
00:02:34,960 --> 00:02:40,480
So all of these things enter as soon as we introduce assignment.

47
00:02:40,480 --> 00:02:45,400
See, this is a really far cry from where we started with substitution.

49
00:02:45,400 --> 00:02:53,540
It's a technically harder way of looking at things because we have to think more mechanistically about our programming language.

52
00:02:53,540 --> 00:02:55,960
We can't just think about it as mathematics.

53
00:02:55,960 --> 00:03:04,050
It's philosophically harder, because suddenly there are all these funny issues about what does it mean that something changes or that two things are the same.

56
00:03:04,050 --> 00:03:18,210
And also, it's programming harder, because as Gerry showed last time, there are all these bugs having to do with bad sequencing and aliasing that just don't exist in a language where we don't worry about objects.

60
00:03:18,210 --> 00:03:23,635
Well, how'd we get into this mess?

61
00:03:23,635 --> 00:03:42,760
Remember what we did, the reason we got into this is because we were looking to build modular systems. We wanted to build systems that fall apart into chunks that seem natural.

65
00:03:42,760 --> 00:04:06,980
So for instance, we want to take a random number generator and package up the state of that random number generator inside of it so that we can separate the idea of picking random numbers from the general Monte Carlo strategy of estimating something and separate that from the particular way that you work with random numbers in that formula developed by Cesaro for pi.

72
00:04:06,980 --> 00:04:24,900
And similarly, when we go off and construct some models of things, if we go off and model a system that we see in the real world, we'd like our program to break into natural pieces, pieces that mirror the parts of the system that we see in the real world.

77
00:04:24,900 --> 00:04:35,160
So for example, if we look at a digital circuit, we say, gee, there's a circuit and it has a piece and it has another piece.

81
00:04:40,100 --> 00:04:43,580
And these different pieces sort of have identity.

82
00:04:43,580 --> 00:04:45,550
They have state.

83
00:04:45,550 --> 00:04:48,580
And the state sits on these wires.

84
00:04:48,580 --> 00:04:52,610
And we think of this piece as an object that's different from that as an object.

86
00:04:52,610 --> 00:05:02,170
And when we watch the system change, we think about a signal coming in here and changing a state that might be here and going here and interacting with a state that might be stored there, and so on and so on.

91
00:05:06,860 --> 00:05:23,365
So what we'd like is we'd like to build in the computer systems that fall into pieces that mirror our view of reality, of the way that the actual systems we're modeling seem to fall into pieces.

95
00:05:23,365 --> 00:05:33,610
Well, maybe the reason that building systems like this seems to introduce such technical complications has nothing to do with computers.

98
00:05:33,610 --> 00:05:44,550
See, maybe the real reason that we pay such a price to write programs that mirror our view of reality is that we have the wrong view of reality.

101
00:05:44,550 --> 00:05:50,150
See, maybe time is just an illusion, and nothing ever changes.

103
00:05:50,150 --> 00:05:55,820
See, for example, if I take this chalk, and we say, gee, this is an object and it has a state.

105
00:05:55,820 --> 00:05:59,710
At each moment it has a position and a velocity.

106
00:05:59,710 --> 00:06:01,240
And if we do something, that state can change.

108
00:06:04,340 --> 00:06:11,340
But if you studied any relativity, for instance, you know that you don't think of the path of that chalk as something that goes on instant by instant.

111
00:06:11,340 --> 00:06:16,020
It's more insightful to think of that whole chalk's existence as a path in space-time.

113
00:06:16,020 --> 00:06:18,040
that's all splayed out.

114
00:06:18,040 --> 00:06:19,840
There aren't individual positions and velocities.

115
00:06:19,840 --> 00:06:24,640
There's just its unchanging existence in space-time.

116
00:06:24,640 --> 00:06:41,490
Similarly, if we look at this electrical system, if we imagine this electrical system is implementing some sort of signal processing system, the signal processing engineer who put that thing together doesn't think of it as, well, at each instance there's a voltage coming in.

121
00:06:41,490 --> 00:06:43,340
And that translates into something.

122
00:06:43,340 --> 00:06:46,810
And that affects the state over here, which changes the state over here.

124
00:06:46,810 --> 00:06:50,420
Nobody putting together a signal processing system thinks about it like that.

126
00:06:50,420 --> 00:06:58,060
Instead, you say there's this signal that's splayed out over time.

128
00:06:58,060 --> 00:07:09,570
And if this is acting as a filter, this whole thing transforms this whole thing for some sort of other output.

130
00:07:09,570 --> 00:07:14,160
You don't think of it as what's happening instant by instant as the state of these things.

132
00:07:14,160 --> 00:07:22,230
And somehow you think of this box as a whole thing, not as little pieces sending messages of state to each other at particular instants.

136
00:07:28,250 --> 00:07:41,130
Well, today we're going to look at another way to decompose systems that's more like the signal processing engineer's view of the world than it is like thinking about objects that communicate sending messages.

140
00:07:41,130 --> 00:07:43,310
That's called stream processing.

142
00:07:54,570 --> 00:08:17,210
And we're going to start by showing how we can make our programs more uniform and see a lot more commonality if we throw out of these programs what you might say is an inordinate concern with worrying about time.

146
00:08:17,210 --> 00:08:19,910
Let me start by comparing two procedures.

148
00:08:23,260 --> 00:08:25,690
The first one does this.

149
00:08:25,690 --> 00:08:27,770
We imagine that there's a tree.

151
00:08:30,400 --> 00:08:33,179
Say there's a tree of integers.

152
00:08:33,179 --> 00:08:34,429
It's a binary tree.

154
00:08:39,100 --> 00:08:40,230
So it looks like this.

155
00:08:40,230 --> 00:08:44,990
And there's integers in each of the nodes.

156
00:08:44,990 --> 00:08:57,210
And what we would like to compute is for each odd number sitting here, we'd like to find the square and then sum up all those squares.

159
00:08:57,210 --> 00:08:59,480
Well, that should be a familiar kind of thing.

160
00:08:59,480 --> 00:09:02,930
There's a recursive strategy for doing it.

161
00:09:02,930 --> 00:09:08,680
We look at each leaf, and either it's going to contribute the square of the number if it's odd or 0 if it's even.

164
00:09:08,680 --> 00:09:17,640
And then recursively, we can say at each tree, the sum of all of them is the sum coming from the right branch and the left branch, and recursively down through the nodes.

167
00:09:17,640 --> 00:09:20,360
And that's a familiar way of thinking about programming.

168
00:09:20,360 --> 00:09:23,960
Let's actually look at that on the slide.

169
00:09:23,960 --> 00:09:37,160
We say to sum the odd squares in a tree, well, there's a test. Either it's a leaf node, and we're going to check to see if it's an integer, and then either it's odd, in which we take the square, or else it's 0.

173
00:09:37,160 --> 00:09:42,120
And then the sum of the whole thing is the sum coming from the left branch and the right branch.

176
00:09:46,340 --> 00:09:51,560
OK, well, let me contrast that with a second problem.

177
00:09:51,560 --> 00:09:59,270
Suppose I give you an integer n, and then some function to compute of the first of each integer in 1 through n.

179
00:09:59,270 --> 00:10:05,600
And then I want to collect together in a list all those function values that satisfy some property.

181
00:10:05,600 --> 00:10:06,880
That's a general kind of thing.

182
00:10:06,880 --> 00:10:14,210
Let's say to be specific, let's imagine that for each integer, k, we're going to compute the k Fibonacci number.

185
00:10:14,210 --> 00:10:19,050
And then we'll see which of those are odd and assemble those into a list.

187
00:10:19,050 --> 00:10:20,710
So here's a procedure that does that.

189
00:10:23,730 --> 00:10:26,240
Find the odd Fibonacci numbers among the first n.

190
00:10:26,240 --> 00:10:28,910
And here is a standard loop the way we've been writing it.

191
00:10:28,910 --> 00:10:30,800
This is a recursion.

192
00:10:30,800 --> 00:10:40,370
It's a loop on k, and says if k is bigger than n, it's the empty list. Otherwise we compute the k-th Fibonacci number, call that f.

195
00:10:40,370 --> 00:10:47,690
If it's odd, we CONS it on to the list starting with the next one.

197
00:10:47,690 --> 00:10:50,390
And otherwise, we just take the next one.

198
00:10:50,390 --> 00:10:53,000
And this is the standard way we've been writing iterative loops.

200
00:10:53,000 --> 00:10:57,600
And we start off calling that loop with 1.

201
00:10:57,600 --> 00:11:01,600
OK, so there are two procedures.

202
00:11:01,600 --> 00:11:02,900
Those procedures look very different.

203
00:11:02,900 --> 00:11:04,390
They have very different structures.

204
00:11:04,390 --> 00:11:11,330
Yet from a certain point of view, those procedures are really doing very much the same thing.

206
00:11:11,330 --> 00:11:26,980
So if I was talking like a signal processing engineer, what I might say is that the first procedure enumerates the leaves of a tree.

210
00:11:31,160 --> 00:11:35,330
And then we can think of a signal coming out of that, which is all the leaves.

212
00:11:35,330 --> 00:11:45,190
We'll filter them to see which ones are odd, put them through some kind of filter.

214
00:11:45,190 --> 00:11:49,000
We'll then put them through a kind of transducer.

215
00:11:49,000 --> 00:11:51,420
And for each one of those things, we'll take the square.

217
00:11:54,200 --> 00:11:58,290
And then we'll accumulate all of those.

218
00:11:58,290 --> 00:12:03,340
We'll accumulate them by sticking them together with addition starting from 0.

221
00:12:07,140 --> 00:12:08,210
That's the first program.

222
00:12:08,210 --> 00:12:11,780
The second program, I can describe in a very, very similar way.

224
00:12:11,780 --> 00:12:19,080
I'll say, we'll enumerate the numbers on this interval, for the interval 1 through n.

227
00:12:22,500 --> 00:12:29,270
We'll, for each one, compute the Fibonacci number, put them through a transducer.

229
00:12:29,270 --> 00:12:35,976
We'll then take the result of that, and we'll filter it for oddness.

231
00:12:35,976 --> 00:12:39,350
And then we'll take those and put them into an accumulator.

232
00:12:39,350 --> 00:12:47,110
This time we'll build up a list, so we'll accumulate with CONS starting from the empty list.

234
00:12:47,110 --> 00:12:51,900
So this way of looking at the program makes the two seem very, very similar.

236
00:12:51,900 --> 00:12:58,050
The problem is that that commonality is completely obscured when we look at the procedures we wrote.

238
00:12:58,050 --> 00:13:06,300
Let's go back and look at some odd squares again, and say things like, where's the enumerator?

240
00:13:06,300 --> 00:13:08,140
Where's the enumerator in this program?

241
00:13:08,140 --> 00:13:11,230
Well, it's not in one place.

242
00:13:11,230 --> 00:13:17,160
It's a little bit in this leaf-node test, which is going to stop.

244
00:13:17,160 --> 00:13:20,630
It's a little bit in the recursive structure of the thing itself.

247
00:13:23,150 --> 00:13:24,120
Where's the accumulator?

248
00:13:24,120 --> 00:13:25,680
The accumulator isn't in one place either.

249
00:13:25,680 --> 00:13:32,180
It's partly in this 0 and partly in this plus.

250
00:13:32,180 --> 00:13:34,510
It's not there as a thing that we can look at.

251
00:13:34,510 --> 00:13:44,470
Similarly, if we look at odd Fibs, that's also, in some sense, an enumerator and an accumulator, but it looks very different.

254
00:13:44,470 --> 00:13:55,680
Because partly, the enumerator is here in this greater than sign in the test. And partly it's in this whole recursive structure in the loop, and the way that we call it.

257
00:13:55,680 --> 00:14:03,600
And then similarly, that's also mixed up in there with the accumulator, which is partly over there and partly over there.

260
00:14:03,600 --> 00:14:14,360
So these very, very natural pieces, these very natural boxes here don't appear in our programs. Because they're kind of mixed up.

263
00:14:14,360 --> 00:14:16,290
The programs don't chop things up in the right way.

265
00:14:19,450 --> 00:14:31,060
Going back to this fundamental principle of computer science that in order to control something, you need the name of it, we don't really have control over thinking about things this way because we don't have our hands in them explicitly.

270
00:14:31,060 --> 00:14:35,510
We don't have a good language for talking about them.

271
00:14:35,510 --> 00:14:44,515
Well, let's invent an appropriate language in which we can build these pieces.

273
00:14:44,515 --> 00:14:50,480
The key to the language is these guys, is what is these things I called signals?

275
00:14:50,480 --> 00:14:53,320
What are these things that are flying on the arrows between the boxes?

278
00:14:56,880 --> 00:15:07,980
Well, those things are going to be data structures called streams. That's going to be the key to inventing this language.

281
00:15:07,980 --> 00:15:08,600
What's a stream?

282
00:15:08,600 --> 00:15:12,220
Well, a stream is, like anything else, a data abstraction.

284
00:15:12,220 --> 00:15:16,870
So I should tell you what its selectors and constructors are.

286
00:15:16,870 --> 00:15:21,435
For a stream, we're going to have one constructor that's called CONS-stream.

289
00:15:25,690 --> 00:15:32,040
CONS-stream is going to put two things together to form a thing called a stream.

291
00:15:32,040 --> 00:15:38,010
And then to extract things from the stream, we're going to have a selector called the head of the stream.

293
00:15:38,010 --> 00:15:44,720
So if I have a stream, I can take its head or I can take its tail.

295
00:15:44,720 --> 00:15:53,160
And remember, I have to tell you George's contract here to tell you what the axioms are that relate these.

297
00:15:53,160 --> 00:16:28,440
And it's going to be for any x and y, if I form the CONS-stream and take the head, the head of CONS-stream of x and y is going to be x and the tail of CONS-stream of x and y is going to be y.

301
00:16:28,440 --> 00:16:34,750
So those are the constructor, two selectors for streams, and an axiom.

303
00:16:34,750 --> 00:16:36,980
There's something fishy here.

304
00:16:36,980 --> 00:16:52,810
So you might notice that these are exactly the axioms for CONS, CAR, and CDR. If instead of writing CONS-stream I wrote CONS and I said head was the CAR and tail was the CDR, those are exactly the axioms for pairs.

308
00:16:52,810 --> 00:16:55,130
And in fact, there's another thing here.

309
00:16:55,130 --> 00:17:08,319
We're going to have a thing called the-empty-stream, which is like the-empty-list.

311
00:17:08,319 --> 00:17:10,030
So why am I introducing this terminology?

312
00:17:10,030 --> 00:17:12,780
Why don't I just keep talking about pairs and lists?

313
00:17:12,780 --> 00:17:15,510
Well, we'll see.

314
00:17:15,510 --> 00:17:21,560
For now, if you like, why don't you just pretend that streams really are just a terminology for lists.

316
00:17:21,560 --> 00:17:28,150
And we'll see in a little while why we want to keep this extra abstraction layer and not just call them lists.

319
00:17:32,300 --> 00:17:42,120
OK, now that we have streams, we can start constructing the pieces of the language to operate on streams. And there are a whole bunch of very useful things that we could start making.

323
00:17:42,120 --> 00:18:05,666
For instance, we'll make our map box to take a stream, s, and a procedure, and to generate a new stream which has as its elements the procedure applied to all the successive elements of s.

327
00:18:05,666 --> 00:18:07,400
In fact, we've seen this before.

328
00:18:07,400 --> 00:18:10,950
This is the procedure map that we did with lists.

329
00:18:10,950 --> 00:18:14,650
And you see it's exactly map, except we're testing for empty-stream.

331
00:18:14,650 --> 00:18:15,560
Oh, I forgot to mention that.

332
00:18:15,560 --> 00:18:20,510
Empty-stream is like the null test. So if it's empty, we generate the empty stream.

334
00:18:20,510 --> 00:18:33,140
Otherwise, we form a new stream whose first element is the procedure applied to the head of the stream, and whose rest is gotten by mapping along with the procedure down the tail of the stream.

338
00:18:33,140 --> 00:18:37,030
So that looks exactly like the map procedure we looked at before.

340
00:18:37,030 --> 00:18:38,350
Here's another useful thing.

341
00:18:38,350 --> 00:18:40,460
Filter, this is our filter box.

342
00:18:40,460 --> 00:18:43,890
We're going to have a predicate and a stream.

343
00:18:43,890 --> 00:18:50,160
We're going to make a new stream that consists of all the elements of the original one that satisfy the predicate.

346
00:18:50,160 --> 00:18:51,270
That's case analysis.

347
00:18:51,270 --> 00:18:56,280
When there's nothing in the stream, we return the empty stream.

349
00:18:56,280 --> 00:19:00,060
We test the predicate on the head of the stream.

350
00:19:00,060 --> 00:19:08,220
And if it's true, we add the head of the stream onto the result of filtering the tail of the stream.

352
00:19:08,220 --> 00:19:13,500
And otherwise, if that predicate was false, we just filter the tail of the stream.

354
00:19:13,500 --> 00:19:16,595
Right, so there's filter.

355
00:19:16,595 --> 00:19:18,560
Let me run through a couple more rather quickly.

356
00:19:18,560 --> 00:19:20,880
They're all in the book and you can look at them.

357
00:19:20,880 --> 00:19:22,110
Let me just flash through.

358
00:19:22,110 --> 00:19:23,260
Here's accumulate.

359
00:19:23,260 --> 00:19:31,560
Accumulate takes a way of combining things and an initial value in a stream and sticks them all together.

361
00:19:31,560 --> 00:19:33,970
If the stream's empty, it's just the initial value.

362
00:19:33,970 --> 00:19:40,900
Otherwise, we combine the head of the stream with the result of accumulating the tail of the stream starting from the initial value.

365
00:19:40,900 --> 00:19:42,830
So that's what I'd use to add up everything in the stream.

366
00:19:42,830 --> 00:19:45,830
I'd accumulate with plus.

367
00:19:45,830 --> 00:19:48,060
How would I enumerate the leaves of a tree?

368
00:19:48,060 --> 00:19:56,640
Well, if the tree is just a leaf itself, I make something which only has that node in it.

370
00:19:56,640 --> 00:20:04,340
Otherwise, I append together the stuff of enumerating the left branch and the right branch.

372
00:20:04,340 --> 00:20:08,130
And then append here is like the ordinary append on lists.

374
00:20:13,190 --> 00:20:13,850
You can look at that.

375
00:20:13,850 --> 00:20:19,150
That's analogous to the ordinary procedure for appending two lists.

377
00:20:19,150 --> 00:20:21,810
How would I enumerate an interval?

378
00:20:21,810 --> 00:20:28,106
This will take two integers, low and high, and generate a stream of the integers going from low to high.

380
00:20:28,106 --> 00:20:31,890
And we can make a whole bunch of pieces.

381
00:20:31,890 --> 00:20:37,670
So that's a little language of talking about streams. Once we have streams, we can build things for manipulating them.

383
00:20:37,670 --> 00:20:40,200
Again, we're making a language.

384
00:20:40,200 --> 00:20:43,060
And now we can start expressing things in this language.

386
00:20:43,060 --> 00:20:47,310
Here's our original procedure for summing the odd squares in a tree.

388
00:20:47,310 --> 00:20:54,590
And you'll notice it looks exactly now like the block diagram, like the signal processing block diagram.

390
00:20:54,590 --> 00:21:01,320
So to sum the odd squares in a tree, we enumerate the leaves of the tree.

392
00:21:01,320 --> 00:21:04,830
We filter that for oddness.

393
00:21:04,830 --> 00:21:06,220
We map that for squareness.

395
00:21:09,320 --> 00:21:14,760
And we accumulate the result of that using addition, starting from 0.

397
00:21:14,760 --> 00:21:17,290
So we can see the pieces that we wanted.

398
00:21:17,290 --> 00:21:22,050
Similarly, the Fibonacci one, how do we get the odd Fibs?

399
00:21:22,050 --> 00:21:30,920
Well, we enumerate the interval from 1 to n, we map along that, computing the Fibonacci of each one.

401
00:21:30,920 --> 00:21:34,810
We filter the result of those for oddness.

402
00:21:34,810 --> 00:21:43,650
And we accumulate all of that stuff using CONS starting from the empty-list.

404
00:21:43,650 --> 00:21:47,680
OK, what's the advantage of this?

405
00:21:47,680 --> 00:21:51,880
Well, for one thing, we now have pieces that we can start mixing and matching.

407
00:21:51,880 --> 00:22:06,210
So for instance, if I wanted to change this, if I wanted to compute the squares of the integers and then filter them, all I need to do is pick up a standard piece like this in that square and put it in.

411
00:22:06,210 --> 00:22:18,030
Or if we wanted to do this whole Fibonacci computation on the leaves of a tree rather than a sequence, all I need to do is replace this enumerator with that one.

414
00:22:18,030 --> 00:22:38,130
See, the advantage of this stream processing is that we're establishing-- this is one of the big themes of the course-- we're establishing conventional interfaces that allow us to glue things together.

419
00:22:38,130 --> 00:22:45,750
Things like map and filter are a standard set of components that we can start using for pasting together programs in all sorts of ways.

422
00:22:45,750 --> 00:22:50,090
It allows us to see the commonality of programs.

423
00:22:50,090 --> 00:22:53,860
I just ought to mention, I've only showed you two procedures.

425
00:22:53,860 --> 00:23:01,410
But let me emphasize that this way of putting things together with maps, filters, and accumulators is very, very general.

428
00:23:01,410 --> 00:23:30,710
It's the generate and test paradigm for programs. And as an example of that, Richard Waters, who was at MIT when he was a graduate student, as part of his thesis research went and analyzed a large chunk of the IBM scientific subroutine library, and discovered that about 60% of the programs in it could be expressed exactly in terms using no more than what we've put here-- map, filter, and accumulate.

436
00:23:30,710 --> 00:23:31,960
All right, let's take a break.

438
00:23:36,620 --> 00:23:37,870
Questions?

440
00:23:40,470 --> 00:23:48,380
AUDIENCE: It seems like the essence of this whole thing is just that you have a very uniform, simple data structure to work with, the stream.

443
00:23:48,380 --> 00:23:48,920
PROFESSOR: Right.

444
00:23:48,920 --> 00:23:53,710
The essence is that you, again, it's this sense of conventional interfaces.

446
00:23:53,710 --> 00:23:55,610
So you can start putting a lot of things together.

447
00:23:55,610 --> 00:24:00,890
And the stream is as you say, the uniform data structure that supports that.

449
00:24:00,890 --> 00:24:03,600
This is very much like APL, by the way.

450
00:24:03,600 --> 00:24:09,560
APL is very much the same idea, except in APL, instead of this stream, you have arrays and vectors.

452
00:24:09,560 --> 00:24:14,815
And a lot of the power of APL is exactly the same reason of the power of this.

455
00:24:19,910 --> 00:24:20,910
OK, thank you.

456
00:24:20,910 --> 00:24:22,160
Let's take a break.

458
00:24:57,470 --> 00:24:57,610
All right.

459
00:24:57,610 --> 00:25:10,810
We've been looking at ways of organizing computations using streams. What I want to do now is just show you two somewhat more complicated examples of that.

462
00:25:10,810 --> 00:25:16,810
Let's start by thinking about the following kind of utility procedure that will come in useful.

464
00:25:16,810 --> 00:25:19,960
Suppose I've got a stream.

465
00:25:19,960 --> 00:25:23,730
And the elements of this stream are themselves streams.

466
00:25:23,730 --> 00:25:26,530
So the first thing might be 1, 2, 3.

468
00:25:32,600 --> 00:25:33,880
So I've got a stream.

469
00:25:33,880 --> 00:25:40,100
And each element of the stream is itself a stream.

470
00:25:40,100 --> 00:25:52,080
And what I'd like to do is build a stream that collects together all of the elements, pulls all of the elements out of these sub-streams and strings them all together in one thing.

474
00:25:52,080 --> 00:25:56,960
So just to show you the use of this language, how easy it is, call that flatten.

476
00:25:56,960 --> 00:26:13,960
And I can define to flatten this stream of streams. Well, what is that?

478
00:26:13,960 --> 00:26:16,240
That's just an accumulation.

479
00:26:16,240 --> 00:26:26,450
I want to accumulate using append, by successively appending.

481
00:26:26,450 --> 00:26:54,370
So I accumulate using append streams, starting with the-empty-stream down that stream of streams.

483
00:26:54,370 --> 00:27:00,830
OK, so there's an example of how you can start using these higher order things to do some interesting operations.

485
00:27:00,830 --> 00:27:05,100
In fact, there's another useful thing that I want to do.

487
00:27:05,100 --> 00:27:21,840
I want to define a procedure called flat-map, flat map of some function and a stream.

489
00:27:21,840 --> 00:27:25,720
And what this is going to do is f will be a stream of elements.

491
00:27:25,720 --> 00:27:31,950
f is going to be a function that for each element in the stream produces another stream.

493
00:27:31,950 --> 00:27:36,000
And what I want to do is take all of the elements and all of those streams and combine them together.

495
00:27:36,000 --> 00:27:51,350
So that's just going to be the flatten of map f down s.

496
00:27:51,350 --> 00:27:54,290
Each time I apply f to an element of s, I get a stream.

497
00:27:54,290 --> 00:27:58,385
If I map it all the way down, I get a stream of streams, and I'll flatten that.

499
00:27:58,385 --> 00:28:06,360
Well, I want to use that to show you a new way to do a familiar kind of problem.

501
00:28:06,360 --> 00:28:14,190
The problem's going to be like a lot of problems you've seen, although maybe not this particular one.

503
00:28:14,190 --> 00:28:15,490
I'm going to give you an integer, n.

505
00:28:18,480 --> 00:28:51,910
And the problem is going to be find all pairs and integers i and j, between 0 and i, with j less than i, up to n, such that i plus j is prime.

509
00:28:55,740 --> 00:29:06,640
So for example, if n equals 6, let's make a little table here, i and j and i plus j.

512
00:29:09,700 --> 00:29:15,520
So for, say, i equals 2 and j equals 1, I'd get 3.

513
00:29:15,520 --> 00:29:21,210
And for i equals 3, I could have j equals 2, and that would be 5.

515
00:29:21,210 --> 00:29:28,400
And 4 and 1 would be 5 and so on, up until i goes to 6.

516
00:29:28,400 --> 00:29:37,350
And what I'd like to return is to produce a stream of all the triples like this, let's say i, j, and i plus j.

518
00:29:37,350 --> 00:29:41,530
So for each n, I want to generate this stream.

519
00:29:41,530 --> 00:29:43,680
OK, well, that's easy.

520
00:29:43,680 --> 00:29:47,230
Let's build it up.

521
00:29:47,230 --> 00:29:50,150
We start like this.

522
00:29:50,150 --> 00:29:56,440
We're going to say for each i, we're going to generate a stream.

524
00:29:56,440 --> 00:30:00,660
For each i in the interval 1 through n, we're going to generate a stream.

526
00:30:00,660 --> 00:30:02,230
What's that stream going to be?

527
00:30:02,230 --> 00:30:04,180
We're going to start by generating all the pairs.

528
00:30:04,180 --> 00:30:20,710
So for each i, we're going to generate, for each j in the interval 1 to i minus 1, we'll generate the pair, or the list with two elements i and j.

532
00:30:23,780 --> 00:30:30,712
So we map along the interval, generating the pairs.

533
00:30:30,712 --> 00:30:33,170
And for each i, that generates a stream of pairs.

534
00:30:33,170 --> 00:30:34,590
And we flatmap it.

535
00:30:34,590 --> 00:30:38,730
Now we have all the pairs i and j, such that i is less than j.

537
00:30:38,730 --> 00:30:39,850
So that builds that.

538
00:30:39,850 --> 00:30:42,990
Now we're got to test them.

539
00:30:42,990 --> 00:30:51,660
Well, we take that thing we just built, the flatmap, and we filter it to see whether the i-- see, we had an i and a j.

542
00:30:51,660 --> 00:31:02,070
i was the first thing in the list, j was the second thing in the list. So we have a predicate which says in that list of two elements is the sum of the CAR and the CDR prime.

546
00:31:02,070 --> 00:31:06,540
And we filter that collection of pairs we just built.

547
00:31:06,540 --> 00:31:09,420
So those are the pairs we want.

548
00:31:09,420 --> 00:31:19,610
Now we go ahead and we take the result of that filter and we map along it, generating the list i and j and i plus j.

550
00:31:19,610 --> 00:31:22,910
And that's our procedure prime-sum-pairs.

551
00:31:22,910 --> 00:31:24,480
And then just to flash it up, here's the whole procedure.

553
00:31:27,945 --> 00:31:30,750
A map, a filter, a flatmap.

555
00:31:34,850 --> 00:31:37,120
There's the whole thing, even though this isn't particularly readable.

557
00:31:37,120 --> 00:31:40,000
It's just expanding that flatmap.

558
00:31:40,000 --> 00:31:54,200
So there's an example which illustrates the general point that nested loops in this procedure start looking like compositions of flatmaps of flatmaps of flatmaps of maps and things.

562
00:31:54,200 --> 00:32:03,230
So not only can we enumerate individual things, but by using flatmaps, we can do what would correspond to nested loops in most other languages.

565
00:32:03,230 --> 00:32:08,410
Of course, it's pretty awful to keep writing these flatmaps of flatmaps of flatmaps.

567
00:32:08,410 --> 00:32:15,480
Prime-sum-pairs you saw looked fairly complicated, even though the individual pieces were easy.

569
00:32:15,480 --> 00:32:21,040
So what you can do, if you like, is introduced some syntactic sugar that's called collect.

571
00:32:21,040 --> 00:32:26,160
And collect is just an abbreviation for that nest of flatmaps and filters arranged in that particular way.

573
00:32:26,160 --> 00:32:29,620
Here's prime-sum-pairs again, written using collect.

574
00:32:29,620 --> 00:32:58,040
It says to find all those pairs, I'm going to collect together a result, which is the list i, j, and i plus j, that's going to be generated as i runs through the interval from 1 to n and as j runs through the interval from 1 to i minus 1, such that i plus j is prime.

579
00:32:58,040 --> 00:33:00,690
So I'm not going to say what collect does in general.

580
00:33:00,690 --> 00:33:03,420
You can look at that by looking at it in the book.

581
00:33:03,420 --> 00:33:08,820
But pretty much, you can see that the pieces of this are the pieces of that original procedure I wrote.

583
00:33:08,820 --> 00:33:16,310
And this collect is just some syntactic sugar for automatically generating that nest of flatmaps and flatmaps.

585
00:33:16,310 --> 00:33:22,120
OK, well, let me do one more example that shows you the same kind of thing.

587
00:33:22,120 --> 00:33:30,200
Here's a very famous problem that's used to illustrate a lot of so-called backtracking computer algorithms. This is the eight queens problem.

590
00:33:30,200 --> 00:33:32,370
This is a chess board.

591
00:33:32,370 --> 00:33:38,000
And the eight queens problem says, find a way to put down eight queens on a chess board so that no two are attacking each other.

594
00:33:38,000 --> 00:33:41,430
And here's a particular solution to the eight queens problem.

596
00:33:41,430 --> 00:33:51,410
So I have to make sure to put down queens so that no two are in the same row or the same column or sit along the same diagonal.

599
00:33:51,410 --> 00:33:56,400
Now, there's sort of a standard way of doing that.

601
00:33:59,740 --> 00:34:04,940
Well, first we need to do is below the surface, at George's level.

603
00:34:04,940 --> 00:34:08,095
We have to find some way to represent a board, and represent positions.

605
00:34:08,095 --> 00:34:09,800
And we'll not worry about that.

606
00:34:09,800 --> 00:34:12,540
But let's assume that there's a predicate called safe.

608
00:34:16,040 --> 00:34:25,400
And what safe is going to do is going to say given that I have a bunch of queens down on the chess board, is it OK to put a queen in this particular spot?

611
00:34:25,400 --> 00:34:32,889
So safe is going to take a row and a column.

612
00:34:32,889 --> 00:34:42,370
That's going to be a place where I'm going to try and put down the next queen, and the rest of positions.

615
00:34:45,420 --> 00:34:58,300
And what safe will say is given that I already have queens down in these positions, is it safe to put another queen down in that row and that column?

618
00:34:58,300 --> 00:34:59,360
And let's not worry about that.

619
00:34:59,360 --> 00:35:01,380
That's George's problem. and it's not hard to write.

620
00:35:01,380 --> 00:35:10,530
You just have to check whether this thing contains any things on that row or that column or in that diagonal.

622
00:35:10,530 --> 00:35:13,590
Now, how would you organize the program given that?

623
00:35:13,590 --> 00:35:20,116
And there's sort of a traditional way to organize it called backtracking.

625
00:35:20,116 --> 00:35:31,290
And it says, well, let's think about all the ways of putting the first queen down in the first column.

627
00:35:31,290 --> 00:35:32,580
There are eight ways.

628
00:35:32,580 --> 00:35:35,880
Well, let's say try the first column.

629
00:35:35,880 --> 00:35:37,300
Try column 1, row 1.

630
00:35:37,300 --> 00:35:43,360
These branches are going to represent the possibilities at each level.

632
00:35:43,360 --> 00:35:45,875
So I'll try and put a queen down in the first column.

633
00:35:45,875 --> 00:35:49,980
And now given that it's in the first column, I'll try and put the next queen down in the first column.

636
00:35:53,035 --> 00:35:56,920
I'll try and put the first queen, the one in the first column, down in the first row.

638
00:35:56,920 --> 00:35:59,050
I'm sorry.

639
00:35:59,050 --> 00:36:01,390
And then given that, we'll put the next queen down in the first row.

641
00:36:01,390 --> 00:36:02,090
And that's no good.

642
00:36:02,090 --> 00:36:04,200
So I'll back up to here.

643
00:36:04,200 --> 00:36:07,510
And I'll say, oh, can I put the first queen down in the second row?

645
00:36:07,510 --> 00:36:08,550
Well, that's no good.

646
00:36:08,550 --> 00:36:09,760
Oh, can I put it down in the third row?

647
00:36:09,760 --> 00:36:12,790
Well, that's good.

648
00:36:12,790 --> 00:36:15,380
Well, now can I put the next queen down in the first column?

650
00:36:15,380 --> 00:36:19,195
Well, I can't visualize this chess board anymore, but I think that's right.

652
00:36:19,195 --> 00:36:20,450
And I try the next one.

653
00:36:20,450 --> 00:36:24,170
And at each place, I go as far down this tree as I can.

654
00:36:24,170 --> 00:36:25,640
And I back up.

655
00:36:25,640 --> 00:36:33,260
If I get down to here and find no possibilities below there, I back all the way up to here, and now start again generating this sub-tree.

658
00:36:33,260 --> 00:36:35,050
And I sort of walk around.

659
00:36:35,050 --> 00:36:40,090
And finally, if I ever manage to get all the way down, I've found a solution.

661
00:36:40,090 --> 00:36:45,930
So that's a typical sort of paradigm that's used a lot in AI programming.

663
00:36:45,930 --> 00:36:47,300
It's called backtracking search.

665
00:36:57,470 --> 00:37:03,860
And it's really unnecessary.

666
00:37:03,860 --> 00:37:06,550
You saw me get confused when I was visualizing this thing.

667
00:37:06,550 --> 00:37:08,550
And you see the complication.

668
00:37:08,550 --> 00:37:10,760
This is a complicated thing to say.

669
00:37:10,760 --> 00:37:12,390
Why is it complicated?

670
00:37:12,390 --> 00:37:18,580
Its because somehow this program is too inordinately concerned with time.

672
00:37:18,580 --> 00:37:22,320
It's too much-- I try this one, and I try this one, and I go back to the last possibility.

675
00:37:22,320 --> 00:37:24,340
And that's a complicated thing.

676
00:37:24,340 --> 00:37:31,200
If I stop worrying about time so much, then there's a much simpler way to describe this.

678
00:37:31,200 --> 00:37:43,400
It says, let's imagine that I have in my hands the tree down to k minus 1 levels.

680
00:37:43,400 --> 00:37:53,560
See, suppose I had in my hands all possible ways to put down queens in the first k columns.

682
00:37:53,560 --> 00:37:54,610
Suppose I just had that.

683
00:37:54,610 --> 00:37:57,070
Let's not worry about how we get it.

684
00:37:57,070 --> 00:37:59,200
Well, then, how do I extend that?

685
00:37:59,200 --> 00:38:02,480
How do I find all possible ways to put down queens in the next column?

687
00:38:02,480 --> 00:38:03,620
It's really easy.

688
00:38:03,620 --> 00:38:16,160
For each of these positions I have, I think about putting down a queen in each row to make the next thing.

690
00:38:16,160 --> 00:38:22,080
And then for each one I put down, I filter those by the ones that are safe.

692
00:38:22,080 --> 00:38:26,860
So instead of thinking about this tree as generated step by step, suppose I had it all there.

695
00:38:29,680 --> 00:38:37,800
And to extend it from level k minus 1 to level k, I just need to extend each thing in all possible ways and only keep the ones that are safe.

698
00:38:37,800 --> 00:38:39,300
And that will give me the tree to level k.

699
00:38:39,300 --> 00:38:44,530
And that's a recursive strategy for solving the eight queens problem.

701
00:38:44,530 --> 00:38:45,780
All right, well, let's look at it.

703
00:38:50,280 --> 00:39:01,030
To solve the eight queens problem on a board of some specified size, we write a sub-procedure called fill-columns.

706
00:39:01,030 --> 00:39:06,086
Fill-columns is going to put down queens up through column k.

708
00:39:06,086 --> 00:39:07,700
And here's the pattern of the recursion.

709
00:39:07,700 --> 00:39:12,990
I'm going to call fill-columns with the size eventually.

710
00:39:12,990 --> 00:39:20,360
So fill-columns says how to put down queens safely in the first k columns of this chess board with a size number of rows in it.

713
00:39:20,360 --> 00:39:23,940
If k is equal to 0, well, then I don't have to put anything down.

715
00:39:23,940 --> 00:39:26,710
So my solution is just an empty chess board.

716
00:39:26,710 --> 00:39:28,070
Otherwise, I'm going to do some stuff.

717
00:39:28,070 --> 00:39:30,522
And I'm going to use collect.

718
00:39:30,522 --> 00:39:31,772
And here's the collect.

720
00:39:34,530 --> 00:39:41,910
I find all ways to put down queens in the first k minus 1 columns.

722
00:39:41,910 --> 00:39:43,320
And this was just what I set for.

723
00:39:43,320 --> 00:39:48,880
Imagine I have this tree down to k minus 1 levels.

724
00:39:48,880 --> 00:39:54,130
And then I find all ways of trying a row, that's just each of the possible rows.

726
00:39:54,130 --> 00:39:58,040
They're size rows, so that's enumerate interval.

727
00:39:58,040 --> 00:40:08,950
And now what I do is I collect together the new row I'm going to try and column k with the rest of the queens.

729
00:40:08,950 --> 00:40:10,200
I adjoin a position.

730
00:40:10,200 --> 00:40:11,290
This is George's problem.

731
00:40:11,290 --> 00:40:13,640
An adjoined position is like safe.

732
00:40:13,640 --> 00:40:19,660
It's a thing that takes a row and a column and the rest of the positions and makes a new position collection.

734
00:40:19,660 --> 00:40:34,620
So I adjoin a position of a new row and a new column to the rest of the queens, where the rest of the queens runs through all possible ways of solving the problem in k minus 1 columns.

738
00:40:34,620 --> 00:40:43,240
And the new row runs through all possible rows such that it was safe to put one there.

740
00:40:43,240 --> 00:40:46,500
And that's the whole program.

741
00:40:46,500 --> 00:40:49,840
There's the whole procedure.

742
00:40:49,840 --> 00:40:56,680
Not only that, that doesn't just solve the eight queens problem, it gives you all solutions to the eight queens problem.

745
00:40:56,680 --> 00:40:58,480
When you're done, you have a stream.

746
00:40:58,480 --> 00:41:01,900
And the elements of that stream are all possible ways of solving that problem.

749
00:41:05,310 --> 00:41:06,260
Why is that simpler?

750
00:41:06,260 --> 00:41:12,720
Well, we threw away the whole idea that this is some process that happens in time with state.

752
00:41:12,720 --> 00:41:14,420
And we just said it's a whole collection of stuff.

753
00:41:14,420 --> 00:41:18,260
And that's why it's simpler.

754
00:41:18,260 --> 00:41:20,110
We've changed our view.

755
00:41:20,110 --> 00:41:22,820
Remember, that's where we started today.

756
00:41:22,820 --> 00:41:26,230
We've changed our view of what it is we're trying to model.

757
00:41:26,230 --> 00:41:31,750
we stop modeling things that evolve in time and have steps and have state.

759
00:41:31,750 --> 00:41:40,750
And instead, we're trying to model this global thing like the whole flight of the chalk, rather than its state at each instant.

762
00:41:40,750 --> 00:41:42,000
Any questions?

764
00:41:43,810 --> 00:41:54,030
AUDIENCE: It looks to me like backtracking would be searching for the first solution it can find, whereas this recursive search would be looking for all solutions.

767
00:41:54,030 --> 00:42:01,360
And it seems that if you have a large enough area to search, that the second is going to become impossible.

769
00:42:01,360 --> 00:42:08,570
PROFESSOR: OK, the answer to that question is the whole rest of this lecture.

771
00:42:08,570 --> 00:42:10,540
It's exactly the right question.

773
00:42:13,522 --> 00:42:22,220
And without trying to anticipate the lecture too much, you should start being suspicious at this point, and exactly those kinds of suspicions.

776
00:42:22,220 --> 00:42:24,830
It's wonderful, but isn't it so terribly inefficient?

777
00:42:24,830 --> 00:42:28,100
That's where we're going.

778
00:42:28,100 --> 00:42:30,020
So I won't answer now, but I'll answer later.

780
00:42:33,350 --> 00:42:34,600
OK, let's take a break.

782
00:43:29,650 --> 00:43:35,600
Well, by now you should be starting to get suspicious.

783
00:43:35,600 --> 00:43:53,740
See, I've showed your this simple, elegant way of putting programs together, very unlike these other traditional programs that sum the odd squares or compute the odd Fibonacci numbers.

787
00:43:53,740 --> 00:44:00,440
Very unlike these programs that mix up the enumerator and the filter and the accumulator.

789
00:44:00,440 --> 00:44:13,800
And by mixing it up, we don't have all of these wonderful conceptual advantages of these streams pieces, these wonderful mix and match components for putting together lots and lots of programs.

793
00:44:13,800 --> 00:44:18,340
On the other hand, most of the programs you've seen look like these ugly ones.

795
00:44:18,340 --> 00:44:19,460
Why's that?

796
00:44:19,460 --> 00:44:33,620
Can it possibly be that computer scientists are so obtuse that they don't notice that if you'd merely did this thing, then you can get this great programming elegance?

799
00:44:33,620 --> 00:44:36,760
There's got to be a catch.

800
00:44:36,760 --> 00:44:39,510
And it's actually pretty easy to see what the catch is.

801
00:44:39,510 --> 00:44:42,030
Let's think about the following problem.

802
00:44:42,030 --> 00:44:54,105
Suppose I tell you to find the second prime between 10,000 and 1 million, or if your computer's larger, say between 10,000 and 100 billion, or something.

805
00:44:54,105 --> 00:44:55,550
And you say, oh, that's easy.

806
00:44:55,550 --> 00:44:57,080
I can do that with a stream.

807
00:44:57,080 --> 00:45:04,160
All I do is I enumerate the interval from 10,000 to 1 million.

809
00:45:04,160 --> 00:45:06,800
So I get all those integers from 10,000 to 1 million.

810
00:45:06,800 --> 00:45:11,762
I filter them for prime-ness, so test all of them and see if they're prime.

812
00:45:11,762 --> 00:45:13,170
And I take the second element.

813
00:45:13,170 --> 00:45:16,130
That's the head of the tail.

814
00:45:16,130 --> 00:45:17,380
Well, that's clearly pretty ridiculous.

816
00:45:21,660 --> 00:45:27,040
We'd not even have room in the machine to store the integers in the first place, much less to test them.

818
00:45:27,040 --> 00:45:29,810
And then I only want the second one.

819
00:45:29,810 --> 00:45:45,090
See, the power of this traditional programming style is exactly its weakness, that we're mixing up the enumerating and the testing and the accumulating.

822
00:45:45,090 --> 00:45:46,670
So we don't do it all.

823
00:45:46,670 --> 00:45:55,210
So the very thing that makes it conceptually ugly is the very thing that makes it efficient.

825
00:45:55,210 --> 00:45:57,800
It's this mixing up.

826
00:45:57,800 --> 00:46:00,420
So it seems that all I've done this morning so far is just confuse you.

828
00:46:00,420 --> 00:46:05,840
I showed you this wonderful way that programming might work, except that it doesn't.

830
00:46:05,840 --> 00:46:09,040
Well, here's where the wonderful thing happens.

831
00:46:09,040 --> 00:46:14,870
It turns out in this game that we really can have our cake and eat it too.

833
00:46:14,870 --> 00:46:36,310
And what I mean by that is that we really can write stream programs exactly like the ones I wrote and arrange things so that when the machine actually runs, it's as efficient as running this traditional programming style that mixes up the generation and the test.

838
00:46:36,310 --> 00:46:40,770
Well, that sounds pretty magic.

839
00:46:40,770 --> 00:46:43,690
The key to this is that streams are not lists.

841
00:46:48,090 --> 00:46:52,115
We'll see this carefully in a second, but for now, let's take a look at that slide again.

843
00:46:52,115 --> 00:47:05,360
The image you should have here of this signal processing system is that what's going to happen is there's this box that has the integers sitting in it.

846
00:47:05,360 --> 00:47:10,940
And there's this filter that's connected to it and it's tugging on them.

848
00:47:10,940 --> 00:47:16,790
And then there's someone who's tugging on this stuff saying what comes out of the filter.

850
00:47:16,790 --> 00:47:24,590
And the image you should have is that someone says, well, what's the first prime, and tugs on this filter.

852
00:47:24,590 --> 00:47:28,020
And the filter tugs on the integers.

853
00:47:28,020 --> 00:47:30,930
And you look only at that much, and then say, oh, I really wanted the second one.

855
00:47:30,930 --> 00:47:33,710
What's the second prime?

856
00:47:33,710 --> 00:47:40,500
And that no computation gets done except when you tug on these things.

858
00:47:40,500 --> 00:47:41,410
Let me try that again.

859
00:47:41,410 --> 00:47:43,815
This is a little device.

860
00:47:43,815 --> 00:47:49,830
This is a little stream machine invented by Eric Grimson who's been teaching this course at MIT.

862
00:47:49,830 --> 00:47:54,780
And the image is here's a stream of stuff, like a whole bunch of the integers.

864
00:47:54,780 --> 00:47:58,700
And here's some processing elements.

865
00:47:58,700 --> 00:48:02,600
And if, say, it's filter of filter of map, or something.

867
00:48:05,570 --> 00:48:12,670
And if I really tried to implement that with streams as lists, what I'd say is, well, I've got this list of things, and now I do the first filter.

870
00:48:12,670 --> 00:48:14,070
So do all this processing.

871
00:48:14,070 --> 00:48:19,610
And I take this and I process and I process and I process and I process.

873
00:48:19,610 --> 00:48:21,910
And now I'm got this new stream.

874
00:48:21,910 --> 00:48:24,070
Now I take that result in my hand someplace.

875
00:48:24,070 --> 00:48:25,260
And I put that through the second one.

876
00:48:25,260 --> 00:48:28,110
And I process the whole thing.

877
00:48:28,110 --> 00:48:29,510
And there's this new stream.

879
00:48:32,130 --> 00:48:36,360
And then I take the result and I put it all the way through this one the same way.

881
00:48:36,360 --> 00:48:43,860
That's what would happen to these stream programs if streams were just lists.

883
00:48:43,860 --> 00:48:50,230
But in fact, streams aren't lists, they're streams. And the image you should have is something a little bit more like this.

886
00:48:50,230 --> 00:48:57,130
I've got these gadgets connected up by this data that's flowing out of them.

889
00:48:59,960 --> 00:49:05,980
And here's my original source of the streams. It might be starting to generate the integers.

891
00:49:05,980 --> 00:49:07,580
And now, what happens if I want a result?

892
00:49:07,580 --> 00:49:10,200
I tug on the end here.

893
00:49:10,200 --> 00:49:13,090
And this element says, gee, I need some more data.

894
00:49:13,090 --> 00:49:15,830
So this one comes here and tugs on that one.

895
00:49:15,830 --> 00:49:17,890
And it says, gee, I need some more data.

896
00:49:17,890 --> 00:49:21,640
And this one tugs on this thing, which might be a filter, and says, gee, I need some more data.

898
00:49:21,640 --> 00:49:25,780
And only as much of this thing at the end here gets generated as I tugged.

900
00:49:25,780 --> 00:49:30,760
And only as much of this stuff goes through the processing units as I'm pulling on the end I need.

902
00:49:30,760 --> 00:49:37,830
That's the image you should have of the difference between implementing what we're actually going to do and if streams were lists.

906
00:49:40,600 --> 00:49:42,430
Well, how do we make this thing?

907
00:49:42,430 --> 00:49:43,400
I hope you have the image.

908
00:49:43,400 --> 00:49:44,947
The trick is how to make it.

910
00:49:47,930 --> 00:49:56,920
We want to arrange for a stream to be a data structure that computes itself incrementally, an on-demand data structure.

914
00:49:59,220 --> 00:50:04,490
And the basic idea is, again, one of the very basic ideas that we're seeing throughout the whole course.

916
00:50:04,490 --> 00:50:09,240
And that is that there's not a firm distinction between programs and data.

918
00:50:09,240 --> 00:50:16,810
So what a stream is going to be is simultaneously this data structure that you think of, like the stream of the leaves of this tree.

921
00:50:16,810 --> 00:50:23,550
But at the same time, it's going to be a very clever procedure that has the method of computing in it.

923
00:50:23,550 --> 00:50:25,930
Well, let me try this.

924
00:50:25,930 --> 00:50:28,460
It's going to turn out that we don't need any more mechanism.

925
00:50:28,460 --> 00:50:35,460
We already have everything we need simply from the fact that we know how to handle procedures as first-class objects.

928
00:50:35,460 --> 00:50:36,880
Well, let's go back to the key.

929
00:50:36,880 --> 00:50:39,030
The key is, remember, we had these operations.

930
00:50:39,030 --> 00:50:48,080
CONS-stream and head and tail.

931
00:50:48,080 --> 00:50:55,080
When I started, I said you can think about this as CONS and think about this as CAR and think about that as CDR, but it's not.

934
00:50:55,080 --> 00:50:57,550
Now, let's look at what they really are.

935
00:50:57,550 --> 00:51:19,540
Well, CONS-stream of x and y is going to be an abbreviation for the following thing.

937
00:51:19,540 --> 00:51:28,000
CONS form a pair, ordinary CONS, of x to a thing called delay of y.

940
00:51:31,188 --> 00:51:39,790
And before I explain that, let me go and write the rest. The head of a stream is going to be just the CAR.

943
00:51:42,380 --> 00:51:56,120
And the tail of a stream is going to be a thing called force the CDR of the stream.

945
00:51:56,120 --> 00:51:58,060
Now let me explain this.

946
00:51:58,060 --> 00:52:01,420
Delay is going to be a special magic thing.

947
00:52:01,420 --> 00:52:10,600
What delay does is take an expression and produce a promise to compute that expression when you ask for it.

950
00:52:10,600 --> 00:52:11,980
It doesn't do any computation here.

951
00:52:11,980 --> 00:52:14,820
It just gives you a rain check.

952
00:52:14,820 --> 00:52:17,110
It produces a promise.

953
00:52:17,110 --> 00:52:25,360
And CONS-stream says I'm going to put together in a pair x and a promise to compute y.

956
00:52:28,230 --> 00:52:31,840
Now, if I want the head, that's just the CAR that I put in the pair.

958
00:52:31,840 --> 00:52:39,110
And the key is that the tail is going to be-- force calls in that promise.

960
00:52:39,110 --> 00:52:44,610
Tail says, well, take that promise and now call in that promise.

962
00:52:44,610 --> 00:52:47,430
And then we compute that thing.

963
00:52:47,430 --> 00:52:48,740
That's how this is going to work.

964
00:52:48,740 --> 00:52:51,550
That's what CONS-stream, head, and tail really are.

966
00:52:54,196 --> 00:52:55,570
Now, let's see how this works.

967
00:52:55,570 --> 00:52:58,410
And we'll go through this fairly carefully.

968
00:52:58,410 --> 00:53:08,650
We're going to see how this works in this example of computing the second prime between 10,000 and a million.

970
00:53:08,650 --> 00:53:11,610
OK, so we start off and we have this expression.

972
00:53:15,820 --> 00:53:26,710
The second prime-- the head of the tail of the result of filtering for primality the integers between 10,000 and 1 million.

975
00:53:26,710 --> 00:53:28,400
Now, what is that?

976
00:53:28,400 --> 00:53:40,250
What that is, that interval between 10,000 and 1 million, well, if you trace through enumerate interval, there builds a CONS-stream.

979
00:53:40,250 --> 00:53:54,480
And the CONS-stream is the CONS of 10,000 to a promise to compute the integers between 10,001 and 1 million.

981
00:53:54,480 --> 00:53:55,750
So that's what this expression is.

982
00:53:55,750 --> 00:53:57,640
Here I'm using the substitution model.

983
00:53:57,640 --> 00:54:01,010
And we can use the substitution model because we don't have side effects and state.

986
00:54:04,270 --> 00:54:08,380
So I have CONS of 10,000 to a promise to compute the rest of the integers.

988
00:54:08,380 --> 00:54:09,850
So only one integer, so far, got enumerated.

990
00:54:14,380 --> 00:54:16,580
Well, I'm going to filter that thing for primality.

992
00:54:19,900 --> 00:54:22,360
Again, you go back and look at the filter code.

993
00:54:22,360 --> 00:54:25,460
What the filter will first do is test the head.

994
00:54:25,460 --> 00:54:33,500
So in this case, the filter will test 10,000 and say, oh, 10,000's not prime.

996
00:54:33,500 --> 00:54:39,220
Therefore, what I have to do recursively is filter the tail.

998
00:54:39,220 --> 00:54:46,340
And what's the tail of it, well, that's the tail of this pair with a promise in it.

1000
00:54:46,340 --> 00:54:49,680
Tail now comes in and says, well, I'm going to force that.

1001
00:54:49,680 --> 00:55:00,880
I'm going to force that promise, which means now I'm going to compute the integers between 10,001 and 1 million.

1003
00:55:00,880 --> 00:55:02,970
OK, so this filter now is looking at that.

1005
00:55:07,810 --> 00:55:11,960
That enumerate itself, well, now we're back in the original enumerate situation.

1007
00:55:11,960 --> 00:55:19,740
The enumerate is the CONS of the first thing, 10,001, onto a promise to compute the rest.

1009
00:55:19,740 --> 00:55:23,060
So now the primality filter is going to go look at 10,001.

1010
00:55:23,060 --> 00:55:25,120
It's going to decide if it likes that or not.

1011
00:55:25,120 --> 00:55:27,550
It turns out 10,001 isn't prime.

1012
00:55:27,550 --> 00:55:29,610
So it'll force it again and again and again.

1014
00:55:32,920 --> 00:55:37,100
And finally, I think the first prime it hits is 10,009.

1015
00:55:37,100 --> 00:55:40,465
And at that point, it'll stop.

1016
00:55:40,465 --> 00:55:45,240
And that will be the first prime, and then eventually, it'll need the second prime.

1018
00:55:45,240 --> 00:55:47,030
So at that point, it will go again.

1019
00:55:47,030 --> 00:55:53,130
So you see what happens is that no more gets generated than you actually need.

1022
00:55:56,690 --> 00:56:04,930
That enumerator is not going to generate any more integers than the filter asks it for as it's pulling in things to check for primality.

1025
00:56:04,930 --> 00:56:11,255
And the filter is not going to generate any more stuff than you ask it for, which is the head of the tail.

1027
00:56:11,255 --> 00:56:28,160
You see, what's happened is we've put that mixing of generation and test into what actually happens in the computer, even though that's not apparently what's happening from looking at our programs.

1031
00:56:28,160 --> 00:56:30,230
OK, well, that seemed easy.

1032
00:56:30,230 --> 00:56:33,326
All of this mechanism got put into this magic delay.

1033
00:56:33,326 --> 00:56:36,900
So you're saying, gee, that must be where the magic is.

1034
00:56:36,900 --> 00:56:39,070
But see there's no magic there either.

1035
00:56:39,070 --> 00:56:40,610
You know what delay is.

1036
00:56:40,610 --> 00:56:56,490
Delay on some expression is just an abbreviation for--  well, what's a promise to compute an expression?

1039
00:56:56,490 --> 00:57:03,000
Lambda of nil, procedure of no arguments, which is that expression.

1041
00:57:03,000 --> 00:57:03,930
That's what a procedure is.

1042
00:57:03,930 --> 00:57:06,050
It says I'm going to compute an expression.

1043
00:57:06,050 --> 00:57:07,460
What's force?

1044
00:57:07,460 --> 00:57:10,800
How do I take up a promise?

1045
00:57:10,800 --> 00:57:15,890
Well, force of some procedure, a promise, is just run it.

1047
00:57:18,710 --> 00:57:20,120
Done.

1048
00:57:20,120 --> 00:57:23,580
So there's no magic there at all.

1049
00:57:23,580 --> 00:57:26,440
Well, what have we done?

1050
00:57:26,440 --> 00:57:30,960
We said the old style, traditional style of programming is more efficient.

1052
00:57:30,960 --> 00:57:35,260
And the stream thing is more perspicuous.

1053
00:57:35,260 --> 00:57:43,350
And we managed to make the stream procedures run like the other procedures by using delay.

1055
00:57:43,350 --> 00:57:54,440
And the thing that delay did for us was to de-couple the apparent order of events in our programs from the actual order of events that happened in the machine.

1058
00:57:54,440 --> 00:57:56,540
That's really what delay is doing.

1059
00:57:56,540 --> 00:57:58,290
That's exactly the whole point.

1060
00:57:58,290 --> 00:58:09,182
We've given up the idea that our procedures, as they run, or as we look at them, mirror some clear notion of time.

1062
00:58:09,182 --> 00:58:16,690
And by giving that up, we give delay the freedom to arrange the order of events in the computation the way it likes.

1064
00:58:16,690 --> 00:58:17,610
That's the whole idea.

1065
00:58:17,610 --> 00:58:24,200
We de-couple the apparent order of events in our programs from the actual order of events in the computer.

1067
00:58:24,200 --> 00:58:25,770
OK, well there's one more detail.

1068
00:58:25,770 --> 00:58:29,730
It's just a technical detail, but it's actually an important one.

1070
00:58:29,730 --> 00:58:39,320
As you run through these recursive programs unwinding, you'll see a lot of things that look like tail of the tail of the tail.

1073
00:58:39,320 --> 00:58:43,860
That's the kind of thing that would happen as I go CONSing down a stream all the way.

1075
00:58:43,860 --> 00:59:05,290
And if each time I'm doing that, each time to compute a tail, I evaluate a procedure which then has to go re-compute its tail, and re-compute its tail and recompute its tail each time, you can see that's very inefficient compared to just having a list where the elements are all there, and I don't have to re-compute each tail every time I get the next tail.

1082
00:59:05,290 --> 00:59:20,390
So there's one little hack to slightly change what delay is, and make it a thing which is-- I'll write it this way.

1085
00:59:20,390 --> 00:59:31,000
The actual implementation, delay is an abbreviation for this thing, memo-proc of a procedure.

1087
00:59:31,000 --> 00:59:35,150
Memo-proc is a special thing that transforms a procedure.

1088
00:59:35,150 --> 00:59:44,806
What it does is it takes a procedure of no arguments and it transforms it into a procedure that'll only have to do its computation once.

1091
00:59:44,806 --> 00:59:48,700
And what I mean by that is, you give it a procedure.

1092
00:59:48,700 --> 01:00:02,360
The result of memo-proc will be a new procedure, which the first time you call it, will run the original procedure, remember what result it got, and then from ever on after, when you call it, it just won't have to do the computation.

1097
01:00:02,360 --> 01:00:05,200
It will have cached that result someplace.

1098
01:00:05,200 --> 01:00:06,550
And here's an implementation of memo-proc.

1100
01:00:11,210 --> 01:00:12,710
Once you have the idea, it's easy to implement.

1101
01:00:12,710 --> 01:00:17,390
Memo-proc is this little thing that has two little flags in there.

1103
01:00:17,390 --> 01:00:20,320
It says, have I already been run?

1104
01:00:20,320 --> 01:00:23,620
And initially it says, no, I haven't already been run.

1105
01:00:23,620 --> 01:00:29,070
And what was the result I got the last time I was run?

1106
01:00:29,070 --> 01:00:34,360
So memo-proc takes a procedure called proc, and it returns a new procedure of no arguments.

1108
01:00:34,360 --> 01:00:38,610
Proc is supposed to be a procedure of no arguments.

1109
01:00:38,610 --> 01:00:44,430
And it says, oh, if I'm not already run, then I'm going to do a sequence of things.

1111
01:00:44,430 --> 01:00:48,450
I'm going to compute proc, I'm going to save that.

1112
01:00:48,450 --> 01:00:51,140
I'm going to stash that in the variable result.

1113
01:00:51,140 --> 01:00:56,610
I'm going to make a note to myself that I've already been run, and then I'll return the result.

1115
01:00:56,610 --> 01:00:59,010
So that's if you compute it if it's not already run.

1116
01:00:59,010 --> 01:01:03,420
If you call it and it's already been run, it just returns the result.

1118
01:01:03,420 --> 01:01:08,400
So that's a little clever hack called memoization.

1119
01:01:08,400 --> 01:01:15,270
And in this case, it short circuits having to re-compute the tail of the tail of the tail of the tail of the tail.

1121
01:01:15,270 --> 01:01:17,810
So there isn't even that kind of inefficiency.

1122
01:01:17,810 --> 01:01:24,210
And in fact, the streams will run with pretty much the same efficiency as the other programs precisely.

1124
01:01:24,210 --> 01:01:33,610
And remember, again, the whole idea of this is that we've used the fact that there's no really good dividing line between procedures and data.

1127
01:01:33,610 --> 01:01:38,760
We've written data structures that, in fact, are sort of like procedures.

1129
01:01:38,760 --> 01:01:49,620
And what that's allowed us to do is take an example of a common control structure, in this place iteration.

1131
01:01:49,620 --> 01:01:55,496
And we've built a data structure which, since itself is a procedure, kind of has this iteration control structure in it.

1134
01:01:55,496 --> 01:01:58,650
And that's really what streams are.

1135
01:01:58,650 --> 01:01:59,900
OK, questions?

1137
01:02:03,950 --> 01:02:13,052
AUDIENCE: Your description of tail-tail-tail, if I understand it correctly, force is actually execution of a procedure, if it's done without this memo-proc thing.

1140
01:02:13,052 --> 01:02:16,380
And you implied that memo-proc gets around that problem.

1141
01:02:16,380 --> 01:02:23,910
Doesn't it only get around it if tail-tail-tail is always executing exactly the same-- PROFESSOR: Oh, that's-- sure.

1145
01:02:23,910 --> 01:02:26,050
AUDIENCE: I guess I missed that point.

1146
01:02:26,050 --> 01:02:26,540
PROFESSOR: Oh, sure.

1147
01:02:26,540 --> 01:02:31,290
I mean the point is--  yeah.

1150
01:02:31,290 --> 01:02:34,160
I mean I have to do a computation to get the answer.

1151
01:02:34,160 --> 01:02:42,980
But the point is, once I've found the tail of the stream, to get the tail of the tail, I shouldn't have had to re-compute the first tail.

1154
01:02:42,980 --> 01:02:46,460
See, and if I didn't use memo-proc, that re-computation would have been done.

1156
01:02:46,460 --> 01:02:47,710
AUDIENCE: I understand now.

1158
01:02:50,830 --> 01:02:56,830
AUDIENCE: In one of your examples, you mentioned that we were able to use the substitution model because there are no side effects.

1161
01:02:56,830 --> 01:03:03,620
What if we had a single processing unit-- if we had a side effect, if we had a state?

1163
01:03:03,620 --> 01:03:09,120
Could we still practically build the stream model?

1164
01:03:09,120 --> 01:03:09,530
PROFESSOR: Maybe.

1165
01:03:09,530 --> 01:03:10,540
That's a hard question.

1166
01:03:10,540 --> 01:03:18,960
I'm going to talk a little bit later about the places where substitution and side effects don't really mix very well.

1168
01:03:18,960 --> 01:03:25,170
But in general, I think the answer is unless you're very careful, any amount of side effect is going to mess up everything.

1172
01:03:35,490 --> 01:03:39,410
AUDIENCE: Sorry, I didn't quite understand the memo-proc operation.

1174
01:03:39,410 --> 01:03:41,990
When do you execute the lambda?

1175
01:03:41,990 --> 01:03:47,600
In other words, when memo-proc is executed, just this lambda expression is being generated.

1177
01:03:47,600 --> 01:03:50,390
But it's not clear to me when it's executed.

1178
01:03:50,390 --> 01:03:51,350
PROFESSOR: Right.

1179
01:03:51,350 --> 01:03:57,930
What memo-proc does-- remember, the thing that's going into memo-proc, the thing proc, is a procedure of no arguments.

1182
01:03:57,930 --> 01:04:00,390
And someday, you're going to call it.

1183
01:04:00,390 --> 01:04:06,620
Memo-proc translates that procedure into another procedure of no arguments, which someday you're going to call.

1186
01:04:06,620 --> 01:04:09,890
That's that lambda.

1187
01:04:09,890 --> 01:04:24,100
So here, where I initially built as my tail of the stream, say, this procedure of no arguments, which someday I'll call.

1190
01:04:24,100 --> 01:04:30,650
Instead, I'm going to have the tail of the stream be memo-proc of it, which someday I'll call.

1192
01:04:30,650 --> 01:04:47,642
So that lambda of nil, that gets called when you call the memo-proc, when you call the result of that memo-proc, which would be ordinarily when you would have called the original thing that you set it.

1196
01:04:47,642 --> 01:04:52,610
AUDIENCE: OK, the reason I ask is I had a feeling that when you call memo-proc, you just return this lambda.

1198
01:04:52,610 --> 01:04:53,770
PROFESSOR: That's right.

1199
01:04:53,770 --> 01:04:58,100
When you call memo-proc, you return the lambda.

1200
01:04:58,100 --> 01:05:02,270
You never evaluate the expression at all, until the first time that you would have evaluated it.

1203
01:05:07,590 --> 01:05:14,240
AUDIENCE: Do I understand it right that you actually have to build the list up, but the elements of the list don't get evaluated?

1206
01:05:14,240 --> 01:05:15,630
The expressions don't get evaluated?

1207
01:05:15,630 --> 01:05:18,540
But at each stage, you actually are building a list.

1208
01:05:18,540 --> 01:05:20,700
PROFESSOR: That's-- I really should have said this.

1210
01:05:20,700 --> 01:05:22,270
That's a really good point.

1211
01:05:22,270 --> 01:05:23,660
No, it's not quite right.

1212
01:05:23,660 --> 01:05:25,080
Because what happens is this.

1213
01:05:25,080 --> 01:05:26,890
Let me draw this as pairs.

1214
01:05:26,890 --> 01:05:32,740
Suppose I'm going to make a big stream, like enumerate interval, 1 through 1 billion.

1216
01:05:32,740 --> 01:05:43,045
What that is, is a pair with a 1 and a promise.

1218
01:05:46,520 --> 01:05:47,890
That's exactly what it is.

1219
01:05:47,890 --> 01:05:49,140
Nothing got built up.

1221
01:05:51,600 --> 01:05:56,370
When I go and force this, and say, what happens?

1222
01:05:56,370 --> 01:06:00,530
Well, this thing is now also recursively a CONS.

1223
01:06:00,530 --> 01:06:11,350
So that this promise now is the next thing, which is a 2 and a promise to do more.

1225
01:06:11,350 --> 01:06:14,470
And so on and so on and so on.

1226
01:06:14,470 --> 01:06:18,200
So nothing gets built up until you walk down the stream.

1227
01:06:18,200 --> 01:06:25,500
Because what's sitting here is not the list, but a promise to generate the list. And by promise, technically I mean procedure.

1231
01:06:28,050 --> 01:06:30,485
So it doesn't get built up.

1232
01:06:30,485 --> 01:06:34,280
Yeah, I should have said that before this point.

1233
01:06:34,280 --> 01:06:34,490
OK.

1234
01:06:34,490 --> 01:06:34,790
Thank you.

1235
01:06:34,790 --> 01:06:36,340
Let's take a break.

