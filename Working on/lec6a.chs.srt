1
00:00:18,550 --> 00:00:22,230
教授：上次Gerry教授揭晓了秘密

2
00:00:22,230 --> 00:00:26,350
他介绍了赋值的概念

3
00:00:26,350 --> 00:00:33,405
赋值与状态

4
00:00:37,620 --> 00:00:45,350
正如我们所见，语言引入了赋值与状态，其含义是相当令人惊骇的

5
00:00:45,350 --> 00:00:48,865
首先，计算的代换模型失效了

6
00:00:48,865 --> 00:00:58,130
我们不得不使用更为复杂的环境模型和这种带图解的机械性的东西，甚至还要讲解声明编程语言中意味着什么

7
00:00:58,130 --> 00:01:00,260
这不仅仅是技术上的一点

8
00:01:00,260 --> 00:01:05,870
看，代换模型在这里完全失效了，我们得想些其它办法

9
00:01:05,870 --> 00:01:10,730
代换模型什么都做不了

10
00:01:10,730 --> 00:01:18,080
因为突然地，一个变量不仅仅代表着一个值了

11
00:01:18,080 --> 00:01:23,630
变量现在用来指定一个存放值的位置

12
00:01:23,630 --> 00:01:25,885
并且在这个位置的值是可以变的

13
00:01:30,280 --> 00:01:40,410
比如像 (f x) 这个表达式就可能有副作用

14
00:01:40,410 --> 00:01:49,730
如果我们执行(f x)得到某些值，之后我们再次执行(f x)，可能因为执行顺序的关系而得到不同的值

15
00:01:49,730 --> 00:01:54,030
所以突然间，我们不能仅仅关注于值，也要开始关注时间

16
00:01:57,970 --> 00:02:02,520
序对也不仅仅只是CAR和CDR了

17
00:02:02,520 --> 00:02:08,449
序对不仅是它的CAR和CDR，更是它的“同一”

18
00:02:08,449 --> 00:02:11,650
所以一个序对有“同一”

19
00:02:11,650 --> 00:02:12,900
它是一个对象

20
00:02:21,330 --> 00:02:30,900
两个CAR与CDR相同的序对可能相同也可能不同，因为我们必须关注“共享”

21
00:02:34,960 --> 00:02:40,480
一引入赋值。这些都变成要考虑的问题了

22
00:02:40,480 --> 00:02:45,400
确实，这和我们说讲代换的时候差别悬殊

23
00:02:45,400 --> 00:02:53,540
技术角度来看，我们必须相加机械的思考程序语言，因此看待事情也变得更加困难

24
00:02:53,540 --> 00:02:55,960
我们还不能仅仅用数学的方式来思考

25
00:02:55,960 --> 00:03:04,050
哲学上也很难理解，什么是事物的改变？两个事物是否相同？我们突然要开始思考这类问题

26
00:03:04,050 --> 00:03:18,210
并且，编程也更加困难，正如Gerry上次演示的，会有很多由于别名与顺序引发的bug，对于不考虑对象的语言，这些问题是绝对不会出现的

27
00:03:18,210 --> 00:03:23,635
我们是怎样陷入这样的困境的呢？

28
00:03:23,635 --> 00:03:42,760
想想我们之前所做的，原因就在于我们想要构造模块化的系统，而且这些模块的划分是很自然的

29
00:03:42,760 --> 00:04:06,980
举例来说，我们构造一个随机数生成器并打包生成器的状态，所以我们可以把求随机数的计算过程与蒙特卡罗方法相分离，与那个用随机数求Pi的计算过程相分离

30
00:04:06,980 --> 00:04:24,900
相似地，如果我们动身去构建一个现实世界的模型，我们就想要程序自然的分成很多部分，每一部分各自代表着我们在现实世界所看到的事物

31
00:04:24,900 --> 00:04:35,160
举个例子，看到一个电子电路，我们可能会说，哇，这有一个电路板，它有一个这样的元件，有一个那样的元件

32
00:04:40,100 --> 00:04:43,580
这些元件在某种程度上都有“同一”

33
00:04:43,580 --> 00:04:45,550
它们都有各自的状态

34
00:04:45,550 --> 00:04:48,580
状态附着在电路上

35
00:04:48,580 --> 00:04:52,610
我们把这个元件看作一个不同于其它对象的对象

36
00:04:52,610 --> 00:05:02,170
当系统发生变化，我们想着，信号从这里过来，可能在这里改变了一个状态，信号又到了那里，和一个存储在那里的状态相互作用，等等

37
00:05:06,860 --> 00:05:23,365
所以我们在做的是构建一个如实映射现实的电脑系统，每一部分都与现实的某一部分相对应，用这样的方法来构建的话，系统便很容易的分成模块

38
00:05:23,365 --> 00:05:33,610
这样来构造系统的原因是想说明
介绍如此复杂的技术与计算机本身没有什么关系

39
00:05:33,610 --> 00:05:44,550
看到了吧，我们付出了这么大的代价来编写映射现实世界的程序，却因为我们错误的认知现实而失败

40
00:05:44,550 --> 00:05:50,150
或许时间只是错觉，什么都没有改变

41
00:05:50,150 --> 00:05:55,820
举例来说，我拿起这个粉笔，我们会想，哦，这是一个对象，它有自己的状态

42
00:05:55,820 --> 00:05:59,710
每时每刻，它都有一个位置与速度

43
00:05:59,710 --> 00:06:01,240
如果我们做点什么，就可以改变它的状态

44
00:06:04,340 --> 00:06:11,340
但是你如果了解一点相对性的概念，你可能不会认为粉笔的路径是某种东西随着时间运动而形成的

45
00:06:11,340 --> 00:06:16,020
把整个粉笔的存在认为是时空中的路径，这是很有洞察力的

46
00:06:16,020 --> 00:06:18,040
全部都展开了

47
00:06:18,040 --> 00:06:19,840
没有单独的位置与速度

48
00:06:19,840 --> 00:06:24,640
只有在时空中不变的存在

49
00:06:24,640 --> 00:06:41,490
相似地，如果我们想象这些电子系统是一个信号处理系统，组合这个系统的工程师可不会这样想，“哦，每个瞬间有一个电压过来，

50
00:06:41,490 --> 00:06:43,340
转换成了某种东西，

51
00:06:43,340 --> 00:06:46,810
影响了这里的状态，还改变了那里的状态”

52
00:06:46,810 --> 00:06:50,420
没有一个做信号处理的会这样想

53
00:06:50,420 --> 00:06:58,060
相反，你说这里有一个在时间上伸展的信号

54
00:06:58,060 --> 00:07:09,570
如果有一个滤波器，就会把整个信号变成整个完全不同的输出信号

55
00:07:09,570 --> 00:07:14,160
你不必考虑在某个时间点上事物的状态

56
00:07:14,160 --> 00:07:22,230
以某种方式，把这个盒子作为完整的东西，而不是在某些个特定时间的状态的集合

57
00:07:28,250 --> 00:07:41,130
好的，今天我们就从信号处理工程师的角度而不是之前以对象思考的角度来分解系统

58
00:07:41,130 --> 00:07:43,310
它被称为“流处理”

59
00:07:54,570 --> 00:08:17,210
我们打算展示如何使那些对时间过度关注的程序更具统一性，而且可以从中看到很多的共性

60
00:08:17,210 --> 00:08:19,910
我们来对比这两个过程

61
00:08:23,260 --> 00:08:25,690
第一个是这样

62
00:08:25,690 --> 00:08:27,770
想像这有一个树

63
00:08:30,400 --> 00:08:33,179
一个自然数的树

64
00:08:33,179 --> 00:08:34,429
还是一个二叉树

65
00:08:39,100 --> 00:08:40,230
看起来就像这样

66
00:08:40,230 --> 00:08:44,990
在每个结点上都有一个数

67
00:08:44,990 --> 00:08:57,210
我们想计算的是，对这个树中所有的奇数，计算它们的平方和

68
00:08:57,210 --> 00:08:59,480
看起来很熟悉

69
00:08:59,480 --> 00:09:02,930
这里我们用递归的方式来计算

70
00:09:02,930 --> 00:09:08,680
观察每个叶子结点，如果是奇数我们求它的平方，如果是偶数我们不需要，也就是0

71
00:09:08,680 --> 00:09:17,640
递归求解，我们知道 一棵树的解 = 左子树的解 + 右子树的解，就这样递归下去

72
00:09:17,640 --> 00:09:20,360
这种思考方式我们已经很熟悉了

73
00:09:20,360 --> 00:09:23,960
我们来看看幻灯片

74
00:09:23,960 --> 00:09:37,160
计算一棵树的奇数平方和，这里有一个判断，是否是一个叶子结点，断而判断是否是一个奇数，然后我们计算它的平方，否则就取0

75
00:09:37,160 --> 00:09:42,120
然后，整个的解就是左、右子树解的总和

76
00:09:46,340 --> 00:09:51,560
好的，现在我们对比第二个问题

77
00:09:51,560 --> 00:09:59,270
假如给你一个整数n，还有一些函数来计算每一个从1到n的数

78
00:09:59,270 --> 00:10:05,600
然后我想把那些所有满足特定属性的值收集到一个列表中

79
00:10:05,600 --> 00:10:06,880
这是一个广泛的概述

80
00:10:06,880 --> 00:10:14,210
说的更具体一点，假如对于每个整数k，计算第k个斐波那契数

81
00:10:14,210 --> 00:10:19,050
然后挑出其中的奇数并把它们放入一个列表

82
00:10:19,050 --> 00:10:20,710
这个过程是这样的

83
00:10:23,730 --> 00:10:26,240
寻找n个斐波那契数中的奇数

84
00:10:26,240 --> 00:10:28,910
这里是一个循环的标准写法

85
00:10:28,910 --> 00:10:30,800
一个递归

86
00:10:30,800 --> 00:10:40,370
一个循环，参数是k，如果k大于n，返回空列表；否则计算第k个斐波那契数，称它为f

87
00:10:40,370 --> 00:10:47,690
如果是奇数，我们把它与从k+1计算得到的列表相连接

88
00:10:47,690 --> 00:10:50,390
否则，我们只取从k+1计算得到的结果

89
00:10:50,390 --> 00:10:53,000
这是迭代式循环的标准写法

90
00:10:53,000 --> 00:10:57,600
我们以1为参数开始这个循环

91
00:10:57,600 --> 00:11:01,600
好的，这就是这两个过程

92
00:11:01,600 --> 00:11:02,900
直观来看，它们两个没有什么共同点

93
00:11:02,900 --> 00:11:04,390
结构完全不同

94
00:11:04,390 --> 00:11:11,330
但是从一个特定的角度来看，两个过程做的事情是一样的

95
00:11:11,330 --> 00:11:26,980
如果我是一个信号处理工程师，我可能会说，第一个过程枚举了树叶结点

96
00:11:31,160 --> 00:11:35,330
可以认为是一个全部是树叶结点的信号从这里输出

97
00:11:35,330 --> 00:11:45,190
然后把信号导入某个过滤器，过滤出其中的奇数

98
00:11:45,190 --> 00:11:49,000
通过这样的一个变换器

99
00:11:49,000 --> 00:11:51,420
对每一个输出，我们对其取平方

100
00:11:54,200 --> 00:11:58,290
最后把结果累积在一起

101
00:11:58,290 --> 00:12:03,340
我们通过从0开始的加法来累计它们

102
00:12:07,140 --> 00:12:08,210
这是第一个程序

103
00:12:08,210 --> 00:12:11,780
第二个程序，也可以用一个非常非常相似的方法来描述

104
00:12:11,780 --> 00:12:19,080
枚举了从1到n的所有整数

105
00:12:22,500 --> 00:12:29,270
对于每个数，计算斐波那契数，通过一个转换器

106
00:12:29,270 --> 00:12:35,976
对于输出的结果，再通过奇偶性进行过滤

107
00:12:35,976 --> 00:12:39,350
最后，我们将这些放入累积器

108
00:12:39,350 --> 00:12:47,110
这里我们累积出一个列表，传递CONS方法，与空列表作为参数

109
00:12:47,110 --> 00:12:51,900
从这个角度来看，这两个程序真的是太相似了

110
00:12:51,900 --> 00:12:58,050
问题在于两个程序的写法导致我们看不出其中的共性

111
00:12:58,050 --> 00:13:06,300
我们回头再来看第一个奇数平方和的问题，问题来了，枚举器是什么？

112
00:13:06,300 --> 00:13:08,140
程序中哪一部分有枚举的作用？

113
00:13:08,140 --> 00:13:11,230
枚举不是仅仅在一个地方表现出来的

114
00:13:11,230 --> 00:13:17,160
在叶子结点的判断处存在一部分

115
00:13:17,160 --> 00:13:20,630
也下面的递归结构中也有体现

116
00:13:23,150 --> 00:13:24,120
累积器又在哪儿呢？

117
00:13:24,120 --> 00:13:25,680
和枚举器类似，也不是在一个地方

118
00:13:25,680 --> 00:13:32,180
它由 0 和 + 这两个地方体现出来

119
00:13:32,180 --> 00:13:34,510
累积器的完整过程并不体在唯一一个地方

120
00:13:34,510 --> 00:13:44,470
相似地，我们来观察奇数斐波那契数的例子，程序中也存在枚举器与累积器的含义，但是有些不同

121
00:13:44,470 --> 00:13:55,680
枚举的含义部分的表现在 ( > k n) 的判断中，部分的表现在下面的递归调用中

122
00:13:55,680 --> 00:14:03,600
同样地，累积的含义也被混杂在其中，比如在这里和那里

123
00:14:03,600 --> 00:14:14,360
我们之前所画出的盒子在我们的程序中完全看不出来，因为它们混杂在一起了

124
00:14:14,360 --> 00:14:16,290
因此，这些程序并没有很好的对问题进行划分

125
00:14:19,450 --> 00:14:31,060
回到计算机科学的基本原理上来，为了控制某种东西，你需要给它命名，即使我们如此思考，我们也并没有完全地控制住它，因为我们没有明确地深入它的内部

126
00:14:31,060 --> 00:14:35,510
我们没有一个好的语言来说明

127
00:14:35,510 --> 00:14:44,515
好吧，我们来发明合适的语言来构造这些部分

128
00:14:44,515 --> 00:14:50,480
这种语言的关键在于 这些叫作信号的东西到底是什么？

129
00:14:50,480 --> 00:14:53,320
这些沿着箭头传递的又是什么？

130
00:14:56,880 --> 00:15:07,980
直接说明吧，这些东西将变成一种叫做流的数据结构，也是发明这个语言的关键

131
00:15:07,980 --> 00:15:08,600
什么是流呢？

132
00:15:08,600 --> 00:15:12,220
流，和其它的相似，是一种数据抽象

133
00:15:12,220 --> 00:15:16,870
所以，我先说明它的选择器与构造器分别是什么

134
00:15:16,870 --> 00:15:21,435
构造器我们称其为CONS-stream

135
00:15:25,690 --> 00:15:32,040
CONS-stream把两个事物放在一起构造出一个流

136
00:15:32,040 --> 00:15:38,010
选择器叫作HEAD，用于从流中提取数据

137
00:15:38,010 --> 00:15:44,720
可以提取head，也要可以提取tail

138
00:15:44,720 --> 00:15:53,160
我把我和George的约定告诉你，是想让你明确到底是什么相关的法则

139
00:15:53,160 --> 00:16:28,440
对于任何的x与y，(HEAD (CONS-STREAM x y)) => x，(TAIL (CONS-STREAM)) => y

140
00:16:28,440 --> 00:16:34,750
一个构造函数，两个选择函数，一个法则，就是这些

141
00:16:34,750 --> 00:16:36,980
这里有点可疑

142
00:16:36,980 --> 00:16:52,810
你可能注意到了这完全和CONS，CAR，CDR序对相关的法则完全一样啊，把CONS-STREAM换成CONS，HEAD换成CAR，TAIL换成CDR，就完全一样了

143
00:16:52,810 --> 00:16:55,130
事实上，还有另一个东西

144
00:16:55,130 --> 00:17:08,319
我们有一个叫空流的东西，像空列表

145
00:17:08,319 --> 00:17:10,030
为什么我要介绍这个术语呢？

146
00:17:10,030 --> 00:17:12,780
为什么我不直接说序对与列表呢？

147
00:17:12,780 --> 00:17:15,510
好吧，我们将会看到

148
00:17:15,510 --> 00:17:21,560
暂时地，如果你喜欢，为什么不把流假装作列表的另一种术语

149
00:17:21,560 --> 00:17:28,150
一会儿我们就知道了为什么我们需要这样的抽象而不是仅仅把它叫做列表

150
00:17:32,300 --> 00:17:42,120
OK, now that we have streams, we can start constructing the pieces of the language to operate on streams. And there are a whole bunch of very useful things that we could start making.

151
00:17:42,120 --> 00:18:05,666
For instance, we'll make our map box to take a stream, s, and a procedure, and to generate a new stream which has as its elements the procedure applied to all the successive elements of s.

152
00:18:05,666 --> 00:18:07,400
In fact, we've seen this before.

153
00:18:07,400 --> 00:18:10,950
This is the procedure map that we did with lists.

154
00:18:10,950 --> 00:18:14,650
And you see it's exactly map, except we're testing for empty-stream.

155
00:18:14,650 --> 00:18:15,560
Oh, I forgot to mention that.

156
00:18:15,560 --> 00:18:20,510
Empty-stream is like the null test. So if it's empty, we generate the empty stream.

157
00:18:20,510 --> 00:18:33,140
Otherwise, we form a new stream whose first element is the procedure applied to the head of the stream, and whose rest is gotten by mapping along with the procedure down the tail of the stream.

158
00:18:33,140 --> 00:18:37,030
So that looks exactly like the map procedure we looked at before.

159
00:18:37,030 --> 00:18:38,350
Here's another useful thing.

160
00:18:38,350 --> 00:18:40,460
Filter, this is our filter box.

161
00:18:40,460 --> 00:18:43,890
We're going to have a predicate and a stream.

162
00:18:43,890 --> 00:18:50,160
We're going to make a new stream that consists of all the elements of the original one that satisfy the predicate.

163
00:18:50,160 --> 00:18:51,270
That's case analysis.

164
00:18:51,270 --> 00:18:56,280
When there's nothing in the stream, we return the empty stream.

165
00:18:56,280 --> 00:19:00,060
We test the predicate on the head of the stream.

166
00:19:00,060 --> 00:19:08,220
And if it's true, we add the head of the stream onto the result of filtering the tail of the stream.

167
00:19:08,220 --> 00:19:13,500
And otherwise, if that predicate was false, we just filter the tail of the stream.

168
00:19:13,500 --> 00:19:16,595
Right, so there's filter.

169
00:19:16,595 --> 00:19:18,560
Let me run through a couple more rather quickly.

170
00:19:18,560 --> 00:19:20,880
They're all in the book and you can look at them.

171
00:19:20,880 --> 00:19:22,110
Let me just flash through.

172
00:19:22,110 --> 00:19:23,260
Here's accumulate.

173
00:19:23,260 --> 00:19:31,560
Accumulate takes a way of combining things and an initial value in a stream and sticks them all together.

174
00:19:31,560 --> 00:19:33,970
If the stream's empty, it's just the initial value.

175
00:19:33,970 --> 00:19:40,900
Otherwise, we combine the head of the stream with the result of accumulating the tail of the stream starting from the initial value.

176
00:19:40,900 --> 00:19:42,830
So that's what I'd use to add up everything in the stream.

177
00:19:42,830 --> 00:19:45,830
I'd accumulate with plus.

178
00:19:45,830 --> 00:19:48,060
How would I enumerate the leaves of a tree?

179
00:19:48,060 --> 00:19:56,640
Well, if the tree is just a leaf itself, I make something which only has that node in it.

180
00:19:56,640 --> 00:20:04,340
Otherwise, I append together the stuff of enumerating the left branch and the right branch.

181
00:20:04,340 --> 00:20:08,130
And then append here is like the ordinary append on lists.

182
00:20:13,190 --> 00:20:13,850
You can look at that.

183
00:20:13,850 --> 00:20:19,150
That's analogous to the ordinary procedure for appending two lists.

184
00:20:19,150 --> 00:20:21,810
How would I enumerate an interval?

185
00:20:21,810 --> 00:20:28,106
This will take two integers, low and high, and generate a stream of the integers going from low to high.

186
00:20:28,106 --> 00:20:31,890
And we can make a whole bunch of pieces.

187
00:20:31,890 --> 00:20:37,670
So that's a little language of talking about streams. Once we have streams, we can build things for manipulating them.

188
00:20:37,670 --> 00:20:40,200
Again, we're making a language.

189
00:20:40,200 --> 00:20:43,060
And now we can start expressing things in this language.

190
00:20:43,060 --> 00:20:47,310
Here's our original procedure for summing the odd squares in a tree.

191
00:20:47,310 --> 00:20:54,590
And you'll notice it looks exactly now like the block diagram, like the signal processing block diagram.

192
00:20:54,590 --> 00:21:01,320
So to sum the odd squares in a tree, we enumerate the leaves of the tree.

193
00:21:01,320 --> 00:21:04,830
We filter that for oddness.

194
00:21:04,830 --> 00:21:06,220
We map that for squareness.

195
00:21:09,320 --> 00:21:14,760
And we accumulate the result of that using addition, starting from 0.

196
00:21:14,760 --> 00:21:17,290
So we can see the pieces that we wanted.

197
00:21:17,290 --> 00:21:22,050
Similarly, the Fibonacci one, how do we get the odd Fibs?

198
00:21:22,050 --> 00:21:30,920
Well, we enumerate the interval from 1 to n, we map along that, computing the Fibonacci of each one.

199
00:21:30,920 --> 00:21:34,810
We filter the result of those for oddness.

200
00:21:34,810 --> 00:21:43,650
And we accumulate all of that stuff using CONS starting from the empty-list.

201
00:21:43,650 --> 00:21:47,680
OK, what's the advantage of this?

202
00:21:47,680 --> 00:21:51,880
Well, for one thing, we now have pieces that we can start mixing and matching.

203
00:21:51,880 --> 00:22:06,210
So for instance, if I wanted to change this, if I wanted to compute the squares of the integers and then filter them, all I need to do is pick up a standard piece like this in that square and put it in.

204
00:22:06,210 --> 00:22:18,030
Or if we wanted to do this whole Fibonacci computation on the leaves of a tree rather than a sequence, all I need to do is replace this enumerator with that one.

205
00:22:18,030 --> 00:22:38,130
See, the advantage of this stream processing is that we're establishing-- this is one of the big themes of the course-- we're establishing conventional interfaces that allow us to glue things together.

206
00:22:38,130 --> 00:22:45,750
Things like map and filter are a standard set of components that we can start using for pasting together programs in all sorts of ways.

207
00:22:45,750 --> 00:22:50,090
It allows us to see the commonality of programs.

208
00:22:50,090 --> 00:22:53,860
I just ought to mention, I've only showed you two procedures.

209
00:22:53,860 --> 00:23:01,410
But let me emphasize that this way of putting things together with maps, filters, and accumulators is very, very general.

210
00:23:01,410 --> 00:23:30,710
It's the generate and test paradigm for programs. And as an example of that, Richard Waters, who was at MIT when he was a graduate student, as part of his thesis research went and analyzed a large chunk of the IBM scientific subroutine library, and discovered that about 60% of the programs in it could be expressed exactly in terms using no more than what we've put here-- map, filter, and accumulate.

211
00:23:30,710 --> 00:23:31,960
All right, let's take a break.

212
00:23:36,620 --> 00:23:37,870
Questions?

213
00:23:40,470 --> 00:23:48,380
AUDIENCE: It seems like the essence of this whole thing is just that you have a very uniform, simple data structure to work with, the stream.

214
00:23:48,380 --> 00:23:48,920
PROFESSOR: Right.

215
00:23:48,920 --> 00:23:53,710
The essence is that you, again, it's this sense of conventional interfaces.

216
00:23:53,710 --> 00:23:55,610
So you can start putting a lot of things together.

217
00:23:55,610 --> 00:24:00,890
And the stream is as you say, the uniform data structure that supports that.

218
00:24:00,890 --> 00:24:03,600
This is very much like APL, by the way.

219
00:24:03,600 --> 00:24:09,560
APL is very much the same idea, except in APL, instead of this stream, you have arrays and vectors.

220
00:24:09,560 --> 00:24:14,815
And a lot of the power of APL is exactly the same reason of the power of this.

221
00:24:19,910 --> 00:24:20,910
OK, thank you.

222
00:24:20,910 --> 00:24:22,160
Let's take a break.

223
00:24:57,470 --> 00:24:57,610
All right.

224
00:24:57,610 --> 00:25:10,810
We've been looking at ways of organizing computations using streams. What I want to do now is just show you two somewhat more complicated examples of that.

225
00:25:10,810 --> 00:25:16,810
Let's start by thinking about the following kind of utility procedure that will come in useful.

226
00:25:16,810 --> 00:25:19,960
Suppose I've got a stream.

227
00:25:19,960 --> 00:25:23,730
And the elements of this stream are themselves streams.

228
00:25:23,730 --> 00:25:26,530
So the first thing might be 1, 2, 3.

229
00:25:32,600 --> 00:25:33,880
So I've got a stream.

230
00:25:33,880 --> 00:25:40,100
And each element of the stream is itself a stream.

231
00:25:40,100 --> 00:25:52,080
And what I'd like to do is build a stream that collects together all of the elements, pulls all of the elements out of these sub-streams and strings them all together in one thing.

232
00:25:52,080 --> 00:25:56,960
So just to show you the use of this language, how easy it is, call that flatten.

233
00:25:56,960 --> 00:26:13,960
And I can define to flatten this stream of streams. Well, what is that?

234
00:26:13,960 --> 00:26:16,240
That's just an accumulation.

235
00:26:16,240 --> 00:26:26,450
I want to accumulate using append, by successively appending.

236
00:26:26,450 --> 00:26:54,370
So I accumulate using append streams, starting with the-empty-stream down that stream of streams.

237
00:26:54,370 --> 00:27:00,830
OK, so there's an example of how you can start using these higher order things to do some interesting operations.

238
00:27:00,830 --> 00:27:05,100
In fact, there's another useful thing that I want to do.

239
00:27:05,100 --> 00:27:21,840
I want to define a procedure called flat-map, flat map of some function and a stream.

240
00:27:21,840 --> 00:27:25,720
And what this is going to do is f will be a stream of elements.

241
00:27:25,720 --> 00:27:31,950
f is going to be a function that for each element in the stream produces another stream.

242
00:27:31,950 --> 00:27:36,000
And what I want to do is take all of the elements and all of those streams and combine them together.

243
00:27:36,000 --> 00:27:51,350
So that's just going to be the flatten of map f down s.

244
00:27:51,350 --> 00:27:54,290
Each time I apply f to an element of s, I get a stream.

245
00:27:54,290 --> 00:27:58,385
If I map it all the way down, I get a stream of streams, and I'll flatten that.

246
00:27:58,385 --> 00:28:06,360
Well, I want to use that to show you a new way to do a familiar kind of problem.

247
00:28:06,360 --> 00:28:14,190
The problem's going to be like a lot of problems you've seen, although maybe not this particular one.

248
00:28:14,190 --> 00:28:15,490
I'm going to give you an integer, n.

249
00:28:18,480 --> 00:28:51,910
And the problem is going to be find all pairs and integers i and j, between 0 and i, with j less than i, up to n, such that i plus j is prime.

250
00:28:55,740 --> 00:29:06,640
So for example, if n equals 6, let's make a little table here, i and j and i plus j.

251
00:29:09,700 --> 00:29:15,520
So for, say, i equals 2 and j equals 1, I'd get 3.

252
00:29:15,520 --> 00:29:21,210
And for i equals 3, I could have j equals 2, and that would be 5.

253
00:29:21,210 --> 00:29:28,400
And 4 and 1 would be 5 and so on, up until i goes to 6.

254
00:29:28,400 --> 00:29:37,350
And what I'd like to return is to produce a stream of all the triples like this, let's say i, j, and i plus j.

255
00:29:37,350 --> 00:29:41,530
So for each n, I want to generate this stream.

256
00:29:41,530 --> 00:29:43,680
OK, well, that's easy.

257
00:29:43,680 --> 00:29:47,230
Let's build it up.

258
00:29:47,230 --> 00:29:50,150
We start like this.

259
00:29:50,150 --> 00:29:56,440
We're going to say for each i, we're going to generate a stream.

260
00:29:56,440 --> 00:30:00,660
For each i in the interval 1 through n, we're going to generate a stream.

261
00:30:00,660 --> 00:30:02,230
What's that stream going to be?

262
00:30:02,230 --> 00:30:04,180
We're going to start by generating all the pairs.

263
00:30:04,180 --> 00:30:20,710
So for each i, we're going to generate, for each j in the interval 1 to i minus 1, we'll generate the pair, or the list with two elements i and j.

264
00:30:23,780 --> 00:30:30,712
So we map along the interval, generating the pairs.

265
00:30:30,712 --> 00:30:33,170
And for each i, that generates a stream of pairs.

266
00:30:33,170 --> 00:30:34,590
And we flatmap it.

267
00:30:34,590 --> 00:30:38,730
Now we have all the pairs i and j, such that i is less than j.

268
00:30:38,730 --> 00:30:39,850
So that builds that.

269
00:30:39,850 --> 00:30:42,990
Now we're got to test them.

270
00:30:42,990 --> 00:30:51,660
Well, we take that thing we just built, the flatmap, and we filter it to see whether the i-- see, we had an i and a j.

271
00:30:51,660 --> 00:31:02,070
i was the first thing in the list, j was the second thing in the list. So we have a predicate which says in that list of two elements is the sum of the CAR and the CDR prime.

272
00:31:02,070 --> 00:31:06,540
And we filter that collection of pairs we just built.

273
00:31:06,540 --> 00:31:09,420
So those are the pairs we want.

274
00:31:09,420 --> 00:31:19,610
Now we go ahead and we take the result of that filter and we map along it, generating the list i and j and i plus j.

275
00:31:19,610 --> 00:31:22,910
And that's our procedure prime-sum-pairs.

276
00:31:22,910 --> 00:31:24,480
And then just to flash it up, here's the whole procedure.

277
00:31:27,945 --> 00:31:30,750
A map, a filter, a flatmap.

278
00:31:34,850 --> 00:31:37,120
There's the whole thing, even though this isn't particularly readable.

279
00:31:37,120 --> 00:31:40,000
It's just expanding that flatmap.

280
00:31:40,000 --> 00:31:54,200
So there's an example which illustrates the general point that nested loops in this procedure start looking like compositions of flatmaps of flatmaps of flatmaps of maps and things.

281
00:31:54,200 --> 00:32:03,230
So not only can we enumerate individual things, but by using flatmaps, we can do what would correspond to nested loops in most other languages.

282
00:32:03,230 --> 00:32:08,410
Of course, it's pretty awful to keep writing these flatmaps of flatmaps of flatmaps.

283
00:32:08,410 --> 00:32:15,480
Prime-sum-pairs you saw looked fairly complicated, even though the individual pieces were easy.

284
00:32:15,480 --> 00:32:21,040
So what you can do, if you like, is introduced some syntactic sugar that's called collect.

285
00:32:21,040 --> 00:32:26,160
And collect is just an abbreviation for that nest of flatmaps and filters arranged in that particular way.

286
00:32:26,160 --> 00:32:29,620
Here's prime-sum-pairs again, written using collect.

287
00:32:29,620 --> 00:32:58,040
It says to find all those pairs, I'm going to collect together a result, which is the list i, j, and i plus j, that's going to be generated as i runs through the interval from 1 to n and as j runs through the interval from 1 to i minus 1, such that i plus j is prime.

288
00:32:58,040 --> 00:33:00,690
So I'm not going to say what collect does in general.

289
00:33:00,690 --> 00:33:03,420
You can look at that by looking at it in the book.

290
00:33:03,420 --> 00:33:08,820
But pretty much, you can see that the pieces of this are the pieces of that original procedure I wrote.

291
00:33:08,820 --> 00:33:16,310
And this collect is just some syntactic sugar for automatically generating that nest of flatmaps and flatmaps.

292
00:33:16,310 --> 00:33:22,120
OK, well, let me do one more example that shows you the same kind of thing.

293
00:33:22,120 --> 00:33:30,200
Here's a very famous problem that's used to illustrate a lot of so-called backtracking computer algorithms. This is the eight queens problem.

294
00:33:30,200 --> 00:33:32,370
This is a chess board.

295
00:33:32,370 --> 00:33:38,000
And the eight queens problem says, find a way to put down eight queens on a chess board so that no two are attacking each other.

296
00:33:38,000 --> 00:33:41,430
And here's a particular solution to the eight queens problem.

297
00:33:41,430 --> 00:33:51,410
So I have to make sure to put down queens so that no two are in the same row or the same column or sit along the same diagonal.

298
00:33:51,410 --> 00:33:56,400
Now, there's sort of a standard way of doing that.

299
00:33:59,740 --> 00:34:04,940
Well, first we need to do is below the surface, at George's level.

300
00:34:04,940 --> 00:34:08,095
We have to find some way to represent a board, and represent positions.

301
00:34:08,095 --> 00:34:09,800
And we'll not worry about that.

302
00:34:09,800 --> 00:34:12,540
But let's assume that there's a predicate called safe.

303
00:34:16,040 --> 00:34:25,400
And what safe is going to do is going to say given that I have a bunch of queens down on the chess board, is it OK to put a queen in this particular spot?

304
00:34:25,400 --> 00:34:32,889
So safe is going to take a row and a column.

305
00:34:32,889 --> 00:34:42,370
That's going to be a place where I'm going to try and put down the next queen, and the rest of positions.

306
00:34:45,420 --> 00:34:58,300
And what safe will say is given that I already have queens down in these positions, is it safe to put another queen down in that row and that column?

307
00:34:58,300 --> 00:34:59,360
And let's not worry about that.

308
00:34:59,360 --> 00:35:01,380
That's George's problem. and it's not hard to write.

309
00:35:01,380 --> 00:35:10,530
You just have to check whether this thing contains any things on that row or that column or in that diagonal.

310
00:35:10,530 --> 00:35:13,590
Now, how would you organize the program given that?

311
00:35:13,590 --> 00:35:20,116
And there's sort of a traditional way to organize it called backtracking.

312
00:35:20,116 --> 00:35:31,290
And it says, well, let's think about all the ways of putting the first queen down in the first column.

313
00:35:31,290 --> 00:35:32,580
There are eight ways.

314
00:35:32,580 --> 00:35:35,880
Well, let's say try the first column.

315
00:35:35,880 --> 00:35:37,300
Try column 1, row 1.

316
00:35:37,300 --> 00:35:43,360
These branches are going to represent the possibilities at each level.

317
00:35:43,360 --> 00:35:45,875
So I'll try and put a queen down in the first column.

318
00:35:45,875 --> 00:35:49,980
And now given that it's in the first column, I'll try and put the next queen down in the first column.

319
00:35:53,035 --> 00:35:56,920
I'll try and put the first queen, the one in the first column, down in the first row.

320
00:35:56,920 --> 00:35:59,050
I'm sorry.

321
00:35:59,050 --> 00:36:01,390
And then given that, we'll put the next queen down in the first row.

322
00:36:01,390 --> 00:36:02,090
And that's no good.

323
00:36:02,090 --> 00:36:04,200
So I'll back up to here.

324
00:36:04,200 --> 00:36:07,510
And I'll say, oh, can I put the first queen down in the second row?

325
00:36:07,510 --> 00:36:08,550
Well, that's no good.

326
00:36:08,550 --> 00:36:09,760
Oh, can I put it down in the third row?

327
00:36:09,760 --> 00:36:12,790
Well, that's good.

328
00:36:12,790 --> 00:36:15,380
Well, now can I put the next queen down in the first column?

329
00:36:15,380 --> 00:36:19,195
Well, I can't visualize this chess board anymore, but I think that's right.

330
00:36:19,195 --> 00:36:20,450
And I try the next one.

331
00:36:20,450 --> 00:36:24,170
And at each place, I go as far down this tree as I can.

332
00:36:24,170 --> 00:36:25,640
And I back up.

333
00:36:25,640 --> 00:36:33,260
If I get down to here and find no possibilities below there, I back all the way up to here, and now start again generating this sub-tree.

334
00:36:33,260 --> 00:36:35,050
And I sort of walk around.

335
00:36:35,050 --> 00:36:40,090
And finally, if I ever manage to get all the way down, I've found a solution.

336
00:36:40,090 --> 00:36:45,930
So that's a typical sort of paradigm that's used a lot in AI programming.

337
00:36:45,930 --> 00:36:47,300
It's called backtracking search.

338
00:36:57,470 --> 00:37:03,860
And it's really unnecessary.

339
00:37:03,860 --> 00:37:06,550
You saw me get confused when I was visualizing this thing.

340
00:37:06,550 --> 00:37:08,550
And you see the complication.

341
00:37:08,550 --> 00:37:10,760
This is a complicated thing to say.

342
00:37:10,760 --> 00:37:12,390
Why is it complicated?

343
00:37:12,390 --> 00:37:18,580
Its because somehow this program is too inordinately concerned with time.

344
00:37:18,580 --> 00:37:22,320
It's too much-- I try this one, and I try this one, and I go back to the last possibility.

345
00:37:22,320 --> 00:37:24,340
And that's a complicated thing.

346
00:37:24,340 --> 00:37:31,200
If I stop worrying about time so much, then there's a much simpler way to describe this.

347
00:37:31,200 --> 00:37:43,400
It says, let's imagine that I have in my hands the tree down to k minus 1 levels.

348
00:37:43,400 --> 00:37:53,560
See, suppose I had in my hands all possible ways to put down queens in the first k columns.

349
00:37:53,560 --> 00:37:54,610
Suppose I just had that.

350
00:37:54,610 --> 00:37:57,070
Let's not worry about how we get it.

351
00:37:57,070 --> 00:37:59,200
Well, then, how do I extend that?

352
00:37:59,200 --> 00:38:02,480
How do I find all possible ways to put down queens in the next column?

353
00:38:02,480 --> 00:38:03,620
It's really easy.

354
00:38:03,620 --> 00:38:16,160
For each of these positions I have, I think about putting down a queen in each row to make the next thing.

355
00:38:16,160 --> 00:38:22,080
And then for each one I put down, I filter those by the ones that are safe.

356
00:38:22,080 --> 00:38:26,860
So instead of thinking about this tree as generated step by step, suppose I had it all there.

357
00:38:29,680 --> 00:38:37,800
And to extend it from level k minus 1 to level k, I just need to extend each thing in all possible ways and only keep the ones that are safe.

358
00:38:37,800 --> 00:38:39,300
And that will give me the tree to level k.

359
00:38:39,300 --> 00:38:44,530
And that's a recursive strategy for solving the eight queens problem.

360
00:38:44,530 --> 00:38:45,780
All right, well, let's look at it.

361
00:38:50,280 --> 00:39:01,030
To solve the eight queens problem on a board of some specified size, we write a sub-procedure called fill-columns.

362
00:39:01,030 --> 00:39:06,086
Fill-columns is going to put down queens up through column k.

363
00:39:06,086 --> 00:39:07,700
And here's the pattern of the recursion.

364
00:39:07,700 --> 00:39:12,990
I'm going to call fill-columns with the size eventually.

365
00:39:12,990 --> 00:39:20,360
So fill-columns says how to put down queens safely in the first k columns of this chess board with a size number of rows in it.

366
00:39:20,360 --> 00:39:23,940
If k is equal to 0, well, then I don't have to put anything down.

367
00:39:23,940 --> 00:39:26,710
So my solution is just an empty chess board.

368
00:39:26,710 --> 00:39:28,070
Otherwise, I'm going to do some stuff.

369
00:39:28,070 --> 00:39:30,522
And I'm going to use collect.

370
00:39:30,522 --> 00:39:31,772
And here's the collect.

371
00:39:34,530 --> 00:39:41,910
I find all ways to put down queens in the first k minus 1 columns.

372
00:39:41,910 --> 00:39:43,320
And this was just what I set for.

373
00:39:43,320 --> 00:39:48,880
Imagine I have this tree down to k minus 1 levels.

374
00:39:48,880 --> 00:39:54,130
And then I find all ways of trying a row, that's just each of the possible rows.

375
00:39:54,130 --> 00:39:58,040
They're size rows, so that's enumerate interval.

376
00:39:58,040 --> 00:40:08,950
And now what I do is I collect together the new row I'm going to try and column k with the rest of the queens.

377
00:40:08,950 --> 00:40:10,200
I adjoin a position.

378
00:40:10,200 --> 00:40:11,290
This is George's problem.

379
00:40:11,290 --> 00:40:13,640
An adjoined position is like safe.

380
00:40:13,640 --> 00:40:19,660
It's a thing that takes a row and a column and the rest of the positions and makes a new position collection.

381
00:40:19,660 --> 00:40:34,620
So I adjoin a position of a new row and a new column to the rest of the queens, where the rest of the queens runs through all possible ways of solving the problem in k minus 1 columns.

382
00:40:34,620 --> 00:40:43,240
And the new row runs through all possible rows such that it was safe to put one there.

383
00:40:43,240 --> 00:40:46,500
And that's the whole program.

384
00:40:46,500 --> 00:40:49,840
There's the whole procedure.

385
00:40:49,840 --> 00:40:56,680
Not only that, that doesn't just solve the eight queens problem, it gives you all solutions to the eight queens problem.

386
00:40:56,680 --> 00:40:58,480
When you're done, you have a stream.

387
00:40:58,480 --> 00:41:01,900
And the elements of that stream are all possible ways of solving that problem.

388
00:41:05,310 --> 00:41:06,260
Why is that simpler?

389
00:41:06,260 --> 00:41:12,720
Well, we threw away the whole idea that this is some process that happens in time with state.

390
00:41:12,720 --> 00:41:14,420
And we just said it's a whole collection of stuff.

391
00:41:14,420 --> 00:41:18,260
And that's why it's simpler.

392
00:41:18,260 --> 00:41:20,110
We've changed our view.

393
00:41:20,110 --> 00:41:22,820
Remember, that's where we started today.

394
00:41:22,820 --> 00:41:26,230
We've changed our view of what it is we're trying to model.

395
00:41:26,230 --> 00:41:31,750
we stop modeling things that evolve in time and have steps and have state.

396
00:41:31,750 --> 00:41:40,750
And instead, we're trying to model this global thing like the whole flight of the chalk, rather than its state at each instant.

397
00:41:40,750 --> 00:41:42,000
Any questions?

398
00:41:43,810 --> 00:41:54,030
AUDIENCE: It looks to me like backtracking would be searching for the first solution it can find, whereas this recursive search would be looking for all solutions.

399
00:41:54,030 --> 00:42:01,360
And it seems that if you have a large enough area to search, that the second is going to become impossible.

400
00:42:01,360 --> 00:42:08,570
PROFESSOR: OK, the answer to that question is the whole rest of this lecture.

401
00:42:08,570 --> 00:42:10,540
It's exactly the right question.

402
00:42:13,522 --> 00:42:22,220
And without trying to anticipate the lecture too much, you should start being suspicious at this point, and exactly those kinds of suspicions.

403
00:42:22,220 --> 00:42:24,830
It's wonderful, but isn't it so terribly inefficient?

404
00:42:24,830 --> 00:42:28,100
That's where we're going.

405
00:42:28,100 --> 00:42:30,020
So I won't answer now, but I'll answer later.

406
00:42:33,350 --> 00:42:34,600
OK, let's take a break.

407
00:43:29,650 --> 00:43:35,600
Well, by now you should be starting to get suspicious.

408
00:43:35,600 --> 00:43:53,740
See, I've showed your this simple, elegant way of putting programs together, very unlike these other traditional programs that sum the odd squares or compute the odd Fibonacci numbers.

409
00:43:53,740 --> 00:44:00,440
Very unlike these programs that mix up the enumerator and the filter and the accumulator.

410
00:44:00,440 --> 00:44:13,800
And by mixing it up, we don't have all of these wonderful conceptual advantages of these streams pieces, these wonderful mix and match components for putting together lots and lots of programs.

411
00:44:13,800 --> 00:44:18,340
On the other hand, most of the programs you've seen look like these ugly ones.

412
00:44:18,340 --> 00:44:19,460
Why's that?

413
00:44:19,460 --> 00:44:33,620
Can it possibly be that computer scientists are so obtuse that they don't notice that if you'd merely did this thing, then you can get this great programming elegance?

414
00:44:33,620 --> 00:44:36,760
There's got to be a catch.

415
00:44:36,760 --> 00:44:39,510
And it's actually pretty easy to see what the catch is.

416
00:44:39,510 --> 00:44:42,030
Let's think about the following problem.

417
00:44:42,030 --> 00:44:54,105
Suppose I tell you to find the second prime between 10,000 and 1 million, or if your computer's larger, say between 10,000 and 100 billion, or something.

418
00:44:54,105 --> 00:44:55,550
And you say, oh, that's easy.

419
00:44:55,550 --> 00:44:57,080
I can do that with a stream.

420
00:44:57,080 --> 00:45:04,160
All I do is I enumerate the interval from 10,000 to 1 million.

421
00:45:04,160 --> 00:45:06,800
So I get all those integers from 10,000 to 1 million.

422
00:45:06,800 --> 00:45:11,762
I filter them for prime-ness, so test all of them and see if they're prime.

423
00:45:11,762 --> 00:45:13,170
And I take the second element.

424
00:45:13,170 --> 00:45:16,130
That's the head of the tail.

425
00:45:16,130 --> 00:45:17,380
Well, that's clearly pretty ridiculous.

426
00:45:21,660 --> 00:45:27,040
We'd not even have room in the machine to store the integers in the first place, much less to test them.

427
00:45:27,040 --> 00:45:29,810
And then I only want the second one.

428
00:45:29,810 --> 00:45:45,090
See, the power of this traditional programming style is exactly its weakness, that we're mixing up the enumerating and the testing and the accumulating.

429
00:45:45,090 --> 00:45:46,670
So we don't do it all.

430
00:45:46,670 --> 00:45:55,210
So the very thing that makes it conceptually ugly is the very thing that makes it efficient.

431
00:45:55,210 --> 00:45:57,800
It's this mixing up.

432
00:45:57,800 --> 00:46:00,420
So it seems that all I've done this morning so far is just confuse you.

433
00:46:00,420 --> 00:46:05,840
I showed you this wonderful way that programming might work, except that it doesn't.

434
00:46:05,840 --> 00:46:09,040
Well, here's where the wonderful thing happens.

435
00:46:09,040 --> 00:46:14,870
It turns out in this game that we really can have our cake and eat it too.

436
00:46:14,870 --> 00:46:36,310
And what I mean by that is that we really can write stream programs exactly like the ones I wrote and arrange things so that when the machine actually runs, it's as efficient as running this traditional programming style that mixes up the generation and the test.

437
00:46:36,310 --> 00:46:40,770
Well, that sounds pretty magic.

438
00:46:40,770 --> 00:46:43,690
The key to this is that streams are not lists.

439
00:46:48,090 --> 00:46:52,115
We'll see this carefully in a second, but for now, let's take a look at that slide again.

440
00:46:52,115 --> 00:47:05,360
The image you should have here of this signal processing system is that what's going to happen is there's this box that has the integers sitting in it.

441
00:47:05,360 --> 00:47:10,940
And there's this filter that's connected to it and it's tugging on them.

442
00:47:10,940 --> 00:47:16,790
And then there's someone who's tugging on this stuff saying what comes out of the filter.

443
00:47:16,790 --> 00:47:24,590
And the image you should have is that someone says, well, what's the first prime, and tugs on this filter.

444
00:47:24,590 --> 00:47:28,020
And the filter tugs on the integers.

445
00:47:28,020 --> 00:47:30,930
And you look only at that much, and then say, oh, I really wanted the second one.

446
00:47:30,930 --> 00:47:33,710
What's the second prime?

447
00:47:33,710 --> 00:47:40,500
And that no computation gets done except when you tug on these things.

448
00:47:40,500 --> 00:47:41,410
Let me try that again.

449
00:47:41,410 --> 00:47:43,815
This is a little device.

450
00:47:43,815 --> 00:47:49,830
This is a little stream machine invented by Eric Grimson who's been teaching this course at MIT.

451
00:47:49,830 --> 00:47:54,780
And the image is here's a stream of stuff, like a whole bunch of the integers.

452
00:47:54,780 --> 00:47:58,700
And here's some processing elements.

453
00:47:58,700 --> 00:48:02,600
And if, say, it's filter of filter of map, or something.

454
00:48:05,570 --> 00:48:12,670
And if I really tried to implement that with streams as lists, what I'd say is, well, I've got this list of things, and now I do the first filter.

455
00:48:12,670 --> 00:48:14,070
So do all this processing.

456
00:48:14,070 --> 00:48:19,610
And I take this and I process and I process and I process and I process.

457
00:48:19,610 --> 00:48:21,910
And now I'm got this new stream.

458
00:48:21,910 --> 00:48:24,070
Now I take that result in my hand someplace.

459
00:48:24,070 --> 00:48:25,260
And I put that through the second one.

460
00:48:25,260 --> 00:48:28,110
And I process the whole thing.

461
00:48:28,110 --> 00:48:29,510
And there's this new stream.

462
00:48:32,130 --> 00:48:36,360
And then I take the result and I put it all the way through this one the same way.

463
00:48:36,360 --> 00:48:43,860
That's what would happen to these stream programs if streams were just lists.

464
00:48:43,860 --> 00:48:50,230
But in fact, streams aren't lists, they're streams. And the image you should have is something a little bit more like this.

465
00:48:50,230 --> 00:48:57,130
I've got these gadgets connected up by this data that's flowing out of them.

466
00:48:59,960 --> 00:49:05,980
And here's my original source of the streams. It might be starting to generate the integers.

467
00:49:05,980 --> 00:49:07,580
And now, what happens if I want a result?

468
00:49:07,580 --> 00:49:10,200
I tug on the end here.

469
00:49:10,200 --> 00:49:13,090
And this element says, gee, I need some more data.

470
00:49:13,090 --> 00:49:15,830
So this one comes here and tugs on that one.

471
00:49:15,830 --> 00:49:17,890
And it says, gee, I need some more data.

472
00:49:17,890 --> 00:49:21,640
And this one tugs on this thing, which might be a filter, and says, gee, I need some more data.

473
00:49:21,640 --> 00:49:25,780
And only as much of this thing at the end here gets generated as I tugged.

474
00:49:25,780 --> 00:49:30,760
And only as much of this stuff goes through the processing units as I'm pulling on the end I need.

475
00:49:30,760 --> 00:49:37,830
That's the image you should have of the difference between implementing what we're actually going to do and if streams were lists.

476
00:49:40,600 --> 00:49:42,430
Well, how do we make this thing?

477
00:49:42,430 --> 00:49:43,400
I hope you have the image.

478
00:49:43,400 --> 00:49:44,947
The trick is how to make it.

479
00:49:47,930 --> 00:49:56,920
We want to arrange for a stream to be a data structure that computes itself incrementally, an on-demand data structure.

480
00:49:59,220 --> 00:50:04,490
And the basic idea is, again, one of the very basic ideas that we're seeing throughout the whole course.

481
00:50:04,490 --> 00:50:09,240
And that is that there's not a firm distinction between programs and data.

482
00:50:09,240 --> 00:50:16,810
So what a stream is going to be is simultaneously this data structure that you think of, like the stream of the leaves of this tree.

483
00:50:16,810 --> 00:50:23,550
But at the same time, it's going to be a very clever procedure that has the method of computing in it.

484
00:50:23,550 --> 00:50:25,930
Well, let me try this.

485
00:50:25,930 --> 00:50:28,460
It's going to turn out that we don't need any more mechanism.

486
00:50:28,460 --> 00:50:35,460
We already have everything we need simply from the fact that we know how to handle procedures as first-class objects.

487
00:50:35,460 --> 00:50:36,880
Well, let's go back to the key.

488
00:50:36,880 --> 00:50:39,030
The key is, remember, we had these operations.

489
00:50:39,030 --> 00:50:48,080
CONS-stream and head and tail.

490
00:50:48,080 --> 00:50:55,080
When I started, I said you can think about this as CONS and think about this as CAR and think about that as CDR, but it's not.

491
00:50:55,080 --> 00:50:57,550
Now, let's look at what they really are.

492
00:50:57,550 --> 00:51:19,540
Well, CONS-stream of x and y is going to be an abbreviation for the following thing.

493
00:51:19,540 --> 00:51:28,000
CONS form a pair, ordinary CONS, of x to a thing called delay of y.

494
00:51:31,188 --> 00:51:39,790
And before I explain that, let me go and write the rest. The head of a stream is going to be just the CAR.

495
00:51:42,380 --> 00:51:56,120
And the tail of a stream is going to be a thing called force the CDR of the stream.

496
00:51:56,120 --> 00:51:58,060
Now let me explain this.

497
00:51:58,060 --> 00:52:01,420
Delay is going to be a special magic thing.

498
00:52:01,420 --> 00:52:10,600
What delay does is take an expression and produce a promise to compute that expression when you ask for it.

499
00:52:10,600 --> 00:52:11,980
It doesn't do any computation here.

500
00:52:11,980 --> 00:52:14,820
It just gives you a rain check.

501
00:52:14,820 --> 00:52:17,110
It produces a promise.

502
00:52:17,110 --> 00:52:25,360
And CONS-stream says I'm going to put together in a pair x and a promise to compute y.

503
00:52:28,230 --> 00:52:31,840
Now, if I want the head, that's just the CAR that I put in the pair.

504
00:52:31,840 --> 00:52:39,110
And the key is that the tail is going to be-- force calls in that promise.

505
00:52:39,110 --> 00:52:44,610
Tail says, well, take that promise and now call in that promise.

506
00:52:44,610 --> 00:52:47,430
And then we compute that thing.

507
00:52:47,430 --> 00:52:48,740
That's how this is going to work.

508
00:52:48,740 --> 00:52:51,550
That's what CONS-stream, head, and tail really are.

509
00:52:54,196 --> 00:52:55,570
Now, let's see how this works.

510
00:52:55,570 --> 00:52:58,410
And we'll go through this fairly carefully.

511
00:52:58,410 --> 00:53:08,650
We're going to see how this works in this example of computing the second prime between 10,000 and a million.

512
00:53:08,650 --> 00:53:11,610
OK, so we start off and we have this expression.

513
00:53:15,820 --> 00:53:26,710
The second prime-- the head of the tail of the result of filtering for primality the integers between 10,000 and 1 million.

514
00:53:26,710 --> 00:53:28,400
Now, what is that?

515
00:53:28,400 --> 00:53:40,250
What that is, that interval between 10,000 and 1 million, well, if you trace through enumerate interval, there builds a CONS-stream.

516
00:53:40,250 --> 00:53:54,480
And the CONS-stream is the CONS of 10,000 to a promise to compute the integers between 10,001 and 1 million.

517
00:53:54,480 --> 00:53:55,750
So that's what this expression is.

518
00:53:55,750 --> 00:53:57,640
Here I'm using the substitution model.

519
00:53:57,640 --> 00:54:01,010
And we can use the substitution model because we don't have side effects and state.

520
00:54:04,270 --> 00:54:08,380
So I have CONS of 10,000 to a promise to compute the rest of the integers.

521
00:54:08,380 --> 00:54:09,850
So only one integer, so far, got enumerated.

522
00:54:14,380 --> 00:54:16,580
Well, I'm going to filter that thing for primality.

523
00:54:19,900 --> 00:54:22,360
Again, you go back and look at the filter code.

524
00:54:22,360 --> 00:54:25,460
What the filter will first do is test the head.

525
00:54:25,460 --> 00:54:33,500
So in this case, the filter will test 10,000 and say, oh, 10,000's not prime.

526
00:54:33,500 --> 00:54:39,220
Therefore, what I have to do recursively is filter the tail.

527
00:54:39,220 --> 00:54:46,340
And what's the tail of it, well, that's the tail of this pair with a promise in it.

528
00:54:46,340 --> 00:54:49,680
Tail now comes in and says, well, I'm going to force that.

529
00:54:49,680 --> 00:55:00,880
I'm going to force that promise, which means now I'm going to compute the integers between 10,001 and 1 million.

530
00:55:00,880 --> 00:55:02,970
OK, so this filter now is looking at that.

531
00:55:07,810 --> 00:55:11,960
That enumerate itself, well, now we're back in the original enumerate situation.

532
00:55:11,960 --> 00:55:19,740
The enumerate is the CONS of the first thing, 10,001, onto a promise to compute the rest.

533
00:55:19,740 --> 00:55:23,060
So now the primality filter is going to go look at 10,001.

534
00:55:23,060 --> 00:55:25,120
It's going to decide if it likes that or not.

535
00:55:25,120 --> 00:55:27,550
It turns out 10,001 isn't prime.

536
00:55:27,550 --> 00:55:29,610
So it'll force it again and again and again.

537
00:55:32,920 --> 00:55:37,100
And finally, I think the first prime it hits is 10,009.

538
00:55:37,100 --> 00:55:40,465
And at that point, it'll stop.

539
00:55:40,465 --> 00:55:45,240
And that will be the first prime, and then eventually, it'll need the second prime.

540
00:55:45,240 --> 00:55:47,030
So at that point, it will go again.

541
00:55:47,030 --> 00:55:53,130
So you see what happens is that no more gets generated than you actually need.

542
00:55:56,690 --> 00:56:04,930
That enumerator is not going to generate any more integers than the filter asks it for as it's pulling in things to check for primality.

543
00:56:04,930 --> 00:56:11,255
And the filter is not going to generate any more stuff than you ask it for, which is the head of the tail.

544
00:56:11,255 --> 00:56:28,160
You see, what's happened is we've put that mixing of generation and test into what actually happens in the computer, even though that's not apparently what's happening from looking at our programs.

545
00:56:28,160 --> 00:56:30,230
OK, well, that seemed easy.

546
00:56:30,230 --> 00:56:33,326
All of this mechanism got put into this magic delay.

547
00:56:33,326 --> 00:56:36,900
So you're saying, gee, that must be where the magic is.

548
00:56:36,900 --> 00:56:39,070
But see there's no magic there either.

549
00:56:39,070 --> 00:56:40,610
You know what delay is.

550
00:56:40,610 --> 00:56:56,490
Delay on some expression is just an abbreviation for--  well, what's a promise to compute an expression?

551
00:56:56,490 --> 00:57:03,000
Lambda of nil, procedure of no arguments, which is that expression.

552
00:57:03,000 --> 00:57:03,930
That's what a procedure is.

553
00:57:03,930 --> 00:57:06,050
It says I'm going to compute an expression.

554
00:57:06,050 --> 00:57:07,460
What's force?

555
00:57:07,460 --> 00:57:10,800
How do I take up a promise?

556
00:57:10,800 --> 00:57:15,890
Well, force of some procedure, a promise, is just run it.

557
00:57:18,710 --> 00:57:20,120
Done.

558
00:57:20,120 --> 00:57:23,580
So there's no magic there at all.

559
00:57:23,580 --> 00:57:26,440
Well, what have we done?

560
00:57:26,440 --> 00:57:30,960
We said the old style, traditional style of programming is more efficient.

561
00:57:30,960 --> 00:57:35,260
And the stream thing is more perspicuous.

562
00:57:35,260 --> 00:57:43,350
And we managed to make the stream procedures run like the other procedures by using delay.

563
00:57:43,350 --> 00:57:54,440
And the thing that delay did for us was to de-couple the apparent order of events in our programs from the actual order of events that happened in the machine.

564
00:57:54,440 --> 00:57:56,540
That's really what delay is doing.

565
00:57:56,540 --> 00:57:58,290
That's exactly the whole point.

566
00:57:58,290 --> 00:58:09,182
We've given up the idea that our procedures, as they run, or as we look at them, mirror some clear notion of time.

567
00:58:09,182 --> 00:58:16,690
And by giving that up, we give delay the freedom to arrange the order of events in the computation the way it likes.

568
00:58:16,690 --> 00:58:17,610
That's the whole idea.

569
00:58:17,610 --> 00:58:24,200
We de-couple the apparent order of events in our programs from the actual order of events in the computer.

570
00:58:24,200 --> 00:58:25,770
OK, well there's one more detail.

571
00:58:25,770 --> 00:58:29,730
It's just a technical detail, but it's actually an important one.

572
00:58:29,730 --> 00:58:39,320
As you run through these recursive programs unwinding, you'll see a lot of things that look like tail of the tail of the tail.

573
00:58:39,320 --> 00:58:43,860
That's the kind of thing that would happen as I go CONSing down a stream all the way.

574
00:58:43,860 --> 00:59:05,290
And if each time I'm doing that, each time to compute a tail, I evaluate a procedure which then has to go re-compute its tail, and re-compute its tail and recompute its tail each time, you can see that's very inefficient compared to just having a list where the elements are all there, and I don't have to re-compute each tail every time I get the next tail.

575
00:59:05,290 --> 00:59:20,390
So there's one little hack to slightly change what delay is, and make it a thing which is-- I'll write it this way.

576
00:59:20,390 --> 00:59:31,000
The actual implementation, delay is an abbreviation for this thing, memo-proc of a procedure.

577
00:59:31,000 --> 00:59:35,150
Memo-proc is a special thing that transforms a procedure.

578
00:59:35,150 --> 00:59:44,806
What it does is it takes a procedure of no arguments and it transforms it into a procedure that'll only have to do its computation once.

579
00:59:44,806 --> 00:59:48,700
And what I mean by that is, you give it a procedure.

580
00:59:48,700 --> 01:00:02,360
The result of memo-proc will be a new procedure, which the first time you call it, will run the original procedure, remember what result it got, and then from ever on after, when you call it, it just won't have to do the computation.

581
01:00:02,360 --> 01:00:05,200
It will have cached that result someplace.

582
01:00:05,200 --> 01:00:06,550
And here's an implementation of memo-proc.

583
01:00:11,210 --> 01:00:12,710
Once you have the idea, it's easy to implement.

584
01:00:12,710 --> 01:00:17,390
Memo-proc is this little thing that has two little flags in there.

585
01:00:17,390 --> 01:00:20,320
It says, have I already been run?

586
01:00:20,320 --> 01:00:23,620
And initially it says, no, I haven't already been run.

587
01:00:23,620 --> 01:00:29,070
And what was the result I got the last time I was run?

588
01:00:29,070 --> 01:00:34,360
So memo-proc takes a procedure called proc, and it returns a new procedure of no arguments.

589
01:00:34,360 --> 01:00:38,610
Proc is supposed to be a procedure of no arguments.

590
01:00:38,610 --> 01:00:44,430
And it says, oh, if I'm not already run, then I'm going to do a sequence of things.

591
01:00:44,430 --> 01:00:48,450
I'm going to compute proc, I'm going to save that.

592
01:00:48,450 --> 01:00:51,140
I'm going to stash that in the variable result.

593
01:00:51,140 --> 01:00:56,610
I'm going to make a note to myself that I've already been run, and then I'll return the result.

594
01:00:56,610 --> 01:00:59,010
So that's if you compute it if it's not already run.

595
01:00:59,010 --> 01:01:03,420
If you call it and it's already been run, it just returns the result.

596
01:01:03,420 --> 01:01:08,400
So that's a little clever hack called memoization.

597
01:01:08,400 --> 01:01:15,270
And in this case, it short circuits having to re-compute the tail of the tail of the tail of the tail of the tail.

598
01:01:15,270 --> 01:01:17,810
So there isn't even that kind of inefficiency.

599
01:01:17,810 --> 01:01:24,210
And in fact, the streams will run with pretty much the same efficiency as the other programs precisely.

600
01:01:24,210 --> 01:01:33,610
And remember, again, the whole idea of this is that we've used the fact that there's no really good dividing line between procedures and data.

601
01:01:33,610 --> 01:01:38,760
We've written data structures that, in fact, are sort of like procedures.

602
01:01:38,760 --> 01:01:49,620
And what that's allowed us to do is take an example of a common control structure, in this place iteration.

603
01:01:49,620 --> 01:01:55,496
And we've built a data structure which, since itself is a procedure, kind of has this iteration control structure in it.

604
01:01:55,496 --> 01:01:58,650
And that's really what streams are.

605
01:01:58,650 --> 01:01:59,900
OK, questions?

606
01:02:03,950 --> 01:02:13,052
AUDIENCE: Your description of tail-tail-tail, if I understand it correctly, force is actually execution of a procedure, if it's done without this memo-proc thing.

607
01:02:13,052 --> 01:02:16,380
And you implied that memo-proc gets around that problem.

608
01:02:16,380 --> 01:02:23,910
Doesn't it only get around it if tail-tail-tail is always executing exactly the same-- PROFESSOR: Oh, that's-- sure.

609
01:02:23,910 --> 01:02:26,050
AUDIENCE: I guess I missed that point.

610
01:02:26,050 --> 01:02:26,540
PROFESSOR: Oh, sure.

611
01:02:26,540 --> 01:02:31,290
I mean the point is--  yeah.

612
01:02:31,290 --> 01:02:34,160
I mean I have to do a computation to get the answer.

613
01:02:34,160 --> 01:02:42,980
But the point is, once I've found the tail of the stream, to get the tail of the tail, I shouldn't have had to re-compute the first tail.

614
01:02:42,980 --> 01:02:46,460
See, and if I didn't use memo-proc, that re-computation would have been done.

615
01:02:46,460 --> 01:02:47,710
AUDIENCE: I understand now.

616
01:02:50,830 --> 01:02:56,830
AUDIENCE: In one of your examples, you mentioned that we were able to use the substitution model because there are no side effects.

617
01:02:56,830 --> 01:03:03,620
What if we had a single processing unit-- if we had a side effect, if we had a state?

618
01:03:03,620 --> 01:03:09,120
Could we still practically build the stream model?

619
01:03:09,120 --> 01:03:09,530
PROFESSOR: Maybe.

620
01:03:09,530 --> 01:03:10,540
That's a hard question.

621
01:03:10,540 --> 01:03:18,960
I'm going to talk a little bit later about the places where substitution and side effects don't really mix very well.

622
01:03:18,960 --> 01:03:25,170
But in general, I think the answer is unless you're very careful, any amount of side effect is going to mess up everything.

623
01:03:35,490 --> 01:03:39,410
AUDIENCE: Sorry, I didn't quite understand the memo-proc operation.

624
01:03:39,410 --> 01:03:41,990
When do you execute the lambda?

625
01:03:41,990 --> 01:03:47,600
In other words, when memo-proc is executed, just this lambda expression is being generated.

626
01:03:47,600 --> 01:03:50,390
But it's not clear to me when it's executed.

627
01:03:50,390 --> 01:03:51,350
PROFESSOR: Right.

628
01:03:51,350 --> 01:03:57,930
What memo-proc does-- remember, the thing that's going into memo-proc, the thing proc, is a procedure of no arguments.

629
01:03:57,930 --> 01:04:00,390
And someday, you're going to call it.

630
01:04:00,390 --> 01:04:06,620
Memo-proc translates that procedure into another procedure of no arguments, which someday you're going to call.

631
01:04:06,620 --> 01:04:09,890
That's that lambda.

632
01:04:09,890 --> 01:04:24,100
So here, where I initially built as my tail of the stream, say, this procedure of no arguments, which someday I'll call.

633
01:04:24,100 --> 01:04:30,650
Instead, I'm going to have the tail of the stream be memo-proc of it, which someday I'll call.

634
01:04:30,650 --> 01:04:47,642
So that lambda of nil, that gets called when you call the memo-proc, when you call the result of that memo-proc, which would be ordinarily when you would have called the original thing that you set it.

635
01:04:47,642 --> 01:04:52,610
AUDIENCE: OK, the reason I ask is I had a feeling that when you call memo-proc, you just return this lambda.

636
01:04:52,610 --> 01:04:53,770
PROFESSOR: That's right.

637
01:04:53,770 --> 01:04:58,100
When you call memo-proc, you return the lambda.

638
01:04:58,100 --> 01:05:02,270
You never evaluate the expression at all, until the first time that you would have evaluated it.

639
01:05:07,590 --> 01:05:14,240
AUDIENCE: Do I understand it right that you actually have to build the list up, but the elements of the list don't get evaluated?

640
01:05:14,240 --> 01:05:15,630
The expressions don't get evaluated?

641
01:05:15,630 --> 01:05:18,540
But at each stage, you actually are building a list.

642
01:05:18,540 --> 01:05:20,700
PROFESSOR: That's-- I really should have said this.

643
01:05:20,700 --> 01:05:22,270
That's a really good point.

644
01:05:22,270 --> 01:05:23,660
No, it's not quite right.

645
01:05:23,660 --> 01:05:25,080
Because what happens is this.

646
01:05:25,080 --> 01:05:26,890
Let me draw this as pairs.

647
01:05:26,890 --> 01:05:32,740
Suppose I'm going to make a big stream, like enumerate interval, 1 through 1 billion.

648
01:05:32,740 --> 01:05:43,045
What that is, is a pair with a 1 and a promise.

649
01:05:46,520 --> 01:05:47,890
That's exactly what it is.

650
01:05:47,890 --> 01:05:49,140
Nothing got built up.

651
01:05:51,600 --> 01:05:56,370
When I go and force this, and say, what happens?

652
01:05:56,370 --> 01:06:00,530
Well, this thing is now also recursively a CONS.

653
01:06:00,530 --> 01:06:11,350
So that this promise now is the next thing, which is a 2 and a promise to do more.

654
01:06:11,350 --> 01:06:14,470
And so on and so on and so on.

655
01:06:14,470 --> 01:06:18,200
So nothing gets built up until you walk down the stream.

656
01:06:18,200 --> 01:06:25,500
Because what's sitting here is not the list, but a promise to generate the list. And by promise, technically I mean procedure.

657
01:06:28,050 --> 01:06:30,485
So it doesn't get built up.

658
01:06:30,485 --> 01:06:34,280
Yeah, I should have said that before this point.

659
01:06:34,280 --> 01:06:34,490
OK.

660
01:06:34,490 --> 01:06:34,790
Thank you.

661
01:06:34,790 --> 01:06:36,340
Let's take a break.

