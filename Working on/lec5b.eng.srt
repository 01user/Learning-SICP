1
00:00:21,170 --> 00:00:36,630
PROFESSOR: Well, now that we've given you some power to make independent local state and to model objects, I thought we'd do a bit of programming of a very complicated kind, just to illustrate what you can do with this sort of thing.

7
00:00:40,430 --> 00:00:52,060
I suppose, as I said, we were motivated by physical systems and the ways we like to think about physical systems, which is that there are these things that the world is made out of.

10
00:00:52,060 --> 00:00:58,830
And each of these things has particular independent local state, and therefore it is a thing.

12
00:00:58,830 --> 00:01:01,280
That's what makes it a thing.

13
00:01:01,280 --> 00:01:10,940
And then we're going to say that in the model in the world--we have a world and a model in our minds and in the computer of that world.

16
00:01:10,940 --> 00:01:28,570
And what I want to make is a correspondence between the objects in the world and the objects in the computer, the relationships between the objects in the world and the relationships between those same obj...--the model objects in the computer, and the functions that relate things in the world to the functions that relate things in the computer.

24
00:01:30,840 --> 00:01:34,740
This buys us modularity.

25
00:01:34,740 --> 00:01:50,450
If we really believe the world is like that, that it's made out of these little pieces, and of course we could arrange our world to be like that, we could only model those things that are like that, then we can inherit the modularity in the world into our programming.

30
00:01:50,450 --> 00:01:55,420
That's why we would invent some of this object-oriented programming.

32
00:01:55,420 --> 00:01:58,890
Well, let's take the best kind of objects I know.

33
00:01:58,890 --> 00:02:14,220
They're completely--they're completely wonderful: electrical systems. Electrical systems really are the physicist's best, best objects.

36
00:02:14,220 --> 00:02:16,760
You see over here I have some piece of machinery.

37
00:02:16,760 --> 00:02:20,040
Right here's a piece of machinery.

38
00:02:20,040 --> 00:02:27,190
And it's got an electrical wire connecting one part of the machinery with another part of the machinery.

40
00:02:27,190 --> 00:02:38,310
And one of the wonderful properties of the electrical world is that I can say this is an object, and this is an object, and they're-- the connection between them is clear.

44
00:02:38,310 --> 00:02:44,740
In principle, there is no connection that I didn't describe with these wires.

46
00:02:44,740 --> 00:02:51,370
Let's say if I have light bulbs, a light bulb and a power supply that's plugged into the outlet.

48
00:02:51,370 --> 00:02:53,620
Then the connection is perfectly clear.

49
00:02:53,620 --> 00:02:56,220
There's no other connections that we know of.

50
00:02:56,220 --> 00:03:04,040
If I were to tie a knot in the wire that connects the light bulb to the power supply, the light remains lit up.

52
00:03:04,040 --> 00:03:05,290
It doesn't care.

54
00:03:08,300 --> 00:03:15,270
That the way the physics is arranged is such that the connection can be made abstract, at least for low frequencies and things like that.

58
00:03:17,840 --> 00:03:22,350
So in fact, we have captured all of the connections there really are.

60
00:03:22,350 --> 00:03:30,951
Well, as you can go one step further and talk about the most abstract types of electrical systems we have, digital to dual circuits.

63
00:03:30,951 --> 00:03:34,610
And here there are certain kinds of objects.

64
00:03:34,610 --> 00:03:41,092
For example, in digital circuits we have things like inverters.

66
00:03:41,092 --> 00:03:43,990
We have things like and-gates.

67
00:03:43,990 --> 00:03:47,210
We have things like or-gates.

68
00:03:47,210 --> 00:03:55,610
We connect them together by sort-of wires which represent abstract signals.

70
00:03:55,610 --> 00:04:05,160
We don't really care as physical variables whether these are voltages or currents or some combination or anything like that, or water, water pressure.

73
00:04:05,160 --> 00:04:09,420
These abstract variables represent certain signals.

74
00:04:09,420 --> 00:04:14,070
And we build systems by wiring these things together with wires.

76
00:04:14,070 --> 00:04:32,700
So today what I'm going to show you, right now, we're going to build up an invented language in Lisp, embedded in the same sense that Henderson's picture language was embedded, which is not the same sense as the language of pattern match and substitution was done yesterday.

81
00:04:32,700 --> 00:04:38,160
The pattern match/substitution language was interpreted by a Lisp program.

83
00:04:38,160 --> 00:04:45,480
But the embedding of Henderson's program is that we just build up more and more procedures that encapsulate the structure we want.

86
00:04:45,480 --> 00:04:53,026
So for example here, I'm going to have some various primitive kinds of objects, as you see, that one and that one.

88
00:04:53,026 --> 00:04:55,810
I'm going to use wires to combine them.

89
00:04:55,810 --> 00:04:59,870
The way I represent attaching-- I can make wires.

91
00:04:59,870 --> 00:05:01,740
So let's say A is a wire.

92
00:05:01,740 --> 00:05:02,690
And B is a wire.

93
00:05:02,690 --> 00:05:03,460
And C is a wire.

94
00:05:03,460 --> 00:05:04,230
And D is a wire.

95
00:05:04,230 --> 00:05:04,830
And E is wire.

96
00:05:04,830 --> 00:05:06,880
And S is a wire.

97
00:05:06,880 --> 00:05:17,940
Well, an or-gate that has both inputs, the inputs being A and B, and the output being Y or D, you notate like this.

99
00:05:17,940 --> 00:05:24,820
An and-gate, which has inputs A and B and output C, we notate like that.

101
00:05:24,820 --> 00:05:32,750
By making such a sequence of declarations, like this, I can wire together an arbitrary circuit.

103
00:05:32,750 --> 00:05:43,690
So I've just told you a set of primitives and means of combination for building digital circuits, when I need more in a real language than abstraction.

106
00:05:43,690 --> 00:05:52,240
And so for example, here I have--here I have a half adder.

108
00:05:52,240 --> 00:05:56,930
It's something you all know if you've done any digital design.

110
00:05:56,930 --> 00:06:03,956
It's used for adding numbers together on A and B and putting out a sum and a carry.

112
00:06:03,956 --> 00:06:07,450
And in fact, the wiring diagram is exactly what I told you.

114
00:06:07,450 --> 00:06:14,790
A half adder with things that come out of the box-- you see the box, the boundary, the abstraction is always a box.

116
00:06:14,790 --> 00:06:19,700
And there are things that come out of it, A, B, S, and C.

117
00:06:19,700 --> 00:06:28,270
Those are the declared variables--declared variables of a lambda expression, which is the one that defines half adder.

121
00:06:31,400 --> 00:06:48,790
And internal to that, I make up some more wires, D and E, which I'm going to use for the interconnect-- here E is this one and D is this wire, the interconnect that doesn't come through the walls of the box-- and wire things together as you just saw.

126
00:06:48,790 --> 00:06:53,890
And the nice thing about this that I've just shown you is this language is hierarchical in the right way.

128
00:06:53,890 --> 00:07:06,300
If a language isn't hierarchical in the right way, if it turns out that a compound object doesn't look like a primitive, there's something wrong with the language-- at least the way I feel about that.

133
00:07:06,300 --> 00:07:23,350
So here we have--here, instead of starting with mathematical functions, or things that compute mathematical functions, which is what we've been doing up until now, instead of starting with things that look like mathematical functions, or compute such things, we are starting with things that are electrical objects and we build up more electrical objects.

140
00:07:23,350 --> 00:07:30,500
And the glue we're using is basically the Lisp structure: lambdas.

142
00:07:30,500 --> 00:07:32,930
Lambda is the ultimate glue, if you will.

143
00:07:32,930 --> 00:08:05,900
And of course, half adder itself can be used in a more complicated abstraction called a full adder, which in fact involves two half adders, as you see here, hooked together with some extra wires, that you see here, S, C1, and C2, and an or-gate, to manufacture a full adder, which takes a input number, another input number, a carry in, and produces output, a sum and a carry out.

150
00:08:05,900 --> 00:08:12,990
And out of full adders, you can make real adder chains and big adders.

152
00:08:12,990 --> 00:08:22,270
So we have here a language so far that has primitives, means of combination, and means of abstraction to real language.

154
00:08:22,270 --> 00:08:25,000
Now, how are we going to implement this?

155
00:08:25,000 --> 00:08:27,070
Well, let's do it easily.

156
00:08:27,070 --> 00:08:28,610
Let's look at the primitives.

157
00:08:28,610 --> 00:08:31,160
The only problem is we have to implement the primitives.

158
00:08:31,160 --> 00:08:43,417
Nothing else has to be implemented, because we're picking up the means of combination and abstraction from Lisp, inheriting them in the embedding.

161
00:08:43,417 --> 00:08:45,860
OK, so let's look at a particular primitive.

162
00:08:45,860 --> 00:08:47,400
An inverter is a nice one.

164
00:08:51,540 --> 00:08:54,900
Now, inverter has two wires coming in, an in and an out.

166
00:08:57,440 --> 00:09:04,300
And somehow, it's going to have to know what to do when a signal comes in.

168
00:09:04,300 --> 00:09:20,120
So somehow it's going to have to tell its input wire-- and now we're going to talk about objects and we're going to see this in a little more detail soon-- but it's going to have to tell its input wire that when you change, tell me.

173
00:09:20,120 --> 00:09:26,870
So this object, the object which is the inverter has to tell the object which is the input wire, hi, my name is George.

176
00:09:26,870 --> 00:09:31,720
And my, my job is to do something with results when you change.

178
00:09:31,720 --> 00:09:34,730
So when you change, you get a change, tell me about it.

179
00:09:34,730 --> 00:09:37,010
Because I've got to do something with that.

180
00:09:37,010 --> 00:09:56,130
Well, that's done down here by adding an action on the input wire called invert-in, where invert-in is defined over here to be a procedure of no arguments, which gets the logical not of the signal on the input wire.

184
00:09:56,130 --> 00:10:07,140
And after some delay, which is the inverter delay, all these electrical objects have delays, we'll do the following thing-- set the signal on the output wire to the new value.

188
00:10:10,160 --> 00:10:12,400
A very simple program.

189
00:10:12,400 --> 00:10:23,840
Now, you have to imagine that the output wire has to be sensitive and know that when its signal changes, it may have to tell other guys, hey, wake up.

192
00:10:23,840 --> 00:10:26,050
My value has changed.

193
00:10:26,050 --> 00:10:36,810
So when you hook together inverter with an and-gate or something like that, there has to be a lot of communication going on in order to make sure that the signal propagates right.

197
00:10:36,810 --> 00:10:38,620
And down here is nothing very exciting.

198
00:10:38,620 --> 00:10:46,240
This is just the definition of logical not for some particular representations of the logical values-- 1, 0 in this case.

201
00:10:46,240 --> 00:10:49,780
And we can look at things more complicated like and-gates.

202
00:10:49,780 --> 00:10:56,950
And-gates take two inputs, A1 and A2, we'll call them, and produce an output.

204
00:10:56,950 --> 00:11:00,860
But the structure of the and-gate is identical to the one we just saw.

206
00:11:00,860 --> 00:11:10,910
There's one called an and-action procedure that's defined, which is the thing that gets called when an input is changed.

209
00:11:10,910 --> 00:11:15,900
And what it does, of course, is nothing more than compute the logical and of the signals on the inputs.

211
00:11:15,900 --> 00:11:25,470
And after some delay, called the and-gate delay, calls this procedure, which sets a signal on the output to a new value.

213
00:11:25,470 --> 00:11:28,350
Now, how I implement these things is all wishful thinking.

215
00:11:28,350 --> 00:11:32,020
As you see here, I have an assignment operation.

216
00:11:32,020 --> 00:11:34,570
It's not set.

217
00:11:34,570 --> 00:11:46,340
It's a derived assignment operation in the same way we had functions that were derived from CAR and CDR. So I, by convention, label that with an exclamation point.

220
00:11:46,340 --> 00:12:03,350
And over here, you see there's an action, which is to inform the wire, called A1 locally in this and-gate, to call the and-action procedure when it gets changed, and the wire A2 to call the and-action procedure when it gets changed.

226
00:12:06,310 --> 00:12:09,510
All very simple.

227
00:12:09,510 --> 00:12:18,310
Well, let's talk a little bit about this communication that must occur between these various parts.

229
00:12:18,310 --> 00:12:47,360
Suppose, for example, I have a very simple circuit which contains an and with wires A and B. And that connects through a wire called C to an inverter which has a wire output called D. What are the comput...--here's the physical world.

234
00:12:47,360 --> 00:12:49,860
It's an abstraction of the physical world.

235
00:12:49,860 --> 00:12:54,880
Now I can buy these out of little pieces that you get at Radio Shack for a few cents.

237
00:12:54,880 --> 00:13:01,530
And there are boxes that act like this, which have little numbers on them like LS04 or something.

239
00:13:01,530 --> 00:13:09,010
Now supposing I were to try to say what's the computational model.

241
00:13:09,010 --> 00:13:15,850
What is the thing that corresponds to that, that part of reality in the mind of us and in the computer?

243
00:13:15,850 --> 00:13:25,750
Well, I have to assign for every object in the world an object in the computer, and for every relationship in the world between them a relationship in the computer.

246
00:13:25,750 --> 00:13:28,560
That's my goal.

247
00:13:28,560 --> 00:13:30,900
So let's do that.

248
00:13:30,900 --> 00:13:35,401
Well, I have some sort of thing called the signal, A.

249
00:13:35,401 --> 00:13:37,940
This is A. It's a signal.

250
00:13:37,940 --> 00:13:39,900
It's a cloudy thing like that.

251
00:13:39,900 --> 00:13:49,140
And I have another one down here which I'm going to call B. It's another signal.

253
00:13:49,140 --> 00:14:00,320
Now this signal--these two signals are somehow going to have to hook together into a box, let's call it this, which is the and-gate, action procedure.

256
00:14:00,320 --> 00:14:02,040
That's the and-gate's action procedure.

258
00:14:07,660 --> 00:14:30,195
And it's going to produce--well, it's going to interact with a signal object, which we call C--a wire object, excuse me, we call C. And then the-- this is going to put out again, or connect to, another action procedure which is one associated with the inverter in the world, not.

265
00:14:32,860 --> 00:14:42,970
And I'm going to have another--another wire, which we'll call D.

267
00:14:42,970 --> 00:14:45,770
So here's my layout of stuff.

268
00:14:45,770 --> 00:14:51,500
Now we have to say what's inside them and what they have to know to compute.

270
00:14:51,500 --> 00:14:57,340
Well, every--every one of these wires has to know what the value of the signal that's on that wire is.

272
00:14:57,340 --> 00:15:00,680
So there's going to be some variable inside here, we'll call it signal.

275
00:15:02,670 --> 00:15:05,840
And he owns a value.

276
00:15:05,840 --> 00:15:08,656
So there must be some environment associated with this.

278
00:15:08,656 --> 00:15:11,800
And for each one of these, there must be an environment that binds signal.

281
00:15:15,400 --> 00:15:16,880
And there must be a signal here, therefore.

283
00:15:19,400 --> 00:15:24,170
And presumably, signal's a value that's either 1 or 0, and signal.

286
00:15:28,000 --> 00:15:34,390
Now, we also have to have some list of people to inform if the signal here changes.

289
00:15:36,660 --> 00:15:39,300
We're going to have to inform this.

290
00:15:39,300 --> 00:15:44,500
So I've got that list. We'll call it the Action Procedures, AP.

292
00:15:44,500 --> 00:15:50,500
And it's presumably a list. But the first thing on the list, in this case, is this guy.

294
00:15:50,500 --> 00:15:54,810
And the action procedures of this one happens to have some list of stuff.

296
00:15:54,810 --> 00:15:59,020
There might be other people who are sharing A, who are looking at it.

298
00:15:59,020 --> 00:16:03,630
So there might be other guys on this list, like somebody over there that we don't know about.

300
00:16:03,630 --> 00:16:07,200
It's the other guy attached to A.

301
00:16:07,200 --> 00:16:13,070
And the action procedure here also has to point to that, the list of action procedures.

303
00:16:13,070 --> 00:16:18,530
And of course, that means this one, its action procedures has to point up to here.

305
00:16:18,530 --> 00:16:21,770
This is the things-- the people it has to inform.

307
00:16:21,770 --> 00:16:24,280
And this guy has some too.

308
00:16:24,280 --> 00:16:27,190
But I don't know what they are because I didn't draw it in my diagram.

310
00:16:27,190 --> 00:16:30,320
It's the things connected to D.

311
00:16:30,320 --> 00:16:52,790
Now, it's also the case that when the and-action procedure is awakened, saying one of the people who know that you've told--one of the people you've told to wake you up if their signal changes, you have to go look and ask them what's their signal so you can do the and, and produce a signal for this one.

318
00:16:57,090 --> 00:17:06,400
So there has to be, for example, information here saying A1, my A1 is this guy, and my A2 is this guy.

321
00:17:08,930 --> 00:17:16,170
And not only that, when I do my and, I'm going to have to tell this guy something.

323
00:17:16,170 --> 00:17:21,160
So I need an output--  being this guy.

327
00:17:25,800 --> 00:17:43,520
And similarly, this guy's going to have a thing called the input that he interrogates to find out what the value of the signal on the input is, when the signal wakes up and says, I've changed, and sends a message this way saying, I've changed.

332
00:17:43,520 --> 00:17:46,900
This guy says, OK, what's your value now?

333
00:17:46,900 --> 00:17:55,860
When he gets that value, then he's going to have to say, OK, output changes this guy, changes this guy.

336
00:18:00,600 --> 00:18:02,481
And so on.

337
00:18:02,481 --> 00:18:06,240
And so I have to have at least that much connected-ness.

338
00:18:06,240 --> 00:18:10,260
Now, let's go back and look, for example, at the and-gate.

339
00:18:10,260 --> 00:18:13,670
Here we are back on this slide.

340
00:18:13,670 --> 00:18:16,040
And we can see some of these parts.

341
00:18:16,040 --> 00:18:21,030
For any particular and-gate, there is an A1, there is an A2, and the output.

343
00:18:21,030 --> 00:18:46,240
And those are, those are an environment that was created at the--those produce a frame at the time and-gate was called, a frame where A1, A2, and output are--have as their values, they're bound to the wires which, they are--which were passed in.

348
00:18:46,240 --> 00:18:54,590
In that environment, I constructed a procedure-- this one right there.

350
00:18:54,590 --> 00:18:57,780
And-action procedure was constructed in that environment.

352
00:18:57,780 --> 00:19:01,620
That was the result of evaluating a lambda expression.

354
00:19:01,620 --> 00:19:07,620
So it hangs onto the frame where these were defined.

355
00:19:07,620 --> 00:19:11,700
Local--part of its local state is that.

356
00:19:11,700 --> 00:19:17,310
The and-action procedure, therefore, has access to A1, A2, and output as we see here.

358
00:19:17,310 --> 00:19:19,645
A1, A2, and output.

360
00:19:22,360 --> 00:19:26,030
Now, we haven't looked inside of a wire yet.

361
00:19:26,030 --> 00:19:29,030
That's all that remains.

362
00:19:29,030 --> 00:19:30,280
Let's look at a wire.

364
00:19:33,520 --> 00:19:36,160
Like the overhead, very good.

366
00:19:39,500 --> 00:19:43,090
Well, the wire, again, is a, is a somewhat complicated mess.

368
00:19:43,090 --> 00:19:46,840
Ooh, wrong one.

369
00:19:46,840 --> 00:19:49,780
It's a big complicated mess, like that.

370
00:19:49,780 --> 00:19:54,720
But let's look at it in detail and see what's going on.

371
00:19:54,720 --> 00:19:57,760
Well, the wire is one of these.

372
00:19:57,760 --> 00:20:05,010
And it has to have two things that are part of it, that it's state.

374
00:20:05,010 --> 00:20:07,390
One of them is the signal we see here.

375
00:20:07,390 --> 00:20:19,270
In other words, when we call make-wire to make a wire, then the first thing we do is we create some variables which are the signal and the action procedures for this wire.

379
00:20:22,042 --> 00:20:27,840
And in that context, we define various functions--or procedures, excuse me, procedures.

381
00:20:27,840 --> 00:20:32,850
One of them is called set-my-signal to a new value.

382
00:20:32,850 --> 00:20:37,930
And what that does is takes a new value in.

383
00:20:37,930 --> 00:20:40,360
If that's equal to my current value of my signal, I'm done.

384
00:20:40,360 --> 00:20:54,630
Otherwise, I set the signal to the new value and call each of the action procedures that I've been, that I've been--what's the right word?--  introduced to.

389
00:20:54,630 --> 00:21:01,530
I get introduced when the and-gate was applied to me.

391
00:21:04,130 --> 00:21:07,410
I add action procedure at the bottom.

392
00:21:07,410 --> 00:21:27,780
Also, I have to define a way of accepting an action procedure-- which is what you see here--- which increments my action procedures using set to the result of CONSing up a new process--a procedure, which is passed to me, on to my actions procedures list. And for technical reasons, I have to call that procedure one.

398
00:21:27,780 --> 00:21:36,950
So I'm not going to tell you anything about that, that has to do with event-driven simulations and getting them started, which takes a little bit of thinking.

401
00:21:36,950 --> 00:21:53,820
And finally, I'm going to define a thing called the dispatcher, which is a way of passing a message to a wire, which is going to be used to extract from it various information, like what is the current signal value?

405
00:21:53,820 --> 00:21:57,180
What is the method of setting your signal?

406
00:21:57,180 --> 00:22:00,100
I want to get that out of it.

407
00:22:00,100 --> 00:22:02,600
How do I--how do I add another action procedure?

409
00:22:05,510 --> 00:22:09,940
And I'm going to return that dispatch, that procedure as a value.

411
00:22:09,940 --> 00:22:19,790
So the wire that I've constructed is a message accepting object which accepts a message like, like what's your method of adding action procedures?

414
00:22:19,790 --> 00:22:29,010
In fact, it'll give me a procedure, which is the add action procedure, which I can then apply to an action procedure to create another action procedure in the wire.

418
00:22:31,620 --> 00:22:32,820
So that's a permission.

419
00:22:32,820 --> 00:22:37,450
So it's given me permission to change your action procedures.

420
00:22:37,450 --> 00:22:41,710
And in fact, you can see that over here.

421
00:22:41,710 --> 00:22:43,278
Next slide.

422
00:22:43,278 --> 00:22:44,528
Ah.

424
00:22:47,760 --> 00:22:49,120
This is nothing very interesting.

425
00:22:49,120 --> 00:22:54,990
The call each of the action procedures is just a CDRing down a list. And I'm not going to even talk about that anymore.

428
00:22:54,990 --> 00:22:57,560
We're too advanced for that.

429
00:22:57,560 --> 00:23:03,090
However, if I want to get a signal from a wire, I ask the wire-- which is, what is the wire?

432
00:23:03,090 --> 00:23:05,860
The wire is the dispatch returned by creating the wire.

433
00:23:05,860 --> 00:23:06,830
It's a procedure.

434
00:23:06,830 --> 00:23:12,590
I call that dispatch on the message get-signal.

435
00:23:12,590 --> 00:23:16,900
And what I should expect to get is a method of getting a signal.

437
00:23:16,900 --> 00:23:19,220
Or actually, I get the signal.

438
00:23:19,220 --> 00:23:38,700
If I want to set a signal, I want to change a signal, then what I'm going to do is take a wire as an argument and a new value for the signal, I'm going to ask the wire for permission to set its signal and use that permission, which is a procedure, on the new value.

443
00:23:38,700 --> 00:24:13,010
And if we go back to the overhead here, thank you, if we go back to the overhead here, we see that the method-- if I ask for the method of setting the signal, that's over here, it's set-my-signal, a procedure that's defined inside the wire, which if we look over here is the thing that says set my internal value called the signal, my internal variable, which is the signal, to the new value, which is passed to me as an argument, and then call each of the action procedures waking them up.

453
00:24:16,340 --> 00:24:19,400
Very simple.

454
00:24:19,400 --> 00:24:30,100
Going back to that slide, we also have the one last thing-- which I suppose now you can easily work out for yourself-- is the way you add an action.

457
00:24:30,100 --> 00:24:36,470
You take a wire--a wire and an action procedure.

458
00:24:36,470 --> 00:24:40,050
And I ask the wire for permission to add an action.

459
00:24:40,050 --> 00:24:45,020
Getting that permission, I use that permission to give it an action procedure.

461
00:24:45,020 --> 00:24:48,570
So that's a real object.

462
00:24:48,570 --> 00:24:52,460
There's a few more details about this.

463
00:24:52,460 --> 00:24:58,390
For example, how am I going to control this thing?

464
00:24:58,390 --> 00:25:01,290
How do I do these delays?

465
00:25:01,290 --> 00:25:02,540
Let's look at that for a second.

467
00:25:05,275 --> 00:25:08,360
The next one here.

468
00:25:08,360 --> 00:25:09,570
Let's see.

469
00:25:09,570 --> 00:25:18,770
We know when we looked at the and-gate or the not-gate that when a signal changed on the input, there was a delay.

471
00:25:18,770 --> 00:25:23,310
And then it was going to call the procedure, which was going to change the output.

474
00:25:26,040 --> 00:25:28,120
Well, how are we going to do this?

475
00:25:28,120 --> 00:25:34,720
We're going to make up some mechanism, a fairly complicated mechanism at that, which we're going to have to be very careful about.

478
00:25:34,720 --> 00:25:37,390
But after a delay, we're going to do an action.

479
00:25:37,390 --> 00:25:40,590
A delay is a number, and an action is a procedure.

480
00:25:40,590 --> 00:25:49,510
What that's going to be is they're going to have a special structure called an agenda, which is a thing that organizes time and actions.

483
00:25:49,510 --> 00:25:50,880
And we're going to see that in a while.

484
00:25:50,880 --> 00:25:53,070
I don't want to get into that right now.

485
00:25:53,070 --> 00:25:59,130
But the agenda has a moment at which--at which something happens.

487
00:25:59,130 --> 00:26:08,460
We're setting up for later at some moment, which is the sum of the time, which is the delay time plus the current time, which the agenda thinks is now.

490
00:26:08,460 --> 00:26:13,090
We're going to set up to do this action, and add that to the agenda.

493
00:26:15,280 --> 00:26:18,660
And the way this machine will now run is very simple.

494
00:26:18,660 --> 00:26:22,710
We have a thing called propagate, which is the way things run.

496
00:26:22,710 --> 00:26:27,440
If the agenda is empty, we're done--if there's nothing more to be done.

498
00:26:27,440 --> 00:26:34,200
Otherwise, we're going to take the first item off the agenda, and that's a procedure of no arguments.

500
00:26:34,200 --> 00:26:36,030
So that we're going to see extra parentheses here.

501
00:26:36,030 --> 00:26:39,190
We call that on no arguments.

502
00:26:39,190 --> 00:26:42,200
That takes the action.

503
00:26:42,200 --> 00:26:48,395
Then we remove that first item from the agenda, and we go around the propagation loop.

505
00:26:48,395 --> 00:26:50,750
So that's the overall structure of this thing.

507
00:26:53,380 --> 00:26:57,430
Now, there's a, a few other things we can look at.

508
00:26:57,430 --> 00:27:00,410
And then we're going to look into the agenda a little while from now.

510
00:27:00,410 --> 00:27:02,800
Now the overhead again.

511
00:27:02,800 --> 00:27:07,410
Well, in order to set this thing going, I just want to show you some behavior out of this simulator.

513
00:27:07,410 --> 00:27:12,370
By the way, you may think this simulator is very simple, and probably too simple to be useful.

515
00:27:12,370 --> 00:27:18,680
The fact of the matter is that this simulator has been used to manufacture a fairly large computer.

517
00:27:18,680 --> 00:27:22,360
So this is a real live example.

518
00:27:22,360 --> 00:27:25,560
Actually, not exactly this simulator, because I'll tell you the difference.

520
00:27:25,560 --> 00:27:29,820
The difference is that there were many more different kinds of primitives.

522
00:27:29,820 --> 00:27:33,200
There's not just the word inverter or and-gate.

523
00:27:33,200 --> 00:27:45,170
There were things like edge-triggered, flip-flops, and latches, transparent latches, and adders, and things like that.

526
00:27:45,170 --> 00:27:54,690
And the difficulty with that is that there's pages and pages of the definitions of all these primitives with numbers like LS04.

529
00:27:54,690 --> 00:27:56,740
And then there's many more parameters for them.

530
00:27:56,740 --> 00:27:58,480
It's not just one delay.

531
00:27:58,480 --> 00:28:01,220
There's things like set up times and hold times and all that.

533
00:28:01,220 --> 00:28:15,110
But with the exception of that part of the complexity, the structure of the simulator that we use for building a real computer, that works is exactly what you're seeing here.

537
00:28:15,110 --> 00:28:19,270
Well in any case, what we have here is a few simple things.

538
00:28:19,270 --> 00:28:23,030
Like, there's inverter delays being set up and making a new agenda.

540
00:28:23,030 --> 00:28:26,470
And then we can make some inputs.

541
00:28:26,470 --> 00:28:29,460
There's input-1, input-2, a sum and a carry, which are wires.

543
00:28:29,460 --> 00:28:37,810
I'm going to put a special kind of object called a probe onto, onto some of the wires, onto sum and onto carry.

545
00:28:37,810 --> 00:28:46,120
A probe is a, can object that has the property that when you change a wire it's attached to, it types out a message.

547
00:28:46,120 --> 00:28:47,970
It's an easy thing to do.

548
00:28:47,970 --> 00:28:59,400
And then once we have that, of course, the way you put the probe on, the first thing it does, it says, the current value of the sum at time 0 is 0 because I just noticed it.

551
00:28:59,400 --> 00:29:05,556
And the value of the carry at time 0, this is the time, is 0.

553
00:29:05,556 --> 00:29:09,620
And then we go off and we build some structure.

554
00:29:09,620 --> 00:29:18,420
Like, we can build a structure here that says you have a half-adder on input-1, input-2, sum, and carry.

556
00:29:18,420 --> 00:29:20,420
And we're going to set the signal on input-1 to 1.

557
00:29:20,420 --> 00:29:21,880
We do some propagation.

558
00:29:21,880 --> 00:29:29,520
At time 8, which you could see going through this thing if you wanted to, the new value of sum became 1.

560
00:29:29,520 --> 00:29:31,150
And the thing says I'm done.

561
00:29:31,150 --> 00:29:32,630
That wasn't very interesting.

562
00:29:32,630 --> 00:29:34,150
But we can send it some more signals.

563
00:29:34,150 --> 00:29:36,590
Like, we set-signal on input-2 to be one.

564
00:29:36,590 --> 00:29:45,040
And at that time if we propagate, then it carried at 11, the carry becomes 1, and at 16, the sum's new value becomes 0.

567
00:29:45,040 --> 00:29:48,990
And you might want to work out that, if you like, about the digital circuitry.

569
00:29:48,990 --> 00:29:50,620
It's true, and it works.

570
00:29:50,620 --> 00:29:51,535
And it's not very interesting.

571
00:29:51,535 --> 00:29:54,580
But that's the kind of behavior we get out of this thing.

574
00:30:01,830 --> 00:30:12,952
So what I've shown you right now is a large-scale picture, how you, at a bigger, big scale, you implement an event-driven simulation of some sort.

577
00:30:12,952 --> 00:30:21,225
And how you might organize it to have nice hierarchical structure allowing you to build abstract boxes that you can instantiate.

580
00:30:21,225 --> 00:30:25,780
But I haven't told you any of the details about how this agenda and things like that work.

582
00:30:25,780 --> 00:30:28,630
That we'll do next.

583
00:30:28,630 --> 00:30:34,310
And that's going to involve change and mutation of data and things like that.

585
00:30:34,310 --> 00:30:35,860
Are there any questions now, before I go on?

587
00:30:47,160 --> 00:30:47,550
Thank you.

588
00:30:47,550 --> 00:30:48,800
Let's take a break.

590
00:31:28,940 --> 00:31:35,060
Well, we've been making a simulation.

591
00:31:35,060 --> 00:31:43,920
And the simulation is an event-driven simulation where the objects in the world are the objects in the computer.

593
00:31:43,920 --> 00:32:04,420
And the changes of state that are happening in the world in time are organized to be time in the computer, so that if something happens after something else in the world, then we have it happen after, after the corresponding events happen in the same order in the computer.

598
00:32:04,420 --> 00:32:08,220
That's where we have assignments, when we make that alignment.

600
00:32:08,220 --> 00:32:16,040
Right now I want to show you a way of organizing time, which is an agenda or priority queue, it's sometimes called.

602
00:32:16,040 --> 00:32:21,230
We'll do some--we'll do a little bit of just understanding what are the things we need to be able to do to make agendas.

606
00:32:28,330 --> 00:32:35,960
And so we're going to have--and so right now over here, I'm going to write down a bunch of primitive operations for manipulating agendas.

609
00:32:35,960 --> 00:32:43,680
I'm not going to show you the code for them because they're all very simple, and you've got listings of all that anyway.

612
00:32:43,680 --> 00:32:44,380
So what do we have?

613
00:32:44,380 --> 00:32:54,130
We have things like make-agenda which produces a new agenda.

616
00:32:59,860 --> 00:33:12,625
We can ask--we get the current-time of an agenda, which gives me a number, a time.

619
00:33:16,990 --> 00:33:21,900
We can get--we can ask whether an agenda is empty, empty-agenda.

622
00:33:30,200 --> 00:33:32,570
And that produces either a true or a false.

624
00:33:42,590 --> 00:33:44,720
We can add an object to an agenda.

626
00:33:52,710 --> 00:33:56,910
Actually, what we add to an agenda is an operation--an action to be done.

628
00:33:56,910 --> 00:34:04,810
And that takes a time, the action itself, and the agenda I want to add it to.

631
00:34:07,850 --> 00:34:10,719
That inserts it in the appropriate place in the agenda.

633
00:34:10,719 --> 00:34:23,259
I can get the first item off an agenda, the first thing I have to do, which is going to give me an action.

636
00:34:26,085 --> 00:34:29,540
And I can remove the first item from an agenda.

637
00:34:29,540 --> 00:34:31,409
That's what I have to be able to do with agendas.

638
00:34:31,409 --> 00:34:33,020
That is a big complicated mess.

640
00:34:42,530 --> 00:34:43,780
From an agenda.

642
00:34:45,530 --> 00:34:52,528
Well, let's see how we can organize this thing as a data structure a bit.

644
00:34:52,528 --> 00:35:01,570
Well, an agenda is going to be some kind of list. And it's going to be a list that I'm going to have to be able to modify.

647
00:35:01,570 --> 00:35:11,070
So we have to talk about modifying of lists, because I'm going to add things to it, and delete things from it, and things like that.

650
00:35:11,070 --> 00:35:13,820
It's organized by time.

651
00:35:13,820 --> 00:35:15,570
It's probably good to keep it in sorted order.

653
00:35:18,330 --> 00:35:23,420
But sometimes there are lots of things that happen at the same time--approximate same time.

655
00:35:23,420 --> 00:35:29,040
What I have to do is say, group things by the time at which they're supposed to happen.

657
00:35:29,040 --> 00:35:32,780
So I'm going to make an agenda as a list of segments.

658
00:35:32,780 --> 00:35:39,620
And so I'm going to draw you a data structure for an agenda, a perfectly reasonable one.

660
00:35:39,620 --> 00:35:41,110
Here's an agenda.

661
00:35:41,110 --> 00:35:42,870
It's a thing that begins with a name.

663
00:35:47,630 --> 00:35:49,940
I'm going to do it right now out of list structure.

665
00:35:52,620 --> 00:35:53,980
It's got a header.

666
00:35:53,980 --> 00:35:55,840
There's a reason for the header.

667
00:35:55,840 --> 00:35:57,630
We're going to see the reason soon.

669
00:36:00,680 --> 00:36:03,750
And it will have a segment.

670
00:36:03,750 --> 00:36:05,620
It will have--it will be a list of segments.

672
00:36:08,310 --> 00:36:33,320
Supposing this agenda has two segments, they're the car's-- successive car's of this list. Each segment is going to have a time--  say for example, 10-- that says that the things that happen in this segment are at time 10.

679
00:36:33,320 --> 00:36:42,240
And what I'm going to have in here is another data structure which I'm not going to describe, which is a queue of things to do at time 10.

682
00:36:42,240 --> 00:36:43,330
It's a queue.

683
00:36:43,330 --> 00:36:45,130
And we'll talk about that in a second.

684
00:36:45,130 --> 00:36:50,200
But abstractly, the queue is just a list of things to do at a particular time.

686
00:36:50,200 --> 00:36:53,100
And I can add things to a queue.

687
00:36:53,100 --> 00:36:56,140
This is a queue.

688
00:36:56,140 --> 00:36:59,115
There's a time, there's a segment.

690
00:37:02,889 --> 00:37:06,035
Now, I may have another segment in this agenda.

692
00:37:08,940 --> 00:37:13,410
Supposing this is stuff that happens at time 30.

693
00:37:13,410 --> 00:37:23,210
It has, of course, another queue of things that are queued up to be done at time 30.

695
00:37:23,210 --> 00:37:27,090
Well, there are various things I have to be able to do to an agenda.

697
00:37:27,090 --> 00:37:33,030
Supposing I want to add to an agenda another thing to be done at time 10.

699
00:37:33,030 --> 00:37:34,700
Well, that's not very hard.

700
00:37:34,700 --> 00:37:39,730
I'm going to walk down here, looking for the segment of time 10.

702
00:37:39,730 --> 00:37:42,930
It is possible that there is no segment of time 10.

703
00:37:42,930 --> 00:37:45,420
We'll cover that case in a second.

704
00:37:45,420 --> 00:37:56,290
But if I find a segment of time 10, then if I want to add another thing to be done at time 10, I just increase that queue-- "just increase" isn't such an obvious idea.

708
00:37:56,290 --> 00:38:01,430
But I increase the things to be done at that time.

709
00:38:01,430 --> 00:38:05,140
Now, supposing I want to add something to be done at time 20.

711
00:38:05,140 --> 00:38:08,680
There is no segment for time 20.

712
00:38:08,680 --> 00:38:11,340
I'm going to have to create a new segment.

713
00:38:11,340 --> 00:38:17,610
I want my time 20 segment to exist between time 10 and time 30.

715
00:38:17,610 --> 00:38:20,170
Well, that takes a little work.

716
00:38:20,170 --> 00:38:21,525
I'm going to have to do a CONS.

718
00:38:24,260 --> 00:38:29,940
I'm going to have to make a new element of the agenda list--list of segments.

721
00:38:33,600 --> 00:38:35,400
I'm going to have to change.

722
00:38:35,400 --> 00:38:37,540
Here's change.

723
00:38:37,540 --> 00:38:56,657
I'm going to have to change the CDR of the CDR of the agenda to point that a new CONS of the new segment and the CDR of the CDR of the CDR of the agenda, the CD-D-D-DR.

726
00:38:56,657 --> 00:39:06,290
And this is going to have a new segment now of time 20 with its own queue, which now has one element in it.

729
00:39:10,730 --> 00:39:20,770
If I wanted to add something at the end, I'm going to have to replace the CDR of this, of this list with something.

731
00:39:20,770 --> 00:39:24,040
We're going to have to change that piece of data structure.

732
00:39:24,040 --> 00:39:27,210
So I'm going to need new primitives for doing this.

733
00:39:27,210 --> 00:39:29,550
But I'm just showing you why I need them.

734
00:39:29,550 --> 00:39:49,400
And finally, if I wanted to add a thing to be done at time 5, I'm going to have to change this one, because I'm going to have to add it in over here, which is why I planned ahead and had a header cell, which has a place.

738
00:39:49,400 --> 00:39:53,420
If I'm going to change things, I have to have places for the change.

740
00:39:53,420 --> 00:39:58,600
I have to have a place to make the change.

741
00:39:58,600 --> 00:40:02,540
If I remove things from the agenda, that's not so hard.

742
00:40:02,540 --> 00:40:11,220
Removing them from the beginning is pretty easy, which is the only case I have. I can go looking for the first, the first segment.

745
00:40:11,220 --> 00:40:14,510
I see if it has a non-empty queue.

746
00:40:14,510 --> 00:40:20,100
If it has a non-empty queue, well, I'm going to delete one element from the queue, like that.

748
00:40:20,100 --> 00:40:24,220
If the queue ever becomes empty, then I have to delete the whole segment.

750
00:40:24,220 --> 00:40:28,220
And then this, this changes to point to here.

751
00:40:28,220 --> 00:40:36,440
So it's quite a complicated data structure manipulation going on, the details of which are not really very exciting.

753
00:40:36,440 --> 00:40:38,920
Now, let's talk about queues.

754
00:40:38,920 --> 00:40:41,160
They're similar.

755
00:40:41,160 --> 00:40:44,340
Because each of these agendas has a queue in it.

756
00:40:44,340 --> 00:40:45,590
What's a queue?

758
00:40:49,079 --> 00:40:52,350
A queue is going to have the following primitive operations.

760
00:40:52,350 --> 00:41:02,170
To make a queue, this gives me a new queue.

762
00:41:07,274 --> 00:41:16,850
I'm going to have to be able to insert into a queue a new item.

765
00:41:24,510 --> 00:41:28,740
I'm going to have to be able to delete from a queue the first item in the queue.

768
00:41:39,988 --> 00:41:52,890
And I want to be able to get the first thing in the queue from some queue.

770
00:41:52,890 --> 00:41:55,140
I also have to be able to test whether a queue is empty.

772
00:42:07,110 --> 00:42:15,120
And when you invent things like this, I want you to be very careful to use the kinds of conventions I use for naming things.

775
00:42:15,120 --> 00:42:19,870
Notice that I'm careful to say these change something and that tests it.

777
00:42:19,870 --> 00:42:24,335
And presumably, I did the same thing over here.

778
00:42:24,335 --> 00:42:29,240
OK, and there should be an empty test over here.

779
00:42:29,240 --> 00:42:31,720
OK, well, how would I make a queue?

780
00:42:31,720 --> 00:42:37,840
A queue wants to be something I can add to at the end of, and pick up the thing at the beginning of.

782
00:42:37,840 --> 00:42:41,230
I should be able to delete from the beginning and add to the end.

784
00:42:41,230 --> 00:42:43,740
Well, I'm going to show you a very simple structure for that.

786
00:42:43,740 --> 00:42:47,080
We can make this out of CONSes as well.

787
00:42:47,080 --> 00:42:49,910
Here's a queue.

788
00:42:49,910 --> 00:42:59,610
It has--it has a queue header, which contains two parts-- a front pointer and a rear pointer.

791
00:43:02,930 --> 00:43:09,000
And here I have a queue with two items in it.

792
00:43:09,000 --> 00:43:12,095
The first item, I don't know, it's perhaps a 1.

793
00:43:12,095 --> 00:43:16,530
And the second item, I don't know, let's give it a 2.

795
00:43:21,160 --> 00:43:31,850
The reason why I want two pointers in here, a front pointer and a rear pointer, is so I can add to the end without having to chase down from the beginning.

798
00:43:31,850 --> 00:43:47,530
So for example, if I wanted to add one more item to this queue, if I want to add on another item to be worried about later, all I have to do is make a CONS, which contains that item, say a 3.

802
00:43:47,530 --> 00:43:51,340
That's for inserting 3 into the queue.

803
00:43:51,340 --> 00:44:00,100
Then I have to change this pointer here to here.

804
00:44:00,100 --> 00:44:04,320
And I have to change this one to point to the new rear.

806
00:44:09,120 --> 00:44:18,890
If I wish to take the first element of the queue, the first item, I just go chasing down the front pointer until I find the first one and pick it up.

809
00:44:18,890 --> 00:44:27,450
If I wish to delete the first item from the queue, delete-queue, all I do is move the front pointer along this way.

812
00:44:27,450 --> 00:44:31,700
The new front of the queue is now this.

813
00:44:31,700 --> 00:44:34,390
So queues are very simple too.

814
00:44:34,390 --> 00:44:41,350
So what you see now is that I need a certain number of new primitive operations.

816
00:44:41,350 --> 00:44:42,560
And I'm going to give them some names.

817
00:44:42,560 --> 00:44:47,350
And then we're going to look into how they work, and how they're used.

819
00:44:47,350 --> 00:44:58,940
We have set the CAR of some pair, or a thing produced by CONSing, to a new value.

822
00:45:02,370 --> 00:45:09,920
And set the CDR of a pair to a new value.

824
00:45:12,680 --> 00:45:16,030
And then we're going to look into how they work.

825
00:45:16,030 --> 00:45:20,960
I needed setting CAR over here to delete the first element of the queue.

827
00:45:20,960 --> 00:45:23,470
This is the CAR, and I had to set it.

828
00:45:23,470 --> 00:45:30,160
I had to be able to set the CDR to be able to move the rear pointer, or to be able to increment the queue here.

830
00:45:30,160 --> 00:45:35,515
All of the operations I did were made out of those that I just showed you on the, on the last blackboard.

833
00:45:38,230 --> 00:45:38,430
Good.

834
00:45:38,430 --> 00:45:40,357
Let's pause the time, and take a little break then.

836
00:46:38,346 --> 00:47:21,850
When we originally introduced pairs made out of CONS, made by CONS, we only said a few axioms about them, which were of the form-- what were they-- for all X and Y, the CAR of the CONS of X and Y is X and the CDR of the CONS of X and Y is Y. Now, these say nothing about whether a CONS has an identity like a person.

843
00:47:21,850 --> 00:47:29,740
In fact, all they say is something sort of abstract, that a CONS is the parts it's made out of.

845
00:47:29,740 --> 00:47:37,390
And of course, two things are made out of the same parts, they're the same, at least from the point of view of these axioms.

848
00:47:37,390 --> 00:47:49,830
But by introducing assignment-- in fact, mutable data is a kind of assignment, we have a set CAR and a set CDR-- by introducing those, these axioms no longer tell the whole story.

853
00:47:49,830 --> 00:47:53,250
And they're still true if written exactly like this.

854
00:47:53,250 --> 00:47:56,070
But they don't tell the whole story.

855
00:47:56,070 --> 00:48:10,090
Because if I'm going to set a particular CAR in a particular CONS, the questions are, well, is that setting all CARs and all CONSes of the same two things or not?

858
00:48:10,090 --> 00:48:21,570
If I--if we use CONSes to make up things like rational numbers, or things like 3 over 4, supposing I had two three-fourths.

861
00:48:21,570 --> 00:48:25,340
Are they the same one-- or are they different?

863
00:48:25,340 --> 00:48:27,860
Well, in the case of numbers, it doesn't matter.

864
00:48:27,860 --> 00:48:33,020
Because there's no meaning to changing the denominator of a number.

866
00:48:33,020 --> 00:48:36,840
What you could do is make a number which has a different denominator.

868
00:48:36,840 --> 00:48:44,770
But the concept of changing a number which has to have a different denominator is sort of a very weird, and sort of not supported by what you think of as mathematics.

871
00:48:44,770 --> 00:48:53,690
However, when these CONSes represent things in the physical world, then changing something like the CAR is like removing a piece of the fingernail.

874
00:48:53,690 --> 00:48:57,770
And so CONSes have an identity.

875
00:48:57,770 --> 00:49:01,280
Let me show you what I mean about identity, first of all.

876
00:49:01,280 --> 00:49:04,320
Let's do some little example here.

877
00:49:04,320 --> 00:49:15,200
Supposing I define A to the CONS of 1 and 2.

879
00:49:18,040 --> 00:49:38,120
Well, what that means, first of all, is that somewhere in some environment I've made a symbol A to have a value which is a pair consisting of pointers to a 1 and a pointer to a 2, just like that.

883
00:49:38,120 --> 00:50:03,970
Now, supposing I also say define B to be the CONS--  it doesn't matter, but I like it better, it's prettier-- of A and A.

887
00:50:03,970 --> 00:50:07,840
Well, first of all, I'm using the name A twice.

888
00:50:07,840 --> 00:50:11,300
At this moment, I'm going to think of CONSes as having identity.

890
00:50:11,300 --> 00:50:13,690
This is the same one.

891
00:50:13,690 --> 00:50:33,260
And so what that means is I make another pair, which I'm going to call B. And it contains two pointers to A. At this point, I have three names for this object.

894
00:50:33,260 --> 00:50:34,790
A is its name.

895
00:50:34,790 --> 00:50:37,230
The CAR of B is its name.

896
00:50:37,230 --> 00:50:39,360
And the CDR of B is its name.

897
00:50:39,360 --> 00:50:41,150
It has several aliases, they're called.

899
00:50:44,230 --> 00:51:07,880
Now, supposing I do something like set-the-CAR, the CAR of the CAR of B to 3.

902
00:51:12,750 --> 00:51:17,830
What that means is I find the CAR of B, that's this.

903
00:51:17,830 --> 00:51:20,935
I set the CAR of that to be 3, changing this.

905
00:51:24,760 --> 00:51:35,340
I've changed A. If I were to ask what's the CAR of A--of A now?

907
00:51:35,340 --> 00:51:45,290
I would get out 3, even though here we see that A was the CONS of 1 and 2.

909
00:51:45,290 --> 00:51:48,400
I caused A to change by changing B.

910
00:51:48,400 --> 00:51:52,010
There is sharing here.

911
00:51:52,010 --> 00:51:54,240
That's sometimes what we want.

912
00:51:54,240 --> 00:52:04,350
Surely in the queues and things like that, that's exactly what we defined our--organized our data structures to facilitate-- sharing.

916
00:52:04,350 --> 00:52:25,190
But inadvertent sharing, unanticipated interactions between objects, is the source of most of the bugs that occur in complicated programs. So by introducing this possibility of things having identity and sharing and having multiple names for the same thing, we get a lot of power.

921
00:52:25,190 --> 00:52:28,640
But we're going to pay for it with lots of complexity and bugs.

924
00:52:32,190 --> 00:52:46,560
So also, for example, if I just looked at this just to drive that home, the CADR of B, which has nothing to do with even the CAR of B, apparently.

927
00:52:46,560 --> 00:52:49,350
The CADR of B, what's that?

928
00:52:49,350 --> 00:52:53,560
Take that CDR of B and now take the CAR of that.

929
00:52:53,560 --> 00:52:56,480
Oh, that's 3 also.

930
00:52:56,480 --> 00:53:01,120
So I can have non-local interactions by sharing.

931
00:53:01,120 --> 00:53:02,480
And I have to be very careful of that.

933
00:53:06,640 --> 00:53:22,820
Well, so far, of course, it seems I've introduced several different assignment operators-- set, set CAR, set CDR. Well, maybe I should just get rid of set CAR and set CDR. Maybe they're not worthwhile.

937
00:53:22,820 --> 00:53:27,170
Well, the answer is that once you let the camel's nose into the tent, the rest of him follows.

940
00:53:30,160 --> 00:53:35,850
All I have to have is set, and I can make all of the--all of the bad things that can happen.

943
00:53:38,550 --> 00:53:40,690
Let's play with that a little bit.

944
00:53:40,690 --> 00:53:52,480
A couple of days ago, when we introduced compound data, you saw Hal show you a definition of CONS in terms of a message acceptor.

947
00:53:52,480 --> 00:54:04,440
I'm going to show you even a more horrible thing, a definition of CONS in terms of nothing but air, hot air.

949
00:54:04,440 --> 00:54:14,580
What is the definition of CONS, of the old functional kind, in terms of purely lambdic expressions, procedures?

953
00:54:17,190 --> 00:54:28,580
Because I'm going to then modify this definition to get assignment to be only one kind of assignment, to get rid of the set CAR and set CDR in terms of set.

956
00:54:28,580 --> 00:54:46,320
So what if I define CONS of X and Y to be a procedure of one argument called a message M, which calls that message on X and Y?

960
00:54:51,120 --> 00:54:57,870
This [? idea ?] was invented by Alonzo Church, who was the greatest programmer of the 20th century, although he never saw a computer.

963
00:54:57,870 --> 00:54:59,130
It was done in the 1930s.

964
00:54:59,130 --> 00:55:02,220
He was a logician, I suppose at Princeton at the time.

966
00:55:08,660 --> 00:55:46,670
Define CAR of X to be the result of applying X to that procedure of two arguments, A and D, which selects A. I will define CDR of X to be that procedure, to be the result of applying X to that procedure of A and D, which selects D.

970
00:55:46,670 --> 00:55:50,510
Now, you may not recognize this as CAR, CDR, and CONS.

971
00:55:50,510 --> 00:55:55,210
But I'm going to demonstrate to you that it satisfies the original axioms, just once.

973
00:55:55,210 --> 00:55:58,290
And then we're going to do some playing of games.

974
00:55:58,290 --> 00:56:09,695
Consider the problem CAR of CONS of, say, 35 and 47.

975
00:56:09,695 --> 00:56:11,120
Well, what is that?

976
00:56:11,120 --> 00:56:19,710
It is the result of taking car of the result of substituting 35 and 47 for X and Y in the body of this.

978
00:56:19,710 --> 00:56:20,690
Well, that's easy enough.

979
00:56:20,690 --> 00:56:35,750
That's CAR of the result of substituting into lambda of M, M of 35 and 47.

981
00:56:35,750 --> 00:56:42,830
Well, what this is, is the result of substituting this object for X in the body of that.

983
00:56:42,830 --> 00:57:15,840
So that's just lambda of M-- that's substituted, because this object is being substituted for X, which is the beginning of a list, lambda of M-- M of 35 and 47, applied to that procedure of A and D, which gives me A. Well, that's the result of substituting this for M here.

990
00:57:15,840 --> 00:57:26,026
So that's the same thing as lambda of A, D, A, applied to 35 and 47.

992
00:57:26,026 --> 00:57:27,560
Oh, well that's 35.

993
00:57:27,560 --> 00:57:40,720
That's substituting 35 for A and for 47 for D in A. So I don't need any data at all, not even numbers.

995
00:57:40,720 --> 00:57:42,640
This is Alonso Church's hack.

997
00:57:52,420 --> 00:57:56,760
Well, now we're going to do something nasty to him.

998
00:57:56,760 --> 00:57:58,860
Being a logician, he wouldn't like this.

999
00:57:58,860 --> 00:58:03,260
But as programmers, let's look at the overhead.

1000
00:58:03,260 --> 00:58:05,390
And here we go.

1001
00:58:05,390 --> 00:58:09,570
I'm going to change the definition of CONS.

1002
00:58:09,570 --> 00:58:14,520
It's almost the same as Alonzo Church's, but not quite.

1003
00:58:14,520 --> 00:58:16,070
What do we have here?

1004
00:58:16,070 --> 00:58:40,940
The CONS of two arguments, X and Y, is going to be that procedure of one argument M, which supplies M to X and Y as before, but also to two permissions, the permission to set X to N and the permission to set Y to N, given that I have an N.

1009
00:58:40,940 --> 00:59:03,365
So besides the things that I had here in Church's definition, what I have is that the thing that CONS returns will apply its argument to not just the values of the X and Y that the CONS is made of, but also permissions to set X and Y to new values.

1015
00:59:06,540 --> 00:59:11,690
Now, of course, just as before, CAR is exactly the same.

1017
00:59:11,690 --> 00:59:22,550
The CAR of X is nothing more than applying X, as in Church's definition, to a procedure, in this case, of four arguments, which selects out the first one.

1020
00:59:22,550 --> 00:59:37,920
And just as we did before, that will be the value of X that was contained in the procedure which is the result of evaluating this lambda expression in the environment where X and Y are defined over here.

1025
00:59:41,940 --> 00:59:45,640
That's the value of CONS.

1026
00:59:45,640 --> 00:59:47,730
Now, however, the exciting part.

1027
00:59:47,730 --> 00:59:48,960
CDR, of course, is the same.

1028
00:59:48,960 --> 00:59:55,800
The exciting part, set CAR and set CDR. Well, they're nothing very complicated anymore.

1030
00:59:55,800 --> 01:00:26,150
Set CAR of a CONS X to a new value Y is nothing more than applying that CONS, which is the procedure of four--the procedure of one argument which applies its argument to four things, to a procedure which is of four arguments-- the value of X, the value of Y, permission to set X, the permission to set Y-- and using it--using that permission to set X to the new value.

1039
01:00:31,650 --> 01:00:33,540
And similarly, set-cdr is the same thing.

1041
01:00:36,120 --> 01:00:40,470
So what you've just seen is that I didn't introduce any new primitives at all.

1043
01:00:40,470 --> 01:00:45,340
Whether or not I want to implement it this way is a matter of engineering.

1045
01:00:45,340 --> 01:00:51,680
And the answer is of course I don't implement it this way for reasons that have to do with engineering.

1047
01:00:51,680 --> 01:00:58,765
However in principle, logically, once I introduced one assignment operator, I've assigned--I've introduced them all.

1051
01:01:05,420 --> 01:01:06,670
Are there any questions?

1053
01:01:09,200 --> 01:01:12,040
Yes, David.

1054
01:01:12,040 --> 01:01:15,740
AUDIENCE: I can follow you up until you get--I can follow all of that.

1056
01:01:15,740 --> 01:01:24,210
But when we bring in the permissions, defining CONS in terms of the lambda N, I don't follow where N gets passed.

1058
01:01:24,210 --> 01:01:25,100
PROFESSOR: Oh, I'm sorry.

1059
01:01:25,100 --> 01:01:26,340
I'll show you.

1060
01:01:26,340 --> 01:01:27,360
Let's follow it.

1061
01:01:27,360 --> 01:01:29,180
Of course, we could do it on the blackboard.

1062
01:01:29,180 --> 01:01:30,170
It's not so hard.

1063
01:01:30,170 --> 01:01:32,450
But it's also easy here.

1064
01:01:32,450 --> 01:01:38,520
Supposing I wish to set-cdr of X to Y. See that right there.

1065
01:01:38,520 --> 01:01:46,890
set-cdr of X to Y. X is presumably a CONS, a thing resulting from evaluating CONS.

1067
01:01:46,890 --> 01:01:58,110
Therefore X comes from a place over here, that that X is of the result of evaluating this lambda expression.

1069
01:01:58,110 --> 01:01:59,380
Right?

1070
01:01:59,380 --> 01:02:08,950
That when I evaluated that lambda expression, I evaluated it in an environment where the arguments to CONS were defined.

1074
01:02:11,750 --> 01:02:29,250
That means that as free variables in this lambda expression, there is the--there are in the frame, which is the parent frame of this lambda expression, the procedure resulting from this lambda expression, X and Y have places.

1079
01:02:29,250 --> 01:02:31,910
And it's possible to set them.

1080
01:02:31,910 --> 01:02:37,010
I set them to an N, which is the argument of the permission.

1082
01:02:37,010 --> 01:02:47,940
The permission is a procedure which is passed to M, which is the argument that the CONS object gets passed.

1084
01:02:47,940 --> 01:02:57,480
Now, let's go back here in the set-cdr The CONS object, which is the first argument of set-cdr gets passed an argument.

1088
01:03:00,260 --> 01:03:07,920
That--there's a procedure of four things, indeed, because that's the same thing as this M over here, which is applied to four objects.

1091
01:03:07,920 --> 01:03:12,970
The object over here, SD, is, in fact, this permission.

1093
01:03:15,470 --> 01:03:19,930
When I use SD, I apply it to Y, right there.

1095
01:03:22,910 --> 01:03:25,740
So that comes from this.

1096
01:03:25,740 --> 01:03:34,160
AUDIENCE: So what do you-- PROFESSOR: So to finish that, the N that was here is the Y which is here.

1099
01:03:34,160 --> 01:03:34,810
How's that?

1100
01:03:34,810 --> 01:03:35,750
AUDIENCE: Right, OK.

1101
01:03:35,750 --> 01:03:41,970
Now, when you do a set-cdr, X is the value the CDR is going to become.

1103
01:03:41,970 --> 01:03:44,742
PROFESSOR: The X over here.

1104
01:03:44,742 --> 01:03:46,200
I'm sorry, that's not true.

1105
01:03:46,200 --> 01:03:56,150
The X is--set-cdr has two arguments-- The CONS I'm changing and the value I'm changing it to.

1107
01:03:56,150 --> 01:03:58,320
So you have them backwards, that's all.

1109
01:04:01,750 --> 01:04:03,000
Are there any other questions?

1111
01:04:07,880 --> 01:04:08,640
Well, thank you.

1112
01:04:08,640 --> 01:04:09,890
It's time for lunch.

