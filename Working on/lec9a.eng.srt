1
00:00:02,190 --> 00:00:03,800
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

4
00:00:17,260 --> 00:00:49,900
PROFESSOR: Well, up 'til now, I suppose, we've been learning about a lot of techniques for organizing big programs, symbolic manipulation a bit, some of the technology that you use for establishing languages, one in terms of another, which is used for organizing very large programs. In fact, the nicest programs I know look more like a pile of languages than like a decomposition of a problem into parts.

12
00:00:49,900 --> 00:00:56,260
Well, I suppose at this point, there are still, however, a few mysteries about how this sort of stuff works.

14
00:00:56,260 --> 00:01:12,196
And so what we'd like to do now is diverge from the plan of telling you how to organize big programs, and rather tell you something about the mechanisms by which these things can be made to work.

18
00:01:12,196 --> 00:01:32,430
The main reason for this is demystification, if you will, that we have a lot of mysteries left, like exactly how it is the case that a program is controlled, how a computer knows what the next thing to do is, or something like that.

23
00:01:32,430 --> 00:01:47,650
And what I'd like to do now is make that clear to you, that even if you've never played with a physical computer before, the mechanism is really very simple, and that you can understand it completely with no trouble.

27
00:01:47,650 --> 00:02:02,160
So I'd like to start by imagining that we-- well, the way we're going to do this, by the way, is we're going to take some very simple Lisp programs, very simple Lisp programs, and transform them into hardware.

31
00:02:02,160 --> 00:02:12,750
I'm not going to worry about some intermediate step of going through some existing computer machine language and then showing you how that computer works, because that's not as illuminating.

35
00:02:12,750 --> 00:02:22,040
So what I'm really going to show you is how a piece of machinery can be built to do a job that you have written down as a program.

38
00:02:22,040 --> 00:02:25,760
That program is, in fact, a description of a machine.

39
00:02:25,760 --> 00:02:41,230
We're going to start with a very simple program, proceed to show you some simple mechanisms, proceed to a few more complicated programs, and then later show you a not very complicated program, how the evaluator transforms into a piece of hardware.

44
00:02:41,230 --> 00:02:48,800
And of course at that point, you have made the universal transition and can execute any program imaginable with a piece of well-defined hardware.

48
00:02:51,392 --> 00:02:55,440
Well, let's start up now, give you a real concrete feeling for this sort of thing.

50
00:02:55,440 --> 00:02:59,600
Let's start with a very simple program.

51
00:02:59,600 --> 00:03:00,850
Here's Euclid's algorithm.

53
00:03:03,880 --> 00:03:06,770
It's actually a little bit more modern than Euclid's algorithm.

55
00:03:06,770 --> 00:03:14,300
Euclid's algorithm for computing the greatest common divisor of two numbers was invented 350 BC, I think.

57
00:03:14,300 --> 00:03:15,550
It's the oldest known algorithm.

59
00:03:19,320 --> 00:03:29,500
But here we're going to talk about GCD of A and B, the Greatest Common Divisor or two numbers, A and B. And the algorithm is extremely simple.

62
00:03:29,500 --> 00:03:58,530
If B is 0, then the result is going to be A. Otherwise, the result is the GCD of B and the remainder when A is divided by B.

65
00:03:58,530 --> 00:04:02,030
So this we have here is a very simple iterative process.

66
00:04:02,030 --> 00:04:09,990
This a simple recursive procedure, recursively defined procedure, recursive definition, which yields an iterative process.

69
00:04:09,990 --> 00:04:15,996
And the way it works is that every step, it determines whether B was zero.

71
00:04:15,996 --> 00:04:31,110
And if B is 0, we got the answer in A. Otherwise, we make another step where A is the old B, and B is the remainder of the old A divided by the old B. Very simple.

74
00:04:31,110 --> 00:04:34,860
Now this, I've already told you some of the mechanism by just saying it that way.

76
00:04:34,860 --> 00:04:36,360
I set it in time.

77
00:04:36,360 --> 00:04:49,490
I said there are certain steps, and that, in fact, one of the things you can see here is that one of the reasons why this is iterative is nothing is needed of the last step to get the answer.

81
00:04:49,490 --> 00:04:57,540
All of the information that's needed to run this algorithm is in A and B. It has two well-defined state variables.

84
00:05:00,470 --> 00:05:06,560
So I'm going to define a machine for you that can compute you GCDs.

86
00:05:06,560 --> 00:05:07,120
Now let's see.

87
00:05:07,120 --> 00:05:17,840
Every computer that's ever been made that's a single-process computer, as opposed to a multiprocessor of some sort, is made according to the same plan.

90
00:05:17,840 --> 00:05:25,910
The plan is the computer has two parts, a part called the datapaths, and a part called the controller.

92
00:05:25,910 --> 00:05:33,560
The datapaths correspond to a calculator that you might have. It contains certain registers that remember things, and you've all used calculators.

95
00:05:33,560 --> 00:05:37,030
It has some buttons on it and some lights.

96
00:05:37,030 --> 00:05:45,160
And so by pushing the various buttons, you can cause operations to happen inside there among the registers, and some of the results to be displayed.

99
00:05:45,160 --> 00:05:46,250
That's completely mechanical.

100
00:05:46,250 --> 00:05:50,900
You could imagine that box has no intelligence in it.

101
00:05:50,900 --> 00:05:58,970
Now it might be very impressive that it can produce the sine of a number, but that at least is apparently possibly mechanical.

104
00:05:58,970 --> 00:06:02,690
At least, I could open that up in the same way I'm about to open GCD.

106
00:06:02,690 --> 00:06:05,940
So this may have a whole computer inside of it, but that's not interesting.

108
00:06:05,940 --> 00:06:08,200
Addition is certainly simple.

109
00:06:08,200 --> 00:06:10,890
That can be done without any further mechanism.

110
00:06:10,890 --> 00:06:18,190
Now also, if we were to look at the other half, the controller, that's a part that's dumb, too.

112
00:06:18,190 --> 00:06:20,350
It pushes the buttons.

113
00:06:20,350 --> 00:06:26,290
It pushes them according to the sequence, which is written down on a piece of paper, and observes the lights.

115
00:06:26,290 --> 00:06:32,370
And every so often, it comes to a place in a sequence that says, if light A is on, do this sequence.

117
00:06:32,370 --> 00:06:34,620
Otherwise, do that sequence.

118
00:06:34,620 --> 00:06:37,950
And thereby, there's no complexity there either.

119
00:06:37,950 --> 00:06:42,510
Well, let's just draw that and see what we feel about that.

120
00:06:42,510 --> 00:06:50,310
So for computing GCDs, what I want you to think about is that there are these registers.

122
00:06:50,310 --> 00:06:53,240
A register is a place where I store a number, in this case.

123
00:06:53,240 --> 00:06:56,810
And this one's called a.

124
00:06:56,810 --> 00:06:58,700
And then there's another one for storing b.

126
00:07:03,170 --> 00:07:09,840
Now we have to see what things we can do with these registers, and they're not entirely obvious what you can do with them.

129
00:07:09,840 --> 00:07:11,890
Well, we have to see what things we need to do with them.

131
00:07:11,890 --> 00:07:14,030
We're looking at the problem we're trying to solve.

132
00:07:14,030 --> 00:07:32,140
One of the important things for designing a computer, which I think most designers don't do, is you study the problem you want to solve and then use what you learn from studying the problem you want to solve to put in the mechanisms needed to solve it in the computer you're building, no more no less.

138
00:07:32,140 --> 00:07:40,190
Now it may be that the problem you're trying to solve is everybody's problem, in which case you have to build in a universal interpreter of some language.

141
00:07:40,190 --> 00:07:44,540
But you shouldn't put any more in than required to build the universal interpreter of some language.

143
00:07:44,540 --> 00:07:47,025
We'll worry about that in a second.

144
00:07:47,025 --> 00:07:49,930
OK, going back to here, let's see.

145
00:07:49,930 --> 00:07:51,640
What do we have to be able to do?

146
00:07:51,640 --> 00:08:07,390
Well, somehow, we have to be able to get B into A. We have to be able to get the old value of B into the value of A. So we have to have some path by which stuff can flow, whatever this information is, from b to a.

150
00:08:07,390 --> 00:08:15,120
I'm going to draw that with by an arrow saying that it is possible to move the contents of b into a, replacing the value of a.

153
00:08:15,120 --> 00:08:19,710
And there's a little button here which you push which allows that to happen.

155
00:08:19,710 --> 00:08:23,070
That's what the little x is here.

156
00:08:23,070 --> 00:08:27,000
Now it's also the case that I have to be able to compute the remainder of a and b.

158
00:08:27,000 --> 00:08:28,860
Now that may be a complicated mess.

159
00:08:28,860 --> 00:08:31,960
On the other hand, I'm going to make it a small box.

160
00:08:31,960 --> 00:08:37,740
If we have to, we may open up that box and look inside and see what it is.

162
00:08:37,740 --> 00:08:46,440
So here, I'm going to have a little box, which I'm going to draw this way, which we'll call the remainder.

164
00:08:46,440 --> 00:08:48,265
And it's going to take in a.

166
00:08:50,910 --> 00:08:54,370
That's going to take in b.

167
00:08:54,370 --> 00:09:02,290
And it's going to put out something, the remainder of a divided by b.

169
00:09:02,290 --> 00:09:08,000
Another thing we have to see here is that we have to be able to test whether b is equal to 0.

171
00:09:08,000 --> 00:09:13,390
Well, that means somebody's got to be looking at-- a thing that's looking at the value of b.

173
00:09:13,390 --> 00:09:17,390
I have a light bulb here which lights up if b equals 0.

175
00:09:21,110 --> 00:09:24,030
That's its job.

176
00:09:24,030 --> 00:09:46,300
And finally, I suppose, because of the fact that we want the new value of a to be the old value of b, and simultaneously the new value of b to be something I've done with a, and if I plan to make my machine such that everything happens one at a time, one motion at a time, and I can't put two numbers in a register, then I have to have another place to put one while I'm interchanging.

184
00:09:49,534 --> 00:09:50,000
OK?

185
00:09:50,000 --> 00:10:08,850
I can't interchange the two things in my hands, unless I either put two in one hand and then pull it back the other way, or unless I put one down, pick it up, and put the other one, like that, unless I'm a juggler, which I'm not, as you can see, in which case I have a possibility of timing errors.

191
00:10:08,850 --> 00:10:17,840
In fact, much of the type of computer design people do involves timing errors, of some potential timing errors, which I don't much like.

194
00:10:17,840 --> 00:10:23,410
So for that reason, I have to have a place to put the second one of them down.

196
00:10:23,410 --> 00:10:30,470
So I have a place called t, which is a register just for temporary, t, with a button on it.

198
00:10:30,470 --> 00:10:39,300
And then I'll take the result of that, since I have to take that and put into b, over here, we'll take the result of that and go like this, and a button here.

202
00:10:42,430 --> 00:10:47,600
So that's the datapaths of a GCD machine.

203
00:10:47,600 --> 00:10:49,740
Now what's the controller?

204
00:10:49,740 --> 00:10:52,280
Controller's a very simple thing, too.

205
00:10:52,280 --> 00:10:53,710
The machine has a state.

206
00:10:53,710 --> 00:10:59,010
The way I like to visualize that is that I've got a maze.

207
00:10:59,010 --> 00:11:04,430
And the maze has a bunch of places connected by directed arrows.

209
00:11:04,430 --> 00:11:10,740
And what I have is a marble, which represents the state of the controller.

211
00:11:10,740 --> 00:11:13,256
The marble rolls around in the maze.

212
00:11:13,256 --> 00:11:17,150
Of course, this analogy breaks down for energy reasons.

213
00:11:17,150 --> 00:11:22,000
I sometimes have to pump the marble up to the top, because it's going to otherwise be a perpetual motion machine.

215
00:11:22,000 --> 00:11:26,080
But not worrying about that, this is not a physical analogy.

217
00:11:26,080 --> 00:11:27,680
This marble rolls around.

218
00:11:27,680 --> 00:11:34,830
And every time it rolls around certain bumpers, like in a pinball machine, it pushes one of these buttons.

220
00:11:34,830 --> 00:11:40,250
And every so often, it comes to a place, which is a division, where it has to make a choice.

222
00:11:40,250 --> 00:11:42,360
And there's a flap, which is controlled by this.

224
00:11:46,000 --> 00:11:48,820
So that's a really mechanical way of thinking about it.

225
00:11:48,820 --> 00:11:51,840
Of course, controllers these days, are not built that way in real computers.

227
00:11:51,840 --> 00:11:56,610
They're built with a little bit of ROM and a state register.

229
00:11:56,610 --> 00:12:01,400
But there was a time, like the DEC PDP-6, where that's how you built the controller of a machine.

231
00:12:01,400 --> 00:12:08,580
There was a bit that ran around the delay line, and it triggered things as it went by.

233
00:12:08,580 --> 00:12:11,990
And it would come back to the beginning and get fed round again.

235
00:12:11,990 --> 00:12:17,670
And of course, there were all sorts of great bugs you could have like two bits going around, two marbles.

237
00:12:17,670 --> 00:12:19,260
And then the machine has lost its marbles.

238
00:12:19,260 --> 00:12:20,980
That happens, too.

239
00:12:20,980 --> 00:12:21,935
Oh, well.

240
00:12:21,935 --> 00:12:25,940
So anyway, for this machine, what I have to do is the following.

242
00:12:25,940 --> 00:12:27,690
I'm going to start my maze here.

244
00:12:30,520 --> 00:12:41,540
And the first thing I've got to do, in a notation which many of you are familiar with, is b equal to zero, a test.

246
00:12:41,540 --> 00:12:45,790
And there's a possibility, either yes, in which case I'm done.

249
00:12:49,790 --> 00:12:54,725
Otherwise, if no, then I'm going have to roll over some bumpers.

251
00:12:54,725 --> 00:12:57,420
I'm going to do it in the following order.

252
00:12:57,420 --> 00:13:04,050
I want to do this interchange game.

253
00:13:04,050 --> 00:13:11,070
Now first, since I need both a and b, but then the first-- and this is not necessary-- I want to collect this.

256
00:13:11,070 --> 00:13:13,240
This is the thing that's going to go into b.

257
00:13:13,240 --> 00:13:19,150
So I'm going to say, take this, which depends upon both a and b, and put the remainder into here.

259
00:13:19,150 --> 00:13:32,030
So I'm going to push this button first. Then, I'm going to transfer b to a, push that button, and then I transfer the temporary into b, push that button.

262
00:13:32,030 --> 00:13:37,750
So a very sequential machine, it's very inefficient.

263
00:13:37,750 --> 00:13:39,810
But that's fine right now.

264
00:13:39,810 --> 00:13:42,305
We're going to name the buttons, t gets remainder.

266
00:13:46,750 --> 00:13:50,036
a gets b.

267
00:13:50,036 --> 00:13:55,470
And b gets t.

268
00:13:55,470 --> 00:14:01,620
And then I'm going to go around here and it's to go back to start.

270
00:14:01,620 --> 00:14:03,870
And if you look, what are we seeing here?

271
00:14:03,870 --> 00:14:13,620
We're seeing the various-- what I really have is some sort of mechanical connection, where t gets r controls this thing.

275
00:14:16,830 --> 00:14:28,120
And I have here that a gets b controls this fellow over here, and this fellow over here.

277
00:14:28,120 --> 00:14:32,630
Boy, that's absolutely pessimal, the inverse of optimal.

279
00:14:32,630 --> 00:14:34,590
Every line heads across every other line the way I drew it.

281
00:14:38,540 --> 00:14:41,150
I suppose this goes here, b gets t.

283
00:14:45,690 --> 00:14:48,040
Now I'd like to run this machine.

284
00:14:48,040 --> 00:15:00,710
But before I run the machine, I want to write down a description of this controller, just so you can see that these things, of course, as usual, can be written down in some nice language, so that we don't have to always draw these diagrams. One of the problems with diagrams is that they take up a lot of space.

290
00:15:00,710 --> 00:15:03,220
And for a machine this small, it takes two blackboards.

291
00:15:03,220 --> 00:15:09,900
For a machine that's the evaluator machine, I have trouble putting it into this room, even though it isn't very big.

294
00:15:09,900 --> 00:15:24,420
So I'm going to make a little language for this that's just a description of that, saying define a machine we'll call GCD.

297
00:15:24,420 --> 00:15:27,220
Of course, once we have something like this, we have a simulator for it.

299
00:15:27,220 --> 00:15:33,210
And the reason why we want to build a language in this form, is because all of a sudden we can manipulate these expressions that I'm writing down.

302
00:15:33,210 --> 00:15:43,630
And then of course I can write things that can algebraically manipulate these things, simulate them, all that sort of things that I might want to do, perhaps transform them as a layout, who knows.

306
00:15:43,630 --> 00:15:56,326
Once I have a nice representation of registers, it has certain registers, which we can call A, B, and T.

308
00:15:56,326 --> 00:15:57,576
And there's a controller.

310
00:16:02,190 --> 00:16:10,420
Actually, a better language, which would be more explicit, would be one which named every button also and said what it did.

313
00:16:10,420 --> 00:16:19,510
Like, this button causes the contents of T to go to the contents of B. Well I don't want to do that, because it's actually harder to read to do that, and it takes up more space.

317
00:16:19,510 --> 00:16:23,290
So I'm going to have that in the instructions written in the controller.

319
00:16:23,290 --> 00:16:26,460
It's going to be implicit what the operations are.

320
00:16:26,460 --> 00:16:33,500
They can be deduced by reading these and collecting together all the different things that can be done.

322
00:16:33,500 --> 00:16:35,482
Well, let's just look at what these things are.

323
00:16:35,482 --> 00:17:03,640
There's a little loop that we go around which says branch, this is the representation of the little flap that decides which way you go here, if 0 fetch of B, the contents of B, and if the contents of B is 0, then go to a place called done.

328
00:17:03,640 --> 00:17:08,170
Now, one thing you're seeing here, this looks very much like a traditional computer language.

330
00:17:08,170 --> 00:17:17,609
And what you're seeing here is things like labels that represent places in a sequence written down as a sequence.

332
00:17:17,609 --> 00:17:23,329
The reason why they're needed is because over here, I've written something with loops.

334
00:17:23,329 --> 00:17:28,580
But if I'm writing English text, or something like that, it's hard to refer to a place.

336
00:17:28,580 --> 00:17:31,440
I don't have arrows.

337
00:17:31,440 --> 00:17:37,620
Arrows are represented by giving names to the places where the arrows terminate, and then referring to them by those names.

340
00:17:37,620 --> 00:17:39,860
Now this is just an encoding.

341
00:17:39,860 --> 00:17:43,150
There's nothing magical about things like that.

342
00:17:43,150 --> 00:17:46,840
Next thing we're going to do is we're going to say, how do we do T gets R?

344
00:17:46,840 --> 00:17:49,030
Oh, that's easy enough, assign.

346
00:17:51,930 --> 00:17:56,400
We assign to T the remainder.

347
00:17:56,400 --> 00:18:01,470
Assign is the name of the button.

348
00:18:01,470 --> 00:18:03,140
That's the button-pusher.

349
00:18:03,140 --> 00:18:23,478
Assign to T the remainder, and here's the representation of the operation, when we divide the fetch of A by the fetch of B.

352
00:18:23,478 --> 00:18:53,280
And we're also going to assign to A the fetch of B, assign to B the result of getting the contents of T. And now I have to refer to the beginning here.

355
00:18:53,280 --> 00:18:55,760
I see, why don't I call that loop like I have here?

357
00:19:05,390 --> 00:19:07,610
So that's that reference to that arrow.

358
00:19:07,610 --> 00:19:08,950
And when we're done, we're done.

359
00:19:08,950 --> 00:19:14,340
We go to here, which is the end of the thing.

360
00:19:14,340 --> 00:19:21,660
So here's just a written representation of this fragment of machinery that we've drawn here.

362
00:19:21,660 --> 00:19:25,490
Now the next thing I'd like to do is run this.

363
00:19:25,490 --> 00:19:27,620
I want us to feel it running.

364
00:19:27,620 --> 00:19:31,010
Never done this before, you got to do it once.

365
00:19:31,010 --> 00:19:33,100
So let's take a particular problem.

366
00:19:33,100 --> 00:19:42,210
Suppose we want to compute the GCD of a equals 30 and b equals 42.

368
00:19:42,210 --> 00:19:45,860
I have no idea what that is right now.

369
00:19:45,860 --> 00:19:50,530
But a 30 and b is 42.

370
00:19:50,530 --> 00:19:52,410
So that's how I start this thing up.

371
00:19:52,410 --> 00:19:54,240
Well, what's the first thing I do?

372
00:19:54,240 --> 00:19:57,590
I say is B equal to 0, no.

373
00:19:57,590 --> 00:20:11,130
Then assign to T the remainder of the fetch of A and the fetch of B. Well the remainder of 30 when divided by 42 is itself 30.

376
00:20:11,130 --> 00:20:12,920
Push that button.

377
00:20:12,920 --> 00:20:17,100
Now the marble has rolled to here.

378
00:20:17,100 --> 00:20:21,220
A gets B. That pushes this button.

379
00:20:21,220 --> 00:20:26,360
So 42 moves into here.

380
00:20:26,360 --> 00:20:29,870
B gets C. Push that button.

381
00:20:29,870 --> 00:20:32,225
The 30 goes here.

382
00:20:32,225 --> 00:20:34,660
Let met just interchange them.

383
00:20:34,660 --> 00:20:38,280
Now let's see, go back to the beginning.

384
00:20:38,280 --> 00:20:40,200
B 0, no.

385
00:20:40,200 --> 00:20:43,230
T gets the remainder.

386
00:20:43,230 --> 00:20:47,240
I suppose the remainder when dividing 42 by 30 is 12.

387
00:20:47,240 --> 00:20:48,530
I push that one.

388
00:20:48,530 --> 00:20:55,950
Next thing I do is allow the 30 to go to here, push this one, allow the 12 to go to here.

391
00:20:59,550 --> 00:21:00,380
Go around this thing.

392
00:21:00,380 --> 00:21:01,530
Is that done?

393
00:21:01,530 --> 00:21:02,360
No.

394
00:21:02,360 --> 00:21:08,850
How about-- so now I have to find out the remainder of 30 divided by 12.

396
00:21:08,850 --> 00:21:12,420
And I believe that's 6.

397
00:21:12,420 --> 00:21:15,916
So 6 goes here on this button push.

398
00:21:15,916 --> 00:21:23,730
Then the next thing I push is this one, which the 12 goes into here.

400
00:21:23,730 --> 00:21:25,090
Then I push this button.

401
00:21:25,090 --> 00:21:26,340
The 6 gets into here.

403
00:21:29,850 --> 00:21:32,100
Is 6 equal to 0?

404
00:21:32,100 --> 00:21:33,420
No.

405
00:21:33,420 --> 00:21:34,380
OK.

406
00:21:34,380 --> 00:21:38,380
So then at that point, the next thing to do is divide it.

407
00:21:38,380 --> 00:21:40,660
Ooh, this has got a remainder of 0.

408
00:21:40,660 --> 00:21:42,360
Looks like we're almost done.

409
00:21:42,360 --> 00:21:44,360
Move the 6 over here next.

411
00:21:47,230 --> 00:21:49,090
0 over here.

412
00:21:49,090 --> 00:21:50,200
Is the answer 0?

413
00:21:50,200 --> 00:21:51,340
Yes.

414
00:21:51,340 --> 00:21:54,470
B is 0, therefore the answer is in A.

415
00:21:54,470 --> 00:21:56,610
The answer is 6.

416
00:21:56,610 --> 00:22:11,670
And indeed that's right, because if we look at the original problem, what we have is 30 is 2 times 3 times 5, and 42 is 2 times 3 times 7.

419
00:22:11,670 --> 00:22:15,090
So the greatest common divisor is 2 times 3, which is 6.

421
00:22:18,380 --> 00:22:31,010
Now normally, we write one other little line here, just to make it a little bit clearer, which is that we leave in a connection saying that this light is the guy that that flap looks at.

426
00:22:34,050 --> 00:22:41,350
Of course, any real machine has a lot more complicated things in it than what I've just shown you.

428
00:22:41,350 --> 00:22:47,980
Let's look for a second at the first still store.

429
00:22:47,980 --> 00:22:50,190
Wow.

430
00:22:50,190 --> 00:22:56,840
Well you see, for example, one thing we might want to do is worry about the operations that are of IO form.

432
00:22:56,840 --> 00:23:01,980
And we may have to collect something from the outside.

433
00:23:01,980 --> 00:23:13,490
So a state machine that we might have, the controller may have to, for example, get a value from something and put register a to load it up.

436
00:23:13,490 --> 00:23:17,070
I have to master load up register b with another value.

437
00:23:17,070 --> 00:23:20,970
And then later, when I'm done, I might want to print the answer out.

439
00:23:20,970 --> 00:23:26,250
And of course, that might be either simple or complicated.

440
00:23:26,250 --> 00:23:29,880
I'm writing, assuming print is very simple, and read is very simple.

442
00:23:29,880 --> 00:23:38,330
But in fact, in the real world, those are very complicated operations, usually much, much larger and more complicated than the thing you're doing as your problem you're trying to solve.

447
00:23:41,670 --> 00:23:59,065
On the other hand, I can remember a time when, I remember using IBM 7090 computer of sorts, where things like read and write of a single object, a single number, a number, is a primitive operation of the IO controller.

452
00:23:59,065 --> 00:24:00,400
OK?

453
00:24:00,400 --> 00:24:02,330
And so we have that kind of thing in there.

454
00:24:02,330 --> 00:24:08,360
And in such a machine, well, what are we really doing?

455
00:24:08,360 --> 00:24:14,660
We're just saying that there's a source over here called "read," which is an operation which always has a value.

457
00:24:14,660 --> 00:24:21,660
We have to think about this as always having a value which can be gated into either register a or b.

459
00:24:21,660 --> 00:24:31,660
And print is some sort of thing which when you gate it appropriately, when you push the button on it, will cause a print of the value that's currently in register a.

462
00:24:31,660 --> 00:24:33,050
Nothing very exciting.

463
00:24:33,050 --> 00:24:38,320
So that's one sort of thing you might want to have. But these are also other things that are a little bit worrisome.

466
00:24:38,320 --> 00:24:41,050
Like I've used here some complicated mechanisms.

467
00:24:41,050 --> 00:24:43,850
What you see here is remainder.

468
00:24:43,850 --> 00:24:44,690
What is that?

469
00:24:44,690 --> 00:24:46,920
That may not be so obvious how to compute.

470
00:24:46,920 --> 00:24:51,880
It may be something which when you open it up, you get a whole machine.

472
00:24:51,880 --> 00:24:52,720
OK?

473
00:24:52,720 --> 00:24:54,540
In fact, that's true.

474
00:24:54,540 --> 00:25:04,480
For example, if I write down the program for remainder, the simplest program for it is by repeated subtraction.

476
00:25:04,480 --> 00:25:09,800
Because of course, division can be done by repeated subtraction of numbers, of integers.

478
00:25:09,800 --> 00:25:56,890
So the remainder of N divided by D is nothing more than if N is less than D, then the result is N. Otherwise, it's the remainder when we subtract D from N with respect to D, when divided by D. Gee, this looks just like the GCD program.

483
00:25:56,890 --> 00:25:59,750
Of course, it's not a very nice way to do remainders.

484
00:25:59,750 --> 00:26:05,550
You'd really want to use something like binary notation and shift and things like that in a practical computer.

486
00:26:05,550 --> 00:26:11,880
But the point of that is that if I open this thing up, I might find inside of it a computer.

488
00:26:11,880 --> 00:26:13,510
Oh, we know how to do that.

489
00:26:13,510 --> 00:26:15,640
We just made one.

490
00:26:15,640 --> 00:26:17,400
And it could be another thing just like this.

491
00:26:17,400 --> 00:26:29,250
On the other hand, we might want to make a more efficient or better-structured machine, or maybe make use of some of the registers more than once, or some horrible mess like that that hardware designers like to do, and for very good reasons.

496
00:26:29,250 --> 00:26:35,050
So for example, here's a machine that you see, which you're not supposed to be able to read.

498
00:26:35,050 --> 00:26:37,520
It's a little bit complicated.

499
00:26:37,520 --> 00:26:44,210
But what it is is the integration of the remainder into the GCD machine.

501
00:26:44,210 --> 00:26:46,020
And it takes, in fact, no more registers.

502
00:26:46,020 --> 00:26:48,360
There are three registers in the datapaths.

503
00:26:48,360 --> 00:26:49,050
OK?

504
00:26:49,050 --> 00:26:51,550
But now there's a subtractor.

505
00:26:51,550 --> 00:26:53,020
There are two things that are tested.

506
00:26:53,020 --> 00:26:57,250
Is b equal to 0, or is t less than b?

507
00:26:57,250 --> 00:27:01,850
And then the controller, which you see over here, is not much more complicated.

509
00:27:01,850 --> 00:27:14,030
But it has two loops in it, one of which is the main one for doing the GCD, and one of which is the subtraction loop for doing the remainder sub-operation.

512
00:27:14,030 --> 00:27:19,920
And there are ways, of course, of, if you think about it, taking the remainder program.

514
00:27:19,920 --> 00:27:36,630
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

519
00:27:36,630 --> 00:27:45,950
And I can get this piece of machinery by basically, a little bit of algebraic simplification on the lambda expressions.

523
00:27:48,550 --> 00:27:52,280
So I suppose you've seen your first very simple machines now.

525
00:27:52,280 --> 00:27:53,530
Are there any questions?

527
00:28:02,700 --> 00:28:05,360
Good.

528
00:28:05,360 --> 00:28:06,610
This looks easy, doesn't it?

530
00:28:10,200 --> 00:28:10,550
Thank you.

531
00:28:10,550 --> 00:28:11,350
I suppose, take a break.

532
00:28:11,350 --> 00:28:13,010
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

535
00:28:47,310 --> 00:28:49,480
PROFESSOR: Well, let's see.

536
00:28:49,480 --> 00:28:57,770
Now you know how to make an iterative procedure, or a procedure that yields an iterative process, turn into a machine.

539
00:28:57,770 --> 00:29:02,690
I suppose the next thing we want to do is worry about things that reveal recursive processes.

541
00:29:02,690 --> 00:29:04,695
So let's play with a simple factorial procedure.

543
00:29:10,894 --> 00:29:33,940
We define factorial of N to be if n is 1, the result is 1, using 1 right now to decrease the amount of work I have to do to simulate it, else it's times N factorial N minus 1.

547
00:29:42,520 --> 00:29:52,260
And what's different with this program, as you know, is that after I've computed factorial of N minus 1 here, I have to do something to the result.

550
00:29:52,260 --> 00:29:56,000
I have to multiply it by N.

551
00:29:56,000 --> 00:30:09,320
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

556
00:30:09,320 --> 00:30:16,800
But this machine, the outer machine, has to exist before and after the factorial machine, which is inside.

558
00:30:16,800 --> 00:30:28,640
Whereas in the iterative case, the outer machine doesn't need to exist after the inner machine is running, because you never need to go back to the outer machine to do anything.

562
00:30:28,640 --> 00:30:35,340
So here we have a problem where we have a machine which has the same machine inside of it, an infinitely large machine.

566
00:30:40,390 --> 00:30:50,690
And it's got other things inside of it, like a multiplier, which takes some inputs, and there's a minus 1 box, and things like that.

569
00:30:50,690 --> 00:30:54,370
You can imagine that's what it looks like.

570
00:30:54,370 --> 00:31:02,540
But the important thing is that here I have something that happens before and after, in the outer machine, the execution of the inner machine.

573
00:31:02,540 --> 00:31:05,570
So this machine has to have a life.

574
00:31:05,570 --> 00:31:13,490
It has to exist on both times sides of this machine.

575
00:31:13,490 --> 00:31:20,030
So somehow, I have to have a place to store the things that this thing needs to run.

577
00:31:20,030 --> 00:31:24,140
Infinite objects don't exist in the real world.

578
00:31:24,140 --> 00:31:31,830
What we have to do is arrange an illusion that we have an infinite object, we have an infinite amount of hardware somewhere.

581
00:31:31,830 --> 00:31:36,280
Now of course, illusion's all that really matters.

582
00:31:36,280 --> 00:31:47,390
If we can arrange that every time you look at some infinite object, the part of it that you look at is there, then it's as infinite as you need it to be.

585
00:31:47,390 --> 00:32:09,170
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

590
00:32:09,170 --> 00:32:13,080
We have some datapaths, which consist of registers and operators.

592
00:32:13,080 --> 00:32:24,230
And what I propose to do here is decompose the machine into two parts, such that there is a part which is fundamentally finite, and some part where a certain amount of infinite stuff can be kept.

596
00:32:24,230 --> 00:32:29,430
On the other hand this is very simple and really isn't infinite, but it's just very large.

598
00:32:29,430 --> 00:32:48,340
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

604
00:32:48,340 --> 00:33:01,650
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

609
00:33:03,840 --> 00:33:11,390
So it will remember the important things about the life of the outer machine that will be needed for this computation.

612
00:33:11,390 --> 00:33:26,580
Since, of course, these machines are nested in a recursive manner, then in fact the stack will only be accessed in a manner which is the last thing that goes in is the first thing that comes out.

617
00:33:29,330 --> 00:33:34,930
So we'll only need to access some little part of this stack memory.

619
00:33:34,930 --> 00:33:36,810
OK, well, let's do it.

620
00:33:36,810 --> 00:33:40,370
I'm going to build you a datapath now, and I'm going to write the controller.

622
00:33:40,370 --> 00:33:43,510
And then we're going to execute this to see how you do it.

624
00:33:43,510 --> 00:33:47,900
So the factorial machine isn't so bad.

625
00:33:47,900 --> 00:34:04,165
It's going to have a register called the value, where the answer is going to be stored, and a registered called N, which is where the number I'm taking factorial will be stored, factorial of.

629
00:34:04,165 --> 00:34:11,760
And it will be necessary in some instances to connect VAL to N.

631
00:34:11,760 --> 00:34:19,139
In fact, one nice case of this is if I just said over here, N, because that would be right for N equal 1N.

633
00:34:19,139 --> 00:34:23,909
And I could just move the answer over there if that's important.

635
00:34:23,909 --> 00:34:26,980
I'm not worried about that right now.

636
00:34:26,980 --> 00:34:29,060
And there are things I have to be able to do.

637
00:34:29,060 --> 00:34:38,290
Like I have to be able to, as we see here, multiply N by something in VAL, because VAL is the result of computing factorial.

640
00:34:38,290 --> 00:34:41,429
And I have to put the result back into VAL.

641
00:34:41,429 --> 00:34:50,690
So here we can see that the result of computing a factorial is N times the result of computing a factorial.

644
00:34:50,690 --> 00:34:55,199
VAL will be the representation of the answer of the inner factorial.

646
00:34:55,199 --> 00:35:17,170
And so I'm going to have to have a multiplier here, which is going to sample the value of N and the value of VAL and put the result back into VAL like that.

649
00:35:17,170 --> 00:35:20,618
I'm also going to have to be able to see if N is 1.

650
00:35:20,618 --> 00:35:22,230
So I need a light bulb.

652
00:35:28,200 --> 00:35:46,620
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

655
00:35:46,620 --> 00:35:49,550
That's pretty much what I need in my machine.

656
00:35:49,550 --> 00:35:51,985
Now, there's a little bit else I need.

657
00:35:51,985 --> 00:36:06,250
It's a little bit more complicated, because I'm also going to need a way to store, to save away, the things that are going to be needed for resuming the computation of a factorial after I've done a sub-factorial.

661
00:36:06,250 --> 00:36:07,230
What's that?

662
00:36:07,230 --> 00:36:09,850
One thing I need is N.

663
00:36:09,850 --> 00:36:11,870
So I'm going to build here a thing called a stack.

665
00:36:14,700 --> 00:36:25,380
The stack is a bunch of stuff that I'm going to write in sequentially.

668
00:36:27,410 --> 00:36:28,916
I don't how long it is.

669
00:36:28,916 --> 00:36:32,890
The longer it is, the better my illusion of infinity.

670
00:36:32,890 --> 00:36:39,515
And I'm going to have to have a way of getting stuff out of N and into the stack and vice versa.

672
00:36:39,515 --> 00:36:55,820
So I'm going to need a connection like this, which is two-way, whereby I can save the value of N and then restore it some other time through that connection.

675
00:36:55,820 --> 00:36:58,100
This is the stack.

676
00:36:58,100 --> 00:37:08,530
I also need a way of remembering where I was in the computation of factorial in the outer program.

678
00:37:08,530 --> 00:37:14,090
Now in the case of this machine, it isn't very much a problem.

680
00:37:14,090 --> 00:37:25,660
Factorial always returns, has to go back to the place where we multiply by N, except for the last time, when it has to return to whatever needs the factorial or go to done or stop.

684
00:37:25,660 --> 00:37:31,770
However, in general, I'm going to have to remember where I have been, because I might have computed factorial from somewhere else.

687
00:37:31,770 --> 00:37:36,070
I have to go back to that place and continue there.

688
00:37:36,070 --> 00:37:47,400
So I'm going to have to have some way of taking the place where the marble is in the finite state controller, the state of the controller, and storing that in the stack as well.

692
00:37:47,400 --> 00:37:51,870
And I'm going to have to have ways of restoring that back to the state of the-- the marble.

694
00:37:51,870 --> 00:37:54,310
So I have to have something that moves the marble to the right place.

696
00:37:54,310 --> 00:37:57,462
Well, we're going to have a place which is the marble now.

697
00:37:57,462 --> 00:38:14,260
And it's called the continue register, called continue, which is the place to put the marble next time I go to continue.

700
00:38:14,260 --> 00:38:16,140
That's what that's for.

701
00:38:16,140 --> 00:38:19,240
And so there's got to be some path from that into the controller.

704
00:38:22,910 --> 00:38:29,074
I also have to have some way of saving that on the stack.

705
00:38:29,074 --> 00:38:36,860
And I have to have some way of setting that up to have various constants, a certain fixed number of constants.

707
00:38:36,860 --> 00:38:38,840
And that's very easy to arrange.

708
00:38:38,840 --> 00:38:40,180
So let's have some constants here.

709
00:38:40,180 --> 00:38:41,430
We'll call this one after-fact.

711
00:38:47,430 --> 00:38:54,010
And that's a constant which we'll get into the continue register, and also another one called fact-done.

714
00:39:05,210 --> 00:39:08,130
So this is the machine I want to build.

715
00:39:08,130 --> 00:39:17,300
That's its datapaths, at least. And it mixes a little with the controller here, because of the fact that I have to remember where I was and restore myself to that place.

719
00:39:17,300 --> 00:39:20,390
But let's write the program now which represents the controller.

721
00:39:20,390 --> 00:39:24,890
I'm not going to write the define machine thing and the register list, because that's not very interesting.

723
00:39:24,890 --> 00:39:30,920
I'm just going to write down the sequence of instructions that constitute the controller.

725
00:39:30,920 --> 00:39:41,510
So we have assign, to set up, continue to done.

727
00:39:44,476 --> 00:40:08,050
We have a loop which says branch if equal 1 fetch N, if N is 1, then go to the base step of the induction, the simple case.

730
00:40:08,050 --> 00:40:14,265
Otherwise, I have to remember the things that are necessary to perform a sub-factorial.

732
00:40:14,265 --> 00:40:17,570
I'm going to go over here, and I have to perform a sub-factorial.

734
00:40:17,570 --> 00:40:24,000
So I have to remember what's needed after I will be done with that.

736
00:40:24,000 --> 00:40:25,510
See, I'm about to do something terrible.

737
00:40:25,510 --> 00:40:38,000
I'm about to change the value of N. But this guy has to know the old value of N. But in order to make the sub-factorial work, I have to change the value of N. So I have to remember the old value.

741
00:40:38,000 --> 00:40:40,850
And I also have to remember where I've been.

742
00:40:40,850 --> 00:40:42,100
So I save up continue.

744
00:40:47,705 --> 00:40:53,580
And this is an instruction that says, put something in the stack.

746
00:40:53,580 --> 00:41:03,550
Save the contents of the continuation register, which in this case is done, because later I'm going to change that, too, because I need to go back to after-fact, as well.

750
00:41:03,550 --> 00:41:05,040
We'll see that.

751
00:41:05,040 --> 00:41:10,380
We save N, because I'm going to need that for later.

752
00:41:10,380 --> 00:41:37,690
Assign to N the decrement of fetch N. Assign continue, we're going to look at this now, to after, we'll call it.

754
00:41:37,690 --> 00:41:41,140
That's a good name for this, a little bit easier and shorter, and fits in here.

757
00:41:52,772 --> 00:41:55,330
Now look what I'm doing here.

758
00:41:55,330 --> 00:42:00,065
I'm saying, if the answer is 1, I'm done.

759
00:42:00,065 --> 00:42:02,150
I'm going to have to just get the answer.

760
00:42:02,150 --> 00:42:11,780
Otherwise, I'm going to save the continuation, save N, make N one less than N, remember I'm going to come back to someplace else, and go back and start doing another factorial.

765
00:42:13,980 --> 00:42:16,050
However, I've got a different machine [? in me ?] now.

766
00:42:16,050 --> 00:42:18,380
N is 1, and continue is something else.

768
00:42:22,160 --> 00:42:23,590
N is N minus 1.

769
00:42:23,590 --> 00:42:28,660
Now after I'm done with that, I can go there.

770
00:42:28,660 --> 00:42:38,360
I will restore the old value of N, which is the opposite of this save over here.

772
00:42:38,360 --> 00:42:39,610
I will restore the continuation.

774
00:42:49,660 --> 00:42:54,320
I will then go to here.

775
00:42:54,320 --> 00:43:08,130
I will assign to the VAL register the product of N and fetch VAL.

778
00:43:13,520 --> 00:43:19,790
VAL fetch product assign.

779
00:43:19,790 --> 00:43:21,440
And then I will be done.

780
00:43:21,440 --> 00:43:26,570
I will have my answer to the sub-factorial in VAL.

781
00:43:26,570 --> 00:43:33,640
At that point, I'm going to return by going to the place where the continuation is pointing.

783
00:43:33,640 --> 00:43:35,300
That says, go to fetch continue.

785
00:43:45,870 --> 00:43:50,730
And then I have finally a base step, which is the immediate answer.

787
00:43:50,730 --> 00:44:02,570
Assign to VAL fetch N, and go to fetch continue.

789
00:44:12,670 --> 00:44:13,920
And then I'm done.

791
00:44:18,640 --> 00:44:26,890
Now let's see how this executes on a very simple case, because then we'll see the use of this stack to do the job we need.

794
00:44:26,890 --> 00:44:31,340
This is statically what it's doing, but we have look dynamically at this.

796
00:44:31,340 --> 00:44:32,300
So let's see.

797
00:44:32,300 --> 00:44:36,730
First thing we do is continue gets done.

798
00:44:36,730 --> 00:44:38,300
The way that happened is I pushed this.

799
00:44:38,300 --> 00:44:40,122
Let's call that done the way I have it.

801
00:44:46,390 --> 00:44:47,030
I push that button.

802
00:44:47,030 --> 00:44:48,950
Done goes into there.

803
00:44:48,950 --> 00:44:53,850
Now I also have to set this thing up to have an initial value.

805
00:44:53,850 --> 00:45:00,192
Let's consider a factorial of three, a simple case.

806
00:45:00,192 --> 00:45:05,900
And we're going to start out with our stack growing over here.

808
00:45:05,900 --> 00:45:12,770
Stacks have their own little internal state saying where they are, where the next place I'm going to write is.

810
00:45:12,770 --> 00:45:14,590
So now we say, is N 1?

811
00:45:14,590 --> 00:45:16,110
The answer is no.

812
00:45:16,110 --> 00:45:19,066
So now I'm going to save continue, bang.

813
00:45:19,066 --> 00:45:22,080
Now that done goes in here.

814
00:45:22,080 --> 00:45:26,660
And this moves to here, the next place I'm going to write.

815
00:45:26,660 --> 00:45:29,950
Save N 3.

816
00:45:29,950 --> 00:45:30,750
OK?

817
00:45:30,750 --> 00:45:35,940
Assign to N the decrement of N. That means I've pushed this button.

819
00:45:35,940 --> 00:45:37,320
This becomes 2.

821
00:45:40,400 --> 00:45:42,580
Assign to continue aft.

822
00:45:42,580 --> 00:45:43,610
So I've pushed that button.

823
00:45:43,610 --> 00:45:44,860
Aft goes in here.

825
00:45:49,140 --> 00:45:54,830
OK, now go to loop, bang, so up to here.

826
00:45:54,830 --> 00:45:56,570
Is N 1?

827
00:45:56,570 --> 00:45:57,780
No.

828
00:45:57,780 --> 00:45:59,490
So I have to save continue.

829
00:45:59,490 --> 00:46:00,600
What's continue?

830
00:46:00,600 --> 00:46:01,530
Continue is aft.

831
00:46:01,530 --> 00:46:02,780
Push this button.

832
00:46:02,780 --> 00:46:04,030
So this moves to here.

834
00:46:08,490 --> 00:46:11,460
I have to save N. N is over here.

835
00:46:11,460 --> 00:46:12,280
I got to 2.

836
00:46:12,280 --> 00:46:13,655
Push that button.

837
00:46:13,655 --> 00:46:16,050
So a 2 gets written there.

838
00:46:16,050 --> 00:46:20,060
And then this thing moves down here.

839
00:46:20,060 --> 00:46:24,214
OK, save N. Assign N to the decrement of N.

840
00:46:24,214 --> 00:46:25,464
This becomes a 1.

842
00:46:29,240 --> 00:46:31,370
Assign continue to aft.

843
00:46:31,370 --> 00:46:34,960
A-F-T gets written there again.

844
00:46:34,960 --> 00:46:36,520
Go to loop.

845
00:46:36,520 --> 00:46:37,930
Is N equal to 1?

846
00:46:37,930 --> 00:46:41,160
Oh, yes, the answer is 1.

847
00:46:41,160 --> 00:46:44,160
OK, go to base step.

848
00:46:44,160 --> 00:46:51,100
Assign to VAL fetch of N. Bang, 1 gets put in there.

849
00:46:51,100 --> 00:46:52,200
Go to fetch continue.

850
00:46:52,200 --> 00:46:53,680
So we look in continue.

851
00:46:53,680 --> 00:46:57,130
Basically, I'm pushing a button over here that goes to the controller.

853
00:46:57,130 --> 00:47:02,640
The continue becomes aft, and all of a sudden, the program's running here.

855
00:47:02,640 --> 00:47:06,650
I now have to restore the outer version of factorial.

856
00:47:06,650 --> 00:47:07,550
So we go here.

857
00:47:07,550 --> 00:47:13,940
We say, restore N. So restore N means take the contents that's here.

859
00:47:13,940 --> 00:47:22,230
Push this button, and it goes into here, 2, and the pointer moves up.

861
00:47:22,230 --> 00:47:24,810
Restore continue, pretty easy.

862
00:47:24,810 --> 00:47:27,020
Go push this button.

863
00:47:27,020 --> 00:47:31,280
And then aft gets written in here again.

864
00:47:31,280 --> 00:47:32,640
That means this thing moves up.

865
00:47:32,640 --> 00:47:35,190
I've gotten rid of something else on my stack.

867
00:47:42,240 --> 00:47:47,850
Right, then I go to here, which says, assign to VAL the product of N an VAL.

869
00:47:47,850 --> 00:47:50,970
So I push this button over here, bang.

870
00:47:50,970 --> 00:47:55,920
2 times 1 gives me a 2, get written there.

871
00:47:55,920 --> 00:47:57,540
Go to fetch continue.

872
00:47:57,540 --> 00:47:59,190
Continue is aft.

873
00:47:59,190 --> 00:48:01,290
I go to aft.

874
00:48:01,290 --> 00:48:17,715
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

877
00:48:17,715 --> 00:48:20,200
The next thing I do is restore continue.

878
00:48:20,200 --> 00:48:22,830
Continue is now going to become done.

879
00:48:22,830 --> 00:48:27,260
So this moves up here when I push this button.

880
00:48:27,260 --> 00:48:31,720
Done may or may be there anymore, I'm not interested, but it certainly is here.

883
00:48:35,800 --> 00:48:41,440
Next thing I do is assign to VAL the product of the fetch of N and the fetch of VAL.

885
00:48:41,440 --> 00:48:44,300
That's pushing this button over here, bang.

886
00:48:44,300 --> 00:48:46,520
2 times 3 is 6.

887
00:48:46,520 --> 00:48:47,870
So I get a 6 over here.

889
00:48:52,020 --> 00:48:55,020
And go to fetch continue, whoops, I go to done, and I'm done.

891
00:48:55,020 --> 00:48:58,950
And my answer is 6, as you can see in the VAL register.

892
00:48:58,950 --> 00:49:03,630
And in fact, the stack is in the state it originally was in.

895
00:49:07,735 --> 00:49:13,620
Now there's a bit of discipline in using these things like stacks that we have to be careful of.

897
00:49:13,620 --> 00:49:16,260
And we'll see that in the next segment.

898
00:49:16,260 --> 00:49:18,590
But first I want to ask if there are any questions for this.

901
00:49:28,560 --> 00:49:30,170
Are there any questions?

902
00:49:30,170 --> 00:49:30,630
Yes, Ron.

903
00:49:30,630 --> 00:49:35,030
AUDIENCE: What happens when you roll off the end of the stack with-- PROFESSOR: What do you mean, roll off of?

906
00:49:35,030 --> 00:49:38,860
AUDIENCE: Well, the largest number-- a larger starting point of N requires more memory, correct?

908
00:49:38,860 --> 00:49:39,440
PROFESSOR: Oh, yes.

909
00:49:39,440 --> 00:49:41,530
Well, I need to have a long enough stack.

910
00:49:41,530 --> 00:49:43,843
You say, what if I violate my illusion?

911
00:49:43,843 --> 00:49:44,550
AUDIENCE: Yes.

912
00:49:44,550 --> 00:49:48,210
PROFESSOR: Well, then the magic doesn't work.

913
00:49:48,210 --> 00:49:51,640
The truth of the matter is that every machine is finite.

914
00:49:51,640 --> 00:49:59,950
And for a procedure like this, there's a limit to the number of sub-factorials I could have.

916
00:49:59,950 --> 00:50:08,350
Remember when we were doing the y-operator a while ago, we pointed out that there was a sequence of exponentiation procedures, each of which was a little better than the previous one.

920
00:50:08,350 --> 00:50:13,090
Well, we're now seeing how we implement that mathematical idea.

922
00:50:13,090 --> 00:50:17,990
The limiting process is only so good as as far as you take the limit.

924
00:50:17,990 --> 00:50:19,420
If you think about it, what am I using here?

925
00:50:19,420 --> 00:50:29,100
I'm using about two pieces of memory for every recursion of this process.

927
00:50:29,100 --> 00:50:33,180
If we try to compute factorial of 10,000, that's not a lot of memory.

929
00:50:33,180 --> 00:50:36,080
On the other hand, it's an awful big number.

930
00:50:36,080 --> 00:50:39,180
So the question is, is that a valuable thing in this case.

931
00:50:39,180 --> 00:50:45,085
But it really turns out not to be a terrible limit, because memory is el cheapo, and people are pretty expensive.

934
00:50:48,130 --> 00:50:51,050
OK, thank you, let's take a break.

935
00:50:51,050 --> 00:50:52,660
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

938
00:51:55,176 --> 00:51:58,351
PROFESSOR: Well, let's see.

939
00:51:58,351 --> 00:52:05,640
What I've shown you now is how to do a simple iterative process and a simple recursive process.

941
00:52:05,640 --> 00:52:26,400
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

947
00:52:26,400 --> 00:52:27,110
So let's see.

948
00:52:27,110 --> 00:52:30,080
I'm just going to write down, first of all, the program I'm going to translate.

951
00:52:34,150 --> 00:52:59,965
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

955
00:53:07,240 --> 00:53:09,290
That's the plan I have here.

956
00:53:09,290 --> 00:53:13,070
And we're just going to write down the controller for such a machine.

958
00:53:13,070 --> 00:53:26,810
We're going to assume that there are registers, N, which holds the number we're taking Fibonacci of, VAL, which is where the answer is going to get put, and continue, which is the thing that's linked to the controller, like before.

962
00:53:26,810 --> 00:53:34,360
But I'm not going to draw another physical datapath, because it's pretty much the same as the last one you've seen.

965
00:53:34,360 --> 00:53:44,860
And of course, one of the most amazing things about computation is that after a while, you build up a little more features and a few more features, and all of the sudden, you've got everything you need.

969
00:53:44,860 --> 00:53:51,810
So it's remarkable that it just gets there so fast. I don't need much more to make a universal computer.

971
00:53:51,810 --> 00:53:55,060
But in any case, let's look at the controller for the Fibonacci thing.

973
00:53:55,060 --> 00:54:10,230
First thing I want to do is start the thing up by assign to continue a place called done, called Fib-done here.

976
00:54:13,709 --> 00:54:24,120
So that means that somewhere over here, I'm going to have a label, Fib-done, which is the place where I go when I want the machine to stop.

979
00:54:24,120 --> 00:54:25,395
That's what that is.

980
00:54:25,395 --> 00:54:26,795
And I'm going to make up a loop.

982
00:54:31,110 --> 00:54:35,470
It's a place I'm going to go to in order to start up computing a Fib.

984
00:54:35,470 --> 00:54:42,570
Whatever is in N at this point, Fibonacci will be computed of, and we will return to the place specified by continue.

988
00:54:46,070 --> 00:55:02,100
So what you're going to see here at this place, what I want here is the contract that says, I'm going to write this with a comment syntax, the contract is N contains arg, the argument.

992
00:55:02,100 --> 00:55:09,325
Continue is the recipient.

994
00:55:12,812 --> 00:55:14,290
And that's where it is.

996
00:55:17,370 --> 00:55:24,820
At this point, if I ever go to this place, I'm expecting this to be true, the argument for computing the Fibonacci.

998
00:55:24,820 --> 00:55:26,450
Now the next thing I want to do is to branch.

1000
00:55:30,220 --> 00:55:38,730
And if N is less than 2--  by the way, I'm using what looks like Lisp syntax.

1003
00:55:38,730 --> 00:55:41,310
This is not Lisp.

1004
00:55:41,310 --> 00:55:42,750
This does not run.

1005
00:55:42,750 --> 00:55:46,120
What I'm writing here does not run as a simple Lisp program.

1006
00:55:46,120 --> 00:55:49,710
This is a representation of another language.

1007
00:55:49,710 --> 00:56:03,380
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

1011
00:56:03,380 --> 00:56:06,940
I don't want to confuse this to think that this is Lisp code.

1013
00:56:06,940 --> 00:56:09,510
It's just I'm using a lot of the pieces of Lisp.

1014
00:56:09,510 --> 00:56:16,620
I'm embedding a language in Lisp, using Lisp as pieces to make my process of making my simulator easy.

1016
00:56:16,620 --> 00:56:18,900
So I'm inheriting from Lisp all of its properties.

1017
00:56:18,900 --> 00:56:25,985
Fetch of N 2, I want to go to a place called immediate answer.

1019
00:56:25,985 --> 00:56:27,235
It's the base step.

1021
00:56:33,150 --> 00:56:37,750
Now, that's somewhere over here, just above done.

1022
00:56:37,750 --> 00:56:39,330
And we'll see it later.

1023
00:56:39,330 --> 00:56:44,860
Now, in the general case, which is the part I'm going to write down now, let's just do it.

1025
00:56:44,860 --> 00:56:49,420
Well, first of all, I'm going to have to call Fibonacci twice.

1027
00:56:49,420 --> 00:56:56,310
In each case-- well, in one case at least, I'm going to have to know what to do to come back and do the next one.

1030
00:56:56,310 --> 00:57:04,500
I have to remember, have I done the first Fib, or have I done the second one?

1032
00:57:04,500 --> 00:57:09,490
Do I have to come back to the place where I do the second Fib, or do I have to come back to the place where I do the add?

1036
00:57:12,140 --> 00:57:16,980
In the first case, over the first Fibonacci, I'm going to need the value of N for computing for the second one.

1039
00:57:20,010 --> 00:57:22,996
So I have to store some of these things up.

1040
00:57:22,996 --> 00:57:25,820
So first I'm going to save continue.

1041
00:57:25,820 --> 00:57:27,265
That's who needs the answer.

1043
00:57:31,320 --> 00:57:44,130
And the reason I'm doing that is because I'm about to assign continue to the place which is the place I want to go to after.

1047
00:57:46,870 --> 00:57:53,760
Let's call it Fib-N-minus-1, big long name, classic Lisp name.

1050
00:57:57,700 --> 00:58:03,960
Because I'm going to compute the first Fib of N minus 1, and then after that, I want to come back and do something else.

1053
00:58:03,960 --> 00:58:11,106
That's the place I want to go to after I've done the first Fibonacci calculation.

1055
00:58:11,106 --> 00:58:19,130
And I want to do a save of N, because I'm going to need it later, after that.

1057
00:58:19,130 --> 00:58:23,230
Now I'm going to, at this point, get ready to do the Fibonacci of N minus 1.

1059
00:58:23,230 --> 00:58:33,950
So assign to N the difference of the fetch of N and 1.

1061
00:58:38,110 --> 00:58:40,270
Now I'm ready to go back to doing the Fib loop.

1063
00:58:47,630 --> 00:58:50,195
Have I satisfied my contract?

1064
00:58:50,195 --> 00:58:51,770
And the answer is yes.

1065
00:58:51,770 --> 00:58:57,210
N contains N minus 1, which is what I need.

1066
00:58:57,210 --> 00:59:04,100
Continue contains a place I want to go to when I'm done with calculating N minus 1.

1068
00:59:04,100 --> 00:59:05,440
So I've satisfied the contract.

1069
00:59:05,440 --> 00:59:12,830
And therefore, I can write down here a label, after-Fib-N-minus-1.

1072
00:59:20,490 --> 00:59:22,690
Now what am I going to do here?

1073
00:59:22,690 --> 00:59:26,910
Here's a place where I now have to get ready to do Fib of N minus 2.

1076
00:59:29,270 --> 00:59:31,780
But in order to do a Fib of N minus 2, look, I don't know.

1077
00:59:31,780 --> 00:59:33,810
I've clobbered my N over here.

1078
00:59:33,810 --> 00:59:39,780
And presumably my N is counted down all the way to 1 or 0 or something at this point.

1080
00:59:39,780 --> 00:59:43,030
So I don't know what the value of N in the N register is.

1081
00:59:43,030 --> 00:59:49,520
I want the value of N that was on the stack that I saved over here so that could restore it over here.

1083
00:59:49,520 --> 01:00:01,810
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1087
01:00:01,810 --> 01:00:03,060
So let's restore that.

1089
01:00:08,830 --> 01:00:11,130
Restore of N.

1090
01:00:11,130 --> 01:00:18,520
Now I'm about to do something which is superstitious, and we will remove it shortly.

1092
01:00:18,520 --> 01:00:24,800
I am about to finish the sequence of doing the subroutine call, if you will.

1094
01:00:24,800 --> 01:00:31,600
I'm going to say, well, I also saved up the continuation, since I'm going to restore it now.

1096
01:00:31,600 --> 01:00:34,610
But actually, I don't have to, because I'm not going to need it.

1098
01:00:34,610 --> 01:00:36,260
We'll fix that in a second.

1099
01:00:36,260 --> 01:00:48,020
So we'll do a restore of continue, which is what I would in general need to do.

1101
01:00:48,020 --> 01:00:55,420
And we're just going to see what you would call in the compiler world a peephole optimization, which says, whoops, you didn't have to do that.

1104
01:00:55,420 --> 01:01:02,770
OK, so the next thing I see here is that I have to get ready now to do Fibonacci of N minus 2.

1106
01:01:02,770 --> 01:01:05,050
But I don't have to save N anymore.

1107
01:01:05,050 --> 01:01:13,540
The reason why I don't have to save N anymore is because I don't need N after I've done Fib of N minus 2, because the next thing I do is add.

1110
01:01:13,540 --> 01:01:16,500
So I'm just going to set up my N that way.

1111
01:01:16,500 --> 01:01:28,990
Assign N minus difference of fetch N and 2.

1113
01:01:31,850 --> 01:01:36,950
Now I have to finish the setup for calling Fibonacci of N minus 2.

1115
01:01:36,950 --> 01:02:05,320
Well, I have to save up continue and assign continue, continue, to the place which is after Fib N 2, that place over here somewhere.

1118
01:02:05,320 --> 01:02:08,650
However, I've got to be very careful.

1119
01:02:08,650 --> 01:02:15,300
The old value, the value of Fib of N minus 1, I'm going to need later.

1121
01:02:15,300 --> 01:02:18,480
The value of Fibonacci of N minus 1, I'm going to need.

1122
01:02:18,480 --> 01:02:24,150
And I can't clobber it, because I'm going to have to add it to the value of Fib of N minus 2.

1124
01:02:24,150 --> 01:02:27,720
That's in the value register, so I'm going to save it.

1125
01:02:27,720 --> 01:02:33,780
So I have to save this right now, save up VAL.

1126
01:02:33,780 --> 01:02:39,547
And now I can go off to my subroutine, go to Fib loop.

1128
01:02:44,220 --> 01:03:01,580
Now before I go any further and finish this program, I just want to look at this segment so far and see, oh yes, there's a sequence of instructions here, if you will, that I can do something about.

1132
01:03:01,580 --> 01:03:10,640
Here I have a restore of continue, a save of continue, and then an assign of continue, with no other references to continue in between.

1136
01:03:13,840 --> 01:03:16,770
The restore followed by the save leaves the stack unchanged.

1139
01:03:19,090 --> 01:03:24,330
The only difference is that I set the continue register to a value, which is the value that was on the stack.

1141
01:03:24,330 --> 01:03:31,710
Since I now clobber that value, as in it was never referenced, these instructions are unnecessary.

1143
01:03:31,710 --> 01:03:35,390
So we will remove these.

1145
01:03:38,550 --> 01:03:41,460
But I couldn't have seen that unless I had written them down.

1148
01:03:43,780 --> 01:03:45,590
Was that really true?

1149
01:03:45,590 --> 01:03:48,610
Well, I don't know.

1150
01:03:48,610 --> 01:03:53,660
OK, so we've now gone off to compute Fibonacci of N minus 2.

1152
01:03:53,660 --> 01:04:05,070
So after that, what are we going to do?

1153
01:04:05,070 --> 01:04:07,960
Well, I suppose the first thing we have to do-- we've got two things.

1155
01:04:07,960 --> 01:04:10,920
We've got a thing in the value register which is now valuable.

1157
01:04:10,920 --> 01:04:14,815
We also have a thing on the stack that can be restored into the value register.

1159
01:04:14,815 --> 01:04:19,470
And what I have to be careful with now is I want to shuffle this right so I can do the multiply.

1161
01:04:19,470 --> 01:04:26,740
Now there are various conventions I might use, but I'm going to be very picky and say, I'm only going to restore into a register I've saved from.

1164
01:04:26,740 --> 01:04:30,020
If that's the case, I have to do a shuffle here.

1165
01:04:30,020 --> 01:04:47,340
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1170
01:04:52,950 --> 01:04:56,180
And I'm going to restore the value register now.

1172
01:05:01,850 --> 01:05:13,840
This restore matches this save. And if you're very careful and examine very carefully what goes on, restores and saves are always matched.

1175
01:05:13,840 --> 01:05:19,000
Now there's an outstanding save, of course, that we have to get rid of soon.

1177
01:05:19,000 --> 01:05:20,590
And so I restored the value register.

1178
01:05:20,590 --> 01:05:42,860
Now I restore the continue one, which matches this one, dot, dot, dot, dot, dot, dot, dot, down to here, restoring that continuation.

1181
01:05:42,860 --> 01:05:49,665
That continuation is a continuation of Fib of N, which is the problem I was trying to solve, a major problem I'm trying to solve.

1184
01:05:49,665 --> 01:05:57,360
So that's the guy I have to go back to who wants Fib of N. I saved them all the way up here when I realized N was not less than 2.

1187
01:05:57,360 --> 01:06:00,840
And so I had to do a complicated operation.

1188
01:06:00,840 --> 01:06:03,240
Now I've got everything I need to do it.

1189
01:06:03,240 --> 01:06:28,335
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1192
01:06:38,260 --> 01:06:47,110
So now I've returned from computing Fibonacci of N, the general case.

1194
01:06:47,110 --> 01:07:36,130
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1203
01:07:43,460 --> 01:07:45,640
So that's a fairly complicated program.

1204
01:07:45,640 --> 01:07:52,965
And the reason I wanted you see to that is because I want you to see the particular flavors of stack discipline that I was obeying.

1207
01:07:52,965 --> 01:08:00,395
It was first of all, I don't want to take anything that I'm not going to need later.

1209
01:08:00,395 --> 01:08:01,850
I was being very careful.

1210
01:08:01,850 --> 01:08:03,940
And it's very important.

1211
01:08:03,940 --> 01:08:15,830
And there are all sorts of other disciplines people make with frames and things like that of some sort, where you save all sorts of junk you're not going to need later and restore it because, in some sense, it's easier to do that.

1215
01:08:15,830 --> 01:08:21,740
That's going to lead to various disasters, which we'll see a little later.

1217
01:08:21,740 --> 01:08:24,810
It's crucial to say exactly what you're going to need later.

1220
01:08:26,899 --> 01:08:29,859
It's an important idea.

1221
01:08:29,859 --> 01:08:36,930
And the responsibility of that is whoever saves something is the guy who restores it, because he needs it.

1223
01:08:36,930 --> 01:08:46,940
And in such discipline, you can see what things are unnecessary, operations that are unimportant.

1225
01:08:46,940 --> 01:08:55,350
Now, one other thing I want to tell you about that's very simple is that, of course, the picture you see is not the whole picture.

1228
01:08:55,350 --> 01:09:10,000
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1231
01:09:10,000 --> 01:09:18,299
Well, at this level of detail, whatever it is, we can conceptualize those as primitive operations in the datapath.

1234
01:09:18,299 --> 01:09:33,630
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1239
01:09:33,630 --> 01:09:36,133
Well, it's got about the same structure.

1240
01:09:36,133 --> 01:09:37,270
And what do we have?

1241
01:09:37,270 --> 01:09:46,939
We have some sort of things in it which may be registers, x and y, and then x has to somehow move to y sometimes, x has to get the value of y.

1244
01:09:46,939 --> 01:09:51,700
And then we may have to be able to do something which is a cons.

1246
01:09:51,700 --> 01:10:01,420
I don't remember if I need to like this is in this system, but cons is sort of like subtract or add or something.

1248
01:10:01,420 --> 01:10:07,600
It combines two things, producing a thing which is the cons, which we may then think goes into there.

1250
01:10:07,600 --> 01:10:16,920
And then maybe a thing called the CAR, which will produce-- I can get the CAR or something.

1252
01:10:16,920 --> 01:10:20,150
And maybe I can get the CDR of something, and so on.

1253
01:10:20,150 --> 01:10:31,770
But we shouldn't be too afraid of saying things this way, because the worst that could happen is if we open up cons, what we're going to find is some machine.

1256
01:10:31,770 --> 01:10:41,210
And cons may in fact overlap with CAR and CDR, and it always does, in the same way that plus and minus overlap, and really the same business.

1259
01:10:41,210 --> 01:10:53,300
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1262
01:10:53,300 --> 01:11:02,030
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1266
01:11:06,570 --> 01:11:09,330
And I wouldn't be so horrified if that were the way it works.

1267
01:11:09,330 --> 01:11:13,320
In fact, it does, and we'll talk about that later.

1268
01:11:13,320 --> 01:11:14,570
So are there any questions?

1270
01:11:24,340 --> 01:11:25,665
Gee, what an unquestioning audience.

1272
01:11:28,670 --> 01:11:30,330
Suppose I tell you a horrible pile of lies.

1274
01:11:39,690 --> 01:11:41,990
OK.

1275
01:11:41,990 --> 01:11:42,520
Well, thank you.

1276
01:11:42,520 --> 01:11:44,230
Let's take our break.

1277
01:11:44,230 --> 01:11:48,780
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

