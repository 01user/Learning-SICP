[Script Info]
; Script generated by Aegisub 3.2.1
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 712
PlayResY: 360

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Movies/Lec10a.mp4
Video File: ../../../Movies/Lec10a.mp4
Video AR Mode: 1
Video AR Value: 1.333333
Video Zoom Percent: 1.250000
Scroll Position: 145
Active Line: 156
Video Position: 18234

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,.PingFang SC,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:19.36,0:00:22.26,Default,,0,0,0,,教授: 上节课 我们学习了\NPROFESSOR: Last time, we took a look at
Dialogue: 0,0:00:22.26,0:00:25.54,Default,,0,0,0,,一个Lisp 显式控制求值器\Nan explicit control evaluator for Lisp,
Dialogue: 0,0:00:25.54,0:00:32.32,Default,,0,0,0,,它在如Lisp或查询语言等高级语言\Nand that bridged the gap between all these high-level languages
Dialogue: 0,0:00:32.32,0:00:36.40,Default,,0,0,0,,与传统的寄存器机器之间架起了桥梁\Nbridged the gap between that and a conventional register machine.
Dialogue: 0,0:00:36.40,0:00:42.46,Default,,0,0,0,,事实上 你可以将显式控制求值器\NAnd in fact, you can think of the explicit control evaluator either as, say,
Dialogue: 0,0:00:42.46,0:00:55.20,Default,,0,0,0,,#TBD \Nthe code for a Lisp interpreter if you wanted to implement it in the assembly language of some conventional register transfer machine, or, if you like, you can think of it as the microcode of some machine that's going to be specially designed to run Lisp.
Dialogue: 0,0:00:55.20,0:01:00.92,Default,,0,0,0,,在任何一种情况下 我们得到一种能够处理低级语言的机器\NIn either case, what we're doing is we're taking a machine that speaks some low-level language,
Dialogue: 0,0:01:00.92,0:01:07.26,Default,,0,0,0,,通过写一个解释器来让它能够执行像Lisp之类的高级语言\Nand we're raising the machine to a high-level language like Lisp by writing an interpreter.
Dialogue: 0,0:01:07.26,0:01:11.00,Default,,0,0,0,,来看个例子\NSo for instance,
Dialogue: 0,0:01:11.00,0:01:23.84,Default,,0,0,0,,这是一个概念上的 用于计算阶乘的专用机器\N here, conceptually, is a special purpose machine for computing factorials.
Dialogue: 0,0:01:23.84,0:01:28.26,Default,,0,0,0,,输入5 输出120 \NIt takes in five and puts out 120.
Dialogue: 0,0:01:28.26,0:01:33.16,Default,,0,0,0,,这个专用机器实际上是一个Lisp解释器\NAnd what this special purpose machine is actually a Lisp interpreter
Dialogue: 0,0:01:33.16,0:01:37.48,Default,,0,0,0,,它将自己设置为运行阶乘\Nthat's configured itself to run factorials,
Dialogue: 0,0:01:37.48,0:01:41.66,Default,,0,0,0,,因为你喂给它了阶乘机器的描述\Nbecause you feed into it a description of the factorial machine.
Dialogue: 0,0:01:41.66,0:01:43.70,Default,,0,0,0,,这就是解释器\NSo that's what an interpreter is.
Dialogue: 0,0:01:43.70,0:01:49.68,Default,,0,0,0,,它将自己设置为 模拟你所输入描述的机器\NIt configures itself to emulate a machine whose description you read in.
Dialogue: 0,0:01:49.68,0:01:52.04,Default,,0,0,0,,在Lisp解释器里是什么? \NNow, inside the Lisp interpreter, what's that?
Dialogue: 0,0:01:52.04,0:01:56.42,Default,,0,0,0,,里面可能是通用的寄存器语言解释器\NWell, that might be your general register language interpreter
Dialogue: 0,0:01:56.42,0:02:00.18,Default,,0,0,0,,它将自己设置为像Lisp解释器一样工作\Nthat configures itself to behave like a Lisp interpreter,
Dialogue: 0,0:02:00.18,0:02:03.24,Default,,0,0,0,,因为你输入了一系列寄存器语言编写的指令\Nbecause you put in a whole bunch of instructions in register language.
Dialogue: 0,0:02:03.24,0:02:06.46,Default,,0,0,0,,这就是显式控制求值器\NThis is the explicit control evaluator.
Dialogue: 0,0:02:06.46,0:02:09.30,Default,,0,0,0,,它也有某种TBD\NAnd then it also has some sort of library,
Dialogue: 0,0:02:09.30,0:02:12.48,Default,,0,0,0,,\Na library of primitive operators and Lisp operations and all sorts of things like that.
Dialogue: 0,0:02:12.48,0:02:17.04,Default,,0,0,0,,这是解释执行的通常策略\NThat's the general strategy of interpretation.
Dialogue: 0,0:02:17.04,0:02:20.88,Default,,0,0,0,,事实上，我们所做的是写了一个解释器\NAnd the point is, what we're doing is we're writing an interpreter
Dialogue: 0,0:02:20.88,0:02:25.24,Default,,0,0,0,,将机器提升到能理解我们写的程序的层次\Nto raise the machine to the level of the programs that we want to write.
Dialogue: 0,0:02:25.24,0:02:27.04,Default,,0,0,0,,也有另一种逻辑\NWell, there's another strategy,
Dialogue: 0,0:02:27.04,0:02:29.04,Default,,0,0,0,,一种不同的策略，就是编译\Na different one, which is compilation.
Dialogue: 0,0:02:29.04,0:02:31.04,Default,,0,0,0,,编译有一些不同\NCompilation's a little bit different.
Dialogue: 0,0:02:31.04,0:02:32.44,Default,,0,0,0,,这里\NHere--
Dialogue: 0,0:02:32.44,0:02:35.16,Default,,0,0,0,,我们可能已经制造了\Nhere we might have produced
Dialogue: 0,0:02:35.16,0:02:42.20,Default,,0,0,0,,一个特定用途的机器，用来计算阶乘\Na special purpose machine for, for computing factorials,
Dialogue: 0,0:02:42.20,0:02:46.26,Default,,0,0,0,,从某种讲寄存器语言的机器开始\Nstarting with some sort of machine that speaks register language,
Dialogue: 0,0:02:46.26,0:02:47.72,Default,,0,0,0,,除此之外，我们将让它执行不同的策略TBD\Nexcept we're going to do a different strategy.
Dialogue: 0,0:02:47.72,0:02:50.98,Default,,0,0,0,,我们拿来阶乘程序\NWe take our factorial program.
Dialogue: 0,0:02:50.98,0:02:53.92,Default,,0,0,0,,我们把这些源代码输入编译器\NWe use that as the source code into a compiler.
Dialogue: 0,0:02:53.92,0:02:56.18,Default,,0,0,0,,编译器将会做的是\NWhat the compiler will do
Dialogue: 0,0:02:56.18,0:02:59.64,Default,,0,0,0,,把这个阶乘程序翻译成某种寄存器机器语言\Nis translate that factorial program into some register machine language.
Dialogue: 0,0:02:59.64,0:03:03.40,Default,,0,0,0,,现在它并不是Lisp的显式控制求值器\NAnd this will now be not the explicit control evaluator for Lisp,
Dialogue: 0,0:03:03.40,0:03:06.34,Default,,0,0,0,,它现在是某种用来计算阶乘的寄存器语言\Nthis will be some register language for computing factorials.
Dialogue: 0,0:03:06.34,0:03:09.16,Default,,0,0,0,,这就是翻译的过程\NSo this is the translation of that.
Dialogue: 0,0:03:09.16,0:03:12.92,Default,,0,0,0,,它将进入某种加载器\NThat will go into some sort of loader
Dialogue: 0,0:03:12.92,0:03:19.36,Default,,0,0,0,,并与从库中选取的乘法之类的代码组合到一起\Nwhich will combine this code with code selected from the library to do things like primitive multiplication.
Dialogue: 0,0:03:19.36,0:03:21.96,Default,,0,0,0,,随后我们将生成一个加载模块\NAnd then we'll produce a load module
Dialogue: 0,0:03:21.96,0:03:25.06,Default,,0,0,0,,它把寄存器语言机器配置成\Nwhich configures the register language machine
Dialogue: 0,0:03:25.06,0:03:27.74,Default,,0,0,0,,一个专门用来计算阶乘的机器\Nto be a special purpose factorial machine.
Dialogue: 0,0:03:27.74,0:03:30.22,Default,,0,0,0,,这就是不同的策略\NSo that's a, that's a different strategy.
Dialogue: 0,0:03:30.22,0:03:32.40,Default,,0,0,0,,在解释中\NIn interpretation, we're raising
Dialogue: 0,0:03:32.40,0:03:35.32,Default,,0,0,0,,我们将机器提升到我们语言的层次，如Lisp\Nthe machine to the level of our language, like Lisp.
Dialogue: 0,0:03:35.32,0:03:36.34,Default,,0,0,0,,在编译中\NIn compilation,
Dialogue: 0,0:03:36.34,0:03:41.24,Default,,0,0,0,,我们将我们的程序降到机器语言的层次\Nwe're taking our program and lowering it to the language that's spoken by the machine.
Dialogue: 0,0:03:41.24,0:03:44.10,Default,,0,0,0,,那么，这两个策略有什么区别呢？\NWell, how do these two strategies compare?
Dialogue: 0,0:03:44.10,0:03:51.02,Default,,0,0,0,,编译器可以生成执行起来更有效率的代码\NThe compiler can produce code that will execute more efficiently.
Dialogue: 0,0:03:51.02,0:03:54.06,Default,,0,0,0,,The essential reason for that is that
Dialogue: 0,0:03:54.06,0:04:00.60,Default,,0,0,0,,if you think about the register operations that are running,
Dialogue: 0,0:04:00.60,0:04:04.82,Default,,0,0,0,,the interpreter has to produce register operations
Dialogue: 0,0:04:04.82,0:04:09.58,Default,,0,0,0,,which, in principle, are going to be general enough to execute any Lisp procedure.
Dialogue: 0,0:04:09.58,0:04:15.16,Default,,0,0,0,,Whereas the compiler only has to worry about producing a special bunch of register operations for,
Dialogue: 0,0:04:15.16,0:04:19.28,Default,,0,0,0,, for doing the particular Lisp procedure that you've compiled.
Dialogue: 0,0:04:19.28,0:04:21.24,Default,,0,0,0,,换一种说法\NOr another way to say that
Dialogue: 0,0:04:22.66,0:04:25.66,Default,,0,0,0,,解释器是一种通用的模拟器\Nis that the interpreter is a general purpose simulator,
Dialogue: 0,0:04:25.66,0:04:27.58,Default,,0,0,0,,当你输入一个Lisp过程时\Nthat when you read in a Lisp procedure
Dialogue: 0,0:04:27.58,0:04:31.08,Default,,0,0,0,,它们就会模拟被那个过程解释的程序\Nthen those can simulate the program described by that, by that procedure.
Dialogue: 0,0:04:31.08,0:04:34.12,Default,,0,0,0,,所以解释器关注的是做出一个通用模拟器\NSo the interpreter is worrying about making a general purpose simulator,
Dialogue: 0,0:04:34.12,0:04:39.68,Default,,0,0,0,,TBD所以解释器关注的是做出一个通用意图的模拟器，而编译器，in effect将东西配置成解释器将要去模拟的机器\Nwhereas the compiler, in effect, is configuring the thing to be the machine that the interpreter would have been simulating.
Dialogue: 0,0:04:39.68,0:04:44.34,Default,,0,0,0,,所以编译器可以运行得更快\NSo the compiler can be faster.
Dialogue: 0,0:04:51.74,0:04:54.78,Default,,0,0,0,,另一方面\NOK, On the other hand,
Dialogue: 0,0:04:54.78,0:04:58.74,Default,,0,0,0,,解释器更适合用来排查错误\Nthe interpreter is a nicer environment for debugging.
Dialogue: 0,0:04:58.74,0:05:01.32,Default,,0,0,0,,因为\NAnd the reason for that is that we've got the
Dialogue: 0,0:05:01.32,0:05:03.02,Default,,0,0,0,,我们的源代码实际上就在那里\Nthe source code actually there.
Dialogue: 0,0:05:03.02,0:05:05.38,Default,,0,0,0,,我们正在解释它们\NWe're interpreting it That's what we're working with.
Dialogue: 0,0:05:05.38,0:05:07.76,Default,,0,0,0,,并且库就在这里\NAnd we also have the library around.
Dialogue: 0,0:05:07.76,0:05:11.02,Default,,0,0,0,,看，这里的库是解释器的一部分\NSee, the interpreter--the library sitting there is part of the interpreter.
Dialogue: 0,0:05:11.02,0:05:14.64,Default,,0,0,0,,而编译器只会把运行程序所需要的代码从库中拉出来\NThe compiler only pulls out from the library what it needs to run the program.
Dialogue: 0,0:05:14.64,0:05:17.52,Default,,0,0,0,,所以，如果你在排查错误的途中\NSo if you're in the middle of debugging,
Dialogue: 0,0:05:17.52,0:05:19.38,Default,,0,0,0,,可能你想写一些\Nand you might like to write
Dialogue: 0,0:05:19.38,0:05:22.82,Default,,0,0,0,,额外的代码来考察运行过程中的数据类型\Na little extra program to examine some run time data structure
Dialogue: 0,0:05:22.82,0:05:25.86,Default,,0,0,0,,或者做一些你在写程序时没有想到的运算\Nor to produce some computation that you didn't think of when you wrote the program
Dialogue: 0,0:05:25.86,0:05:27.82,Default,,0,0,0,,解释器可以完美搞定这些\Nthe interpreter can do that perfectly well,
Dialogue: 0,0:05:27.82,0:05:29.36,Default,,0,0,0,,而编译器不行\Nwhereas the compiler can't.
Dialogue: 0,0:05:29.36,0:05:31.90,Default,,0,0,0,,所以它们各有优点\NSo there are sort of dual, dual advantages.
Dialogue: 0,0:05:31.90,0:05:34.60,Default,,0,0,0,,编译器将生成运行更快的代码\NThe compiler will produce code that executes faster.
Dialogue: 0,0:05:34.60,0:05:37.96,Default,,0,0,0,,而解释器是一种更适合debug的环境\NThe interpreter is a better environment for debugging.
Dialogue: 0,0:05:37.96,0:05:42.36,Default,,0,0,0,,大多数Lisp系统最终将二者都实现了\NAnd most Lisp systems end up having both,
Dialogue: 0,0:05:42.36,0:05:47.08,Default,,0,0,0,,你可以在开发代码是使用解释器\Nend up being configured so you have an interpreter that you use when you're developing your code.
Dialogue: 0,0:05:47.08,0:05:48.82,Default,,0,0,0,,随后通过编译代码来使运行更快\NThen you can speed it up by compiling.
Dialogue: 0,0:05:48.82,0:05:54.12,Default,,0,0,0,,通常你能做到让被编译的代码和被解释的代码互相调用\NAnd very often, you can arrange that compiled code and interpreted code can call each other.
Dialogue: 0,0:05:54.12,0:05:58.58,Default,,0,0,0,,我们将学习如何做到这一点，其实不难\NWe'll see how to do that, That's not hard.
Dialogue: 0,0:05:58.58,0:06:00.34,Default,,0,0,0,,OK
Dialogue: 0,0:06:00.34,0:06:03.08,Default,,0,0,0,,In fact, the way we'll--
Dialogue: 0,0:06:03.08,0:06:05.72,Default,,0,0,0,,in the compiler we're going to make,
Dialogue: 0,0:06:05.72,0:06:08.62,Default,,0,0,0,,the way we'll arrange for compiled coding and interpreted code to call,
Dialogue: 0,0:06:08.62,0:06:09.76,Default,,0,0,0,,to call each other,
Dialogue: 0,0:06:09.76,0:06:11.40,Default,,0,0,0,,is that we'll have the compiler
Dialogue: 0,0:06:11.40,0:06:16.92,Default,,0,0,0,,use exactly the same register conventions as the interpreter.
Dialogue: 0,0:06:16.92,0:06:25.76,Default,,0,0,0,,编译器的思路和解释器或执行器很像\NWell, the idea of a compiler is very much like the idea of an interpreter or evaluator.
Dialogue: 0,0:06:25.76,0:06:26.86,Default,,0,0,0,,它们是相同的东西\NIt's the same thing.
Dialogue: 0,0:06:26.86,0:06:29.60,Default,,0,0,0,,求值器读取代码\NSee, the evaluator walks over the code
Dialogue: 0,0:06:29.60,0:06:32.92,Default,,0,0,0,,产生一些寄存器操作\Nand performs some register operations.
Dialogue: 0,0:06:32.92,0:06:36.10,Default,,0,0,0,,就是我们昨天做的事情\NThat's what we did yesterday.
Dialogue: 0,0:06:36.10,0:06:40.34,Default,,0,0,0,,而编译器会读取代码\NWell, the compiler essentially would like to walk over the code
Dialogue: 0,0:06:40.34,0:06:47.70,Default,,0,0,0,,生成一些求值器在求值时所做事情的寄存器操作\Nand produce the register operations that the evaluator would have done were it evaluating the thing.
Dialogue: 0,0:06:47.70,0:06:54.60,Default,,0,0,0,,这给我们了实现一个zeroth-order编译器的模型\NAnd that gives us a model for how to implement a zeroth-order compiler,
Dialogue: 0,0:06:54.60,0:06:58.32,Default,,0,0,0,,一个很差的编译器，但TBD大体上是个编译器\Na very bad compiler but essentially a compiler.
Dialogue: 0,0:06:58.32,0:07:02.30,Default,,0,0,0,,这种模型就是，你用求值器把代码跑一遍\NA model for doing that is you just take the evaluator, you run it over the code,
Dialogue: 0,0:07:02.30,0:07:06.06,Default,,0,0,0,,但不去执行实际的操作\Nbut instead of executing the actual operations,
Dialogue: 0,0:07:06.06,0:07:07.32,Default,,0,0,0,,只是把它们保存下来\Nyou just save them away.
Dialogue: 0,0:07:07.32,0:07:11.52,Default,,0,0,0,,这就是你编译后的代码 举个例子\NAnd that's your compiled code. So let me give you an example of that.
Dialogue: 0,0:07:11.52,0:07:14.62,Default,,0,0,0,,假设我们要编译\NSuppose we're going to compile--
Dialogue: 0,0:07:14.62,0:07:21.48,Default,,0,0,0,,假设我们要编译，假设我们想编译这个表达式(F X)
Dialogue: 0,0:07:21.48,0:07:24.36,Default,,0,0,0,,
Dialogue: 0,0:07:24.36,0:07:29.74,Default,,0,0,0,,So let's assume that we've got f of x in the x register and something in the environment register.
Dialogue: 0,0:07:29.74,0:07:32.48,Default,,0,0,0,,想象我们启动了执行器\NAnd now imagine starting up the evaluator.
Dialogue: 0,0:07:32.48,0:07:37.62,Default,,0,0,0,,它读取了表达式，它认为这是个应用\NWell, it looks at the expression and it sees that it's an application.
Dialogue: 0,0:07:37.62,0:07:46.28,Default,,0,0,0,,它分叉到求值器的一个地方，我们之前见过的叫ev-application的地方\NAnd it branches to a place in the evaluator code we saw called ev-application.
Dialogue: 0,0:07:46.28,0:07:50.08,Default,,0,0,0,,它将操作数和unev保存\NAnd then it begins. It stores away the operands and unev,
Dialogue: 0,0:07:50.08,0:07:54.36,Default,,0,0,0,,然后之后它将操作符放在exp里，用来递归执行\Nand it's going to go recursively evaluate it.
Dialogue: 0,0:07:54.36,0:07:56.36,Default,,0,0,0,,这就是我们经历的过程\NThat's the process that we walk through.
Dialogue: 0,0:07:56.36,0:07:59.88,Default,,0,0,0,,你如果看代码，会看到一些寄存器操作\NAnd if you start looking at the code, you start seeing some register operations.
Dialogue: 0,0:07:59.88,0:08:02.94,Default,,0,0,0,,你会看到对unev的操作数TBD\NYou see assign to unev the operands,
Dialogue: 0,0:08:02.94,0:08:07.16,Default,,0,0,0,,TBD引用exp的操作符，保存环境，生成它，之类的\Nassign to exp the operator, save the environment, generate that, and so on.
Dialogue: 0,0:08:07.16,0:08:09.46,Default,,0,0,0,,
Dialogue: 0,0:08:09.46,0:08:12.88,Default,,0,0,0,,如果我们研究这里的性能消耗\NWell, if we look on the overhead here,
Dialogue: 0,0:08:14.84,0:08:20.52,Default,,0,0,0,,会发现这些操作被生成出来\Nwe can see those operations starting to be produced.
Dialogue: 0,0:08:20.52,0:08:24.88,Default,,0,0,0,,这是求值器第一个本来要做的实际操作\NHere's sort of the first real operation that the evaluator would have done.
Dialogue: 0,0:08:24.88,0:08:27.30,Default,,0,0,0,,它将操作数从 exp 寄存器里拿出来\NIt pulls the operands out of the exp register
Dialogue: 0,0:08:27.30,0:08:29.30,Default,,0,0,0,,并将它赋值给unev\Nand assigns it to unev.
Dialogue: 0,0:08:29.30,0:08:33.46,Default,,0,0,0,,然后它将某些东西绑定到表达式寄存器, 保存continue \NAnd then it assigns something to the expression register, and it saves continue,
Dialogue: 0,0:08:33.46,0:08:34.62,Default,,0,0,0,,保存env\Nand it saves env.
Dialogue: 0,0:08:34.62,0:08:39.24,Default,,0,0,0,,我们在这做的就是写下\NAnd all I'm doing here is writing down the register assignments
Dialogue: 0,0:08:39.24,0:08:42.54,Default,,0,0,0,,在求值时会进行的寄存器赋值操作\Nthat the evaluator would have done in executing that code.
Dialogue: 0,0:08:42.54,0:08:44.06,Default,,0,0,0,,我们缩小画面看看\NAnd can zoom out a little bit.
Dialogue: 0,0:08:44.06,0:08:48.48,Default,,0,0,0,,总计有19个操作\NAltogether, there are about 19 operations there.
Dialogue: 0,0:08:48.48,0:08:51.80,Default,,0,0,0,,And this is the--this will be the piece of code
Dialogue: 0,0:08:51.80,0:08:57.48,Default,,0,0,0,,up until the point where the evaluator branches off to apply-dispatch.
Dialogue: 0,0:08:57.48,0:08:59.42,Default,,0,0,0,,事实上，在这个编译器中\NAnd in fact, in this compiler,
Dialogue: 0,0:08:59.42,0:09:01.30,Default,,0,0,0,,我们不需要再关心apply-dispatch了\Nwe're not going to worry about apply-dispatch at all.
Dialogue: 0,0:09:01.30,0:09:02.28,Default,,0,0,0,,我们有所有东西We're going to have everything
Dialogue: 0,0:09:02.28,0:09:05.50,Default,,0,0,0,,我们拥有解释后代码和编译后代码\Nwe're going to have both interpreted code and compiled code.
Dialogue: 0,0:09:05.50,0:09:10.04,Default,,0,0,0,,通常求值过程，通常应用过程是由apply-dispatch处理的\NAlways evaluate procedures, always apply procedures by going to apply-dispatch.
Dialogue: 0,0:09:10.04,0:09:15.50,Default,,0,0,0,,这将让被解释后代码与编译后代码很很容易互相调用\NThat will easily allow interpreted code and compiled code to call each other.\N
Dialogue: 0,0:09:15.50,0:09:17.58,Default,,0,0,0,,
Dialogue: 0,0:09:17.58,0:09:20.52,Default,,0,0,0,,从原则上来说，这就是我们要做的一切\NWell, in principle, that's all we need to do.
Dialogue: 0,0:09:20.52,0:09:22.66,Default,,0,0,0,,你只是运行求值器\NYou just run the evaluator.
Dialogue: 0,0:09:22.66,0:09:24.98,Default,,0,0,0,,因而编译器非常像求值器\NSo the compiler's a lot like the evaluator.
Dialogue: 0,0:09:24.98,0:09:28.86,Default,,0,0,0,,你运行它，唯一不同是你把操作存下来，而不是实际执行它们You run it, except it stashes away these operations instead of actually executing them.
Dialogue: 0,0:09:28.86,0:09:32.06,Default,,0,0,0,,这其实不完全正确\NWell, that's not, that's not quite true.
Dialogue: 0,0:09:32.06,0:09:35.76,Default,,0,0,0,,这里面我们撒了个小谎\NThere's only one little lie in that.
Dialogue: 0,0:09:35.76,0:09:39.76,Default,,0,0,0,,你需要关心的是如果你有\NWhat you have to worry about is if you have a, a predicate.
Dialogue: 0,0:09:39.76,0:09:43.00,Default,,0,0,0,,如果你有某种测试需要做\NIf you have some kind of test you want to do,
Dialogue: 0,0:09:43.00,0:09:46.24,Default,,0,0,0,,显然，在你编译时\Nobviously, at the point when you're compiling it,
Dialogue: 0,0:09:46.24,0:09:50.68,Default,,0,0,0,,你并不能知道哪个分支需要执行\Nyou don't know which branch of these--of a conditional like this you're going to do.
Dialogue: 0,0:09:50.68,0:09:54.44,Default,,0,0,0,,所以你不能确定求值器将执行哪个\NSo you can't say which one the evaluator would have done.
Dialogue: 0,0:09:54.44,0:09:56.22,Default,,0,0,0,,在这里要做的很简单\NSo all you do there is very simple.
Dialogue: 0,0:09:56.22,0:09:59.06,Default,,0,0,0,,你编译全部分支\NYou compile both branches.
Dialogue: 0,0:09:59.06,0:10:01.62,Default,,0,0,0,,因此你编译一个这样的结构\NSo you compile a structure that looks like this.
Dialogue: 0,0:10:01.62,0:10:10.02,Default,,0,0,0,,他们都会被编译成P的代码\NThat'll compile into something that says, the code, the code for P.
