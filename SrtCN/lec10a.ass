[Script Info]
; Script generated by Aegisub 3.2.1
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 712
PlayResY: 360

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Movies/Lec10a.mp4
Video File: ../../../Movies/Lec10a.mp4
Video AR Mode: 1
Video AR Value: 1.333333
Video Zoom Percent: 0.750000
Scroll Position: 305
Active Line: 321
Video Position: 36565

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,.PingFang SC,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:19.36,0:00:22.26,Default,,0,0,0,,教授: 上节课 我们学习了\NPROFESSOR: Last time, we took a look at
Dialogue: 0,0:00:22.26,0:00:25.54,Default,,0,0,0,,一个Lisp 显式控制求值器\Nan explicit control evaluator for Lisp,
Dialogue: 0,0:00:25.54,0:00:32.32,Default,,0,0,0,,它在如Lisp或查询语言等高级语言\Nand that bridged the gap between all these high-level languages
Dialogue: 0,0:00:32.32,0:00:36.40,Default,,0,0,0,,与传统的寄存器机器之间架起了桥梁\Nbridged the gap between that and a conventional register machine.
Dialogue: 0,0:00:36.40,0:00:42.46,Default,,0,0,0,,事实上 你可以将显式控制求值器\NAnd in fact, you can think of the explicit control evaluator either as, say,
Dialogue: 0,0:00:42.46,0:00:55.20,Default,,0,0,0,,#TBD \Nthe code for a Lisp interpreter if you wanted to implement it in the assembly language of some conventional register transfer machine, or, if you like, you can think of it as the microcode of some machine that's going to be specially designed to run Lisp.
Dialogue: 0,0:00:55.20,0:01:00.92,Default,,0,0,0,,在任何一种情况下 我们得到一种能够处理低级语言的机器\NIn either case, what we're doing is we're taking a machine that speaks some low-level language,
Dialogue: 0,0:01:00.92,0:01:07.26,Default,,0,0,0,,通过写一个解释器来让它能够执行像Lisp之类的高级语言\Nand we're raising the machine to a high-level language like Lisp by writing an interpreter.
Dialogue: 0,0:01:07.26,0:01:11.00,Default,,0,0,0,,来看个例子\NSo for instance,
Dialogue: 0,0:01:11.00,0:01:23.84,Default,,0,0,0,,这是一个概念上的 用于计算阶乘的专用机器\N here, conceptually, is a special purpose machine for computing factorials.
Dialogue: 0,0:01:23.84,0:01:28.26,Default,,0,0,0,,输入5 输出120 \NIt takes in five and puts out 120.
Dialogue: 0,0:01:28.26,0:01:33.16,Default,,0,0,0,,这个专用机器实际上是一个Lisp解释器\NAnd what this special purpose machine is actually a Lisp interpreter
Dialogue: 0,0:01:33.16,0:01:37.48,Default,,0,0,0,,它将自己设置为运行阶乘\Nthat's configured itself to run factorials,
Dialogue: 0,0:01:37.48,0:01:41.66,Default,,0,0,0,,因为你喂给它了阶乘机器的描述\Nbecause you feed into it a description of the factorial machine.
Dialogue: 0,0:01:41.66,0:01:43.70,Default,,0,0,0,,这就是解释器\NSo that's what an interpreter is.
Dialogue: 0,0:01:43.70,0:01:49.68,Default,,0,0,0,,它将自己设置为 模拟你所输入描述的机器\NIt configures itself to emulate a machine whose description you read in.
Dialogue: 0,0:01:49.68,0:01:52.04,Default,,0,0,0,,在Lisp解释器里是什么? \NNow, inside the Lisp interpreter, what's that?
Dialogue: 0,0:01:52.04,0:01:56.42,Default,,0,0,0,,里面可能是通用的寄存器语言解释器\NWell, that might be your general register language interpreter
Dialogue: 0,0:01:56.42,0:02:00.18,Default,,0,0,0,,它将自己设置为像Lisp解释器一样工作\Nthat configures itself to behave like a Lisp interpreter,
Dialogue: 0,0:02:00.18,0:02:03.24,Default,,0,0,0,,因为你输入了一系列寄存器语言编写的指令\Nbecause you put in a whole bunch of instructions in register language.
Dialogue: 0,0:02:03.24,0:02:06.46,Default,,0,0,0,,这就是显式控制求值器\NThis is the explicit control evaluator.
Dialogue: 0,0:02:06.46,0:02:09.30,Default,,0,0,0,,它也有某种TBD\NAnd then it also has some sort of library,
Dialogue: 0,0:02:09.30,0:02:12.48,Default,,0,0,0,,\Na library of primitive operators and Lisp operations and all sorts of things like that.
Dialogue: 0,0:02:12.48,0:02:17.04,Default,,0,0,0,,这是解释执行的通常策略\NThat's the general strategy of interpretation.
Dialogue: 0,0:02:17.04,0:02:20.88,Default,,0,0,0,,事实上，我们所做的是写了一个解释器\NAnd the point is, what we're doing is we're writing an interpreter
Dialogue: 0,0:02:20.88,0:02:25.24,Default,,0,0,0,,将机器提升到能理解我们写的程序的层次\Nto raise the machine to the level of the programs that we want to write.
Dialogue: 0,0:02:25.24,0:02:27.04,Default,,0,0,0,,也有另一种逻辑\NWell, there's another strategy,
Dialogue: 0,0:02:27.04,0:02:29.04,Default,,0,0,0,,一种不同的策略，就是编译\Na different one, which is compilation.
Dialogue: 0,0:02:29.04,0:02:31.04,Default,,0,0,0,,编译有一些不同\NCompilation's a little bit different.
Dialogue: 0,0:02:31.04,0:02:32.44,Default,,0,0,0,,这里\NHere--
Dialogue: 0,0:02:32.44,0:02:35.16,Default,,0,0,0,,我们可能已经制造了\Nhere we might have produced
Dialogue: 0,0:02:35.16,0:02:42.20,Default,,0,0,0,,一个特定用途的机器，用来计算阶乘\Na special purpose machine for, for computing factorials,
Dialogue: 0,0:02:42.20,0:02:46.26,Default,,0,0,0,,从某种讲寄存器语言的机器开始\Nstarting with some sort of machine that speaks register language,
Dialogue: 0,0:02:46.26,0:02:47.72,Default,,0,0,0,,除此之外，我们将让它执行不同的策略TBD\Nexcept we're going to do a different strategy.
Dialogue: 0,0:02:47.72,0:02:50.98,Default,,0,0,0,,我们拿来阶乘程序\NWe take our factorial program.
Dialogue: 0,0:02:50.98,0:02:53.92,Default,,0,0,0,,我们把这些源代码输入编译器\NWe use that as the source code into a compiler.
Dialogue: 0,0:02:53.92,0:02:56.18,Default,,0,0,0,,编译器将会做的是\NWhat the compiler will do
Dialogue: 0,0:02:56.18,0:02:59.64,Default,,0,0,0,,把这个阶乘程序翻译成某种寄存器机器语言\Nis translate that factorial program into some register machine language.
Dialogue: 0,0:02:59.64,0:03:03.40,Default,,0,0,0,,现在它并不是Lisp的显式控制求值器\NAnd this will now be not the explicit control evaluator for Lisp,
Dialogue: 0,0:03:03.40,0:03:06.34,Default,,0,0,0,,它现在是某种用来计算阶乘的寄存器语言\Nthis will be some register language for computing factorials.
Dialogue: 0,0:03:06.34,0:03:09.16,Default,,0,0,0,,这就是翻译的过程\NSo this is the translation of that.
Dialogue: 0,0:03:09.16,0:03:12.92,Default,,0,0,0,,它将进入某种加载器\NThat will go into some sort of loader
Dialogue: 0,0:03:12.92,0:03:19.36,Default,,0,0,0,,并与从库中选取的乘法之类的代码组合到一起\Nwhich will combine this code with code selected from the library to do things like primitive multiplication.
Dialogue: 0,0:03:19.36,0:03:21.96,Default,,0,0,0,,随后我们将生成一个加载模块\NAnd then we'll produce a load module
Dialogue: 0,0:03:21.96,0:03:25.06,Default,,0,0,0,,它把寄存器语言机器配置成\Nwhich configures the register language machine
Dialogue: 0,0:03:25.06,0:03:27.74,Default,,0,0,0,,一个专门用来计算阶乘的机器\Nto be a special purpose factorial machine.
Dialogue: 0,0:03:27.74,0:03:30.22,Default,,0,0,0,,这就是不同的策略\NSo that's a, that's a different strategy.
Dialogue: 0,0:03:30.22,0:03:32.40,Default,,0,0,0,,在解释中\NIn interpretation, we're raising
Dialogue: 0,0:03:32.40,0:03:35.32,Default,,0,0,0,,我们将机器提升到我们语言的层次，如Lisp\Nthe machine to the level of our language, like Lisp.
Dialogue: 0,0:03:35.32,0:03:36.34,Default,,0,0,0,,在编译中\NIn compilation,
Dialogue: 0,0:03:36.34,0:03:41.24,Default,,0,0,0,,我们将我们的程序降到机器语言的层次\Nwe're taking our program and lowering it to the language that's spoken by the machine.
Dialogue: 0,0:03:41.24,0:03:44.10,Default,,0,0,0,,那么，这两个策略有什么区别呢？\NWell, how do these two strategies compare?
Dialogue: 0,0:03:44.10,0:03:51.02,Default,,0,0,0,,编译器可以生成执行起来更有效率的代码\NThe compiler can produce code that will execute more efficiently.
Dialogue: 0,0:03:51.02,0:03:54.06,Default,,0,0,0,,The essential reason for that is that
Dialogue: 0,0:03:54.06,0:04:00.60,Default,,0,0,0,,if you think about the register operations that are running,
Dialogue: 0,0:04:00.60,0:04:04.82,Default,,0,0,0,,the interpreter has to produce register operations
Dialogue: 0,0:04:04.82,0:04:09.58,Default,,0,0,0,,which, in principle, are going to be general enough to execute any Lisp procedure.
Dialogue: 0,0:04:09.58,0:04:15.16,Default,,0,0,0,,Whereas the compiler only has to worry about producing a special bunch of register operations for,
Dialogue: 0,0:04:15.16,0:04:19.28,Default,,0,0,0,, for doing the particular Lisp procedure that you've compiled.
Dialogue: 0,0:04:19.28,0:04:21.24,Default,,0,0,0,,换一种说法\NOr another way to say that
Dialogue: 0,0:04:22.66,0:04:25.66,Default,,0,0,0,,解释器是一种通用的模拟器\Nis that the interpreter is a general purpose simulator,
Dialogue: 0,0:04:25.66,0:04:27.58,Default,,0,0,0,,当你输入一个Lisp过程时\Nthat when you read in a Lisp procedure
Dialogue: 0,0:04:27.58,0:04:31.08,Default,,0,0,0,,它们就会模拟被那个过程解释的程序\Nthen those can simulate the program described by that, by that procedure.
Dialogue: 0,0:04:31.08,0:04:34.12,Default,,0,0,0,,所以解释器关注的是做出一个通用模拟器\NSo the interpreter is worrying about making a general purpose simulator,
Dialogue: 0,0:04:34.12,0:04:39.68,Default,,0,0,0,,TBD所以解释器关注的是做出一个通用意图的模拟器，而编译器，in effect将东西配置成解释器将要去模拟的机器\Nwhereas the compiler, in effect, is configuring the thing to be the machine that the interpreter would have been simulating.
Dialogue: 0,0:04:39.68,0:04:44.34,Default,,0,0,0,,所以编译器可以运行得更快\NSo the compiler can be faster.
Dialogue: 0,0:04:51.74,0:04:54.78,Default,,0,0,0,,另一方面\NOK, On the other hand,
Dialogue: 0,0:04:54.78,0:04:58.74,Default,,0,0,0,,解释器更适合用来排查错误\Nthe interpreter is a nicer environment for debugging.
Dialogue: 0,0:04:58.74,0:05:01.32,Default,,0,0,0,,因为\NAnd the reason for that is that we've got the
Dialogue: 0,0:05:01.32,0:05:03.02,Default,,0,0,0,,我们的源代码实际上就在那里\Nthe source code actually there.
Dialogue: 0,0:05:03.02,0:05:05.38,Default,,0,0,0,,我们正在解释它们\NWe're interpreting it That's what we're working with.
Dialogue: 0,0:05:05.38,0:05:07.76,Default,,0,0,0,,并且库就在这里\NAnd we also have the library around.
Dialogue: 0,0:05:07.76,0:05:11.02,Default,,0,0,0,,看，这里的库是解释器的一部分\NSee, the interpreter--the library sitting there is part of the interpreter.
Dialogue: 0,0:05:11.02,0:05:14.64,Default,,0,0,0,,而编译器只会把运行程序所需要的代码从库中拉出来\NThe compiler only pulls out from the library what it needs to run the program.
Dialogue: 0,0:05:14.64,0:05:17.52,Default,,0,0,0,,所以，如果你在排查错误的途中\NSo if you're in the middle of debugging,
Dialogue: 0,0:05:17.52,0:05:19.38,Default,,0,0,0,,可能你想写一些\Nand you might like to write
Dialogue: 0,0:05:19.38,0:05:22.82,Default,,0,0,0,,额外的代码来考察运行过程中的数据类型\Na little extra program to examine some run time data structure
Dialogue: 0,0:05:22.82,0:05:25.86,Default,,0,0,0,,或者做一些你在写程序时没有想到的运算\Nor to produce some computation that you didn't think of when you wrote the program
Dialogue: 0,0:05:25.86,0:05:27.82,Default,,0,0,0,,解释器可以完美搞定这些\Nthe interpreter can do that perfectly well,
Dialogue: 0,0:05:27.82,0:05:29.36,Default,,0,0,0,,而编译器不行\Nwhereas the compiler can't.
Dialogue: 0,0:05:29.36,0:05:31.90,Default,,0,0,0,,所以它们各有优点\NSo there are sort of dual, dual advantages.
Dialogue: 0,0:05:31.90,0:05:34.60,Default,,0,0,0,,编译器将生成运行更快的代码\NThe compiler will produce code that executes faster.
Dialogue: 0,0:05:34.60,0:05:37.96,Default,,0,0,0,,而解释器是一种更适合debug的环境\NThe interpreter is a better environment for debugging.
Dialogue: 0,0:05:37.96,0:05:42.36,Default,,0,0,0,,大多数Lisp系统最终将二者都实现了\NAnd most Lisp systems end up having both,
Dialogue: 0,0:05:42.36,0:05:47.08,Default,,0,0,0,,你可以在开发代码是使用解释器\Nend up being configured so you have an interpreter that you use when you're developing your code.
Dialogue: 0,0:05:47.08,0:05:48.82,Default,,0,0,0,,随后通过编译代码来使运行更快\NThen you can speed it up by compiling.
Dialogue: 0,0:05:48.82,0:05:54.12,Default,,0,0,0,,通常你能做到让被编译的代码和被解释的代码互相调用\NAnd very often, you can arrange that compiled code and interpreted code can call each other.
Dialogue: 0,0:05:54.12,0:05:58.58,Default,,0,0,0,,我们将学习如何做到这一点，其实不难\NWe'll see how to do that, That's not hard.
Dialogue: 0,0:05:58.58,0:06:00.34,Default,,0,0,0,,OK
Dialogue: 0,0:06:00.34,0:06:03.08,Default,,0,0,0,,In fact, the way we'll--
Dialogue: 0,0:06:03.08,0:06:05.72,Default,,0,0,0,,in the compiler we're going to make,
Dialogue: 0,0:06:05.72,0:06:08.62,Default,,0,0,0,,the way we'll arrange for compiled coding and interpreted code to call,
Dialogue: 0,0:06:08.62,0:06:09.76,Default,,0,0,0,,to call each other,
Dialogue: 0,0:06:09.76,0:06:11.40,Default,,0,0,0,,is that we'll have the compiler
Dialogue: 0,0:06:11.40,0:06:16.92,Default,,0,0,0,,use exactly the same register conventions as the interpreter.
Dialogue: 0,0:06:16.92,0:06:25.76,Default,,0,0,0,,编译器的思路和解释器或执行器很像\NWell, the idea of a compiler is very much like the idea of an interpreter or evaluator.
Dialogue: 0,0:06:25.76,0:06:26.86,Default,,0,0,0,,它们是相同的东西\NIt's the same thing.
Dialogue: 0,0:06:26.86,0:06:29.60,Default,,0,0,0,,求值器读取代码\NSee, the evaluator walks over the code
Dialogue: 0,0:06:29.60,0:06:32.92,Default,,0,0,0,,产生一些寄存器操作\Nand performs some register operations.
Dialogue: 0,0:06:32.92,0:06:36.10,Default,,0,0,0,,就是我们昨天做的事情\NThat's what we did yesterday.
Dialogue: 0,0:06:36.10,0:06:40.34,Default,,0,0,0,,而编译器会读取代码\NWell, the compiler essentially would like to walk over the code
Dialogue: 0,0:06:40.34,0:06:47.70,Default,,0,0,0,,生成一些求值器在求值时所做事情的寄存器操作\Nand produce the register operations that the evaluator would have done were it evaluating the thing.
Dialogue: 0,0:06:47.70,0:06:54.60,Default,,0,0,0,,这给我们了实现一个zeroth-order编译器的模型\NAnd that gives us a model for how to implement a zeroth-order compiler,
Dialogue: 0,0:06:54.60,0:06:58.32,Default,,0,0,0,,一个很差的编译器，但TBD大体上是个编译器\Na very bad compiler but essentially a compiler.
Dialogue: 0,0:06:58.32,0:07:02.30,Default,,0,0,0,,这种模型就是，你用求值器把代码跑一遍\NA model for doing that is you just take the evaluator, you run it over the code,
Dialogue: 0,0:07:02.30,0:07:06.06,Default,,0,0,0,,但不去执行实际的操作\Nbut instead of executing the actual operations,
Dialogue: 0,0:07:06.06,0:07:07.32,Default,,0,0,0,,只是把它们保存下来\Nyou just save them away.
Dialogue: 0,0:07:07.32,0:07:11.52,Default,,0,0,0,,这就是你编译后的代码 举个例子\NAnd that's your compiled code. So let me give you an example of that.
Dialogue: 0,0:07:11.52,0:07:14.62,Default,,0,0,0,,假设我们要编译\NSuppose we're going to compile--
Dialogue: 0,0:07:14.62,0:07:21.48,Default,,0,0,0,,假设我们要编译，假设我们想编译这个表达式(F X)
Dialogue: 0,0:07:21.48,0:07:24.36,Default,,0,0,0,,
Dialogue: 0,0:07:24.36,0:07:29.74,Default,,0,0,0,,So let's assume that we've got f of x in the x register and something in the environment register.
Dialogue: 0,0:07:29.74,0:07:32.48,Default,,0,0,0,,想象我们启动了执行器\NAnd now imagine starting up the evaluator.
Dialogue: 0,0:07:32.48,0:07:37.62,Default,,0,0,0,,它读取了表达式，它认为这是个应用\NWell, it looks at the expression and it sees that it's an application.
Dialogue: 0,0:07:37.62,0:07:46.28,Default,,0,0,0,,它分叉到求值器的一个地方，我们之前见过的叫ev-application的地方\NAnd it branches to a place in the evaluator code we saw called ev-application.
Dialogue: 0,0:07:46.28,0:07:50.08,Default,,0,0,0,,它将操作数和unev保存\NAnd then it begins. It stores away the operands and unev,
Dialogue: 0,0:07:50.08,0:07:54.36,Default,,0,0,0,,然后之后它将操作符放在exp里，用来递归执行\Nand it's going to go recursively evaluate it.
Dialogue: 0,0:07:54.36,0:07:56.36,Default,,0,0,0,,这就是我们经历的过程\NThat's the process that we walk through.
Dialogue: 0,0:07:56.36,0:07:59.88,Default,,0,0,0,,你如果看代码，会看到一些寄存器操作\NAnd if you start looking at the code, you start seeing some register operations.
Dialogue: 0,0:07:59.88,0:08:02.94,Default,,0,0,0,,你会看到对unev的操作数TBD\NYou see assign to unev the operands,
Dialogue: 0,0:08:02.94,0:08:07.16,Default,,0,0,0,,TBD引用exp的操作符，保存环境，生成它，之类的\Nassign to exp the operator, save the environment, generate that, and so on.
Dialogue: 0,0:08:07.16,0:08:09.46,Default,,0,0,0,,
Dialogue: 0,0:08:09.46,0:08:12.88,Default,,0,0,0,,如果我们研究这里的性能消耗\NWell, if we look on the overhead here,
Dialogue: 0,0:08:14.84,0:08:20.52,Default,,0,0,0,,会发现这些操作被生成出来\Nwe can see those operations starting to be produced.
Dialogue: 0,0:08:20.52,0:08:24.88,Default,,0,0,0,,这是求值器第一个本来要做的实际操作\NHere's sort of the first real operation that the evaluator would have done.
Dialogue: 0,0:08:24.88,0:08:27.30,Default,,0,0,0,,它将操作数从 exp 寄存器里拿出来\NIt pulls the operands out of the exp register
Dialogue: 0,0:08:27.30,0:08:29.30,Default,,0,0,0,,并将它赋值给unev\Nand assigns it to unev.
Dialogue: 0,0:08:29.30,0:08:33.46,Default,,0,0,0,,然后它将某些东西绑定到表达式寄存器, 保存continue \NAnd then it assigns something to the expression register, and it saves continue,
Dialogue: 0,0:08:33.46,0:08:34.62,Default,,0,0,0,,保存env\Nand it saves env.
Dialogue: 0,0:08:34.62,0:08:39.24,Default,,0,0,0,,我们在这做的就是写下\NAnd all I'm doing here is writing down the register assignments
Dialogue: 0,0:08:39.24,0:08:42.54,Default,,0,0,0,,在求值时会进行的寄存器赋值操作\Nthat the evaluator would have done in executing that code.
Dialogue: 0,0:08:42.54,0:08:44.06,Default,,0,0,0,,我们缩小画面看看\NAnd can zoom out a little bit.
Dialogue: 0,0:08:44.06,0:08:48.48,Default,,0,0,0,,总计有19个操作\NAltogether, there are about 19 operations there.
Dialogue: 0,0:08:48.48,0:08:51.80,Default,,0,0,0,,And this is the--this will be the piece of code
Dialogue: 0,0:08:51.80,0:08:57.48,Default,,0,0,0,,up until the point where the evaluator branches off to apply-dispatch.
Dialogue: 0,0:08:57.48,0:08:59.42,Default,,0,0,0,,事实上，在这个编译器中\NAnd in fact, in this compiler,
Dialogue: 0,0:08:59.42,0:09:01.30,Default,,0,0,0,,我们不需要再关心apply-dispatch了\Nwe're not going to worry about apply-dispatch at all.
Dialogue: 0,0:09:01.30,0:09:02.28,Default,,0,0,0,,我们有所有东西We're going to have everything
Dialogue: 0,0:09:02.28,0:09:05.50,Default,,0,0,0,,我们拥有解释后代码和编译后代码\Nwe're going to have both interpreted code and compiled code.
Dialogue: 0,0:09:05.50,0:09:10.04,Default,,0,0,0,,通常求值过程，通常应用过程是由apply-dispatch处理的\NAlways evaluate procedures, always apply procedures by going to apply-dispatch.
Dialogue: 0,0:09:10.04,0:09:15.50,Default,,0,0,0,,这将让被解释后代码与编译后代码很很容易互相调用\NThat will easily allow interpreted code and compiled code to call each other.\N
Dialogue: 0,0:09:15.50,0:09:17.58,Default,,0,0,0,,
Dialogue: 0,0:09:17.58,0:09:20.52,Default,,0,0,0,,从原则上来说，这就是我们要做的一切\NWell, in principle, that's all we need to do.
Dialogue: 0,0:09:20.52,0:09:22.66,Default,,0,0,0,,你只是运行求值器\NYou just run the evaluator.
Dialogue: 0,0:09:22.66,0:09:24.98,Default,,0,0,0,,因而编译器非常像求值器\NSo the compiler's a lot like the evaluator.
Dialogue: 0,0:09:24.98,0:09:28.86,Default,,0,0,0,,你运行它，唯一不同是你把操作存下来，而不是实际执行它们You run it, except it stashes away these operations instead of actually executing them.
Dialogue: 0,0:09:28.86,0:09:32.06,Default,,0,0,0,,这其实不完全正确\NWell, that's not, that's not quite true.
Dialogue: 0,0:09:32.06,0:09:35.76,Default,,0,0,0,,这里面我们撒了个小谎\NThere's only one little lie in that.
Dialogue: 0,0:09:35.76,0:09:39.76,Default,,0,0,0,,你需要关心的是如果你有\NWhat you have to worry about is if you have a, a predicate.
Dialogue: 0,0:09:39.76,0:09:43.00,Default,,0,0,0,,如果你有某种测试需要做\NIf you have some kind of test you want to do,
Dialogue: 0,0:09:43.00,0:09:46.24,Default,,0,0,0,,显然，在你编译时\Nobviously, at the point when you're compiling it,
Dialogue: 0,0:09:46.24,0:09:50.68,Default,,0,0,0,,你并不能知道哪个分支需要执行\Nyou don't know which branch of these--of a conditional like this you're going to do.
Dialogue: 0,0:09:50.68,0:09:54.44,Default,,0,0,0,,所以你不能确定求值器将执行哪个\NSo you can't say which one the evaluator would have done.
Dialogue: 0,0:09:54.44,0:09:56.22,Default,,0,0,0,,在这里要做的很简单\NSo all you do there is very simple.
Dialogue: 0,0:09:56.22,0:09:59.06,Default,,0,0,0,,你编译全部分支\NYou compile both branches.
Dialogue: 0,0:09:59.06,0:10:01.62,Default,,0,0,0,,因此你编译一个这样的结构\NSo you compile a structure that looks like this.
Dialogue: 0,0:10:01.62,0:10:10.02,Default,,0,0,0,,他们都会被编译成P的代码\NThat'll compile into something that says, the code, the code for P.
Dialogue: 0,0:10:10.02,0:10:18.86,Default,,0,0,0,,And it puts its results in, say, the val register.
Dialogue: 0,0:10:18.86,0:10:20.98,Default,,0,0,0,,So you walk the interpreter over the predicate
Dialogue: 0,0:10:20.98,0:10:24.40,Default,,0,0,0,,and make sure that the result would go into the val register.
Dialogue: 0,0:10:24.40,0:10:27.22,Default,,0,0,0,,And then you compile an instruction that says,
Dialogue: 0,0:10:27.22,0:10:36.82,Default,,0,0,0,,branch if, if val is true,
Dialogue: 0,0:10:36.82,0:10:43.72,Default,,0,0,0,,to a place we'll call label one.
Dialogue: 0,0:10:44.56,0:10:53.16,Default,,0,0,0,,Then we, we will put the code for B to walk the interpreter--walk the interpreter over B.
Dialogue: 0,0:10:53.16,0:11:01.88,Default,,0,0,0,,And then go to put in an instruction that says, go to the next thing, whatever,
Dialogue: 0,0:11:01.88,0:11:04.68,Default,,0,0,0,,whatever was supposed to happen after this thing was done.
Dialogue: 0,0:11:04.68,0:11:06.52,Default,,0,0,0,,你放入那个指令\NYou put in that instruction.
Dialogue: 0,0:11:06.52,0:11:11.22,Default,,0,0,0,,这里你放入label one\NAnd here you put label one.
Dialogue: 0,0:11:11.22,0:11:16.62,Default,,0,0,0,,And here you put the code for A.
Dialogue: 0,0:11:16.62,0:11:18.62,Default,,0,0,0,,
Dialogue: 0,0:11:18.62,0:11:29.82,Default,,0,0,0,,And you put go to next thing.
Dialogue: 0,0:11:30.40,0:11:32.98,Default,,0,0,0,,这就是处理条件分支的办法\NSo that's how you treat a conditional.
Dialogue: 0,0:11:32.98,0:11:35.32,Default,,0,0,0,,你生成这样一小块代码\NYou generate a little block like that.
Dialogue: 0,0:11:35.32,0:11:38.66,Default,,0,0,0,,除此之外\NAnd other than that,
Dialogue: 0,0:11:38.66,0:11:42.04,Default,,0,0,0,,编译器与求值器一模一样\Nthis zeroth-order compiler is the same as the evaluator.
Dialogue: 0,0:11:42.04,0:11:45.86,Default,,0,0,0,,它只是把指令存起来而不是执行它们\NIt's just stashing away the instructions instead of executing them.
Dialogue: 0,0:11:45.86,0:11:49.64,Default,,0,0,0,,看起来肯简单，但我们已经因此有了一些收获\NThat seems pretty simple, but we've gained something by that.
Dialogue: 0,0:11:49.64,0:11:53.14,Default,,0,0,0,,它会比求值器更有效率\NSee, already that's going to be more efficient than the evaluator.
Dialogue: 0,0:11:53.14,0:11:56.16,Default,,0,0,0,,因为，如果你观察求值器的运行\NBecause, if you watch the evaluator run,
Dialogue: 0,0:11:56.16,0:12:01.10,Default,,0,0,0,,它并不只是生成我们写下的注册操作\Nit's not only generating the register operations we wrote down,
Dialogue: 0,0:12:01.10,0:12:04.30,Default,,0,0,0,,它还会决定生成哪个\Nit's also doing things to decide which ones to generate.
Dialogue: 0,0:12:04.30,0:12:07.58,Default,,0,0,0,,它做的第一件事就是\NSo the very first thing it does, say,
Dialogue: 0,0:12:07.58,0:12:12.64,Default,,0,0,0,,here for instance, is go do some tests and decide that this is an application,
Dialogue: 0,0:12:12.64,0:12:16.62,Default,,0,0,0,,and then branch off to the place that, that handles applications.
Dialogue: 0,0:12:16.62,0:12:18.62,Default,,0,0,0,,换句话说，求值器做的事情是\NIn other words, what the evaluator's doing
Dialogue: 0,0:12:18.62,0:12:23.08,Default,,0,0,0,,在分析代码看看需要做什么的同时\Nis simultaneously analyzing the code to see what to do,
Dialogue: 0,0:12:23.08,0:12:25.08,Default,,0,0,0,,运行这些操作\Nand running these operations.
Dialogue: 0,0:12:25.08,0:12:28.28,Default,,0,0,0,,当你运行求值器一百万次\NAnd when you-- if you run the evaluator a million times
Dialogue: 0,0:12:28.28,0:12:30.58,Default,,0,0,0,,这个分析过程就进行一百万次\Nthat analysis phase happens a million times
Dialogue: 0,0:12:30.58,0:12:32.58,Default,,0,0,0,,而在编译器中它只会进行一次\Nwhereas in the compiler, it's happened once
Dialogue: 0,0:12:32.58,0:12:35.58,Default,,0,0,0,,之后就只有寄存器操作了\Nand then you just have the register operations themselves.
Dialogue: 0,0:12:35.58,0:12:38.66,Default,,0,0,0,,
Dialogue: 0,0:12:38.66,0:12:41.66,Default,,0,0,0,,这就是零阶编译器TBD\NOk, that's a, a zeroth-order compiler
Dialogue: 0,0:12:41.66,0:12:44.16,Default,,0,0,0,,但它是个很挫的编译器\Nbut it is a wretched, wretched compiler.
Dialogue: 0,0:12:44.16,0:12:46.16,Default,,0,0,0,,它很蠢\NIt's really dumb.
Dialogue: 0,0:12:46.56,0:12:51.56,Default,,0,0,0,,让我们回来，TBD\NLet's--let's go back and, and look at this overhead.
Dialogue: 0,0:12:51.56,0:12:55.46,Default,,0,0,0,,看看这个东西做的一些操作\NSo look at look at some of the operations this thing is doing.\N
Dialogue: 0,0:12:55.46,0:13:02.96,Default,,0,0,0,,我们想看看 (F  X) 的操作和解释过程\NWe're supposedly looking at the operations and interpreting f of x.
Dialogue: 0,0:13:02.96,0:13:04.96,Default,,0,0,0,,这里就是它做了什么\NNow, look here what it's doing.
Dialogue: 0,0:13:04.96,0:13:06.96,Default,,0,0,0,,举个例子，这里\NFor example, here
Dialogue: 0,0:13:06.96,0:13:12.94,Default,,0,0,0,,它将(operator (fetch exp))赋值给 exp\Nit assigns to exp the operator in fetch of exp.
Dialogue: 0,0:13:12.94,0:13:16.00,Default,,0,0,0,,看，没理由干这个\NBut see, there's no reason to do that, because this is--
Dialogue: 0,0:13:16.00,0:13:22.50,Default,,0,0,0,,因为编译器知道(operator (fetch exp))在这里就是F\Nthe compiler knows that the operator, fetch of exp, is f right here.
Dialogue: 0,0:13:22.50,0:13:25.70,Default,,0,0,0,,因此这个指令没理由存在\NSo there's no reason why this instruction should say that.
Dialogue: 0,0:13:25.70,0:13:29.18,Default,,0,0,0,,它应该表达，我们要把F赋值给exp\NIt should say, we'll assign to exp, f.
Dialogue: 0,0:13:29.18,0:13:31.46,Default,,0,0,0,,或者实际上，你完全不需要exp\NOr in fact, you don't need exp at all.
Dialogue: 0,0:13:31.46,0:13:33.56,Default,,0,0,0,,没有理由显示需要exp\NThere's no reason it should have exp at all.
Dialogue: 0,0:13:33.56,0:13:37.00,Default,,0,0,0,,exp是用来做什么的？我们看这里\NWhat, what did exp get used for? Well, if we come down here
Dialogue: 0,0:13:37.00,0:13:40.12,Default,,0,0,0,,
Dialogue: 0,0:13:40.12,0:13:42.62,Default,,0,0,0,,我们对val赋值\Nwe're going to assign to val
Dialogue: 0,0:13:42.62,0:13:47.98,Default,,0,0,0,,在环境里的exp里寻找东西\Nlook up the stuff in exp in the environment.
Dialogue: 0,0:13:47.98,0:13:51.54,Default,,0,0,0,,因此在这里我们实际上要做的是TBD\NSo what we really should do is get rid of the exp register altogether
Dialogue: 0,0:13:51.54,0:13:54.30,Default,,0,0,0,,只修改指令为，引用val\Nand just change this instruction to say, assign to val,
Dialogue: 0,0:13:54.30,0:13:59.42,Default,,0,0,0,,在环境中查找符号f的值\Nlook up the variable value of the symbol f in the environment.
Dialogue: 0,0:13:59.42,0:14:02.06,Default,,0,0,0,,类似地\NSimilarly
Dialogue: 0,0:14:02.06,0:14:04.56,Default,,0,0,0,,回到这里，我们完全不需要unev\Nback up here, we don't need unev at all,
Dialogue: 0,0:14:04.56,0:14:06.04,Default,,0,0,0,,因为我们知道\Nbecause we know
Dialogue: 0,0:14:06.04,0:14:09.16,Default,,0,0,0,,因为我们知道这一块代码要从exp中找的操作数\Nwhat the operands of fetch of exp are for this piece of code.
Dialogue: 0,0:14:09.16,0:14:11.16,Default,,0,0,0,,就是列表x\NIt's the, it's the list x.
Dialogue: 0,0:14:12.54,0:14:15.16,Default,,0,0,0,,从某种意义上来说\NSo in some sense,
Dialogue: 0,0:14:15.16,0:14:19.42,Default,,0,0,0,,你想完全抛掉unev和exp\Nyou don't want unev and exp at all.
Dialogue: 0,0:14:19.42,0:14:22.04,Default,,0,0,0,,See, what they really are in some sense
Dialogue: 0,0:14:22.04,0:14:25.30,Default,,0,0,0,,它们不是它们实际运行机器的寄存器\Nthose aren't registers of the actual machine that's supposed to run.
Dialogue: 0,0:14:25.30,0:14:30.16,Default,,0,0,0,,它们是用来模拟那台机器的寄存器\NThose are registers that have to do with arranging the thing that can simulate that machine.
Dialogue: 0,0:14:30.16,0:14:34.64,Default,,0,0,0,,So they're always going to hold expressions which,
Dialogue: 0,0:14:34.64,0:14:38.84,Default,,0,0,0,,from the compiler's point of view, are just constants, so can be put right into the code.
Dialogue: 0,0:14:38.84,0:14:45.18,Default,,0,0,0,,所以你可以忘掉对于exp和unev的操作，只用那些常量\NSo you can forget about all the operations worrying about exp and unev and just use those constants.
Dialogue: 0,0:14:45.18,0:14:47.88,Default,,0,0,0,,与之相似，如果我们回顾这里\NSimilarly, again, if we go, go back and look here,
Dialogue: 0,0:14:47.88,0:14:51.90,Default,,0,0,0,,there are things like assign to continue eval-args.
Dialogue: 0,0:14:53.16,0:14:56.62,Default,,0,0,0,,现在它没啥事情需要做了\NNow, that has nothing to do with anything.
Dialogue: 0,0:14:56.62,0:15:00.80,Default,,0,0,0,,它只是求值器维护了下一步需要去哪\NThat was just the evaluator keeping track of where it should go next,
Dialogue: 0,0:15:00.80,0:15:06.34,Default,,0,0,0,,to evaluate the arguments in some, in some application.
Dialogue: 0,0:15:06.34,0:15:10.26,Default,,0,0,0,,当然，这与编译器没关系\NBut of course, that's irrelevant to the compiler, because you--
Dialogue: 0,0:15:10.26,0:15:14.58,Default,,0,0,0,,因为这个分析过程已经被编译器干完了the analysis phase will have already done that.
Dialogue: 0,0:15:14.58,0:15:17.30,Default,,0,0,0,,这与我们的主题完全无关\NSo this is completely irrelevant.
Dialogue: 0,0:15:17.30,0:15:25.94,Default,,0,0,0,,So a lot of these, these assignments to continue have not to do where the running machine is supposed to continue in keeping track of its state.
Dialogue: 0,0:15:25.94,0:15:29.30,Default,,0,0,0,,It has to, to do with where the evaluator analysis should continue,
Dialogue: 0,0:15:29.30,0:15:31.76,Default,,0,0,0,,TBD它们是完全无关的，所以我的可以去掉它们\Nand those are completely irrelevant. So we can get rid of them.
Dialogue: 0,0:15:31.76,0:15:42.70,Default,,0,0,0,,
Dialogue: 0,0:15:42.70,0:15:46.10,Default,,0,0,0,,Ok, well, if we, if we simply do that
Dialogue: 0,0:15:46.10,0:15:48.80,Default,,0,0,0,,make those kinds of optimizations
Dialogue: 0,0:15:48.80,0:15:53.44,Default,,0,0,0,,get rid, get rid of worrying about exp and unev,
Dialogue: 0,0:15:53.44,0:15:56.64,Default,,0,0,0,,and get rid of these irrelevant register assignments to continue,
Dialogue: 0,0:15:56.64,0:16:00.68,Default,,0,0,0,,then we can take this literal code,
Dialogue: 0,0:16:00.68,0:16:03.74,Default,,0,0,0,,these sort of 19 instructions that the,
Dialogue: 0,0:16:03.74,0:16:06.68,Default,,0,0,0,,that the evaluator would have done,
Dialogue: 0,0:16:06.68,0:16:08.36,Default,,0,0,0,,and then replace them.
Dialogue: 0,0:16:08.36,0:16:10.36,Default,,0,0,0,,大家看幻灯片\NLet's look at the, at the slide.
Dialogue: 0,0:16:10.36,0:16:11.82,Default,,0,0,0,,
Dialogue: 0,0:16:11.82,0:16:16.10,Default,,0,0,0,,我们去掉其中一半\NReplace them by--we get rid of about half of them.\N
Dialogue: 0,0:16:16.10,0:16:18.10,Default,,0,0,0,,
Dialogue: 0,0:16:18.10,0:16:20.86,Default,,0,0,0,,同样，这就是求值器做的某种过滤\NAnd again, this is just sort of filtering
Dialogue: 0,0:16:20.86,0:16:24.80,Default,,0,0,0,,把无关的东西去掉\Nwhat the evaluator would have done by getting rid of the irrelevant stuff.
Dialogue: 0,0:16:24.80,0:16:26.80,Default,,0,0,0,,你看\NAnd you see, for instance,
Dialogue: 0,0:16:26.80,0:16:31.74,Default,,0,0,0,,here the--where the evaluator said, assign val, look up variable value,
Dialogue: 0,0:16:31.74,0:16:34.88,Default,,0,0,0,,fetch of exp, here we have put in the constant f.
Dialogue: 0,0:16:34.88,0:16:37.94,Default,,0,0,0,,这里我的放了常量x\NHere we've put in the constant x.
Dialogue: 0,0:16:38.90,0:16:43.04,Default,,0,0,0,,因此这是个稍好一些的编译器\NSo there's a, there's a little better compiler.
Dialogue: 0,0:16:43.04,0:16:47.34,Default,,0,0,0,,但它还是比较蠢\NIt's still pretty dumb.
Dialogue: 0,0:16:47.34,0:16:50.08,Default,,0,0,0,,它仍会做很多蠢事\NIt's still doing a lot of dumb things.
Dialogue: 0,0:16:50.08,0:16:52.56,Default,,0,0,0,,我们再看幻灯片\NAgain, if we go look at the slide again,
Dialogue: 0,0:16:52.56,0:16:54.56,Default,,0,0,0,,看最开头的地方\Nlook at the very beginning here,
Dialogue: 0,0:16:55.74,0:16:58.66,Default,,0,0,0,,能发现保存环境\Nwe see a save the environment,
Dialogue: 0,0:16:58.66,0:17:01.80,Default,,0,0,0,,把某些东西赋值给val寄存器\Nassign something to the val register,
Dialogue: 0,0:17:01.80,0:17:03.22,Default,,0,0,0,,然后恢复环境and restore the environment.
Dialogue: 0,0:17:03.22,0:17:04.64,Default,,0,0,0,,它是从哪来的\NWhere'd that come from?
Dialogue: 0,0:17:04.64,0:17:07.90,Default,,0,0,0,,它来自求值器的这个地方\NThat came from the evaluator back here saying,
Dialogue: 0,0:17:07.90,0:17:10.68,Default,,0,0,0,,哦，我在求值一个应用的过程中\Noh, I'm in the middle of evaluating an application.
Dialogue: 0,0:17:10.68,0:17:15.32,Default,,0,0,0,,所以我要递归调用eval dispatch\NSo I'm going to recursively call eval dispatch.\N
Dialogue: 0,0:17:15.32,0:17:19.36,Default,,0,0,0,,我最好把接下来要用到的东西存下来，存到环境里\NSo I'd better save the thing I'm going to need later, which is the environment.
Dialogue: 0,0:17:19.36,0:17:23.14,Default,,0,0,0,,这就是递归调用eval dispatch的结果\NThis was the result of recursively calling eval dispatch.\N
Dialogue: 0,0:17:23.14,0:17:26.08,Default,,0,0,0,,在刚才这个例子中是对符号f进行求值\NIt was evaluating the symbol f in that case.
Dialogue: 0,0:17:26.08,0:17:30.42,Default,,0,0,0,,从eval dispatch中返回，将环境恢复\NThen it came back from eval dispatch, restored the environment.
Dialogue: 0,0:17:30.42,0:17:34.62,Default,,0,0,0,,实际上，这个求值过程中的进行的操作\NBut in fact, the actual thing it ended up doing
Dialogue: 0,0:17:34.62,0:17:38.24,Default,,0,0,0,,完全不会影响环境\Nin the evaluation is not going to hurt the environment at all.
Dialogue: 0,0:17:38.24,0:17:42.96,Default,,0,0,0,,所以这里没必要保存环境再恢复环境\NSo there's no reason to be saving the environment and restoring the environment here.
Dialogue: 0,0:17:42.96,0:17:44.96,Default,,0,0,0,,
Dialogue: 0,0:17:44.96,0:17:48.04,Default,,0,0,0,,与之类似\NSimilarly,
Dialogue: 0,0:17:48.04,0:17:52.20,Default,,0,0,0,,这里我们保存了参数列表\Nhere I'm saving the argument list.
Dialogue: 0,0:17:52.20,0:17:56.94,Default,,0,0,0,,那是一个参数求值循环，保存参数列表\NThat's a piece of the argument evaluation loop, saving the argument list,
Dialogue: 0,0:17:56.94,0:17:58.94,Default,,0,0,0,,在这里恢复参数列表\Nand here you restore it.
Dialogue: 0,0:17:58.94,0:18:00.72,Default,,0,0,0,,事实上最后\NBut the actual thing that you ended up doing
Dialogue: 0,0:18:00.72,0:18:02.52,Default,,0,0,0,,并没有变更参数列表\Ndidn't trash the argument list.
Dialogue: 0,0:18:02.52,0:18:04.52,Default,,0,0,0,,所以不需要保存它\NSo there was no reason to save it.
Dialogue: 0,0:18:04.52,0:18:07.68,Default,,0,0,0,,
Dialogue: 0,0:18:07.68,0:18:13.38,Default,,0,0,0,,So another way to say, another way to say that
Dialogue: 0,0:18:13.38,0:18:19.38,Default,,0,0,0,,求值器不得不最大限度的保持悲观\Nis that the, the evaluator has to be maximally pessimistic,
Dialogue: 0,0:18:19.38,0:18:23.06,Default,,0,0,0,,因为，从它的视角来看，只知道接下来是要对某些东西进行求值\Nbecause as far from its point of view it's just going off to evaluate something.
Dialogue: 0,0:18:23.06,0:18:25.56,Default,,0,0,0,,所以最好把后面要用到的都存下来\NSo it better save what it's going to need later.
Dialogue: 0,0:18:25.56,0:18:29.26,Default,,0,0,0,,一旦你完成了分析，编译器就是从另一种视角看问题了\NBut once you've done the analysis, the compiler is in a position to say,
Dialogue: 0,0:18:29.26,0:18:31.84,Default,,0,0,0,,哪些是我真正需要存下来的？\Nwell, what actually did I need to save?
Dialogue: 0,0:18:31.84,0:18:37.30,Default,,0,0,0,,它不需要像求值器一样小心翼翼\NAnd doesn't need to do any-- it doesn't need to be as careful as the evaluator,
Dialogue: 0,0:18:37.30,0:18:39.30,Default,,0,0,0,,因为它知道哪些才是真正需要的\Nbecause it knows what it actually needs
Dialogue: 0,0:18:39.30,0:18:41.90,Default,,0,0,0,,在任何情况下，如果我们Well, in any case, if we do that
Dialogue: 0,0:18:41.90,0:18:46.08,Default,,0,0,0,,去除所有多余的保存和恢复\Nand eliminate all those redundant saves and restores,
Dialogue: 0,0:18:46.08,0:18:49.42,Default,,0,0,0,,那么我们可以把它记下来TBD\Nthen we can get it down to this.
Dialogue: 0,0:18:49.42,0:18:53.76,Default,,0,0,0,,可以发现，只有三个指令是必须的\NAnd you see there are actually only three instructions that we actually need,
Dialogue: 0,0:18:53.76,0:18:55.76,Default,,0,0,0,,down from the initial 11 or so,
Dialogue: 0,0:18:55.76,0:18:59.26,Default,,0,0,0,,or the initial 20 or so in the original one.
Dialogue: 0,0:18:59.26,0:19:03.16,Default,,0,0,0,,对于这些寄存器操作\NAnd that's just saying, of those register operations,
Dialogue: 0,0:19:03.16,0:19:05.76,Default,,0,0,0,,哪些是必需的？\Nwhich ones did we actually need?
Dialogue: 0,0:19:05.76,0:19:08.72,Default,,0,0,0,,
Dialogue: 0,0:19:08.72,0:19:14.26,Default,,0,0,0,,我们换个方式概括，来看看稍好一些的图片\NLet me just sort of summarize that in another way, just to show you in a little better picture.
Dialogue: 0,0:19:14.26,0:19:18.02,Default,,0,0,0,,Here's a picture of starting--
Dialogue: 0,0:19:18.02,0:19:22.16,Default,,0,0,0,,This is looking at all the saves and restores.
Dialogue: 0,0:19:22.16,0:19:25.26,Default,,0,0,0,,So here's the expression, f of x,
Dialogue: 0,0:19:25.26,0:19:28.22,Default,,0,0,0,,and then this traces through, on the bottom here,
Dialogue: 0,0:19:28.22,0:19:32.52,Default,,0,0,0,,the various places in the evaluator
Dialogue: 0,0:19:34.54,0:19:38.04,Default,,0,0,0,,that were passed when the evaluation happened.
Dialogue: 0,0:19:38.04,0:19:40.04,Default,,0,0,0,,在这，你可以看到箭头\NAnd then here, here you see arrows.
Dialogue: 0,0:19:40.04,0:19:42.26,Default,,0,0,0,,向下的箭头表示register保存了\NArrow down means register saved.
Dialogue: 0,0:19:42.26,0:19:45.88,Default,,0,0,0,,所以发生的第一件事就是保存环境\NSo the first thing that happened is the environment got saved.
Dialogue: 0,0:19:45.88,0:19:49.52,Default,,0,0,0,,在这，环境恢复了\NAnd over here, the environment got restored.
Dialogue: 0,0:19:49.52,0:19:55.12,Default,,0,0,0,,这些，都是成对的栈操作\NAnd these-- so there are all the pairs of stack operations.
Dialogue: 0,0:19:55.12,0:19:57.86,Default,,0,0,0,,Now, if you go ahead and say,
Dialogue: 0,0:19:57.86,0:20:00.78,Default,,0,0,0,,well, let's remember that we don't--that unev,
Dialogue: 0,0:20:00.78,0:20:03.92,Default,,0,0,0,,unev是个完全无用的registerfor instance, is a completely useless register.
Dialogue: 0,0:20:03.92,0:20:07.24,Default,,0,0,0,,
Dialogue: 0,0:20:07.24,0:20:09.78,Default,,0,0,0,,如果我们用固定结构的代码\NAnd if we use the constant structure of the code,
Dialogue: 0,0:20:09.78,0:20:13.08,Default,,0,0,0,,我们就不需要保存unev，我们完全不需要unev\Nwell, we don't need, we don't need to save unev.
Dialogue: 0,0:20:13.08,0:20:15.54,Default,,0,0,0,,
Dialogue: 0,0:20:15.54,0:20:20.08,Default,,0,0,0,,And then, depending on how we set up the discipline of the--
