[Script Info]
; Script generated by Aegisub 3.2.1
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 712
PlayResY: 360

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Movies/Lec10a.mp4
Video File: ../../../Movies/Lec10a.mp4
Video AR Mode: 1
Video AR Value: 1.333333
Video Zoom Percent: 1.250000
Scroll Position: 60
Active Line: 67
Video Position: 8835

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,.PingFang SC,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:19.36,0:00:22.26,Default,,0,0,0,,教授: 上节课 我们学习了\NPROFESSOR: Last time, we took a look at
Dialogue: 0,0:00:22.26,0:00:25.54,Default,,0,0,0,,一个Lisp 显式控制求值器\Nan explicit control evaluator for Lisp,
Dialogue: 0,0:00:25.54,0:00:32.32,Default,,0,0,0,,它在如Lisp或查询语言等高级语言\Nand that bridged the gap between all these high-level languages
Dialogue: 0,0:00:32.32,0:00:36.40,Default,,0,0,0,,与传统的寄存器机器之间架起了桥梁\Nbridged the gap between that and a conventional register machine.
Dialogue: 0,0:00:36.40,0:00:42.46,Default,,0,0,0,,事实上 你可以将显式控制求值器\NAnd in fact, you can think of the explicit control evaluator either as, say,
Dialogue: 0,0:00:42.46,0:00:55.20,Default,,0,0,0,,#TBD \Nthe code for a Lisp interpreter if you wanted to implement it in the assembly language of some conventional register transfer machine, or, if you like, you can think of it as the microcode of some machine that's going to be specially designed to run Lisp.
Dialogue: 0,0:00:55.20,0:01:00.92,Default,,0,0,0,,在任何一种情况下 我们得到一种能够处理低级语言的机器\NIn either case, what we're doing is we're taking a machine that speaks some low-level language,
Dialogue: 0,0:01:00.92,0:01:07.26,Default,,0,0,0,,通过写一个解释器来让它能够执行像Lisp之类的高级语言\Nand we're raising the machine to a high-level language like Lisp by writing an interpreter.
Dialogue: 0,0:01:07.26,0:01:11.00,Default,,0,0,0,,来看个例子\NSo for instance,
Dialogue: 0,0:01:11.00,0:01:23.84,Default,,0,0,0,,这是一个概念上的 用于计算阶乘的专用机器\N here, conceptually, is a special purpose machine for computing factorials.
Dialogue: 0,0:01:23.84,0:01:28.26,Default,,0,0,0,,输入5 输出120 \NIt takes in five and puts out 120.
Dialogue: 0,0:01:28.26,0:01:33.16,Default,,0,0,0,,这个专用机器实际上是一个Lisp解释器\NAnd what this special purpose machine is actually a Lisp interpreter
Dialogue: 0,0:01:33.16,0:01:37.48,Default,,0,0,0,,它将自己设置为运行阶乘\Nthat's configured itself to run factorials,
Dialogue: 0,0:01:37.48,0:01:41.66,Default,,0,0,0,,因为你喂给它了阶乘机器的描述\Nbecause you feed into it a description of the factorial machine.
Dialogue: 0,0:01:41.66,0:01:43.70,Default,,0,0,0,,这就是解释器\NSo that's what an interpreter is.
Dialogue: 0,0:01:43.70,0:01:49.68,Default,,0,0,0,,它将自己设置为 模拟你所输入描述的机器\NIt configures itself to emulate a machine whose description you read in.
Dialogue: 0,0:01:49.68,0:01:52.04,Default,,0,0,0,,在Lisp解释器里是什么? \NNow, inside the Lisp interpreter, what's that?
Dialogue: 0,0:01:52.04,0:01:56.42,Default,,0,0,0,,里面可能是通用的寄存器语言解释器\NWell, that might be your general register language interpreter
Dialogue: 0,0:01:56.42,0:02:00.18,Default,,0,0,0,,它将自己设置为像Lisp解释器一样工作\Nthat configures itself to behave like a Lisp interpreter,
Dialogue: 0,0:02:00.18,0:02:03.24,Default,,0,0,0,,因为你输入了一系列寄存器语言编写的指令\Nbecause you put in a whole bunch of instructions in register language.
Dialogue: 0,0:02:03.24,0:02:06.46,Default,,0,0,0,,这就是显式控制求值器\NThis is the explicit control evaluator.
Dialogue: 0,0:02:06.46,0:02:09.30,Default,,0,0,0,,它也有某种TBD\NAnd then it also has some sort of library,
Dialogue: 0,0:02:09.30,0:02:12.48,Default,,0,0,0,,\Na library of primitive operators and Lisp operations and all sorts of things like that.
Dialogue: 0,0:02:12.48,0:02:17.04,Default,,0,0,0,,这是解释执行的通常策略\NThat's the general strategy of interpretation.
Dialogue: 0,0:02:17.04,0:02:20.88,Default,,0,0,0,,事实上，我们所做的是写了一个解释器\NAnd the point is, what we're doing is we're writing an interpreter
Dialogue: 0,0:02:20.88,0:02:25.24,Default,,0,0,0,,将机器提升到能理解我们写的程序的层次\Nto raise the machine to the level of the programs that we want to write.
Dialogue: 0,0:02:25.24,0:02:27.04,Default,,0,0,0,,也有另一种逻辑\NWell, there's another strategy,
Dialogue: 0,0:02:27.04,0:02:29.04,Default,,0,0,0,,一种不同的策略，就是编译\Na different one, which is compilation.
Dialogue: 0,0:02:29.04,0:02:31.04,Default,,0,0,0,,编译有一些不同\NCompilation's a little bit different.
Dialogue: 0,0:02:31.04,0:02:32.44,Default,,0,0,0,,这里\NHere--
Dialogue: 0,0:02:32.44,0:02:35.16,Default,,0,0,0,,我们可能已经制造了\Nhere we might have produced
Dialogue: 0,0:02:35.16,0:02:42.20,Default,,0,0,0,,一个特定用途的机器，用来计算阶乘\Na special purpose machine for, for computing factorials,
Dialogue: 0,0:02:42.20,0:02:46.26,Default,,0,0,0,,从某种讲寄存器语言的机器开始\Nstarting with some sort of machine that speaks register language,
Dialogue: 0,0:02:46.26,0:02:47.72,Default,,0,0,0,,除此之外，我们将让它执行不同的策略TBD\Nexcept we're going to do a different strategy.
Dialogue: 0,0:02:47.72,0:02:50.98,Default,,0,0,0,,我们拿来阶乘程序\NWe take our factorial program.
Dialogue: 0,0:02:50.98,0:02:53.92,Default,,0,0,0,,我们把这些源代码输入编译器\NWe use that as the source code into a compiler.
Dialogue: 0,0:02:53.92,0:02:56.18,Default,,0,0,0,,编译器将会做的是\NWhat the compiler will do
Dialogue: 0,0:02:56.18,0:02:59.64,Default,,0,0,0,,把这个阶乘程序翻译成某种寄存器机器语言\Nis translate that factorial program into some register machine language.
Dialogue: 0,0:02:59.64,0:03:03.40,Default,,0,0,0,,现在它并不是Lisp的显式控制求值器\NAnd this will now be not the explicit control evaluator for Lisp,
Dialogue: 0,0:03:03.40,0:03:06.34,Default,,0,0,0,,它现在是某种用来计算阶乘的寄存器语言\Nthis will be some register language for computing factorials.
Dialogue: 0,0:03:06.34,0:03:09.16,Default,,0,0,0,,这就是翻译的过程\NSo this is the translation of that.
Dialogue: 0,0:03:09.16,0:03:12.92,Default,,0,0,0,,它将进入某种加载器\NThat will go into some sort of loader
Dialogue: 0,0:03:12.92,0:03:19.36,Default,,0,0,0,,并与从库中选取的乘法之类的代码组合到一起\Nwhich will combine this code with code selected from the library to do things like primitive multiplication.
Dialogue: 0,0:03:19.36,0:03:21.96,Default,,0,0,0,,随后我们将生成一个加载模块\NAnd then we'll produce a load module
Dialogue: 0,0:03:21.96,0:03:25.06,Default,,0,0,0,,它把寄存器语言机器配置成\Nwhich configures the register language machine
Dialogue: 0,0:03:25.06,0:03:27.74,Default,,0,0,0,,一个专门用来计算阶乘的机器\Nto be a special purpose factorial machine.
Dialogue: 0,0:03:27.74,0:03:30.22,Default,,0,0,0,,这就是不同的策略\NSo that's a, that's a different strategy.
Dialogue: 0,0:03:30.22,0:03:32.40,Default,,0,0,0,,在解释中\NIn interpretation, we're raising
Dialogue: 0,0:03:32.40,0:03:35.32,Default,,0,0,0,,我们将机器提升到我们语言的层次，如Lisp\Nthe machine to the level of our language, like Lisp.
Dialogue: 0,0:03:35.32,0:03:36.34,Default,,0,0,0,,在编译中\NIn compilation,
Dialogue: 0,0:03:36.34,0:03:41.24,Default,,0,0,0,,我们将我们的程序降到机器语言的层次\Nwe're taking our program and lowering it to the language that's spoken by the machine.
Dialogue: 0,0:03:41.24,0:03:44.10,Default,,0,0,0,,那么，这两个策略有什么区别呢？\NWell, how do these two strategies compare?
Dialogue: 0,0:03:44.10,0:03:51.02,Default,,0,0,0,,编译器可以生成执行起来更有效率的代码\NThe compiler can produce code that will execute more efficiently.
Dialogue: 0,0:03:51.02,0:03:54.06,Default,,0,0,0,,The essential reason for that is that
Dialogue: 0,0:03:54.06,0:04:00.60,Default,,0,0,0,,if you think about the register operations that are running,
Dialogue: 0,0:04:00.60,0:04:04.82,Default,,0,0,0,,the interpreter has to produce register operations
Dialogue: 0,0:04:04.82,0:04:09.58,Default,,0,0,0,,which, in principle, are going to be general enough to execute any Lisp procedure.
Dialogue: 0,0:04:09.58,0:04:15.16,Default,,0,0,0,,Whereas the compiler only has to worry about producing a special bunch of register operations for,
Dialogue: 0,0:04:15.16,0:04:19.28,Default,,0,0,0,, for doing the particular Lisp procedure that you've compiled.
Dialogue: 0,0:04:19.28,0:04:21.24,Default,,0,0,0,,换一种说法\NOr another way to say that
Dialogue: 0,0:04:22.66,0:04:25.66,Default,,0,0,0,,解释器是一种通用的模拟器\Nis that the interpreter is a general purpose simulator,
Dialogue: 0,0:04:25.66,0:04:27.58,Default,,0,0,0,,当你输入一个Lisp过程时\Nthat when you read in a Lisp procedure
Dialogue: 0,0:04:27.58,0:04:31.08,Default,,0,0,0,,它们就会模拟被那个过程解释的程序\Nthen those can simulate the program described by that, by that procedure.
Dialogue: 0,0:04:31.08,0:04:34.12,Default,,0,0,0,,所以解释器关注的是做出一个通用模拟器\NSo the interpreter is worrying about making a general purpose simulator,
Dialogue: 0,0:04:34.12,0:04:39.68,Default,,0,0,0,,TBD所以解释器关注的是做出一个通用意图的模拟器，而编译器，in effect将东西配置成解释器将要去模拟的机器\Nwhereas the compiler, in effect, is configuring the thing to be the machine that the interpreter would have been simulating.
Dialogue: 0,0:04:39.68,0:04:44.34,Default,,0,0,0,,所以编译器可以运行得更快\NSo the compiler can be faster.
Dialogue: 0,0:04:51.74,0:04:54.78,Default,,0,0,0,,另一方面\NOK, On the other hand,
Dialogue: 0,0:04:54.78,0:04:58.74,Default,,0,0,0,,解释器更适合用来排查错误\Nthe interpreter is a nicer environment for debugging.
Dialogue: 0,0:04:58.74,0:05:01.32,Default,,0,0,0,,因为\NAnd the reason for that is that we've got the
Dialogue: 0,0:05:01.32,0:05:03.02,Default,,0,0,0,,我们的源代码实际上就在那里\Nthe source code actually there.
Dialogue: 0,0:05:03.02,0:05:05.38,Default,,0,0,0,,我们正在解释它们\NWe're interpreting it That's what we're working with.
Dialogue: 0,0:05:05.38,0:05:07.76,Default,,0,0,0,,并且库就在这里\NAnd we also have the library around.
Dialogue: 0,0:05:07.76,0:05:11.02,Default,,0,0,0,,See, the interpreter--the library sitting there is part of the interpreter.
Dialogue: 0,0:05:11.02,0:05:14.64,Default,,0,0,0,,The compiler only pulls out from the library what it needs to run the program.
Dialogue: 0,0:05:14.64,0:05:17.52,Default,,0,0,0,,So if you're in the middle of debugging,
Dialogue: 0,0:05:17.52,0:05:19.38,Default,,0,0,0,,and you might like to write
Dialogue: 0,0:05:19.38,0:05:22.82,Default,,0,0,0,,a little extra program to examine some run time data structure
Dialogue: 0,0:05:22.82,0:05:24.46,Default,,0,0,0,,or to produce some computation
Dialogue: 0,0:05:24.46,0:05:27.82,Default,,0,0,0,,that you didn't think of when you wrote the program,  the interpreter can do that perfectly well,
Dialogue: 0,0:05:27.82,0:05:29.36,Default,,0,0,0,,whereas the compiler can't.
Dialogue: 0,0:05:29.36,0:05:31.90,Default,,0,0,0,,So there are sort of dual, dual advantages.
Dialogue: 0,0:05:31.90,0:05:34.60,Default,,0,0,0,,The compiler will produce code that executes faster.
Dialogue: 0,0:05:34.60,0:05:37.96,Default,,0,0,0,,The interpreter is a better environment for debugging.
Dialogue: 0,0:05:37.96,0:05:42.36,Default,,0,0,0,,And most Lisp systems end up having both,
Dialogue: 0,0:05:42.36,0:05:47.08,Default,,0,0,0,,end up being configured so you have an interpreter that you use when you're developing your code.
Dialogue: 0,0:05:47.08,0:05:48.82,Default,,0,0,0,,Then you can speed it up by compiling.
Dialogue: 0,0:05:48.82,0:05:54.12,Default,,0,0,0,,And very often, you can arrange that compiled code and interpreted code can call each other.
