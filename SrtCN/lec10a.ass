[Script Info]
; Script generated by Aegisub 3.2.1
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 712
PlayResY: 360

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../Movies/Lec10a.mp4
Video File: ../../../Movies/Lec10a.mp4
Video AR Mode: 1
Video AR Value: 1.333333
Video Zoom Percent: 1.000000
Scroll Position: 75
Active Line: 86
Video Position: 10509

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,.PingFang SC,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:19.36,0:00:22.26,Default,,0,0,0,,教授: 上节课 我们学习了\NPROFESSOR: Last time, we took a look at
Dialogue: 0,0:00:22.26,0:00:25.54,Default,,0,0,0,,一个Lisp 显式控制求值器\Nan explicit control evaluator for Lisp,
Dialogue: 0,0:00:25.54,0:00:32.32,Default,,0,0,0,,它在如Lisp或查询语言等高级语言\Nand that bridged the gap between all these high-level languages
Dialogue: 0,0:00:32.32,0:00:36.40,Default,,0,0,0,,与传统的寄存器机器之间架起了桥梁\Nbridged the gap between that and a conventional register machine.
Dialogue: 0,0:00:36.40,0:00:42.46,Default,,0,0,0,,事实上 你可以将显式控制求值器\NAnd in fact, you can think of the explicit control evaluator either as, say,
Dialogue: 0,0:00:42.46,0:00:55.20,Default,,0,0,0,,#TBD \Nthe code for a Lisp interpreter if you wanted to implement it in the assembly language of some conventional register transfer machine, or, if you like, you can think of it as the microcode of some machine that's going to be specially designed to run Lisp.
Dialogue: 0,0:00:55.20,0:01:00.92,Default,,0,0,0,,在任何一种情况下 我们得到一种能够处理低级语言的机器\NIn either case, what we're doing is we're taking a machine that speaks some low-level language,
Dialogue: 0,0:01:00.92,0:01:07.26,Default,,0,0,0,,通过写一个解释器来让它能够执行像Lisp之类的高级语言\Nand we're raising the machine to a high-level language like Lisp by writing an interpreter.
Dialogue: 0,0:01:07.26,0:01:11.00,Default,,0,0,0,,来看个例子\NSo for instance,
Dialogue: 0,0:01:11.00,0:01:23.84,Default,,0,0,0,,这是一个概念上的 用于计算阶乘的专用机器\N here, conceptually, is a special purpose machine for computing factorials.
Dialogue: 0,0:01:23.84,0:01:28.26,Default,,0,0,0,,输入5 输出120 \NIt takes in five and puts out 120.
Dialogue: 0,0:01:28.26,0:01:33.16,Default,,0,0,0,,这个专用机器实际上是一个Lisp解释器\NAnd what this special purpose machine is actually a Lisp interpreter
Dialogue: 0,0:01:33.16,0:01:37.48,Default,,0,0,0,,它将自己设置为运行阶乘\Nthat's configured itself to run factorials,
Dialogue: 0,0:01:37.48,0:01:41.66,Default,,0,0,0,,因为你喂给它了阶乘机器的描述\Nbecause you feed into it a description of the factorial machine.
Dialogue: 0,0:01:41.66,0:01:43.70,Default,,0,0,0,,这就是解释器\NSo that's what an interpreter is.
Dialogue: 0,0:01:43.70,0:01:49.68,Default,,0,0,0,,它将自己设置为 模拟你所输入描述的机器\NIt configures itself to emulate a machine whose description you read in.
Dialogue: 0,0:01:49.68,0:01:52.04,Default,,0,0,0,,在Lisp解释器里是什么? \NNow, inside the Lisp interpreter, what's that?
Dialogue: 0,0:01:52.04,0:01:56.42,Default,,0,0,0,,里面可能是通用的寄存器语言解释器\NWell, that might be your general register language interpreter
Dialogue: 0,0:01:56.42,0:02:00.18,Default,,0,0,0,,它将自己设置为像Lisp解释器一样工作\Nthat configures itself to behave like a Lisp interpreter,
Dialogue: 0,0:02:00.18,0:02:03.24,Default,,0,0,0,,因为你输入了一系列寄存器语言编写的指令\Nbecause you put in a whole bunch of instructions in register language.
Dialogue: 0,0:02:03.24,0:02:06.46,Default,,0,0,0,,这就是显式控制求值器\NThis is the explicit control evaluator.
Dialogue: 0,0:02:06.46,0:02:09.30,Default,,0,0,0,,它也有某种TBD\NAnd then it also has some sort of library,
Dialogue: 0,0:02:09.30,0:02:12.48,Default,,0,0,0,,\Na library of primitive operators and Lisp operations and all sorts of things like that.
Dialogue: 0,0:02:12.48,0:02:17.04,Default,,0,0,0,,That's the general strategy of interpretation.
Dialogue: 0,0:02:17.04,0:02:20.88,Default,,0,0,0,,And the point is, what we're doing is we're writing an interpreter
Dialogue: 0,0:02:20.88,0:02:25.24,Default,,0,0,0,,to raise the machine to the level of the programs that we want to write.
Dialogue: 0,0:02:25.24,0:02:27.04,Default,,0,0,0,,Well, there's another strategy,
Dialogue: 0,0:02:27.04,0:02:29.04,Default,,0,0,0,,a different one, which is compilation.
Dialogue: 0,0:02:29.04,0:02:31.04,Default,,0,0,0,,Compilation's a little bit different.
Dialogue: 0,0:02:31.04,0:02:32.44,Default,,0,0,0,,Here--
Dialogue: 0,0:02:32.44,0:02:35.16,Default,,0,0,0,,here we might have produced
Dialogue: 0,0:02:35.16,0:02:42.20,Default,,0,0,0,,a special purpose machine for, for computing factorials,
Dialogue: 0,0:02:42.20,0:02:46.26,Default,,0,0,0,,starting with some sort of machine that speaks register language,
Dialogue: 0,0:02:46.26,0:02:47.72,Default,,0,0,0,,except we're going to do a different strategy.
Dialogue: 0,0:02:47.72,0:02:50.98,Default,,0,0,0,,We take our factorial program.
Dialogue: 0,0:02:50.98,0:02:53.92,Default,,0,0,0,,We use that as the source code into a compiler.
Dialogue: 0,0:02:53.92,0:02:56.18,Default,,0,0,0,,What the compiler will do
Dialogue: 0,0:02:56.18,0:02:59.64,Default,,0,0,0,, is translate that factorial program into some register machine language.
Dialogue: 0,0:02:59.64,0:03:03.40,Default,,0,0,0,,And this will now be not the explicit control evaluator for Lisp,
Dialogue: 0,0:03:03.40,0:03:06.34,Default,,0,0,0,,this will be some register language for computing factorials.
Dialogue: 0,0:03:06.34,0:03:09.16,Default,,0,0,0,,So this is the translation of that.
Dialogue: 0,0:03:09.16,0:03:12.92,Default,,0,0,0,,That will go into some sort of loader
Dialogue: 0,0:03:12.92,0:03:19.36,Default,,0,0,0,,which will combine this code with code selected from the library to do things like primitive multiplication.
Dialogue: 0,0:03:19.36,0:03:21.96,Default,,0,0,0,,And then we'll produce a load module
Dialogue: 0,0:03:21.96,0:03:25.06,Default,,0,0,0,,which configures the register language machine
Dialogue: 0,0:03:25.06,0:03:27.74,Default,,0,0,0,,to be a special purpose factorial machine.
Dialogue: 0,0:03:27.74,0:03:30.22,Default,,0,0,0,,So that's a, that's a different strategy.
Dialogue: 0,0:03:30.22,0:03:32.40,Default,,0,0,0,,In interpretation, we're raising
Dialogue: 0,0:03:32.40,0:03:35.32,Default,,0,0,0,,the machine to the level of our language, like Lisp.
Dialogue: 0,0:03:35.32,0:03:36.34,Default,,0,0,0,,In compilation,
Dialogue: 0,0:03:36.34,0:03:41.24,Default,,0,0,0,,we're taking our program and lowering it to the language that's spoken by the machine.
Dialogue: 0,0:03:41.24,0:03:44.10,Default,,0,0,0,,Well, how do these two strategies compare?
Dialogue: 0,0:03:44.10,0:03:46.10,Default,,0,0,0,,The compiler
Dialogue: 0,0:03:46.10,0:03:51.02,Default,,0,0,0,,can produce code that will execute more efficiently.
Dialogue: 0,0:03:51.02,0:03:54.06,Default,,0,0,0,,The essential reason for that is that
Dialogue: 0,0:03:54.06,0:04:00.60,Default,,0,0,0,,if you think about the register operations that are running,
Dialogue: 0,0:04:00.60,0:04:04.82,Default,,0,0,0,,the interpreter has to produce register operations
Dialogue: 0,0:04:04.82,0:04:09.58,Default,,0,0,0,,which, in principle, are going to be general enough to execute any Lisp procedure.
Dialogue: 0,0:04:09.58,0:04:15.16,Default,,0,0,0,,Whereas the compiler only has to worry about producing a special bunch of register operations for,
Dialogue: 0,0:04:15.16,0:04:19.28,Default,,0,0,0,, for doing the particular Lisp procedure that you've compiled.
Dialogue: 0,0:04:19.28,0:04:21.24,Default,,0,0,0,,Or another way to say that 
Dialogue: 0,0:04:21.24,0:04:22.66,Default,,0,0,0,,is that the interpreter
Dialogue: 0,0:04:22.66,0:04:25.66,Default,,0,0,0,,is a general purpose simulator, 
Dialogue: 0,0:04:25.66,0:04:31.20,Default,,0,0,0,,that when you read in a Lisp procedure, then those can simulate the program described by that, by that procedure.\N
Dialogue: 0,0:04:31.20,0:04:34.12,Default,,0,0,0,,So the interpreter is worrying about making a general purpose simulator, 
Dialogue: 0,0:04:34.12,0:04:39.68,Default,,0,0,0,,whereas the compiler, in effect, is configuring the thing to be the machine that the interpreter would have been simulating.\N
Dialogue: 0,0:04:39.68,0:04:42.76,Default,,0,0,0,,So the compiler can be faster.
Dialogue: 0,0:04:51.74,0:04:54.78,Default,,0,0,0,,On the other hand,
Dialogue: 0,0:04:54.78,0:04:58.74,Default,,0,0,0,,the interpreter is a nicer environment for debugging.
Dialogue: 0,0:04:58.74,0:05:01.32,Default,,0,0,0,,And the reason for that is that we've got the
Dialogue: 0,0:05:01.32,0:05:05.38,Default,,0,0,0,,the source code actually there. We're interpreting it That's what we're working with.
Dialogue: 0,0:05:05.38,0:05:07.76,Default,,0,0,0,,And we also have the library around.
Dialogue: 0,0:05:07.76,0:05:11.02,Default,,0,0,0,,See, the interpreter--the library sitting there is part of the interpreter.
Dialogue: 0,0:05:11.02,0:05:14.64,Default,,0,0,0,,The compiler only pulls out from the library what it needs to run the program.
Dialogue: 0,0:05:14.64,0:05:17.52,Default,,0,0,0,,So if you're in the middle of debugging,
Dialogue: 0,0:05:17.52,0:05:19.38,Default,,0,0,0,,and you might like to write
Dialogue: 0,0:05:19.38,0:05:22.82,Default,,0,0,0,,a little extra program to examine some run time data structure
Dialogue: 0,0:05:22.82,0:05:24.46,Default,,0,0,0,,or to produce some computation
Dialogue: 0,0:05:24.46,0:05:27.82,Default,,0,0,0,,that you didn't think of when you wrote the program,  the interpreter can do that perfectly well,
Dialogue: 0,0:05:27.82,0:05:29.36,Default,,0,0,0,,whereas the compiler can't.
Dialogue: 0,0:05:29.36,0:05:31.90,Default,,0,0,0,,So there are sort of dual, dual advantages.
Dialogue: 0,0:05:31.90,0:05:34.60,Default,,0,0,0,,The compiler will produce code that executes faster.
Dialogue: 0,0:05:34.60,0:05:37.96,Default,,0,0,0,,The interpreter is a better environment for debugging.
Dialogue: 0,0:05:37.96,0:05:42.36,Default,,0,0,0,,And most Lisp systems end up having both,
Dialogue: 0,0:05:42.36,0:05:47.08,Default,,0,0,0,,end up being configured so you have an interpreter that you use when you're developing your code.
Dialogue: 0,0:05:47.08,0:05:48.82,Default,,0,0,0,,Then you can speed it up by compiling.
Dialogue: 0,0:05:48.82,0:05:54.12,Default,,0,0,0,,And very often, you can arrange that compiled code and interpreted code can call each other.
