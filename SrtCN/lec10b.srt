1
00:00:04,725 --> 00:00:17,875
[音乐]
[JESU, JOY OF MAN'S DESIRING]

2
00:00:18,910 --> 00:00:20,612
教授: 接下来我即将
PROFESSOR: Well, there's one bit of mystery left,

3
00:00:21,275 --> 00:00:23,364
解开目前仅剩的谜团
which I'd like to get rid of right now.

4
00:00:24,440 --> 00:00:28,804
我们能毫无顾虑地用CONS
And that's that we've been blithely doing things like cons

5
00:00:30,000 --> 00:00:31,620
就如同总有空间能用一样
assuming there's always another one.

6
00:00:32,800 --> 00:00:37,025
我们使用CAR和CDR
That we've been doing these things like car-ing and cdr-ing

7
00:00:37,025 --> 00:00:39,600
并假设我们知道它们是如何实现的
and assuming that we had some idea how this can be done.

8
00:00:40,020 --> 00:00:40,675
事实上
Now indeed

9
00:00:41,075 --> 00:00:44,403
我们认为这与执行过程等同
we said that that's equivalent to having procedures.

10
00:00:45,780 --> 00:00:47,575
但这没有真正解决问题
But that doesn't really solve the problem,

11
00:00:47,739 --> 00:00:50,350
因为过程需要各种复杂的机制 
because the procedure need all sorts of complicated mechanisms 

12
00:00:50,350 --> 00:00:51,643
如环境结构
like environment structures

13
00:00:51,643 --> 00:00:53,010
之类的东西才能跑得起来
and things like that to work.

14
00:00:53,010 --> 00:00:54,890
而归根结底它们也是
And those were ultimately made out of conses 

15
00:00:54,890 --> 00:00:56,425
由CONS之类的东西构成的
in the model that we had,

16
00:00:56,700 --> 00:00:58,473
这确实没有解决问题
so that really doesn't solve the problem.

17
00:00:59,380 --> 00:01:03,977
目前的问题是#TBD数据结构是由什么构成的
Now the problem here is the glue the data structure's made out of.

18
00:01:04,760 --> 00:01:06,409
哪种方案是可行的?
What kind of possible thing could it be?

19
00:01:07,370 --> 00:01:10,460
我们已经见过了一个机器
We've been showing you things like a machine,

20
00:01:10,460 --> 00:01:13,850
一个计算机有个控制器
a computer that has a controller,

21
00:01:14,275 --> 00:01:15,450
和一些寄存器
and some registers,

22
00:01:15,450 --> 00:01:16,475
可能是一个栈
and maybe a stack.

23
00:01:16,980 --> 00:01:18,875
但是我们还没提到一些东西
And we haven't said anything about,

24
00:01:18,875 --> 00:01:19,950
例如 大一些的内存
for example, larger memory.

25
00:01:20,570 --> 00:01:22,382
这就是我们现在需要关心的东西了
And I think that's what we have to worry about right now.

26
00:01:23,740 --> 00:01:27,886
#TBD
But just to make it perfectly clear that this is an inessential,

27
00:01:28,825 --> 00:01:30,791
#TBD
purely implementational thing,

28
00:01:31,100 --> 00:01:32,600
让我举个例子
I'd like to show you, for example,

29
00:01:32,600 --> 00:01:34,286
你如何把这些东西都使用数字来表示
how you can do it all with the numbers.

30
00:01:34,800 --> 00:01:36,825
这是个比较简单的方法
That's an easy one.

31
00:01:37,590 --> 00:01:39,000
一位著名的逻辑学家 歌德尔
Famous fellow by the name of Godel,

32
00:01:43,325 --> 00:01:46,255
在20世纪30年代末
a logician at the end of the 1930s,

33
00:01:46,255 --> 00:01:48,700
发明了一个精巧的方法 
invented a very clever way 

34
00:01:48,700 --> 00:01:52,275
能够把复杂的表达式
of encoding the complicated expressions 

35
00:01:52,600 --> 00:01:53,525
表示成数字
as numbers.

36
00:01:54,320 --> 00:01:55,050
例如
For example--

37
00:01:55,050 --> 00:01:58,000
我不会精确描述歌德尔的方法是怎样的
I'm not saying exactly what Godel's scheme is,

38
00:01:58,000 --> 00:01:59,660
因为他没有使用CONS之类的术语
because he didn't use words like cons.

39
00:01:59,660 --> 00:02:02,600
他使用了其他的组合方式来制造表达式
He had other kinds of ways of combining to make expressions.

40
00:02:03,090 --> 00:02:03,500
但他说
But he said, 

41
00:02:03,500 --> 00:02:07,080
我要为每个代数表达式赋值一个数字
I'm going to assign a number to every algebraic expression.

42
00:02:07,920 --> 00:02:09,725
我通过把这些数字组合起来
And the way I'm going to manufacture these numbers

43
00:02:09,725 --> 00:02:11,650
来处理这些数字
is by combining the numbers of the parts.

44
00:02:12,470 --> 00:02:13,625
举例来说
So for example,

45
00:02:13,625 --> 00:02:15,350
我们在创造世界的时候
what we were doing our world,

46
00:02:15,350 --> 00:02:22,225
如果对象是由数字表示的
we could say that if objects are represented by numbers,

47
00:02:30,675 --> 00:02:38,229
那么(CONS X Y)
then cons of x and y

48
00:02:38,229 --> 00:02:43,775
可以表示为2的x次幂乘3的y次幂
could be represented by 2 to the x times 2 to the y.

49
00:02:46,130 --> 00:02:48,127
因为这样我们还能把它分解开
Because then we could extract the parts.

50
00:02:49,560 --> 00:02:51,100
举例来说
We could say, for example,

51
00:02:51,100 --> 00:02:56,550
(CAR X)
# that then car of, say, x

52
00:02:56,550 --> 00:03:05,275
就是2的x次幂
is the number of factors of 2 in x.

53
00:03:06,690 --> 00:03:09,115
当然(CDR X)是一样的
And of course cdr is the same thing.

54
00:03:10,690 --> 00:03:15,579
它就是3的X次幂
It's the number of factors of 3 in x.

55
00:03:16,510 --> 00:03:18,651
这是个很合理的方案
Now this is a perfectly reasonable scheme,

56
00:03:19,100 --> 00:03:22,800
除了数字会急剧增大
except for the fact that the numbers rapidly get to be much larger

57
00:03:22,800 --> 00:03:26,550
甚至比宇宙中的粒子还多
in number of digits than the number of protons in the universe.

58
00:03:27,950 --> 00:03:31,286
除了在理论上之外 没有实现这种方案的好办法
So there's no easy way to use this scheme other than the theoretical one.

59
00:03:33,430 --> 00:03:34,486
另一方面
On the other hand,

60
00:03:35,125 --> 00:03:37,558
也有其他的表示方式
there are other ways of representing these things.

61
00:03:38,450 --> 00:03:42,422
我们把它们表示为一些小盒子
We have been thinking in terms of little boxes.

62
00:03:43,325 --> 00:03:46,500
我们把CONS结构
We've been thinking about our cons structures

63
00:03:46,500 --> 00:03:48,054
想象为这样的东西
as looking sort of like this.

64
00:03:50,280 --> 00:03:52,790
它们是里面装着东西的小隔间
They're little pigeon holes with things in them.

65
00:03:53,610 --> 00:03:55,478
这些格子组成一个树
And of course we arrange them in little trees.

66
00:03:57,210 --> 00:04:02,075
我希望半导体生产厂能够供应适配这样需求的芯片
I wish that the semiconductor manufacturers would supply me with something appropriate for this,

67
00:04:02,700 --> 00:04:03,850
但事实上
but actually

68
00:04:03,850 --> 00:04:07,963
他们提供的只是线性内存
what they do supply me with is a linear memory.

69
00:04:09,380 --> 00:04:13,467
内存是一串小隔间
Memory is sort of a big pile of pigeonholes,

70
00:04:15,075 --> 00:04:16,347
像这样的小隔间
pigeonholes like this.

71
00:04:17,720 --> 00:04:20,251
每个小隔间里可以保存确定大小的对象
Each of which can hold a certain sized object,

72
00:04:21,000 --> 00:04:22,200
一个尺寸固定的对象
a fixed size object.

73
00:04:23,390 --> 00:04:24,075
例如
So, for example,

74
00:04:24,075 --> 00:04:26,744
一个含25个元素的列表就塞不到这里
a complicated list with 25 elements won't fit in one of these.

75
00:04:28,550 --> 00:04:30,900
然而 它们每一个都是由地址索引的
However, each of these is indexed by an address.

76
00:04:33,970 --> 00:04:34,807
因此它们的地址可能是 
So the address might be 

77
00:04:34,807 --> 00:04:35,500
这里是0
zero here, 

78
00:04:35,500 --> 00:04:36,225
这里是1 
one here, 

79
00:04:36,225 --> 00:04:36,700
这里是2 
two here, 

80
00:04:36,700 --> 00:04:37,250
这里是3 
three here, 

81
00:04:37,250 --> 00:04:37,944
以此类推
and so on.

82
00:04:38,060 --> 00:04:40,400
这里写的数字并不重要
That we write these down as numbers is unimportant.

83
00:04:40,400 --> 00:04:41,950
重要的是 它们不重复
What matters is that they're distinct

84
00:04:41,950 --> 00:04:43,425
有了它们就能找到下一个在哪
as a way to get to the next one.

85
00:04:44,970 --> 00:04:46,366
在其中每一个小隔间里面
And inside of each of these,

86
00:04:46,366 --> 00:04:49,110
我们可以把东西放进去
we can stuff something into these pigeonholes.

87
00:04:49,530 --> 00:04:50,774
对于没有造过计算机的我们来说
That's what memory is like,

88
00:04:51,025 --> 00:04:54,150
这就是内存的样子
for those of you who haven't built a computer.

89
00:04:54,150 --> 00:04:54,650
现在
Now.

90
00:04:56,690 --> 00:04:59,975
问题是如何用这样的结构
Now the problem is how are we going to impose on this type of structure,

91
00:05:00,425 --> 00:05:01,725
来实现这个树形结构
this nice tree structure.

92
00:05:03,290 --> 00:05:04,575
其实并不难
Well it's not very hard,

93
00:05:04,575 --> 00:05:06,350
已经有大量的方案来做这个了
and there have been numerous schemes involved in this.

94
00:05:06,875 --> 00:05:08,800
最重要的一个方案是
The most important one is to say,

95
00:05:08,800 --> 00:05:12,575
假设半导体生产厂
well assuming that the semiconductor manufacturer allows me to arrange

96
00:05:13,151 --> 00:05:15,775
允许我们的其中一个小隔间足够大
my memory so that one of these pigeonholes is big enough

97
00:05:16,287 --> 00:05:18,325
能够装得下另一个
to hold the address of another 

98
00:05:19,350 --> 00:05:20,831
未使用的小隔间的地址
I haven't made.

99
00:05:22,050 --> 00:05:23,700
事实上它需要更大一点
Now it actually has to be a little bit bigger

100
00:05:23,700 --> 00:05:27,650
因为我还要存一些信息在里面
because I have to also install or store some information

101
00:05:27,650 --> 00:05:30,390
它标示了这里面是什么东西
as to a tag which describes the kind of thing that's there.

102
00:05:30,390 --> 00:05:31,647
我们过一会能看到
And we'll see that in a second.

103
00:05:32,625 --> 00:05:36,081
如果半导体生产厂没这么良心
And of course if the semiconductor manufacturer doesn't arrange it so I can do that,

104
00:05:36,081 --> 00:05:38,575
我就需要用一些机智的方式
then of course I can, with some cleverness, 

105
00:05:38,575 --> 00:05:41,823
把它们组合起来以供使用
arrange combinations of these to fit together in that way.

106
00:05:43,770 --> 00:05:47,050
我们想象一下
So we're going to have to imagine 

107
00:05:47,050 --> 00:05:49,546
把这个复杂的树形结构
imposing this complicated tree structure 

108
00:05:49,546 --> 00:05:51,200
塞到线性内存里
on our nice linear memory.

109
00:05:51,740 --> 00:05:54,475
#TBD
If we look at the first still store,

110
00:05:54,475 --> 00:05:58,304
我们发现了一个传统的实现方案
we see a classic scheme for doing that.

111
00:05:59,490 --> 00:06:02,625
它是把Lisp结构
It's a standard way of representing Lisp structures 

112
00:06:03,225 --> 00:06:05,875
放入线性内存的基本方式
in a linear memory.

113
00:06:06,275 --> 00:06:08,325
我们把这块内存
What we do is we divide this memory 

114
00:06:08,725 --> 00:06:11,123
分为两部分
into two parts.

115
00:06:12,030 --> 00:06:13,427
一个叫the-cars的数组
An array called the cars,

116
00:06:14,450 --> 00:06:15,923
一个叫the-cdrs的数组
and an array called the cdrs.

117
00:06:17,580 --> 00:06:21,275
现在不管它是不是顺序地址
Now whether those happen to be sequential addresses or whatever,

118
00:06:21,275 --> 00:06:22,003
这不重要
it's not important.

119
00:06:22,875 --> 00:06:25,203
这是实现细节了
That's somebody's implementation details.

120
00:06:25,800 --> 00:06:28,403
但有两个数组
But there are two arrays here.

121
00:06:28,960 --> 00:06:32,755
一维数组是由顺序的下标索引的
Linear arrays indexed by sequential indices like this.

122
00:06:34,840 --> 00:06:36,851
每个小隔间里存的
What is stored in each of these pigeonholes

123
00:06:37,467 --> 00:06:39,859
是一个有类型的对象
is a typed object.

124
00:06:41,430 --> 00:06:42,575
这里是
And what we have here

125
00:06:42,575 --> 00:06:45,300
以字母p开头 
are types which begin with letters like p, 

126
00:06:45,300 --> 00:06:46,725
表示序对
standing for a pair.

127
00:06:47,790 --> 00:06:49,375
以n开头 表示数字
Or n, standing for a number.

128
00:06:50,040 --> 00:06:52,255
e开头 表示空列表
Or e, standing for an empty list.

129
00:06:54,813 --> 00:06:55,839
以及列表的结尾
The end of the list.

130
00:06:57,025 --> 00:06:59,975
如果我们想表示这样一个对象
And so if we wish to represent an object like this,

131
00:06:59,975 --> 00:07:00,050
列表由(1 2)开始
the list beginning with 1, 2

132
00:07:00,050 --> 00:07:02,164
列表由(1 2)开始
the list beginning with 1, 2

133
00:07:02,650 --> 00:07:05,503
3和4是它的第二和第三个元素
and then having a 3 and a 4 as its second and third elements.

134
00:07:06,430 --> 00:07:08,831
它第一个部分是一个包含了列表的列表
A list containing a list as its first part

135
00:07:09,350 --> 00:07:10,650
后面接着是两个数字 
and then two numbers 

136
00:07:10,650 --> 00:07:12,000
分别为第二和第三部分
as a second and third parts.

137
00:07:12,870 --> 00:07:16,672
现在我们用盒子和指针表示法来描绘它
Then of course we draw it sort of like this these days, in box-and-pointer notation.

138
00:07:17,320 --> 00:07:18,000
你能发现
And you see,

139
00:07:18,000 --> 00:07:22,275
有三个格子里是car指针
these are the three cells that have as their car pointer

140
00:07:22,275 --> 00:07:27,104
对象是(1 2)或3或4
the object which is either 1, 2 or 3 or 4.

141
00:07:28,390 --> 00:07:29,750
当然这个(1 2)
And then of course the 1, 2,

142
00:07:29,750 --> 00:07:31,325
即整个结构的CAR
the car of this entire structure,

143
00:07:31,325 --> 00:07:34,875
就是一个包含子列表的子结构
is itself a substructure which contains a sublist like that.

144
00:07:35,940 --> 00:07:37,200
我要做的是
What I'm about to do

145
00:07:37,200 --> 00:07:41,467
就是按照序号把它们放进去
is put down places which are-- I'm going to assign indices.

146
00:07:41,880 --> 00:07:43,562
像这里的1
Like this 1, over here,

147
00:07:43,562 --> 00:07:46,850
代表了这个格子的下标
represents the index of this cell.

148
00:07:49,850 --> 00:07:51,475
这里的指针
But that pointer that we see here

149
00:07:52,375 --> 00:07:57,400
是对the-cars和the-cdrs里的小隔间的引用
is a reference to the pair of pigeonholes in the cars and the cdrs

150
00:07:57,400 --> 00:07:58,675
在线性内存里 
that are labeled by 1 

151
00:07:58,675 --> 00:08:00,371
被标记为1
in my linear memory down here.

152
00:08:02,000 --> 00:08:05,363
如果我想把这个结构塞进线性内存中
So if I wish to impose this structure on my linear memory,

153
00:08:05,850 --> 00:08:07,525
要做的是 
what I do is I say, oh yes, 

154
00:08:07,525 --> 00:08:12,220
把它放进格子1中
why don't we drop this into cell 1?

155
00:08:12,220 --> 00:08:12,660
我拿了个1
I pick one.

156
00:08:12,660 --> 00:08:14,270
这是个1
There's 1.

157
00:08:14,270 --> 00:08:16,225
这是它的CAR
And that says that its car,

158
00:08:16,225 --> 00:08:17,950
我要把它赋值给一个序对
I'm going to assign it to be a pair.

159
00:08:17,950 --> 00:08:18,725
这个序对 
It's a pair, 

160
00:08:20,025 --> 00:08:21,555
序号是5
which is in index 5.

161
00:08:22,590 --> 00:08:23,900
它的CDR 
And the cdr, 

162
00:08:23,900 --> 00:08:25,139
就是这个
which is this one over here,

163
00:08:25,390 --> 00:08:26,135
它是个序对 
is a pair

164
00:08:26,135 --> 00:08:27,700
我会把它放到2的位置
 which I'm going to stick into place 2.

165
00:08:28,340 --> 00:08:28,980
即p2
p2.

166
00:08:30,890 --> 00:08:32,950
我们看p2
And take a look at p2.

167
00:08:32,950 --> 00:08:34,725
p2的CAR
Oh yes, well p2 is a thing

168
00:08:34,900 --> 00:08:37,225
是数字3 
whose car is the number 3,

169
00:08:37,225 --> 00:08:38,644
如你所见 n3
so as you see, an n3.

170
00:08:39,520 --> 00:08:41,524
它的CDR
And whose cdr, over here,

171
00:08:41,727 --> 00:08:43,400
是一个序对 
is a pair, 

172
00:08:43,975 --> 00:08:45,812
在位置4
which lives in place 4.

173
00:08:46,640 --> 00:08:47,796
这就是p4
So that's what this p4 is.

174
00:08:48,650 --> 00:08:51,167
p4是一个数字 
p4 is a number 

175
00:08:51,850 --> 00:08:53,876
它的值是4 存在CDR中
whose value is 4 in its car

176
00:08:54,475 --> 00:08:58,484
它的cdr是个空列表 在这里
and whose cdr is an empty list right there.

177
00:08:59,170 --> 00:09:00,020
这就结束了
And that ends it.

178
00:09:00,690 --> 00:09:04,907
这就是在线性内存中
So this is the traditional way of representing

179
00:09:04,907 --> 00:09:09,748
表示二叉树的传统方式
this kind of binary tree in a linear memory.

180
00:09:11,620 --> 00:09:15,100
那么 下一个问题是
Now the next question, of course,

181
00:09:15,100 --> 00:09:18,440
我们可能担心如何实现
that we might want to worry about is just a little bit of implementation.

182
00:09:18,440 --> 00:09:23,625
这意味着当我写下一个对a赋值的过程
That means that when I write procedures of the form assigned a,

183
00:09:23,625 --> 00:09:30,140
#TBD
[UNINTELLIGIBLE] procedures-- lines of register machine code of the form assigned a, the car of [UNINTELLIGIBLE] b, 

184
00:09:30,140 --> 00:09:31,975
我实际上想做的是
what I really mean

185
00:09:31,975 --> 00:09:37,100
定位这些元素
is addressing these elements.

186
00:09:38,740 --> 00:09:43,000
我们会把它当作一个缩写
And so we're going to think of that as a abbreviation for it.

187
00:09:44,470 --> 00:09:46,600
当然 为了把它们写下来
Now of course in order to write that down

188
00:09:46,600 --> 00:09:49,425
我要引入一种叫作向量的结构
I'm going to introduce some sort of a structure called a vector.

189
00:09:52,120 --> 00:09:54,750
我们#TBD
And we're going to have something which will reference a vector,

190
00:09:56,840 --> 00:09:58,710
这样我们就能把它写下来
just so we can write it down.

191
00:09:58,710 --> 00:10:00,436
它叫向量vector
Which takes the name of the vector,

192
00:10:01,025 --> 00:10:03,970
我觉得这个名字起得不太靠谱
or the-- I don't think that name is the right word.

193
00:10:03,970 --> 00:10:09,400
它接受vector和index
Which takes the vector and the index,

194
00:10:11,201 --> 00:10:14,657
#TBD
and I have to have a way of setting one of those with something called a vector set,

195
00:10:14,657 --> 00:10:15,608
我不太在意
I don't really care.

196
00:10:16,280 --> 00:10:17,550
举个例子
But let's look, for example,

197
00:10:18,113 --> 00:10:20,425
在这种实现中
at then that kind of implementation 

198
00:10:21,250 --> 00:10:23,182
CAR和CDR是什么样子的
of car and cdr.

199
00:10:26,470 --> 00:10:30,800
如果我有一个寄存器b
So for example if I happen to have a register b,

200
00:10:31,150 --> 00:10:34,640
它存了一个序对的下标
which contains the type index of a pair,

201
00:10:35,950 --> 00:10:38,800
即它是指向一个序对的指针
and therefore it is the pointer to a pair,

202
00:10:39,350 --> 00:10:40,850
我可以取它的CAR 
then I could take the car of that and

203
00:10:41,425 --> 00:10:44,112
存到寄存器a里面
 if I-- write this down-- I might put that in register a.

204
00:10:44,490 --> 00:10:46,864
事实上它是
What that really is is a representation of

205
00:10:47,375 --> 00:10:50,191
对a赋值的代表#TBD
the assign to a,

206
00:10:50,191 --> 00:10:55,425
#TBD
the value of vector reffing-- or array indexing, if you will-- or something,

207
00:10:55,425 --> 00:11:01,136
#TBD
the cars object-- whatever that is-- with the index, b.

208
00:11:02,650 --> 00:11:03,760
与cdr类似
And similarly for cdr.

209
00:11:04,100 --> 00:11:05,725
我们可以用同样的方式
And we can do the same thing 

210
00:11:05,725 --> 00:11:08,496
来对数据结构赋值
for assignment to data structures,

211
00:11:08,925 --> 00:11:10,925
如果我们需要这么做的话
If we need to do that sort of things at all.

212
00:11:11,840 --> 00:11:13,808
构建这个并不太难
It's not too hard to build that.

213
00:11:14,580 --> 00:11:15,600
下一个问题是 
Well now the next question is

214
00:11:15,600 --> 00:11:17,008
我们如何分配它们
 how are we going to do allocation.

215
00:11:18,010 --> 00:11:20,138
我说过很多次 我需要一个CONS
And every so often I say I want a cons.

216
00:11:21,400 --> 00:11:23,790
当然 CONS并没有长在树上
Now conses don't grow on trees.

217
00:11:23,790 --> 00:11:25,340
或许它们应该那样
Or maybe they should.

218
00:11:25,340 --> 00:11:28,975
我需要某种获得下一个的方法
But I have to have some way of getting the next one.

219
00:11:29,980 --> 00:11:31,475
我需要某种方案
I have to have some idea of

220
00:11:31,475 --> 00:11:35,630
当内存不用的时候 我可以分配它们
if their memory is unused that I might want to allocate from.

221
00:11:35,630 --> 00:11:37,380
有很多方案可以实现这一点
And there are many schemes for doing this.

222
00:11:37,380 --> 00:11:40,450
我给你看这这个东西是不必要的
And the particular thing I'm showing you right now is not essential.

223
00:11:42,100 --> 00:11:44,960
然而它很方便 并且被实现很多次了
However it's convenient and has been done many times.

224
00:11:44,960 --> 00:11:47,660
一种方案被称为#TBD
One scheme's was called the free list allocation scheme.

225
00:11:47,660 --> 00:11:48,684
它就是
What that means is

226
00:11:48,684 --> 00:11:51,550
世界上所有的空闲内存
that all of the free memory that there is in the world

227
00:11:51,550 --> 00:11:53,429
都连在一个链表中
is linked together in a linked list,

228
00:11:54,550 --> 00:11:56,373
就像其他东西一样
just like all the other stuff.

229
00:11:56,960 --> 00:12:00,213
每当你需要一个新的格子来进行CONS的时候
And whenever you need a free cell to make a new cons,

230
00:12:00,950 --> 00:12:03,825
你用第一个 让这个free list指向它的cdr
you grab the first, one make the free list be the cdr of it,

231
00:12:04,325 --> 00:12:05,553
然后分配它
and then allocate that.

232
00:12:06,030 --> 00:12:08,325
就像这样
And so what that looks like is something like this.

233
00:12:09,530 --> 00:12:16,817
我们的free list从6开始
Here we have the free list starting in 6.

234
00:12:18,510 --> 00:12:23,729
它是一个指向8的指针
And what that is is a pointer-off to say 8.

235
00:12:24,860 --> 00:12:26,553
它表示 当前这个是空闲的 
So what it says is, this one is free 

236
00:12:26,553 --> 00:12:27,953
下一个在8
and the next one is an 8.

237
00:12:28,870 --> 00:12:29,881
这个是空闲的 
This one is free 

238
00:12:29,881 --> 00:12:32,271
下一个在3
and the next one is in 3,

239
00:12:32,271 --> 00:12:33,457
下一个是空闲的
the next one that's free.

240
00:12:33,930 --> 00:12:34,950
这个是空闲的 
That one's free

241
00:12:34,950 --> 00:12:37,680
下一个在0
 and the next one is in 0.

242
00:12:37,680 --> 00:12:38,250
这个是空闲的 
That one's free 

243
00:12:38,250 --> 00:12:39,857
下一个在15
and the next one's in 15.

244
00:12:40,940 --> 00:12:41,975
以此类推
Something like that.

245
00:12:42,780 --> 00:12:44,977
我们可以想象有这样的结构
We can imagine having such a structure.

246
00:12:46,400 --> 00:12:48,250
一旦我们有了这样一个机制
Given that we have something like that,

247
00:12:49,450 --> 00:12:52,421
那么当你需要空间的时候就能给你一个了
then it's possible to just get one when you need it.

248
00:12:53,825 --> 00:12:56,466
对于进行CONS的程序
And so a program for doing cons,

249
00:12:57,450 --> 00:12:59,320
这就是CONS的程序会是什么样子
this is what cons might turn into.

250
00:12:59,320 --> 00:13:06,200
把B和C进行CONS之后的值赋值给A寄存器
To assign to a register A the result of cons-ing, a B onto C,

251
00:13:06,200 --> 00:13:09,275
结果包括B和C
the value in this containing B and the value containing C,

252
00:13:09,275 --> 00:13:12,475
我们要做的是用free list前面的第一个
what we have to do is get the current [? type ?] ahead of the freelist,

253
00:13:12,475 --> 00:13:14,300
让它的cdr称为新的free list
make the free list be its cdr.

254
00:13:15,643 --> 00:13:20,475
我们要把car修改为
Then we have to change the cars to be the thing we're

255
00:13:20,475 --> 00:13:25,450
#TBD
making up to be in A to be the B, the thing in B.

256
00:13:25,900 --> 00:13:31,722
我们还要把cdr改为#TBD
And we have to make change the cdrs of the thing that's in A to be C.

257
00:13:33,200 --> 00:13:36,650
#TBD
And then what we have in A is the right new frob, whatever it is.

258
00:13:36,650 --> 00:13:38,186
这就是我们要的对象
The object that we want.

259
00:13:40,470 --> 00:13:42,500
我之前告诉过你们 
Now there's a little bit of 

260
00:13:42,500 --> 00:13:43,975
这里撒了个谎
a cheat here that I haven't told you about,

261
00:13:43,975 --> 00:13:47,326
#TBD
which is somewhere around here I haven't set that

262
00:13:48,455 --> 00:13:53,050
#TBD
I've the type of the thing that I'm cons-ing up to be a pair, and I ought to.

263
00:13:53,510 --> 00:13:55,675
#TBD
So there should be some sort of bits here are being set,

264
00:13:55,675 --> 00:13:57,914
我只是还没把它写下来
and I just haven't written that down.

265
00:13:59,810 --> 00:14:02,450
#TBD
We could have arranged it, of course, for the free lift to be made out of pairs.

266
00:14:03,100 --> 00:14:04,882
因此这是没问题的
And so then there's no problem with that.

267
00:14:06,430 --> 00:14:10,225
 
But that sort of-- again, an inessential detail in a way

268
00:14:10,225 --> 00:14:16,850
 
some particular programmer or architect or whatever might manufacture his machine or Lisp system.

269
00:14:17,540 --> 00:14:23,550
例如 看这个
So for example, just looking at this, to allocate

270
00:14:23,550 --> 00:14:26,834
 
given that I had already the structure that you saw before,

271
00:14:27,100 --> 00:14:30,265
 
supposing I wanted to allocate a new cell,

272
00:14:30,550 --> 00:14:36,617
 
which is going to be representation of list one, one, two,

273
00:14:37,075 --> 00:14:42,161
 
where already one  two was the car of the list we were playing with before. 

274
00:14:43,430 --> 00:14:44,450
这不难
Well that's not so hard.

275
00:14:44,780 --> 00:14:46,200
#TBD
I stored that one and one,

276
00:14:46,200 --> 00:14:49,175
#TBD
so p1 one is the representation of this.

277
00:14:49,530 --> 00:14:50,839
这个是p5
This is p5.

278
00:14:51,675 --> 00:14:53,512
 
That's going to be the cdr of this.

279
00:14:54,070 --> 00:14:55,525
现在我们想用掉一些free list
Now we're going to pull something off the free list,

280
00:14:55,525 --> 00:14:57,303
记住free list从6开始
but remember the free list started at six.

281
00:14:57,780 --> 00:15:00,183
分配之后的新free list是8
The new free list after this allocation is eight,

282
00:15:00,600 --> 00:15:02,551
一个从8开始的free list
a free list beginning at eight.

283
00:15:02,890 --> 00:15:06,157
当然 现在6里面是数字1
And of course in six now we have a number one,

284
00:15:06,157 --> 00:15:11,562
#TBD
which is what we wanted, with its cdr being the pair starting in location five.

285
00:15:13,330 --> 00:15:14,506
#TBD
And that's no big deal.

286
00:15:16,810 --> 00:15:20,450
这里依然存在的一个问题是
So the only problem really remaining here is,

287
00:15:21,000 --> 00:15:23,402
我们没有无限大的内存
well, I don't have an infinitely large memory.

288
00:15:25,080 --> 00:15:26,666
如果它需要花费一些时间
If I do this for a little while,

289
00:15:27,250 --> 00:15:30,150
例如 假设进行一次cons花费1微秒
say, for example, supposing it takes me a microsecond to do a cons,

290
00:15:30,600 --> 00:15:32,975
我们要进行一百万cons
and I have a million cons memory

291
00:15:33,600 --> 00:15:35,279
那么我就要消耗1秒钟的时间
then I'm only going to run out in a second,

292
00:15:35,950 --> 00:15:37,007
这就很糟糕了
and that's pretty bad.

293
00:15:38,000 --> 00:15:40,625
如何预防这样的灾难
So what we do to prevent that disaster,

294
00:15:40,625 --> 00:15:42,191
环境灾难
that ecological disaster,

295
00:15:42,600 --> 00:15:44,300
在提问环节之后我们再继续讨论
talk about right after questions.

296
00:15:44,300 --> 00:15:45,263
有人要提问吗?
Are there any questions?

297
00:15:51,500 --> 00:15:52,030
请讲
Yes.

298
00:15:52,030 --> 00:15:54,675
学生: 在环境图表中
AUDIENCE: In the environment diagrams that we were drawing

299
00:15:54,675 --> 00:15:58,250
我们画了过程体
we would use the body of procedures,

300
00:15:58,250 --> 00:16:04,350
#TBD
and you would eventually wind up with things that were no longer useful in that structure.

301
00:16:04,930 --> 00:16:06,890
它是如何表示的
How is that represented?

302
00:16:06,890 --> 00:16:09,180
教授: 这其实是两个问题
PROFESSOR: There's two problems here.

303
00:16:09,180 --> 00:16:10,250
第一个问题是 
One you were asking 

304
00:16:10,250 --> 00:16:13,438
材料没用了
is that material becomes useless.

305
00:16:13,870 --> 00:16:14,920
我们稍后就会讲
We'll talk about that in a second.

306
00:16:14,920 --> 00:16:17,175
如何预防环境灾难
That has to do with how to prevent ecological disasters.

307
00:16:18,100 --> 00:16:19,200
如果我制造了一堆垃圾 
If I make a lot of garbage 

308
00:16:19,200 --> 00:16:21,399
我需要自己清理掉
I have to somehow be able to clean up after myself.

309
00:16:21,820 --> 00:16:23,255
我们一会儿就要讲
And we'll talk about that in a second.

310
00:16:23,430 --> 00:16:24,575
第二个问题 
The other question you're asking 

311
00:16:24,575 --> 00:16:27,210
你问的是如何表示环境
is how you represent the environments, I think.

312
00:16:27,210 --> 00:16:27,600
学生: 对
AUDIENCE: Yes.

313
00:16:27,600 --> 00:16:28,190
教授: 好
PROFESSOR: OK.

314
00:16:28,190 --> 00:16:30,860
环境结构能够以任意的方式表示
And the environment structures can be represented in arbitrary ways.

315
00:16:30,860 --> 00:16:31,780
有很多种表示方式
There are lots of them.

316
00:16:31,780 --> 00:16:33,630
我的意思是 我这里只教你了list格子的表示方式
I mean, here I'm just telling you about list cells.

317
00:16:33,630 --> 00:16:34,925
当然 每个真实的系统
Of course every real system 

318
00:16:34,925 --> 00:16:36,725
都有任意长度的向量
has vectors of arbitrary length

319
00:16:36,725 --> 00:16:41,080
也有长度的向量#TBD
as well as the vectors of length, too, which represent list cells.

320
00:16:41,080 --> 00:16:44,909
#TBD
And the environment structures that one uses in a 

321
00:16:44,909 --> 00:16:47,300
 
professionally written Lisp system

322
00:16:47,300 --> 00:16:49,699
#TBD
tend to be vectors 

323
00:16:49,699 --> 00:16:51,925
 
which contain a number of elements approximately e

324
00:16:51,925 --> 00:16:54,601
 
qual to the number of arguments-- a little bit more

325
00:16:55,350 --> 00:16:58,290
因为你需要#TBD
because you need certain glue.

326
00:16:58,290 --> 00:17:00,740
记住环境是在框架里的
So remember, the environment is in a frame.

327
00:17:00,740 --> 00:17:03,980
框架是应用过程时被构建出来的
The frames are constructed by applying a procedure.

328
00:17:03,980 --> 00:17:06,825
#TBD
In doing so, an allocation is made of

329
00:17:06,825 --> 00:17:11,270
#TBD
a place which is the number of arguments long plus [? unglue ?]

330
00:17:11,270 --> 00:17:12,713
#TBD
that gets linked into a chain.

331
00:17:13,325 --> 00:17:15,660
#TBD
It's just like algol at that level.

332
00:17:19,810 --> 00:17:20,725
还有其他问题吗?
There any other questions?

333
00:17:23,700 --> 00:17:23,920
好
OK.

334
00:17:23,920 --> 00:17:26,106
谢谢 我们休息一下
Thank you, and let's take a short break.

335
00:17:26,350 --> 00:18:10,625
[音乐]
[JESU, JOY OF MAN'S DESIRING]

336
00:18:12,270 --> 00:18:14,550
教授: 就像我刚才提到过的
PROFESSOR: Well, as I just said,

337
00:18:14,550 --> 00:18:17,975
半导体厂商生产的计算机内存
computer memories supplied by the semiconductor manufacturers 

338
00:18:17,975 --> 00:18:19,000
容量是有限的
are finite.

339
00:18:19,420 --> 00:18:20,408
这的确很可惜
And that's quite a pity.

340
00:18:21,620 --> 00:18:23,352
可能并不永远是这样
It might not always be that way.

341
00:18:24,030 --> 00:18:25,623
简单算一下
Just for a quick calculation, 

342
00:18:25,623 --> 00:18:28,860
你可以看到 如果内存的价格
you can see that it's possible that if memory's

343
00:18:28,860 --> 00:18:30,800
继续保持当前的趋势的话
prices keep going at the rate they're going

344
00:18:31,225 --> 00:18:33,872
如果你执行cons的时候一直花费1微秒
that if you still took a microsecond second to do a cons,

345
00:18:34,425 --> 00:18:38,864
那么 首先大家知道pi乘10的7次方秒大约是一年
then-- first of all, everybody should know that there's about pi times ten to the seventh seconds in a year.

346
00:18:39,450 --> 00:18:43,940
那么就有10的6次方乘10的7次方 也就是10的13次方
And so that would be ten to the seventh plus ten to the sixth is ten to the thirteenth.

347
00:18:43,940 --> 00:18:46,800
那么在机器的一生中就能有10的14次方个CONS
So there's maybe ten to the fourteenth conses in the life of a machine.

348
00:18:47,520 --> 00:18:50,576
如果你的机器上有10的14次方个字的内存
If there was ten to the fourteenth words of memory on your machine,

349
00:18:51,200 --> 00:18:52,368
你永远不会用完
you'd never run out.

350
00:18:54,020 --> 00:18:55,760
这并不是完全没有道理
And that's not completely unreasonable.

351
00:18:56,310 --> 00:18:58,460
10的14次方不是个非常大的数字
Ten to the fourteenth is not a very large number.

352
00:19:03,860 --> 00:19:05,180
我不觉觉得它是个很大的数字
I don't think it is.

353
00:19:05,180 --> 00:19:08,700
但我喜欢在天文学领域进行比较
But then again I like to play with astronomy.

354
00:19:09,250 --> 00:19:12,450
距离我们最近的星星至少有10的18次方厘米远
It's at least ten to the eighteenth centimeters between us and the nearest star.

355
00:19:12,930 --> 00:19:18,850
我担心的是
But the thing I'm about to worry about is,

356
00:19:19,150 --> 00:19:21,275
至少以现在的经济状况
at least in the current economic state of affairs,

357
00:19:21,275 --> 00:19:23,575
10的14次方内存很贵
ten to the fourteenth pieces of memory is expensive.

358
00:19:24,200 --> 00:19:28,600
因此我认为我们需要适应更小的内存
And so I suppose what we have to do is make do with much smaller memories.

359
00:19:30,025 --> 00:19:35,145
一般来说 我们需要有无限内存的错觉
Now in general we want to have an illusion of infinity.

360
00:19:35,800 --> 00:19:37,825
我们需要的是#TBD
All we need to do is arrange it

361
00:19:37,825 --> 00:19:39,689
那么在我们需要内存的时候就能获得它
so that whenever you look, the thing is there.

362
00:19:42,875 --> 00:19:45,550
这是个非常重要的想法
That's really an important idea.

363
00:19:49,540 --> 00:19:51,975
人或者计算机只能存在有限的时间
A person or a computer lives only a finite amount of time

364
00:19:52,325 --> 00:19:54,599
只能看有限的东西
and can only take a finite number of looks at something.

365
00:19:55,280 --> 00:19:57,375
因此你只需要有限的东西
And so you really only need a finite amount of stuff.

366
00:19:58,190 --> 00:20:00,383
#TBD
But you have to arrange it so no matter how much there is,

367
00:20:00,773 --> 00:20:03,461
#TBD
how much you really claim there is,

368
00:20:03,461 --> 00:20:06,900
#TBD
there's always enough stuff so that when you take a look, it's there.

369
00:20:06,900 --> 00:20:08,157
#TBD
And so you only need a finite amount.

370
00:20:08,750 --> 00:20:09,949
我们看
But let's see.

371
00:20:11,630 --> 00:20:13,533
我们之前提过一个问题
One problem is, as was brought up,

372
00:20:13,925 --> 00:20:15,450
#TBD
that there are possible ways

373
00:20:15,725 --> 00:20:19,125
#TBD
that there is lots of stuff that we make that we don't need.

374
00:20:19,410 --> 00:20:21,813
我们可以进行回收再利用
And we could recycle the material out of which its made.

375
00:20:22,625 --> 00:20:23,533
举个例子
An example

376
00:20:24,150 --> 00:20:25,500
事实上 
is the fact that 

377
00:20:25,500 --> 00:20:28,400
当我们调用一个过程的时候
we're building environment structures,

378
00:20:28,400 --> 00:20:30,470
都会构建环境结构
and we do so every time we call a procedure.

379
00:20:30,470 --> 00:20:32,565
我们把它构建在一个环境框架中
We have built in it a environment frame.

380
00:20:33,141 --> 00:20:36,075
环境框架不用存在很长时间
That environment frame doesn't necessarily have a very long lifetime.

381
00:20:36,730 --> 00:20:38,699
它只在有用的时候才会存在
Its lifetime, meaning its usefulness,

382
00:20:39,425 --> 00:20:42,603
可能只在调用过程的时候才会存在
may exist only over the invocation of the procedure.

383
00:20:42,850 --> 00:20:45,275
如果过程把另一个过程
Or if the procedure exports another procedure 

384
00:20:45,275 --> 00:20:46,875
作为返回值返回
by returning it as a value

385
00:20:46,875 --> 00:20:48,525
并且这个过程是在它的内部定义的
and that procedure is defined inside of it,

386
00:20:48,525 --> 00:20:53,500
那么外层过程的框架的存活时间
well then the lifetime of the frame of the outer procedure still is

387
00:20:53,500 --> 00:20:57,900
就是被返回的过程的存活时间
only the lifetime of the procedure which was exported.

388
00:20:58,530 --> 00:21:00,972
最后 就会产生很多垃圾
And so ultimately, a lot of that is garbage.

389
00:21:01,960 --> 00:21:04,108
还有其他产生垃圾的方式
There are other ways of producing garbage as well.

390
00:21:05,370 --> 00:21:06,675
用户产生垃圾
Users produce garbage.

391
00:21:07,240 --> 00:21:08,075
举例来说 
An example of 

392
00:21:08,075 --> 00:21:10,225
用户的垃圾是这样的东西
user garbage is something like this.

393
00:21:10,930 --> 00:21:14,000
如果我们写个程序
If we write a program to, for example,

394
00:21:14,000 --> 00:21:15,800
把两个列表连接到一起
append two lists together,

395
00:21:16,050 --> 00:21:18,325
唯一的办法是
well one way to do it is

396
00:21:18,325 --> 00:21:21,375
把第一个列表逆序塞到空列表中
to reverse the first list onto the empty list

397
00:21:21,375 --> 00:21:23,725
把新列表逆序塞到第二个列表中
and reverse that onto the second list.

398
00:21:24,703 --> 00:21:26,925
这并不是完成任务的很差的办法
Now that's not terribly bad way of doing it.

399
00:21:28,160 --> 00:21:28,850
然而
And however, 

400
00:21:28,850 --> 00:21:32,025
程序所生成的中间结果
the intermediate result, which is the reversal of the first list

401
00:21:33,875 --> 00:21:35,576
即第一个逆序的列表
as done by this program,

402
00:21:36,700 --> 00:21:38,525
在它被复制回第二个列表之后 
is never going to be accessed ever again 

403
00:21:38,525 --> 00:21:40,568
再也不会被用到了
after it's copied back on to the second.

404
00:21:41,010 --> 00:21:42,232
它是个中间结果
It's an intermediate result.

405
00:21:43,580 --> 00:21:45,432
它很难被找到
It's going to be hard to ever see

406
00:21:46,075 --> 00:21:48,056
没有人能访问到它
how anybody would ever be able to access it.

407
00:21:48,600 --> 00:21:49,848
事实上 它会消失掉
In fact, it will go away.

408
00:21:51,050 --> 00:21:52,900
如果我们制造了大量这样的垃圾
Now if we make a lot of garbage like that,

409
00:21:52,900 --> 00:21:54,200
我们应该被允许这样做
and we should be allowed to,

410
00:21:54,800 --> 00:21:57,550
但应该有某些方法去回收这些垃圾
then there's got to be some way to reclaim that garbage.

411
00:21:58,800 --> 00:22:00,900
我现在要告诉你
is a very clever technique

412
00:22:01,700 --> 00:22:03,775
一个非常聪明的技巧

413
00:22:04,325 --> 00:22:16,225
lisp系统可以证明一个小定理#TBD
whereby a Lisp system can prove a small theorem every so often on the [? forum, ?] the following piece of junk will never be accessed again.

414
00:22:17,410 --> 00:22:19,809
它对将来的计算没有任何影响
It can have no affect on the future of the computation.

415
00:22:21,400 --> 00:22:23,841
事实上 这基于一个很简单的想法
It's actually based on a very simple idea.

416
00:22:24,725 --> 00:22:28,065
我们已经把计算机设计成这个样子
We've designed our computers to look sort of like this.

417
00:22:28,950 --> 00:22:30,943
有一些数据路径 
There's some data path, 

418
00:22:30,943 --> 00:22:33,505
保存了寄存器
which contains the registers. 

419
00:22:35,280 --> 00:22:42,275
有x, env和val之类的东西
There are things like x, and env, and val, and so on.

420
00:22:42,610 --> 00:22:44,025
这里有个叫stack的东西
And there's one here called stack,

421
00:22:46,025 --> 00:22:49,071
某种指向一个结构的东西 
some sort which points off to a structure somewhere, 

422
00:22:49,071 --> 00:22:50,240
它是个栈
which is the stack.

423
00:22:50,240 --> 00:22:51,740
我们过一会再研究它
And we'll worry about that in a second.

424
00:22:51,740 --> 00:22:53,625
这有一些有限控制器
There's some finite controller,

425
00:22:54,389 --> 00:22:56,730
有限状态机控制器
finite state machine controller.

426
00:22:56,730 --> 00:22:59,513
这些控制信号通过这里
And there's some control signals that go this way and

427
00:22:59,800 --> 00:23:01,679
谓词结果通过这里 
predicate results that come this way, 

428
00:23:01,679 --> 00:23:03,350
这部分并不太有趣
not the interesting part.

429
00:23:03,350 --> 00:23:06,806
这里有某种结构化的内存
There's some sort of structured memory,

430
00:23:06,806 --> 00:23:08,271
我刚才给你讲过如何构建它 
which I just told you how to make, 

431
00:23:08,271 --> 00:23:10,460
它可能包括一个栈
which may contain a stack.

432
00:23:10,460 --> 00:23:12,431
我没有告诉你如何把东西构建成任意形状 
I didn't tell you how to make things of arbitrary shape, 

433
00:23:12,431 --> 00:23:13,450
只有pair
only pairs.

434
00:23:13,450 --> 00:23:14,350
但事实上 
But in fact

435
00:23:14,350 --> 00:23:17,177
你可以用一个大列表来模拟栈
 with what I've told you can simulate a stack by a big list.

436
00:23:17,775 --> 00:23:18,850
我没准备干这个 
I don't plan to do that, 

437
00:23:18,850 --> 00:23:20,360
这不是个好办法
it's not a nice way to do it.

438
00:23:20,360 --> 00:23:22,745
但是我们可以有这样一个东西
But we could have something like that.

439
00:23:22,990 --> 00:23:25,647
这里有各种数据结构
We have all sorts of little data structures in here

440
00:23:25,647 --> 00:23:27,750
它们通过有趣的方式互相连接
that are hooked together in funny ways.

441
00:23:30,115 --> 00:23:32,025
它们和其他东西连接到一起
They connect to other things.

442
00:23:32,560 --> 00:23:33,250
以此类推
And so on.

443
00:23:33,250 --> 00:23:34,225
归根结底 
And ultimately

444
00:23:34,455 --> 00:23:37,190
这里的东西是指向这里的指针
things up there are pointers to these.

445
00:23:37,190 --> 00:23:38,873
寄存器里的东西
The things that are in the registers

446
00:23:39,407 --> 00:23:43,609
是指向Lisp结构内存的数据结构指针
are pointers off to the data structures that live in this Lisp structure memory.

447
00:23:44,910 --> 00:23:49,850
#TBD
Now the truth of the matter is

448
00:23:51,055 --> 00:23:54,266
机器的整个意识是在寄存器里的
that the entire consciousness of this machine is in these registers.

449
00:23:55,550 --> 00:23:58,750
如果这个机器
There is no possible way that the machine,

450
00:23:58,750 --> 00:24:01,374
构建得正确的话
if done correctly, if built correctly,

451
00:24:01,374 --> 00:24:03,418
它无法访问Lisp结构内存中任何东西
can access anything in this Lisp structure memory

452
00:24:04,575 --> 00:24:06,475
除了在Lisp结构内存中
unless the thing in that Lisp structure memory

453
00:24:08,095 --> 00:24:13,066
与序列数据结构连接的寄存器
is connected by a sequence of data structures to the registers.

454
00:24:15,070 --> 00:24:18,314
#TBD如果合法数据结构选择器
If it's accessible by legitimate data structure selectors

455
00:24:19,088 --> 00:24:21,322
通过寄存器里保存的指针能够访问它
from the pointers that are stored in these registers.

456
00:24:22,280 --> 00:24:24,650
类似数组引用
Things like array references, perhaps.

457
00:24:24,940 --> 00:24:28,170
或者#TBD
Or cons cell references, cars and cdrs.

458
00:24:28,790 --> 00:24:30,950
但我不能只讨论内存中的任意位置 
But I can't just talk about a random place in this memory, 

459
00:24:30,950 --> 00:24:31,950
因为我找不到它
because I can't get to it.

460
00:24:32,740 --> 00:24:34,904
#TBD
These are being arbitrary names I'm not allowed to count,

461
00:24:37,008 --> 00:24:38,985
#TBD
at least as I'm evaluating expressions.

462
00:24:41,620 --> 00:24:43,275
#TBD
If that's the case

463
00:24:43,275 --> 00:24:45,336
就可以证明一个简单的理论
then there's a very simple theorem to be proved.

464
00:24:47,160 --> 00:24:47,900
就是说
Which is,

465
00:24:47,900 --> 00:24:50,520
#TBD
if I start with all lead pointers that are in all these registers

466
00:24:51,164 --> 00:24:52,550
递归地取出
and recursively chase out,

467
00:24:52,825 --> 00:24:56,150
把所有能访问到的东西做标记
marking all the places I can get to by selectors,

468
00:24:56,900 --> 00:24:59,400
最终就能标记所有能访问的东西
then eventually I mark everything they can be gotten to.

469
00:25:00,650 --> 00:25:02,699
任何未标记的都是垃圾 
Anything which is not so marked is garbage 

470
00:25:02,699 --> 00:25:03,750
它们可以被回收
and can be recycled.

471
00:25:05,560 --> 00:25:06,400
贼简单
Very simple.

472
00:25:07,200 --> 00:25:09,100
不会影响未来的计算
Cannot affect the future of the computation.

473
00:25:11,180 --> 00:25:15,750
看下这个特殊的例子
So let me show you that in a particular example.

474
00:25:17,124 --> 00:25:22,200
#TBD
Now that means I'm going to have to append to my description of the list structure a mark.

475
00:25:23,640 --> 00:25:27,825
在这里是一个Lisp结构化的内存
And so here, for example, is a Lisp structured memory.

476
00:25:29,080 --> 00:25:31,333
在这块内存里是一个Lisp数据结构
And in this Lisp structured memory is a Lisp structure

477
00:25:31,333 --> 00:25:34,150
我们把这个起始位置
beginning in a place I'm going to call--

478
00:25:35,875 --> 00:25:36,775
称为根
this is the root.

479
00:25:38,590 --> 00:25:40,120
它不必真是的根
Now it doesn't really have to have a root.

480
00:25:40,120 --> 00:25:41,950
因为有很多这种东西 与寄存器类似
It could be a bunch of them, like all the registers.

481
00:25:42,670 --> 00:25:44,138
但我可以#TBD
But I could cleverly arrange it

482
00:25:44,138 --> 00:25:46,300
因此所有的寄存器 所有在旧寄存器里的东西
so all the registers, all the things that are in old registers

483
00:25:46,300 --> 00:25:50,460
也应该放在这个根结构里
are also at the right moment put into this root structure,

484
00:25:50,460 --> 00:25:51,850
然后我们有一个指针指向它
and then we've got one pointer to it.

485
00:25:51,850 --> 00:25:52,675
我不是很在意
I don't really care.

486
00:25:54,570 --> 00:25:58,050
思路是 我们要一直把东西用cons连接起来 直到我们的free list为空
So the idea is we're going to cons up stuff until our free list is empty.

487
00:25:58,720 --> 00:25:59,675
我们用尽所有的空间
We've run out of things.

488
00:26:00,950 --> 00:26:04,475
现在我们要证明这个理论
Now we're going to do this process of proving the theorem

489
00:26:04,475 --> 00:26:06,900
#TBD
that a certain percentage of the memory has got crap in it.

490
00:26:07,850 --> 00:26:09,250
然后我们要回收它
And then we're going to recycle that

491
00:26:09,787 --> 00:26:10,875
构建一个新的树 
to grow new trees, 

492
00:26:11,904 --> 00:26:14,570
这是对于垃圾基本处理方式
a standard use of such garbage.

493
00:26:17,090 --> 00:26:18,840
那么我们要做什么呢?
So in any case, what do we have here?

494
00:26:18,840 --> 00:26:22,545
从p5这个位置开始 
Well we have some data structure which starts out over here 

495
00:26:22,545 --> 00:26:24,275
存了一些数据结构
in p5.

496
00:26:25,150 --> 00:26:26,750
从1开始
and it will start at one

497
00:26:27,275 --> 00:26:32,209
事实上 p5是一个car
And in fact it has a car in p5, 

498
00:26:32,209 --> 00:26:33,980
 它的cdr在2这个位置
and its cdr is in two.

499
00:26:33,980 --> 00:26:35,800
所有标记都是从0开始的
And all the marks start out at zero.

500
00:26:36,700 --> 00:26:39,000
我们要开始标记了
Well let's start marking, just to play this game.

501
00:26:39,920 --> 00:26:40,525
好
OK.

502
00:26:42,540 --> 00:26:44,475
例如
So for example,

503
00:26:44,475 --> 00:26:46,950
因为我可以从根访问到它 
since I can access one from the root 

504
00:26:46,950 --> 00:26:47,975
我就标记一下
I will mark that.

505
00:26:48,390 --> 00:26:49,175
让我标记一下
Let me mark it.

506
00:26:50,960 --> 00:26:51,450
砰
Bang.

507
00:26:52,430 --> 00:26:53,150
这个被标记了
That's marked.

508
00:26:54,560 --> 00:26:57,510
因为这有个5 
Now since I have a five here 

509
00:26:57,510 --> 00:26:58,675
所以我跑到了5
I can go to five

510
00:26:59,025 --> 00:27:00,725
看 我要标记这个
and see, well I'll mark that.

511
00:27:01,450 --> 00:27:01,760
砰
Bang.

512
00:27:01,760 --> 00:27:02,600
这是个有用的东西
That's useful stuff.

513
00:27:02,900 --> 00:27:05,275
但5的car是个数字
But five references as a number in its car,

514
00:27:05,275 --> 00:27:06,765
我对标记数字不感兴趣 
I'm not interested in marking numbers 

515
00:27:06,765 --> 00:27:08,175
但它的cdr是7
but its cdr is seven.

516
00:27:08,700 --> 00:27:09,750
所以我可以标记它
So I can mark that.

517
00:27:10,450 --> 00:27:11,075
砰
Bang.

518
00:27:12,260 --> 00:27:13,400
7是一个空列表
Seven is the empty list,

519
00:27:13,675 --> 00:27:15,100
#TBD
the only thing that references,

520
00:27:15,595 --> 00:27:17,120
它的car是个数字
and it's got a number in its car.

521
00:27:17,120 --> 00:27:17,850
对它不感兴趣
Not interesting.

522
00:27:19,490 --> 00:27:20,500
让我们回到这里
Well now let's go back here.

523
00:27:20,500 --> 00:27:21,650
我忘记了一些事情
I forgot about something.

524
00:27:21,650 --> 00:27:22,175
2
Two.

525
00:27:22,840 --> 00:27:24,850
换句话说 如果我看格子1
See in other words, if I'm looking at cell one,

526
00:27:25,425 --> 00:27:29,450
格子1包括了#TBD
cell one contains a two right over here.

527
00:27:30,370 --> 00:27:31,300
一个到2的引用
A reference to two.

528
00:27:31,730 --> 00:27:34,975
这意味着我应该标记2
That means I should go mark two.

529
00:27:35,700 --> 00:27:36,275
砰
Bang.

530
00:27:37,140 --> 00:27:38,960
2包括了一个到4的引用
Two contains a reference to four.

531
00:27:38,960 --> 00:27:40,279
它的car是个数字 
It's got a number in its car, 

532
00:27:40,279 --> 00:27:41,200
我对它不感兴趣

533
00:27:41,489 --> 00:27:42,725
所以我要标记它
so I'm going to go mark that.

534
00:27:43,780 --> 00:27:46,100
4通过car引用了7
Four refers to seven through its car,

535
00:27:46,750 --> 00:27:48,475
它的cdr是空的
and is empty in its cdr,

536
00:27:48,475 --> 00:27:49,576
但由于我已经标记过了 
but I've already marked that one 

537
00:27:49,576 --> 00:27:50,750
就不再次标记它了
so I don't have to mark it again.

538
00:27:51,400 --> 00:27:53,875
这就是这个地方所有能够访问的结构
This is all the accessible structure from that place.

539
00:27:55,000 --> 00:27:56,575
很简单的递归标记算法
Simple recursive mark algorithm.

540
00:27:58,710 --> 00:28:01,900
这个算法有一些不足的地方
Now there are some unhappinesses about that algorithm,

541
00:28:01,900 --> 00:28:04,025
我们稍后会说
and we can worry about that a second.

542
00:28:04,920 --> 00:28:06,525
但基本上你能看到 
But basically you'll see 

543
00:28:06,525 --> 00:28:07,850
所有没被标记的
that all the things that have not been marked

544
00:28:09,625 --> 00:28:12,525
#TBD 都是可以回收的
are places that are free, and I could recycle.

545
00:28:14,250 --> 00:28:15,750
所以下一步就是
So the next stage after that is going to be 

546
00:28:15,750 --> 00:28:17,050
扫描整个内存
to scan through all of my memory,

547
00:28:17,945 --> 00:28:20,350
寻找未被标记的东西
looking for things that are not marked.

548
00:28:21,180 --> 00:28:22,450
每当遇到一个已标记的东西 
Every time I come across a marked thing 

549
00:28:22,450 --> 00:28:23,225
就把标记去掉
I unmark it,

550
00:28:23,225 --> 00:28:25,575
每当遇到未标记的东西时
and every time I come across an unmarked thing

551
00:28:26,297 --> 00:28:27,825
我就把它连接到我的free list里面
I'm going to link it together in my free list.

552
00:28:28,770 --> 00:28:30,300
传统而且非常简单的算法
Classic, very simple algorithm.

553
00:28:32,120 --> 00:28:33,100
我们看
So let's see.

554
00:28:33,840 --> 00:28:34,770
它很简单吗?
Is that very simple?

555
00:28:34,770 --> 00:28:35,570
是的
Yes it is.

556
00:28:35,570 --> 00:28:38,009
我不会深入代码细节
I'm not going to go through the code in any detail,

557
00:28:38,009 --> 00:28:39,650
只是想给你看看它有多长
but I just want to show you about how long it is.

558
00:28:40,090 --> 00:28:41,100
看这个标记阶段
Let's look at the mark phase.

559
00:28:41,575 --> 00:28:44,145
这是标记阶段的第一部分
Here's the first part of the mark phase.

560
00:28:45,060 --> 00:28:46,000
我们找到根
We pick up the root.

561
00:28:46,500 --> 00:28:47,525
我们要
We're going to do some

562
00:28:47,675 --> 00:28:51,050
我们要对它进行递归过程调用
We're going to use that as a recursive procedure call.

563
00:28:52,380 --> 00:28:54,475
当我们完成标记之后
We're going to sweep from there,

564
00:28:54,775 --> 00:28:56,950
就从这里开始清除
after when we're done with marking.

565
00:28:57,380 --> 00:29:03,075
#TBD
And then we're going to do a little couple of instructions that do this checking out on the marks and changing the marks and things like that,

566
00:29:03,075 --> 00:29:04,900
按照我刚才讲的那个算法进行
according to the algorithm I've just shown you.

567
00:29:05,500 --> 00:29:06,470
#TBD
It comes out here.

568
00:29:06,470 --> 00:29:07,650
你需要标记它们的car
You have to mark the cars of things

569
00:29:07,875 --> 00:29:10,212
也需要标记它们的cdr
and you also have to be able to mark the cdrs of things.

570
00:29:10,660 --> 00:29:12,100
这就是整个标记阶段
That's the entire mark phase.

571
00:29:14,370 --> 00:29:16,164
我给你讲个关于它的小故事
I'll just tell you a little story about this.

572
00:29:16,590 --> 00:29:19,375
古董货DEC PDP-6计算机
The old DEC PDP-6 computer,

573
00:29:20,937 --> 00:29:24,850
标记清除垃圾回收#TBD
this was the way that the mark-sweep garbage collection, as it was, was written.

574
00:29:26,740 --> 00:29:28,500
程序很短
The program was so small

575
00:29:29,257 --> 00:29:31,600
包括它需要的数据
that with the data that it needed,

576
00:29:32,201 --> 00:29:34,875
还包括它用来操作内存的寄存器
with the registers that it needed to manipulate the memory,

577
00:29:36,169 --> 00:29:38,975
能放到机器的快速寄存器里 #TBD 16
it fit into the fast registers of the machine, which were 16.

578
00:29:39,280 --> 00:29:39,800
整个程序
The whole program.

579
00:29:39,800 --> 00:29:42,212
你可以在快速寄存器里执行指令
And you could execute instructions in the fast registers.

580
00:29:43,170 --> 00:29:45,000
所以这是个非常短的程序
So it's an extremely small program,

581
00:29:45,850 --> 00:29:47,075
它跑得飞快
and it could run very fast.

582
00:29:48,870 --> 00:29:51,300
很不幸
Now unfortunately, of course,

583
00:29:51,610 --> 00:29:54,025
因为这个程序是递归的
this program, because the fact that it's recursive

584
00:29:54,800 --> 00:29:59,216
#TBD
in the way that you do something first and then you do something after that,

585
00:29:59,216 --> 00:30:01,150
你不得不先处理car 再处理cdr
you have to work on the cars and then the cdrs,

586
00:30:01,150 --> 00:30:02,750
这需要海量的内存
it requires auxiliary memory.

587
00:30:03,410 --> 00:30:07,425
所以Lisp系统需要一个栈来进行标记
So Lisp systems-- those requires a stack for marking.

588
00:30:08,260 --> 00:30:11,050
Lisp系统通过这样的方式
Lisp systems that are built this way

589
00:30:11,575 --> 00:30:14,425
限制了你在数据结构上
have a limit to the depth of recursion you can have

590
00:30:14,425 --> 00:30:17,375
进行car或者cdr递归的深度
in data structures in either the car or the cdr,

591
00:30:17,817 --> 00:30:19,350
这并不太靠谱
and that doesn't work very nicely.

592
00:30:19,930 --> 00:30:22,175
另一方面 当它足够大的时候你不会发现
On the other hand, you never notice it if it's big enough.

593
00:30:23,180 --> 00:30:28,697
例如对于Maclisp#TBD
And that's certainly been the case for most Maclisp, for example,

594
00:30:28,697 --> 00:30:32,725
#TBD
which ran Macsyma where you could deal with expressions of thousands of elements long.

595
00:30:33,560 --> 00:30:36,025
#TBD
These are algebraic expressions with thousand of terms.

596
00:30:36,825 --> 00:30:38,100
这没啥问题
And there's no problem with that.

597
00:30:39,490 --> 00:30:40,825
垃圾回收器能正常工作
Such, the garbage collector does work.

598
00:30:42,190 --> 00:30:42,925
另一方面
On the other hand,

599
00:30:42,925 --> 00:30:45,375
这个算法有个很精妙的魔改版 
there's a very clever modification to this algorithm, 

600
00:30:45,375 --> 00:30:46,475
但我不会去讲
which I will not describe,

601
00:30:46,800 --> 00:30:50,768
它是由两个人提出的
by Peter Deutsch and Schorr and Waite--

602
00:30:50,768 --> 00:30:52,725
IBM的Herb Schorr和Waite 
Herb Schorr from IBM and Waite, 

603
00:30:52,725 --> 00:30:54,750
后面这个我不认识
who I don't know.

604
00:30:55,380 --> 00:30:56,675
这个算法让你
That algorithm allows you to build- -

605
00:30:56,675 --> 00:30:59,550
能够不消耗大量内存就完成工作
you do can do this without auxiliary memory,

606
00:31:00,500 --> 00:31:02,975
通过反转你下降的时候的指针
by remembering as you walk the data structures

607
00:31:02,975 --> 00:31:05,525
#TBD
where you came from by reversing the pointers as you go down

608
00:31:05,525 --> 00:31:07,520
通过反转的指针再回去
and crawling up the reverse pointers as you go up.

609
00:31:07,520 --> 00:31:09,130
这是个很取巧的算法
It's a rather tricky algorithm.

610
00:31:09,130 --> 00:31:12,725
你第一次写它 事实上 前三次你写的时候都会写出惊天大bug
The first time you write it-- or in fact, the first three times you write it it has a terrible bug in it.

611
00:31:14,350 --> 00:31:16,725
也可能跑得奇慢无比
And it's also rather slow, 

612
00:31:16,725 --> 00:31:17,675
因为这个算法太复杂了
because it's complicated.

613
00:31:18,110 --> 00:31:20,450
它用了七倍的内存引用
It takes about six times as many memory references

614
00:31:20,850 --> 00:31:23,225
来完成我们刚才讨论的任务
to do the sorts of things that we're talking about.

615
00:31:24,580 --> 00:31:27,075
一旦我完成了标记阶段
Well now once I've done this marking phase,

616
00:31:27,500 --> 00:31:31,510
#TBD
and I get into a position where things look like this, let's look-- yes.

617
00:31:31,510 --> 00:31:35,050
这里完成了标记工作 和我刚才做的一样
Here we have the mark done, just as I did it.

618
00:31:35,590 --> 00:31:37,330
现在我们要进行清除阶段
Now we have to perform the sweep phase.

619
00:31:37,330 --> 00:31:39,325
我刚才已经讲过如何清除了
And I described to you what this sweep is like.

620
00:31:39,820 --> 00:31:42,348
我要从内存的一端开始
I'm going to walk down from one end of memory or the other,

621
00:31:42,348 --> 00:31:43,628
哪一端都可以
I don't care where,

622
00:31:43,628 --> 00:31:46,175
扫描内存中的每个格子
scanning every cell that's in the memory.

623
00:31:47,175 --> 00:31:48,675
在扫描的同时
And as I scan these cells,

624
00:31:49,207 --> 00:31:51,950
如果是空闲内存
I'm going to link them together, if they are free,

625
00:31:51,950 --> 00:31:53,150
就把它们连接到free list里
into the free list.

626
00:31:53,150 --> 00:31:54,050
如果它们不是空闲内存 
And if they're not free, 

627
00:31:54,050 --> 00:31:56,075
我就把它们的标记清除掉
I'm going to unmark them so the marks become zero.

628
00:31:57,500 --> 00:31:58,700
事实上
And in fact what I get--

629
00:31:58,700 --> 00:32:00,460
最终的程序并不很复杂
well the program is not very complicated.

630
00:32:00,460 --> 00:32:02,225
它只是变长了一些
It looks sort of like this-- it's a little longer.

631
00:32:02,780 --> 00:32:04,175
这是第一部分
Here's the first piece of it.

632
00:32:04,820 --> 00:32:06,710
这玩意从内存的顶端下降下来
This one's coming down from the top of memory.

633
00:32:06,710 --> 00:32:09,580
我不期望你现在就搞懂它
I don't want you to try to understand this at this point.

634
00:32:09,580 --> 00:32:10,550
它挺简单的
It's rather simple.

635
00:32:11,030 --> 00:32:12,525
这是个非常简单的算法
It's a very simple algorithm,

636
00:32:13,075 --> 00:32:15,970
#TBD
but there's pieces of it that just sort of look like this.

637
00:32:15,970 --> 00:32:17,375
非常显而易见
They're all sort of obvious.

638
00:32:18,600 --> 00:32:20,307
在清理结束后
And after we've done the sweep,

639
00:32:20,307 --> 00:32:22,025
我们就得到了长这个样子的结果
we get an answer that looks like that.

640
00:32:25,330 --> 00:32:28,500
标记清除算法有一些缺点
Now there are some disadvantages with mark-sweep algorithms of this sort.

641
00:32:29,590 --> 00:32:30,350
最严重的一个是
Serious ones.

642
00:32:31,450 --> 00:32:33,203
最重要的缺点是 
One important disadvantage is 

643
00:32:33,203 --> 00:32:34,975
你的内存越来越大
that your memories get larger and larger.

644
00:32:36,826 --> 00:32:38,875
内存空间越来越大 
As you say, address spaces get larger and larger, 

645
00:32:38,875 --> 00:32:40,800
你想用它存更多东西
you're willing to represent more and more stuff,

646
00:32:41,370 --> 00:32:44,750
这导致扫描整个内存的耗时特别长
then it gets very costly to scan all of memory.

647
00:32:46,360 --> 00:32:48,900
你真正想做的是只扫描有用的东西
What you'd really like to do is only scan useful stuff.

648
00:32:50,490 --> 00:32:51,550
这样就会好一点
It would even be better

649
00:32:52,075 --> 00:32:57,725
如果你意识到有些东西是有用的
if you realized that some stuff was known to be good and useful,

650
00:32:58,283 --> 00:33:00,370
你就没必要去多次检查它
and you don't have to look at it more than once or twice.

651
00:33:00,370 --> 00:33:01,200
或者不用经常去检查它
Or very rarely.

652
00:33:01,550 --> 00:33:04,325
对于那些你不太确定的
Whereas other stuff that you're not so sure about,

653
00:33:05,003 --> 00:33:06,425
你可以在每次需要的时候
you can look at more detail 

654
00:33:07,100 --> 00:33:08,750
进行仔细检查
every time you want to do this,

655
00:33:09,931 --> 00:33:10,850
也就是垃圾回收的时候
want to garbage collect.

656
00:33:11,910 --> 00:33:15,100
这些算法就是用了这样的方法
Well there are algorithms that are organized in this way.

657
00:33:15,660 --> 00:33:18,282
我要介绍一个著名的古老算法
Let me tell you about a famous old algorithm

658
00:33:18,282 --> 00:33:21,375
它让你只检查可用部分的内存
which allows you only look at the part of memory which is known to be useful.

659
00:33:22,800 --> 00:33:25,550
这让它成为了最快的垃圾回收算法
And which happens to be the fastest known garbage collector algorithm.

660
00:33:26,310 --> 00:33:29,450
它就是Minsky-Fenichel-Yochelson垃圾回收算法
This is the Minsky-Fenichel-Yochelson garbage collector algorithm.

661
00:33:30,150 --> 00:33:36,525
它在1961年或1960年时由Minsky发明
It was invented by Minsky in 1961 or '60 or something,

662
00:33:36,525 --> 00:33:39,825
当时是给RLE PDP-1 Lisp用的
for the RLE PDP-1 Lisp,

663
00:33:40,125 --> 00:33:43,584
这个机器只有4096个字的线性内存
which had 4,096 words of list memory, 

664
00:33:45,650 --> 00:33:46,800
 还有个#TBD
and a drum.

665
00:33:48,480 --> 00:33:51,875
#TBD
And the whole idea was to garbage collect this terrible memory.

666
00:33:53,050 --> 00:33:55,625
Minsky发现达到目的的最容易的方法是
What Minsky realized was the easiest way to do this

667
00:33:56,200 --> 00:33:58,475
一视同仁地扫描整个内存
is to scan the memory in the same sense,

668
00:33:58,475 --> 00:34:00,600
遍历好的结构
walking the good structure,

669
00:34:01,575 --> 00:34:05,475
把它复制到drum 压缩
copying it out into the drum, compacted.

670
00:34:06,350 --> 00:34:09,127
结束之后 把它们复制出来
And then when we were done copying it all out,

671
00:34:09,127 --> 00:34:10,900
并把它们交换回内存里
then you swap that back into your memory.

672
00:34:12,300 --> 00:34:14,710
不管你有没有用drum或者其他的内存 
Now whether or you not use a drum, or another piece of memory, 

673
00:34:14,710 --> 00:34:16,425
这不重要

674
00:34:17,030 --> 00:34:19,600
事实上 我不认为#TBD
In fact, I don't think people use drums anymore for anything.

675
00:34:20,350 --> 00:34:25,425
但这个算法依赖
But this algorithm basically depends upon having

676
00:34:25,425 --> 00:34:28,575
大约两倍于你实际使用的内存
about twice as much address space as you're actually using.

677
00:34:30,270 --> 00:34:33,125
最开始 你有一些
And so what you have is some, initially,

678
00:34:33,125 --> 00:34:37,110
可用的数据和垃圾的混合物
some mixture of useful data and garbage.

679
00:34:37,110 --> 00:34:38,560
它被成为fromspace
So this is called fromspace.

680
00:34:45,179 --> 00:34:47,050
这是crud的混合
And this is a mixture of crud.

681
00:34:47,800 --> 00:34:49,950
有些是有用的有些没有
Some of it's important and some of it isn't.

682
00:34:52,000 --> 00:34:55,775
有一个地方需要足够大
Now there's another place which is hopefully big enough,

683
00:34:55,775 --> 00:34:58,240
这个地方叫topspace 要把东西复制进去
if we recall, tospace, which is where we're copying to.

684
00:35:01,590 --> 00:35:02,600
然后就发生了
And what happens is--

685
00:35:02,600 --> 00:35:04,970
我不会深入细节
and I'm not going to go through this detail.

686
00:35:04,970 --> 00:35:07,075
书上写得很清楚了
It's in our book quite explicitly.

687
00:35:07,590 --> 00:35:10,400
有一个你开始的根节点
There's a root point where you start from.

688
00:35:11,030 --> 00:35:14,300
你从这里开始
And the idea is that you start with the root.

689
00:35:14,600 --> 00:35:16,425
复制你看到的第一个东西
You copy the first thing you see,

690
00:35:17,832 --> 00:35:19,752
#TBD
the first thing that the root points at,

691
00:35:19,752 --> 00:35:21,425
复制到topspace的开始
to the beginning of tospace.

692
00:35:22,810 --> 00:35:25,975
第一个东西是一个序对或者数据结构
The first thing is a pair or something like, a data structure.

693
00:35:27,560 --> 00:35:31,775
#TBD
You then also leave behind a broken heart saying,

694
00:35:31,775 --> 00:35:35,743
我把东西从这移动到这
I moved this object from here to here,

695
00:35:35,743 --> 00:35:37,050
在它要去的地方分配空间
giving the place where it moved to.

696
00:35:37,800 --> 00:35:39,650
这被叫作broken heart是因为
This is called a broken heart because

697
00:35:39,650 --> 00:35:43,825
我的一个朋友1966年实现了它
a friend of mine who implemented one of these in 1966

698
00:35:43,825 --> 00:35:45,262
他是个文艺青年 
was a very romantic character 

699
00:35:45,262 --> 00:35:46,760
就取名叫破碎的心
and called it a broken heart.

700
00:35:49,580 --> 00:35:51,150
不论如何
But in any case,

701
00:35:51,150 --> 00:35:52,942
接下来要做的是
the next thing you do

702
00:35:52,942 --> 00:35:55,175
这有个新的free pointer
is now you have a new free pointer which is here,

703
00:35:55,175 --> 00:35:57,840
你开始扫描
and you start scanning.

704
00:35:57,840 --> 00:35:59,775
你扫描这个你刚复制过的数据结构
You scan this data structure you just copied.

705
00:36:00,551 --> 00:36:02,195
每当你encounter一个指针到里面
And every time you encounter a pointer in it,

706
00:36:02,195 --> 00:36:04,000
你把它当作root pointer
you treat it as if it was the root pointer here.

707
00:36:04,000 --> 00:36:05,170
对不起
Oh, I'm sorry.

708
00:36:05,170 --> 00:36:07,150
你做的另一件事是 你将根指针移动到这里
The other thing you do is you now move the root pointer to there.

709
00:36:09,220 --> 00:36:10,175
所以你可以扫描这里
So now you scan this,

710
00:36:10,175 --> 00:36:12,375
把每个遇到的东西都作为根指针对待
and everything you see you treat as it were the root pointer.

711
00:36:14,110 --> 00:36:15,450
如果你看到了什么
So if you see something,

712
00:36:15,450 --> 00:36:17,400
它指向了这里的某个地方
well it points up into there somewhere.

713
00:36:18,510 --> 00:36:21,125
它指向了你没复制的东西吗?
Is it pointing at a thing which you've not copied yet?

714
00:36:21,780 --> 00:36:22,875
这里有破碎的心吗
Is there a broken heart there?

715
00:36:23,880 --> 00:36:26,202
如果#TBD
If there's a broken heart there and it's something you have copied,

716
00:36:26,202 --> 00:36:28,750
#TBD
you've just replaced this pointer with the thing a broken heart points at.

717
00:36:29,825 --> 00:36:32,125
如果它还没被复制
If this thing has not been copied,

718
00:36:32,125 --> 00:36:34,430
你把它移到这里
you copy it to the next place over here.

719
00:36:34,430 --> 00:36:35,950
把你的free指针移到这里
Move your free pointer over here,

720
00:36:37,053 --> 00:36:41,800
#TBD
and then leave a broken heart behind and scan.

721
00:36:43,670 --> 00:36:46,400
最终已扫描的指针追上了free指针
And eventually when the scant pointer hits the free pointer,

722
00:36:46,825 --> 00:36:48,525
内存里的所有东西都被复制了
everything in memory has been copied.

723
00:36:50,140 --> 00:36:52,075
那么就有一大堆空闲空间了
And then there's a whole bunch of empty space up here,

724
00:36:52,075 --> 00:36:54,470
你就可以把它们放进free list里
which you could either make into a free list, if that's what you want to do.

725
00:36:54,470 --> 00:36:56,270
但通常在这种系统中你不会这样做
But generally you don't in this kind of system.

726
00:36:56,270 --> 00:36:59,150
在这个系统中你顺序分配你的内存
In this system you sequentially allocate your memory.

727
00:37:00,910 --> 00:37:02,975
这是个非常 非常好的算法
That is a very, very nice algorithm,

728
00:37:02,975 --> 00:37:05,975
在你们用的scheme里就有这么个东西
and sort of the one we use in the scheme that you've been using.

729
00:37:06,790 --> 00:37:09,475
它应该是--
And it's expected--

730
00:37:09,475 --> 00:37:12,125
我相信没人能发现比它跑得更快的算法
I believe no one has found a faster algorithm than that.

731
00:37:12,400 --> 00:37:14,850
有一些对这个算法的简单修改
There are very simple modifications to this algorithm

732
00:37:14,850 --> 00:37:16,775
由Henry Baker发明
invented by Henry Baker

733
00:37:17,175 --> 00:37:20,311
它让你能实时运行这个算法
which allow one to run this algorithm in real time,

734
00:37:20,311 --> 00:37:22,010
这意味着你在垃圾回收的时候不需要停下来
meaning you don't have to stop to garbage collect.

735
00:37:22,010 --> 00:37:26,327
#TBD
But you could interleave the consing that the machine does when its running

736
00:37:26,327 --> 00:37:28,400
#TBD
with steps of the garbage collection process,

737
00:37:31,200 --> 00:37:32,416
机器不需要停下来
and the machine doesn't have to stop,

738
00:37:32,416 --> 00:37:33,475
垃圾回收才能开始
and garbage collecting can start.

739
00:37:34,640 --> 00:37:38,000
在使用虚拟内存的机器中
Of course in the case of machines with virtual memory

740
00:37:38,900 --> 00:37:41,509
#TBD
where a lot of it is in inaccessible places,

741
00:37:41,509 --> 00:37:43,600
#TBD
this becomes a very expensive process.

742
00:37:44,460 --> 00:37:48,650
#TBD
And there have been numerous attempts to make this much better.

743
00:37:49,190 --> 00:37:52,645
对于感兴趣的同学 这有一篇论文
There is a nice paper, for those of you who are interested,

744
00:37:52,645 --> 00:37:54,650
由Moon等人写的
by Moon and other people

745
00:37:54,650 --> 00:37:59,514
这篇论文描述了对于insky-Fenichel-Yochelson算法的一个修改#TBD
which describes a modification to the incremental Minsky-Fenichel-Yochelson algorithm,

746
00:37:59,514 --> 00:38:01,425
和Baker算法的一个修改
and modification the Baker algorithm

747
00:38:01,425 --> 00:38:06,600
让使用虚拟内存的系统更加高效
which is more efficient for virtual memory systems.

748
00:38:08,340 --> 00:38:12,840
现在最后一个谜团也解开了
Well I think now the mystery to this is sort of gone.

749
00:38:12,840 --> 00:38:14,090
谁有问题呢
And I'd like to see if there are any questions.

750
00:38:19,780 --> 00:38:20,810
请讲
Yes.

751
00:38:20,810 --> 00:38:25,125
学生: 我在楼上的一些系统里看到你运行的垃圾回收器
AUDIENCE: I saw one of you run the garbage collector on the systems upstairs,

752
00:38:25,937 --> 00:38:28,497
它看起来跑得飞快
and it seemed to me to run extremely fast.

753
00:38:28,497 --> 00:38:31,880
它真的清理了整个内存吗?
Did the whole thing take-- does it sweep through all of memory?

754
00:38:31,880 --> 00:38:32,510
教授: 没有
PROFESSOR: No.

755
00:38:32,510 --> 00:38:35,912
它只清理了那些需要复制有用数据结构的内存
It swept through exactly what was needed to copy the useful structure.

756
00:38:37,320 --> 00:38:38,950
它是个复制收集器
It's a copying collector.

757
00:38:39,300 --> 00:38:44,600
它确实很快#TBD
And it is very fast. On the whole, I suppose to copy--

758
00:38:45,050 --> 00:38:48,442
#TBD
in a Bobcat-- to copy,

759
00:38:48,442 --> 00:38:53,200
一个3MB的东西将在1秒内完成
I think, a three megabyte thing or something is less than a second, real time.

760
00:38:54,925 --> 00:38:58,625
它们是非常小的程序
Really, these are very small programs.

761
00:38:58,625 --> 00:39:02,200
你需要注意到的一件事是
One thing you should realise is that

762
00:39:02,913 --> 00:39:04,400
垃圾回收器必须要小
garbage collectors have to be small.

763
00:39:05,400 --> 00:39:07,100
不是因为它们需要跑得很快
Not because they have to be fast,

764
00:39:07,905 --> 00:39:10,650
而是因为没人能对一个复杂的垃圾回收器排查错误
but because no one can debug a complicated garbage collector.

765
00:39:11,340 --> 00:39:13,075
如果一个垃圾回收器不能正常工作
A garbage collector, if it doesn't work,

766
00:39:14,049 --> 00:39:15,933
它把你的内存搞得一团糟 
will trash your memory in such a way 

767
00:39:15,933 --> 00:39:17,550
你却束手无策
that you cannot figure out what the hell happened.

768
00:39:18,350 --> 00:39:19,675
#TBD
You need an audit trail.

769
00:39:20,660 --> 00:39:23,336
因为它把所有东西都换了位置 你又如何知道发生了什么
Because it rearranges everything, and how do you know what happened there?

770
00:39:23,740 --> 00:39:26,587
#TBD
So this is the only kind of program that

771
00:39:26,925 --> 00:39:31,970
#TBD
it really, seriously matters if you stare at it long enough so you believe that it works.

772
00:39:31,970 --> 00:39:33,400
#TBD
And sort of prove it to yourself.

773
00:39:35,100 --> 00:39:36,940
无法对它进行查错
So there's no way to debug it.

774
00:39:36,940 --> 00:39:39,975
这意味着它需要足够小 让你能脑补出它的工作情况
And that takes it being small enough so you can hold it in your head.

775
00:39:41,690 --> 00:39:43,925
垃圾回收器的就是如此特殊
Garbage collectors are special in this way.

776
00:39:45,020 --> 00:39:46,775
所以每个#TBD的垃圾回收器一定体积很小
So every reasonable garbage collector has gotten small,

777
00:39:46,775 --> 00:39:48,450
而通常小程序跑得就快
and generally small programs are fast.

778
00:39:52,050 --> 00:39:52,430
请提问
Yes.

779
00:39:52,430 --> 00:39:54,510
学生: 您能再重复一遍这个技术的名字吗?
AUDIENCE: Can you repeat the name of this technique once again?

780
00:39:54,510 --> 00:39:56,925
教授: 是Minsky-Fenichel-Yochelson垃圾回收器
PROFESSOR: That's the Minsky-Fenichel-Yochelson garbage collector.

781
00:39:58,420 --> 00:39:59,340
学生: 啥?
AUDIENCE: You got that?

782
00:39:59,340 --> 00:40:02,210
教授: Minsky在1961年时为RLE PDP-1发明了它
PROFESSOR: Minsky invented it in '61 for the RLE PDP-1.

783
00:40:02,210 --> 00:40:06,450
它的一个版本被Fenichel和Yochelson继续开发优化后
A version of it was developed and elaborated

784
00:40:06,450 --> 00:40:10,275
被用在了Multics Maclisp里面
to be used in Multics Maclisp by Fenichel and Yochelson

785
00:40:11,378 --> 00:40:14,750
那时大约是1968或者1969年
in somewhere around 1968 or '69.

786
00:40:19,570 --> 00:40:20,650
好
OK.

787
00:40:20,650 --> 00:40:21,400
休息一下
Let's take a break.

788
00:40:22,640 --> 00:41:16,675
[音乐]
[JESU, JOY OF MAN'S DESIRING]

789
00:41:17,310 --> 00:41:19,675
教授: 我们到课程的最后一部分了
PROFESSOR: Well we've come to the end of this subject,

790
00:41:19,675 --> 00:41:23,850
我已经给你们展示了一个通用的机器
and we've already shown you a universal machine

791
00:41:24,475 --> 00:41:26,740
它被简化为求值器
which is down to evaluator.

792
00:41:27,025 --> 00:41:28,388
它被简化到
It's down to the level of detail 

793
00:41:28,388 --> 00:41:29,675
你能想象自己可以做一个
you could imagine you could make one.

794
00:41:30,420 --> 00:41:33,325
这就是个特定的Lisp实现
This is a particular implementation of Lisp,

795
00:41:33,900 --> 00:41:36,074
就是用我昨天讲到的
built on one of those 

796
00:41:36,074 --> 00:41:38,050
scheme芯片做的
scheme chips that was talked about yesterday, 

797
00:41:38,050 --> 00:41:39,180
 就是这个
sitting over here.

798
00:41:39,350 --> 00:41:42,000
#TBD
This is mostly interface to somebody's memory

799
00:41:42,600 --> 00:41:44,750
#TBD
with a little bit of timing and other such stuff.

800
00:41:45,225 --> 00:41:47,250
但它们实际能以合理的速度
But this fellow actually ran Lisp

801
00:41:47,775 --> 00:41:50,175
运行Lisp
at a fairly reasonable rate, as interpretive.

802
00:41:50,610 --> 00:41:53,825
它跑得像1979年的
It ran Lisp as fast as a DEC PDP-10

803
00:41:54,250 --> 00:41:55,675
back in 1979.
DEC PDP-10一样快

804
00:41:56,500 --> 00:41:59,675
这是一个硬件
And so it's gotten pretty hardware.

805
00:42:00,025 --> 00:42:02,175
是个实物
Pretty concrete.

806
00:42:02,470 --> 00:42:06,075
#TBD
We've also downed you a bit with the things you can compute.

807
00:42:07,370 --> 00:42:10,550
那么有我们无法计算的情况吗?
But is it the case that there are things we can't compute?

808
00:42:11,850 --> 00:42:13,500
让我以展示一些
And so I'd like to end this with

809
00:42:13,750 --> 00:42:17,225
你不能计算的东西作为结尾
showing you some things that you'd like be able to compute that you can't.

810
00:42:18,190 --> 00:42:19,375
答案是 是的
The answer is yes,

811
00:42:19,375 --> 00:42:20,825
有无法计算的事物
there are things you can't compute.

812
00:42:22,720 --> 00:42:23,471
例如
For example,

813
00:42:24,450 --> 00:42:25,825
有些东西是你很想要的
something you'd really like is--

814
00:42:27,800 --> 00:42:29,300
当你正在写一个编译器时
if you're writing a compiler

815
00:42:29,775 --> 00:42:31,425
你想要一个程序
you'd like a program that would check

816
00:42:32,000 --> 00:42:33,975
检查你的代码能不能正常运行
that the thing you're going to do will work.

817
00:42:34,630 --> 00:42:35,400
这不是很棒吗?
Wouldn't that be nice?

818
00:42:36,080 --> 00:42:37,875
你希望能够捕获死循环
You'd like something that would catch infinite loops,

819
00:42:37,875 --> 00:42:38,500
例如
for example,

820
00:42:39,450 --> 00:42:42,425
用户的程序里的死循环
in programs that were written by users.

821
00:42:43,190 --> 00:42:45,125
但通常你写不出这样的程序
But in general you can't write such a program

822
00:42:45,350 --> 00:42:47,575
它读取和检测某个程序
that will read any program and determine whether or not

823
00:42:48,350 --> 00:42:49,300
是不是死循环
it's an infinite loop.

824
00:42:50,990 --> 00:42:51,685
我给你展示一下
Let me show you that.

825
00:42:51,685 --> 00:42:53,775
这是个关于数学的小例子
It's a little bit of a minor mathematics.

826
00:42:58,780 --> 00:42:59,650
设想
Let's imagine

827
00:43:00,050 --> 00:43:01,781
在我们开始之前
that we just had a mathematical function 

828
00:43:01,781 --> 00:43:02,620
有一个数学函数
before we start.

829
00:43:02,620 --> 00:43:03,425
这里就有一个
And there is one,

830
00:43:03,825 --> 00:43:04,550
称为S
called s, 

831
00:43:05,475 --> 00:43:07,546
它接受一个过程
which takes a procedure

832
00:43:12,525 --> 00:43:14,230
和它的参数a
and its argument, a.

833
00:43:19,175 --> 00:43:20,525
S所做的是
And what s does

834
00:43:21,650 --> 00:43:24,014
检测以a为参数运行p时 
is it determines whether or not 

835
00:43:24,014 --> 00:43:25,975
是否安全
it's safe to run p on a.

836
00:43:26,900 --> 00:43:28,175
我的意思是
And what I mean by that is this:

837
00:43:28,400 --> 00:43:35,125
如果a可以作为p的参数
it's true if p applied to a

838
00:43:35,625 --> 00:43:36,740
最终能返回一个值 
to a will converge 

839
00:43:41,400 --> 00:43:42,450
没有报错的话
to a value

840
00:43:44,350 --> 00:43:45,330
就返回true
 without an error.

841
00:43:52,700 --> 00:43:54,025
但当以a为参数调用p
And it's false 

842
00:43:56,100 --> 00:43:57,200
是死循环
if p of a 

843
00:43:59,675 --> 00:44:00,765
或者会报错
or makes an error.

844
00:44:05,875 --> 00:44:06,950
就返回false
loops forever

845
00:44:15,000 --> 00:44:17,225
这确实是个函数
Now that's surely a function.

846
00:44:18,780 --> 00:44:20,725
对于你输入的任何过程
There is some for every procedure

847
00:44:21,200 --> 00:44:22,850
或者任何参数
and for every argument you could give it

848
00:44:23,925 --> 00:44:25,425
它只能返回true或false
that is either true or false

849
00:44:25,925 --> 00:44:27,850
不会报错
that it converges without making an error.

850
00:44:28,440 --> 00:44:30,150
你可以为它们画一张巨大的表格
And you could make a giant table of them.

851
00:44:32,225 --> 00:44:32,925
但问题是
But the question is,

852
00:44:32,925 --> 00:44:34,093
你能写个一个过程 
can you write a procedure 

853
00:44:34,093 --> 00:44:35,925
计算这个函数的值吗?
that compute the values of this function?

854
00:44:37,430 --> 00:44:39,025
假设我们能做到
Well let's assume that we can.

855
00:44:39,720 --> 00:44:40,550
假设
Suppose

856
00:44:44,000 --> 00:44:45,675
我们有个过程
that we have a procedure

857
00:44:48,550 --> 00:44:52,775
叫作SAFE?
procedure called "safe"

858
00:44:56,475 --> 00:44:59,900
它能计算S的值
that computes the value of s.

859
00:45:12,475 --> 00:45:14,925
现在我要用几种方法
Now I'm going to show you by several methods

860
00:45:15,900 --> 00:45:18,475
证明你做不到
that you can't do this.

861
00:45:19,760 --> 00:45:20,626
最简单的一个 
The easiest one, 

862
00:45:20,626 --> 00:45:21,425
或者说第一个
or the first one,

863
00:45:21,425 --> 00:45:23,450
我们定义一个叫diag1的过程
let's define a procedure called diag1.

864
00:45:23,810 --> 00:45:24,945
#TBD
Given that we have safe,

865
00:45:25,200 --> 00:45:26,993
我们可以定义
we can define diag1

866
00:45:34,425 --> 00:45:35,550
diag1
diag1

867
00:45:37,550 --> 00:45:39,056
是有一个参数p
to be the procedure

868
00:45:39,675 --> 00:45:41,700
的过程
of one argument, p,

869
00:45:42,450 --> 00:45:44,050
它有着这样的属性
which has the following properties.

870
00:45:44,780 --> 00:45:50,675
如果它对自己应用p
If it's safe to apply p to itself,

871
00:45:53,325 --> 00:45:55,325
那么就形成了死循环
then I wish to have an infinite loop.

872
00:45:59,225 --> 00:46:00,925
否则我会返回3
Otherwise I'm going to return 3.

873
00:46:03,680 --> 00:46:04,470
它也可能是42
Maybe it was 42.

874
00:46:04,470 --> 00:46:06,425
宇宙的终极答案是什么?
What's the answer to the big question?

875
00:46:07,060 --> 00:46:08,875
我们当然知道死循环是什么
Where of course we know what an infinite loop is.

876
00:46:12,050 --> 00:46:12,964
死循环
Infinite loop,

877
00:46:13,825 --> 00:46:16,025
没有参数的过程
to be a procedure of no arguments,

878
00:46:16,025 --> 00:46:18,075
这是一个极好的lambda运算循环
which is that nice lambda calculus loop.

879
00:46:18,430 --> 00:46:19,289
lambda (x)
Lambda of x,

880
00:46:19,400 --> 00:46:20,475
(X X)
x of x,

881
00:46:21,300 --> 00:46:24,680
应用到(lambda (x) (x x))
applied to lambda of x, x of x.

882
00:46:24,680 --> 00:46:26,550
没什么想象的余地了
So there's nothing left to the imagination here.

883
00:46:29,830 --> 00:46:31,175
总结一下
Well let's see what the story is.

884
00:46:32,500 --> 00:46:33,908
我假设
I'm supposing it's the case

885
00:46:35,450 --> 00:46:38,772
我们担心有个过程
that we worry about the procedure

886
00:46:39,000 --> 00:46:43,450
把diag1应用到diag1上
called diag1 applied to diag1.

887
00:46:46,275 --> 00:46:47,775
那会发生什么呢?
Well what could it possibly be?

888
00:46:49,970 --> 00:46:51,390
我不知道
Well I don't know.

889
00:46:51,390 --> 00:46:53,213
将diag1代换为
We're going to substitute diag1

890
00:46:53,550 --> 00:46:55,500
p的过程体
for p in the body here.

891
00:46:57,310 --> 00:47:00,220
计算(diag1 diag1)安全吗?
Well is it safe to compute diag1 of diag1?

892
00:47:00,220 --> 00:47:00,780
我不知道
I don't know.

893
00:47:00,780 --> 00:47:01,825
有两种可能
There are two possibilities.

894
00:47:03,400 --> 00:47:05,501
如果计算(diag1 diag1)是安全的
If it's safe to compute diag1 of diag1

895
00:47:05,875 --> 00:47:07,000
这意味着不会循环
that means it shouldn't loop.

896
00:47:08,490 --> 00:47:09,225
意味着我到了这里
That means I go to here, 

897
00:47:09,225 --> 00:47:10,350
然后我生成了个死循环
but then I produce an infinite loop.

898
00:47:10,560 --> 00:47:11,575
所以它不是安全的
So it can't be safe.

899
00:47:12,210 --> 00:47:14,781
但如果计算(diag1 diag1)不安全
But if it's not safe to compute diag1 of diag1

900
00:47:14,900 --> 00:47:16,020
那么它的结果是3
then the answer to this is 3.

901
00:47:16,020 --> 00:47:17,267
但那是(diag1 diag1) 
But that's diag1 of diag1, 

902
00:47:17,267 --> 00:47:18,200
所以它必须安全才行
so it had to be safe.

903
00:47:20,530 --> 00:47:23,600
由于这个矛盾
So therefore by contradiction

904
00:47:24,325 --> 00:47:26,300
你无法写出这个SAFE?过程
you cannot produce safe.

905
00:47:27,400 --> 00:47:29,805
对于没听懂这个叙述的同学
For those of you who were boggled by that one

906
00:47:30,250 --> 00:47:32,150
我换个方式再讲一遍
I'm going to say it again, in a different way.

907
00:47:32,820 --> 00:47:34,475
请听另一个版本
Listen to one more alternative.

908
00:47:35,530 --> 00:47:36,950
我们定义diag2
Let's define diag2.

909
00:47:39,840 --> 00:47:41,600
这个diag的名字
These are named diag because

910
00:47:42,650 --> 00:47:44,725
来源于康托尔的对角论证法
of Cantor's diagonal argument.

911
00:47:45,000 --> 00:47:47,050
#TBD
These are instances of 

912
00:47:47,050 --> 00:47:49,395
#TBD
a famous argument which was originally used by

913
00:47:49,450 --> 00:47:52,650
Cantor在19世纪末
Cantor in the late part of the last century

914
00:47:52,775 --> 00:47:56,106
证明了实数是无限的
to prove that the real numbers were not countable,

915
00:47:56,675 --> 00:47:59,450
用整数无法数完实数
that there are too many real numbers to be counted by integers.

916
00:48:00,190 --> 00:48:01,741
举例来说 
That there are more points on a line, 

917
00:48:01,741 --> 00:48:02,500
在数轴上
for example,

918
00:48:02,500 --> 00:48:02,506
点的数量比计数的数字多
than there are counting numbers.

919
00:48:02,506 --> 00:48:04,425
直线上的点比自然数多
than there are counting numbers.

920
00:48:05,260 --> 00:48:06,858
这或许不是个显而易见的结论
It may or may not be obvious,

921
00:48:06,858 --> 00:48:08,175
但我不想深入讨论这个
and I don't want to get into that now.

922
00:48:10,900 --> 00:48:12,450
但是diag2
But diag2

923
00:48:13,300 --> 00:48:15,820
仍有一个参数的过程p
is again a procedure of one argument p.

924
00:48:15,820 --> 00:48:17,475
这几乎与之前的例子相同
It's almost the same as the previous one,

925
00:48:17,725 --> 00:48:24,323
如果计算(p p)是安全的
which is, if it's safe to compute p on p,

926
00:48:25,175 --> 00:48:26,675
那么我就要
then I'm going to produce--

927
00:48:27,267 --> 00:48:31,025
要去计算
then I want to compute

928
00:48:31,575 --> 00:48:32,775
一些(p p)之外的
some other things

929
00:48:33,800 --> 00:48:37,825
其他东西
other than p of p.

930
00:48:38,960 --> 00:48:40,210
否则我就返回false
Otherwise I'm going to put out false.

931
00:48:43,600 --> 00:48:45,300
这里的other-than意思是
Where other then it says,

932
00:48:45,300 --> 00:48:46,352
不管这个(p p)是什么
whatever p of p, 

933
00:48:46,352 --> 00:48:47,475
我都返回一些别的东西
I'm going to put out something else.

934
00:48:48,880 --> 00:48:50,075
我会告诉你
I can give you an example of 

935
00:48:50,075 --> 00:48:51,525
一个other-than的定义
a definition of other than

936
00:48:51,575 --> 00:48:52,575
我觉得它是可用的
which I think works.

937
00:48:53,890 --> 00:48:55,225
我们看
Let's see.

938
00:48:55,640 --> 00:48:56,330
是的
Yes.

939
00:48:56,330 --> 00:48:57,266
定义other-than
Where other than

940
00:49:03,950 --> 00:49:07,265
是一个以x为参数的过程
be a procedure of one argument x which says,

941
00:49:08,050 --> 00:49:12,961
如果x等于'A
if its eq x to, say, quote a,

942
00:49:13,325 --> 00:49:15,075
那么结果是'B
then the answer is quote b.

943
00:49:15,720 --> 00:49:16,970
否则结果是'A
Otherwise it's quote a.

944
00:49:20,090 --> 00:49:21,900
这就能做到不管参数是什么
That always produces something

945
00:49:22,075 --> 00:49:23,450
我都能给出与参数不同的结果
which is not what its argument is.

946
00:49:25,350 --> 00:49:26,125
就是这样
That's all it is.

947
00:49:26,540 --> 00:49:27,375
这就是我要的
That's all I wanted.

948
00:49:28,250 --> 00:49:29,587
我们考虑一下这个
Well now let's consider this one,

949
00:49:29,587 --> 00:49:31,150
(diag2 diag2)
diag2 of diag2.

950
00:49:38,220 --> 00:49:39,000
看
Well look.

951
00:49:39,950 --> 00:49:41,725
这个东西会做些危险的事情
This only does something dangerous,

952
00:49:42,000 --> 00:49:43,450
比如求值(p p)
like calling p of p,

953
00:49:44,750 --> 00:49:45,950
如果它是是安全的
if it's safe to do so.

954
00:49:47,470 --> 00:49:49,168
如果SAFE?能够被定义的话
So if safe defined at all,

955
00:49:50,300 --> 00:49:52,496
如果你能定义SAFE?过程
if you can define such a procedure, safe,

956
00:49:52,975 --> 00:49:54,325
那么这个过程
then this procedure

957
00:49:54,608 --> 00:49:56,400
总是安全的
is always defined and therefore safe

958
00:49:56,525 --> 00:49:57,225
对于任意输入来说都是
on any inputs.

959
00:50:01,540 --> 00:50:03,504
那么(diag2 diag2)
So diag2 of diag2

960
00:50:03,875 --> 00:50:12,200
一定会返回(diag2 diag2)以外的东西
must reduce to other than diag2 of diag2.

961
00:50:15,825 --> 00:50:16,975
这就没意义了
And that doesn't make sense,

962
00:50:17,800 --> 00:50:19,309
又产生了悖论
so we have a contradiction,

963
00:50:19,850 --> 00:50:21,575
因此我们不能定义SAFE?
and therefore we can't define safe.

964
00:50:22,950 --> 00:50:24,237
我只想这样证明两次
I just waned to do that twice,

965
00:50:24,750 --> 00:50:25,825
有些许不同
slightly differently,

966
00:50:26,625 --> 00:50:27,905
你不会感到
so you wouldn't feel

967
00:50:28,800 --> 00:50:30,975
第一个证明是个把戏
that the first one was a trick.

968
00:50:32,825 --> 00:50:33,450
他们都是把戏
They may be both tricks,

969
00:50:33,800 --> 00:50:35,300
但它们稍微有些不同
but they're at least slightly different.

970
00:50:37,300 --> 00:50:39,200
#TBD
So I suppose that pretty much wraps it up.

971
00:50:40,080 --> 00:50:41,973
#TBD
I've just proved what we call the halting theorem,

972
00:50:43,000 --> 00:50:44,925
#TBD
and I suppose with that we're going to halt.

973
00:50:46,720 --> 00:50:47,970
#TBD
I hope you have a good time.

974
00:50:50,900 --> 00:50:51,765
有什么问题吗?
Are there any questions?

975
00:50:53,300 --> 00:50:53,810
请讲
Yes.

976
00:50:53,810 --> 00:50:56,275
学生: diag1的值是什么?
AUDIENCE: What is the value of s of diag1?

977
00:50:56,750 --> 00:50:57,430
教授: 什么的值?
PROFESSOR: Of what?

978
00:50:57,430 --> 00:50:58,950
学生: (S diag)的值
AUDIENCE: S of diag1.

979
00:51:00,120 --> 00:51:02,037
如果你说S是个函数 
If you said s is a function 

980
00:51:02,037 --> 00:51:02,620
我们可以
and we can [INTERPOSING VOICES]

981
00:51:02,620 --> 00:51:03,870
教授: 噢 我不知道啊
PROFESSOR: Oh, I don't know.

982
00:51:03,870 --> 00:51:04,350
我不知道
I don't know.

983
00:51:04,350 --> 00:51:04,882
它是一个函数 
It's a function, 

984
00:51:04,882 --> 00:51:05,950
但我不知道如何计算它
but I don't know how to compute it.

985
00:51:06,800 --> 00:51:08,125
我做不到
I can't do it.

986
00:51:08,610 --> 00:51:09,775
我也只是个机器
I'm just a machine, too.

987
00:51:11,530 --> 00:51:12,210
对吧?
Right?

988
00:51:12,210 --> 00:51:13,375
原则上来说 
There's no machine 

989
00:51:13,375 --> 00:51:14,050
没有机器
that in principle--

990
00:51:14,475 --> 00:51:16,875
会处在你刚才问的那个情况中
it might be that in that particular case you just asked, 

991
00:51:16,875 --> 00:51:18,580
#TBD
with some thinking I could figure it out.

992
00:51:18,580 --> 00:51:19,375
但通常情况下
But in general

993
00:51:19,600 --> 00:51:21,050
我无法计算S的值
I can't compute the value of s 

994
00:51:21,050 --> 00:51:22,525
别的机器也做不到
any better than any other machine can.

995
00:51:23,780 --> 00:51:24,925
存在这样一个函数
There is such a function,

996
00:51:25,925 --> 00:51:28,000
没有任何机器能够计算它
it's just that no machine can be built to compute it.

997
00:51:29,580 --> 00:51:30,050
现在
Now

998
00:51:30,672 --> 00:51:33,675
#TBD
there's a way of saying that that should not be surprising.

999
00:51:35,225 --> 00:51:36,250
#TBD
Going through this--

1000
00:51:36,250 --> 00:51:38,362
我并没有时间在这展示这个
I mean, I don't have time to do this here,

1001
00:51:38,450 --> 00:51:43,000
但这样的函数非常多
but the number of functions is very large.

1002
00:51:44,400 --> 00:51:47,754
如果有一定量的可能输入
If there's a certain number of answers possible 

1003
00:51:47,754 --> 00:51:49,626
和结果
and a certain number of inputs possible,

1004
00:51:49,875 --> 00:51:51,800
那么结果对应输入的数量
then it's the number of answers raised to the number inputs 

1005
00:51:51,800 --> 00:51:53,200
就是可能函数的数量
is the number of possible functions.

1006
00:51:54,500 --> 00:51:55,970
对于同一个参数来说
On one variable.

1007
00:51:58,150 --> 00:52:04,325
#TBD
Now that's always bigger than the thing you're raising to, the exponent.

1008
00:52:05,480 --> 00:52:09,800
函数的数量
The number of functions is larger

1009
00:52:09,950 --> 00:52:12,725
比程序的数量更多
than the number of programs

1010
00:52:13,306 --> 00:52:14,100
#
that one can write, 

1011
00:52:14,825 --> 00:52:16,450
#TBD
by an infinity counting argument.

1012
00:52:17,575 --> 00:52:19,000
可能会更多
And it's much larger.

1013
00:52:19,475 --> 00:52:22,124
所以不可计算的函数数量
So there must be a lot of functions 

1014
00:52:22,124 --> 00:52:23,550
一定会非常多
that can't be computed by programs.

1015
00:52:26,280 --> 00:52:27,475
学生: 不久前
AUDIENCE: A few moments ago

1016
00:52:27,475 --> 00:52:28,563
 你讲了#TBD
 you were talking about specifications 

1017
00:52:28,563 --> 00:52:30,640
#TBD
and automatic generation of solutions.

1018
00:52:30,640 --> 00:52:33,360
#TBD
Do you see any steps between specifications and solutions?

1019
00:52:37,250 --> 00:52:38,225
教授: #TBD
PROFESSOR: Steps between.

1020
00:52:38,720 --> 00:52:39,375
你是说
You mean, you're saying, 

1021
00:52:39,375 --> 00:52:42,603
#TBD
how you go about constructing

1022
00:52:42,603 --> 00:52:45,205
#TBD
devices given that have specifications for the device?

1023
00:52:45,205 --> 00:52:45,500
是的
Sure.

1024
00:52:45,500 --> 00:52:48,361
学生:
AUDIENCE: There's a lot of software engineering 

1025
00:52:48,361 --> 00:52:49,900
#TBD
that goes through specifications through 

1026
00:52:49,900 --> 00:52:51,900
#TBD
many layers of design and then implementation.

1027
00:52:52,430 --> 00:52:52,850
教授: 是的
PROFESSOR: Yes?

1028
00:52:52,850 --> 00:52:53,700
学生: 我很好奇
AUDIENCE: I was curious 

1029
00:52:53,700 --> 00:52:54,625
你觉得这现实吗?
if you think that's realistic.

1030
00:52:55,600 --> 00:52:57,175
教授: 我觉得其中一些是现实的
PROFESSOR: Well I think that some of it's realistic 

1031
00:52:57,175 --> 00:52:58,100
另一些不现实
and some of it isn't.

1032
00:52:58,100 --> 00:53:00,538
如果你想制造一个滤波器
I mean, surely if I want to build an electrical filter

1033
00:53:01,175 --> 00:53:07,160
#TBD
and I have a rather interesting possibility.

1034
00:53:07,160 --> 00:53:10,615
假设我想制造一个东西
Supposing I want to build a thing that matches

1035
00:53:11,050 --> 00:53:14,071
无线电广播发射机
some power output to the radio transmitter,

1036
00:53:14,475 --> 00:53:18,750
到某些天线
to some antenna.

1037
00:53:19,906 --> 00:53:23,230
#TBD
And I'm really out of this power-- it's output tube out here.

1038
00:53:23,230 --> 00:53:25,920
问题是它们的阻抗不同
And the problem is that they have different impedances.

1039
00:53:25,920 --> 00:53:27,550
我希望能够匹配阻抗
I want them to match the impedances.

1040
00:53:27,550 --> 00:53:29,150
我也想制造一个滤波器
I also want to make a filter

1041
00:53:29,150 --> 00:53:32,780
用来过滤一些谐波辐射
in there which is going to get rid of some harmonic radiation.

1042
00:53:32,780 --> 00:53:36,638
一个老派的技术叫作
Well one old-fashioned technique for doing this is called

1043
00:53:36,825 --> 00:53:38,860
镜像阻抗或之类的东西
image impedances, or something like that.

1044
00:53:38,860 --> 00:53:39,500
你要做的是
And what you do 

1045
00:53:39,500 --> 00:53:40,850
你有个基础的模块
is you say you have a basic module

1046
00:53:40,850 --> 00:53:42,750
称为L-section
called an L-section.

1047
00:53:43,300 --> 00:53:44,550
像这个一样
Looks like this.

1048
00:53:47,080 --> 00:53:49,800
如果把它连接到某些电阻上
If I happen to connect this to some resistance,

1049
00:53:50,050 --> 00:53:52,600
#TBD
r, and if I make this impedance x, xl,

1050
00:53:52,725 --> 00:53:55,400
#TBD
and if it happens to be q times r, 

1051
00:53:55,400 --> 00:53:58,525
#TBD
then this produces a low pass filter 

1052
00:53:58,525 --> 00:54:00,865
#TBD
with a q square plus one impedance match.

1053
00:54:02,110 --> 00:54:03,120
这就是我想要的
Just what I need.

1054
00:54:03,120 --> 00:54:03,875
因为这样我就可以
Because now I can take two of these, 

1055
00:54:03,875 --> 00:54:05,300
把它们组装到一起了
hook them together

1056
00:54:06,025 --> 00:54:06,510
就像这样
like this.

1057
00:54:11,660 --> 00:54:13,150
我拿来另一个
OK, and I take another one

1058
00:54:13,625 --> 00:54:18,290
想这样把它们连在一起
and I'll hook them together like that.

1059
00:54:18,290 --> 00:54:19,950
有两个L-section连到一起
And I have two L-sections hooked together.

1060
00:54:20,320 --> 00:54:23,070
#TBD
And this will step the impedance down to one that I know,

1061
00:54:23,375 --> 00:54:25,225
#TBD
and this will step it up to one I know.

1062
00:54:25,530 --> 00:54:27,850
#TBD
Each of these is a low pass filter getting rid of some harmonics.

1063
00:54:28,090 --> 00:54:30,270
#TBD
It's good filter, it's called a pie-section filter.

1064
00:54:30,270 --> 00:54:30,800
很好
Great.

1065
00:54:31,700 --> 00:54:34,974
除了事实上
Except for the fact that in doing what I just did,

1066
00:54:35,250 --> 00:54:37,850
我在系统里放了些无用的东西
I've made a terrible inefficiency in this system.

1067
00:54:38,620 --> 00:54:40,725
我在本该一个线圈的地方用了两个
I've made two coils where I should have made one.

1068
00:54:41,620 --> 00:54:44,600
在大多数软件工程中
And the problem with most software engineering art

1069
00:54:44,894 --> 00:54:47,150
#
is that there's no mechanism, 

1070
00:54:47,150 --> 00:54:48,650
TBD
other than peephole optimization and compilers,

1071
00:54:48,800 --> 00:54:53,550
#TBD
for getting rid of the redundant parts that are constructed when doing top down design.

1072
00:54:55,350 --> 00:54:56,076
或许会更糟
It's even worse, 

1073
00:54:56,076 --> 00:54:57,804
有很多重要的结构
there are lots of very important structures 

1074
00:54:57,804 --> 00:54:59,025
你无法采用这种方式构建
that you can't construct at all this way.

1075
00:55:01,110 --> 00:55:03,535
我觉得自上而下的设计方式
So I think that the standard top down design 

1076
00:55:03,535 --> 00:55:04,875
是一种很浅显的手段
is a rather shallow business.

1077
00:55:05,710 --> 00:55:06,600
它不会
Doesn't really capture 

1078
00:55:06,600 --> 00:55:08,100
#TBD
what people want to do in design.

1079
00:55:08,315 --> 00:55:10,100
我再举一个电子学的例子
I'll give you another electrical example.

1080
00:55:10,100 --> 00:55:11,750
#TBD
Electrical examples are so much clearer

1081
00:55:11,907 --> 00:55:13,364
#TBD
than computational examples, 

1082
00:55:13,364 --> 00:55:14,275
#TBD
because computation examples require

1083
00:55:14,275 --> 00:55:16,525
#TBD
a certain degree of complexity to explain them.

1084
00:55:17,220 --> 00:55:20,163
电子学世界中 我最喜欢的例子之一是
But one of my favorite examples in the electrical world 

1085
00:55:20,600 --> 00:55:24,195
#TBD
is how would I ever come up with the output stage

1086
00:55:24,195 --> 00:55:26,550
#TBD
of this inter-stage connection in an IF amplifier.

1087
00:55:27,530 --> 00:55:31,500
这是一个三极管
It's a little transistor here, and let's see.

1088
00:55:32,410 --> 00:55:33,400
#TBD
Well I'm going to have a tank,

1089
00:55:36,450 --> 00:55:39,175
#TBD
and I'm going to hook this up to, say,

1090
00:55:41,375 --> 00:55:43,975
#TBD
I'm going to link-couple that to the input of the next stage.

1091
00:55:44,850 --> 00:55:47,475
#TBD
Here's a perfectly plausible plan--

1092
00:55:48,225 --> 00:55:50,875
#TBD
well except for the fact that since I put that going up

1093
00:55:50,875 --> 00:55:52,925
#TBD
I should make that going that way.

1094
00:55:53,170 --> 00:55:55,775
#TBD
Here's a perfectly plausible plan for a-- 

1095
00:55:55,775 --> 00:55:56,700
不对
no I shouldn't.

1096
00:55:57,125 --> 00:55:57,940
我傻了
I'm dumb.

1097
00:55:58,400 --> 00:55:59,075
对不起
Excuse me.

1098
00:55:59,690 --> 00:56:00,425
没关系
Doesn't matter.

1099
00:56:00,730 --> 00:56:01,540
#TBD
The point is [UNINTELLIGIBLE]

1100
00:56:01,540 --> 00:56:02,560
#TBD
plan for a couple [UNINTELLIGIBLE]

1101
00:56:02,560 --> 00:56:03,425
#TBD
stages together.

1102
00:56:04,590 --> 00:56:06,925
#TBD
Now what the problem is is what's this hierarchically?

1103
00:56:07,620 --> 00:56:08,800
#TBD
It's not one thing.

1104
00:56:09,480 --> 00:56:11,990
#TBD
Hierarchically it doesn't make any sense at all.

1105
00:56:11,990 --> 00:56:14,325
#TBD
It's the inductance of a tuned circuit,

1106
00:56:15,550 --> 00:56:18,025
#TBD
it's the primary of a transformer,

1107
00:56:19,100 --> 00:56:21,825
#TBD
and it's also the DC path by 

1108
00:56:21,825 --> 00:56:23,575
#TBD
which bias conditions get to the 

1109
00:56:23,575 --> 00:56:25,100
#TBD
collector of that transistor.

1110
00:56:26,460 --> 00:56:30,175
#TBD
And there's no simple top-down design that's going to produce a structure like that

1111
00:56:30,225 --> 00:56:34,025
#TBD
with so many overlapping uses for a particular thing.

1112
00:56:34,530 --> 00:56:36,729
玩拼字游戏
Playing Scrabble,

1113
00:56:36,729 --> 00:56:38,841
当你要完成三倍分数的词时
where you have to do triple word scores,

1114
00:56:39,300 --> 00:56:43,600
自顶向下的设计策略并不容易
or whatever, is not so easy in top-down design strategy.

1115
00:56:44,950 --> 00:56:50,700
真正的工程基于努力的吸引力#TBD
Yet most of real engineering is based on getting the most oomph for effort.

1116
00:56:52,140 --> 00:56:53,525
那就是你所看到的东西
And that's what you're seeing here.

1117
00:56:54,860 --> 00:56:55,550
嗯?
Yeah?

1118
00:56:55,550 --> 00:56:56,810
学生: 这是最后一个问题吗?
AUDIENCE: Is this the last question?

1119
00:57:00,282 --> 00:57:02,525
[笑声]
[LAUGHTER]

1120
00:57:18,640 --> 00:57:19,890
教授: 看起来是
PROFESSOR: Apparently so.

1121
00:57:23,575 --> 00:57:24,125
谢谢大家
Thank you.

1122
00:57:25,300 --> 00:57:36,500
[掌声]
[APPLAUSE]

1123
00:57:39,040 --> 00:58:52,200
[音乐]
[JESU, JOY OF MAN'S DESIRING]

