1
00:00:00,000 --> 00:00:01,980
[MUSIC PLAYING]
[音乐]

2
00:00:11,500 --> 00:00:15,790
赋值、状态和副作用
Assignment, State, and Side-effects

3
00:00:15,790 --> 00:00:22,000
教授：到目前为止 我们编写程序
PROFESSOR: Well, so far we've invented enough programming

4
00:00:22,000 --> 00:00:26,780
做了一些非常复杂事情
to do some very complicated things.

5
00:00:26,780 --> 00:00:29,660
并且关于编程你们确实已经学到了很多
And you surely learned a lot about programming at this point.

6
00:00:29,660 --> 00:00:31,860
你们已经学习了几乎所有的
You've learned almost all the most important tricks

7
00:00:31,860 --> 00:00:36,200
那些拥有大量经验的人才能领悟的技巧
that usually don't get taught to people until they have had a lot of experience.

8
00:00:36,200 --> 00:00:40,750
例如，数据导向编程是一个主要的技巧
For example, data directed programming is a major trick,

9
00:00:40,750 --> 00:00:43,680
昨天你们也看到了一种解释型语言
and yesterday you also saw an interpreted language.

10
00:00:43,680 --> 00:00:48,460
我们所做的这一切
We did this all in a computer language,

11
00:00:48,460 --> 00:00:49,800
目前来讲
at this point,

12
00:00:49,800 --> 00:00:53,180
都是在一种没有赋值语句的计算机语言中完成的
where there was no assignment statement.

13
00:00:53,180 --> 00:00:55,860
想必 对于你们中已经见过
And presumably, for those of you who've

14
00:00:55,860 --> 00:00:58,320
Basic或者Pascal或者其他什么语言的人来说
seen your Basic or Pascal or whatever,

15
00:00:58,320 --> 00:01:01,340
也许，赋值语句被认为是最重要的东西
that's usually considered the most important thing.

16
00:01:01,340 --> 00:01:03,820
今天我们将要做一些糟糕的事情
Well today, we're going to do something horrible.

17
00:01:03,820 --> 00:01:06,300
我们要把赋值语句加进来
We're going to add an assignment statement.

18
00:01:06,300 --> 00:01:09,140
既然在没有赋值语句的时候，我们都可以很好地完成工作
And since we can do all these wonderful things without it,

19
00:01:09,140 --> 00:01:10,500
为什么我们还要把它加进来呢？
why should we add it?

20
00:01:10,500 --> 00:01:12,540
我们需要认识到一件重要的事情
 An important thing to understand is

21
00:01:12,540 --> 00:01:14,020
首先，我们要
that today we're going to

22
00:01:14,020 --> 00:01:16,020
定下一个原则
first of all, have a rule,

23
00:01:16,020 --> 00:01:17,930
而我们将一直遵守这个规则
which is going to always be obeyed,

24
00:01:17,930 --> 00:01:21,140
我们为语言引入新的特性的唯一原因
which is the only reason we ever add a feature to our language

25
00:01:21,140 --> 00:01:23,140
是因为有一个好的理由
is because there is a good reason.

26
00:01:23,140 --> 00:01:27,280
这个好理由就是能力
And the good reason is going to boil down to the ability,

27
00:01:27,280 --> 00:01:28,890
现在你获得了
you now get an ability

28
00:01:28,890 --> 00:01:31,510
把问题分解为不同的小部分
to break a problem into pieces that are different sets of pieces

29
00:01:31,510 --> 00:01:34,270
在过去你可能在不使用这种能力的情况下分解问题
then you could have broken it down without that,

30
00:01:34,270 --> 00:01:37,360
从而领悟解耦的另一种含义
give you another means of decomposition.

31
00:01:37,360 --> 00:01:39,450
我们这就开始
However, let's just start.

32
00:01:39,450 --> 00:01:41,880
我们从回顾我们的
Let me quick begin by reviewing

33
00:01:41,880 --> 00:01:47,590
现在已经有的这种语言出发
the kind of language that we have now.

34
00:01:47,590 --> 00:01:50,850
我们之前写的是所谓的函数式程序
We've been writing what's called functional programs.

35
00:01:50,850 --> 00:01:52,790
函数式程序
And functional programs

36
00:01:52,790 --> 00:01:58,030
是一种对数学真理的编码
are a kind of encoding of mathematical truths.

37
00:01:58,030 --> 00:02:00,510
例如，当我们看到
For example, when we look at

38
00:02:00,510 --> 00:02:04,570
像幻灯片上这样阶乘过程时
the factorial procedure that you see on the slide here,

39
00:02:04,570 --> 00:02:06,770
基本上是两个子句
it's basically two clauses.

40
00:02:06,770 --> 00:02:08,640
如果n是1，则结果是1
If n is one, the result is one,

41
00:02:08,640 --> 00:02:11,200
否则返回n乘以n-1的阶乘
otherwise n times factorial n minus one.

42
00:02:11,200 --> 00:02:12,560
这是n的阶乘
That's factorial of n.

43
00:02:12,560 --> 00:02:14,560
它就是n的阶乘
Well, that is factorial of n.

44
00:02:14,560 --> 00:02:16,870
如果用一些其他的
And written down in some other obscure notation

45
00:02:16,870 --> 00:02:20,910
那些你在微积分课堂上学到的晦涩的符号来写
that you might have learned in calculus classes,

46
00:02:20,910 --> 00:02:22,110
以数学上的逻辑来写
mathematical logic,

47
00:02:22,110 --> 00:02:26,530
如果n等于1
what you see there is if n equals one,

48
00:02:26,530 --> 00:02:29,900
那么n的阶乘结果是1，否则，
for the result of n factorial is one, otherwise,

49
00:02:29,900 --> 00:02:32,560
如果n大于1，则n的阶乘就是n乘以n-1的阶乘
greater than one, n factorial is n times n minus one factorial.

50
00:02:32,560 --> 00:02:34,560
#TBD
True statements,

51
00:02:34,560 --> 00:02:36,700
这就是我们一直以来用的那种语言
that's the kind of language we've been using.

52
00:02:36,700 --> 00:02:39,230
#TBD
And whenever we have true statements of that sort,

53
00:02:39,230 --> 00:02:46,940
有一种理解它们是如何工作的方法
there is a kind of, a way of understanding how they work

54
00:02:46,940 --> 00:02:51,120
就是这些过程可以由代换演变出来
which is that such processes can be evolved by substitution.

55
00:02:51,120 --> 00:02:54,140
来看第二张幻灯片
And so we see on the second slide here,

56
00:02:54,140 --> 00:03:00,040
我们理解执行的过程
that the way we understand the execution implied

57
00:03:00,040 --> 00:03:03,500
隐含在表达式的顺序中
by those statements in arranged in that order,

58
00:03:03,500 --> 00:03:11,380
就是你在过程体中连续地将形式参数，代换为实际参数的顺序
is that you do successive substitutions of arguments for formal parameters in the body of a procedure.

59
00:03:11,380 --> 00:03:14,610
这是基本上是一系列的等价代换
This is basically a sequence of equalities.

60
00:03:14,610 --> 00:03:17,250
4的阶乘是4乘以3的阶乘
Factorial four is four times factorial three.

61
00:03:17,250 --> 00:03:20,050
也就是4乘以3乘以2的阶乘
That is four times three times factorial of two

62
00:03:20,050 --> 00:03:21,010
以此类推
and so on.

63
00:03:21,010 --> 00:03:24,480
#TBD
We're always preserving truth.

64
00:03:24,480 --> 00:03:28,840
尽管我们正在讨论#TBD
Even though we're talking about true statements,

65
00:03:28,840 --> 00:03:31,960
这里会有超过一个#TBD
there might be more than one organization of these true statements

66
00:03:31,960 --> 00:03:35,560
来描述一个特定的函数的计算
to describe the computation of a particular function,

67
00:03:35,560 --> 00:03:38,420
这个特定的函数的值的计算
the computation of the value of a particular function.

68
00:03:38,420 --> 00:03:41,180
所以，让我来看下一个例子
So, for example, looking at the next one here.

69
00:03:41,180 --> 00:03:49,020
这有一个计算m与n的和的办法
Here is a way of looking at the sum of n and m.

70
00:03:49,020 --> 00:03:52,360
我们使用一个递归的过程来完成这个任务
And we did this one by a recursive process.

71
00:03:52,360 --> 00:03:58,640
它就是sum的增加，及n与m的减少
It's the increment of the sum of the decrement of n and m.

72
00:03:58,640 --> 00:04:05,620
当然，这里就是一些数学的逻辑，解释了这个方法
And, of course, there is some piece of mathematical logic here that describes that.

73
00:04:05,620 --> 00:04:10,820
就是sum的增加以及n和m的减少
It's the increment of the sum of the decrement of n and m,

74
00:04:10,820 --> 00:04:12,820
跟之前那个一样
just like that.

75
00:04:12,820 --> 00:04:17,040
所以这儿并没有什么特殊的魔法
So there's nothing particularly magic about that.

76
00:04:17,040 --> 00:04:20,010
当然，如果我们可以再来看一个相同的迭代过程
And, of course, if we can also look at an iterative process for the same,

77
00:04:20,010 --> 00:04:24,920
一个对于同样的函数进行逐步迭代的过程的程序
a program that evolves an iterative process, for the same function.

78
00:04:24,920 --> 00:04:28,650
这两个程序将得到同样的结果
These are two things that compute the same answer.

79
00:04:28,650 --> 00:04:35,530
我们就可以认为这两个程序在数学上是等效的
And we have equivalent mathematical truths that are arranged there.

80
00:04:35,530 --> 00:04:40,120
#TBD
And just the way you arrange those truths determine the particular process.

81
00:04:40,120 --> 00:04:43,810
#TBD
In the way choose and arrange them determines the process that's evolved.

82
00:04:43,810 --> 00:04:48,600
因此我们有讨论两个函数被计算的灵活性
So we have the flexibility of talking about both the function to be computed,

83
00:04:48,600 --> 00:04:50,600
#TBD
and the method by which it's computed.

84
00:04:50,600 --> 00:04:52,600
#TBD
So it's not clear we need more.

85
00:04:52,600 --> 00:04:55,500
然而，今天我要来讲这个糟糕的东西
However, today I'm going to this awful thing.

86
00:04:55,500 --> 00:04:58,540
我要给大家介绍赋值操作
I'm going to introduce this assignment operation.

87
00:04:58,540 --> 00:05:01,140
这是什么？
Now, what is this?

88
00:05:02,410 --> 00:05:09,220
首先，在编程语言中有另一种语句
Well, first of all, there is going to be another kind of kind of statement, if you will,

89
00:05:09,220 --> 00:05:12,040
这种语句叫做SET！
in a programming language called Set!

90
00:05:12,040 --> 00:05:18,100
它可以用来进行赋值，我在后面加上一个感叹号
Things that do things like assignment, I'm going to put exclamation points after.

91
00:05:18,100 --> 00:05:20,960
我马上就讲这个感叹号是什么意思
We'll talk about what that means in a second.

92
00:05:20,960 --> 00:05:23,010
这个感叹号，与问号类似
The exclamation point, again like question mark,

93
00:05:23,010 --> 00:05:25,880
是我们给名字随意加的符号
is an arbitrary thing we attach to the symbol which is the name,

94
00:05:25,880 --> 00:05:27,880
它对于系统来说没有意义
has no significance to the system.

95
00:05:27,880 --> 00:05:30,210
它唯一的意义就是告诉我们
The only significance is to me and you

96
00:05:30,210 --> 00:05:34,870
注意这里是某种赋值
to alert you that this is an assignment of some sort.

97
00:05:35,520 --> 00:05:38,220
但是我们要给某个变量
But we're going to set a variable

98
00:05:38,220 --> 00:05:41,600
赋一个值
to a value.

99
00:05:43,600 --> 00:05:45,130
这意味着
And what that's going to mean

100
00:05:45,130 --> 00:05:48,400
在某个时间点发生了一些事情
is that there is a time at which something happens.

101
00:05:48,400 --> 00:05:49,860
这是一个时间点
Here's a time.

102
00:05:49,860 --> 00:05:52,450
如果时间以这个方向流动
If I have time going this way,

103
00:05:52,450 --> 00:05:54,820
#TBD
it's a time access.

104
00:05:54,820 --> 00:05:58,170
时间在纸面上由上到下地流逝
Time progresses by walking down the page.

105
00:05:58,170 --> 00:06:00,920
赋值是第一个
Then an assignment is the first thing we have

106
00:06:00,920 --> 00:06:05,580
使过去和未来之间产生差别的事物
that produces the difference between a before and an after.

107
00:06:05,580 --> 00:06:08,950
我们之前写的所有程序
All the other programs that we've written,

108
00:06:08,950 --> 00:06:10,680
都不包含赋值
that have no assignments in them,

109
00:06:10,680 --> 00:06:13,760
这些程序以怎样的顺序进行执行都没关系
the order in which they were evaluated didn't matter.

110
00:06:13,760 --> 00:06:15,960
但是赋值比较特殊
But assignment is special,

111
00:06:15,960 --> 00:06:17,960
它使时间中产生了一个时间点
it produces a moment in time.

112
00:06:17,960 --> 00:06:25,340
因此在set!出现之前和之后中间有一个时间点，
So there is a moment before the set occurs and after,

113
00:06:27,340 --> 00:06:33,080
使得在这个时间点之后
such that after this moment in time,

114
00:06:33,080 --> 00:06:45,620
变量有了一个值，value 
the variable has the value, value.

115
00:06:48,100 --> 00:06:52,050
与这个变量之前的值无关
Independent of what value it had before,

116
00:06:52,050 --> 00:06:56,500
set!改变了它的值
set! changes the value of the variable.

117
00:06:56,500 --> 00:06:58,750
在此之前
Until this moment,

118
00:06:58,750 --> 00:07:02,160
我们都没遇到过发生这样改变的情况
we had nothing that changed.

119
00:07:02,160 --> 00:07:04,320
举例来说
So, for example,

120
00:07:04,320 --> 00:07:06,230
我们可以想到的一件事是
one of the things we can think of

121
00:07:06,230 --> 00:07:09,420
我们写的一些过程比如阶乘的程序
is that the procedures we write for something like factorial

122
00:07:09,420 --> 00:07:13,170
事实上与数学中的阶乘函数完全相同
are in fact pretty much identical to the function factorial.

123
00:07:13,170 --> 00:07:16,730
4的阶乘，如果我写fact4
Factorial of four, if I write fact4,

124
00:07:16,730 --> 00:07:19,360
它将独立于它的上下文
independent of what context it's in,

125
00:07:19,360 --> 00:07:21,290
也独立于我写几遍
and independent of how many times I write it,

126
00:07:21,290 --> 00:07:23,290
我总能得到同样的结果
I always get the same answer.

127
00:07:23,290 --> 00:07:24,610
结果永远是24
It's always 24.

128
00:07:24,610 --> 00:07:29,710
它是参数到到结果的唯一映射
It's a unique map from the argument to the answer.

129
00:07:29,710 --> 00:07:33,020
迄今为止，我们之前写的所有程序都是这样的
And all the programs we've written so far are like that.

130
00:07:33,020 --> 00:07:36,340
然而，当我赋值的时候，一切就不同了
However, once I have assignment, that isn't true.

131
00:07:36,340 --> 00:07:38,340
举个例子
So, for example,

132
00:07:38,340 --> 00:07:49,240
如果我将count定义为1
if I were to define count to be one.

133
00:07:49,240 --> 00:07:54,010
然后定义一个过程
And then I'm going to define also a procedure,

134
00:07:54,010 --> 00:07:59,210
名为demo的简单过程
a simple procedure called demo,

135
00:07:59,210 --> 00:08:03,840
它接受参数x，并执行下面的操作
which takes argument x and does the following operations.

136
00:08:03,840 --> 00:08:09,620
首先set! x为x加1，
It first sets x to x plus one.

137
00:08:09,620 --> 00:08:12,280
我勒个去，这看起来就像FORTRAN，是吧？
My gosh, this looksjust like FORTRAN, right--

138
00:08:12,280 --> 00:08:15,370
只是用了些有趣的语法
in a funny syntax.

139
00:08:15,370 --> 00:08:21,880
然后加上x count
And then add to x count,

140
00:08:21,880 --> 00:08:24,210
哦，我刚犯了个错
Oh, I just made a mistake.

141
00:08:24,210 --> 00:08:25,310
我的意思是
I want to say,

142
00:08:25,310 --> 00:08:30,370
set! count为1加上count
set! count to one plus count.

143
00:08:30,370 --> 00:08:34,120
就是我在这里定义的这个
It's this thing defined here.

144
00:08:34,120 --> 00:08:39,400
然后x和count相加
And then plus x count.

145
00:08:39,400 --> 00:08:42,210
然后就可以试着运行这个过程了
Then I can try this procedure.

146
00:08:42,210 --> 00:08:43,600
让我们运行它
Let's run it.

147
00:08:43,600 --> 00:08:47,220
假设我可以输入
So, suppose I get a prompt and I say,

148
00:08:47,220 --> 00:08:51,740
我输入demo 3
 demo 3

149
00:08:51,740 --> 00:08:53,740
这里发生了什么？Well, what happens here?

150
00:08:53,740 --> 00:08:55,280
发生的第一件事情是
The first thing that happens

151
00:08:55,300 --> 00:08:56,890
count现在是1
is count is currently one.

152
00:08:56,890 --> 00:08:58,890
现在，这是一个时间点
Currently, there is a time.

153
00:08:58,890 --> 00:09:00,290
我们在讨论时间点
We're talking about time.

154
00:09:00,290 --> 00:09:02,290
x的值为3
x gets three.

155
00:09:02,290 --> 00:09:04,290
在这个时刻
At this moment,

156
00:09:04,290 --> 00:09:08,010
count增加了，所以count是2
I say, oh yes, count is incremented, so count is two.

157
00:09:08,010 --> 00:09:10,540
2加3等于5
two plus three is five.

158
00:09:10,540 --> 00:09:13,650
所以结果是5
So the answer I get out is five.

159
00:09:13,650 --> 00:09:23,000
然后我再一次，输入demo 3
Then I say, demo of say, three again.

160
00:09:23,000 --> 00:09:25,430
结果是什么？
What do I get?

161
00:09:25,430 --> 00:09:28,100
现在count是2，它不再是1了
Well, now count is two, it's not one anymore,

162
00:09:28,100 --> 00:09:30,610
因为我让count加1了
because I have incremented it.

163
00:09:30,610 --> 00:09:32,720
但现在我执行这个过程，
But now I go through this process,

164
00:09:32,720 --> 00:09:34,080
x的值为3
three goes into x,

165
00:09:34,080 --> 00:09:37,840
count变为1加count，因此现在是3了
count becomes one plus count, so that's three now.

166
00:09:37,840 --> 00:09:39,620
这两个相加是6
The sum of those two is six,

167
00:09:39,620 --> 00:09:41,820
所以结果是6
so the answer is six.

168
00:09:41,820 --> 00:09:43,030
我们可以发现
And what we see

169
00:09:43,030 --> 00:09:44,950
同样的表达式
is the same expression

170
00:09:44,950 --> 00:09:48,330
却得到了不同的结果
leads to two different answers,

171
00:09:48,330 --> 00:09:51,490
因为时间的作用
depending upon time.

172
00:09:51,490 --> 00:09:54,040
所以demo不是函数
So demo is not a function,

173
00:09:54,040 --> 00:09:59,460
它没有计算一个数学中的函数
does not compute a mathematical function.

174
00:09:59,460 --> 00:10:02,660
事实上，你可以知道这是为什么
In fact, you could also see why now, of course,

175
00:10:02,660 --> 00:10:07,470
因为这里是第一处代换模型失效的地方
this is the first place where the substitution model isn't going to work.

176
00:10:07,470 --> 00:10:10,960
它弄死了代换模型
This kills the substitution model dead.

177
00:10:10,960 --> 00:10:16,070
哲学家可能注意到一些小麻烦
You know, with quotation there were some little problems that a philosopher might notice

178
00:10:16,070 --> 00:10:22,340
因为你不得不去担心在#TBD的时候能如何代换
with the substitutions, because you have to worry about what deductions you can make when you substitute into quotes,

179
00:10:22,340 --> 00:10:24,340
如果你被允许代换的话
if you're allowed to do that at all.

180
00:10:24,340 --> 00:10:26,000
但是
But

181
00:10:26,000 --> 00:10:28,110
在这里代换模型已经死了
here the substitution model is dead,

182
00:10:28,110 --> 00:10:29,640
他什么也不能做了
can't do anything at all.

183
00:10:29,640 --> 00:10:30,570
因为
Because,

184
00:10:30,570 --> 00:10:36,970
假设我想用代换模型来考虑count的代换
Supposing I wanted to use a substitution model to consider substituting for count?

185
00:10:36,970 --> 00:10:41,570
如果我在这里和这里进行代换
Well, my gosh, if I substitute for here and here,

186
00:10:41,570 --> 00:10:44,060
它们是不同的
they're different ones.

187
00:10:44,060 --> 00:10:46,270
它不再是同一个count了
It's not the same count any more.

188
00:10:46,270 --> 00:10:47,970
我得到了错误的结果
I get the wrong answer.

189
00:10:47,970 --> 00:10:50,940
代换模型是一个静态的现象#TBD
The substitution model is a static phenomenon

190
00:10:50,940 --> 00:10:52,940
它描述了真实的事物#TBD
describes things that are true

191
00:10:52,940 --> 00:10:55,500
并且事物不会改变#TBD
and not things that change.

192
00:10:55,500 --> 00:10:57,500
这里，我们的的真实变了#TBD
Here, we have truths that change.

193
00:11:00,350 --> 00:11:06,740
那么，在我给出任何解释之前
OK, Well, before I give you any understanding of this,

194
00:11:06,740 --> 00:11:07,790
这很糟糕
this is very bad.

195
00:11:07,790 --> 00:11:10,080
我们失去了我们的计算模型
Now, we've lost our model of computation.

196
00:11:10,080 --> 00:11:11,090
并且
And,

197
00:11:11,090 --> 00:11:14,660
很快，我将不得不构建一个新的计算模型
pretty soon, I'm going to have to build you a new model of computation.

198
00:11:14,660 --> 00:11:18,450
#TBD
But ours plays with this, just now, in an informal sense.

199
00:11:18,450 --> 00:11:20,380
当然，你们已经看到的是
Of course, what you already see

200
00:11:20,380 --> 00:11:22,930
当我做一些像赋值之类的事情时
is that when I have something like assignment,

201
00:11:22,930 --> 00:11:24,510
我们所需要的模型
the model that we're going to need

202
00:11:24,510 --> 00:11:26,890
与我们之前模型不同
is different from the model that we had before

203
00:11:26,890 --> 00:11:30,930
在这个的模型中，像count或x这些符号
in that, the variables, those symbols like count, or x

204
00:11:30,930 --> 00:11:34,070
不再关联于他们的值
are no longer going to refer to the values they have,

205
00:11:34,070 --> 00:11:37,560
而是关联于某个储存这些值的地方
but rather to some sort of place where the value restored.

206
00:11:37,560 --> 00:11:39,560
我们将不得不以这种方式思考一段时间
We're going to have to think that way for a while.

207
00:11:39,560 --> 00:11:42,110
这将是一个很糟糕坏的事情
And it's going to be a very bad thing

208
00:11:42,110 --> 00:11:44,020
并且会造成很多麻烦
and cause a lot of trouble.

209
00:11:44,020 --> 00:11:48,250
所以，就像我说的，当我们创造糟糕的事物
And so, as I said, the very fact that we're inventing this bad thing,

210
00:11:48,250 --> 00:11:50,370
意味着有更好的创造它的理由
means that there had better be a good reason for it,

211
00:11:50,370 --> 00:11:53,130
否则，就是浪费时间和精力
otherwise, just a waste of time and a lot of effort.

212
00:11:53,130 --> 00:11:55,880
让我们看看一些东西#TBD
Let's just look at some of it just to play.

213
00:11:55,880 --> 00:11:58,590
假设我们写了函数式版本的阶乘
Supposing we write down the functional version,

214
00:11:58,590 --> 00:12:01,170
传统意义中的那个函数式
functional meaning in the old style,

215
00:12:01,170 --> 00:12:09,590
这个阶乘使用了迭代的过程
of factorial by an iterative process.

216
00:12:09,590 --> 00:12:14,240
n的阶乘

217
00:12:18,120 --> 00:12:25,760
我们要从m迭代到i
we're going to iterate of m and i,

218
00:12:25,760 --> 00:12:33,510
就是说如果i大于n
which says if i is greater than n,

219
00:12:33,510 --> 00:12:35,510
则结果是m
then the result is m,

220
00:12:35,510 --> 00:12:39,560
否则
otherwise,

221
00:12:39,560 --> 00:12:46,820
结果是迭代i和m的乘积
the result of iterating the product of i and m.

222
00:12:46,820 --> 00:12:51,480
所以m将是我累积的结果
So m is going to be the product that I'm accumulating.

223
00:12:51,480 --> 00:12:57,970
m就是这个乘积
m is the product.

224
00:12:57,970 --> 00:13:04,620
然后我要把count加1
And the count I'm going to increase by one.

225
00:13:04,620 --> 00:13:11,780
[闭合括号中]
Plus, ITER, ELSE, COND, define.

226
00:13:11,780 --> 00:13:17,070
我要从这开始写
I'm going to start this up.

227
00:13:17,070 --> 00:13:20,710
如今，你们应该能够没有任何障碍地阅读这类东西了
And these days, you should have no trouble reading something like this.

228
00:13:20,710 --> 00:13:26,180
这里是一个累积的乘积，和一个计数器
What I have here is a product there being accumulated and a counter.

229
00:13:26,180 --> 00:13:28,700
我让它们都从1开始
I start them up both at one.

230
00:13:28,700 --> 00:13:30,920
我将不断让计数器增加
I'm going to buzz the counter up,

231
00:13:30,920 --> 00:13:34,350
每个回合i变成i加1
i goes to i plus one every time around.

232
00:13:34,350 --> 00:13:38,120
那是我们在过程中唯一设置的时间点
But that's only our putting a time on the process,

233
00:13:38,120 --> 00:13:40,320
#TBD
each of this is just a set of truths,

234
00:13:40,320 --> 00:13:42,320
#TBD
true rules.

235
00:13:42,320 --> 00:13:46,130
m将获得一个新的值，就是i乘m
And m is going to get a new values of i and m,

236
00:13:46,130 --> 00:13:48,410
每一轮i乘以m
i times m each time around,

237
00:13:48,410 --> 00:13:52,420
最终i将大于n，在那种情况下，结果就是m
and eventually i is going to be bigger than n, in which case, the answer's going to be m.

238
00:13:52,420 --> 00:13:55,460
现在我给你们讲，#TBD
Now, I'm speaking to you, use time in this.

239
00:13:55,460 --> 00:13:58,070
那是因为我知道计算机是怎么工作的
That's just because I know how the computer
works.

240
00:13:58,070 --> 00:13:59,550
但是我没必要这么做
But I didn't have to.

241
00:13:59,550 --> 00:14:02,300
这可以作为一个纯数学的解释
This could be a purely mathematical description at this point,

242
00:14:02,300 --> 00:14:04,800
因为代换在这里可以工作
because substitution will work for this.

243
00:14:04,800 --> 00:14:08,140
但是我们写一个类似的程序
But let's set right down a similar sort of program,

244
00:14:08,140 --> 00:14:10,510
使用相同的算法
using the same algorithm,

245
00:14:10,510 --> 00:14:13,300
但使用了赋值
but with assignments.

246
00:14:15,330 --> 00:14:23,390
所以这个叫做函数式版本
So this is called the functional version.

247
00:14:23,390 --> 00:14:34,220
我想写个命令式的版本的
I want to write down an imperative version.

248
00:14:34,220 --> 00:14:35,710
n的阶乘
Factorial of n.

249
00:14:35,710 --> 00:14:40,160
我要创建两个变量
I'm going to create my two variables.

250
00:14:40,160 --> 00:14:46,220
把i的值初始化为1
Let i initialize itself to one,

251
00:14:46,220 --> 00:14:50,840
m也初始化为1
and m be initialized to one, similar.

252
00:14:50,840 --> 00:14:59,140
我们创建一个循环
We'll create a loop

253
00:14:59,140 --> 00:15:07,270
如果i比n大，循环结束
which has COND greater than i, and if i is greater than n, we're done.

254
00:15:07,270 --> 00:15:08,870
结果是m
And the result is m,

255
00:15:08,870 --> 00:15:10,870
也就是我累积的乘积
the product I'm accumulating.

256
00:15:10,870 --> 00:15:15,230
否则
Otherwise,

257
00:15:15,230 --> 00:15:19,050
我要写下三件要做的事
I'm going to write down three things to do.

258
00:15:19,050 --> 00:15:29,200
我要set! m为i与m的乘积
I'm going to set! m to the product of i and m,

259
00:15:29,200 --> 00:15:37,640
set! i为i加1的和
set! i to the sum of i and one,

260
00:15:37,640 --> 00:15:40,410
然后继续循环
and go around the loop again.

261
00:15:40,410 --> 00:15:43,400
你们中的FORTRAN程序员应该觉得眼熟
Looks very familiar to you FORTRAN programmers.

262
00:15:43,400 --> 00:15:46,640
[闭合括号中]
ELSE, COND, define,

263
00:15:46,640 --> 00:15:50,890
语法挺有趣吧？
funny syntax though.

264
00:15:50,890 --> 00:15:56,100
启动循环
Start the loop up,

265
00:15:56,100 --> 00:15:58,710
程序写完了
and that's the program.

266
00:15:58,710 --> 00:16:00,710
那么，这个程序
Now, this program,

267
00:16:00,710 --> 00:16:02,710
我们应该怎么看它呢？
how do we think about it?

268
00:16:02,710 --> 00:16:04,710
来看看我们在这看到了什么
Well, let's just say what we're seeing here.

269
00:16:04,710 --> 00:16:07,470
这里有两个局部变量，i和m
There are two local variables, i and m,

270
00:16:07,470 --> 00:16:10,220
它们都被初始化为1
that have been initialized to one.

271
00:16:10,220 --> 00:16:13,890
在每一次循环里，我检测i是否大于n
Every time around the loop, I test to see if i is greater than n,

272
00:16:13,890 --> 00:16:15,300
就是我们传入的参数
which is the input argument,

273
00:16:15,300 --> 00:16:18,770
如果成立的话，结果就是累积在m中的乘积
and if so, the re sult is the product being accumulated in m.

274
00:16:18,770 --> 00:16:21,210
然而，如果循环没有结束
However, if it's not the end of the loop,

275
00:16:21,210 --> 00:16:23,410
如果我们的工作没有结束
if I'm not done,

276
00:16:23,410 --> 00:16:28,890
则我们要把乘积变为i与当前乘积的结果
then what I'm going to do is change the product to be the result of multiplying i times the current product.

277
00:16:28,890 --> 00:16:31,180
就是我们在这里做过的事情
Which is sort of what we were doing here.

278
00:16:31,180 --> 00:16:33,180
除了这里我没有改动
Except here I wasn't changing.

279
00:16:33,180 --> 00:16:36,540
我复制出了另外一份
I was making another copy,

280
00:16:36,540 --> 00:16:42,710
因为代换模型就是你复制过程的体
because the substitution model says, you copy the body of the procedure

281
00:16:42,710 --> 00:16:46,440
并将形式参数用实际参数代换
with the arguments substituted for the formal parameters.

282
00:16:46,440 --> 00:16:48,420
这里我不担心复制
Here I'm not worried about copying,

283
00:16:48,420 --> 00:16:51,530
在这里，我已经改变了m的值
here I've changed the value of m.

284
00:16:51,530 --> 00:16:55,520
我也把i的值变成了i加1
I also then change the value of i to i plus one,

285
00:16:55,520 --> 00:16:57,770
然后继续循环
and go buzzing around.

286
00:16:57,770 --> 00:17:00,770
看起来是一样的程序
Seems like essentially the same program,

287
00:17:00,770 --> 00:17:02,840
但是可能有一些犯错的机会
but there are some ways of making errors here

288
00:17:02,840 --> 00:17:05,850
直到今天还存在
that didn't exist until today.

289
00:17:05,850 --> 00:17:07,320
例如
For example,

290
00:17:07,320 --> 00:17:09,690
如果我在赋值的时候
if I were to do the horrible thing

291
00:17:09,690 --> 00:17:12,440
没有小心地写程序
of not being careful in writing my program

292
00:17:12,440 --> 00:17:16,890
把两个赋值的顺序调换了
and interchange those two assignments,

293
00:17:16,890 --> 00:17:19,890
程序计算的就不是相同的函数了
the program wouldn't compute the same function.

294
00:17:19,890 --> 00:17:22,870
我得到了一个时间错误，因为这儿有个依赖关系
I get a timing error because there's a dependency

295
00:17:22,870 --> 00:17:27,220
m依赖于i上一次的值
there's a dependency that m depends upon having the last value of i.

296
00:17:27,220 --> 00:17:31,040
如果我先改变i的值
If I try change i first,

297
00:17:31,040 --> 00:17:35,550
就会在乘以m的时候，得到错误的i值
then I've got the wrong value of i when I multiply by m.

298
00:17:35,550 --> 00:17:38,380
在此之前不会存在这样的bug
It's a bug that wasn't available until this moment,

299
00:17:38,380 --> 00:17:42,260
直到我们把某些包含时间的东西引入进来才发生
until we introduced something that had time in it.

300
00:17:42,260 --> 00:17:45,370
如我所说的
So, as I said,

301
00:17:45,370 --> 00:17:47,390
首先，我们需要一个新的计算模型
first we need a new model of computation,

302
00:17:47,390 --> 00:17:52,300
然后，我们就不得不去找，搞这些坑爹事的好理由
and second, we have to be damn good reason for doing this kind of ugly thing.

303
00:17:52,300 --> 00:17:58,410
有什么问题吗？
Are there any questions?

304
00:17:58,410 --> 00:18:00,400
大声点说，David
Speak loudly, David

305
00:18:00,400 --> 00:18:03,720
学生：我们现在引入了set
AUDIENCE: I'm confused about, we've introduced set now,

306
00:18:03,720 --> 00:18:06,760
但是我们之前已经有let和define了
but we had let before and define before.

307
00:18:06,760 --> 00:18:09,700
我不太清楚它们的区别
I'm confused about the difference between the three.

308
00:18:09,700 --> 00:18:13,250
define不能像set一样用吗？
Wouldn't define work in the same situation as set

309
00:18:13,250 --> 00:18:14,830
请详细讲讲
if you introduced it a bit?

310
00:18:14,830 --> 00:18:19,310
教授：不，define是在第一次时创建某个东西时给它设置一个值用的
PROFESSOR: No, define is intended for setting something once the first time,

311
00:18:19,310 --> 00:18:21,740
为了创建它
for making it, OK?

312
00:18:21,740 --> 00:18:24,970
你永远也不会见到我在黑板上
You've never seen me write on a blackboard

313
00:18:24,970 --> 00:18:26,960
在同一行写两个define
two defines in a row

314
00:18:26,960 --> 00:18:32,080
为了让某个变量的旧值变成一个新的值
whose intention was to change the old value of some variable to a new one.

315
00:18:32,080 --> 00:18:34,510
学生：这是一个约定俗成的规矩，还是--
AUDIENCE: Is that by convention or--

316
00:18:34,510 --> 00:18:36,350
教授：不，这是有意为之的
PROFESSOR: No, it's intention.

317
00:18:36,350 --> 00:18:39,460
The answer is,

318
00:18:39,460 --> 00:18:40,840
举个例子
that, for example,

319
00:18:40,840 --> 00:18:42,900
在一个过程内部
internal to a procedure,

320
00:18:42,900 --> 00:18:46,440
两个define写在一行里是非法的
two defines in a row are illegal,

321
00:18:46,440 --> 00:18:49,520
对于同一个变量define两次是非法的
two defines in a row of the same variable.

322
00:18:49,520 --> 00:18:51,740
x 不能被define两次
x can't be defined twice.

323
00:18:51,740 --> 00:18:55,600
而系统会不会捕获这个错误，就是另一个问题了
Whether or not a system catches that error is a different question,

324
00:18:55,600 --> 00:18:58,120
但是我定下规矩
but I legislate to you

325
00:18:58,120 --> 00:19:00,640
任何东西都只能define一次
that define happens once on anything.

326
00:19:00,640 --> 00:19:03,150
现在，确实，在交互式调试中
Now, indeed, in interactive debugging,

327
00:19:03,150 --> 00:19:07,960
我们打算让你与你的计算机交互时可以重新define一些东西
we intend that you interacting with your computer will redefine things,

328
00:19:07,960 --> 00:19:11,690
所以这是交互式调试带来的一个特殊的异常
and so there's a special exception made for interactive debugging.

329
00:19:11,690 --> 00:19:17,490
#TBD
But define is intended to mean to set up something

330
00:19:17,490 --> 00:19:22,050
#TBD
which will be forever that value after that point.

331
00:19:22,050 --> 00:19:26,090
#TBD
It's as if all the defines were done at the beginning.

332
00:19:26,090 --> 00:19:29,110
#TBD
In fact, the only legal place to put a define

333
00:19:29,110 --> 00:19:31,110
#TBD
in Scheme, internal to a procedure,

334
00:19:31,110 --> 00:19:34,470
就是lambda表达式的开始
is just at the beginning of a lambda expression,

335
00:19:34,470 --> 00:19:39,950
过程体的开始
the beginning of the body of a procedure.

336
00:19:39,950 --> 00:19:47,760
现在，let当然与那个不一样
Now, let of course does nothing like either of that.

337
00:19:47,760 --> 00:19:50,000
如果你想知道let发生了什么
I mean, if you look at what's happening with a let,

338
00:19:50,000 --> 00:19:52,130
这个只会重新发生一次#TBD
this happens again exactly once.

339
00:19:52,130 --> 00:19:56,650
它建立了一个i和m的值分别为1的上下文
It sets up a context where i and m are values one and one.

340
00:19:56,650 --> 00:20:01,310
这个上下文存在于整个作用域中
That context exists throughout this scope,

341
00:20:01,310 --> 00:20:04,610
即程序的范围之内
this region of the program.

342
00:20:04,610 --> 00:20:10,780
然而，你不会认为let再次设置了i的值
However, you don't think of that let as setting i again.

343
00:20:10,780 --> 00:20:12,160
它没有改变i的值
It doesn't change it.

344
00:20:12,160 --> 00:20:15,090
因为let，i将永远不会变化
i never changes because of the let.

345
00:20:15,090 --> 00:20:18,350
因为let，i才被创建
i gets created because of let.

346
00:20:18,350 --> 00:20:19,730
实际上
In fact,

347
00:20:19,730 --> 00:20:21,980
let是一个非常简单的想法
the let is a very simple idea.

348
00:20:21,980 --> 00:20:23,590
let不会做别的事情
Let does nothing more,

349
00:20:23,590 --> 00:20:31,620
它让var1的值为1
Let a variable one to have value one

350
00:20:31,620 --> 00:20:37,160
我要把这些更规整地写下来
I'll write this down a little bit more neatly;

351
00:20:37,160 --> 00:20:43,730
var1的值，是表达式e1的值
Let's write, var one have value, the value of expression e1,

352
00:20:43,730 --> 00:20:47,920
var2的值，是表达式e2的值
and variable two, have this value of the expression e2,

353
00:20:47,920 --> 00:20:51,260
在表达式e3中
in an expression e3,

354
00:20:51,260 --> 00:21:06,730
#TBD与var1和var2的过程一样，它们是形式参数
is the same thing as a procedure of var one and var two, the formal parameters,

355
00:21:06,730 --> 00:21:10,710
e3成为过程的体
and e3 being the body,

356
00:21:10,710 --> 00:21:14,270
在这里，var1与e1的值绑定

where var one is bound to the value of e1,

357
00:21:14,270 --> 00:21:19,240
var2与e2的值绑定
and var two gets the value of e2.

358
00:21:19,240 --> 00:21:24,690
所以实际上，这是一个从代换的角度来看很容易理解的东西
So this is, in fact, a perfectly understandable thing from a substitution point of view.

359
00:21:24,690 --> 00:21:30,780
其实就是同一个表达式的两种不同的写法
This is really the same expression written in two different ways.

360
00:21:31,310 --> 00:21:37,260
事实上，系统真正的工作方式就是在运行之前，把代码翻译成这种形式
In fact, the way the actual system
works is this gets translated into this before anything happens.

361
00:21:37,260 --> 00:21:41,770
学生：我还是不清楚是什么造成了let和define之间的区别
AUDIENCE: OK, I'm still unclear as then what makes the difference between a let and a define. They could--

362
00:21:41,770 --> 00:21:44,490
教授:define就是个语法糖
PROFESSOR: A define is a syntactic sugar,

363
00:21:44,490 --> 00:21:49,670
#TBD
whereby, essentially a bunch of variables get created by lets and then set up once.

364
00:21:56,740 --> 00:21:59,990
那么，我们休息一会
OK, time for the first break, I think. Thank you.

365
00:22:02,520 --> 00:22:19,230
[音乐]
[MUSIC PLAYING]

366
00:22:48,810 --> 00:23:03,690
[音乐]
[MUSIC PLAYING]

367
00:23:03,690 --> 00:23:06,350
看
Well let's see.

368
00:23:06,350 --> 00:23:09,580
我现在不得不重建计算模型
I now have to rebuild the model of computation,

369
00:23:09,580 --> 00:23:14,630
所以你明白了那些机制是如何运作的
so you understand how some such mechanical mechanism could work

370
00:23:14,630 --> 00:23:17,280
来完成我们刚才说的那些工作
that can do what we've just talked about.

371
00:23:17,280 --> 00:23:22,380
我刚刚摧毁了你们的代换模型
I just recently destroyed your substitution model.

372
00:23:22,380 --> 00:23:26,460
不幸的是，这个模型比代换模型要复杂得多
Unfortunately, this model is significantly more complicated than the substitution model.

373
00:23:26,460 --> 00:23:28,680
这个模型叫环境模型
It's called the environment model.

374
00:23:28,680 --> 00:23:31,860
我即将介绍一些术语
And I'm going to have to introduce some terminology,

375
00:23:31,860 --> 00:23:34,510
无论如何，你知道这些术语都是很好的
which is very good terminology for you to know anyway. It's about names.

376
00:23:34,510 --> 00:23:36,510
它是关于名字的
It's about names.

377
00:23:36,510 --> 00:23:42,480
我们将要给事物拥有的名字和这些名字的用途命名
And we're going
to give names to the kinds of names things have and the way those names are used.

378
00:23:42,480 --> 00:23:47,940
所以这是一个元解释，如果你想这么理解的话
So this is a meta-description, if you will.

379
00:23:47,940 --> 00:23:50,850
不管怎样，这儿有一堆坑爹的术语
Anyway, there is a pile of an unfortunate terminology here,

380
00:23:50,850 --> 00:23:54,430
是我们将需要这些来理解所谓的环境模型
but we're going to need this to understand what's called the environment model.

381
00:23:54,430 --> 00:23:58,040
我们可能要做一点无聊的#TBD了
We're about to do a little bit of boring, dog-work here.

382
00:23:58,040 --> 00:24:02,000
我们来看第一张张幻灯片
Let's look at the first transparency.

383
00:24:02,000 --> 00:24:08,460
我们看到了一个术语“约束”的解释
And we see a description of a word called bound.

384
00:24:08,460 --> 00:24:11,000
我们会说一个变量v
And we're going to say that a variable, v,

385
00:24:11,000 --> 00:24:13,410
被约束在表达式e中
is bound in an expression, e,

386
00:24:13,410 --> 00:24:22,520
如果e的含义没有被变量w的形式代换改变的话
if the meaning of e is unchanged by the uniform replacement of a variable w,

387
00:24:22,520 --> 00:24:25,500
#TBD
for every occurrence of v in e.

388
00:24:25,500 --> 00:24:27,280
这是一个很长的句子
Now that's a long sentence,

389
00:24:27,280 --> 00:24:33,220
我想，在我们都被搞糊涂之前，我应该说得详细点。
so, I think, I'm going to have to say a little bit about that before we even fool around at all here.

390
00:24:33,220 --> 00:24:43,890
我们这里讨论的是约束变量
Bound variables we're talking about here.

391
00:24:43,890 --> 00:24:46,070
你们已经看到它们很多次了
And you've seen lots of them.

392
00:24:46,070 --> 00:24:49,600
但你们可能不知道自己已经见过它们很多次了
You may not know that you've seen lots of them.

393
00:24:49,600 --> 00:24:53,270
我猜在你们的逻辑中，你们看到一个逻辑变量
Well, I suppose in your logic you saw a logical variables like,

394
00:24:53,270 --> 00:25:02,600
对于任意任何x，存在一个y，使得p为真，就像你在微积分课上学到的。
for every x there exists a y such that p is true of x and y from your calculus class.

395
00:25:02,600 --> 00:25:06,840
这个变量x，这个变量y，它们被约束
This variable, x, and this variable, y, are bound,

396
00:25:06,840 --> 00:25:08,150
因为
because,

397
00:25:08,150 --> 00:25:09,980
这个表达式的含义
the meaning of this expression

398
00:25:09,980 --> 00:25:16,330
不取决于
我用来描述x和y的具体字母
does not depend upon the particular letters I used to describe x and y.

399
00:25:16,330 --> 00:25:19,820
如果我用w替换x
If I were to change the w for x,

400
00:25:19,820 --> 00:25:25,860
则可以说对于任意w，存在一个y使得p为真
then said for every w there exists a y such that p is true of w and y,

401
00:25:25,860 --> 00:25:27,860
它们其实是同一句话
it would be the same sentence.

402
00:25:27,860 --> 00:25:30,340
这就是那句话的意思
That's what it means.

403
00:25:30,340 --> 00:25:35,710
或者在另一个情况下，你们看到这是一个积分的描述
Or another case of this that you've seen is integral say,

404
00:25:35,710 --> 00:25:45,600
对1+x的平方分之dx从0到1积分
from 0 to one of dx over one plus x square.

405
00:25:45,600 --> 00:25:47,920
这就是你们经常见到的那种东西
Well that's something you see all the time.

406
00:25:47,920 --> 00:25:51,980
这个x是一个约束变量
And this x is a bound variable.

407
00:25:51,980 --> 00:25:54,150
如果我把它换成t
If I change that to a t,

408
00:25:54,150 --> 00:25:57,600
这个表达式其实没有变化
the expression is still the same thing.

409
00:25:57,600 --> 00:26:04,330
就是#TBD
This is a 1/4 of the arctan of one or something here.

410
00:26:04,330 --> 00:26:06,360
是的，就是1的反正切
Yes, that's the arctan of one.

411
00:26:06,360 --> 00:26:09,080
所以约束变量事实上很常见
So bound variables are actually fairly common,

412
00:26:09,080 --> 00:26:13,100
如果你们接触过一些数学的话for those of you who have played a bit with mathematics.

413
00:26:13,100 --> 00:26:18,720
好，让我们来到编程的世界
Well, let's go into the programming world.

414
00:26:18,720 --> 00:26:21,820
#TBD
Instead of the quantifier being something like,

415
00:26:21,820 --> 00:26:24,060
#TBD
for every, or there exists, or integral,

416
00:26:24,060 --> 00:26:27,220
#TBD
a quantifier is a symbol that binds a variable.

417
00:26:27,220 --> 00:26:29,520
我们要使用#TBDlambda
And we are going to use the quantifier lambda

418
00:26:29,520 --> 00:26:33,500
作为约束变量的一个必要的东西
as being the essential thing that binds variables.

419
00:26:33,500 --> 00:26:36,490
#TBD
And so we have some nice examples here

420
00:26:36,490 --> 00:26:44,140
#TBD
like that procedure of one argument y which does the following thing.

421
00:26:44,140 --> 00:26:47,590
它以一个参数x调用了过程
It calls the procedure of one argument x,

422
00:26:47,590 --> 00:26:52,040
将x乘以y
which multiplies x by y,

423
00:26:52,040 --> 00:26:55,650
#TBD
and applies that to three.

424
00:26:58,140 --> 00:27:01,780
这个过程中包含两个约束变量
That procedure has the property there of two bound variables in it,

425
00:27:01,780 --> 00:27:03,940
x和y
x and y

426
00:27:03,940 --> 00:27:07,910
这个量词，lambda，约束了这个y
This quantifier, lambda here, binds this y,

427
00:27:07,910 --> 00:27:11,640
这个量词lambda，约束了这个x
and this quantifier, lambda, binds that x.

428
00:27:11,640 --> 00:27:17,480
因为，如果我用了一个没有出现在表达式中的任意符号，如w，
Because, if I were to take an arbitrary symbol does not occur in this expression like w

429
00:27:17,480 --> 00:27:21,220
用w替换表达式中的所有y
and replace all y's with w's in this expression,

430
00:27:21,220 --> 00:27:23,530
这个表达式仍与原来的相同
the expression is still the same,

431
00:27:23,530 --> 00:27:25,280
是相同的过程
the same procedure.

432
00:27:25,280 --> 00:27:27,410
这是一个重要的想法
And this is an important idea.

433
00:27:27,410 --> 00:27:29,950
我们有这种东西的原因
The reason why we had such things like that

434
00:27:29,950 --> 00:27:31,410
是一种流行趋势
is a kind of modularity.

435
00:27:31,410 --> 00:27:33,510
如果有两个人写程序
If two people are writing programs,

436
00:27:33,510 --> 00:27:35,260
并且他们在合作编程
and they work together,

437
00:27:35,260 --> 00:27:42,100
在他们自己构建的小项目里用什么命名都没有关系
it shouldn't matter what names they use internal to their own little machines that they're building.

438
00:27:42,100 --> 00:27:45,300
所以，实际上我想告诉你们
And so, what I'm really telling you there,

439
00:27:45,300 --> 00:27:46,840
例如
is that, for example,

440
00:27:46,840 --> 00:27:52,190
这个表达式等于，以y为参数的过程
this is equivalent to that procedure of one argument y which

441
00:27:52,190 --> 00:28:01,270
#TBD
uses that procedure of one argument z which multiplies z by y.

442
00:28:01,270 --> 00:28:05,360
因为没人关心我在这用什么
Because nobody cares what I used in here.

443
00:28:05,360 --> 00:28:07,990
这是一个极好的例子
It's a nice example.

444
00:28:07,990 --> 00:28:10,330
另一方面
On the other hand,

445
00:28:10,330 --> 00:28:14,780
我有一些未被约束的变量
 I have some variables that are not bound.

446
00:28:14,780 --> 00:28:16,780
举个例子
And example,

447
00:28:19,590 --> 00:28:21,920
这个对于一个参数x的过程
that procedure of one argument x

448
00:28:21,920 --> 00:28:27,100
将x乘以y
which multiplies x by y

449
00:28:27,100 --> 00:28:29,100
在这个例子中
In this case,

450
00:28:29,100 --> 00:28:31,910
y没有被约束
y is not bound.

451
00:28:31,910 --> 00:28:34,860
假设y的值是3
Supposing y had the value three,

452
00:28:34,860 --> 00:28:37,900
z的值是4
and z had the value four,

453
00:28:37,900 --> 00:28:44,590
那么这个过程就是把它的参数乘以3
then this procedure would be the thing that multiplies its argument by three.

454
00:28:44,590 --> 00:28:47,420
如果我如果我把所有的y都用z来代替
If I were to replace every instance of y with z,

455
00:28:47,420 --> 00:28:53,440
我将得到一个完全不同的过程，它会把参数乘以4
I would have a different procedure which multiplies every argument that's given by four.

456
00:28:53,440 --> 00:28:57,440
事实上，我们给这种变量取了个名字
And, in fact, we have a name for such a variable.

457
00:28:57,440 --> 00:29:04,010
我们把表达式e中的变量v叫做自由变量
Here, we say that a variable, v, is free in the expression, e,

458
00:29:04,010 --> 00:29:09,500
if the meaning of the expression, e, is changed by the uniform replacement of a variable, w, not occurring in e

459
00:29:09,500 --> 00:29:12,170
for every occurrence of v and e.

460
00:29:12,170 --> 00:29:14,080
所以
So,

461
00:29:14,080 --> 00:29:29,160
所以这就是为什么这个变量y，是一个自由变量
So that's why this variable over here, y, is a free variable.

462
00:29:29,160 --> 00:29:33,220
所以，这个表达式里的自由变量
And so free variables in this expression--

463
00:29:33,220 --> 00:29:35,680
另一个例子是
And other examples of that is that

464
00:29:35,680 --> 00:29:40,160
对于一个参数y的过程
is that procedure of one argument y,

465
00:29:40,160 --> 00:29:42,160
就像我们之前的那个一样
which is just what we had before,

466
00:29:42,160 --> 00:29:44,900
使用对于参数x的过程
which uses that procedure of one argument x

467
00:29:44,900 --> 00:29:50,910
将x与y相乘--
that multiplies x by y--

468
00:29:50,910 --> 00:29:52,910
#TBD
use that on three.

469
00:29:56,850 --> 00:30:00,700
这个过程中有一个自由变量
This procedure has a free variable in it

470
00:30:00,700 --> 00:30:04,100
也就是这个星号
which is asterisk.

471
00:30:04,100 --> 00:30:05,890
你看，因为
See, because,

472
00:30:05,890 --> 00:30:09,080
如果它表示正常意义的乘法
if that has a normal meaning of multiplication,

473
00:30:09,080 --> 00:30:13,860
如果我形式上将所有星号都以加号代替
then if I were to replace uniformly all asterisks with pluses,

474
00:30:13,860 --> 00:30:18,840
这个表达式的含义就变了
then the meaning of this expression would change.

475
00:30:18,840 --> 00:30:21,840
这就是自由变量的意思
That's what you mean by a free variable.

476
00:30:21,840 --> 00:30:25,360
目前，你们已经学过了一些术语
So, so far you've learned some logician words

477
00:30:25,360 --> 00:30:28,560
用它们可以解释名字的用法
which describe the way names are used.

478
00:30:28,560 --> 00:30:32,540
我们要需要更进一步深入
Now, we have to do a little bit more playing around here,

479
00:30:32,540 --> 00:30:34,780
再多了解一些
a little bit more.

480
00:30:34,780 --> 00:30:36,640
我想给你们讲讲
I want to tell you about

481
00:30:36,640 --> 00:30:41,220
变量是在哪里被定义的
about the regions are over which variables are defined.

482
00:30:41,220 --> 00:30:43,120
你瞧
You see,

483
00:30:43,120 --> 00:30:46,000
#TBD
we've been very informal about this up till now,

484
00:30:46,000 --> 00:30:50,360
当然，你们中的一些，或者大部分人可能已经理解得很透彻了
and, of course, many of you have probably understood very clearly or most of you,

485
00:30:50,360 --> 00:30:53,460
在这里被声明的x
that the x that's being declared here

486
00:30:53,460 --> 00:30:57,440
只被定义在这里
is defined only in here.

487
00:30:57,440 --> 00:31:01,390
这个x，只被定义在这里
This x is the defined only in here,

488
00:31:01,390 --> 00:31:06,180
这个y，只被定义在这里
and this y is defined only in here.

489
00:31:06,180 --> 00:31:10,960
我们给它取了个名字，叫作用域
We have a name for such an idea. It's called a scope.

490
00:31:10,960 --> 00:31:14,320
我给你们再讲个术语
And let me give you another piece of terminology.

491
00:31:14,320 --> 00:31:15,850
这个就比较复杂
It's a long story.

492
00:31:15,850 --> 00:31:17,850
如果x是e中的一个约束变量
If x is a bound variable in e,

493
00:31:17,850 --> 00:31:20,720
那么它是约束于一个lambda表达式中
then there is a lambda expression where it is bound.

494
00:31:20,720 --> 00:31:24,910
获取约束变量的唯一方法就是通过lambda表达式
So the only way you can get a bound variable ultimately is by lambda expression.

495
00:31:24,910 --> 00:31:26,220
你可能会担心
Then you may worry,

496
00:31:26,220 --> 00:31:29,500
define是它的一个例外吗？
does define quite an exception to this?

497
00:31:29,500 --> 00:31:32,920
#TBD
And it turns out, we could always arrange things so you don't need any defines.

498
00:31:32,920 --> 00:31:34,240
一会我们就能看到了
And we'll see that in a while.

499
00:31:34,240 --> 00:31:36,540
它一个非常神奇的东西
It's a very magical thing.

500
00:31:36,540 --> 00:31:38,680
所以这里不需要define
So define really can go away.

501
00:31:38,680 --> 00:31:42,310
实际上，唯一能创建名字的东西是lambda
The really, only thing that makes names is lambda .

502
00:31:42,310 --> 00:31:44,140
那就是它的工作
That's its job.

503
00:31:44,140 --> 00:31:46,230
多么的令人惊奇
And what's so amazing about a lot of things

504
00:31:46,230 --> 00:31:48,540
很多东西你只凭借lambda就可以计算
is you can compute with only lambda.

505
00:31:48,540 --> 00:31:50,540
但是，在任何情况下
But, in any case,

506
00:31:50,540 --> 00:31:55,760
一个lambda表达式有一个地方来声明变量
a lambda expression has a place where it declares a variable.

507
00:31:55,760 --> 00:31:58,350
我们把它称为形式参数列表
We call it the formal parameter list

508
00:31:58,350 --> 00:32:01,110
或约束变量列表
and we say or the bound variable list.

509
00:32:01,110 --> 00:32:04,740
我们说lambda表达式约束--这是一个动词
We say that the lambda expression binds -- so it's a verb

510
00:32:04,740 --> 00:32:08,340
--约束了在约束变量列表里声明的变量
--binds the variables declared in it's bound variable list.

511
00:32:08,340 --> 00:32:13,040
另外，表达式中定义变量的那些部分
In addition, those parts of the expression where the variable is defined,

512
00:32:13,040 --> 00:32:15,450
是被一些声明所声明的
which was declared by some declaration

513
00:32:15,450 --> 00:32:20,100
这些部分被叫做变量的作用域
is called the scope of that variable.

514
00:32:20,100 --> 00:32:22,100
所以，这些是作用域
So these are scopes.

515
00:32:22,100 --> 00:32:27,160
这是y的作用域
This is the scope of y.

516
00:32:27,160 --> 00:32:32,750
这是x的作用域--
And this is the scope of x--

517
00:32:32,750 --> 00:32:35,010
以此类推
that sort of thing.

518
00:32:40,860 --> 00:32:43,550
好
OK,

519
00:32:43,550 --> 00:32:46,250
现在我们有了足够多的术语
well, now we have enough terminology

520
00:32:46,250 --> 00:32:51,760
用来理解如何建立一个新的计算模型了
to begin to understand how to make a new model for computation

521
00:32:51,760 --> 00:32:54,500
因为，很重要的一点是
because the key thing going on here

522
00:32:54,500 --> 00:32:57,100
我们摧毁了代换模型
is that we destroyed the substitution model,

523
00:32:57,100 --> 00:33:03,510
我们现在不得不需要一个模型，来体现表示名字被关联到某些地方
and we now have to have a model that represents the names as referring to places.

524
00:33:03,510 --> 00:33:05,720
因为，如果我们要改变某个东西
Because if we are going to change something,

525
00:33:05,720 --> 00:33:09,050
我们就需要一个存它的地方
then we have a place where it's stored.

526
00:33:09,050 --> 00:33:10,510
你看
You see,

527
00:33:10,510 --> 00:33:13,580
如果一个名字只是关联于一个值
if a name only refers to a value,

528
00:33:13,580 --> 00:33:16,540
如果我试图改变这个名字的含义
and if I tried to change the name's meaning,

529
00:33:16,540 --> 00:33:20,320
这不怎么明确 well, that's not clear.

530
00:33:20,320 --> 00:33:24,680
因为没有名字可以关联的地方
There's nothing that is the place that that name referred to.

531
00:33:24,680 --> 00:33:27,110
我如何真正的去描述它呢？
How am I really saying it? There is nothing shared

532
00:33:27,110 --> 00:33:29,540
没有东西在名字的所有实例之间共享
among all of the instances of that name.

533
00:33:29,540 --> 00:33:31,680
我们真正的意思是，对于一个名字
And what we really mean, by a name,

534
00:33:31,680 --> 00:33:33,800
#TBD
is that we fan something out.

535
00:33:33,800 --> 00:33:36,540
我们为某个东西命名，然后你拿到了它
We've given something a name, and you have it,

536
00:33:36,540 --> 00:33:39,060
你能得到它，是因为我给了你一个它的引用
and you have it, because I'm given you a reference to it,

537
00:33:39,060 --> 00:33:40,850
我把对它的引用给了你
and I've given you a reference to it.

538
00:33:40,850 --> 00:33:43,010
我们会看到很多相关的例子#TBD
And we'll see a lot about that.

539
00:33:43,010 --> 00:33:45,820
所以我来教给你关于环境的知识
So let me tell you about environments.

540
00:33:45,820 --> 00:33:49,020
我需要用一下头顶上的幻灯机I need the overhead projection machine,

541
00:33:49,020 --> 00:33:51,020
谢谢你
thank you.

542
00:33:51,610 --> 00:33:53,620
这里
And so here

543
00:33:55,080 --> 00:34:01,080
是一堆环境结构
is a bunch of environment structures.

544
00:34:01,080 --> 00:34:06,020
环境就是执行虚拟的代换的一种方法
An environment is a way of doing
substitutions virtually.

545
00:34:06,020 --> 00:34:07,890
它代表了一个地方
It represents a place

546
00:34:07,890 --> 00:34:12,980
是存储你的未完成的代换的地方
where something is stored which is the substitutions that you haven't done.

547
00:34:12,980 --> 00:34:16,500
它是一个收集各种东西的地方
It's a place where everything accumulates,

548
00:34:16,500 --> 00:34:21,460
在那里，变量的名字与值关联在一起
where the names of the variables are associated with the values they have

549
00:34:21,460 --> 00:34:22,660
所以
such that,

550
00:34:22,660 --> 00:34:25,900
当你问某个名字是什么意思的时候
when you say, what dose this name mean,

551
00:34:25,900 --> 00:34:27,900
你要在一个环境中寻找答案
you look it up in an environment.

552
00:34:27,900 --> 00:34:30,410
所以环境是一个函数
So an environment is a function,

553
00:34:30,410 --> 00:34:31,940
或一张表
or a table,

554
00:34:31,940 --> 00:34:33,240
或类似的东西
or something like that.

555
00:34:33,240 --> 00:34:35,460
但它是一种结构化的表
But it's a structured sort of table.

556
00:34:35,460 --> 00:34:38,400
它是由框架构成
It's made out of things called frames.

557
00:34:40,860 --> 00:34:44,600
框架是环境的一部分Frames are pieces of environment,

558
00:34:44,600 --> 00:34:46,600
它们被链接在一起
and they are chained together,

559
00:34:46,600 --> 00:34:48,600
以某种很好的方式
in some nice ways,

560
00:34:48,600 --> 00:34:53,080
就是叫做#TBD之类的东西
by what's called parent links or something like that.

561
00:34:53,080 --> 00:34:55,310
这里
So here,

562
00:34:55,310 --> 00:34:57,620
有一个环境结构
we have an environment structure

563
00:34:57,620 --> 00:35:04,900
它由三个环境组成，分别是A，B和C
consisting of three environments, basically, A, B, and C.

564
00:35:04,900 --> 00:35:08,580
D也是环境，但它和C是一样的
d is also an environment, but it's the same one,

565
00:35:08,580 --> 00:35:11,010
它们共享了同一个环境
they share.

566
00:35:11,010 --> 00:35:14,280
那就是赋值的精髓所在
And that's the essence of assignment.

567
00:35:14,280 --> 00:35:16,100
如果我改变了一个变量
If I change a variable,

568
00:35:16,100 --> 00:35:19,800
比如改变这个变量的值
a value of a valuable that lives here, like that one,

569
00:35:19,800 --> 00:35:23,500
那么它将在所有地方都可见
it should be visible from all places that you're looking at it from.

570
00:35:23,500 --> 00:35:24,840
用x来举例
Take this one, x.

571
00:35:24,840 --> 00:35:28,190
如果我将x改为4
If I change the x to four,

572
00:35:28,190 --> 00:35:30,190
在其他地方也是可见的
it's visible from other places.

573
00:35:30,190 --> 00:35:32,190
但是我们现在不去关心这个
But I'm not going to worry about that right now.

574
00:35:32,190 --> 00:35:34,310
过一会儿会详细讨论这个问题
We're going to talk a lot about that in a little while.

575
00:35:34,310 --> 00:35:36,540
这里有什么？
What do we have here?

576
00:35:36,540 --> 00:35:39,220
这些叫做框架。这是一个框架
Well, these are called frames. Here is a frame,

577
00:35:39,220 --> 00:35:40,620
这是一个框架
here's a frame

578
00:35:40,620 --> 00:35:42,770
这也是一个框架
and here's a frame.

579
00:35:42,770 --> 00:35:45,200
A是一个环境
A is an environment which consists of

580
00:35:45,200 --> 00:35:48,170
它由框架II
the table label which is frame two,

581
00:35:48,170 --> 00:35:52,200
和框架I组成
followed by the table labeled frame one.

582
00:35:52,200 --> 00:35:54,870
在这个环境中
And, in this environment,

583
00:35:54,870 --> 00:36:00,200
在这个所谓的环境中，也就是框架II中
in say this environment, frame two,

584
00:36:00,200 --> 00:36:03,840
x和y是被约束的
x and y are bound.

585
00:36:03,840 --> 00:36:05,260
它们有值
They have values.

586
00:36:05,260 --> 00:36:07,180
对不起，是在框架I中
Sorry, in frame one

587
00:36:07,180 --> 00:36:09,520
在框架II中
In frame two,

588
00:36:09,520 --> 00:36:10,880
z被约束
z is bound,

589
00:36:10,880 --> 00:36:12,280
x被约束
and x is bound,

590
00:36:12,280 --> 00:36:14,780
并且y也是被约束的
and y is bound,

591
00:36:14,780 --> 00:36:17,420
但是我们看到的x的值
but the value of x that we see,

592
00:36:17,420 --> 00:36:19,640
从这个角度来看
looking from this point of view,

593
00:36:19,640 --> 00:36:22,230
是这个x，它的值是7
is this x. It's x is seven,

594
00:36:22,230 --> 00:36:24,840
而不是这个值为3的x
rather than this one which is three.

595
00:36:24,840 --> 00:36:30,100
我们称之为，这个x隐蔽了这个x
We say that this x shadows this x.

596
00:36:30,720 --> 00:36:32,980
从环境III
From environment three--

597
00:36:32,980 --> 00:36:34,450
从框架III
from frame three,

598
00:36:34,450 --> 00:36:35,730
从环境B
from environment b,

599
00:36:35,730 --> 00:36:37,450
它引用了框架III
which refers to frame three,

600
00:36:37,450 --> 00:36:44,010
变量n 和y被约束，x也被约束
we have variables n and y bound and also x.

601
00:36:44,010 --> 00:36:48,150
这个y把它隐蔽了
This y shadow this one.

602
00:36:48,150 --> 00:36:51,000
从这个角度来看
So the value, looking from this point of view,

603
00:36:51,000 --> 00:36:53,180
y的值是2
of y is two.

604
00:36:53,180 --> 00:36:55,280
从这个角度来看
The value for looking from this point of view

605
00:36:55,280 --> 00:36:59,620
m的值是1，x的值是3
and m is one. And the value, looking from this point of view, of x is three.

606
00:37:01,920 --> 00:37:03,150
所以，我们有了一个
So there we have

607
00:37:03,150 --> 00:37:06,060
由框架构成的非常简单的环境结构
a very simple environment structure made out of frames.

608
00:37:06,060 --> 00:37:10,700
它们与过程的应用相一致
These correspond to the applications of procedures.

609
00:37:10,700 --> 00:37:13,420
我们马上就会看到
And we'll see that in a second.

610
00:37:13,420 --> 00:37:18,690
现在要给你们看看我们构建的一些其他的很好的小结构
So now I have to make you some other nice little structure that we build.

611
00:37:20,560 --> 00:37:22,020
下一张幻灯片
Next slide,

612
00:37:22,020 --> 00:37:24,840
我们可以看到一个对象
we see an object,

613
00:37:24,840 --> 00:37:27,620
我们将要描绘它的过程
which I'm going to draw procedures.

614
00:37:27,620 --> 00:37:29,830
这是一个过程
This is a procedure.

615
00:37:29,830 --> 00:37:32,840
这个过程由两个部分组成
A procedure is made out of two parts.

616
00:37:32,840 --> 00:37:36,300
这有点像cons
It's sort of like a cons.

617
00:37:36,790 --> 00:37:39,440
不管怎样，它有两个部分
However, it's the two parts.

618
00:37:40,440 --> 00:37:45,420
第一个部分指向一些代码
The first part refers to some code,

619
00:37:45,420 --> 00:37:47,420
这些代码将会被执行
something that can be executed,

620
00:37:47,420 --> 00:37:50,530
你可以把它视作一组指令
a set of instructions, if you will. You can think of it that way.

621
00:37:50,530 --> 00:37:53,700
第二部分是环境
And the second part is the environment.

622
00:37:53,700 --> 00:37:56,710
这个过程就是全部了
The procedure is the whole thing.

623
00:37:56,710 --> 00:37:58,710
我们要用它
And we're going to have to use this

624
00:37:58,710 --> 00:38:05,910
来捕获出现在过程中的自由变量的值
to capture the values of the free variables that occur in the procedure.

625
00:38:05,910 --> 00:38:10,860
如果过程中出现一个变量，它不是约束变量就是自由变量
If a variable occurs in the procedure it's either bound in that procedure or free.

626
00:38:10,860 --> 00:38:12,380
如果它是约束变量
If it's bound,

627
00:38:12,380 --> 00:38:15,670
则它的值将很容易被找到
then the value will somehow be easy to find.

628
00:38:15,890 --> 00:38:18,910
它将存在于某个很容易找到的环境中
It will be in some easy environment to get at.

629
00:38:18,910 --> 00:38:20,660
如果它是自由变量
If it's free,

630
00:38:20,660 --> 00:38:23,020

we're going to have to have something that goes with the procedure

631
00:38:23,020 --> 00:38:26,280

that says where we'll go look for its value.

632
00:38:26,280 --> 00:38:29,210
现在为什么的理由还不清楚
And the reasons why are not obvious yet,

633
00:38:29,210 --> 00:38:31,760
但很快就要真相大白了
but will be soon.

634
00:38:31,760 --> 00:38:35,190
这里有一个对象，它是个混合的对象
So here's a procedure object. It's a composite object

635
00:38:35,190 --> 00:38:42,400
由一些代码和一个环境结构组成
consisting of a piece of code and a environment structure.

636
00:38:42,400 --> 00:38:46,190
现在我要告诉你们一些全新的规则
Now I will tell you the new rules, the complete new rules,

637
00:38:46,190 --> 00:38:49,200
关于执行的规则
for evaluation.

638
00:38:50,320 --> 00:38:52,960
这里只有两条规则
The first rule is-- there's only two of them.

639
00:38:52,960 --> 00:38:56,920
这些规则与代换模型规则相对应
These correspond to the substitution model rules.

640
00:38:56,920 --> 00:38:59,480
第一条规则是用来解决
And the first one has to do with

641
00:38:59,480 --> 00:39:04,140
如何把一个过程，应用到它参数上的问题的
how do you apply a procedure to its arguments?

642
00:39:05,020 --> 00:39:08,820
程序对象被应用于一组参数
And a procedural object is applied to a set of arguments

643
00:39:08,820 --> 00:39:10,940
是通过构建一个新的框架来完成
by constructing a new frame.

644
00:39:10,940 --> 00:39:15,830
那个框架将包含形式参数
That frame will contain the mapping of the former parameters to the actual
parameters

645
00:39:15,830 --> 00:39:20,960
对调用中使用的实际参数的映射
of the arguments that were supplied in the call.

646
00:39:20,960 --> 00:39:22,310
如你所知
As you know,

647
00:39:22,310 --> 00:39:26,940
当我们建立一个过程，如lambda x， x乘y
when we make up a call to a procedure like lambda x times x y,

648
00:39:26,940 --> 00:39:29,900
然后我们以3为参数调用它
and we call that with the argument three,

649
00:39:29,900 --> 00:39:33,870
那么我们需要某个从x到3的映射
then we're going to need some mapping of x to three.

650
00:39:33,870 --> 00:39:36,520
这与之前的代换是一样的
It's the same thing as later substituting,

651
00:39:36,520 --> 00:39:41,520
在旧的模型中，x代换为3
if you will, the three for the x in the old model.

652
00:39:41,520 --> 00:39:44,990
所以我要建立一个框架
So I'm going to build a frame which contains x equals three

653
00:39:44,990 --> 00:39:48,160
在框架中包含x等于3的这个信息
as the information in that frame.

654
00:39:48,160 --> 00:39:50,160
现在
Now,

655
00:39:50,160 --> 00:39:53,960
过程的体即将被执行
the body of the procedure will then have to be evaluated which is this,

656
00:39:53,960 --> 00:39:57,610
它将在一个环境中执行
and will be evaluated in an environment

657
00:39:57,610 --> 00:40:08,370
这个环境是由我们创建的新框架组合而成
which is constructed by adjoining the new frame that we just made

658
00:40:08,370 --> 00:40:12,770
它是我们所应用的哦成的一部分
to the environment which was part of the procedure that we applied.

659
00:40:12,770 --> 00:40:17,820
所以，举个例子
So I'm going to make a little example of that here.

660
00:40:18,680 --> 00:40:24,920
假设我有一些环境
Supposing I have some environment.

661
00:40:24,920 --> 00:40:27,570
画个方框代表它
Here's a frame which represents it.

662
00:40:27,570 --> 00:40:32,830
以及一些过程--我画圆来代表它们，因为这比小三角形好画--
And some procedure-- which I'm going to draw with circles here because it's easier than little triangles--

663
00:40:32,830 --> 00:40:37,460
抱歉，是菱形
Sorry, those are rhombuses,

664
00:40:37,460 --> 00:40:42,400
小块菱形的果冻之类的东西
rhomboidal little pieces of fruit jelly or something.

665
00:40:42,400 --> 00:40:45,700
这有一个使用这个环境的过程
So here's a procedure which takes this environment.

666
00:40:45,700 --> 00:40:48,160
这个过程有一些代码
And the procedure has a piece of code,

667
00:40:48,160 --> 00:40:50,120
是一个lambda表达式
which is a lambda expression,

668
00:40:50,120 --> 00:40:52,960
约束了x和y
which binds x and y

669
00:40:52,960 --> 00:40:57,760
然后执行了表达式e
and then executes an expression, e.

670
00:40:57,760 --> 00:40:59,560
这是一个过程
And this is the procedure.

671
00:40:59,560 --> 00:41:01,060
我们叫它p
We'll call it p.

672
00:41:01,060 --> 00:41:06,180
我希望将这个过程应用于3和4
I wish to apply that procedure to three and four.

673
00:41:06,180 --> 00:41:09,530
所以我在这写(p 3 4)
So I want to do p of three and four.

674
00:41:09,530 --> 00:41:12,890
我要做的事情是，是创建一个新的框架
What I'm going to do, of course, is make a new frame.

675
00:41:12,890 --> 00:41:15,140
我建立了一个框架
I build a frame

676
00:41:15,140 --> 00:41:18,640
框架中x等于3
which contains x equals three,

677
00:41:18,640 --> 00:41:21,240
y等于4
and y equals four.

678
00:41:21,240 --> 00:41:24,130
我要把这个框架
I'm going to connect that frame

679
00:41:24,130 --> 00:41:26,130
连接到这一个框架上
to this frame over here.

680
00:41:27,120 --> 00:41:29,680
对于这个环境
And then this environment,

681
00:41:29,680 --> 00:41:31,300
我把它叫做B
with I will call b,

682
00:41:31,300 --> 00:41:37,070
我会在这个环境中执行e的体
is the environment in which I will evaluate the body of e.

683
00:41:39,370 --> 00:41:41,370
现在
Now,

684
00:41:41,370 --> 00:41:46,290
e可能包含了x和y的引用以及一些别的东西
e may contain references to x and y and other things.

685
00:41:46,290 --> 00:41:50,540
x和y的值在这里
x and y will have values right here.

686
00:41:50,540 --> 00:41:54,300
其他的变量的值在这里
Other things will have their values here.

687
00:41:54,700 --> 00:41:56,940
怎样才能获取这个框架呢？
How do we get this frame?

688
00:41:56,940 --> 00:41:59,450
我们通过过程构建来完成
That we do by the construction of procedures

689
00:41:59,450 --> 00:42:01,840
这就是另一条规则了
which is the other rule.

690
00:42:01,840 --> 00:42:05,140
请看下一张幻灯片
And I think that's the next slide.

691
00:42:05,140 --> 00:42:07,310
规则二
Rule two,

692
00:42:07,310 --> 00:42:09,900
当一个lambda表达式被执行时
when a lambda expression is evaluated,

693
00:42:09,900 --> 00:42:13,650
相对于某个特定的环境--
relative to a particular environment--

694
00:42:13,650 --> 00:42:14,700
看
See,

695
00:42:14,700 --> 00:42:18,120
获取一个过程的方式就是执行一个lambda表达式
the way I get a procedure is by evaluating the lambda expression.

696
00:42:18,120 --> 00:42:19,850
这里有一个lambda表达式
Here's a lambda expression.

697
00:42:19,850 --> 00:42:21,630
通过执行它
By evaluating it,

698
00:42:21,630 --> 00:42:24,860
我获得了一个可以应用于3的过程
I get a procedure which I can apply to three.

699
00:42:24,860 --> 00:42:26,650
现在lambda表达式
Now this lambda expression

700
00:42:26,650 --> 00:42:31,540
在一个y已被定义的环境中执行
is evaluated in an environment where y is defined.

701
00:42:31,540 --> 00:42:36,390
我希望这个过程的体中包括的y是自由变量
And I want the body of this which contains a free version of y.

702
00:42:36,390 --> 00:42:38,660
在这里面，y是自由变量
y is free in here,

703
00:42:38,660 --> 00:42:41,230
它在其他的地方都是被约束的
it's bound over the whole thing,

704
00:42:41,230 --> 00:42:43,190
但在这里是自由变量
but it's free over here.

705
00:42:43,190 --> 00:42:47,060
我想让这个y成为它
I want that y to be this one.

706
00:42:47,060 --> 00:42:55,280
我在y被创建的环境中执行这个过程的体
I evaluate this body of this procedure in the environment where y was created.

707
00:42:55,280 --> 00:42:58,860
#TBD
That's this kind of thing, because that was done by application.

708
00:42:58,860 --> 00:43:00,030
现在
Now,

709
00:43:00,030 --> 00:43:02,850
如果我还想查找y的值
if I ever want to look up the value of y,

710
00:43:02,850 --> 00:43:04,320
我就必须知道它在哪
I have to know where it is.

711
00:43:04,320 --> 00:43:06,420
因此，这个过程在被创建时
Therefore, this procedural was created,

712
00:43:06,420 --> 00:43:10,060
过程的创建，也就是lambda表达式的执行结果
the creation of the procedure which is the result of evaluating that lambda expression

713
00:43:10,060 --> 00:43:17,840
最好是获取一个指针或记住y被约束在哪个框架中
had better capture a pointer or remember the frame in which y was bound.

714
00:43:17,840 --> 00:43:20,960
这就是这个规则的内容
So that's what this rule is telling us.

715
00:43:20,960 --> 00:43:24,310
那么，举个例子
So, for example,

716
00:43:24,310 --> 00:43:30,680
如果我恰好执行了一个lambda表达式
if I happen to be evaluating a lambda expression,

717
00:43:30,680 --> 00:43:33,780
在e中的lambda表达式
lambda expression in e,

718
00:43:33,780 --> 00:43:40,990
#TBD
lambda of say, x and y, let's call it g in e,

719
00:43:40,990 --> 00:43:42,760
执行它
evaluating that.

720
00:43:42,760 --> 00:43:46,880
这些事的意义就是我现在构建了一个过程对象
all that means is I now construct a procedure object.

721
00:43:46,880 --> 00:43:48,560
e是某个环境
e is some environment.

722
00:43:48,560 --> 00:43:51,520
有个指针指向e
e is something which has a pointer to it.

723
00:43:51,520 --> 00:43:58,240
我构建了一个过程对象指向了这个环境
I construct a procedure object that points up to that environment,

724
00:43:58,240 --> 00:44:00,450
它的代码
where the code of that

725
00:44:00,450 --> 00:44:05,920
是一个lambda表达式，或者其他可以翻译为lambda表达式的东西
is a lambda expression or whatever that translates into.

726
00:44:05,920 --> 00:44:12,020
而这就是一个过程
And this is the procedure.

727
00:44:12,020 --> 00:44:14,940
所以这个产物对我来说
So this produces for me--

728
00:44:14,940 --> 00:44:16,370
这个对象
this object here,

729
00:44:16,370 --> 00:44:18,370
这个环境指针
this environment pointer,

730
00:44:18,370 --> 00:44:22,520
获取了lambda表达式执行所处于的环境
captures the place where this lambda expression was evaluated,

731
00:44:22,520 --> 00:44:25,360
定义所使用的环境
where the definition was used,

732
00:44:25,360 --> 00:44:29,960
创建一个过程时的定义所用的环境
where the definition was used to make a procedure,

733
00:44:29,960 --> 00:44:32,540
从而创建了过程
to make the procedure.

734
00:44:32,540 --> 00:44:37,040
所以，它将环境从定义过程的地方取出
So it picks up the environment from the place where that procedure was defined,

735
00:44:37,040 --> 00:44:39,350
将它保存在过程自己内部
stores it in the procedure itself,

736
00:44:39,350 --> 00:44:41,140
之后当过程被调用时
and then when the procedure is used,

737
00:44:41,140 --> 00:44:43,820
它在被定义时的环境
the environment where it was defined is extended

738
00:44:43,820 --> 00:44:48,240
将由新的框架扩充
with the new frame.

739
00:44:48,240 --> 00:44:52,790
这给了我们一个放置有值的变量的地方
So this gives us a locus for putting where a variable has a value.

740
00:44:52,790 --> 00:44:53,960
举个例子
And, for example,

741
00:44:53,960 --> 00:44:57,520
如果有很多东西指向那这个环境
if there are lots of guys pointing in at that environment,

742
00:44:57,520 --> 00:45:01,030
它们就会共享这个环境
then they share that place.

743
00:45:01,030 --> 00:45:03,660
我们很快就会更进一步了解它们
And we'll see more of that shortly.

744
00:45:03,660 --> 00:45:06,290
现在你们有了一个新模型
Well, now you have a new model

745
00:45:06,290 --> 00:45:10,950
我们用它来理解程序的执行
for understanding the execution of programs.

746
00:45:10,950 --> 00:45:13,100
我觉得现在我应该解答一些问题了
I suppose I'll take questions now,

747
00:45:13,100 --> 00:45:17,600
之后我们再继续
and then we'll go on and use that for something.

748
00:45:17,600 --> 00:45:19,520
学生：这么说是对的吗？
AUDIENCE: Is it right to say then,

749
00:45:19,520 --> 00:45:23,960
环境就是被连接在一起的框架开始的地方--
the environment is that linked chain of frames starting with--

750
00:45:23,960 --> 00:45:25,480
教授：对的
PROFESSOR: That's right.

751
00:45:25,480 --> 00:45:27,440
学生：通过它能够取回所有的框架？
AUDIENCE:  working all the way back?

752
00:45:27,440 --> 00:45:32,160
教授：是的，环境是一系列被连接在一起的框架
PROFESSOR: Yes, the environment is a sequence of frames linked together.

753
00:45:32,160 --> 00:45:36,600
我对它的理解是，它是指向第一个框架的指针
And the way I like to think about it, it's the pointer to the first one,

754
00:45:36,600 --> 00:45:41,500
因为一旦你获得了它，你就能拿到所有的框架
because once you've got that you've got them all.

755
00:45:43,500 --> 00:45:45,500
还有谁有问题吗？
Anybody else?

756
00:45:45,500 --> 00:45:49,360
学生：有这种可能吗？在两个不同的环境中执行
AUDIENCE: Is it possible to evaluate a procedure or to define a procedure in two different environments

757
00:45:49,360 --> 00:45:53,200
或定义一个过程，使得它有不同的行为，并且有指向两个环境的指针--
such that it will behave differently, and have pointers to both--

758
00:45:53,200 --> 00:45:56,900
教授：噢，是的。同一个过程不会有两个不同环境
PROFESSOR: Oh, yes. The same procedure is not going to have two different environments.

759
00:45:56,900 --> 00:45:59,020
同样的代码
The same code,

760
00:45:59,020 --> 00:46:00,820
同样的lambda表达式
the same lambda expression

761
00:46:00,820 --> 00:46:05,790
可以在两个不同的环境中执行
can be evaluated in two environments producing two different procedures.

762
00:46:05,790 --> 00:46:07,180
每个过程--
Each procedure--

763
00:46:07,180 --> 00:46:09,950
学生：它们的定义有同样的名字，它们的操作--
AUDIENCE: Their definition has the same name. Their operation--

764
00:46:09,950 --> 00:46:12,380
教授：它们定义是写起来是一样的，使用同样的字母
PROFESSOR: The definition is written the same, with the same characters.

765
00:46:12,380 --> 00:46:14,930
我能执行那一组字母
I can evaluate that set of characters,

766
00:46:14,930 --> 00:46:18,140
或定义的列表结构之类的东西
whatever, that list structure that defines,

767
00:46:18,140 --> 00:46:20,800
那只是文本表示
that is the textual representation.

768
00:46:20,800 --> 00:46:25,420
我可以在两个不同环境种执行它，产生两个不同的过程
I can evaluate that in two different environments producing two different procedures.

769
00:46:25,420 --> 00:46:27,420
每一个过程
Each of those procedures

770
00:46:27,420 --> 00:46:32,340
有它们自己的一组局部变量
has its own local sets of variables,

771
00:46:32,340 --> 00:46:36,100
我们很快就会看到
and we'll see that right now.

772
00:46:36,100 --> 00:46:38,950
还有其他人吗？
Anybody else?

773
00:46:42,220 --> 00:46:46,520
好，谢谢你们，我们休息一会
OK, thank you. Let's take a break.

774
00:46:46,520 --> 00:47:03,170
[音乐]
[MUSIC PLAYING]

775
00:47:05,610 --> 00:47:22,670
[音乐]
[MUSIC PLAYING]

776
00:47:22,670 --> 00:47:26,420
我现在已经为你们做了一件非常糟糕的事情
Well, now I've done this terrible thing to you.

777
00:47:26,420 --> 00:47:32,230
我引入了一个非常复杂的东西
I've introduced a very complicated thing,

778
00:47:32,230 --> 00:47:34,350
赋值
assignment,

779
00:47:34,350 --> 00:47:40,700
它摧毁了我们程序中大部分的，有趣的数学特性
which destroys most of the interesting mathematical properties of our programs.

780
00:47:40,700 --> 00:47:42,980
我为什么要做这件事呢
Why should I have done this?

781
00:47:42,980 --> 00:47:45,860
这样做可能有什么好处吗？
What possible good could this do?

782
00:47:45,860 --> 00:47:49,340
很明显，这不是一个什么好东西
Clearly not a nice thing,

783
00:47:49,340 --> 00:47:52,560
因此我最好有一个好的解释
so I better have a good excuse.

784
00:47:52,560 --> 00:47:54,800
让我们来小小地玩一下
Well, let's do a little bit of playing,

785
00:47:54,800 --> 00:47:58,680
首先，我们写些非常有趣的带赋值的程序
first of all, with some very interesting programs that have assignment.

786
00:47:58,680 --> 00:48:01,290
来理解它们的特殊之处
Understand something special about them

787
00:48:01,290 --> 00:48:04,310
这些特殊之处使赋值变得有价值
that makes them somewhat valuable.

788
00:48:04,310 --> 00:48:07,550
我们从一个非常简单的程序开始
Start with a very simple program

789
00:48:07,550 --> 00:48:10,350
我把这个程序叫做make-counter
I'm going to call make-counter.

790
00:48:10,350 --> 00:48:24,060
我要把它定义为
I'm going to define make-counter

791
00:48:24,060 --> 00:48:29,020
接受一个参数n的过程
to be a procedure of one argument n

792
00:48:29,020 --> 00:48:34,190
并且它的返回值是一个没有参数的过程--
which returns as its value a procedure of no arguments--

793
00:48:34,190 --> 00:48:36,670
一个生成过程的过程--
a procedure that produces a procedure--

794
00:48:36,670 --> 00:48:47,540
这个过程把n的值设为n加1
which sets n to the increment of n

795
00:48:47,540 --> 00:48:53,700
并且返回n的值
and returns that value of n.

796
00:48:54,850 --> 00:48:57,540
现在，我们要研究它的行为
Now we're going to investigate the behavior of this.

797
00:48:57,540 --> 00:48:59,540
它很有趣
It's a sort of interesting thing.

798
00:48:59,540 --> 00:49:01,450
为了研究它的行为
In order to investigate the behavior,

799
00:49:01,450 --> 00:49:03,830
我需要建立一个环境模型
I have to make an environment model,

800
00:49:03,830 --> 00:49:08,000
因为我们不能通过其他的方式来理解它
because we can't understand this any other way.

801
00:49:08,000 --> 00:49:10,000
所以我们开始吧
So let's just do that.

802
00:49:10,000 --> 00:49:13,240
我们从这里开始
We start out with some sort of--

803
00:49:13,240 --> 00:49:16,130
假设机器天生就有一个全局的环境
let's say there is a global environment that the machine is born with.

804
00:49:16,130 --> 00:49:19,780
我们把它叫做全局环境
Global we'll call it.

805
00:49:19,780 --> 00:49:24,440
它内部有一堆初始化的东西
And it's going to have in it a bunch of initial things.

806
00:49:24,440 --> 00:49:25,720
我们都知道它里面有什么
We all know what it's got.

807
00:49:25,720 --> 00:49:32,130
这里面有+和*
It's got things in it like say, plus, and times,

808
00:49:32,130 --> 00:49:38,570
/，-和CAR
and quotient, and difference, and CAR,

809
00:49:38,570 --> 00:49:41,450
以此类推
and etcetera,

810
00:49:41,450 --> 00:49:42,720
有很多东西
lots of things.

811
00:49:42,720 --> 00:49:44,420
我不知道它们是什么
I don't know what they are,

812
00:49:44,420 --> 00:49:45,980
一些#TBD
some various squiggles

813
00:49:45,980 --> 00:49:50,560
机器一开始就有这些特性
that are the things the machine is born with.

814
00:49:50,560 --> 00:49:54,370
通过在这做定义
And by doing the definition here,

815
00:49:54,370 --> 00:49:56,160
我要做的是--
what I plan to do--

816
00:49:56,160 --> 00:49:57,310
我在干什么呢？
Well, what am I doing?

817
00:49:57,310 --> 00:49:59,720
我要把它关联到全局环境上
I'm doing this relative to the global environment.

818
00:49:59,720 --> 00:50:03,460
这是我的环境指针
So here's my environment pointer.

819
00:50:03,460 --> 00:50:07,960
为了达到那个目的，我要执行这个lambda表达式In order to do that I have to evaluate this lambda expression.

820
00:50:07,960 --> 00:50:11,110
这意味着我创建了一个过程对象That means I make a procedure object.

821
00:50:11,110 --> 00:50:17,040
所以，我要在这创建一个过程对象
So I'm going to make a procedure object here.

822
00:50:17,040 --> 00:50:19,410
这个过程对象
And the procedure object has,

823
00:50:19,410 --> 00:50:21,120
由于在它被定义的地方
as the place it's defined,

824
00:50:21,120 --> 00:50:23,660
有一个全局的环境
the global environment.

825
00:50:23,660 --> 00:50:27,900
这个过程对象包括了
The procedure object contains

826
00:50:27,900 --> 00:50:31,960
以n为参数的过程的代码some code that represents a procedure of one argument n

827
00:50:31,960 --> 00:50:36,780
它返回一个不接受参数的过程来做一些事情
which returns a procedure of no arguments which does something.

828
00:50:37,810 --> 00:50:44,110
定义是一种改变环境的方法
And the define is a way of changing this environment,

829
00:50:44,110 --> 00:50:52,200
所以我把make-counter加入全局环境中
so that I now add to it a make-counter,

830
00:50:52,200 --> 00:50:55,690
这是对于特殊的东西定义的一个特殊的规则
a special rule for the special thing defined.

831
00:50:55,690 --> 00:50:58,800
但它其实是
But what that is,

832
00:50:58,800 --> 00:51:03,630
它给了我们一个指针，指向那个过程
is it gives me that pointer to that procedure.

833
00:51:03,630 --> 00:51:08,950
所以现在全局环境中也有了make-counter
So now the global environment contains make-counter as well.

834
00:51:08,950 --> 00:51:11,640
现在，我们要进行一些操作
Now, we're going to do some operations.

835
00:51:11,640 --> 00:51:14,810
我要用它来创建一些计数器
I'm going to use this to make some counters.

836
00:51:14,810 --> 00:51:16,900
我们将看到什么是计数器
We'll see what a counter is.

837
00:51:16,900 --> 00:51:23,260
所以我们定义
So let's define

838
00:51:23,260 --> 00:51:35,550
c1为一个从0开始的计数器
c1 to be a counter beginning at 0.

839
00:51:35,550 --> 00:51:39,320
根据模型，我们知道如何做这个了
Well, we know how to do this now, according to the model.

840
00:51:39,320 --> 00:51:45,200
我需要执行在全局环境中的make-counter
I have to evaluate the expression make-counter in the global environment,

841
00:51:45,200 --> 00:51:47,660
make-counter 0
make-counter of 0.

842
00:51:47,660 --> 00:51:53,320
我查找make-counter，发现它是一个过程
Well, I look up make-counter and see that it's a procedure.

843
00:51:53,320 --> 00:51:55,950
我将要应用这个过程
I'm going to have to apply that procedure.

844
00:51:55,950 --> 00:51:58,240
我应用这个过程的方式
The way I apply the procedure

845
00:51:58,240 --> 00:52:01,630
就是构建一个框架
is by constructing a frame.

846
00:52:01,630 --> 00:52:06,450
所以我构建了一个框架
So I construct a frame

847
00:52:06,450 --> 00:52:11,620
它内部有一个n的值
which has a value for n in it

848
00:52:11,620 --> 00:52:13,760
这个值是0
which is 0

849
00:52:13,760 --> 00:52:15,760
它的父环境and the parent environment

850
00:52:15,760 --> 00:52:22,820
是make-counter的定义的环境
is the one which is the environment of definition of make-counter.

851
00:52:22,820 --> 00:52:30,930
所以我已经通过将make-counter应用于0上，而创建了一个环境
So I've made an environment by applying make-counter to 0.

852
00:52:30,930 --> 00:52:33,460
现在，我需要执行make-counter的体
Now, I have to evaluate the body of make-counter,

853
00:52:33,460 --> 00:52:40,140
就是那个环境中的lambda表达式
which is this lambda expression, in that environment.

854
00:52:40,140 --> 00:52:42,590
执行这个体
Well evaluating this body,

855
00:52:42,590 --> 00:52:46,050
它是一个lambda表达式
this body is a lambda expression.

856
00:52:46,050 --> 00:52:49,390
执行一个lambda表达式，意味着创建一个过程对象
Evaluate a lambda expression means make a procedure object.

857
00:52:49,390 --> 00:52:56,380
所以我将创建一个过程对象
So I'm going to make a procedure object.

858
00:52:56,380 --> 00:52:58,290
And that procedure object has

859
00:52:58,290 --> 00:53:04,080
the environment it was defined in being that,

860
00:53:04,080 --> 00:53:07,410
where n was defined to be 0.

861
00:53:07,410 --> 00:53:09,880
And it has some code,

862
00:53:09,880 --> 00:53:13,640
which is the procedure of no arguments which does
something,

863
00:53:13,640 --> 00:53:15,280
that sets something,

864
00:53:15,280 --> 00:53:17,470

and returns n.

865
00:53:17,470 --> 00:53:19,280
And this thing

866
00:53:19,280 --> 00:53:21,920
is going to be the object,

867
00:53:21,920 --> 00:53:25,820
which in the global environment, will have the name c1.

868
00:53:25,820 --> 00:53:28,640
所以我们在这建立一个名字，c1
So we construct a name here, c1,

869
00:53:28,640 --> 00:53:35,200
并且说c1等于这个过程
and say that equals that.

870
00:53:35,200 --> 00:53:42,740
现在，再来创建另一个计数器
Now, but also make another counter,

871
00:53:42,740 --> 00:53:50,530
通过make-counter创建c2
c2 to be make-counter say,

872
00:53:50,530 --> 00:53:53,970
让它从10开始
starting with 10.

873
00:53:53,970 --> 00:53:56,530
然后我执行同样的步骤
Then I do essentially the same thing.

874
00:53:56,530 --> 00:54:00,820
我应用这个make-counter过程
I apply the make-counter procedure, which I got from here,

875
00:54:00,820 --> 00:54:05,480
建立另一个n等于10的框架
to make another frame with n being 10.

876
00:54:05,480 --> 00:54:09,840
全局环境作为它的父环境
That frame has the global environment as its parent.

877
00:54:09,840 --> 00:54:12,780
然后我构建一个过程
I then construct a procedure

878
00:54:12,780 --> 00:54:18,080
以这个框架作为它定义的环境
which has that as it's frame of definition.

879
00:54:18,080 --> 00:54:21,800
它的代码是
The code of it is

880
00:54:21,800 --> 00:54:25,540
一个不需要参数，并做了某些工作的过程
the procedure of no arguments which does something.

881
00:54:25,540 --> 00:54:28,600

And it does a set, and so on.

882
00:54:28,600 --> 00:54:31,220
然后返回n
And n comes out.

883
00:54:31,220 --> 00:54:36,710
这就是c2
And c2 is this.

884
00:54:36,710 --> 00:54:39,920
好，你们应该发现，某些东西开始变得有趣了
Well, you're already beginning to see something fairly interesting.

885
00:54:39,920 --> 00:54:42,850
这里有两个n
There are two n's here.

886
00:54:42,850 --> 00:54:45,890
它们不是同一个n
They are not one n.

887
00:54:45,890 --> 00:54:48,450
每当我调用make-counter的时候
Each time I called make-counter,

888
00:54:48,450 --> 00:54:52,340
我就创建了另一个n的实例
I made another instance of n.

889
00:54:52,340 --> 00:54:57,470
它们彼此独立，没有关联
These are distinct and separate from each other.

890
00:54:57,470 --> 00:55:01,350
现在，我们来使用一下这些计数器
Now, let's do some execution, use those counters.

891
00:55:05,620 --> 00:55:15,640
如果此时，我调用c1，会发生什么？
Well, what happens if I say, c1 at this point?

892
00:55:15,640 --> 00:55:17,560
我会在这里查找
Well, I go over here,

893
00:55:17,560 --> 00:55:20,640
发现c1是一个过程
and I say, oh yes, c1 is a procedure.

894
00:55:20,640 --> 00:55:23,160
我要不带参数地调用这个过程
I'm going to call this procedure on no arguments,

895
00:55:23,160 --> 00:55:24,960
因为它不需要参数
but it has no parameters.

896
00:55:24,960 --> 00:55:26,810
对吧？
That's right.

897
00:55:26,810 --> 00:55:27,960
它的体是什么呢？
What's its body?

898
00:55:27,960 --> 00:55:30,020
我得在这里查找，因为我没有写下来
Well, I have to look over here, because I didn't write it down.

899
00:55:30,020 --> 00:55:33,660
这个体是将n设置为n加1
It said, set n to one plus n

900
00:55:33,660 --> 00:55:36,860
并且返回n
and return n,

901
00:55:36,860 --> 00:55:38,860
就是把n增大1
increment n.

902
00:55:38,860 --> 00:55:42,620
n看起来应该是这一个
Well, the n it sees is this one.

903
00:55:42,620 --> 00:55:45,630
所以我把这个n增大1
So I increment that n.

904
00:55:45,630 --> 00:55:48,440
它变成了1
That becomes one,

905
00:55:48,440 --> 00:55:51,700
然后返回了1
and I return the value one.

906
00:55:51,700 --> 00:55:58,160
之后我调用c2
Supposing I then called c2.

907
00:55:58,160 --> 00:56:00,980
我会做什么？
Well, what do I do?

908
00:56:00,980 --> 00:56:03,330
c2是相同的过程
I say c2 is this procedure which does the same thing,

909
00:56:03,330 --> 00:56:05,330
但这个n
but here's the n.

910
00:56:05,330 --> 00:56:10,730
它变成了11
It becomes 11.

911
00:56:10,730 --> 00:56:15,760
所以返回值是11
And so I have an 11 which is the value.

912
00:56:15,760 --> 00:56:20,670
然后我们再来调用一下c1
I then can say, let's try c1 again.

913
00:56:20,670 --> 00:56:23,110
c1是这个
c1 is this,

914
00:56:23,110 --> 00:56:27,010
它是2
that's two,

915
00:56:27,010 --> 00:56:29,360
所以结果是2
so the answer is two.

916
00:56:29,360 --> 00:56:33,180
然后调用c2
And c2

917
00:56:33,180 --> 00:56:35,550
然后c2通过同样的方法，返回了12
gives me a 12 by the same method,

918
00:56:35,550 --> 00:56:37,550
它在这里进行查找
by walking down here looking at that

919
00:56:37,550 --> 00:56:41,420
发现了n，并把它加1
and saying, here's the n, I'm incrementing.

920
00:56:41,420 --> 00:56:44,850
这里就是计算对象
So what I have are computational objects.

921
00:56:44,850 --> 00:56:48,840
这里有两个计数器
There are two counters,

922
00:56:48,840 --> 00:56:55,150
每一个都有各自独立的局部状态
each with its own independent local state.

923
00:56:55,150 --> 00:56:57,450
我们再进一步
Let's talk about this a little.

924
00:56:57,450 --> 00:57:01,000
这是个奇怪的东西
This is a strange thing.

925
00:57:01,000 --> 00:57:03,980
什么是对象？
What's an object?

926
00:57:03,980 --> 00:57:07,360
这个概念并不明确
It's not at all obvious what an object is.

927
00:57:07,360 --> 00:57:10,940
我们倾向于以对象的角度思考
We like to think about objects,

928
00:57:10,940 --> 00:57:14,400
因为这样思考比较经济
because it's economical to think that way.

929
00:57:14,400 --> 00:57:18,360
这是一种智力上的经济
It's an intellectual economy.

930
00:57:18,360 --> 00:57:20,840
我是一个对象
I am an object.

931
00:57:20,840 --> 00:57:23,390
你们都是对象
You are an object.

932
00:57:23,390 --> 00:57:27,210
我们不是一样的对象
We are not the same object.

933
00:57:27,210 --> 00:57:29,920
我可以把世界分为两部分
I can divide the world into two parts,

934
00:57:29,920 --> 00:57:31,920
我和你
me and you,

935
00:57:31,920 --> 00:57:34,420
以及其他的东西
and there's other things as well,

936
00:57:34,420 --> 00:57:35,440
那么
such that

937
00:57:35,440 --> 00:57:39,680
大多数对于我的讨论
most of the things I might want to discuss about my workings

938
00:57:39,680 --> 00:57:41,240
不会影响到你
do not involve you,

939
00:57:41,240 --> 00:57:45,480
大多数对于你的讨论不会牵涉到我
and most of the things I want to discuss about your workings don't involve me.

940
00:57:45,480 --> 00:57:47,390
我有血压
I have a blood pressure,

941
00:57:47,390 --> 00:57:49,150
体温
a temperature,

942
00:57:49,150 --> 00:57:52,670
呼吸频率

a respiration rate,

943
00:57:52,670 --> 00:57:55,820
血液中有确定的血糖值
certain amount of sugar in my blood,

944
00:57:55,820 --> 00:57:59,720
数不清的，数以千计的状态变量--上百万实际上
and numerous, thousands, of state variables-- millions actually,

945
00:57:59,720 --> 00:58:00,930
我不知道具体有多少
or I don't know how many--

946
00:58:00,930 --> 00:58:04,740
以物理学观点，我拥有大量的状态变量
huge numbers of state variables in the physical sense

947
00:58:04,740 --> 00:58:08,810
如果将我视为一个粒子的话which represent the state of me as a particle,

948
00:58:08,810 --> 00:58:12,500
而你也有许许多多这样的变量
and you have gazillions of them as well.

949
00:58:12,500 --> 00:58:17,080
大多数我的变量与大多数你的变量是解耦的无关的
And most of mine are uncoupled to most of yours.

950
00:58:17,080 --> 00:58:20,310
所以可以计算我的属性
So we can compute the properties of me

951
00:58:20,310 --> 00:58:23,660
而不用太担心你的属性
without worrying too much about the properties of you.

952
00:58:23,660 --> 00:58:25,890
如果我们需要把我们两个放在一起计算
If we had to work about both of us together,

953
00:58:25,890 --> 00:58:30,340
那么我们需要考虑的状态的数量，就是你与我的状态的数量的乘积
than the number of states that we have to consider is the product of the number of states you have and the number of states I have.

954
00:58:30,340 --> 00:58:32,450
但这个方法只是一种计数
But this way it's almost a sum.

955
00:58:32,450 --> 00:58:35,900
#TBD
Now, indeed there are forces that couple us.

956
00:58:35,900 --> 00:58:38,240
我对你讲话，你的状态就变了
I'm talking to you and your state changes.

957
00:58:38,240 --> 00:58:41,420
我看着你，我的状态就变了
I'm looking at you and my state changes.

958
00:58:41,420 --> 00:58:44,200
因此，我的变量中的一小部分
Some of my state variables, a very few of them,

959
00:58:44,200 --> 00:58:46,070
与你的一些变量是耦合的
therefore, are coupled to yours.

960
00:58:46,070 --> 00:58:47,800
如果你突然大喊大叫
If you were to suddenly yell very loud,

961
00:58:47,800 --> 00:58:51,970
我的血压就会升高
my blood pressure would go up.

962
00:58:53,700 --> 00:58:57,170
将世界看作是由独立的变量
However, and it may not be always appropriate

963
00:58:57,170 --> 00:59:01,990
和独立的粒子组成的是不恰当的
to think about the world as being made out of independent states and independent particles.

964
00:59:01,990 --> 00:59:05,030
在像量子力学这样的东西里存在大量的bug
Lots of the bugs that occur in things like quantum mechanics,

965
00:59:05,030 --> 00:59:08,800
或者当我们思考像量子力学之类的东西的时候，会在我们的脑海中产生bug
or the bugs in our minds that occur when we think about things like quantum mechanics,

966
00:59:08,800 --> 00:59:10,970
由于这样的事实，
are due the fact that we are trying to think about things

967
00:59:10,970 --> 00:59:13,430
我们会竭尽全力地去将事物分解为相互独立的部分来看待
being broken up into independent pieces,

968
00:59:13,430 --> 00:59:17,910
而事实上事物的耦合程度，远远大于在表面所看到的
when in fact there's more coupling than we see on the surface,

969
00:59:17,910 --> 00:59:19,530
即便这样，我们仍像那样思考
or that we want to believe in,

970
00:59:19,530 --> 00:59:22,030
是因为我们希望高效并且有效的进行计算
because we want to compute efficiently and effectively.

971
00:59:22,030 --> 00:59:25,510
我们被培养成以那种方式进行思考
We've been trained to think that way.

972
00:59:29,540 --> 00:59:31,300
大家看
Well, let's see.

973
00:59:31,300 --> 00:59:34,740
我们如何才能知道我们是否有对象？
How would we know if we had objects at all?

974
00:59:34,740 --> 00:59:37,640
#TBD
How can we tell if we have objects?

975
00:59:37,640 --> 00:59:42,160
通过思考一些视觉误差
Consider some possible optical illusions.

976
00:59:42,160 --> 00:59:44,820
就能解答这个问题
This could be done.

977
00:59:44,820 --> 00:59:47,760
这几截粉笔不完全相同
These pieces of chalk are not appropriately identical,

978
00:59:47,760 --> 00:59:51,120
但是我觉得你看不出来他们的区别
but supposing you couldn't tell the difference of them by looking at them.

979
00:59:51,730 --> 00:59:53,320
有一种可能
Well, there's a possibility

980
00:59:53,320 --> 00:59:56,070
是这一切都是我们与镜子的游戏
that this all a game I'm playing with mirrors.

981
00:59:56,070 --> 00:59:58,790
它们真的是同一截粉笔
It's really the same piece of chalk,

982
00:59:58,790 --> 01:00:01,230
但你看到了两个
but you're seeing two of them.

983
01:00:01,230 --> 01:00:04,600
你怎么知道你看到的是一个还是两个呢？
How would you know if you're seeing one or two?

984
01:00:04,600 --> 01:00:07,220
我只知道有一种方法可以确定
Well, there's only one way I know.

985
01:00:07,220 --> 01:00:09,320
抓起其中一个并且改变它
You grab one of them and change it

986
01:00:09,320 --> 01:00:11,590
然后看看另一个有没有跟着变化
and see if the other one changed.

987
01:00:13,760 --> 01:00:15,340
而另一个没有变化
And it didn't, so there's two of them.

988
01:00:15,340 --> 01:00:17,340
所以这里有两截粉笔
so there's two of them.

989
01:00:19,250 --> 01:00:20,590
另一方面
And, on the other hand,

990
01:00:20,590 --> 01:00:22,440
事物还有一些其他的类似的纠结属性
there is some other screwy properties of things like that.

991
01:00:22,440 --> 01:00:24,840
例如，我们怎么才知道某个东西是否改变了呢？
Like, how do we know if something changed?

992
01:00:24,840 --> 01:00:28,650
我们需要在它改变之前和之后进行观察We have to look at it before and after the change.

993
01:00:28,650 --> 01:00:30,020
改变就是赋值
The change is an assignment,

994
01:00:30,020 --> 01:00:32,020
它是时间中的一个时刻
it's a moment in time.

995
01:00:32,020 --> 01:00:36,250
但是那意味着我们需要知道，我们看到的是否是同一个
But that means we have to know it was the same one that we're looking at.

996
01:00:36,250 --> 01:00:38,840
所以一些东西非常奇怪
So some very strange, and unusual, and obscure,

997
01:00:38,840 --> 01:00:40,840
不同寻常并且晦涩难懂
and obscure, and -- I don't understand

998
01:00:40,840 --> 01:00:44,450
并且我不理解与赋值
the problems associated with assignment,

999
01:00:44,450 --> 01:00:47,120
变化以及对象有关的问题
and change, and objects.

1000
01:00:47,120 --> 01:00:50,100
这些东西可能变得非常非常糟糕
These could get very, very bad.

1001
01:00:51,060 --> 01:00:52,880
例如
For example,

1002
01:00:52,880 --> 01:00:55,960
我，是一个特定的人
here I am, I am a particular person,

1003
01:00:55,960 --> 01:00:57,960
一个特定的对象
a particular object.

1004
01:00:57,960 --> 01:01:00,490
现在，我可以拿出小刀
Now, I can take out my knife,

1005
01:01:00,490 --> 01:01:01,890
修剪我的指甲
and cut my fingernail.

1006
01:01:01,890 --> 01:01:05,690
一片指甲掉在了桌子上
A piece of my fingernail has fallen off onto the table.

1007
01:01:05,690 --> 01:01:10,710
我相信自己和一秒钟之前的自己，是同一个人I believe I am the same person I was a second ago,

1008
01:01:10,710 --> 01:01:14,170
但在物理上并不是分毫不差
but I'm not physically the same in the slightest.

1009
01:01:14,170 --> 01:01:15,430
我已经改变了
I have changed.

1010
01:01:15,430 --> 01:01:17,430
为什么我还是同一个人呢？
Why am I the same?

1011
01:01:17,850 --> 01:01:20,770
什么能认定我的身份呢？
What is the identity of me?

1012
01:01:20,770 --> 01:01:24,730
我不知道
I don't know.

1013
01:01:24,730 --> 01:01:29,320
除非我有某种身份证明
Except for the fact that I have some sort of identity.

1014
01:01:29,320 --> 01:01:33,400
我觉得，由于引入赋值和对象
And so, I think by introducing assignment and objects,

1015
01:01:33,400 --> 01:01:38,380
我们不得不去面对这种
we have opened ourselves up to all the horrible questions of philosophy

1016
01:01:38,380 --> 01:01:43,040
困扰了哲学家们上千年的哲学问题
that have been plaguing philosophers for some thousands of years about this sort of thing.

1017
01:01:43,040 --> 01:01:45,580
这也是相比之下，数学清晰得多的原因
It's why mathematics is a lot cleaner.

1018
01:01:45,580 --> 01:01:52,240
我看看来看看动作和身份认证
Let's look at the best things I know to say about actions and identity.

1019
01:01:52,240 --> 01:01:55,600
动作a，对于对于某个对象x有影响
We say that an action,
a, had an effect on an object, x,

1020
01:01:55,600 --> 01:01:56,890
换句话说
or equivalently,

1021
01:01:56,890 --> 01:01:58,680
x被a改变
that x was changed by a,

1022
01:01:58,680 --> 01:02:01,740
如果某个属性p，在a作用于x之前为真
if some property, p, which was true of x before a,

1023
01:02:01,740 --> 01:02:04,800
在a作用于x之后为假
became false of x after a.

1024
01:02:04,800 --> 01:02:06,310
我们测试一下
Let's test.

1025
01:02:06,310 --> 01:02:10,640
这也意味着，我必须#TBD
It still means I have to have the x before and after.

1026
01:02:10,640 --> 01:02:12,790
或者，换句话说
Or, the other way of saying this is,

1027
01:02:12,790 --> 01:02:16,070
我们说两个对象x和y是同一个东西
we say that two objects x and y are the same for any action

1028
01:02:16,070 --> 01:02:19,350
是由于任何动作对x的影响将对y有同样的影响
which has an effect on x has the same effect on y

1029
01:02:19,350 --> 01:02:21,390
然而，就像我说的
However, objects are very useful,

1030
01:02:21,390 --> 01:02:24,340
对象在智力经济上是非常有用的
as I said, for intellectual economy.

1031
01:02:24,340 --> 01:02:27,910
对于它们来说非常有用的东西之一
One of the things that's incredibly useful about them,

1032
01:02:27,910 --> 01:02:30,480
就是对于这个世界
is that the world is,

1033
01:02:30,480 --> 01:02:34,860
我们习惯于把它认为是由带有独立状态的独立对象所构成的
made out of independent objects with independent local state.

1034
01:02:34,860 --> 01:02:39,330
我们喜欢以那样的的方式来思考，虽然那并不完全正确
We like to think that way, although it isn't completely true.

1035
01:02:39,330 --> 01:02:42,030
当我们要写一个非常复杂的程序
When we want to make very complicated programs

1036
01:02:42,030 --> 01:02:43,670
来应对这样一个世界时
that deal with such a world,

1037
01:02:43,670 --> 01:02:46,680
如果我们希望这些程序可以被我们理解
if we want those programs to be understandable by us

1038
01:02:46,680 --> 01:02:48,530
并且也是可修改的
and also to be changeable,

1039
01:02:48,530 --> 01:02:51,280
那么如果世界改变了，我们只需要稍微改动一下程序
so that if we change the world we change the program only a little bit,

1040
01:02:51,280 --> 01:02:53,700
#TBD
then we want there to be connections, isomorphism,

1041
01:02:53,700 --> 01:02:58,380
#TBD
between the objects in the world and the objects in our mental model.

1042
01:02:58,380 --> 01:03:02,000
世界的模块化，使我们的程序得以模块化
The modularity of the world can give us the modularity in our programming.

1043
01:03:02,000 --> 01:03:05,680
所以我们发明了面向对象编程
So we invent things
called object-oriented programming and things like that

1044
01:03:05,680 --> 01:03:09,500
使我们获得那样的力量
to provide us with that power.

1045
01:03:09,500 --> 01:03:11,190
但是，它甚至更简单
But it's even easier.

1046
01:03:11,190 --> 01:03:13,280
让我们玩一个小游戏
Let's play a little game.

1047
01:03:13,280 --> 01:03:16,770
通过这个游戏给你展示一个例子
I want to play a little game, show you an even easier example of where

1048
01:03:16,770 --> 01:03:22,570
赋值表达式可以增强模块化的例子
modularity can be enhanced by using an assignment statement, judiciously.

1049
01:03:22,570 --> 01:03:25,350
有一件我想让你深刻记住的事
One thing I want to enforce and impress on you,

1050
01:03:25,350 --> 01:03:30,000
就是不要像在FORTRAN，Basic或者Pascal里一样使用赋值语句
is don't use assignment statements the way you use it in FORTRAN or Basic or something or Pascal,

1051
01:03:30,000 --> 01:03:32,470
你不那样做，也能达到目的
to do the things you don't have to do with it.

1052
01:03:33,920 --> 01:03:36,840
这不是思考大多数事情的正确方式
It's not the right way to think for most things.

1053
01:03:36,840 --> 01:03:38,490
有些时候它是必要的
Sometimes it's essential,

1054
01:03:38,490 --> 01:03:39,690
或者可能是必要的
or maybe it's essential.

1055
01:03:39,690 --> 01:03:42,010
我们一会更深入地去研究
We'll see more about that too.

1056
01:03:42,010 --> 01:03:44,730
我要给你展示一个有趣的游戏
OK, let me show you a fun game here.

1057
01:03:47,330 --> 01:03:49,520
从前有一个数学家
There was mathematician

1058
01:03:49,520 --> 01:03:54,260
叫做Cesaro
by the name of Cesaro--or Cesaro, Cesaro I suppose it is--

1059
01:03:54,260 --> 01:03:58,140
他发现了一个很绝妙的计算pi的方法
who figured out a clever way of computing pi.

1060
01:03:58,140 --> 01:04:05,020
如果我有两个随机数
It turns out that if I take to random numbers

1061
01:04:05,020 --> 01:04:07,420
两个随机的整数
two integers at random,

1062
01:04:07,420 --> 01:04:10,640
计算它们的最大公约数
and compute the greatest common divisor,

1063
01:04:10,640 --> 01:04:13,660
结果可能是1，或者不是1
their greatest common divisor is either one or it's not one.

1064
01:04:13,660 --> 01:04:17,820
如果是1，它们没有公约数
If it's one, then they have no common divisors.

1065
01:04:17,820 --> 01:04:20,680
如果它们的最大公约数是1
If their greatest common divisor is one--

1066
01:04:20,680 --> 01:04:23,090
这两个随机数
the probability that two random numbers,

1067
01:04:23,090 --> 01:04:26,580
最大公约数为1的，两个随机生成的数
two numbers chosen at random, has as greatest common divisor one

1068
01:04:26,580 --> 01:04:29,110
与pi有关系
is related to pi.

1069
01:04:29,110 --> 01:04:31,110
事实上
In fact--

1070
01:04:31,110 --> 01:04:32,760
是的，这很奇怪
yes, it's very strange--

1071
01:04:32,760 --> 01:04:39,270
当然有其他计算pi的方法，像#TBD之类的的方法
of course there are other ways of computing pi, like dropping pins on flags, and things like that, and sort of the same kind of thing.

1072
01:04:39,270 --> 01:04:51,520
两个随机生成的n1和n2的最大公约数
So the probability of that the GCD of number one and number two, two random numbers chosen,

1073
01:04:51,520 --> 01:04:54,820
是6/pi^2
is 6 over pi squared.

1074
01:04:54,820 --> 01:04:56,970
我不准备证明这个
I'm not going to try to prove that.

1075
01:04:56,970 --> 01:05:00,770
事实上这不难，并且有些有趣
It's actually not too hard and sort of fun.

1076
01:05:00,770 --> 01:05:03,300
我们为什么会做出这样的推断呢？
How would we estimate such probability?

1077
01:05:03,300 --> 01:05:07,070
我们进行可能性推断的方式
Well, the way we do that,

1078
01:05:07,070 --> 01:05:09,070
是做大量的实验
is by doing lots of experiments,

1079
01:05:09,070 --> 01:05:12,010
去计算成功的试验
and then computing the ratios of the ones that come out one way

1080
01:05:12,010 --> 01:05:15,520
与试验总次数的比率
to the total number of experiments we do.

1081
01:05:15,520 --> 01:05:17,840
这种方法叫做蒙特卡洛方法
It's called Monte Carlo,

1082
01:05:17,840 --> 01:05:22,380
在其他的例如有巨量的变量的地方--
and it's useful in other contexts for doing things like integrals where you have lots and lots of variables--

1083
01:05:22,380 --> 01:05:26,080
#TBD是非常有用的
the space which is limiting the dimensions you are doing you integral in.

1084
01:05:26,080 --> 01:05:29,400
回到这里
But going back to here,

1085
01:05:29,400 --> 01:05:33,560
我们来看看这张幻灯片
Let's look at this slide,

1086
01:05:33,560 --> 01:05:37,190
我们可以用Cesaro的方法来推测pi的值
We can use Cesaro's method for estimating pi

1087
01:05:37,190 --> 01:05:43,180
#TBD
with n trials by taking the square root of six over a Monte Carlo,

1088
01:05:43,180 --> 01:05:48,670
#TBD
a Monte Carlo experiment with n trials,

1089
01:05:48,670 --> 01:05:51,090
使用了Cesaro试验
using Cesaro's experiment,

1090
01:05:51,090 --> 01:05:58,700

where Cesaro's experiment is the test of whether the GCD of two random numbers--

1091
01:05:58,700 --> 01:06:01,782
你可以看到，我已经在这里进行了一些赋值
And you can see that I've already got some assignments in here,

1092
01:06:01,780 --> 01:06:03,911
就像我写的这样
just by what I wrote.

1093
01:06:03,910 --> 01:06:07,497
这个在括号中的rand
The fact that this word rand, in parentheses,

1094
01:06:07,490 --> 01:06:09,097
这个过程调用
therefore, that procedure call,

1095
01:06:09,090 --> 01:06:11,395
生成了一个其他的值
yields a different value than this one,

1096
01:06:11,390 --> 01:06:14,408
至少是我写的这样所假设的at least that's what I'm assuming by writing this this way,

1097
01:06:14,400 --> 01:06:17,920
这表明这不是一个函数
indicates that this is not a function,

1098
01:06:17,920 --> 01:06:22,048
在变化时，里面会有一个内部状态
that there's internal state in it which is changing.

1099
01:06:22,040 --> 01:06:28,644
如果两个随机数的最大公约数等于1
If the GCD of those two random numbers is equal to one,

1100
01:06:28,644 --> 01:06:30,640
这就是一次实验#TBD
that's the experiment.

1101
01:06:31,324 --> 01:06:36,240
那么我有了一个用来推算pi的值的实验方法
So here I have an experimental method for estimating the value of pi.

1102
01:06:36,240 --> 01:06:40,022
我可以简单地将这个问题分为两个部分
Where, I can easily divide this problem into two parts.

1103
01:06:40,020 --> 01:06:44,897
一部分是Cesaro的特殊的蒙特卡洛实验，就像你刚才看到那个
One is the specific Monte Carlo experiment of Cesaro, which you just saw,

1104
01:06:44,890 --> 01:06:49,115
另一部分就是进行蒙特卡洛实验的常规技巧
and the other is the general technique of doing Monte Carlo experiments.

1105
01:06:49,110 --> 01:06:50,893
就是这个
And that's what this is.

1106
01:06:50,890 --> 01:06:55,675
如果我想进行n次蒙特卡洛实验
If I want to do Monte Carlo experiments with n trials,

1107
01:06:55,670 --> 01:06:59,142
一个确定次数的实验，和一个特定的实验#TBD
a certain number of trials, and a particular experiment,

1108
01:06:59,140 --> 01:07:00,693
我进行实验的方法就是
the way I do that

1109
01:07:00,690 --> 01:07:03,244
构建一个迭代过程
is I make a little iterative procedure

1110
01:07:03,240 --> 01:07:08,133
这个过程有两个变量，分别是试验的剩余次数，和通过次数
which has variable the number of trials remaining and the number trials that have been passed,

1111
01:07:08,133 --> 01:07:10,130
就是结果为真的次数
that I've gotten true.

1112
01:07:10,130 --> 01:07:12,213
如果剩余次数为0
And if the number remaining is 0,

1113
01:07:12,210 --> 01:07:15,888
结果就是通过的次数除以总次数
then the answer is the number past divided by this whole number of trials,

1114
01:07:15,880 --> 01:07:18,866
即对可能性的估计
was the estimate of the probability.

1115
01:07:18,860 --> 01:07:20,044
如果剩余次数不是0
And if it's not,

1116
01:07:20,040 --> 01:07:22,080
如果还有试验要做
if I have more trials to do,

1117
01:07:22,080 --> 01:07:24,008
那么接下来我们就进行一次试验
then let's do one. We do an experiment.

1118
01:07:24,000 --> 01:07:27,302
我们调用一次没有参数的实验的过程
We call the procedure which is experiment on no arguments.

1119
01:07:27,300 --> 01:07:29,040
我们进行这个试验
We do the experiment

1120
01:07:29,040 --> 01:07:30,822
如果实验结果为真
and then, if that turned out to be true, 

1121
01:07:30,820 --> 01:07:32,626
我们继续循环
we go around the loop

1122
01:07:32,620 --> 01:07:35,706
将试验通过次数加1
decrementing the number of experiments we have to do by one

1123
01:07:35,700 --> 01:07:38,382
试验剩余次数减1and incrementing the number that were passed.

1124
01:07:38,382 --> 01:07:40,380
如果实验的结果为假
And if the experiment was false,

1125
01:07:40,380 --> 01:07:42,253
我们继续循环
we just go around the loop

1126
01:07:42,250 --> 01:07:44,382
剩余试验次数减1
decrementing the number of experiments remaining

1127
01:07:44,380 --> 01:07:47,742
试验通过次数保持不变
and keeping the number passed the same.

1128
01:07:48,600 --> 01:07:55,231
我们以trial为剩余次数，0为通过次数开始迭代
We start this up iterating over the total number of trials with 0 experiments past.

1129
01:07:55,230 --> 01:07:57,524
多么简洁的小程序啊
A very elegant little program.

1130
01:07:57,520 --> 01:08:00,555
我不一定非要进行Cesaro的实验
And I don't have to just do this with Cesaro's experiment,

1131
01:08:00,550 --> 01:08:03,213
它可以用来进行很多种蒙特卡洛实验
it could be lots of Monte Carlo experiments I might do.

1132
01:08:03,210 --> 01:08:07,302
当然，它依赖于某种随机数生成器的存在
Of course, this depends upon the existence of some sort of random number generator.

1133
01:08:07,300 --> 01:08:13,248
随机数生成器通常是像这种的东西
And random number generators generally look something like this.

1134
01:08:13,240 --> 01:08:17,288
这是一个随机数生成器--
There is a random number generator-- 

1135
01:08:17,280 --> 01:08:25,480
实际上它就是一个，进行类似于计数操作的过程is in fact a procedure which is going to do something just like the counter.

1136
01:08:25,480 --> 01:08:28,151
它会把x的值更新为
It's going to update an x

1137
01:08:28,150 --> 01:08:32,137
将某个函数应用于x的结果
to the result of applying some function to x,

1138
01:08:32,130 --> 01:08:35,324
这个函数是
where this function

1139
01:08:35,320 --> 01:08:41,320
你可能在Kunth写的关于编程细节的书中找到的某种复杂的函数
is some screwy kind of function that you might find out in Knuth's books on the details of programming.

1140
01:08:41,320 --> 01:08:45,751
他写了这些充满了编程细节的绝妙的书
He does these wonderful books that are full of the details of programming,

1141
01:08:45,750 --> 01:08:48,631
因为我记不住随机数生成器该怎样写
because I can't remember how to make a random number generator,

1142
01:08:48,630 --> 01:08:51,462
但我可以在书里找出一个来用
but I can look it up there, and I can find out.

1143
01:08:51,460 --> 01:08:54,084
最后，我返回了x的值
And then, eventually, I return the value of x

1144
01:08:54,080 --> 01:08:58,031
也就是随机数生成器的内部状态变量
which is the state variable internal to the random number generator.

1145
01:08:58,030 --> 01:09:01,204
这个状态变量以某种方式被初始化
That state variable is initialized somehow,

1146
01:09:01,204 --> 01:09:03,200
从而获得了一个值
and has a value.

1147
01:09:03,200 --> 01:09:10,217
这个过程被定义在那个变量被约束的上下文中
And this procedure is defined in the context where that variable

1148
01:09:10,210 --> 01:09:15,666
所以你在这看到的，是一个隐藏的本地状态
So this is a hidden piece of local state that you see here.

1149
01:09:15,660 --> 01:09:21,355
这个过程定义在那个上下文中
And this procedure is defined in that context.

1150
01:09:21,350 --> 01:09:24,697
现在，那就是一个非常容易的事情了
Now, that's a very simple thing to do.

1151
01:09:24,690 --> 01:09:25,995
并且它非常的好用
And it's very nice.

1152
01:09:25,990 --> 01:09:28,937
设想，我不想用赋值
Supposing, I didn't want to use assignments.

1153
01:09:28,930 --> 01:09:32,564
假设我想写一个不带赋值的程序
Supposing, I wanted to write this program without assignments.

1154
01:09:32,560 --> 01:09:35,311
我将遇到什么困难？
What problems would I have?

1155
01:09:35,310 --> 01:09:37,666
让我们来看看
Well, let's see.

1156
01:09:37,660 --> 01:09:41,880
我要用一下头顶上的投影仪了
I'd like to use the overhead machine here,

1157
01:09:41,880 --> 01:09:43,226
多谢
thank you.

1158
01:09:43,220 --> 01:09:47,662
首先，我们来整体看一下。这是一个很庞大的东西
First of all, let's look at the whole thing. It's a big story.

1159
01:09:47,662 --> 01:09:50,960
它告诉你有某些东西出了问题
Unfortunately, which tells you there is something wrong.

1160
01:09:50,960 --> 01:09:53,324

It's at least that big,

1161
01:09:53,320 --> 01:09:56,475
#TBD
and it's monolithic.

1162
01:09:56,470 --> 01:10:00,120
你不需要现在去理解或看这里的文本
You don't have to understand or look at the text there right now

1163
01:10:00,120 --> 01:10:01,920
#TBD
to see that it's monolithic.

1164
01:10:01,920 --> 01:10:04,897
它不是Cesaro的实验#TBD
It isn't a thing which is Cesaro's experiment.

1165
01:10:04,890 --> 01:10:09,675
它不是从蒙特卡洛过程中抽取出来的
It's not pulled out from the Monte Carlo process.

1166
01:10:09,670 --> 01:10:13,853
它不是分离的，让我们来看看为什么
It's not separated. Let's look why.

