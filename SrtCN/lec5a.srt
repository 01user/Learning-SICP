1
00:00:00,000 --> 00:00:01,980
[MUSIC PLAYING]
[音乐]

2
00:00:11,500 --> 00:00:15,790
赋值、状态和副作用
Assignment, State, and Side-effects

3
00:00:15,790 --> 00:00:22,000
教授：到目前为止 我们编写程序
PROFESSOR: Well, so far we've invented enough programming

4
00:00:22,000 --> 00:00:26,780
做了一些非常复杂事情
to do some very complicated things.

5
00:00:26,780 --> 00:00:29,660
并且关于编程你们确实已经学到了很多
And you surely learned a lot about programming at this point.

6
00:00:29,660 --> 00:00:31,860
你们已经学习了几乎所有的
You've learned almost all the most important tricks

7
00:00:31,860 --> 00:00:36,200
那些拥有大量经验的人才能领悟的技巧
that usually don't get taught to people until they have had a lot of experience.

8
00:00:36,200 --> 00:00:40,750
例如，数据导向编程是一个主要的技巧
For example, data directed programming is a major trick,

9
00:00:40,750 --> 00:00:43,680
昨天你们也看到了一种解释型语言
and yesterday you also saw an interpreted language.

10
00:00:43,680 --> 00:00:48,460
我们所做的这一切
We did this all in a computer language,

11
00:00:48,460 --> 00:00:49,800
目前来讲
at this point,

12
00:00:49,800 --> 00:00:53,180
都是在一种没有赋值语句的计算机语言中完成的
where there was no assignment statement.

13
00:00:53,180 --> 00:00:55,860
想必 对于你们中已经见过
And presumably, for those of you who've

14
00:00:55,860 --> 00:00:58,320
Basic或者Pascal或者其他什么语言的人来说
seen your Basic or Pascal or whatever,

15
00:00:58,320 --> 00:01:01,340
也许，赋值语句被认为是最重要的东西
that's usually considered the most important thing.

16
00:01:01,340 --> 00:01:03,820
今天我们将要做一些糟糕的事情
Well today, we're going to do something horrible.

17
00:01:03,820 --> 00:01:06,300
我们要把赋值语句加进来
We're going to add an assignment statement.

18
00:01:06,300 --> 00:01:09,140
既然在没有赋值语句的时候，我们都可以很好地完成工作
And since we can do all these wonderful things without it,

19
00:01:09,140 --> 00:01:10,500
为什么我们还要把它加进来呢？
why should we add it?

20
00:01:10,500 --> 00:01:12,540
我们需要认识到一件重要的事情
 An important thing to understand is

21
00:01:12,540 --> 00:01:14,020
首先，我们要
that today we're going to

22
00:01:14,020 --> 00:01:16,020
定下一个原则
first of all, have a rule,

23
00:01:16,020 --> 00:01:17,930
而我们将一直遵守这个规则
which is going to always be obeyed,

24
00:01:17,930 --> 00:01:21,140
我们为语言引入新的特性的唯一原因
which is the only reason we ever add a feature to our language

25
00:01:21,140 --> 00:01:23,140
是因为有一个好的理由
is because there is a good reason.

26
00:01:23,140 --> 00:01:27,280
这个好理由就是能力
And the good reason is going to boil down to the ability,

27
00:01:27,280 --> 00:01:28,890
现在你获得了
you now get an ability

28
00:01:28,890 --> 00:01:31,510
把问题分解为不同的小部分
to break a problem into pieces that are different sets of pieces

29
00:01:31,510 --> 00:01:34,270
在过去你可能在不使用这种能力的情况下分解问题
then you could have broken it down without that,

30
00:01:34,270 --> 00:01:37,360
从而领悟解耦的另一种含义
give you another means of decomposition.

31
00:01:37,360 --> 00:01:39,450
我们这就开始
However, let's just start.

32
00:01:39,450 --> 00:01:41,880
我们从回顾我们的
Let me quick begin by reviewing

33
00:01:41,880 --> 00:01:47,590
现在已经有的这种语言出发
the kind of language that we have now.

34
00:01:47,590 --> 00:01:50,850
我们之前写的是所谓的函数式程序
We've been writing what's called functional programs.

35
00:01:50,850 --> 00:01:52,790
函数式程序
And functional programs

36
00:01:52,790 --> 00:01:58,030
是一种对数学真理的编码
are a kind of encoding of mathematical truths.

37
00:01:58,030 --> 00:02:00,510
例如，当我们看到
For example, when we look at

38
00:02:00,510 --> 00:02:04,570
像幻灯片上这样阶乘过程时
the factorial procedure that you see on the slide here,

39
00:02:04,570 --> 00:02:06,770
基本上是两个子句
it's basically two clauses.

40
00:02:06,770 --> 00:02:08,640
如果n是1，则结果是1
If n is one, the result is one,

41
00:02:08,640 --> 00:02:11,200
否则返回n乘以n-1的阶乘
otherwise n times factorial n minus one.

42
00:02:11,200 --> 00:02:12,560
这是n的阶乘
That's factorial of n.

43
00:02:12,560 --> 00:02:14,560
它就是n的阶乘
Well, that is factorial of n.

44
00:02:14,560 --> 00:02:16,870
如果用一些其他的
And written down in some other obscure notation

45
00:02:16,870 --> 00:02:20,910
那些你在微积分课堂上学到的晦涩的符号来写
that you might have learned in calculus classes,

46
00:02:20,910 --> 00:02:22,110
以数学上的逻辑来写
mathematical logic,

47
00:02:22,110 --> 00:02:26,530
如果n等于1
what you see there is if n equals one,

48
00:02:26,530 --> 00:02:29,900
那么n的阶乘结果是1，否则，
for the result of n factorial is one, otherwise,

49
00:02:29,900 --> 00:02:32,560
如果n大于1，则n的阶乘就是n乘以n-1的阶乘
greater than one, n factorial is n times n minus one factorial.

50
00:02:32,560 --> 00:02:34,560
#TBD
True statements,

51
00:02:34,560 --> 00:02:36,700
这就是我们一直以来用的那种语言
that's the kind of language we've been using.

52
00:02:36,700 --> 00:02:39,230
#TBD
And whenever we have true statements of that sort,

53
00:02:39,230 --> 00:02:46,940
有一种理解它们是如何工作的方法
there is a kind of, a way of understanding how they work

54
00:02:46,940 --> 00:02:51,120
就是这些过程可以#TBD
which is that such processes can be involved by substitution.

55
00:02:51,120 --> 00:02:54,140
来看第二张幻灯片
And so we see on the second slide here,

56
00:02:54,140 --> 00:03:00,040
我们理解执行的过程
that the way we understand the execution implied

57
00:03:00,040 --> 00:03:03,500
隐含在表达式的顺序中
by those statements in arranged in that order,

58
00:03:03,500 --> 00:03:11,380
就是你在过程体中连续地将形式参数，代换为实际参数的顺序
is that you do successive substitutions of arguments for formal parameters in the body of a procedure.

59
00:03:11,380 --> 00:03:14,610
这是基本上是一系列的等价代换
This is basically a sequence of equalities.

60
00:03:14,610 --> 00:03:17,250
4的阶乘是4乘以3的阶乘
Factorial four is four times factorial three.

61
00:03:17,250 --> 00:03:20,050
也就是4乘以3乘以2的阶乘
That is four times three times factorial of two

62
00:03:20,050 --> 00:03:21,010
以此类推
and so on.

63
00:03:21,010 --> 00:03:24,480
#TBD
We're always preserving truth.

64
00:03:24,480 --> 00:03:28,840
尽管我们正在讨论#TBD
Even though we're talking about true statements,

65
00:03:28,840 --> 00:03:31,960
这里会有超过一个#TBD
there might be more than one organization of these true statements

66
00:03:31,960 --> 00:03:35,560
来描述一个特定的函数的计算
to describe the computation of a particular function,

67
00:03:35,560 --> 00:03:38,420
这个特定的函数的值的计算
the computation of the value of a particular function.

68
00:03:38,420 --> 00:03:41,180
所以，让我来看下一个例子
So, for example, looking at the next one here.

69
00:03:41,180 --> 00:03:49,020
这有一个计算m与n的和的办法
Here is a way of looking at the sum of n and m.

70
00:03:49,020 --> 00:03:52,360
我们使用一个递归的过程来完成这个任务
And we did this one by a recursive process.

71
00:03:52,360 --> 00:03:58,640
它就是sum的增加，及n与m的减少
It's the increment of the sum of the decrement of n and m.

72
00:03:58,640 --> 00:04:05,620
当然，这里就是一些数学的逻辑，解释了这个方法
And, of course, there is some piece of mathematical logic here that describes that.

73
00:04:05,620 --> 00:04:10,820
就是sum的增加以及n和m的减少
It's the increment of the sum of the decrement of n and m,

74
00:04:10,820 --> 00:04:12,820
跟之前那个一样
just like that.

75
00:04:12,820 --> 00:04:17,040
所以这儿并没有什么特殊的魔法
So there's nothing particularly magic about that.

76
00:04:17,040 --> 00:04:20,010
当然，如果我们可以再来看一个相同的迭代过程
And, of course, if we can also look at an iterative process for the same,

77
00:04:20,010 --> 00:04:24,920
一个对于同样的函数进行逐步迭代的过程的程序
a program that evolves an iterative process, for the same function.

78
00:04:24,920 --> 00:04:28,650
这两个程序将得到同样的结果
These are two things that compute the same answer.

79
00:04:28,650 --> 00:04:35,530
我们就可以认为这两个程序在数学上是等效的
And we have equivalent mathematical truths that are arranged there.

80
00:04:35,530 --> 00:04:40,120
#TBD
And just the way you arrange those truths determine the particular process.

81
00:04:40,120 --> 00:04:43,810
#TBD
In the way choose and arrange them determines the process that's evolved.

82
00:04:43,810 --> 00:04:48,600
因此我们有讨论两个函数被计算的灵活性
So we have the flexibility of talking about both the function to be computed,

83
00:04:48,600 --> 00:04:50,600
#TBD
and the method by which it's computed.

84
00:04:50,600 --> 00:04:52,600
#TBD
So it's not clear we need more.

85
00:04:52,600 --> 00:04:55,500
然而，今天我要来讲这个糟糕的东西
However, today I'm going to this awful thing.

86
00:04:55,500 --> 00:04:58,540
我要给大家介绍赋值操作
I'm going to introduce this assignment operation.

87
00:04:58,540 --> 00:05:01,140
这是什么？
Now, what is this?

88
00:05:02,410 --> 00:05:09,220
首先，在编程语言中有另一种语句
Well, first of all, there is going to be another kind of kind of statement, if you will,

89
00:05:09,220 --> 00:05:12,040
这种语句叫做SET！
in a programming language called Set!

90
00:05:12,040 --> 00:05:18,100
它可以用来进行赋值，我在后面加上一个感叹号
Things that do things like assignment, I'm going to put exclamation points after.

91
00:05:18,100 --> 00:05:20,960
我马上就讲这个感叹号是什么意思
We'll talk about what that means in a second.

92
00:05:20,960 --> 00:05:23,010
这个感叹号，与问号类似
The exclamation point, again like question mark,

93
00:05:23,010 --> 00:05:25,880
是我们给名字随意加的符号
is an arbitrary thing we attach to the symbol which is the name,

94
00:05:25,880 --> 00:05:27,880
它对于系统来说没有意义
has no significance to the system.

95
00:05:27,880 --> 00:05:30,210
它唯一的意义就是告诉我们
The only significance is to me and you

96
00:05:30,210 --> 00:05:34,870
注意这里是某种赋值
to alert you that this is an assignment of some sort.

97
00:05:35,520 --> 00:05:38,220
但是我们要给某个变量
But we're going to set a variable

98
00:05:38,220 --> 00:05:41,600
赋一个值
to a value.

99
00:05:43,600 --> 00:05:45,130
这意味着
And what that's going to mean

100
00:05:45,130 --> 00:05:48,400
在某个时间点发生了一些事情
is that there is a time at which something happens.

101
00:05:48,400 --> 00:05:49,860
这是一个时间点
Here's a time.

102
00:05:49,860 --> 00:05:52,450
如果时间以这个方向流动
If I have time going this way,

103
00:05:52,450 --> 00:05:54,820
#TBD
it's a time access.

104
00:05:54,820 --> 00:05:58,170
时间在纸面上由上到下地流逝
Time progresses by walking down the page.

105
00:05:58,170 --> 00:06:00,920
赋值是第一个
Then an assignment is the first thing we have

106
00:06:00,920 --> 00:06:05,580
使过去和未来之间产生差别的事物
that produces the difference between a before and an after.

107
00:06:05,580 --> 00:06:08,950
我们之前写的所有程序
All the other programs that we've written,

108
00:06:08,950 --> 00:06:10,680
都不包含赋值
that have no assignments in them,

109
00:06:10,680 --> 00:06:13,760
这些程序以怎样的顺序进行执行都没关系
the order in which they were evaluated didn't matter.

110
00:06:13,760 --> 00:06:15,960
但是赋值比较特殊
But assignment is special,

111
00:06:15,960 --> 00:06:17,960
它使时间中产生了一个时间点
it produces a moment in time.

112
00:06:17,960 --> 00:06:25,340
因此在set!出现之前和之后中间有一个时间点，
So there is a moment before the set occurs and after,

113
00:06:27,340 --> 00:06:33,080
使得在这个时间点之后
such that after this moment in time,

114
00:06:33,080 --> 00:06:45,620
变量有了一个值，value 
the variable has the value, value.

115
00:06:48,100 --> 00:06:52,050
与这个变量之前的值无关
Independent of what value it had before,

116
00:06:52,050 --> 00:06:56,500
set!改变了它的值
set! changes the value of the variable.

117
00:06:56,500 --> 00:06:58,750
在此之前
Until this moment,

118
00:06:58,750 --> 00:07:02,160
我们都没遇到过发生这样改变的情况
we had nothing that changed.

119
00:07:02,160 --> 00:07:04,320
举例来说
So, for example,

120
00:07:04,320 --> 00:07:06,230
我们可以想到的一件事是
one of the things we can think of

121
00:07:06,230 --> 00:07:09,420
我们写的一些过程比如阶乘的程序
is that the procedures we write for something like factorial

122
00:07:09,420 --> 00:07:13,170
事实上与数学中的阶乘函数完全相同
are in fact pretty much identical to the function factorial.

123
00:07:13,170 --> 00:07:16,730
4的阶乘，如果我写fact4
Factorial of four, if I write fact4,

124
00:07:16,730 --> 00:07:19,360
它将独立于它的上下文
independent of what context it's in,

125
00:07:19,360 --> 00:07:21,290
也独立于我写几遍
and independent of how many times I write it,

126
00:07:21,290 --> 00:07:23,290
我总能得到同样的结果
I always get the same answer.

127
00:07:23,290 --> 00:07:24,610
结果永远是24
It's always 24.

128
00:07:24,610 --> 00:07:29,710
它是参数到到结果的唯一映射
It's a unique map from the argument to the answer.

129
00:07:29,710 --> 00:07:33,020
迄今为止，我们之前写的所有程序都是这样的
And all the programs we've written so far are like that.

130
00:07:33,020 --> 00:07:36,340
然而，当我赋值的时候，一切就不同了
However, once I have assignment, that isn't true.

131
00:07:36,340 --> 00:07:38,340
举个例子
So, for example,

132
00:07:38,340 --> 00:07:49,240
如果我将count定义为1
if I were to define count to be one.

133
00:07:49,240 --> 00:07:54,010
然后定义一个过程
And then I'm going to define also a procedure,

134
00:07:54,010 --> 00:07:59,210
名为demo的简单过程
a simple procedure called demo,

135
00:07:59,210 --> 00:08:03,840
它接受参数x，并执行下面的操作
which takes argument x and does the following operations.

136
00:08:03,840 --> 00:08:09,620
首先set! x为x加1，
It first sets x to x plus one.

137
00:08:09,620 --> 00:08:12,280
我勒个去，这看起来就像FORTRAN，是吧？
My gosh, this looksjust like FORTRAN, right--

138
00:08:12,280 --> 00:08:15,370
只是用了些有趣的语法
in a funny syntax.

139
00:08:15,370 --> 00:08:21,880
然后加上x count
And then add to x count,

140
00:08:21,880 --> 00:08:24,210
哦，我刚犯了个错
Oh, I just made a mistake.

141
00:08:24,210 --> 00:08:25,310
我的意思是
I want to say,

142
00:08:25,310 --> 00:08:30,370
set! count为1加上count
set! count to one plus count.

143
00:08:30,370 --> 00:08:34,120
就是我在这里定义的这个
It's this thing defined here.

144
00:08:34,120 --> 00:08:39,400
然后x和count相加
And then plus x count.

145
00:08:39,400 --> 00:08:42,210
然后就可以试着运行这个过程了
Then I can try this procedure.

146
00:08:42,210 --> 00:08:43,600
让我们运行它
Let's run it.

147
00:08:43,600 --> 00:08:47,220
假设我可以输入
So, suppose I get a prompt and I say,

148
00:08:47,220 --> 00:08:51,740
我输入demo 3
 demo 3

149
00:08:51,740 --> 00:08:53,740
这里发生了什么？Well, what happens here?

150
00:08:53,740 --> 00:08:55,280
发生的第一件事情是
The first thing that happens

151
00:08:55,300 --> 00:08:56,890
count现在是1
is count is currently one.

152
00:08:56,890 --> 00:08:58,890
现在，这是一个时间点
Currently, there is a time.

153
00:08:58,890 --> 00:09:00,290
我们在讨论时间点
We're talking about time.

154
00:09:00,290 --> 00:09:02,290
x的值为3
x gets three.

155
00:09:02,290 --> 00:09:04,290
在这个时刻
At this moment,

156
00:09:04,290 --> 00:09:08,010
count增加了，所以count是2
I say, oh yes, count is incremented, so count is two.

157
00:09:08,010 --> 00:09:10,540
2加3等于5
two plus three is five.

158
00:09:10,540 --> 00:09:13,650
所以结果是5
So the answer I get out is five.

159
00:09:13,650 --> 00:09:23,000
然后我再一次，输入demo 3
Then I say, demo of say, three again.

160
00:09:23,000 --> 00:09:25,430
结果是什么？
What do I get?

161
00:09:25,430 --> 00:09:28,100
现在count是2，它不再是1了
Well, now count is two, it's not one anymore,

162
00:09:28,100 --> 00:09:30,610
因为我让count加1了
because I have incremented it.

163
00:09:30,610 --> 00:09:32,720
但现在我执行这个过程，
But now I go through this process,

164
00:09:32,720 --> 00:09:34,080
x的值为3
three goes into x,

165
00:09:34,080 --> 00:09:37,840
count变为1加count，因此现在是3了
count becomes one plus count, so that's three now.

166
00:09:37,840 --> 00:09:39,620
这两个相加是6
The sum of those two is six,

167
00:09:39,620 --> 00:09:41,820
所以结果是6
so the answer is six.

168
00:09:41,820 --> 00:09:43,030
我们可以发现
And what we see

169
00:09:43,030 --> 00:09:44,950
同样的表达式
is the same expression

170
00:09:44,950 --> 00:09:48,330
却得到了不同的结果
leads to two different answers,

171
00:09:48,330 --> 00:09:51,490
因为时间的作用
depending upon time.

172
00:09:51,490 --> 00:09:54,040
所以demo不是函数
So demo is not a function,

173
00:09:54,040 --> 00:09:59,460
它没有计算一个数学中的函数
does not compute a mathematical function.

174
00:09:59,460 --> 00:10:02,660
事实上，你可以知道这是为什么
In fact, you could also see why now, of course,

175
00:10:02,660 --> 00:10:07,470
因为这里是第一处代换模型失效的地方
this is the first place where the substitution model isn't going to work.

176
00:10:07,470 --> 00:10:10,960
它弄死了代换模型
This kills the substitution model dead.

177
00:10:10,960 --> 00:10:16,070
哲学家可能注意到一些小麻烦
You know, with quotation there were some little problems that a philosopher might notice

178
00:10:16,070 --> 00:10:22,340
因为你不得不去担心在#TBD的时候能如何代换
with the substitutions, because you have to worry about what deductions you can make when you substitute into quotes,

179
00:10:22,340 --> 00:10:24,340
如果你被允许代换的话
if you're allowed to do that at all.

180
00:10:24,340 --> 00:10:26,000
但是
But

181
00:10:26,000 --> 00:10:28,110
在这里代换模型已经死了
here the substitution model is dead,

182
00:10:28,110 --> 00:10:29,640
他什么也不能做了
can't do anything at all.

183
00:10:29,640 --> 00:10:30,570
因为
Because,

184
00:10:30,570 --> 00:10:36,970
假设我想用代换模型来考虑count的代换
Supposing I wanted to use a substitution model to consider substituting for count?

185
00:10:36,970 --> 00:10:41,570
如果我在这里和这里进行代换
Well, my gosh, if I substitute for here and here,

186
00:10:41,570 --> 00:10:44,060
它们是不同的
they're different ones.

187
00:10:44,060 --> 00:10:46,270
它不再是同一个count了
It's not the same count any more.

188
00:10:46,270 --> 00:10:47,970
我得到了错误的结果
I get the wrong answer.

189
00:10:47,970 --> 00:10:50,940
代换模型是一个静态的现象#TBD
The substitution model is a static phenomenon

190
00:10:50,940 --> 00:10:52,940
它描述了真实的事物#TBD
describes things that are true

191
00:10:52,940 --> 00:10:55,500
并且事物不会改变#TBD
and not things that change.

192
00:10:55,500 --> 00:10:57,500
这里，我们的的真实变了#TBD
Here, we have truths that change.

193
00:11:00,350 --> 00:11:06,740
那么，在我给出任何解释之前
OK, Well, before I give you any understanding of this,

194
00:11:06,740 --> 00:11:07,790
这很糟糕
this is very bad.

195
00:11:07,790 --> 00:11:10,080
我们失去了我们的计算模型
Now, we've lost our model of computation.

196
00:11:10,080 --> 00:11:11,090
并且
And,

197
00:11:11,090 --> 00:11:14,660
很快，我将不得不构建一个新的计算模型
pretty soon, I'm going to have to build you a new model of computation.

198
00:11:14,660 --> 00:11:18,450
#TBD
But ours plays with this, just now, in an informal sense.

199
00:11:18,450 --> 00:11:20,380
当然，你们已经看到的是
Of course, what you already see

200
00:11:20,380 --> 00:11:22,930
当我做一些像赋值之类的事情时
is that when I have something like assignment,

201
00:11:22,930 --> 00:11:24,510
我们所需要的模型
the model that we're going to need

202
00:11:24,510 --> 00:11:26,890
与我们之前模型不同
is different from the model that we had before

203
00:11:26,890 --> 00:11:30,930
在这个的模型中，像count或x这些符号
in that, the variables, those symbols like count, or x

204
00:11:30,930 --> 00:11:34,070
不再关联于他们的值
are no longer going to refer to the values they have,

205
00:11:34,070 --> 00:11:37,560
而是关联于某个储存这些值的地方
but rather to some sort of place where the value restored.

206
00:11:37,560 --> 00:11:39,560
我们将不得不以这种方式思考一段时间
We're going to have to think that way for a while.

207
00:11:39,560 --> 00:11:42,110
这将是一个很糟糕坏的事情
And it's going to be a very bad thing

208
00:11:42,110 --> 00:11:44,020
并且会造成很多麻烦
and cause a lot of trouble.

209
00:11:44,020 --> 00:11:48,250
所以，就像我说的，当我们创造糟糕的事物
And so, as I said, the very fact that we're inventing this bad thing,

210
00:11:48,250 --> 00:11:50,370
意味着有更好的创造它的理由
means that there had better be a good reason for it,

211
00:11:50,370 --> 00:11:53,130
否则，就是浪费时间和精力
otherwise, just a waste of time and a lot of effort.

212
00:11:53,130 --> 00:11:55,880
让我们看看一些东西#TBD
Let's just look at some of it just to play.

213
00:11:55,880 --> 00:11:58,590
假设我们写了函数式版本的阶乘
Supposing we write down the functional version,

214
00:11:58,590 --> 00:12:01,170
传统意义中的那个函数式
functional meaning in the old style,

215
00:12:01,170 --> 00:12:09,590
这个阶乘使用了迭代的过程
of factorial by an iterative process.

216
00:12:09,590 --> 00:12:14,240
n的阶乘

217
00:12:18,120 --> 00:12:25,760
我们要从m迭代到i
we're going to iterate of m and i,

218
00:12:25,760 --> 00:12:33,510
就是说如果i大于n
which says if i is greater than n,

219
00:12:33,510 --> 00:12:35,510
则结果是m
then the result is m,

220
00:12:35,510 --> 00:12:39,560
否则
otherwise,

221
00:12:39,560 --> 00:12:46,820
结果是迭代i和m的乘积
the result of iterating the product of i and m.

222
00:12:46,820 --> 00:12:51,480
所以m将是我累积的结果
So m is going to be the product that I'm accumulating.

223
00:12:51,480 --> 00:12:57,970
m就是这个乘积
m is the product.

224
00:12:57,970 --> 00:13:04,620
然后我要把count加1
And the count I'm going to increase by one.

225
00:13:04,620 --> 00:13:11,780
[闭合括号中]
Plus, ITER, ELSE, COND, define.

226
00:13:11,780 --> 00:13:17,070
我要从这开始写
I'm going to start this up.

227
00:13:17,070 --> 00:13:20,710
如今，你们应该能够没有任何障碍地阅读这类东西了
And these days, you should have no trouble reading something like this.

228
00:13:20,710 --> 00:13:26,180
这里是一个累积的乘积，和一个计数器
What I have here is a product there being accumulated and a counter.

229
00:13:26,180 --> 00:13:28,700
我让它们都从1开始
I start them up both at one.

230
00:13:28,700 --> 00:13:30,920
我将不断让计数器增加
I'm going to buzz the counter up,

231
00:13:30,920 --> 00:13:34,350
每个回合i变成i加1
i goes to i plus one every time around.

232
00:13:34,350 --> 00:13:38,120
那是我们在过程中唯一设置的时间点
But that's only our putting a time on the process,

233
00:13:38,120 --> 00:13:40,320
#TBD
each of this is just a set of truths,

234
00:13:40,320 --> 00:13:42,320
#TBD
true rules.

235
00:13:42,320 --> 00:13:46,130
m将获得一个新的值，就是i乘m
And m is going to get a new values of i and m,

236
00:13:46,130 --> 00:13:48,410
每一轮i乘以m
i times m each time around,

237
00:13:48,410 --> 00:13:52,420
最终i将大于n，在那种情况下，结果就是m
and eventually i is going to be bigger than n, in which case, the answer's going to be m.

238
00:13:52,420 --> 00:13:55,460
现在我给你们讲，#TBD
Now, I'm speaking to you, use time in this.

239
00:13:55,460 --> 00:13:58,070
那是因为我知道计算机是怎么工作的
That's just because I know how the computer
works.

240
00:13:58,070 --> 00:13:59,550
但是我没必要这么做
But I didn't have to.

241
00:13:59,550 --> 00:14:02,300
这可以作为一个纯数学的解释
This could be a purely mathematical description at this point,

242
00:14:02,300 --> 00:14:04,800
因为代换在这里可以工作
because substitution will work for this.

243
00:14:04,800 --> 00:14:08,140
但是我们写一个类似的程序
But let's set right down a similar sort of program,

244
00:14:08,140 --> 00:14:10,510
使用相同的算法
using the same algorithm,

245
00:14:10,510 --> 00:14:13,300
但使用了赋值
but with assignments.

246
00:14:15,330 --> 00:14:23,390
所以这个叫做函数式版本
So this is called the functional version.

247
00:14:23,390 --> 00:14:34,220
我想写个命令式的版本的
I want to write down an imperative version.

248
00:14:34,220 --> 00:14:35,710
n的阶乘
Factorial of n.

249
00:14:35,710 --> 00:14:40,160
我要创建两个变量
I'm going to create my two variables.

250
00:14:40,160 --> 00:14:46,220
把i的值初始化为1
Let i initialize itself to one,

251
00:14:46,220 --> 00:14:50,840
m也初始化为1
and m be initialized to one, similar.

252
00:14:50,840 --> 00:14:59,140
我们创建一个循环
We'll create a loop

253
00:14:59,140 --> 00:15:07,270
如果i比n大，循环结束
which has COND greater than i, and if i is greater than n, we're done.

254
00:15:07,270 --> 00:15:08,870
结果是m
And the result is m,

255
00:15:08,870 --> 00:15:10,870
也就是我累积的乘积
the product I'm accumulating.

256
00:15:10,870 --> 00:15:15,230
否则
Otherwise,

257
00:15:15,230 --> 00:15:19,050
我要写下三件要做的事
I'm going to write down three things to do.

258
00:15:19,050 --> 00:15:29,200
我要set! m为i与m的乘积
I'm going to set! m to the product of i and m,

259
00:15:29,200 --> 00:15:37,640
set! i为i加1的和
set! i to the sum of i and one,

260
00:15:37,640 --> 00:15:40,410
然后继续循环
and go around the loop again.

261
00:15:40,410 --> 00:15:43,400
你们中的FORTRAN程序员应该觉得眼熟
Looks very familiar to you FORTRAN programmers.

262
00:15:43,400 --> 00:15:46,640
[闭合括号中]
ELSE, COND, define,

263
00:15:46,640 --> 00:15:50,890
语法挺有趣吧？
funny syntax though.

264
00:15:50,890 --> 00:15:56,100
启动循环
Start the loop up,

265
00:15:56,100 --> 00:15:58,710
程序写完了
and that's the program.

266
00:15:58,710 --> 00:16:00,710
那么，这个程序
Now, this program,

267
00:16:00,710 --> 00:16:02,710
我们应该怎么看它呢？
how do we think about it?

268
00:16:02,710 --> 00:16:04,710
来看看我们在这看到了什么
Well, let's just say what we're seeing here.

269
00:16:04,710 --> 00:16:07,470
这里有两个局部变量，i和m
There are two local variables, i and m,

270
00:16:07,470 --> 00:16:10,220
它们都被初始化为1
that have been initialized to one.

271
00:16:10,220 --> 00:16:13,890
在每一次循环里，我检测i是否大于n
Every time around the loop, I test to see if i is greater than n,

272
00:16:13,890 --> 00:16:15,300
就是我们传入的参数
which is the input argument,

273
00:16:15,300 --> 00:16:18,770
如果成立的话，结果就是累积在m中的乘积
and if so, the re sult is the product being accumulated in m.

274
00:16:18,770 --> 00:16:21,210
然而，如果循环没有结束
However, if it's not the end of the loop,

275
00:16:21,210 --> 00:16:23,410
如果我们的工作没有结束
if I'm not done,

276
00:16:23,410 --> 00:16:28,890
则我们要把乘积变为i与当前乘积的结果
then what I'm going to do is change the product to be the result of multiplying i times the current product.

277
00:16:28,890 --> 00:16:31,180
就是我们在这里做过的事情
Which is sort of what we were doing here.

278
00:16:31,180 --> 00:16:33,180
除了这里我没有改动
Except here I wasn't changing.

279
00:16:33,180 --> 00:16:36,540
我复制出了另外一份
I was making another copy,

280
00:16:36,540 --> 00:16:42,710
因为代换模型就是你复制过程的体
because the substitution model says, you copy the body of the procedure

281
00:16:42,710 --> 00:16:46,440
并将形式参数用实际参数代换
with the arguments substituted for the formal parameters.

282
00:16:46,440 --> 00:16:48,420
这里我不担心复制
Here I'm not worried about copying,

283
00:16:48,420 --> 00:16:51,530
在这里，我已经改变了m的值
here I've changed the value of m.

284
00:16:51,530 --> 00:16:55,520
我也把i的值变成了i加1
I also then change the value of i to i plus one,

285
00:16:55,520 --> 00:16:57,770
然后继续循环
and go buzzing around.

286
00:16:57,770 --> 00:17:00,770
看起来是一样的程序
Seems like essentially the same program,

287
00:17:00,770 --> 00:17:02,840
但是可能有一些犯错的机会
but there are some ways of making errors here

288
00:17:02,840 --> 00:17:05,850
直到今天还存在
that didn't exist until today.

289
00:17:05,850 --> 00:17:07,320
例如
For example,

290
00:17:07,320 --> 00:17:09,690
如果我在赋值的时候
if I were to do the horrible thing

291
00:17:09,690 --> 00:17:12,440
没有小心地写程序
of not being careful in writing my program

292
00:17:12,440 --> 00:17:16,890
把两个赋值的顺序调换了
and interchange those two assignments,

293
00:17:16,890 --> 00:17:19,890
程序计算的就不是相同的函数了
the program wouldn't compute the same function.

294
00:17:19,890 --> 00:17:22,870
我得到了一个时间错误，因为这儿有个依赖关系
I get a timing error because there's a dependency

295
00:17:22,870 --> 00:17:27,220
m依赖于i上一次的值
there's a dependency that m depends upon having the last value of i.

296
00:17:27,220 --> 00:17:31,040
如果我先改变i的值
If I try change i first,

297
00:17:31,040 --> 00:17:35,550
就会在乘以m的时候，得到错误的i值
then I've got the wrong value of i when I multiply by m.

298
00:17:35,550 --> 00:17:38,380
在此之前不会存在这样的bug
It's a bug that wasn't available until this moment,

299
00:17:38,380 --> 00:17:42,260
直到我们把某些包含时间的东西引入进来才发生
until we introduced something that had time in it.

300
00:17:42,260 --> 00:17:45,370
如我所说的
So, as I said,

301
00:17:45,370 --> 00:17:47,390
首先，我们需要一个新的计算模型
first we need a new model of computation,

302
00:17:47,390 --> 00:17:52,300
然后，我们就不得不去找，搞这些坑爹事的好理由
and second, we have to be damn good reason for doing this kind of ugly thing.

303
00:17:52,300 --> 00:17:58,410
有什么问题吗？
Are there any questions?

304
00:17:58,410 --> 00:18:00,400
大声点说，David
Speak loudly, David

305
00:18:00,400 --> 00:18:03,720
学生：我们现在引入了set
AUDIENCE: I'm confused about, we've introduced set now,

306
00:18:03,720 --> 00:18:06,760
但是我们之前已经有let和define了
but we had let before and define before.

307
00:18:06,760 --> 00:18:09,700
我不太清楚它们的区别
I'm confused about the difference between the three.

308
00:18:09,700 --> 00:18:13,250
define不能像set一样用吗？
Wouldn't define work in the same situation as set

309
00:18:13,250 --> 00:18:14,830
请详细讲讲
if you introduced it a bit?

310
00:18:14,830 --> 00:18:19,310
教授：不，define是在第一次时创建某个东西时给它设置一个值用的
PROFESSOR: No, define is intended for setting something once the first time,

311
00:18:19,310 --> 00:18:21,740
为了创建它
for making it, OK?

312
00:18:21,740 --> 00:18:24,970
你永远也不会见到我在黑板上
You've never seen me write on a blackboard

313
00:18:24,970 --> 00:18:26,960
在同一行写两个define
two defines in a row

314
00:18:26,960 --> 00:18:32,080
为了让某个变量的旧值变成一个新的值
whose intention was to change the old value of some variable to a new one.

315
00:18:32,080 --> 00:18:34,510
学生：这是一个约定俗成的规矩，还是--
AUDIENCE: Is that by convention or--

316
00:18:34,510 --> 00:18:36,350
教授：不，这是有意为之的
PROFESSOR: No, it's intention.

317
00:18:36,350 --> 00:18:39,460
The answer is,

318
00:18:39,460 --> 00:18:40,840
举个例子
that, for example,

319
00:18:40,840 --> 00:18:42,900
在一个过程内部
internal to a procedure,

320
00:18:42,900 --> 00:18:46,440
两个define写在一行里是非法的
two defines in a row are illegal,

321
00:18:46,440 --> 00:18:49,520
对于同一个变量define两次是非法的
two defines in a row of the same variable.

322
00:18:49,520 --> 00:18:51,740
x 不能被define两次
x can't be defined twice.

323
00:18:51,740 --> 00:18:55,600
而系统会不会捕获这个错误，就是另一个问题了
Whether or not a system catches that error is a different question,

324
00:18:55,600 --> 00:18:58,120
但是我定下规矩
but I legislate to you

325
00:18:58,120 --> 00:19:00,640
任何东西都只能define一次
that define happens once on anything.

326
00:19:00,640 --> 00:19:03,150
现在，确实，在交互式调试中
Now, indeed, in interactive debugging,

327
00:19:03,150 --> 00:19:07,960
我们打算让你与你的计算机交互时可以重新define一些东西
we intend that you interacting with your computer will redefine things,

328
00:19:07,960 --> 00:19:11,690
所以这是交互式调试带来的一个特殊的异常
and so there's a special exception made for interactive debugging.

329
00:19:11,690 --> 00:19:17,490
#TBD
But define is intended to mean to set up something

330
00:19:17,490 --> 00:19:22,050
#TBD
which will be forever that value after that point.

331
00:19:22,050 --> 00:19:26,090
#TBD
It's as if all the defines were done at the beginning.

332
00:19:26,090 --> 00:19:29,110
#TBD
In fact, the only legal place to put a define

333
00:19:29,110 --> 00:19:31,110
#TBD
in Scheme, internal to a procedure,

334
00:19:31,110 --> 00:19:34,470
就是lambda表达式的开始
is just at the beginning of a lambda expression,

335
00:19:34,470 --> 00:19:39,950
过程体的开始
the beginning of the body of a procedure.

336
00:19:39,950 --> 00:19:47,760
现在，let当然与那个不一样
Now, let of course does nothing like either of that.

337
00:19:47,760 --> 00:19:50,000
如果你想知道let发生了什么
I mean, if you look at what's happening with a let,

338
00:19:50,000 --> 00:19:52,130
这个只会重新发生一次#TBD
this happens again exactly once.

339
00:19:52,130 --> 00:19:56,650
它建立了一个i和m的值分别为1的上下文
It sets up a context where i and m are values one and one.

340
00:19:56,650 --> 00:20:01,310
这个上下文存在于整个作用域中
That context exists throughout this scope,

341
00:20:01,310 --> 00:20:04,610
即程序的范围之内
this region of the program.

342
00:20:04,610 --> 00:20:10,780
然而，你不会认为let再次设置了i的值
However, you don't think of that let as setting i again.

343
00:20:10,780 --> 00:20:12,160
它没有改变i的值
It doesn't change it.

344
00:20:12,160 --> 00:20:15,090
因为let，i将永远不会变化
i never changes because of the let.

345
00:20:15,090 --> 00:20:18,350
因为let，i才被创建
i gets created because of let.

346
00:20:18,350 --> 00:20:19,730
实际上
In fact,

347
00:20:19,730 --> 00:20:21,980
let是一个非常简单的想法
the let is a very simple idea.

348
00:20:21,980 --> 00:20:23,590
let不会做别的事情
Let does nothing more,

349
00:20:23,590 --> 00:20:31,620
它让var1的值为1
Let a variable one to have value one

350
00:20:31,620 --> 00:20:37,160
我要把这些更规整地写下来
I'll write this down a little bit more neatly;

351
00:20:37,160 --> 00:20:43,730
var1的值，是表达式e1的值
Let's write, var one have value, the value of expression e1,

352
00:20:43,730 --> 00:20:47,920
var2的值，是表达式e2的值
and variable two, have this value of the expression e2,

353
00:20:47,920 --> 00:20:51,260
在表达式e3中
in an expression e3,

354
00:20:51,260 --> 00:21:06,730
#TBD与var1和var2的过程一样，它们是形式参数
is the same thing as a procedure of var one and var two, the formal parameters,

355
00:21:06,730 --> 00:21:10,710
e3成为过程的体
and e3 being the body,

356
00:21:10,710 --> 00:21:14,270
在这里，var1与e1的值绑定

where var one is bound to the value of e1,

357
00:21:14,270 --> 00:21:19,240
var2与e2的值绑定
and var two gets the value of e2.

358
00:21:19,240 --> 00:21:24,690
所以实际上，这是一个从代换的角度来看很容易理解的东西
So this is, in fact, a perfectly understandable thing from a substitution point of view.

359
00:21:24,690 --> 00:21:30,780
其实就是同一个表达式的两种不同的写法
This is really the same expression written in two different ways.

360
00:21:31,310 --> 00:21:37,260
事实上，系统真正的工作方式就是在运行之前，把代码翻译成这种形式
In fact, the way the actual system
works is this gets translated into this before anything happens.

361
00:21:37,260 --> 00:21:41,770
学生：我还是不清楚是什么造成了let和define之间的区别
AUDIENCE: OK, I'm still unclear as then what makes the difference between a let and a define. They could--

362
00:21:41,770 --> 00:21:44,490
教授:define就是个语法糖
PROFESSOR: A define is a syntactic sugar,

363
00:21:44,490 --> 00:21:49,670
#TBD
whereby, essentially a bunch of variables get created by lets and then set up once.

364
00:21:56,740 --> 00:21:59,990
那么，我们休息一会
OK, time for the first break, I think. Thank you.

365
00:22:02,520 --> 00:22:19,230
[音乐]
[MUSIC PLAYING]

366
00:22:48,810 --> 00:23:03,690
[音乐]
[MUSIC PLAYING]

367
00:23:03,690 --> 00:23:06,350
看
Well let's see.

368
00:23:06,350 --> 00:23:09,580
我现在不得不重建计算模型
I now have to rebuild the model of computation,

369
00:23:09,580 --> 00:23:14,630
所以你明白了那些机制是如何运作的
so you understand how some such mechanical mechanism could work

370
00:23:14,630 --> 00:23:17,280
来完成我们刚才说的那些工作
that can do what we've just talked about.

371
00:23:17,280 --> 00:23:22,380
我刚刚摧毁了你们的代换模型
I just recently destroyed your substitution model.

372
00:23:22,380 --> 00:23:26,460
不幸的是，这个模型比代换模型要复杂得多
Unfortunately, this model is significantly more complicated than the substitution model.

373
00:23:26,460 --> 00:23:28,680
这个模型叫环境模型
It's called the environment model.

374
00:23:28,680 --> 00:23:31,860
我即将介绍一些术语
And I'm going to have to introduce some terminology,

375
00:23:31,860 --> 00:23:34,510
无论如何，你知道这些术语都是很好的
which is very good terminology for you to know anyway. It's about names.

376
00:23:34,510 --> 00:23:36,510
它是关于名字的
It's about names.

377
00:23:36,510 --> 00:23:42,480
我们将要给事物拥有的名字和这些名字的用途命名
And we're going
to give names to the kinds of names things have and the way those names are used.

378
00:23:42,480 --> 00:23:47,940
所以这是一个元解释，如果你想这么理解的话
So this is a meta-description, if you will.

379
00:23:47,940 --> 00:23:50,850
不管怎样，这儿有一堆坑爹的术语
Anyway, there is a pile of an unfortunate terminology here,

380
00:23:50,850 --> 00:23:54,430
是我们将需要这些来理解所谓的环境模型
but we're going to need this to understand what's called the environment model.

381
00:23:54,430 --> 00:23:58,040
我们可能要做一点无聊的#TBD了
We're about to do a little bit of boring, dog-work here.

382
00:23:58,040 --> 00:24:02,000
我们来看第一张张幻灯片
Let's look at the first transparency.

383
00:24:02,000 --> 00:24:08,460
我们看到了一个术语“约束”的解释
And we see a description of a word called bound.

384
00:24:08,460 --> 00:24:11,000
我们会说一个变量v
And we're going to say that a variable, v,

385
00:24:11,000 --> 00:24:13,410
被约束在表达式e中
is bound in an expression, e,

386
00:24:13,410 --> 00:24:22,520
如果e的含义没有被变量w的形式代换改变的话
if the meaning of e is unchanged by the uniform replacement of a variable w,

387
00:24:22,520 --> 00:24:25,500
#TBD
for every occurrence of v in e.

388
00:24:25,500 --> 00:24:27,280
这是一个很长的句子
Now that's a long sentence,

389
00:24:27,280 --> 00:24:33,220
我想，在我们都被搞糊涂之前，我应该说得详细点。
so, I think, I'm going to have to say a little bit about that before we even fool around at all here.

390
00:24:33,220 --> 00:24:43,890
我们这里讨论的是约束变量
Bound variables we're talking about here.

391
00:24:43,890 --> 00:24:46,070
你们已经看到它们很多次了
And you've seen lots of them.

392
00:24:46,070 --> 00:24:49,600
但你们可能不知道自己已经见过它们很多次了
You may not know that you've seen lots of them.

393
00:24:49,600 --> 00:24:53,270
我猜在你们的逻辑中，你们看到一个逻辑变量
Well, I suppose in your logic you saw a logical variables like,

394
00:24:53,270 --> 00:25:02,600
对于任意任何x，存在一个y，使得p为真，就像你在微积分课上学到的。
for every x there exists a y such that p is true of x and y from your calculus class.

395
00:25:02,600 --> 00:25:06,840
这个变量x，这个变量y，它们被约束
This variable, x, and this variable, y, are bound,

396
00:25:06,840 --> 00:25:08,150
因为
because,

397
00:25:08,150 --> 00:25:09,980
这个表达式的含义
the meaning of this expression

398
00:25:09,980 --> 00:25:16,330
不取决于
我用来描述x和y的具体字母
does not depend upon the particular letters I used to describe x and y.

399
00:25:16,330 --> 00:25:19,820
如果我用w替换x
If I were to change the w for x,

400
00:25:19,820 --> 00:25:25,860
则可以说对于任意w，存在一个y使得p为真
then said for every w there exists a y such that p is true of w and y,

401
00:25:25,860 --> 00:25:27,860
它们其实是同一句话
it would be the same sentence.

402
00:25:27,860 --> 00:25:30,340
这就是那句话的意思
That's what it means.

403
00:25:30,340 --> 00:25:35,710
或者在另一个情况下，你们看到这是一个积分的描述
Or another case of this that you've seen is integral say,

404
00:25:35,710 --> 00:25:45,600
对1+x的平方分之dx从0到1积分
from 0 to one of dx over one plus x square.

405
00:25:45,600 --> 00:25:47,920
这就是你们经常见到的那种东西
Well that's something you see all the time.

406
00:25:47,920 --> 00:25:51,980
这个x是一个约束变量
And this x is a bound variable.

407
00:25:51,980 --> 00:25:54,150
如果我把它换成t
If I change that to a t,

408
00:25:54,150 --> 00:25:57,600
这个表达式其实没有变化
the expression is still the same thing.

409
00:25:57,600 --> 00:26:04,330
就是#TBD
This is a 1/4 of the arctan of one or something here.

410
00:26:04,330 --> 00:26:06,360
是的，就是1的反正切
Yes, that's the arctan of one.

411
00:26:06,360 --> 00:26:09,080
所以约束变量事实上很常见
So bound variables are actually fairly common,

412
00:26:09,080 --> 00:26:13,100
如果你们接触过一些数学的话for those of you who have played a bit with mathematics.

413
00:26:13,100 --> 00:26:18,720
好，让我们来到编程的世界
Well, let's go into the programming world.

414
00:26:18,720 --> 00:26:21,820
#TBD
Instead of the quantifier being something like,

415
00:26:21,820 --> 00:26:24,060
#TBD
for every, or there exists, or integral,

416
00:26:24,060 --> 00:26:27,220
#TBD
a quantifier is a symbol that binds a variable.

417
00:26:27,220 --> 00:26:29,520
我们要使用#TBDlambda
And we are going to use the quantifier lambda

418
00:26:29,520 --> 00:26:33,500
作为约束变量的一个必要的东西
as being the essential thing that binds variables.

419
00:26:33,500 --> 00:26:36,490
#TBD
And so we have some nice examples here

420
00:26:36,490 --> 00:26:44,140
#TBD
like that procedure of one argument y which does the following thing.

421
00:26:44,140 --> 00:26:47,590
它以一个参数x调用了过程
It calls the procedure of one argument x,

422
00:26:47,590 --> 00:26:52,040
将x乘以y
which multiplies x by y,

423
00:26:52,040 --> 00:26:55,650
#TBD
and applies that to three.

424
00:26:58,140 --> 00:27:01,780
这个过程中包含两个约束变量
That procedure has the property there of two bound variables in it,

425
00:27:01,780 --> 00:27:03,940
x和y
x and y

426
00:27:03,940 --> 00:27:07,910
这个量词，lambda，约束了这个y
This quantifier, lambda here, binds this y,

427
00:27:07,910 --> 00:27:11,640
这个量词lambda，约束了这个x
and this quantifier, lambda, binds that x.

428
00:27:11,640 --> 00:27:17,480
因为，如果我用了一个没有出现在表达式中的任意符号，如w，
Because, if I were to take an arbitrary symbol does not occur in this expression like w

429
00:27:17,480 --> 00:27:21,220
用w替换表达式中的所有y
and replace all y's with w's in this expression,

430
00:27:21,220 --> 00:27:23,530
这个表达式仍与原来的相同
the expression is still the same,

431
00:27:23,530 --> 00:27:25,280
是相同的过程
the same procedure.

432
00:27:25,280 --> 00:27:27,410
这是一个重要的想法
And this is an important idea.

433
00:27:27,410 --> 00:27:29,950
我们有这种东西的原因
The reason why we had such things like that

434
00:27:29,950 --> 00:27:31,410
是一种流行趋势
is a kind of modularity.

435
00:27:31,410 --> 00:27:33,510
如果有两个人写程序
If two people are writing programs,

436
00:27:33,510 --> 00:27:35,260
并且他们在合作编程
and they work together,

437
00:27:35,260 --> 00:27:42,100
在他们自己构建的小项目里用什么命名都没有关系
it shouldn't matter what names they use internal to their own little machines that they're building.

438
00:27:42,100 --> 00:27:45,300
所以，实际上我想告诉你们
And so, what I'm really telling you there,

439
00:27:45,300 --> 00:27:46,840
例如
is that, for example,

440
00:27:46,840 --> 00:27:52,190
这个表达式等于，以y为参数的过程
this is equivalent to that procedure of one argument y which

441
00:27:52,190 --> 00:28:01,270
#TBD
uses that procedure of one argument z which multiplies z by y.

442
00:28:01,270 --> 00:28:05,360
因为没人关心我在这用什么
Because nobody cares what I used in here.

443
00:28:05,360 --> 00:28:07,990
这是一个极好的例子
It's a nice example.

444
00:28:07,990 --> 00:28:10,330
另一方面
On the other hand,

445
00:28:10,330 --> 00:28:14,780
我有一些未被约束的变量
 I have some variables that are not bound.

446
00:28:14,780 --> 00:28:16,780
举个例子
And example,

447
00:28:19,590 --> 00:28:21,920
这个对于一个参数x的过程
that procedure of one argument x

448
00:28:21,920 --> 00:28:27,100
将x乘以y
which multiplies x by y

449
00:28:27,100 --> 00:28:29,100
在这个例子中
In this case,

450
00:28:29,100 --> 00:28:31,910
y没有被约束
y is not bound.

451
00:28:31,910 --> 00:28:34,860
假设y的值是3
Supposing y had the value three,

452
00:28:34,860 --> 00:28:37,900
z的值是4
and z had the value four,

453
00:28:37,900 --> 00:28:44,590
那么这个过程就是把它的参数乘以3
then this procedure would be the thing that multiplies its argument by three.

454
00:28:44,590 --> 00:28:47,420
如果我如果我把所有的y都用z来代替
If I were to replace every instance of y with z,

455
00:28:47,420 --> 00:28:53,440
我将得到一个完全不同的过程，它会把参数乘以4
I would have a different procedure which multiplies every argument that's given by four.

456
00:28:53,440 --> 00:28:57,440
事实上，我们给这种变量取了个名字
And, in fact, we have a name for such a variable.

457
00:28:57,440 --> 00:29:04,010
我们把表达式e中的变量v叫做自由变量
Here, we say that a variable, v, is free in the expression, e,

458
00:29:04,010 --> 00:29:09,500
if the meaning of the expression, e, is changed by the uniform replacement of a variable, w, not occurring in e

459
00:29:09,500 --> 00:29:12,170
for every occurrence of v and e.

460
00:29:12,170 --> 00:29:14,080
所以
So,

461
00:29:14,080 --> 00:29:29,160
所以这就是为什么这个变量y，是一个自由变量
So that's why this variable over here, y, is a free variable.

462
00:29:29,160 --> 00:29:33,220
所以，这个表达式里的自由变量
And so free variables in this expression--

463
00:29:33,220 --> 00:29:35,680
另一个例子是
And other examples of that is that

464
00:29:35,680 --> 00:29:40,160
对于一个参数y的过程
is that procedure of one argument y,

465
00:29:40,160 --> 00:29:42,160
就像我们之前的那个一样
which is just what we had before,

466
00:29:42,160 --> 00:29:44,900
使用对于参数x的过程
which uses that procedure of one argument x

467
00:29:44,900 --> 00:29:50,910
将x与y相乘--
that multiplies x by y--

468
00:29:50,910 --> 00:29:52,910
#TBD
use that on three.

469
00:29:56,850 --> 00:30:00,700
这个过程中有一个自由变量
This procedure has a free variable in it

470
00:30:00,700 --> 00:30:04,100
也就是这个星号
which is asterisk.

471
00:30:04,100 --> 00:30:05,890
你看，因为
See, because,

472
00:30:05,890 --> 00:30:09,080
如果它表示正常意义的乘法
if that has a normal meaning of multiplication,

473
00:30:09,080 --> 00:30:13,860
如果我形式上将所有星号都以加号代替
then if I were to replace uniformly all asterisks with pluses,

474
00:30:13,860 --> 00:30:18,840
这个表达式的含义就变了
then the meaning of this expression would change.

475
00:30:18,840 --> 00:30:21,840
这就是自由变量的意思
That's what you mean by a free variable.

476
00:30:21,840 --> 00:30:25,360
目前，你们已经学过了一些术语
So, so far you've learned some logician words

477
00:30:25,360 --> 00:30:28,560
用它们可以解释名字的用法
which describe the way names are used.

478
00:30:28,560 --> 00:30:32,540
我们要需要更进一步深入
Now, we have to do a little bit more playing around here,

479
00:30:32,540 --> 00:30:34,780
再多了解一些
a little bit more.

480
00:30:34,780 --> 00:30:36,640
我想给你们讲讲
I want to tell you about

481
00:30:36,640 --> 00:30:41,220
变量是在哪里被定义的
about the regions are over which variables are defined.

482
00:30:41,220 --> 00:30:43,120
你瞧
You see,

483
00:30:43,120 --> 00:30:46,000
#TBD
we've been very informal about this up till now,

484
00:30:46,000 --> 00:30:50,360
当然，你们中的一些，或者大部分人可能已经理解得很透彻了
and, of course, many of you have probably understood very clearly or most of you,

485
00:30:50,360 --> 00:30:53,460
在这里被声明的x
that the x that's being declared here

486
00:30:53,460 --> 00:30:57,440
只被定义在这里
is defined only in here.

487
00:30:57,440 --> 00:31:01,390
这个x，只被定义在这里
This x is the defined only in here,

488
00:31:01,390 --> 00:31:06,180
这个y，只被定义在这里
and this y is defined only in here.

489
00:31:06,180 --> 00:31:10,960
我们给它取了个名字，叫作用域
We have a name for such an idea. It's called a scope.

490
00:31:10,960 --> 00:31:14,320
我给你们再讲个术语
And let me give you another piece of terminology.

491
00:31:14,320 --> 00:31:15,850
这个就比较复杂
It's a long story.

492
00:31:15,850 --> 00:31:17,850
如果x是e中的一个约束变量
If x is a bound variable in e,

493
00:31:17,850 --> 00:31:20,720
那么它是约束于一个lambda表达式中
then there is a lambda expression where it is bound.

494
00:31:20,720 --> 00:31:24,910
获取约束变量的唯一方法就是通过lambda表达式
So the only way you can get a bound variable ultimately is by lambda expression.

495
00:31:24,910 --> 00:31:26,220
你可能会担心
Then you may worry,

496
00:31:26,220 --> 00:31:29,500
define是它的一个例外吗？
does define quite an exception to this?

497
00:31:29,500 --> 00:31:32,920
#TBD
And it turns out, we could always arrange things so you don't need any defines.

498
00:31:32,920 --> 00:31:34,240
一会我们就能看到了
And we'll see that in a while.

499
00:31:34,240 --> 00:31:36,540
它一个非常神奇的东西
It's a very magical thing.

500
00:31:36,540 --> 00:31:38,680
所以这里不需要define
So define really can go away.

501
00:31:38,680 --> 00:31:42,310
实际上，唯一能创建名字的东西是lambda
The really, only thing that makes names is lambda .

502
00:31:42,310 --> 00:31:44,140
那就是它的工作
That's its job.

503
00:31:44,140 --> 00:31:46,230
多么的令人惊奇
And what's so amazing about a lot of things

504
00:31:46,230 --> 00:31:48,540
很多东西你只凭借lambda就可以计算
is you can compute with only lambda.

505
00:31:48,540 --> 00:31:50,540
但是，在任何情况下
But, in any case,

506
00:31:50,540 --> 00:31:55,760
一个lambda表达式有一个地方来声明变量
a lambda expression has a place where it declares a variable.

507
00:31:55,760 --> 00:31:58,350
我们把它称为形式参数列表
We call it the formal parameter list

508
00:31:58,350 --> 00:32:01,110
或约束变量列表
and we say or the bound variable list.

509
00:32:01,110 --> 00:32:04,740
我们说lambda表达式约束--这是一个动词
We say that the lambda expression binds -- so it's a verb

510
00:32:04,740 --> 00:32:08,340
--约束了在约束变量列表里声明的变量
--binds the variables declared in it's bound variable list.

511
00:32:08,340 --> 00:32:13,040
另外，表达式中定义变量的那些部分
In addition, those parts of the expression where the variable is defined,

512
00:32:13,040 --> 00:32:15,450
是被一些声明所声明的
which was declared by some declaration

513
00:32:15,450 --> 00:32:20,100
这些部分被叫做变量的作用域
is called the scope of that variable.

514
00:32:20,100 --> 00:32:22,100
所以，这些是作用域
So these are scopes.

515
00:32:22,100 --> 00:32:27,160
这是y的作用域
This is the scope of y.

516
00:32:27,160 --> 00:32:32,750
这是x的作用域--
And this is the scope of x--

517
00:32:32,750 --> 00:32:35,010
以此类推
that sort of thing.

518
00:32:40,860 --> 00:32:43,550
好
OK,

519
00:32:43,550 --> 00:32:46,250
现在我们有了足够多的术语
well, now we have enough terminology

520
00:32:46,250 --> 00:32:51,760
用来理解如何建立一个新的计算模型了
to begin to understand how to make a new model for computation

521
00:32:51,760 --> 00:32:54,500
因为，很重要的一点是
because the key thing going on here

522
00:32:54,500 --> 00:32:57,100
我们摧毁了代换模型
is that we destroyed the substitution model,

523
00:32:57,100 --> 00:33:03,510
我们现在不得不需要一个模型，来体现表示名字被关联到某些地方
and we now have to have a model that represents the names as referring to places.

524
00:33:03,510 --> 00:33:05,720
因为，如果我们要改变某个东西
Because if we are going to change something,

525
00:33:05,720 --> 00:33:09,050
我们就需要一个存它的地方
then we have a place where it's stored.

526
00:33:09,050 --> 00:33:10,510
你看
You see,

527
00:33:10,510 --> 00:33:13,580
如果一个名字只是关联于一个值
if a name only refers to a value,

528
00:33:13,580 --> 00:33:16,540
如果我试图改变这个名字的含义
and if I tried to change the name's meaning,

529
00:33:16,540 --> 00:33:20,320
这不怎么明确 well, that's not clear.

530
00:33:20,320 --> 00:33:24,680
因为没有名字可以关联的地方
There's nothing that is the place that that name referred to.

531
00:33:24,680 --> 00:33:27,110
我如何真正的去描述它呢？
How am I really saying it? There is nothing shared

532
00:33:27,110 --> 00:33:29,540
没有东西在名字的所有实例之间共享
among all of the instances of that name.

533
00:33:29,540 --> 00:33:31,680
我们真正的意思是，对于一个名字
And what we really mean, by a name,

534
00:33:31,680 --> 00:33:33,800
#TBD
is that we fan something out.

535
00:33:33,800 --> 00:33:36,540
我们为某个东西命名，然后你拿到了它
We've given something a name, and you have it,

536
00:33:36,540 --> 00:33:39,060
你能得到它，是因为我给了你一个它的引用
and you have it, because I'm given you a reference to it,

537
00:33:39,060 --> 00:33:40,850
我把对它的引用给了你
and I've given you a reference to it.

538
00:33:40,850 --> 00:33:43,010
我们会看到很多相关的例子#TBD
And we'll see a lot about that.

539
00:33:43,010 --> 00:33:45,820
所以我来教给你关于环境的知识
So let me tell you about environments.

540
00:33:45,820 --> 00:33:49,020
我需要用一下头顶上的幻灯机I need the overhead projection machine,

541
00:33:49,020 --> 00:33:51,020
谢谢你
thank you.

542
00:33:51,610 --> 00:33:53,620
这里
And so here

543
00:33:55,080 --> 00:34:01,080
是一堆环境结构
is a bunch of environment structures.

544
00:34:01,080 --> 00:34:06,020
环境就是执行虚拟的代换的一种方法
An environment is a way of doing
substitutions virtually.

545
00:34:06,020 --> 00:34:07,890
它代表了一个地方
It represents a place

546
00:34:07,890 --> 00:34:12,980
是存储你的未完成的代换的地方
where something is stored which is the substitutions that you haven't done.

547
00:34:12,980 --> 00:34:16,500
它是一个收集各种东西的地方
It's a place where everything accumulates,

548
00:34:16,500 --> 00:34:21,460
在那里，变量的名字与值关联在一起
where the names of the variables are associated with the values they have

549
00:34:21,460 --> 00:34:22,660
所以
such that,

550
00:34:22,660 --> 00:34:25,900
当你问某个名字是什么意思的时候
when you say, what dose this name mean,

551
00:34:25,900 --> 00:34:27,900
你要在一个环境中寻找答案
you look it up in an environment.

552
00:34:27,900 --> 00:34:30,410
所以环境是一个函数
So an environment is a function,

553
00:34:30,410 --> 00:34:31,940
或一张表
or a table,

554
00:34:31,940 --> 00:34:33,240
或类似的东西
or something like that.

555
00:34:33,240 --> 00:34:35,460
但它是一种结构化的表
But it's a structured sort of table.

556
00:34:35,460 --> 00:34:38,400
它是由框架构成
It's made out of things called frames.

557
00:34:40,860 --> 00:34:44,600
框架是环境的一部分Frames are pieces of environment,

558
00:34:44,600 --> 00:34:46,600
它们被链接在一起
and they are chained together,

559
00:34:46,600 --> 00:34:48,600
以某种很好的方式
in some nice ways,

560
00:34:48,600 --> 00:34:53,080
就是叫做#TBD之类的东西
by what's called parent links or something like that.

561
00:34:53,080 --> 00:34:55,310
这里
So here,

562
00:34:55,310 --> 00:34:57,620
有一个环境结构
we have an environment structure

563
00:34:57,620 --> 00:35:04,900
它由三个环境组成，分别是A，B和C
consisting of three environments, basically, A, B, and C.

564
00:35:04,900 --> 00:35:08,580
D也是环境，但它和C是一样的
d is also an environment, but it's the same one,

565
00:35:08,580 --> 00:35:11,010
它们共享了同一个环境
they share.

566
00:35:11,010 --> 00:35:14,280
那就是赋值的精髓所在
And that's the essence of assignment.

567
00:35:14,280 --> 00:35:16,100
如果我改变了一个变量
If I change a variable,

568
00:35:16,100 --> 00:35:19,800
比如改变这个变量的值
a value of a valuable that lives here, like that one,

569
00:35:19,800 --> 00:35:23,500
那么它将在所有地方都可见
it should be visible from all places that you're looking at it from.

570
00:35:23,500 --> 00:35:24,840
用x来举例
Take this one, x.

571
00:35:24,840 --> 00:35:28,190
如果我将x改为4
If I change the x to four,

572
00:35:28,190 --> 00:35:30,190
在其他地方也是可见的
it's visible from other places.

573
00:35:30,190 --> 00:35:32,190
但是我们现在不去关心这个
But I'm not going to worry about that right now.

574
00:35:32,190 --> 00:35:34,310
过一会儿会详细讨论这个问题
We're going to talk a lot about that in a little while.

575
00:35:34,310 --> 00:35:36,540
这里有什么？
What do we have here?

576
00:35:36,540 --> 00:35:39,220
这些叫做框架。这是一个框架
Well, these are called frames. Here is a frame,

577
00:35:39,220 --> 00:35:40,620
这是一个框架
here's a frame

578
00:35:40,620 --> 00:35:42,770
这也是一个框架
and here's a frame.

579
00:35:42,770 --> 00:35:45,200
A是一个环境
A is an environment which consists of

580
00:35:45,200 --> 00:35:48,170
它由框架II
the table label which is frame two,

581
00:35:48,170 --> 00:35:52,200
和框架I组成
followed by the table labeled frame one.

582
00:35:52,200 --> 00:35:54,870
在这个环境中
And, in this environment,

583
00:35:54,870 --> 00:36:00,200
在这个所谓的环境中，也就是框架II中
in say this environment, frame two,

584
00:36:00,200 --> 00:36:03,840
x和y是被约束的
x and y are bound.

585
00:36:03,840 --> 00:36:05,260
它们有值
They have values.

586
00:36:05,260 --> 00:36:07,180
对不起，是在框架I中
Sorry, in frame one

587
00:36:07,180 --> 00:36:09,520
在框架II中
In frame two,

588
00:36:09,520 --> 00:36:10,880
z被约束
z is bound,

589
00:36:10,880 --> 00:36:12,280
x被约束
and x is bound,

590
00:36:12,280 --> 00:36:14,780
并且y也是被约束的
and y is bound,

591
00:36:14,780 --> 00:36:17,420
但是我们看到的x的值
but the value of x that we see,

592
00:36:17,420 --> 00:36:19,640
从这个角度来看
looking from this point of view,

593
00:36:19,640 --> 00:36:22,230
是这个x，它的值是7
is this x. It's x is seven,

594
00:36:22,230 --> 00:36:24,840
而不是这个值为3的x
rather than this one which is three.

595
00:36:24,840 --> 00:36:30,100
我们称之为，这个x隐蔽了这个x
We say that this x shadows this x.

596
00:36:30,720 --> 00:36:32,980
从环境III
From environment three--

597
00:36:32,980 --> 00:36:34,450
从框架III
from frame three,

598
00:36:34,450 --> 00:36:35,730
从环境B
from environment b,

599
00:36:35,730 --> 00:36:37,450
它引用了框架III
which refers to frame three,

600
00:36:37,450 --> 00:36:44,010
变量n 和y被约束，x也被约束
we have variables n and y bound and also x.

601
00:36:44,010 --> 00:36:48,150
这个y把它隐蔽了
This y shadow this one.

602
00:36:48,150 --> 00:36:51,000
从这个角度来看
So the value, looking from this point of view,

603
00:36:51,000 --> 00:36:53,180
y的值是2
of y is two.

604
00:36:53,180 --> 00:36:55,280
从这个角度来看
The value for looking from this point of view

605
00:36:55,280 --> 00:36:59,620
m的值是1，x的值是3
and m is one. And the value, looking from this point of view, of x is three.

606
00:37:01,920 --> 00:37:03,150
所以，我们有了一个
So there we have

607
00:37:03,150 --> 00:37:06,060
由框架构成的非常简单的环境结构
a very simple environment structure made out of frames.

608
00:37:06,060 --> 00:37:10,700
它们与过程的应用相一致
These correspond to the applications of procedures.

609
00:37:10,700 --> 00:37:13,420
我们马上就会看到
And we'll see that in a second.

610
00:37:13,420 --> 00:37:18,690
现在要给你们看看我们构建的一些其他的很好的小结构
So now I have to make you some other nice little structure that we build.

611
00:37:20,560 --> 00:37:22,020
下一张幻灯片
Next slide,

612
00:37:22,020 --> 00:37:24,840
我们可以看到一个对象
we see an object,

613
00:37:24,840 --> 00:37:27,620
我们将要描绘它的过程
which I'm going to draw procedures.

614
00:37:27,620 --> 00:37:29,830
这是一个过程
This is a procedure.

615
00:37:29,830 --> 00:37:32,840
这个过程由两个部分组成
A procedure is made out of two parts.

616
00:37:32,840 --> 00:37:36,300
这有点像cons
It's sort of like a cons.

617
00:37:36,790 --> 00:37:39,440
不管怎样，它有两个部分
However, it's the two parts.

618
00:37:40,440 --> 00:37:45,420
第一个部分指向一些代码
The first part refers to some code,

619
00:37:45,420 --> 00:37:47,420
这些代码将会被执行
something that can be executed,

620
00:37:47,420 --> 00:37:50,530
你可以把它视作一组指令
a set of instructions, if you will. You can think of it that way.

621
00:37:50,530 --> 00:37:53,700
第二部分是环境
And the second part is the environment.

622
00:37:53,700 --> 00:37:56,710
这个过程就是全部了
The procedure is the whole thing.

623
00:37:56,710 --> 00:37:58,710
我们要用它
And we're going to have to use this

624
00:37:58,710 --> 00:38:05,910
来捕获出现在过程中的自由变量的值
to capture the values of the free variables that occur in the procedure.

625
00:38:05,910 --> 00:38:10,860
如果过程中出现一个变量，它不是约束变量就是自由变量
If a variable occurs in the procedure it's either bound in that procedure or free.

626
00:38:10,860 --> 00:38:12,380
如果它是约束变量
If it's bound,

627
00:38:12,380 --> 00:38:15,670
则它的值将很容易被找到
then the value will somehow be easy to find.

628
00:38:15,890 --> 00:38:18,910
它将存在于某个很容易找到的环境中
It will be in some easy environment to get at.

629
00:38:18,910 --> 00:38:20,660
如果它是自由变量
If it's free,

630
00:38:20,660 --> 00:38:23,020

we're going to have to have something that goes with the procedure

631
00:38:23,020 --> 00:38:26,280

that says where we'll go look for its value.

632
00:38:26,280 --> 00:38:29,210
现在为什么的理由还不清楚
And the reasons why are not obvious yet,

633
00:38:29,210 --> 00:38:31,760
但很快就要真相大白了
but will be soon.

634
00:38:31,760 --> 00:38:35,190
这里有一个对象，它是个混合的对象
So here's a procedure object. It's a composite object

635
00:38:35,190 --> 00:38:42,400
由一些代码和一个环境结构组成
consisting of a piece of code and a environment structure.

636
00:38:42,400 --> 00:38:46,190
现在我要告诉你们一些全新的规则
Now I will tell you the new rules, the complete new rules,

637
00:38:46,190 --> 00:38:49,200
关于执行的规则
for evaluation.

638
00:38:50,320 --> 00:38:52,960
这里只有两条规则
The first rule is-- there's only two of them.

639
00:38:52,960 --> 00:38:56,920
这些规则与代换模型规则相对应
These correspond to the substitution model rules.

640
00:38:56,920 --> 00:38:59,480
第一条规则是用来解决
And the first one has to do with

641
00:38:59,480 --> 00:39:04,140
如何把一个过程，应用到它参数上的问题的
how do you apply a procedure to its arguments?

642
00:39:05,020 --> 00:39:08,820
程序对象被应用于一组参数
And a procedural object is applied to a set of arguments

643
00:39:08,820 --> 00:39:10,940
是通过构建一个新的框架来完成
by constructing a new frame.

644
00:39:10,940 --> 00:39:15,830
那个框架将包含形式参数
That frame will contain the mapping of the former parameters to the actual
parameters

645
00:39:15,830 --> 00:39:20,960
对调用中使用的实际参数的映射
of the arguments that were supplied in the call.

646
00:39:20,960 --> 00:39:22,310
如你所知
As you know,

647
00:39:22,310 --> 00:39:26,940
当我们建立一个过程，如lambda x， x乘y
when we make up a call to a procedure like lambda x times x y,

648
00:39:26,940 --> 00:39:29,900
然后我们以3为参数调用它
and we call that with the argument three,

649
00:39:29,900 --> 00:39:33,870
那么我们需要某个从x到3的映射
then we're going to need some mapping of x to three.

650
00:39:33,870 --> 00:39:36,520
这与之前的代换是一样的
It's the same thing as later substituting,

651
00:39:36,520 --> 00:39:41,520
在旧的模型中，x代换为3
if you will, the three for the x in the old model.

652
00:39:41,520 --> 00:39:44,990
所以我要建立一个框架
So I'm going to build a frame which contains x equals three

653
00:39:44,990 --> 00:39:48,160
在框架中包含x等于3的这个信息
as the information in that frame.

654
00:39:48,160 --> 00:39:50,160
现在
Now,

655
00:39:50,160 --> 00:39:53,960
过程的体即将被执行
the body of the procedure will then have to be evaluated which is this,

656
00:39:53,960 --> 00:39:57,610
它将在一个环境中执行
and will be evaluated in an environment

657
00:39:57,610 --> 00:40:08,370
这个环境是由我们创建的新框架组合而成
which is constructed by adjoining the new frame that we just made

658
00:40:08,370 --> 00:40:12,770
它是我们所应用的哦成的一部分
to the environment which was part of the procedure that we applied.

659
00:40:12,770 --> 00:40:17,820
所以，举个例子
So I'm going to make a little example of that here.

660
00:40:18,680 --> 00:40:24,920
假设我有一些环境
Supposing I have some environment.

661
00:40:24,920 --> 00:40:27,570
画个方框代表它
Here's a frame which represents it.

662
00:40:27,570 --> 00:40:32,830
以及一些过程--我画圆来代表它们，因为这比小三角形好画--
And some procedure-- which I'm going to draw with circles here because it's easier than little triangles--

663
00:40:32,830 --> 00:40:37,460
抱歉，是菱形
Sorry, those are rhombuses,

664
00:40:37,460 --> 00:40:42,400
小块菱形的果冻之类的东西
rhomboidal little pieces of fruit jelly or something.

665
00:40:42,400 --> 00:40:45,700
这有一个使用这个环境的过程
So here's a procedure which takes this environment.

666
00:40:45,700 --> 00:40:48,160
这个过程有一些代码
And the procedure has a piece of code,

667
00:40:48,160 --> 00:40:50,120
是一个lambda表达式
which is a lambda expression,

668
00:40:50,120 --> 00:40:52,960
约束了x和y
which binds x and y

669
00:40:52,960 --> 00:40:57,760
然后执行了表达式e
and then executes an expression, e.

670
00:40:57,760 --> 00:40:59,560
这是一个过程
And this is the procedure.

671
00:40:59,560 --> 00:41:01,060
我们叫它p
We'll call it p.

672
00:41:01,060 --> 00:41:06,180
我希望将这个过程应用于3和4
I wish to apply that procedure to three and four.

673
00:41:06,180 --> 00:41:09,530
所以我在这写(p 3 4)
So I want to do p of three and four.

674
00:41:09,530 --> 00:41:12,890
我要做的事情是，是创建一个新的框架
What I'm going to do, of course, is make a new frame.

675
00:41:12,890 --> 00:41:15,140
我建立了一个框架
I build a frame

676
00:41:15,140 --> 00:41:18,640
框架中x等于3
which contains x equals three,

677
00:41:18,640 --> 00:41:21,240
y等于4
and y equals four.

678
00:41:21,240 --> 00:41:24,130
我要把这个框架
I'm going to connect that frame

679
00:41:24,130 --> 00:41:26,130
连接到这一个框架上
to this frame over here.

680
00:41:27,120 --> 00:41:29,680
对于这个环境
And then this environment,

681
00:41:29,680 --> 00:41:31,300
我把它叫做B
with I will call b,

682
00:41:31,300 --> 00:41:37,070
我会在这个环境中执行e的体
is the environment in which I will evaluate the body of e.

683
00:41:39,370 --> 00:41:41,370
现在
Now,

684
00:41:41,370 --> 00:41:46,290
e可能包含了x和y的引用以及一些别的东西
e may contain references to x and y and other things.

685
00:41:46,290 --> 00:41:50,540
x和y的值在这里
x and y will have values right here.

686
00:41:50,540 --> 00:41:54,300
其他的变量的值在这里
Other things will have their values here.

687
00:41:54,700 --> 00:41:56,940
怎样才能获取这个框架呢？
How do we get this frame?

688
00:41:56,940 --> 00:41:59,450
我们通过过程构建来完成
That we do by the construction of procedures

689
00:41:59,450 --> 00:42:01,840
这就是另一条规则了
which is the other rule.

690
00:42:01,840 --> 00:42:05,140
请看下一张幻灯片
And I think that's the next slide.

691
00:42:05,140 --> 00:42:07,310
规则二
Rule two,

692
00:42:07,310 --> 00:42:09,900
当一个lambda表达式被执行时
when a lambda expression is evaluated,

693
00:42:09,900 --> 00:42:13,650
相对于某个特定的环境--
relative to a particular environment--

694
00:42:13,650 --> 00:42:14,700
看
See,

695
00:42:14,700 --> 00:42:18,120
获取一个过程的方式就是执行一个lambda表达式
the way I get a procedure is by evaluating the lambda expression.

696
00:42:18,120 --> 00:42:19,850
这里有一个lambda表达式
Here's a lambda expression.

697
00:42:19,850 --> 00:42:21,630
通过执行它
By evaluating it,

698
00:42:21,630 --> 00:42:24,860
我获得了一个可以应用于3的过程
I get a procedure which I can apply to three.

699
00:42:24,860 --> 00:42:26,650
现在lambda表达式
Now this lambda expression

700
00:42:26,650 --> 00:42:31,540
在一个y已被定义的环境中执行
is evaluated in an environment where y is defined.

701
00:42:31,540 --> 00:42:36,390
我希望这个过程的体中包括的y是自由变量
And I want the body of this which contains a free version of y.

702
00:42:36,390 --> 00:42:38,660
在这里面，y是自由变量
y is free in here,

703
00:42:38,660 --> 00:42:41,230
它在其他的地方都是被约束的
it's bound over the whole thing,

704
00:42:41,230 --> 00:42:43,190
但在这里是自由变量
but it's free over here.

705
00:42:43,190 --> 00:42:47,060
我想让这个y成为它
I want that y to be this one.

706
00:42:47,060 --> 00:42:55,280
我在y被创建的环境中执行这个过程的体
I evaluate this body of this procedure in the environment where y was created.

707
00:42:55,280 --> 00:42:58,860
#TBD
That's this kind of thing, because that was done by application.

708
00:42:58,860 --> 00:43:00,030
现在
Now,

709
00:43:00,030 --> 00:43:02,850
如果我还想查找y的值
if I ever want to look up the value of y,

710
00:43:02,850 --> 00:43:04,320
我就必须知道它在哪
I have to know where it is.

711
00:43:04,320 --> 00:43:06,420
因此，这个过程在被创建时
Therefore, this procedural was created,

712
00:43:06,420 --> 00:43:10,060
过程的创建，也就是lambda表达式的执行结果
the creation of the procedure which is the result of evaluating that lambda expression

713
00:43:10,060 --> 00:43:17,840
最好是获取一个指针或记住y被约束在哪个框架中
had better capture a pointer or remember the frame in which y was bound.

714
00:43:17,840 --> 00:43:20,960
这就是这个规则的内容
So that's what this rule is telling us.

715
00:43:20,960 --> 00:43:24,310
那么，举个例子
So, for example,

716
00:43:24,310 --> 00:43:30,680
如果我恰好执行了一个lambda表达式
if I happen to be evaluating a lambda expression,

717
00:43:30,680 --> 00:43:33,780
在e中的lambda表达式
lambda expression in e,

718
00:43:33,780 --> 00:43:40,990
#TBD
lambda of say, x and y, let's call it g in e,

719
00:43:40,990 --> 00:43:42,760
执行它
evaluating that.

720
00:43:42,760 --> 00:43:46,880
这些事的意义就是我现在构建了一个过程对象
all that means is I now construct a procedure object.

721
00:43:46,880 --> 00:43:48,560
e是某个环境
e is some environment.

722
00:43:48,560 --> 00:43:51,520
有个指针指向e
e is something which has a pointer to it.

723
00:43:51,520 --> 00:43:58,240
我构建了一个过程对象指向了这个环境
I construct a procedure object that points up to that environment,

724
00:43:58,240 --> 00:44:00,450
它的代码
where the code of that

725
00:44:00,450 --> 00:44:05,920
是一个lambda表达式，或者其他可以翻译为lambda表达式的东西
is a lambda expression or whatever that translates into.

726
00:44:05,920 --> 00:44:12,020
而这就是一个过程
And this is the procedure.

727
00:44:12,020 --> 00:44:14,940
所以这个产物对我来说
So this produces for me--

728
00:44:14,940 --> 00:44:16,370
这个对象
this object here,

729
00:44:16,370 --> 00:44:18,370
这个环境指针
this environment pointer,

730
00:44:18,370 --> 00:44:22,520
获取了lambda表达式执行所处于的环境
captures the place where this lambda expression was evaluated,

731
00:44:22,520 --> 00:44:25,360
定义所使用的环境
where the definition was used,

732
00:44:25,360 --> 00:44:29,960
创建一个过程时的定义所用的环境
where the definition was used to make a procedure,

733
00:44:29,960 --> 00:44:32,540
从而创建了过程
to make the procedure.

734
00:44:32,540 --> 00:44:37,040
所以，它将环境从定义过程的地方取出
So it picks up the environment from the place where that procedure was defined,

735
00:44:37,040 --> 00:44:39,350
将它保存在过程自己内部
stores it in the procedure itself,

736
00:44:39,350 --> 00:44:41,140
之后当过程被调用时
and then when the procedure is used,

737
00:44:41,140 --> 00:44:43,820
它在被定义时的环境
the environment where it was defined is extended

738
00:44:43,820 --> 00:44:48,240
将由新的框架扩充
with the new frame.

739
00:44:48,240 --> 00:44:52,790
这给了我们一个放置有值的变量的地方
So this gives us a locus for putting where a variable has a value.

740
00:44:52,790 --> 00:44:53,960
举个例子
And, for example,

741
00:44:53,960 --> 00:44:57,520
如果有很多东西指向那这个环境
if there are lots of guys pointing in at that environment,

742
00:44:57,520 --> 00:45:01,030
它们就会共享这个环境
then they share that place.

743
00:45:01,030 --> 00:45:03,660
我们很快就会更进一步了解它们
And we'll see more of that shortly.

744
00:45:03,660 --> 00:45:06,293
现在你们有了一个新模型
Well, now you have a new model

745
00:45:06,290 --> 00:45:10,953
我们用它来理解程序的执行
for understanding the execution of programs.

746
00:45:10,950 --> 00:45:13,106
我觉得现在我应该解答一些问题了
I suppose I'll take questions now,

747
00:45:13,100 --> 00:45:17,600
之后我们再继续
and then we'll go on and use that for something.

748
00:45:17,600 --> 00:45:19,520
学生：这么说是对的吗？
AUDIENCE: Is it right to say then, 

749
00:45:19,520 --> 00:45:23,960
环境就是被连接在一起的框架开始的地方--
the environment is that linked chain of frames starting with--

750
00:45:23,960 --> 00:45:25,480
教授：对的
PROFESSOR: That's right.

751
00:45:25,480 --> 00:45:27,440
学生：通过它能够取回所有的框架？
AUDIENCE:  working all the way back?

752
00:45:27,440 --> 00:45:32,160
教授：是的，环境是一系列被连接在一起的框架
PROFESSOR: Yes, the environment is a sequence of frames linked together.

753
00:45:32,160 --> 00:45:36,600
我对它的理解是，它是指向第一个框架的指针
And the way I like to think about it, it's the pointer to the first one,

754
00:45:36,600 --> 00:45:41,506
因为一旦你获得了它，你就能拿到所有的框架
because once you've got that you've got them all.

755
00:45:43,500 --> 00:45:45,500
还有谁有问题吗？
Anybody else?

756
00:45:45,500 --> 00:45:49,366
学生：有这种可能吗？在两个不同的环境中执行
AUDIENCE: Is it possible to evaluate a procedure or to define a procedure in two different environments

757
00:45:49,360 --> 00:45:53,206
或定义一个过程，使得它有不同的行为，并且有指向两个环境的指针--
such that it will behave differently, and have pointers to both--

758
00:45:53,200 --> 00:45:56,906
教授：噢，是的。同一个过程不会有两个不同环境
PROFESSOR: Oh, yes. The same procedure is not going to have two different environments.

759
00:45:56,900 --> 00:45:59,020
同样的代码
The same code,

760
00:45:59,020 --> 00:46:00,820
同样的lambda表达式
the same lambda expression

761
00:46:00,820 --> 00:46:05,793
可以在两个不同的环境中执行
can be evaluated in two environments producing two different procedures.

762
00:46:05,790 --> 00:46:07,180
每个过程--
Each procedure--

763
00:46:07,180 --> 00:46:09,953
学生：它们的定义有同样的名字，它们的操作--
AUDIENCE: Their definition has the same name. Their operation--

764
00:46:09,950 --> 00:46:12,380
教授：它们定义是写起来是一样的，使用同样的字母
PROFESSOR: The definition is written the same, with the same characters.

765
00:46:12,380 --> 00:46:14,933
我能执行那一组字母
I can evaluate that set of characters,

766
00:46:14,930 --> 00:46:18,146
或定义的列表结构之类的东西
whatever, that list structure that defines,

767
00:46:18,140 --> 00:46:20,806
那只是文本表示
that is the textual representation.

768
00:46:20,800 --> 00:46:25,420
我可以在两个不同环境种执行它，产生两个不同的过程
I can evaluate that in two different environments producing two different procedures.

769
00:46:25,420 --> 00:46:27,420
每一个过程
Each of those procedures

770
00:46:27,420 --> 00:46:32,346
有它们自己的一组局部变量
has its own local sets of variables,

771
00:46:32,340 --> 00:46:36,106
我们很快就会看到
and we'll see that right now.

772
00:46:36,100 --> 00:46:38,953
还有其他人吗？
Anybody else?

773
00:46:42,220 --> 00:46:46,520
好，谢谢你们，我们休息一会
OK, thank you. Let's take a break. 

774
00:46:46,520 --> 00:47:03,173
[音乐]
[MUSIC PLAYING]

775
00:47:05,610 --> 00:47:22,673
[音乐]
[MUSIC PLAYING]

776
00:47:22,670 --> 00:47:26,420
我现在已经为你们做了一件非常糟糕的事情
Well, now I've done this terrible thing to you.

777
00:47:26,420 --> 00:47:32,233
我引入了一个非常复杂的东西
I've introduced a very complicated thing,

778
00:47:32,230 --> 00:47:34,353
赋值
assignment,

779
00:47:34,350 --> 00:47:40,706
它摧毁了我们程序中大部分的，有趣的数学特性
which destroys most of the interesting mathematical properties of our programs.

780
00:47:40,700 --> 00:47:42,986
我为什么要做这件事呢
Why should I have done this?

781
00:47:42,980 --> 00:47:45,860
这样做可能有什么好处吗？
What possible good could this do?

782
00:47:45,860 --> 00:47:49,340
很明显，这不是一个什么好东西
Clearly not a nice thing,

783
00:47:49,340 --> 00:47:52,566
因此我最好有一个好的解释
so I better have a good excuse.

784
00:47:52,560 --> 00:47:54,806
让我们来小小地玩一下
Well, let's do a little bit of playing,

785
00:47:54,800 --> 00:47:58,686
首先，我们写些非常有趣的带赋值的程序
first of all, with some very interesting programs that have assignment.

786
00:47:58,680 --> 00:48:01,293
来理解它们的特殊之处
Understand something special about them

787
00:48:01,290 --> 00:48:04,313
这些特殊之处使赋值变得有价值
that makes them somewhat valuable.

788
00:48:04,310 --> 00:48:07,553
我们从一个非常简单的程序开始
Start with a very simple program

789
00:48:07,550 --> 00:48:10,353
我把这个程序叫做make-counter
I'm going to call make-counter.

790
00:48:10,350 --> 00:48:24,066
我要把它定义为
I'm going to define make-counter

791
00:48:24,060 --> 00:48:29,026
接受一个参数n的过程
to be a procedure of one argument n

792
00:48:29,020 --> 00:48:34,193
并且它的返回值是一个没有参数的过程--
which returns as its value a procedure of no arguments--

793
00:48:34,190 --> 00:48:36,673
一个生成过程的过程--
a procedure that produces a procedure--

794
00:48:36,670 --> 00:48:47,546
这个过程把n的值设为n加1
which sets n to the increment of n

795
00:48:47,540 --> 00:48:53,700
并且返回n的值
and returns that value of n.

796
00:48:54,850 --> 00:48:57,546
现在，我们要研究它的行为
Now we're going to investigate the behavior of this.

797
00:48:57,546 --> 00:48:59,540
它很有趣
It's a sort of interesting thing. 

798
00:48:59,540 --> 00:49:01,453
为了研究它的行为
In order to investigate the behavior,

799
00:49:01,450 --> 00:49:03,833
我需要建立一个环境模型
I have to make an environment model,

800
00:49:03,830 --> 00:49:08,006
因为我们不能通过其他的方式来理解它
because we can't understand this any other way.

801
00:49:08,006 --> 00:49:10,000
所以我们开始吧
So let's just do that.

802
00:49:10,000 --> 00:49:13,246
我们从这里开始
We start out with some sort of--

803
00:49:13,240 --> 00:49:16,133
假设机器天生就有一个全局的环境
let's say there is a global environment that the machine is born with.

804
00:49:16,130 --> 00:49:19,780
我们把它叫做全局环境
Global we'll call it.

805
00:49:19,780 --> 00:49:24,440
它内部有一堆初始化的东西
And it's going to have in it a bunch of initial things.

806
00:49:24,440 --> 00:49:25,726
我们都知道它里面有什么
We all know what it's got.

807
00:49:25,720 --> 00:49:32,133
这里面有+和*
It's got things in it like say, plus, and times,

808
00:49:32,130 --> 00:49:38,573
/，-和CAR
and quotient, and difference, and CAR,

809
00:49:38,570 --> 00:49:41,453
以此类推
and etcetera,

810
00:49:41,450 --> 00:49:42,720
有很多东西
lots of things.

811
00:49:42,720 --> 00:49:44,426
我不知道它们是什么
I don't know what they are,

812
00:49:44,420 --> 00:49:45,986
一些#TBD
some various squiggles

813
00:49:45,980 --> 00:49:50,566
机器一开始就有这些特性
that are the things the machine is born with.

814
00:49:50,560 --> 00:49:54,373
通过在这做定义
And by doing the definition here, 

815
00:49:54,370 --> 00:49:56,166
我要做的是--
what I plan to do--

816
00:49:56,160 --> 00:49:57,313
我在干什么呢？
Well, what am I doing?

817
00:49:57,310 --> 00:49:59,726
我要把它关联到全局环境上
I'm doing this relative to the global environment.

818
00:49:59,720 --> 00:50:03,460
这是我的环境指针
So here's my environment pointer.

