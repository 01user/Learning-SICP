1
00:00:00,000 --> 00:00:01,980
[MUSIC PLAYING]
[音乐]

2
00:00:11,500 --> 00:00:15,790
赋值、状态和副作用
Assignment, State, and Side-effects

3
00:00:15,790 --> 00:00:22,000
教授：到目前为止 我们编写程序
PROFESSOR: Well, so far we've invented enough programming

4
00:00:22,000 --> 00:00:26,780
做了一些非常复杂事情
to do some very complicated things.

5
00:00:26,780 --> 00:00:29,660
并且关于编程你们确实已经学到了很多
And you surely learned a lot about programming at this point.

6
00:00:29,660 --> 00:00:31,660
你们已经学习了几乎所有的
You've learned almost all the most important tricks

7
00:00:31,660 --> 00:00:36,200
那些拥有大量经验的人才能领悟的技巧
that usually don't get taught to people until they have had a lot of experience.

8
00:00:36,200 --> 00:00:40,750
例如，数据导向编程是一个主要的技巧
For example, data directed programming is a major trick,

9
00:00:40,750 --> 00:00:43,680
昨天你们也看到了一种解释型语言
and yesterday you also saw an interpreted language.

10
00:00:43,680 --> 00:00:48,460
我们所做的这一切
We did this all in a computer language,

11
00:00:48,460 --> 00:00:49,800
目前来讲
at this point,

12
00:00:49,800 --> 00:00:53,180
都是在一种没有赋值语句的计算机语言中完成的
where there was no assignment statement.

13
00:00:53,180 --> 00:00:55,860
想必 对于你们中已经见过
And presumably, for those of you who've

14
00:00:55,860 --> 00:00:58,320
Basic或者Pascal或者其他什么语言的人来说
seen your Basic or Pascal or whatever,

15
00:00:58,320 --> 00:01:01,340
也许，赋值语句被认为是最重要的东西
that's usually considered the most important thing.

16
00:01:01,340 --> 00:01:03,820
今天我们将要做一些糟糕的事情
Well today, we're going to do something horrible.

17
00:01:03,820 --> 00:01:06,300
我们要把赋值语句加进来
We're going to add an assignment statement.

18
00:01:06,300 --> 00:01:09,140
既然在没有赋值语句的时候，我们都可以很好地完成工作
And since we can do all these wonderful things without it,

19
00:01:09,140 --> 00:01:10,500
为什么我们还要把它加进来呢？
why should we add it?

20
00:01:10,500 --> 00:01:12,540
我们需要认识到一件重要的事情
 An important thing to understand is

21
00:01:12,540 --> 00:01:14,020
首先，我们要
that today we're going to

22
00:01:14,020 --> 00:01:16,020
定下一个原则
first of all, have a rule,

23
00:01:16,020 --> 00:01:17,930
而我们将一直遵守这个规则
which is going to always be obeyed,

24
00:01:17,930 --> 00:01:21,140
我们为语言引入新的特性的唯一原因
which is the only reason we ever add a feature to our language

25
00:01:21,140 --> 00:01:23,140
是因为有一个好的理由
is because there is a good reason.

26
00:01:23,140 --> 00:01:27,280
这个好理由就是能力
And the good reason is going to boil down to the ability,

27
00:01:27,280 --> 00:01:28,890
现在你获得了
you now get an ability

28
00:01:28,890 --> 00:01:31,510
把问题分解为不同的小部分
to break a problem into pieces that are different sets of pieces

29
00:01:31,510 --> 00:01:34,270
在过去你可能在不使用这种能力的情况下分解问题
then you could have broken it down without that,

30
00:01:34,270 --> 00:01:37,360
从而领悟解耦的另一种含义
give you another means of decomposition.

31
00:01:37,360 --> 00:01:39,450
我们这就开始
However, let's just start.

32
00:01:39,450 --> 00:01:41,880
我们从回顾我们的
Let me quick begin by reviewing

33
00:01:41,880 --> 00:01:47,590
现在已经有的这种语言出发
the kind of language that we have now.

34
00:01:47,590 --> 00:01:50,850
我们之前写的是所谓的函数式程序
We've been writing what's called functional programs.

35
00:01:50,850 --> 00:01:52,790
函数式程序
And functional programs

36
00:01:52,790 --> 00:01:58,030
是一种对数学真理的编码
are a kind of encoding of mathematical truths.

37
00:01:58,030 --> 00:02:00,510
例如，当我们看到
For example, when we look at

38
00:02:00,510 --> 00:02:04,570
像幻灯片上这样阶乘过程时
the factorial procedure that you see on the slide here,

39
00:02:04,570 --> 00:02:06,770
基本上是两个子句
it's basically two clauses.

40
00:02:06,770 --> 00:02:08,640
如果n是1，则结果是1
If n is one, the result is one,

41
00:02:08,640 --> 00:02:11,200
否则返回n乘以n-1的阶乘
otherwise n times factorial n minus one.

42
00:02:11,200 --> 00:02:12,560
这是n的阶乘
That's factorial of n.

43
00:02:12,560 --> 00:02:14,560
它就是n的阶乘
Well, that is factorial of n.

44
00:02:14,560 --> 00:02:16,870
如果用一些其他的
And written down in some other obscure notation

45
00:02:16,870 --> 00:02:20,910
那些你在微积分课堂上学到的晦涩的符号来写
that you might have learned in calculus classes,

46
00:02:20,910 --> 00:02:22,110
以数学上的逻辑来写
mathematical logic,

47
00:02:22,110 --> 00:02:26,530
如果n等于1
what you see there is if n equals one,

48
00:02:26,530 --> 00:02:29,900
那么n的阶乘结果是1，否则，
for the result of n factorial is one, otherwise,

49
00:02:29,900 --> 00:02:32,560
如果n大于1，则n的阶乘就是n乘以n-1的阶乘
greater than one, n factorial is n times n minus one factorial.

50
00:02:32,560 --> 00:02:34,560
#TBD
True statements,

51
00:02:34,560 --> 00:02:36,700
这就是我们一直以来用的那种语言
that's the kind of language we've been using.

52
00:02:36,700 --> 00:02:39,230
#TBD
And whenever we have true statements of that sort,

53
00:02:39,230 --> 00:02:46,940
有一种理解它们是如何工作的方法
there is a kind of, a way of understanding how they work

54
00:02:46,940 --> 00:02:51,120
就是这些过程可以#TBD
which is that such processes can be involved by substitution.

55
00:02:51,120 --> 00:02:54,140
来看第二张幻灯片
And so we see on the second slide here,

56
00:02:54,140 --> 00:03:00,040
我们理解执行的过程
that the way we understand the execution implied

57
00:03:00,040 --> 00:03:03,500
隐含在表达式的顺序中
by those statements in arranged in that order,

58
00:03:03,500 --> 00:03:11,380
就是你在过程体中连续地将形式参数，代换为实际参数的顺序
is that you do successive substitutions of arguments for formal parameters in the body of a procedure.

59
00:03:11,380 --> 00:03:14,610
这是基本上是一系列的等价代换
This is basically a sequence of equalities.

60
00:03:14,610 --> 00:03:17,250
4的阶乘是4乘以3的阶乘
Factorial four is four times factorial three.

61
00:03:17,250 --> 00:03:20,050
也就是4乘以3乘以2的阶乘
That is four times three times factorial of two

62
00:03:20,050 --> 00:03:21,010
以此类推
and so on.

63
00:03:21,010 --> 00:03:24,480
#TBD
We're always preserving truth.

64
00:03:24,480 --> 00:03:28,840
尽管我们正在讨论#TBD
Even though we're talking about true statements,

65
00:03:28,840 --> 00:03:31,960
这里会有超过一个#TBD
there might be more than one organization of these true statements

66
00:03:31,960 --> 00:03:35,560
来描述一个特定的函数的计算
to describe the computation of a particular function,

67
00:03:35,560 --> 00:03:38,420
这个特定的函数的值的计算
the computation of the value of a particular function.

68
00:03:38,420 --> 00:03:41,180
所以，让我来看下一个例子
So, for example, looking at the next one here.

69
00:03:41,180 --> 00:03:49,020
这有一个计算m与n的和的办法
Here is a way of looking at the sum of n and m.

70
00:03:49,020 --> 00:03:52,360
我们使用一个递归的过程来完成这个任务
And we did this one by a recursive process.

71
00:03:52,360 --> 00:03:58,640
它就是sum的增加，及n与m的减少
It's the increment of the sum of the decrement of n and m.

72
00:03:58,640 --> 00:04:05,620
当然，这里就是一些数学的逻辑，解释了这个方法
And, of course, there is some piece of mathematical logic here that describes that.

73
00:04:05,620 --> 00:04:10,820
就是sum的增加以及n和m的减少
It's the increment of the sum of the decrement of n and m,

74
00:04:10,820 --> 00:04:12,820
跟之前那个一样
just like that.

75
00:04:12,820 --> 00:04:17,040
所以这儿并没有什么特殊的魔法
So there's nothing particularly magic about that.

76
00:04:17,040 --> 00:04:20,010
当然，如果我们可以再来看一个相同的迭代过程
And, of course, if we can also look at an iterative process for the same,

77
00:04:20,010 --> 00:04:24,920
一个对于同样的函数进行逐步迭代的过程的程序
a program that evolves an iterative process, for the same function.

78
00:04:24,920 --> 00:04:28,650
这两个程序将得到同样的结果
These are two things that compute the same answer.

79
00:04:28,650 --> 00:04:35,530
我们就可以认为这两个程序在数学上是等效的
And we have equivalent mathematical truths that are arranged there.

80
00:04:35,530 --> 00:04:40,120
#TBD
And just the way you arrange those truths determine the particular process.

81
00:04:40,120 --> 00:04:43,810
#TBD
In the way choose and arrange them determines the process that's evolved.

82
00:04:43,810 --> 00:04:48,600
因此我们有讨论两个函数被计算的灵活性
So we have the flexibility of talking about both the function to be computed,

83
00:04:48,600 --> 00:04:50,600
#TBD
and the method by which it's computed.

84
00:04:50,600 --> 00:04:52,600
#TBD
So it's not clear we need more.

85
00:04:52,600 --> 00:04:55,500
然而，今天我要来讲这个糟糕的东西
However, today I'm going to this awful thing.

86
00:04:55,500 --> 00:04:58,540
我要给大家介绍赋值操作
I'm going to introduce this assignment operation.

87
00:04:58,540 --> 00:05:01,140
这是什么？
Now, what is this?

88
00:05:02,410 --> 00:05:09,220
首先，在编程语言中有另一种语句
Well, first of all, there is going to be another kind of kind of statement, if you will,

89
00:05:09,220 --> 00:05:12,040
这种语句叫做SET！
in a programming language called Set!

90
00:05:12,040 --> 00:05:18,100
它可以用来进行赋值，我在后面加上一个感叹号
Things that do things like assignment, I'm going to put exclamation points after.

91
00:05:18,100 --> 00:05:20,960
我马上就讲这个感叹号是什么意思
We'll talk about what that means in a second.

92
00:05:20,960 --> 00:05:23,010
这个感叹号，与问号类似
The exclamation point, again like question mark,

93
00:05:23,010 --> 00:05:25,880
是我们给名字随意加的符号
is an arbitrary thing we attach to the symbol which is the name,

94
00:05:25,880 --> 00:05:27,880
它对于系统来说没有意义
has no significance to the system.

95
00:05:27,880 --> 00:05:30,210
它唯一的意义就是告诉我们
The only significance is to me and you

96
00:05:30,210 --> 00:05:34,870
注意这里是某种赋值
to alert you that this is an assignment of some sort.

97
00:05:35,520 --> 00:05:38,220
但是我们要给某个变量
But we're going to set a variable

98
00:05:38,220 --> 00:05:41,600
赋一个值
to a value.

99
00:05:43,600 --> 00:05:45,130
这意味着
And what that's going to mean

100
00:05:45,130 --> 00:05:48,400
在某个时间点发生了一些事情
is that there is a time at which something happens.

101
00:05:48,400 --> 00:05:49,860
这是一个时间点
Here's a time.

102
00:05:49,860 --> 00:05:52,450
如果时间以这个方向流动
If I have time going this way,

103
00:05:52,450 --> 00:05:54,820
#TBD
it's a time access.

104
00:05:54,820 --> 00:05:58,170
时间在纸面上由上到下地流逝
Time progresses by walking down the page.

105
00:05:58,170 --> 00:06:00,920
赋值是第一个
Then an assignment is the first thing we have

106
00:06:00,920 --> 00:06:05,580
使过去和未来之间产生差别的事物
that produces the difference between a before and an after.

107
00:06:05,580 --> 00:06:08,950
我们之前写的所有程序
All the other programs that we've written,

108
00:06:08,950 --> 00:06:10,680
都不包含赋值
that have no assignments in them,

109
00:06:10,680 --> 00:06:13,760
这些程序以怎样的顺序进行执行都没关系
the order in which they were evaluated didn't matter.

110
00:06:13,760 --> 00:06:15,960
但是赋值比较特殊
But assignment is special,

111
00:06:15,960 --> 00:06:17,960
它使时间中产生了一个时间点
it produces a moment in time.

112
00:06:17,960 --> 00:06:25,340
因此在set!出现之前和之后中间有一个时间点，
So there is a moment before the set occurs and after,

113
00:06:27,340 --> 00:06:33,080
使得在这个时间点之后
such that after this moment in time,

114
00:06:33,080 --> 00:06:45,620
变量有了一个值，value 
the variable has the value, value.

115
00:06:48,100 --> 00:06:52,050
与这个变量之前的值无关
Independent of what value it had before,

116
00:06:52,050 --> 00:06:56,500
set!改变了它的值
set! changes the value of the variable.

117
00:06:56,500 --> 00:06:58,750
在此之前
Until this moment,

118
00:06:58,750 --> 00:07:02,160
我们都没遇到过发生这样改变的情况
we had nothing that changed.

119
00:07:02,160 --> 00:07:04,320
举例来说
So, for example,

120
00:07:04,320 --> 00:07:06,230
我们可以想到的一件事是
one of the things we can think of

121
00:07:06,230 --> 00:07:09,420
我们写的一些过程比如阶乘的程序
is that the procedures we write for something like factorial

122
00:07:09,420 --> 00:07:13,170
事实上与数学中的阶乘函数完全相同
are in fact pretty much identical to the function factorial.

123
00:07:13,170 --> 00:07:16,730
4的阶乘，如果我写fact4
Factorial of four, if I write fact4,

124
00:07:16,730 --> 00:07:19,360
它将独立于它的上下文
independent of what context it's in,

125
00:07:19,360 --> 00:07:21,290
也独立于我写几遍
and independent of how many times I write it,

126
00:07:21,290 --> 00:07:23,290
我总能得到同样的结果
I always get the same answer.

127
00:07:23,290 --> 00:07:24,610
结果永远是24
It's always 24.

128
00:07:24,610 --> 00:07:29,710
它是参数到到结果的唯一映射
It's a unique map from the argument to the answer.

129
00:07:29,710 --> 00:07:33,020
迄今为止，我们之前写的所有程序都是这样的
And all the programs we've written so far are like that.

130
00:07:33,020 --> 00:07:36,340
然而，当我赋值的时候，一切就不同了
However, once I have assignment, that isn't true.

131
00:07:36,340 --> 00:07:38,340
举个例子
So, for example,

132
00:07:38,340 --> 00:07:49,240
如果我将count定义为1
if I were to define count to be one.

133
00:07:49,240 --> 00:07:54,010
然后定义一个过程
And then I'm going to define also a procedure,

134
00:07:54,010 --> 00:07:59,210
名为demo的简单过程
a simple procedure called demo,

135
00:07:59,210 --> 00:08:03,840
它接受参数x，并执行下面的操作
which takes argument x and does the following operations.

136
00:08:03,840 --> 00:08:09,620
首先set! x为x加1，
It first sets x to x plus one.

137
00:08:09,620 --> 00:08:12,280
我勒个去，这看起来就像FORTRAN，是吧？
My gosh, this looksjust like FORTRAN, right--

138
00:08:12,280 --> 00:08:15,370
只是用了些有趣的语法
in a funny syntax.

139
00:08:15,370 --> 00:08:21,880
然后加上x count
And then add to x count,

140
00:08:21,880 --> 00:08:24,210
哦，我刚犯了个错
Oh, I just made a mistake.

141
00:08:24,210 --> 00:08:25,310
我的意思是
I want to say,

142
00:08:25,310 --> 00:08:30,370
set! count为1加上count
set! count to one plus count.

143
00:08:30,370 --> 00:08:34,120
就是我在这里定义的这个
It's this thing defined here.

144
00:08:34,120 --> 00:08:39,400
然后x和count相加
And then plus x count.

145
00:08:39,400 --> 00:08:42,210
然后就可以试着运行这个过程了
Then I can try this procedure.

146
00:08:42,210 --> 00:08:43,600
让我们运行它
Let's run it.

147
00:08:43,600 --> 00:08:47,220
假设我可以输入
So, suppose I get a prompt and I say,

148
00:08:47,220 --> 00:08:51,740
我输入demo 3
 demo 3

149
00:08:51,740 --> 00:08:53,740
这里发生了什么？Well, what happens here?

150
00:08:53,740 --> 00:08:55,280
发生的第一件事情是
The first thing that happens

151
00:08:55,300 --> 00:08:56,890
count现在是1
is count is currently one.

152
00:08:56,890 --> 00:08:58,890
现在，这是一个时间点
Currently, there is a time.

153
00:08:58,890 --> 00:09:00,290
我们在讨论时间点
We're talking about time.

154
00:09:00,290 --> 00:09:02,290
x的值为3
x gets three.

155
00:09:02,290 --> 00:09:04,290
在这个时刻
At this moment,

156
00:09:04,290 --> 00:09:08,010
count增加了，所以count是2
I say, oh yes, count is incremented, so count is two.

157
00:09:08,010 --> 00:09:10,540
2加3等于5
two plus three is five.

158
00:09:10,540 --> 00:09:13,650
所以结果是5
So the answer I get out is five.

159
00:09:13,650 --> 00:09:23,000
然后我再一次，输入demo 3
Then I say, demo of say, three again.

160
00:09:23,000 --> 00:09:25,430
结果是什么？
What do I get?

161
00:09:25,430 --> 00:09:28,100
现在count是2，它不再是1了
Well, now count is two, it's not one anymore,

162
00:09:28,100 --> 00:09:30,610
因为我让count加1了
because I have incremented it.

163
00:09:30,610 --> 00:09:32,720
但现在我执行这个过程，
But now I go through this process,

164
00:09:32,720 --> 00:09:34,080
x的值为3
three goes into x,

165
00:09:34,080 --> 00:09:37,840
count变为1加count，因此现在是3了
count becomes one plus count, so that's three now.

166
00:09:37,840 --> 00:09:39,620
这两个相加是6
The sum of those two is six,

167
00:09:39,620 --> 00:09:41,820
所以结果是6
so the answer is six.

168
00:09:41,820 --> 00:09:43,030
我们可以发现
And what we see

169
00:09:43,030 --> 00:09:44,950
同样的表达式
is the same expression

170
00:09:44,950 --> 00:09:48,330
却得到了不同的结果
leads to two different answers,

171
00:09:48,330 --> 00:09:51,490
因为时间的作用
depending upon time.

172
00:09:51,490 --> 00:09:54,040
所以demo不是函数
So demo is not a function,

173
00:09:54,040 --> 00:09:59,460
它没有计算一个数学中的函数
does not compute a mathematical function.

174
00:09:59,460 --> 00:10:02,660
事实上，你可以知道这是为什么
In fact, you could also see why now, of course,

175
00:10:02,660 --> 00:10:07,470
因为这里是第一处代换模型失效的地方
this is the first place where the substitution model isn't going to work.

176
00:10:07,470 --> 00:10:10,960
它弄死了代换模型
This kills the substitution model dead.

177
00:10:10,960 --> 00:10:16,070
哲学家可能注意到一些小麻烦
You know, with quotation there were some little problems that a philosopher might notice

178
00:10:16,070 --> 00:10:22,340
因为你不得不去担心在#TBD的时候能如何代换
with the substitutions, because you have to worry about what deductions you can make when you substitute into quotes,

179
00:10:22,340 --> 00:10:24,340
如果你被允许代换的话
if you're allowed to do that at all.

180
00:10:24,340 --> 00:10:26,000
但是
But

181
00:10:26,000 --> 00:10:28,110
在这里代换模型已经死了
here the substitution model is dead,

182
00:10:28,110 --> 00:10:29,640
他什么也不能做了
can't do anything at all.

183
00:10:29,640 --> 00:10:30,570
因为
Because,

184
00:10:30,570 --> 00:10:36,970
假设我想用代换模型来考虑count的代换
Supposing I wanted to use a substitution model to consider substituting for count?

185
00:10:36,970 --> 00:10:41,578
如果我在这里和这里进行代换
Well, my gosh, if I substitute for here and here,

186
00:10:41,570 --> 00:10:44,064
它们是不同的
they're different ones.

187
00:10:44,060 --> 00:10:46,272
它不再是同一个count了
It's not the same count any more.

188
00:10:46,270 --> 00:10:47,973
我得到了错误的结果
I get the wrong answer.

189
00:10:47,970 --> 00:10:50,944
代换模型是一个静态的现象#TBD
The substitution model is a static phenomenon

190
00:10:50,944 --> 00:10:52,940
它描述了真实的事物#TBD
describes things that are true

191
00:10:52,940 --> 00:10:55,504
并且事物不会改变#TBD
and not things that change.

192
00:10:55,504 --> 00:10:57,500
这里，我们的的真实变了#TBD
Here, we have truths that change.

193
00:11:00,350 --> 00:11:06,746
那么，在我给出任何解释之前
OK, Well, before I give you any understanding of this,

194
00:11:06,740 --> 00:11:07,797
这很糟糕
this is very bad.

195
00:11:07,790 --> 00:11:10,085
我们失去了我们的计算模型
Now, we've lost our model of computation.

196
00:11:10,080 --> 00:11:11,098
并且
And, 

197
00:11:11,098 --> 00:11:14,666
很快，我将不得不构建一个新的计算模型
pretty soon, I'm going to have to build you a new model of computation.

198
00:11:14,660 --> 00:11:18,458
#TBD
But ours plays with this, just now, in an informal sense.

199
00:11:18,450 --> 00:11:20,389
当然，你们已经看到的是
Of course, what you already see

200
00:11:20,380 --> 00:11:22,938
当我做一些像赋值之类的事情时
is that when I have something like assignment,

201
00:11:22,930 --> 00:11:24,512
我们所需要的模型
the model that we're going to need

202
00:11:24,510 --> 00:11:26,896
与我们之前模型不同
is different from the model that we had before

203
00:11:26,890 --> 00:11:30,933
在这个的模型中，像count或x这些符号
in that, the variables, those symbols like count, or x

204
00:11:30,930 --> 00:11:34,074
不再关联于他们的值
are no longer going to refer to the values they have,

205
00:11:34,070 --> 00:11:37,568
而是关联于某个储存这些值的地方
but rather to some sort of place where the value restored.

206
00:11:37,568 --> 00:11:39,560
我们将不得不以这种方式思考一段时间
We're going to have to think that way for a while.

207
00:11:39,560 --> 00:11:42,112
这将是一个很糟糕坏的事情
And it's going to be a very bad thing

208
00:11:42,110 --> 00:11:44,026
并且会造成很多麻烦
and cause a lot of trouble.

209
00:11:44,020 --> 00:11:48,250
所以，就像我说的，当我们创造糟糕的事物
And so, as I said, the very fact that we're inventing this bad thing,

210
00:11:48,250 --> 00:11:50,378
意味着有更好的创造它的理由
means that there had better be a good reason for it,

211
00:11:50,370 --> 00:11:53,136
否则，就是浪费时间和精力
otherwise, just a waste of time and a lot of effort.

212
00:11:53,130 --> 00:11:55,882
让我们看看一些东西#TBD
Let's just look at some of it just to play.

213
00:11:55,880 --> 00:11:58,592
假设我们写了函数式版本的阶乘
Supposing we write down the functional version,

214
00:11:58,590 --> 00:12:01,178
传统意义中的那个函数式
functional meaning in the old style,

215
00:12:01,170 --> 00:12:09,594
这个阶乘使用了迭代的过程
of factorial by an iterative process.

216
00:12:09,590 --> 00:12:14,245
n的阶乘

217
00:12:18,120 --> 00:12:25,765
我们要从m迭代到i
we're going to iterate of m and i,

218
00:12:25,760 --> 00:12:33,514
就是说如果i大于n
which says if i is greater than n,

219
00:12:33,514 --> 00:12:35,510
则结果是m
then the result is m,

220
00:12:35,510 --> 00:12:39,562
否则
otherwise,

221
00:12:39,560 --> 00:12:46,821
结果是迭代i和m的乘积
the result of iterating the product of i and m.

222
00:12:46,820 --> 00:12:51,488
所以m将是我累积的结果
So m is going to be the product that I'm accumulating.

223
00:12:51,480 --> 00:12:57,973
m就是这个乘积
m is the product.

224
00:12:57,970 --> 00:13:04,624
然后我要把count加1
And the count I'm going to increase by one.

225
00:13:04,620 --> 00:13:11,781
[闭合括号中]
Plus, ITER, ELSE, COND, define.

226
00:13:11,780 --> 00:13:17,072
我要从这开始写
I'm going to start this up.

227
00:13:17,070 --> 00:13:20,714
如今，你们应该能够没有任何障碍地阅读这类东西了
And these days, you should have no trouble reading something like this.

228
00:13:20,710 --> 00:13:26,186
这里是一个累积的乘积，和一个计数器
What I have here is a product there being accumulated and a counter. 

229
00:13:26,180 --> 00:13:28,709
我让它们都从1开始
I start them up both at one.

230
00:13:28,700 --> 00:13:30,928
我将不断让计数器增加
I'm going to buzz the counter up,

231
00:13:30,920 --> 00:13:34,352
每个回合i变成i加1
i goes to i plus one every time around.

232
00:13:34,350 --> 00:13:38,128
那是我们在过程中唯一设置的时间点
But that's only our putting a time on the process,

233
00:13:38,120 --> 00:13:40,325
#TBD
each of this is just a set of truths,

234
00:13:40,325 --> 00:13:42,320
#TBD
true rules.

235
00:13:42,320 --> 00:13:46,138
m将获得一个新的值，就是i乘m
And m is going to get a new values of i and m,

236
00:13:46,130 --> 00:13:48,416
每一轮i乘以m
i times m each time around,

237
00:13:48,410 --> 00:13:52,426
最终i将大于n，在那种情况下，结果就是m
and eventually i is going to be bigger than n, in which case, the answer's going to be m.

238
00:13:52,420 --> 00:13:55,461
现在我给你们讲，#TBD
Now, I'm speaking to you, use time in this. 

239
00:13:55,460 --> 00:13:58,074
那是因为我知道计算机是怎么工作的
That's just because I know how the computer
works.

240
00:13:58,070 --> 00:13:59,552
但是我没必要这么做
But I didn't have to.

241
00:13:59,550 --> 00:14:02,309
这可以作为一个纯数学的解释
This could be a purely mathematical description at this point,

242
00:14:02,300 --> 00:14:04,805
因为代换在这里可以工作
because substitution will work for this.

243
00:14:04,800 --> 00:14:08,144
但是我们写一个类似的程序
But let's set right down a similar sort of program,

244
00:14:08,144 --> 00:14:10,512
使用相同的算法
using the same algorithm,

245
00:14:10,510 --> 00:14:13,306
但使用了赋值
but with assignments.

246
00:14:15,330 --> 00:14:23,392
所以这个叫做函数式版本
So this is called the functional version.

247
00:14:23,390 --> 00:14:34,229
我想写个命令式的版本的
I want to write down an imperative version. 

248
00:14:34,220 --> 00:14:35,712
n的阶乘
Factorial of n.

249
00:14:35,710 --> 00:14:40,160
我要创建两个变量
I'm going to create my two variables.

250
00:14:40,160 --> 00:14:46,229
把i的值初始化为1
Let i initialize itself to one,

251
00:14:46,220 --> 00:14:50,848
m也初始化为1
and m be initialized to one, similar.

252
00:14:50,840 --> 00:14:59,141
我们创建一个循环
We'll create a loop

253
00:14:59,141 --> 00:15:07,274
如果i比n大，循环结束
which has COND greater than i, and if i is greater than n, we're done.

254
00:15:07,270 --> 00:15:08,874
结果是m
And the result is m,

255
00:15:08,874 --> 00:15:10,870
也就是我累积的乘积
the product I'm accumulating.

256
00:15:10,870 --> 00:15:15,237
否则
Otherwise,

257
00:15:15,230 --> 00:15:19,050
我要写下三件要做的事
I'm going to write down three things to do.

258
00:15:19,050 --> 00:15:29,200
我要set! m为i与m的乘积
I'm going to set! m to the product of i and m,

259
00:15:29,200 --> 00:15:37,642
set! i为i加1的和
set! i to the sum of i and one,

260
00:15:37,640 --> 00:15:40,410
然后继续循环
and go around the loop again.

261
00:15:40,410 --> 00:15:43,408
你们中的FORTRAN程序员应该觉得眼熟
Looks very familiar to you FORTRAN programmers.

262
00:15:43,400 --> 00:15:46,640
[闭合括号中]
ELSE, COND, define, 

263
00:15:46,640 --> 00:15:50,890
语法挺有趣吧？
funny syntax though.

264
00:15:50,890 --> 00:15:56,101
启动循环
Start the loop up,

265
00:15:56,100 --> 00:15:58,714
程序写完了
and that's the program.

266
00:15:58,714 --> 00:16:00,710
那么，这个程序
Now, this program,

267
00:16:00,710 --> 00:16:02,710
我们应该怎么看它呢？
how do we think about it?

268
00:16:02,710 --> 00:16:04,710
来看看我们在这看到了什么
Well, let's just say what we're seeing here.

269
00:16:04,710 --> 00:16:07,477
这里有两个局部变量，i和m
There are two local variables, i and m,

270
00:16:07,470 --> 00:16:10,224
它们都被初始化为1
that have been initialized to one.

271
00:16:10,220 --> 00:16:13,893
在每一次循环里，我检测i是否大于n
Every time around the loop, I test to see if i is greater than n,

272
00:16:13,890 --> 00:16:15,306
就是我们传入的参数
which is the input argument,

273
00:16:15,300 --> 00:16:18,773
如果成立的话，结果就是累积在m中的乘积
and if so, the re sult is the product being accumulated in m.

274
00:16:18,770 --> 00:16:21,216
然而，如果循环没有结束
However, if it's not the end of the loop,

275
00:16:21,210 --> 00:16:23,418
如果我们的工作没有结束
if I'm not done,

276
00:16:23,410 --> 00:16:28,896
则我们要把乘积变为i与当前乘积的结果
then what I'm going to do is change the product to be the result of multiplying i times the current product.

277
00:16:28,890 --> 00:16:31,184
就是我们在这里做过的事情
Which is sort of what we were doing here.

278
00:16:31,184 --> 00:16:33,180
除了这里我没有改动
Except here I wasn't changing.

279
00:16:33,180 --> 00:16:36,549
我复制出了另外一份
I was making another copy,

280
00:16:36,540 --> 00:16:42,714
因为代换模型就是你复制过程的体
because the substitution model says, you copy the body of the procedure

281
00:16:42,710 --> 00:16:46,448
并将形式参数用实际参数代换
with the arguments substituted for the formal parameters.

282
00:16:46,440 --> 00:16:48,426
这里我不担心复制
Here I'm not worried about copying,

283
00:16:48,420 --> 00:16:51,536
在这里，我已经改变了m的值
here I've changed the value of m.

284
00:16:51,530 --> 00:16:55,525
我也把i的值变成了i加1
I also then change the value of i to i plus one,

285
00:16:55,520 --> 00:16:57,770
然后继续循环
and go buzzing around.

286
00:16:57,770 --> 00:17:00,778
看起来是一样的程序
Seems like essentially the same program,

287
00:17:00,770 --> 00:17:02,842
但是可能有一些犯错的机会
but there are some ways of making errors here

288
00:17:02,840 --> 00:17:05,856
直到今天还存在
that didn't exist until today.

289
00:17:05,850 --> 00:17:07,328
例如
For example,

290
00:17:07,320 --> 00:17:09,696
如果我在赋值的时候
if I were to do the horrible thing

291
00:17:09,690 --> 00:17:12,442
没有小心地写程序
of not being careful in writing my program

292
00:17:12,440 --> 00:17:16,890
把两个赋值的顺序调换了
and interchange those two assignments,

293
00:17:16,890 --> 00:17:19,893
程序计算的就不是相同的函数了
the program wouldn't compute the same function.

294
00:17:19,890 --> 00:17:22,874
我得到了一个时间错误，因为这儿有个依赖关系
I get a timing error because there's a dependency

295
00:17:22,870 --> 00:17:27,221
m依赖于i上一次的值
there's a dependency that m depends upon having the last value of i.

296
00:17:27,220 --> 00:17:31,040
如果我先改变i的值
If I try change i first,

297
00:17:31,040 --> 00:17:35,557
就会在乘以m的时候，得到错误的i值
then I've got the wrong value of i when I multiply by m.

298
00:17:35,550 --> 00:17:38,384
在此之前不会存在这样的bug
It's a bug that wasn't available until this moment,

299
00:17:38,380 --> 00:17:42,266
直到我们把某些包含时间的东西引入进来才发生
until we introduced something that had time in it.

300
00:17:42,260 --> 00:17:45,370
如我所说的
So, as I said,

301
00:17:45,370 --> 00:17:47,397
首先，我们需要一个新的计算模型
first we need a new model of computation,

302
00:17:47,390 --> 00:17:52,309
然后，我们就不得不去找，搞这些坑爹事的好理由
and second, we have to be damn good reason for doing this kind of ugly thing.

303
00:17:52,300 --> 00:17:58,416
有什么问题吗？
Are there any questions?

304
00:17:58,410 --> 00:18:00,405
大声点说，David
Speak loudly, David

305
00:18:00,400 --> 00:18:03,722
学生：我们现在引入了set
AUDIENCE: I'm confused about, we've introduced set now,

306
00:18:03,720 --> 00:18:06,768
但是我们之前已经有let和define了
but we had let before and define before.

307
00:18:06,760 --> 00:18:09,701
我不太清楚它们的区别
I'm confused about the difference between the three.

308
00:18:09,700 --> 00:18:13,253
define不能像set一样用吗？
Wouldn't define work in the same situation as set

309
00:18:13,253 --> 00:18:14,837
请详细讲讲
if you introduced it a bit?

310
00:18:14,830 --> 00:18:19,317
教授：不，define是在第一次时创建某个东西时给它设置一个值用的
PROFESSOR: No, define is intended for setting something once the first time,

311
00:18:19,310 --> 00:18:21,744
为了创建它
for making it, OK?

312
00:18:21,740 --> 00:18:24,970
你永远也不会见到我在黑板上
You've never seen me write on a blackboard

313
00:18:24,970 --> 00:18:26,965
在同一行写两个define
two defines in a row

314
00:18:26,960 --> 00:18:32,085
为了让某个变量的旧值变成一个新的值
whose intention was to change the old value of some variable to a new one.

315
00:18:32,080 --> 00:18:34,517
学生：这是一个约定俗成的规矩，还是--
AUDIENCE: Is that by convention or--

316
00:18:34,510 --> 00:18:36,357
教授：不，这是有意为之的
PROFESSOR: No, it's intention.

317
00:18:36,350 --> 00:18:39,466
The answer is,

318
00:18:39,460 --> 00:18:40,848
举个例子
that, for example,

319
00:18:40,840 --> 00:18:42,901
在一个过程内部
internal to a procedure,

320
00:18:42,900 --> 00:18:46,448
两个define写在一行里是非法的
two defines in a row are illegal,

321
00:18:46,440 --> 00:18:49,520
对于同一个变量define两次是非法的
two defines in a row of the same variable.

322
00:18:49,520 --> 00:18:51,744
x 不能被define两次
x can't be defined twice.

323
00:18:51,740 --> 00:18:55,600
而系统会不会捕获这个错误，就是另一个问题了
Whether or not a system catches that error is a different question,

324
00:18:55,600 --> 00:18:58,128
但是我定下规矩
but I legislate to you

325
00:18:58,120 --> 00:19:00,640
任何东西都只能define一次
that define happens once on anything.

326
00:19:00,640 --> 00:19:03,157
现在，确实，在交互式调试中
Now, indeed, in interactive debugging,

327
00:19:03,150 --> 00:19:07,962
我们打算让你与你的计算机交互时可以重新define一些东西
we intend that you interacting with your computer will redefine things,

328
00:19:07,960 --> 00:19:11,690
所以这是交互式调试带来的一个特殊的异常
and so there's a special exception made for interactive debugging.

329
00:19:11,690 --> 00:19:17,493
#TBD
But define is intended to mean to set up something

330
00:19:17,490 --> 00:19:22,053
#TBD
which will be forever that value after that point.

331
00:19:22,050 --> 00:19:26,096
#TBD
It's as if all the defines were done at the beginning.

332
00:19:26,090 --> 00:19:29,114
#TBD
In fact, the only legal place to put a define

333
00:19:29,114 --> 00:19:31,110
#TBD
in Scheme, internal to a procedure,

334
00:19:31,110 --> 00:19:34,474
就是lambda表达式的开始
is just at the beginning of a lambda expression,

335
00:19:34,470 --> 00:19:39,952
过程体的开始
the beginning of the body of a procedure.

336
00:19:39,950 --> 00:19:47,765
现在，let当然与那个不一样
Now, let of course does nothing like either of that.

337
00:19:47,760 --> 00:19:50,000
如果你想知道let发生了什么
I mean, if you look at what's happening with a let,

338
00:19:50,000 --> 00:19:52,138
这个只会重新发生一次#TBD
this happens again exactly once.

339
00:19:52,130 --> 00:19:56,656
它建立了一个i和m的值分别为1的上下文
It sets up a context where i and m are values one and one.

340
00:19:56,650 --> 00:20:01,312
这个上下文存在于整个作用域中
That context exists throughout this scope,

341
00:20:01,312 --> 00:20:04,618
即程序的范围之内
this region of the program.

342
00:20:04,610 --> 00:20:10,789
然而，你不会认为let再次设置了i的值
However, you don't think of that let as setting i again.

343
00:20:10,780 --> 00:20:12,160
它没有改变i的值
It doesn't change it.

344
00:20:12,160 --> 00:20:15,093
因为let，i将永远不会变化
i never changes because of the let.

345
00:20:15,090 --> 00:20:18,357
因为let，i才被创建
i gets created because of let.

346
00:20:18,350 --> 00:20:19,733
实际上
In fact,

347
00:20:19,730 --> 00:20:21,989
let是一个非常简单的想法
the let is a very simple idea.

348
00:20:21,980 --> 00:20:23,594
let不会做别的事情
Let does nothing more,

349
00:20:23,590 --> 00:20:31,621
它让var1的值为1
Let a variable one to have value one

350
00:20:31,620 --> 00:20:37,162
我要把这些更规整地写下来
I'll write this down a little bit more neatly;

351
00:20:37,160 --> 00:20:43,738
var1的值，是表达式e1的值
Let's write, var one have value, the value of expression e1,

352
00:20:43,730 --> 00:20:47,920
var2的值，是表达式e2的值
and variable two, have this value of the expression e2,

353
00:20:47,920 --> 00:20:51,269
在表达式e3中
in an expression e3,

354
00:20:51,260 --> 00:21:06,736
#TBD与var1和var2的过程一样，它们是形式参数
is the same thing as a procedure of var one and var two, the formal parameters,

355
00:21:06,730 --> 00:21:10,714
e3成为过程的体
and e3 being the body,

356
00:21:10,710 --> 00:21:14,272
在这里，var1与e1的值绑定

where var one is bound to the value of e1,

357
00:21:14,270 --> 00:21:19,242
var2与e2的值绑定
and var two gets the value of e2.

358
00:21:19,240 --> 00:21:24,698
所以实际上，这是一个从代换的角度来看很容易理解的东西
So this is, in fact, a perfectly understandable thing from a substitution point of view.

359
00:21:24,690 --> 00:21:30,784
其实就是同一个表达式的两种不同的写法
This is really the same expression written in two different ways.

360
00:21:31,317 --> 00:21:37,264
事实上，系统真正的工作方式就是在运行之前，把代码翻译成这种形式
In fact, the way the actual system
works is this gets translated into this before anything happens.

361
00:21:37,260 --> 00:21:41,770
学生：我还是不清楚是什么造成了let和define之间的区别
AUDIENCE: OK, I'm still unclear as then what makes the difference between a let and a define. They could--

362
00:21:41,770 --> 00:21:44,496
教授:define就是个语法糖
PROFESSOR: A define is a syntactic sugar,

363
00:21:44,490 --> 00:21:49,674
#TBD
whereby, essentially a bunch of variables get created by lets and then set up once.

364
00:21:56,740 --> 00:21:59,994
那么，我们休息一会
OK, time for the first break, I think. Thank you.

365
00:22:02,520 --> 00:22:19,232
[音乐]
[MUSIC PLAYING]

366
00:22:48,810 --> 00:23:03,690
[音乐]
[MUSIC PLAYING]

