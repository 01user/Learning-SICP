1
00:00:00,994 --> 00:00:16,401
[MUSIC PLAYING]

2
00:00:16,401 --> 00:00:19,520
现在，我们想想上一节课讲过的东西

3
00:00:19,520 --> 00:00:23,050
感觉上它非常有趣，它有什么实际的用途吗？

4
00:00:26,330 --> 00:00:29,380
我想答案肯定是“是的”

5
00:00:29,380 --> 00:00:35,180
元循环求值器是非常有价值非常值得琢磨的

6
00:00:38,050 --> 00:00:52,570
我曾花费一年的时间研究元循环求值器，并据此设计出不同的元循环求值器

7
00:00:52,570 --> 00:01:01,270
元循环以它们自身来定义自身，因为元循环所求值的语言包含有元循环本身[此句不确定，可能大概意思是 元循环所解释的语言正是编写此元循环的语言]

8
00:01:01,270 --> 00:01:06,800
这样的求值器是一种探索语言的良好媒介

9
00:01:06,800 --> 00:01:15,490
如果你想添加一个新的feature，小菜一碟，只需稍做修改运行看结果就行

10
00:01:15,490 --> 00:01:21,090
你可能试了一会儿，觉得不行，放弃了这个feature

11
00:01:21,090 --> 00:01:33,720
你可能想试试修改一下绑定策略或者更复杂一些的东西，然后看看语言会发生什么

12
00:01:33,720 --> 00:01:49,690
事实上，对于讨论与交换语言设计，元循环求值器是一个良好的媒介，它们非常容易理解，简洁简单

13
00:01:49,690 --> 00:02:05,450
假如我想和在印度的Dan Friedman讨论语言设计上的想法，我只需写一个元循环求值器邮件给他

14
00:02:05,450 --> 00:02:11,940
他在他的机器上运行看看效果，可能他会觉得这个设计并不好

15
00:02:11,940 --> 00:02:16,880
然后他修改一番，然后再邮件给我，为什么不试试这个，会更好一些

16
00:02:16,880 --> 00:02:20,160
所以我将会讲一些这方面的技术

17
00:02:20,160 --> 00:02:30,790
因为，针对特定目的来设计新语言，它真的是一种必需的技术，而且还很容易 

18
00:02:30,790 --> 00:02:34,210
我们试着先在Lisp中添加一个非常简单的feature

19
00:02:40,640 --> 00:02:44,370
在这之前，我先来谈谈feature吧

20
00:02:49,560 --> 00:02:56,620
有太多的语言因为添加了过多的feature而把语言弄的混乱不堪

21
00:02:56,620 --> 00:03:02,520
计算机科学家也有一个笑话说 bug总可以变成feature的事

22
00:03:05,030 --> 00:03:12,820
我认为很多系统都在经受着蠕变特性的折磨

23
00:03:12,820 --> 00:03:20,170
比方说George有一个很喜欢的feature，并且加入了系统

24
00:03:20,170 --> 00:03:26,640
Harry也想着，我也不喜欢这个系统，然后加入了自己最喜欢的特性

25
00:03:26,640 --> 00:03:30,710
Jim也这样做

26
00:03:30,710 --> 00:03:37,790
要不了多长时间，系统的操作手册一定是没人能看懂的500多页的庞然大物

27
00:03:37,790 --> 00:03:44,830
有时候也可能只是一个人在添加feature并且导致同样糟糕的结果

28
00:03:44,830 --> 00:03:55,730
很多情况下，比如编辑器，就会有很多feature，因为你想要很多的功能并且很多功能都有些随意性

29
00:03:55,730 --> 00:04:01,690
但是回到编程语言上来，我认为有太多的feature是一个灾难

30
00:04:04,110 --> 00:04:21,010
还有另一种情况你之为feeping creaturism，假如这儿有一个盒子，它有一个华丽的显示器，还从中引出一个鼠标，这个盒子内部可能还有些复杂

31
00:04:21,010 --> 00:04:30,080
你的编程语言可能会因为Windows内存交换，磁盘颤动等一系列问题而不能正常工作

32
00:04:30,080 --> 00:04:37,440
每当你使用计算机的时候，就会唤醒鼠标进程，它会询问是否需要做什么事情然后就回去沉睡

33
00:04:37,440 --> 00:04:42,940
可能你突然不小心地胳膊肘碰到了鼠标，你的计算机突然就冒起浓烟或者更糟糕的情况 [= =]

34
00:04:42,940 --> 00:04:47,500
这就是由于添加feature而导致系统不能用的两种典型情况

35
00:04:47,500 --> 00:04:49,730
现在我们要添加的是一个非常简单的feature

36
00:04:52,300 --> 00:04:57,250
这是一个好的feature，事实上，Lisp中就有这个feature

37
00:04:57,250 --> 00:05:05,430
我们都知道，像+ *这样的过程可以接受不定数目的参数

38
00:05:05,430 --> 00:05:17,540
就比如 (+ (* a x x) (* b x) c)

39
00:05:17,540 --> 00:05:30,000
你可以看到，+有两到三个参数，*也有两到三个参数，不管多少个参数都同样可以计算

40
00:05:30,000 --> 00:05:34,960
可以接受不定数目的参数，这一点非常有用

41
00:05:34,960 --> 00:05:47,850
而之前我所讲的Lisp求值器只能接受固定数目的参数，因为我用pair-up将形参与实参一一对应

42
00:05:50,810 --> 00:05:58,590
假如我想定义像这样的不定参数数目的过程

43
00:05:58,590 --> 00:06:01,150
我们分步来考虑

44
00:06:01,150 --> 00:06:15,480
第一步，我得先有相应的语法描述，就是一种表示附加参数的表示法，而且附加参数的个数是不定的

45
00:06:15,480 --> 00:06:26,980
下一步，我们之前也提到过，即，我们怎样使用新的语法得到正确的结果呢？

46
00:06:26,980 --> 00:06:30,480
我们先来看一个相关的例子

47
00:06:33,070 --> 00:06:49,090
我想要定义一个过程，有一个必需的参数x和剩下的一串不定数目的参数y

48
00:06:49,090 --> 00:07:05,990
x是必需的，还有剩下的很多参数用y表示，y是剩下参数的列表

49
00:07:14,480 --> 00:07:36,890
这个过程里，我可以这样写 (map (lambda(u) (* x u)) y)

50
00:07:36,890 --> 00:07:46,300
我用一个“点号”来表明y代表了剩下的所有参数

51
00:07:46,300 --> 00:07:47,745
这样，我就对问题做出了语法描述

52
00:07:53,320 --> 00:08:08,631
为什么这样来写呢？因为这恰好是Lisp reader[应该是指REPL的输出]用来表示cons的一种语法

53
00:08:08,631 --> 00:08:11,080
之前没有介绍过

54
00:08:11,080 --> 00:08:26,980
你可能也自己尝试过，当你用cons连接两个东西，返回的结果是 ( 第一个 . 第二个)

55
00:08:26,980 --> 00:08:41,870
举例来说吧，x . y 对应着这样一个序对，CAR是x CDR是y

56
00:08:41,870 --> 00:09:18,280
目前为止你们所见到的过程参数都像是这样的，比如x y z，画出列表来就像是这样，x y z '()

57
00:09:18,280 --> 00:09:46,380
如果我想要一个列表与之匹配的话，假设列表(1 2 3)，用来和(x y z)相匹配

58
00:09:48,990 --> 00:09:54,220
用(x y z)来对应(1 2 3)

59
00:09:54,220 --> 00:10:05,480
很明显的，我们先把列表的第一个元素相对应，即x对应1，然后再开始对应列表剩下的部分

60
00:10:05,480 --> 00:10:18,510
假设我来匹配(x . y)，还是用(1 2 3)

61
00:10:18,510 --> 00:10:20,000
我们再来看

62
00:10:28,000 --> 00:10:43,740
1 2 3,我遍历过来，哦对的，x对应1，y对应剩下的列表，也就是(2 3)

63
00:10:43,740 --> 00:10:50,160
所以这里选用的表示法对于Lisp来说是非常自然的

64
00:10:52,660 --> 00:10:56,040
如果我就选择 x . y 来表示不定参数

65
00:10:58,290 --> 00:11:00,770
还有一种可能性

66
00:11:00,770 --> 00:11:25,140
我不想要一个必需的参数，或者两个或者更多，我想要所有的参数都是不必需的全部作为一个列表，这样的话所有的实际参数组成的列表就是x

67
00:11:25,140 --> 00:11:45,850
举例来看，我定义一个过程，接受参数并返回参数的列表，这个匿名过程就是过程list啊

68
00:11:45,850 --> 00:11:46,840
怎么来看待这一点呢？

69
00:11:46,840 --> 00:11:55,140
不管怎么说，这里应该是一个形参列表，来匹配实际参数的列表

70
00:11:55,140 --> 00:11:57,145
这时，这里的x就代表了所有的参数

71
00:12:01,490 --> 00:12:10,285
所以这是一种特殊的语法描述，来表示参数个数完全不定的情况

72
00:12:13,190 --> 00:12:18,420
一共就两种情况，上面这种和下面这种

73
00:12:18,420 --> 00:12:31,100
当你构建新的语法描述的时候，一定要注意，不要与现有的语法混淆或者矛盾

74
00:12:33,610 --> 00:12:58,465
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示

75
00:13:02,250 --> 00:13:14,560
有很多语言都是由于语法描述方面出现了混淆或者矛盾导致语言解释器的错误

76
00:13:14,560 --> 00:13:25,060
比如 类ALGOL语言的嵌套if问题

77
00:13:25,060 --> 00:13:35,250
现在我已经告诉你们可行的语法了，接下来要怎么做呢？

78
00:13:35,250 --> 00:13:36,590
我们如何来解释它？

79
00:13:36,590 --> 00:13:38,440
其实很简单

80
00:13:38,440 --> 00:13:43,396
现在我来修改一下元循环

81
00:13:43,396 --> 00:13:46,020
只需要修改一行

82
00:13:46,020 --> 00:13:47,590
在这里

83
00:13:47,590 --> 00:13:49,560
把pair-up修改一下就行

84
00:13:56,390 --> 00:14:16,080
pair-up就是那个用来匹配形参与实参的过程

85
00:14:18,960 --> 00:14:22,670
大部分地方都不需要修改

86
00:14:22,670 --> 00:14:31,050
如果变量列表为空，而且值的列表也是空，就返回空列表

87
00:14:31,050 --> 00:14:41,580
否则，就是值太多了，也即变量列表为空而值列表不是空的

88
00:14:41,580 --> 00:14:50,090
如果值列表为空，但是变量列表不为空，那么就是实参给少了

89
00:14:50,090 --> 00:15:06,255
如果变量是一个符号，开始有意思了，这是一种特殊情况，这是一个符号尾

90
00:15:09,010 --> 00:15:14,900
情况就像这里的一样

91
00:15:14,900 --> 00:15:18,630
tail部分的y是一个符号

92
00:15:18,630 --> 00:15:20,730
它不是nil

93
00:15:20,730 --> 00:15:25,600
也不是空列表，这里的符号尾x就是最开始的那种情况

94
00:15:25,600 --> 00:15:27,790
不是另外的情况

95
00:15:27,790 --> 00:15:44,500
这种情况下，我就用这个符号去匹配整个值列表

96
00:15:44,500 --> 00:15:48,910
否则，我就回到以往的正常情况来一一匹配

97
00:15:52,020 --> 00:15:54,510
我认为这很容易理解 

98
00:15:54,510 --> 00:15:57,080
就是这些

99
00:15:57,080 --> 00:15:58,330
现在  答疑时间

100
00:16:02,620 --> 00:16:06,600
有什么问题吗？

101
00:16:06,600 --> 00:16:06,950
你说

102
00:16:06,950 --> 00:16:10,450
你能再解释一下第三种形式吗？

103
00:16:10,450 --> 00:16:12,590
这个？

104
00:16:12,590 --> 00:16:18,570
或许你用表结构来思考它会更容易理解一些

105
00:16:18,570 --> 00:16:22,400
这是一个过程，包含一个lambda

106
00:16:25,970 --> 00:16:31,090
我来画出表示上面这个过程的表结构

107
00:16:31,090 --> 00:16:32,730
这里是x

108
00:16:32,730 --> 00:16:33,980
这些是我们的符号

109
00:16:37,410 --> 00:16:39,580
过程体就是x而已

110
00:16:44,840 --> 00:16:54,010
如果我来查找这个过程的形参部分，取整个结构的CADR，返回一个符号x

111
00:16:54,010 --> 00:17:05,760
所以，很自然地，在pair-up中，我就用一个符号去匹配整个实参的列表

112
00:17:05,760 --> 00:17:09,559
这个符号与实参的列表相绑定

113
00:17:13,910 --> 00:17:20,920
上面这种情况，如果我用CADR，得到这样的结构去匹配实参列表

114
00:17:24,140 --> 00:17:31,450
这里的x就匹配到整个实参的列表然后返回x这个列表，这就是这个过程所做的事

115
00:17:34,510 --> 00:17:36,140
好的

116
00:17:36,140 --> 00:17:37,830
大家休息一下吧

117
00:17:37,830 --> 00:18:20,358
[MUSIC PLAYING]

118
00:18:20,358 --> 00:18:23,260
我们接着来看

119
00:18:23,260 --> 00:18:38,250
我将要介绍另一种Lisp变式，这项feature非常出名，早期的很多Lisp实现都有它

120
00:18:38,250 --> 00:18:41,770
它被称为变量的动态绑定

121
00:18:41,770 --> 00:18:44,680
我们现在来研究一下

122
00:18:47,620 --> 00:18:53,740
我先来介绍一下是什么情况导致人们会有动态绑定这样的想法的

123
00:18:53,740 --> 00:18:58,640
我不具体说是到底是什么情况，我只来举一些例子，你们说不定也会有同样的想法的

124
00:18:58,640 --> 00:19:08,140
假设，我们再来考虑sum这个过程，对一串东西求和

125
00:19:08,140 --> 00:20:08,220
(define sum (lambda (term a next b) (cond ((> a b) 0) (else (+ (term a) (sum term (next a) next b))))))

126
00:20:14,510 --> 00:20:25,450
当我使用sum过程的时候，我可以这样来用

127
00:20:25,450 --> 00:21:11,440
(define sum-powers (lambda (a b n) (sum (lambda (x) (expt x n)) a 1+ b)))

128
00:21:11,440 --> 00:21:16,340
计算x^n

129
00:21:16,340 --> 00:21:19,740
x从a到b取值，加1递增

130
00:21:22,940 --> 00:21:29,780
我也可以写 -- 对了

131
00:21:29,780 --> 00:21:31,910
乘积

132
00:21:31,910 --> 00:21:33,220
product-powers

133
00:21:38,080 --> 00:21:40,020
名字有点奇怪

134
00:21:40,020 --> 00:21:41,960
还是不改了

135
00:21:41,960 --> 00:21:50,890
有点怪，就按原来的吧

136
00:21:50,890 --> 00:22:03,400
如果我想写product-powers，That was 12 brain cells, that double-take.[此句不明了]

137
00:22:03,400 --> 00:22:11,450
这个过程就像刚才的sum-powers差不多

138
00:22:11,450 --> 00:22:16,725
也是一个有三个参数的过程

139
00:22:16,725 --> 00:22:37,850
过程具体为(product (lambda (x) (expt x n)) a 1+ b)

140
00:22:41,530 --> 00:22:50,750
你可能马上就意识到一些问题

141
00:22:50,750 --> 00:22:53,180
它们看起来几乎一样

142
00:22:53,180 --> 00:22:56,590
为什么要重复写代码呢？

143
00:22:56,590 --> 00:23:01,270
现在就和之前我们遇到的情况很相似了

144
00:23:01,270 --> 00:23:03,810
构造一个抽象不是挺好的吗？

145
00:23:03,810 --> 00:23:05,980
如何构建良好的抽象呢？

146
00:23:05,980 --> 00:23:08,470
我看到有一些完全相同的代码

147
00:23:08,470 --> 00:23:11,080
这有一段，还有这里

148
00:23:14,450 --> 00:23:17,090
所以我应该把它们提取出来

149
00:23:17,090 --> 00:23:25,710
所以我就会想，sum-powers可以用名为nth-powers的过程来表示

150
00:23:25,710 --> 00:23:30,030
假如有人想写一个稍微不同的过程

151
00:23:37,630 --> 00:23:53,556
(define sum-powers (lambda (a b n) 

152
00:23:53,556 --> 00:24:02,170
(sum nth-power a 1+ b)

153
00:24:06,000 --> 00:24:16,270
相似地，我用这种方式来重写product-powers

154
00:24:16,270 --> 00:24:17,520
应该这样

155
00:24:22,100 --> 00:24:58,380
(define product-powers (lambda (a b n) (product nth-powers a 1+ b)))

156
00:24:58,380 --> 00:25:05,930
我们还需要定义过程nth-powers，我把它写在这边

157
00:25:11,215 --> 00:25:12,990
写在上面

158
00:25:25,410 --> 00:25:35,390
这个过程就应该是 (define nth-powers (lambda (x) (expt x n)))

159
00:25:35,390 --> 00:25:38,640
但是我遇到一个问题

160
00:25:38,640 --> 00:25:48,810
我们用环境模型来解释这一段代码，但是找不到n的定义

161
00:25:52,520 --> 00:26:06,410
因为，在这个过程内，n是自由变量

162
00:26:06,410 --> 00:26:16,640
环境模型告诉我们自由变量的值取决于过程被定义时所在的环境

163
00:26:16,640 --> 00:26:25,850
假设所有的过程就像我在黑板上写的这样来定义，nth-powers就定义在全局环境下，没有n的定义

164
00:26:25,850 --> 00:26:28,720
因此，n是未绑定的变量

165
00:26:28,720 --> 00:26:36,220
这种写法很简洁，但是我们都希望n是这里的n和这里的n

166
00:26:38,990 --> 00:26:42,840
这样就太完美了

167
00:26:42,840 --> 00:26:52,900
当然我们也要确定这里的n是这里的n，这边的也一样

168
00:26:57,390 --> 00:27:04,040
这种想法造就了一个非常著名的bug

169
00:27:04,040 --> 00:27:07,310
我来细说下这个bug

170
00:27:07,310 --> 00:27:10,660
这张幻灯片

171
00:27:10,660 --> 00:27:13,990
这是一种新的设计想法，动态绑定

172
00:27:13,990 --> 00:27:29,125
不在过程定义时的环境下解释自由变量，而在调用过程的环境下解释被调用过程内部的自由变量

173
00:27:31,850 --> 00:28:04,470
在这个系统中，你从调用程序的链中搜索自由变量，在这个例子里，nth-powers在product的内部被调用 -- sum也是相似的 -- product被product-powers调用，所以你看，product-powers绑定了变量n之后，nth-powers就可以解释自由变量n了

174
00:28:08,140 --> 00:28:15,800
相似地，sum这边，nth-powers中的n会通过sum-powers sum这样的调用关系中解释自由变量n

175
00:28:15,800 --> 00:28:19,730
它被sum调用了

176
00:28:19,730 --> 00:28:22,900
对应这里的term

177
00:28:22,900 --> 00:28:28,930
sum在sum-powers内部被调用，而sum-powers绑定了变量n

178
00:28:28,930 --> 00:28:36,495
因此nth-powers这里的n就得到了解释

179
00:28:39,430 --> 00:28:46,540
这边白线以下的情况，就是我们所称的动态绑定

180
00:28:46,540 --> 00:28:50,850
用动态绑定的角度来解释，就可以正常运行

181
00:28:50,850 --> 00:28:55,990
我们来看看，要怎么实现这个功能

182
00:28:55,990 --> 00:28:57,480
非常简单

183
00:28:57,480 --> 00:29:06,490
事实上，最开始的Lisp实现凡是可以对自由变量进行解释的，都是用的动态绑定方法

184
00:29:06,490 --> 00:29:15,220
APL就是用动态绑定来解释自由变量的，而不是静态绑定

185
00:29:15,220 --> 00:29:18,790
要实现动态绑定，要从eval下手

186
00:29:18,790 --> 00:29:22,780
只需修改两个地方就行

187
00:29:22,780 --> 00:29:29,010
第一个地方修改的更为简单

188
00:29:32,460 --> 00:29:42,030
如果是动态绑定的话，过程在定义的时候就无需关乎环境的问题

189
00:29:42,030 --> 00:30:01,290
所以我们看到，在lambda表达式的这一行，只需要返回exp本身就行了，不需要像之前那样加上类型标签'closure并且和环境结构绑定在一起

190
00:30:01,290 --> 00:30:02,540
就是exp本身

191
00:30:02,540 --> 00:30:06,440
相应的，解读lambda过程的地方也要修改一些

192
00:30:06,440 --> 00:30:14,290
另外要注意的是，在apply的时候必须要知道调用者的环境

193
00:30:14,290 --> 00:30:19,560
调用者的环境就在这里

194
00:30:19,560 --> 00:30:26,980
如果表达式是一个过程应用或者组合式，然后我们就执行过程，也就是操作符的值

195
00:30:29,840 --> 00:30:35,890
调用者的环境就是我们当前的环境

196
00:30:35,890 --> 00:30:41,490
所以我要把这个环境传递予apply

197
00:30:41,490 --> 00:31:06,810
我们再来看看apply，增加了一个环境参数，绑定参数的时候就来扩展这个环境，而不是去扩展原先绑定在'closure过程内的环境了

198
00:31:06,810 --> 00:31:14,130
为什么早期的Lisp如此来实现呢？原因也很清楚，碰巧实现了

199
00:31:14,130 --> 00:31:17,250
然后大家也就习惯了

200
00:31:17,250 --> 00:31:21,590
因此不少人就说Lisp就应该这样做

201
00:31:21,590 --> 00:31:35,460
不幸地是这导致了不小的问题，最严重的一点是，动态绑定破坏了模块性

202
00:31:35,460 --> 00:31:44,580
如果有两个人在一个大型系统上协同工作，其中一个重要的事情就是两个人的命名不能相互冲突

203
00:31:47,930 --> 00:31:59,850
这一点很重要，不能说 你使用了我代码中的命名就导致我的代码停止工作

204
00:31:59,850 --> 00:32:06,670
然而，很明显地 动态绑定和特定的模块性约束相冲突

205
00:32:06,670 --> 00:32:12,540
我们考虑一下，这样会发生什么

206
00:32:12,540 --> 00:32:19,810
假如我把next命名为别的

207
00:32:19,810 --> 00:32:28,970
假设两个人，一个人写sum过程，另一个人使用sum过程

208
00:32:28,970 --> 00:32:33,790
sum的编写者有权利来选择sum内部的命名

209
00:32:33,790 --> 00:32:36,760
假设我就是那个编写者

210
00:32:36,760 --> 00:32:39,300
刚巧，这里我不想用next来表示

211
00:32:39,300 --> 00:32:41,500
只写一个n

212
00:32:41,500 --> 00:32:48,140
所以下面的代码就把next都换成n

213
00:32:48,140 --> 00:32:49,940
哎呀

214
00:32:49,940 --> 00:32:56,110
我只是改变了过程内部的命名而已，但是整个程序就宕掉了

215
00:32:56,110 --> 00:32:59,730
不仅如此，这边也出现了问题

216
00:32:59,730 --> 00:33:02,260
为什么会这样？

217
00:33:02,260 --> 00:33:04,480
答案非常明显

218
00:33:04,480 --> 00:33:24,370
为了找出nth-powers中n的值，如果根据环境模型，这个n总是这个n

219
00:33:24,370 --> 00:33:30,700
lambda表达式总在n被定义的环境下运行

220
00:33:30,700 --> 00:33:37,320
然而如果是动态绑定，我必须追踪过程的调用链，就会有糟糕的事情发生

221
00:33:37,320 --> 00:33:44,780
这个lambda部分其实是在sum内作为term来调用

222
00:33:44,780 --> 00:33:47,350
这时再来查找n的定义

223
00:33:47,350 --> 00:33:50,700
这样我们找到的n就不是sum-powers的n了，而变成了sum这里的n

224
00:33:50,700 --> 00:33:54,680
因此，在过程的内部的小小修改就导致了整个程序停止工作

225
00:33:56,770 --> 00:34:00,020
这里的n就不再是一个量词了

226
00:34:02,700 --> 00:34:05,430
在这个lambda里n应该是一个量词才对

227
00:34:05,430 --> 00:34:24,040
一个事物所绑定的名字应该是不重要的，如果我在这里针对一个名字统一换成别的，表达式的含义也应该保持不变

228
00:34:24,040 --> 00:34:28,690
但是刚才我只是对next换成了n而已，就导致nth-powers改变了意思

229
00:34:28,690 --> 00:34:32,170
所以这里用lambda也就不妥当了

230
00:34:32,170 --> 00:34:34,550
这个问题非常严重

231
00:34:34,550 --> 00:34:48,090
因为这个原因，我和同事们放弃了动态绑定，相对的我更喜欢模块化原则

232
00:34:48,090 --> 00:34:54,530
这也是一种针对求值器的探索

233
00:34:54,530 --> 00:34:58,270
你可以尝试多种方法

234
00:34:58,270 --> 00:35:00,070
从中你会了解到 是什么使一个语言更加优雅

235
00:35:02,680 --> 00:35:04,990
所以元循环真的很重要

236
00:35:04,990 --> 00:35:10,880
现在我们来想想在动态绑定的前提下 怎么样使得这里的程序可以正常运行

237
00:35:10,880 --> 00:35:16,280
如何正确的利用动态绑定带来的好处呢？

238
00:35:16,280 --> 00:35:23,690
答案是，我只想要一个针对n求指数的过程

239
00:35:23,690 --> 00:35:26,280
给定一个n，它就返回一个求n次方的过程

240
00:35:26,280 --> 00:35:28,170
这非常简单

241
00:35:28,170 --> 00:35:30,570
换言之，我可以这样来写

242
00:35:35,450 --> 00:35:45,240
我定义一个过程PGEN，达到刚才所说的效果

243
00:35:50,240 --> 00:35:51,490
(lambda (n) (lambda (x) (expt x n)))

244
00:35:56,900 --> 00:36:07,890
这样来写的话会更好一些，封装就不会被改名的情况而破坏了

245
00:36:07,890 --> 00:36:37,590
(define sum-powers (lambda (a b n) (sum (pgen n) a 1+ b)))

246
00:36:42,490 --> 00:37:11,150
再定义product-powers，(define product-powers (lambda (a b n) (product (pgen n) a 1+ b)))

247
00:37:11,150 --> 00:37:17,280
当然，这里的这个例子针对的抽象很简单

248
00:37:17,280 --> 00:37:20,100
但是这样来写的话就导致要写更多的代码

249
00:37:20,100 --> 00:37:23,670
这样写的目的在于使其清晰一些

250
00:37:23,670 --> 00:37:28,200
确保这里的n引用的是正确的n

251
00:37:28,200 --> 00:37:34,050
pgen这里的n明显的就是product-powers这里的n

252
00:37:37,130 --> 00:37:40,210
你也可以认为这个过程调用是一个很长的名字

253
00:37:40,210 --> 00:37:49,220
这里我用一个n为参数可以生成新过程的过程来避免了之前的问题

254
00:37:55,080 --> 00:37:57,140
有什么问题吗？

255
00:37:57,140 --> 00:37:58,380
你说，David

256
00:37:58,380 --> 00:38:06,470
AUDIENCE: Is the only solution to the problem you raise to create another procedure?

257
00:38:06,470 --> 00:38:12,402
In other words, can this only work in languages that are capable of defining objects as procedures?

258
00:38:12,402 --> 00:38:13,765
PROFESSOR: Oh, I see.

259
00:38:16,530 --> 00:38:28,190
My solution to making this abstraction, when I didn't want include the procedure inside the body, depends upon my ability to return a procedure or export one.

260
00:38:28,190 --> 00:38:30,410
And that's right.

261
00:38:30,410 --> 00:38:43,000
If I don't have that, then I just don't have this ability to make an abstraction in a way where I don't have possibilities of symbol conflicts that were unanticipated.

262
00:38:43,000 --> 00:38:45,610
That's right.

263
00:38:45,610 --> 00:39:03,700
I consider being able to return the procedural value and, therefore, to sort of have first class procedures, in general, as being essential to doing very good modular programming.

264
00:39:03,700 --> 00:39:07,440
Now, indeed there are many other ways to skin this cat.

265
00:39:07,440 --> 00:39:15,840
What you can do is take for each of the bad things that you have to worry about, you can make a special feature that covers that thing.

266
00:39:15,840 --> 00:39:17,930
You can make a package system.

267
00:39:17,930 --> 00:39:22,240
You can make a module system as in Ada, et cetera.

268
00:39:22,240 --> 00:39:26,440
And all of those work, or they cover little regions of it.

269
00:39:26,440 --> 00:39:45,590
The thing is that returning procedures as values cover all of those problems. And so it's the simplest mechanism that gives you the best modularity, gives you all of the known modularity mechanisms.

270
00:39:45,590 --> 00:39:48,248
Well, I suppose it's time for the next break, thank you.

271
00:39:48,248 --> 00:40:41,871
[MUSIC PLAYING]

272
00:40:41,871 --> 00:40:55,420
PROFESSOR: Well, yesterday when you learned about streams, Hal worried to you about the order of evaluation and delayed arguments to procedures.

273
00:40:55,420 --> 00:41:15,250
The way we played with streams yesterday, it was the responsibility of the caller and the callee to both agree that an argument was delayed, and the callee must force the argument if it needs the answer.

274
00:41:15,250 --> 00:41:26,100
So there had to be a lot of hand shaking between the designer of a procedure and user of it over delayedness.

275
00:41:26,100 --> 00:41:45,900
That turns out, of course, to be a fairly bad thing, it works all right with streams. But as a general thing, what you want is an idea to have a locus, a decision, a design decision in general, to have a place where it's made, explicitly, and notated in a clear way.

276
00:41:45,900 --> 00:41:59,500
And so it's not a very good idea to have to have an agreement, between the person who writes a procedure and the person who calls it, about such details as, maybe, the arguments of evaluation, the order of evaluation.

277
00:41:59,500 --> 00:42:00,750
Although, that's not so bad.

278
00:42:00,750 --> 00:42:04,540
I mean, we have other such agreements like, the input's a number.

279
00:42:04,540 --> 00:42:11,020
But it would be nice if only one of these guys could take responsibility, completely.

280
00:42:11,020 --> 00:42:15,510
Now this is not a new idea.

281
00:42:15,510 --> 00:42:22,020
ALGOL 60 had two different ways of calling a procedure.

282
00:42:22,020 --> 00:42:25,590
The arguments could be passed by name or by value.

283
00:42:25,590 --> 00:42:31,110
And what that meant was that a name argument was delayed.

284
00:42:31,110 --> 00:42:39,620
That when you passed an argument by name, that its value would only be obtained if you accessed that argument.

285
00:42:42,290 --> 00:42:50,320
So what I'd like to do now is show you, first of all, a little bit about, again, we're going to make a modification to a language.

286
00:42:50,320 --> 00:42:53,370
In this case, we're going to add a feature.

287
00:42:53,370 --> 00:43:00,430
We're going to add the feature of, by name parameters, if you will, or delayed parameters.

288
00:43:00,430 --> 00:43:08,220
Because, in fact, the default in our Lisp system is by the value of a pointer.

289
00:43:08,220 --> 00:43:13,410
A pointer is copied, but the data structure it points at is not.

290
00:43:13,410 --> 00:43:19,990
But I'd like to, in fact, show you is how you add name arguments as well.

291
00:43:19,990 --> 00:43:23,100
Now again, why would we need such a thing?

292
00:43:23,100 --> 00:43:29,720
Well supposing we wanted to invent certain kinds of what otherwise would be special forms, reserve words?

293
00:43:29,720 --> 00:43:32,180
But I'd rather not take up reserve words.

294
00:43:32,180 --> 00:43:36,360
I want procedures that can do things like if.

295
00:43:36,360 --> 00:43:39,420
If is special, or cond, or whatever it is.

296
00:43:39,420 --> 00:43:40,600
It's the same thing.

297
00:43:40,600 --> 00:43:50,840
It's special in that it determines whether or not to evaluate the consequent or the alternative based on the value of the predicate part of an expression.

298
00:43:50,840 --> 00:43:57,270
So taking the value of one thing determines whether or not to do something else.

299
00:43:57,270 --> 00:44:08,670
Whereas all the procedures like plus, the ones that we can define right now, evaluate all of their arguments before application.

300
00:44:08,670 --> 00:44:19,452
So, for example, supposing I wish to be able to define something like the reverse of if in terms of if.

301
00:44:19,452 --> 00:44:20,702
Call it unless.

302
00:44:24,890 --> 00:44:28,190
We've a predicate, a consequent, and an alternative.

303
00:44:28,190 --> 00:44:32,440
Now what I would like to sort of be able to do is say-- oh, I'll do it in terms of cond.

304
00:44:32,440 --> 00:44:45,350
Cond, if not the predicate, then take the consequent, otherwise, take the alternative.

305
00:44:51,290 --> 00:44:56,920
Now, what I'd like this to mean, is supposing I do something like this.

306
00:44:56,920 --> 00:45:11,350
I'd like this unless say if equals one, 0, then the answer is two, otherwise, the quotient of one and 0.

307
00:45:15,980 --> 00:45:25,580
What I'd like that to mean is the result of substituting equal one, 0, and two, and the quotient of one, 0 for p, c, and a.

308
00:45:25,580 --> 00:45:51,160
I'd like that to mean, and this is funny, I'd like it to transform into or mean cond not equal one, 0, then the result is two, otherwise I want it to be the quotient one and 0.

309
00:45:54,480 --> 00:45:59,970
Now, you know that if I were to type this into Lisp, I'd get a two.

310
00:45:59,970 --> 00:46:02,910
There's no problem with that.

311
00:46:02,910 --> 00:46:10,840
However, if I were to type this into Lisp, because all the arguments are evaluated before I start, then I'm going to get an error out of this.

312
00:46:13,380 --> 00:46:16,880
So that if the substitutions work at all, of course, I would get the right answer.

313
00:46:16,880 --> 00:46:20,160
But here's a case where the substitutions don't work.

314
00:46:22,920 --> 00:46:23,860
I don't get the wrong answer.

315
00:46:23,860 --> 00:46:24,670
I get no answer.

316
00:46:24,670 --> 00:46:25,920
I get an error.

317
00:46:28,420 --> 00:46:34,270
Now, however, I'd like to be able to make my definition so that this kind of thing works.

318
00:46:34,270 --> 00:46:39,930
What I want to do is say something special about c and a.

319
00:46:39,930 --> 00:46:42,715
I want them to be delayed automatically.

320
00:46:46,300 --> 00:46:51,520
I don't want them to be evaluated at the time I call.

321
00:46:51,520 --> 00:46:55,600
So I'm going to make a declaration, and then I'm going to see how to implement such a declaration.

322
00:46:55,600 --> 00:47:02,140
But again, I want you to say to yourself, oh, this is an interesting kluge he's adding in here.

323
00:47:02,140 --> 00:47:05,750
The piles of kluges make a big complicated mess.

324
00:47:05,750 --> 00:47:10,120
And is this going to foul up something else that might occur.

325
00:47:10,120 --> 00:47:13,860
First of all, is it syntactically unambiguous?

326
00:47:13,860 --> 00:47:17,840
Well, it will be syntactically unambiguous with what we've seen so far.

327
00:47:17,840 --> 00:47:21,670
But what I'm going to do may, in fact, cause trouble.

328
00:47:21,670 --> 00:47:34,300
It may be that the thing I had will conflict with type declarations I might want to add in the future for giving some system, some compiler or something, the ability to optimize given the types are known.

329
00:47:34,300 --> 00:47:40,570
Or it might conflict with other types of declarations I might want to make about the formal parameters.

330
00:47:40,570 --> 00:47:44,925
So I'm not making a general mechanism here where I can add declarations.

331
00:47:44,925 --> 00:47:46,750
And I would like to be able to do that.

332
00:47:46,750 --> 00:47:51,010
But I don't want to talk about that right now.

333
00:47:51,010 --> 00:47:53,680
So here I'm going to do, I'm going to build a kluge.

334
00:47:57,050 --> 00:48:14,930
So we're going to define unless of a predicate-- and I'm going to call these by name-- the consequent, and name the alternative.

335
00:48:19,850 --> 00:48:25,280
Huh, huh-- I got caught in the corner.

336
00:48:31,240 --> 00:48:41,360
If not p then the result is c, else-- that's what I'd like.

337
00:48:44,670 --> 00:48:51,650
Where I can explicitly declare certain of the parameters to be delayed, to be computed later.

338
00:48:55,008 --> 00:49:00,450
Now, this is actually a very complicated modification to an interpreter rather than a simple one.

339
00:49:00,450 --> 00:49:09,280
The ones you saw before, dynamic binding or adding indefinite argument procedures, is relatively simple.

340
00:49:09,280 --> 00:49:12,120
But this one changes a basic strategy.

341
00:49:12,120 --> 00:49:36,110
The problem here is that our interpreter, as written, evaluates a combination by evaluating the procedure, the operator producing the procedure, and evaluating the operands producing the arguments, and then doing apply of the procedure to the arguments.

342
00:49:36,110 --> 00:49:46,810
However, here, I don't want to evaluate the operands to produce the arguments until after I examined the procedure to see what the procedure's declarations look like.

343
00:49:49,590 --> 00:49:52,680
So let's look at that.

344
00:49:52,680 --> 00:49:57,480
Here we have a changed evaluator.

345
00:49:57,480 --> 00:50:09,750
I'm starting with the simple lexical evaluator, not dynamic, but we're going to have to do something sort of similar in some ways.

346
00:50:09,750 --> 00:50:19,360
Because of the fact that, if I delay a procedure-- I'm sorry-- delay an argument to a procedure, I'm going to have to attach and environment to it.

347
00:50:19,360 --> 00:50:23,380
Remember how Hal implemented delay.

348
00:50:23,380 --> 00:50:31,180
Hal implemented delay as being a procedure of no arguments which does some expression.

349
00:50:31,180 --> 00:50:32,670
That's what delay of the expression is.

350
00:50:35,370 --> 00:50:36,620
--of that expression.

351
00:50:39,180 --> 00:50:40,950
This turned into something like this.

352
00:50:44,520 --> 00:50:49,010
Now, however, if I evaluate a lambda expression, I have to capture the environment.

353
00:50:51,410 --> 00:51:01,530
The reason why is because there are variables in there who's meaning I wish to derive from the context where this was written.

354
00:51:04,010 --> 00:51:06,095
So that's why a lambda does the job.

355
00:51:06,095 --> 00:51:08,070
It's the right thing.

356
00:51:08,070 --> 00:51:21,090
And such that the forcing of a delayed expression was same thing as calling that with no arguments.

357
00:51:21,090 --> 00:51:24,100
It's just the opposite of this.

358
00:51:24,100 --> 00:51:33,132
Producing an environment of the call which is, in fact, the environment where this was defined with an extra frame in it that's empty.

359
00:51:33,132 --> 00:51:36,240
I don't care about that.

360
00:51:36,240 --> 00:51:51,980
Well, if we go back to this slide, since it's the case, if we look at this for a second, everything is the same as it was before except the case of applications or combinations.

361
00:51:51,980 --> 00:51:54,680
And combinations are going to do two things.

362
00:51:54,680 --> 00:52:00,425
One, is I have to evaluate the procedure-- forget the procedure-- by evaluating the operator.

363
00:52:00,425 --> 00:52:02,380
That's what you see right here.

364
00:52:02,380 --> 00:52:10,730
I have to make sure that that's current, that is not a delayed object, and evaluate that to the point where it's forced now.

365
00:52:10,730 --> 00:52:18,460
And then I have to somehow apply that to the operands.

366
00:52:18,460 --> 00:52:21,530
But I have to keep the environment, pass that environmental along.

367
00:52:21,530 --> 00:52:23,710
So some of those operands I may have to delay.

368
00:52:23,710 --> 00:52:29,302
I may have to attach that environment to those operands.

369
00:52:29,302 --> 00:52:32,990
This is a rather complicated thing happening here.

370
00:52:32,990 --> 00:52:34,240
Looking at that in apply.

371
00:52:36,400 --> 00:52:42,610
Apply, well it has a primitive procedure thing just like before.

372
00:52:42,610 --> 00:52:44,390
But the compound one is a little more interesting.

373
00:52:47,250 --> 00:53:00,290
I have to evaluate the body, just as before, in an environment which is the result of binding some formal parameters to arguments in the environment.

374
00:53:00,290 --> 00:53:01,530
That's true.

375
00:53:01,530 --> 00:53:03,820
The environment is the one that comes from the procedure now.

376
00:53:03,820 --> 00:53:08,040
It's a lexical language, statically bound.

377
00:53:08,040 --> 00:53:12,960
However, one thing I have to do is strip off the declarations to get the names of the variables.

378
00:53:12,960 --> 00:53:15,450
That's what this guy does, vnames.

379
00:53:15,450 --> 00:53:33,770
And the other thing I have to do is process these declarations, deciding which of these operands-- that's the operands now, as opposed to the arguments-- which of these operands to evaluate, and which of them are to be encapsulated in delays of some sort.

380
00:53:37,280 --> 00:53:45,820
The other thing you see here is that we got a primitive, a primitive like plus, had better get at the real operands.

381
00:53:45,820 --> 00:53:47,690
So here is a place where we're going to have to force them.

382
00:53:47,690 --> 00:53:51,340
And we're going to look at what evlist is going to have to do a bunch of forces.

383
00:53:51,340 --> 00:53:52,780
So we have two different kinds of evlist now.

384
00:53:52,780 --> 00:53:59,870
We have evlist and gevlist. Gevlist is going to wrap delays around some things and force others, evaluate others.

385
00:53:59,870 --> 00:54:07,900
And this guy's going to do some forcing of things.

386
00:54:07,900 --> 00:54:12,250
Just looking at this a little bit, this is a game you must play for yourself, you know.

387
00:54:12,250 --> 00:54:19,730
It's not something that you're going to see all possible variations on an evaluator talking to me.

388
00:54:19,730 --> 00:54:21,410
What you have to do is do this for yourself.

389
00:54:21,410 --> 00:54:29,930
And after you feel this, you play this a bit, you get to see all the possible design decisions and what they might mean, and how they interact with each other.

390
00:54:29,930 --> 00:54:33,160
So what languages might have in them.

391
00:54:33,160 --> 00:54:37,200
And what are some of the consistent sets that make a legitimate language.

392
00:54:37,200 --> 00:54:41,850
Whereas what things are complicated kluges that are just piles of junk.

393
00:54:41,850 --> 00:54:50,750
So evlist of course, over here, just as I said, is a list of operands which are going to be undelayed after evaluation.

394
00:54:50,750 --> 00:54:56,050
So these are going to be forced, whatever that's going to mean.

395
00:54:56,050 --> 00:55:04,040
And gevlist, which is the next thing-- Thank you.

396
00:55:04,040 --> 00:55:09,810
What we see here, well there's a couple of possibilities.

397
00:55:09,810 --> 00:55:19,390
Either it's a normal, ordinary thing, a symbol sitting there like the predicate in the unless, and that's what we have here.

398
00:55:19,390 --> 00:55:23,340
In which case, this is intended to be evaluated in applicative order.

399
00:55:23,340 --> 00:55:25,630
And it's, essentially, just what we had before.

400
00:55:25,630 --> 00:55:37,900
It's mapping eval down the list. In other words, I evaluate the first expression and continue gevlisting the CDR of the expression in the environment.

401
00:55:37,900 --> 00:55:43,600
However, it's possible that this is a name parameter.

402
00:55:43,600 --> 00:56:02,790
If it's a name parameter, I want to put a delay in which combines that expression, which I'm calling by name, with the environment that's available at this time and passing that as the parameter.

403
00:56:02,790 --> 00:56:05,600
And this is part of the mapping process that you see here.

404
00:56:09,070 --> 00:56:14,700
The only other interesting place in this interpreter is cond.

405
00:56:14,700 --> 00:56:18,550
People tend to write this thing, and then they leave this one out.

406
00:56:18,550 --> 00:56:20,510
There's a place where you have to force.

407
00:56:20,510 --> 00:56:25,990
Conditionals have to know whether or not the answer is true or false.

408
00:56:25,990 --> 00:56:28,550
It's like a primitive.

409
00:56:28,550 --> 00:56:31,890
When you do a conditional, you have to force.

410
00:56:31,890 --> 00:56:34,350
Now, I'm not going to look at any more of this in any detail.

411
00:56:34,350 --> 00:56:36,750
It isn't very exciting.

412
00:56:36,750 --> 00:56:38,990
And what's left is how you make delays.

413
00:56:38,990 --> 00:56:44,840
Well, delays are data structures which contain an expression, an environment, and a type on them.

414
00:56:44,840 --> 00:56:46,680
And it says they're a thunk.

415
00:56:46,680 --> 00:56:52,970
That comes from ALGOL language, and it's claimed to be the sound of something being pushed on a stack.

416
00:56:52,970 --> 00:56:53,410
I don't know.

417
00:56:53,410 --> 00:56:58,740
I was not an ALGOLician or an ALGOLite or whatever, so I don't know.

418
00:56:58,740 --> 00:57:00,270
But that's what was claimed.

419
00:57:00,270 --> 00:57:07,860
And undelay is something which will recursively undelay thunks until the thunk becomes something which isn't a thunk.

420
00:57:07,860 --> 00:57:12,050
This is the way you implement a call by name like thing in ALGOL.

421
00:57:12,050 --> 00:57:15,210
And that's about all there is.

422
00:57:15,210 --> 00:57:16,460
Are there any questions?

423
00:57:26,840 --> 00:57:27,560
AUDIENCE: Gerry?

424
00:57:27,560 --> 00:57:29,626
PROFESSOR: Yes, Vesko?

425
00:57:29,626 --> 00:57:39,350
AUDIENCE: I noticed you avoided calling by name in the primitive procedures, I was wondering what cause you have on that?

426
00:57:39,350 --> 00:57:40,070
You never need that?

427
00:57:40,070 --> 00:57:47,140
PROFESSOR: Vesko is asking if it's ever reasonable to call a primitive procedure by name?

428
00:57:47,140 --> 00:57:49,270
The answer is, yes.

429
00:57:49,270 --> 00:57:52,930
There's one particular case where it's reasonable, actually two.

430
00:57:56,050 --> 00:58:03,690
Construction of a data structure like cons where making an array if you have arrays with any number of elements.

431
00:58:03,690 --> 00:58:07,440
It's unnecessary to evaluate those arguments.

432
00:58:07,440 --> 00:58:11,160
All you need is promises to evaluate those arguments if you look at them.

433
00:58:11,160 --> 00:58:21,830
If I cons together two things, then I could cons together the promises just as easily as I can cons together the things.

434
00:58:21,830 --> 00:58:24,840
And it's not even when I CAR CDR them that I have to look at them.

435
00:58:24,840 --> 00:58:28,260
That just gets out the promises and passes them to somebody.

436
00:58:28,260 --> 00:58:34,420
That's why the lambda calculus definition, the Alonzo Church definition of CAR, CDR, and cons makes sense.

437
00:58:34,420 --> 00:58:40,760
It's because no work is done in CAR, CDR, and cons, it's just shuffling data, it's just routing, if you will.

438
00:58:40,760 --> 00:58:45,280
However, the things that do have to look at data are things like plus.

439
00:58:45,280 --> 00:58:52,460
Because they have a look at the bits that the numbers are made out of, unless they're lambda calculus numbers which are funny.

440
00:58:52,460 --> 00:58:55,880
They have to look at the bits to be able to crunch them together to do the add.

441
00:58:59,210 --> 00:59:13,300
So, in fact, data constructors, data selectors, and, in fact, things that side-effect data objects don't need to do any forcing in the laziest possible interpreters.

442
00:59:16,460 --> 00:59:18,700
On the other hand predicates on data structures have to.

443
00:59:21,710 --> 00:59:23,560
Is this a pair?

444
00:59:23,560 --> 00:59:24,640
Or is it a symbol?

445
00:59:24,640 --> 00:59:25,690
Well, you better find out.

446
00:59:25,690 --> 00:59:26,940
You got to look at it then.

447
00:59:30,300 --> 00:59:31,550
Any other questions?

448
00:59:40,050 --> 00:59:41,610
Oh, well, I suppose it's time for a break.

449
00:59:41,610 --> 00:59:42,106
Thank you.

450
00:59:42,106 --> 01:00:02,950
[MUSIC PLAYING]

