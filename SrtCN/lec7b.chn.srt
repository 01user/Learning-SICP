1
00:00:00,994 --> 00:00:16,401
[MUSIC PLAYING]

2
00:00:16,401 --> 00:00:19,520
现在，我们想想上一节课讲过的东西

3
00:00:19,520 --> 00:00:23,050
感觉上它非常有趣，它有什么实际的用途吗？

4
00:00:26,330 --> 00:00:29,380
我想答案肯定是“是的”

5
00:00:29,380 --> 00:00:35,180
元循环求值器是非常有价值非常值得琢磨的

6
00:00:38,050 --> 00:00:52,570
我曾花费一年的时间研究元循环求值器，并据此设计出不同的元循环求值器

7
00:00:52,570 --> 00:01:01,270
元循环以它们自身来定义自身，因为元循环所求值的语言包含有元循环本身[此句不确定，可能大概意思是 元循环所解释的语言正是编写此元循环的语言]

8
00:01:01,270 --> 00:01:06,800
这样的求值器是一种探索语言的良好媒介

9
00:01:06,800 --> 00:01:15,490
如果你想添加一个新的feature，小菜一碟，只需稍做修改运行看结果就行

10
00:01:15,490 --> 00:01:21,090
你可能试了一会儿，觉得不行，放弃了这个feature

11
00:01:21,090 --> 00:01:33,720
你可能想试试修改一下绑定策略或者更复杂一些的东西，然后看看语言会发生什么

12
00:01:33,720 --> 00:01:49,690
事实上，对于讨论与交换语言设计，元循环求值器是一个良好的媒介，它们非常容易理解，简洁简单

13
00:01:49,690 --> 00:02:05,450
假如我想和在印度的Dan Friedman讨论语言设计上的想法，我只需写一个元循环求值器邮件给他

14
00:02:05,450 --> 00:02:11,940
他在他的机器上运行看看效果，可能他会觉得这个设计并不好

15
00:02:11,940 --> 00:02:16,880
然后他修改一番，然后再邮件给我，为什么不试试这个，会更好一些

16
00:02:16,880 --> 00:02:20,160
所以我将会讲一些这方面的技术

17
00:02:20,160 --> 00:02:30,790
因为，针对特定目的来设计新语言，它真的是一种必需的技术，而且还很容易 

18
00:02:30,790 --> 00:02:34,210
我们试着先在Lisp中添加一个非常简单的feature

19
00:02:40,640 --> 00:02:44,370
在这之前，我先来谈谈feature吧

20
00:02:49,560 --> 00:02:56,620
有太多的语言因为添加了过多的feature而把语言弄的混乱不堪

21
00:02:56,620 --> 00:03:02,520
计算机科学家也有一个笑话说 bug总可以变成feature的事

22
00:03:05,030 --> 00:03:12,820
我认为很多系统都在经受着蠕变特性的折磨

23
00:03:12,820 --> 00:03:20,170
比方说George有一个很喜欢的feature，并且加入了系统

24
00:03:20,170 --> 00:03:26,640
Harry也想着，我也不喜欢这个系统，然后加入了自己最喜欢的特性

25
00:03:26,640 --> 00:03:30,710
Jim也这样做

26
00:03:30,710 --> 00:03:37,790
要不了多长时间，系统的操作手册一定是没人能看懂的500多页的庞然大物

27
00:03:37,790 --> 00:03:44,830
有时候也可能只是一个人在添加feature并且导致同样糟糕的结果

28
00:03:44,830 --> 00:03:55,730
很多情况下，比如编辑器，就会有很多feature，因为你想要很多的功能并且很多功能都有些随意性

29
00:03:55,730 --> 00:04:01,690
但是回到编程语言上来，我认为有太多的feature是一个灾难

30
00:04:04,110 --> 00:04:21,010
还有另一种情况你之为feeping creaturism，假如这儿有一个盒子，它有一个华丽的显示器，还从中引出一个鼠标，这个盒子内部可能还有些复杂

31
00:04:21,010 --> 00:04:30,080
你的编程语言可能会因为Windows内存交换，磁盘颤动等一系列问题而不能正常工作

32
00:04:30,080 --> 00:04:37,440
每当你使用计算机的时候，就会唤醒鼠标进程，它会询问是否需要做什么事情然后就回去沉睡

33
00:04:37,440 --> 00:04:42,940
可能你突然不小心地胳膊肘碰到了鼠标，你的计算机突然就冒起浓烟或者更糟糕的情况 [= =]

34
00:04:42,940 --> 00:04:47,500
这就是由于添加feature而导致系统不能用的两种典型情况

35
00:04:47,500 --> 00:04:49,730
现在我们要添加的是一个非常简单的feature

36
00:04:52,300 --> 00:04:57,250
这是一个好的feature，事实上，Lisp中就有这个feature

37
00:04:57,250 --> 00:05:05,430
我们都知道，像+ *这样的过程可以接受不定数目的参数

38
00:05:05,430 --> 00:05:17,540
就比如 (+ (* a x x) (* b x) c)

39
00:05:17,540 --> 00:05:30,000
你可以看到，+有两到三个参数，*也有两到三个参数，不管多少个参数都同样可以计算

40
00:05:30,000 --> 00:05:34,960
可以接受不定数目的参数，这一点非常有用

41
00:05:34,960 --> 00:05:47,850
而之前我所讲的Lisp求值器只能接受固定数目的参数，因为我用pair-up将形参与实参一一对应

42
00:05:50,810 --> 00:05:58,590
假如我想定义像这样的不定参数数目的过程

43
00:05:58,590 --> 00:06:01,150
我们分步来考虑

44
00:06:01,150 --> 00:06:15,480
第一步，我得先有相应的语法描述，就是一种表示附加参数的表示法，而且附加参数的个数是不定的

45
00:06:15,480 --> 00:06:26,980
下一步，我们之前也提到过，即，我们怎样使用新的语法得到正确的结果呢？

46
00:06:26,980 --> 00:06:30,480
我们先来看一个相关的例子

47
00:06:33,070 --> 00:06:49,090
我想要定义一个过程，有一个必需的参数x和剩下的一串不定数目的参数y

48
00:06:49,090 --> 00:07:05,990
x是必需的，还有剩下的很多参数用y表示，y是剩下参数的列表

49
00:07:14,480 --> 00:07:36,890
这个过程里，我可以这样写 (map (lambda(u) (* x u)) y)

50
00:07:36,890 --> 00:07:46,300
我用一个“点号”来表明y代表了剩下的所有参数

51
00:07:46,300 --> 00:07:47,745
这样，我就对问题做出了语法描述

52
00:07:53,320 --> 00:08:08,631
为什么这样来写呢？因为这恰好是Lisp reader[应该是指REPL的输出]用来表示cons的一种语法

53
00:08:08,631 --> 00:08:11,080
之前没有介绍过

54
00:08:11,080 --> 00:08:26,980
你可能也自己尝试过，当你用cons连接两个东西，返回的结果是 ( 第一个 . 第二个)

55
00:08:26,980 --> 00:08:41,870
举例来说吧，x . y 对应着这样一个序对，CAR是x CDR是y

56
00:08:41,870 --> 00:09:18,280
目前为止你们所见到的过程参数都像是这样的，比如x y z，画出列表来就像是这样，x y z '()

57
00:09:18,280 --> 00:09:46,380
如果我想要一个列表与之匹配的话，假设列表(1 2 3)，用来和(x y z)相匹配

58
00:09:48,990 --> 00:09:54,220
用(x y z)来对应(1 2 3)

59
00:09:54,220 --> 00:10:05,480
很明显的，我们先把列表的第一个元素相对应，即x对应1，然后再开始对应列表剩下的部分

60
00:10:05,480 --> 00:10:18,510
假设我来匹配(x . y)，还是用(1 2 3)

61
00:10:18,510 --> 00:10:20,000
我们再来看

62
00:10:28,000 --> 00:10:43,740
1 2 3,我遍历过来，哦对的，x对应1，y对应剩下的列表，也就是(2 3)

63
00:10:43,740 --> 00:10:50,160
所以这里选用的表示法对于Lisp来说是非常自然的

64
00:10:52,660 --> 00:10:56,040
如果我就选择 x . y 来表示不定参数

65
00:10:58,290 --> 00:11:00,770
还有一种可能性

66
00:11:00,770 --> 00:11:25,140
我不想要一个必需的参数，或者两个或者更多，我想要所有的参数都是不必需的全部作为一个列表，这样的话所有的实际参数组成的列表就是x

67
00:11:25,140 --> 00:11:45,850
举例来看，我定义一个过程，接受参数并返回参数的列表，这个匿名过程就是过程list啊

68
00:11:45,850 --> 00:11:46,840
怎么来看待这一点呢？

69
00:11:46,840 --> 00:11:55,140
不管怎么说，这里应该是一个形参列表，来匹配实际参数的列表

70
00:11:55,140 --> 00:11:57,145
这时，这里的x就代表了所有的参数

71
00:12:01,490 --> 00:12:10,285
所以这是一种特殊的语法描述，来表示参数个数完全不定的情况

72
00:12:13,190 --> 00:12:18,420
一共就两种情况，上面这种和下面这种

73
00:12:18,420 --> 00:12:31,100
当你构建新的语法描述的时候，一定要注意，不要与现有的语法混淆或者矛盾

74
00:12:33,610 --> 00:12:58,465
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示

75
00:13:02,250 --> 00:13:14,560
有很多语言都是由于语法描述方面出现了混淆或者矛盾导致语言解释器的错误

76
00:13:14,560 --> 00:13:25,060
比如 类ALGOL语言的嵌套if问题

77
00:13:25,060 --> 00:13:35,250
现在我已经告诉你们可行的语法了，接下来要怎么做呢？

78
00:13:35,250 --> 00:13:36,590
我们如何来解释它？

79
00:13:36,590 --> 00:13:38,440
其实很简单

80
00:13:38,440 --> 00:13:43,396
现在我来修改一下元循环

81
00:13:43,396 --> 00:13:46,020
只需要修改一行

82
00:13:46,020 --> 00:13:47,590
在这里

83
00:13:47,590 --> 00:13:49,560
把pair-up修改一下就行

84
00:13:56,390 --> 00:14:16,080
pair-up就是那个用来匹配形参与实参的过程

85
00:14:18,960 --> 00:14:22,670
大部分地方都不需要修改

86
00:14:22,670 --> 00:14:31,050
如果变量列表为空，而且值的列表也是空，就返回空列表

87
00:14:31,050 --> 00:14:41,580
否则，就是值太多了，也即变量列表为空而值列表不是空的

88
00:14:41,580 --> 00:14:50,090
如果值列表为空，但是变量列表不为空，那么就是实参给少了

89
00:14:50,090 --> 00:15:06,255
如果变量是一个符号，开始有意思了，这是一种特殊情况，这是一个符号尾

90
00:15:09,010 --> 00:15:14,900
情况就像这里的一样

91
00:15:14,900 --> 00:15:18,630
tail部分的y是一个符号

92
00:15:18,630 --> 00:15:20,730
它不是nil

93
00:15:20,730 --> 00:15:25,600
也不是空列表，这里的符号尾x就是最开始的那种情况

94
00:15:25,600 --> 00:15:27,790
不是另外的情况

95
00:15:27,790 --> 00:15:44,500
这种情况下，我就用这个符号去匹配整个值列表

96
00:15:44,500 --> 00:15:48,910
否则，我就回到以往的正常情况来一一匹配

97
00:15:52,020 --> 00:15:54,510
我认为这很容易理解 

98
00:15:54,510 --> 00:15:57,080
就是这些

99
00:15:57,080 --> 00:15:58,330
现在  答疑时间

100
00:16:02,620 --> 00:16:06,600
有什么问题吗？

101
00:16:06,600 --> 00:16:06,950
你说

102
00:16:06,950 --> 00:16:10,450
你能再解释一下第三种形式吗？

103
00:16:10,450 --> 00:16:12,590
这个？

104
00:16:12,590 --> 00:16:18,570
或许你用表结构来思考它会更容易理解一些

105
00:16:18,570 --> 00:16:22,400
这是一个过程，包含一个lambda

106
00:16:25,970 --> 00:16:31,090
我来画出表示上面这个过程的表结构

107
00:16:31,090 --> 00:16:32,730
这里是x

108
00:16:32,730 --> 00:16:33,980
这些是我们的符号

109
00:16:37,410 --> 00:16:39,580
过程体就是x而已

110
00:16:44,840 --> 00:16:54,010
如果我来查找这个过程的形参部分，取整个结构的CADR，返回一个符号x

111
00:16:54,010 --> 00:17:05,760
所以，很自然地，在pair-up中，我就用一个符号去匹配整个实参的列表

112
00:17:05,760 --> 00:17:09,559
这个符号与实参的列表相绑定

113
00:17:13,910 --> 00:17:20,920
上面这种情况，如果我用CADR，得到这样的结构去匹配实参列表

114
00:17:24,140 --> 00:17:31,450
这里的x就匹配到整个实参的列表然后返回x这个列表，这就是这个过程所做的事

115
00:17:34,510 --> 00:17:36,140
好的

116
00:17:36,140 --> 00:17:37,830
大家休息一下吧

117
00:17:37,830 --> 00:18:20,358
[MUSIC PLAYING]

118
00:18:20,358 --> 00:18:23,260
我们接着来看

119
00:18:23,260 --> 00:18:38,250
我将要介绍另一种Lisp变式，这项feature非常出名，早期的很多Lisp实现都有它

120
00:18:38,250 --> 00:18:41,770
它被称为变量的动态绑定

121
00:18:41,770 --> 00:18:44,680
我们现在来研究一下

122
00:18:47,620 --> 00:18:53,740
我先来介绍一下是什么情况导致人们会有动态绑定这样的想法的

123
00:18:53,740 --> 00:18:58,640
我不具体说是到底是什么情况，我只来举一些例子，你们说不定也会有同样的想法的

124
00:18:58,640 --> 00:19:08,140
假设，我们再来考虑sum这个过程，对一串东西求和

125
00:19:08,140 --> 00:20:08,220
(define sum (lambda (term a next b) (cond ((> a b) 0) (else (+ (term a) (sum term (next a) next b))))))

126
00:20:14,510 --> 00:20:25,450
当我使用sum过程的时候，我可以这样来用

127
00:20:25,450 --> 00:21:11,440
(define sum-powers (lambda (a b n) (sum (lambda (x) (expt x n)) a 1+ b)))

128
00:21:11,440 --> 00:21:16,340
计算x^n

129
00:21:16,340 --> 00:21:19,740
x从a到b取值，加1递增

130
00:21:22,940 --> 00:21:29,780
我也可以写 -- 对了

131
00:21:29,780 --> 00:21:31,910
乘积

132
00:21:31,910 --> 00:21:33,220
product-powers

133
00:21:38,080 --> 00:21:40,020
名字有点奇怪

134
00:21:40,020 --> 00:21:41,960
还是不改了

135
00:21:41,960 --> 00:21:50,890
有点怪，就按原来的吧

136
00:21:50,890 --> 00:22:03,400
如果我想写product-powers，That was 12 brain cells, that double-take.[此句不明了]

137
00:22:03,400 --> 00:22:11,450
这个过程就像刚才的sum-powers差不多

138
00:22:11,450 --> 00:22:16,725
也是一个有三个参数的过程

139
00:22:16,725 --> 00:22:37,850
过程具体为(product (lambda (x) (expt x n)) a 1+ b)

140
00:22:41,530 --> 00:22:50,750
你可能马上就意识到一些问题

141
00:22:50,750 --> 00:22:53,180
它们看起来几乎一样

142
00:22:53,180 --> 00:22:56,590
为什么要重复写代码呢？

143
00:22:56,590 --> 00:23:01,270
现在就和之前我们遇到的情况很相似了

144
00:23:01,270 --> 00:23:03,810
构造一个抽象不是挺好的吗？

145
00:23:03,810 --> 00:23:05,980
如何构建良好的抽象呢？

146
00:23:05,980 --> 00:23:08,470
我看到有一些完全相同的代码

147
00:23:08,470 --> 00:23:11,080
这有一段，还有这里

148
00:23:14,450 --> 00:23:17,090
所以我应该把它们提取出来

149
00:23:17,090 --> 00:23:25,710
所以我就会想，sum-powers可以用名为nth-powers的过程来表示

150
00:23:25,710 --> 00:23:30,030
假如有人想写一个稍微不同的过程

151
00:23:37,630 --> 00:23:53,556
(define sum-powers (lambda (a b n) 

152
00:23:53,556 --> 00:24:02,170
(sum nth-power a 1+ b)

153
00:24:06,000 --> 00:24:16,270
相似地，我用这种方式来重写product-powers

154
00:24:16,270 --> 00:24:17,520
应该这样

155
00:24:22,100 --> 00:24:58,380
(define product-powers (lambda (a b n) (product nth-powers a 1+ b)))

156
00:24:58,380 --> 00:25:05,930
我们还需要定义过程nth-powers，我把它写在这边

157
00:25:11,215 --> 00:25:12,990
写在上面

158
00:25:25,410 --> 00:25:35,390
这个过程就应该是 (define nth-powers (lambda (x) (expt x n)))

159
00:25:35,390 --> 00:25:38,640
但是我遇到一个问题

160
00:25:38,640 --> 00:25:48,810
我们用环境模型来解释这一段代码，但是找不到n的定义

161
00:25:52,520 --> 00:26:06,410
因为，在这个过程内，n是自由变量

162
00:26:06,410 --> 00:26:16,640
环境模型告诉我们自由变量的值取决于过程被定义时所在的环境

163
00:26:16,640 --> 00:26:25,850
假设所有的过程就像我在黑板上写的这样来定义，nth-powers就定义在全局环境下，没有n的定义

164
00:26:25,850 --> 00:26:28,720
因此，n是未绑定的变量

165
00:26:28,720 --> 00:26:36,220
这种写法很简洁，但是我们都希望n是这里的n和这里的n

166
00:26:38,990 --> 00:26:42,840
这样就太完美了

167
00:26:42,840 --> 00:26:52,900
当然我们也要确定这里的n是这里的n，这边的也一样

168
00:26:57,390 --> 00:27:04,040
这种想法造就了一个非常著名的bug

169
00:27:04,040 --> 00:27:07,310
我来细说下这个bug

170
00:27:07,310 --> 00:27:10,660
这张幻灯片

171
00:27:10,660 --> 00:27:13,990
这是一种新的设计想法，动态绑定

172
00:27:13,990 --> 00:27:29,125
不在过程定义时的环境下解释自由变量，而在调用过程的环境下解释被调用过程内部的自由变量

173
00:27:31,850 --> 00:28:04,470
在这个系统中，你从调用程序的链中搜索自由变量，在这个例子里，nth-powers在product的内部被调用 -- sum也是相似的 -- product被product-powers调用，所以你看，product-powers绑定了变量n之后，nth-powers就可以解释自由变量n了

174
00:28:08,140 --> 00:28:15,800
相似地，sum这边，nth-powers中的n会通过sum-powers sum这样的调用关系中解释自由变量n

175
00:28:15,800 --> 00:28:19,730
它被sum调用了

176
00:28:19,730 --> 00:28:22,900
对应这里的term

177
00:28:22,900 --> 00:28:28,930
sum在sum-powers内部被调用，而sum-powers绑定了变量n

178
00:28:28,930 --> 00:28:36,495
因此nth-powers这里的n就得到了解释

179
00:28:39,430 --> 00:28:46,540
这边白线以下的情况，就是我们所称的动态绑定

180
00:28:46,540 --> 00:28:50,850
用动态绑定的角度来解释，就可以正常运行

181
00:28:50,850 --> 00:28:55,990
我们来看看，要怎么实现这个功能

182
00:28:55,990 --> 00:28:57,480
非常简单

183
00:28:57,480 --> 00:29:06,490
事实上，最开始的Lisp实现凡是可以对自由变量进行解释的，都是用的动态绑定方法

184
00:29:06,490 --> 00:29:15,220
APL就是用动态绑定来解释自由变量的，而不是静态绑定

185
00:29:15,220 --> 00:29:18,790
要实现动态绑定，要从eval下手

186
00:29:18,790 --> 00:29:22,780
只需修改两个地方就行

187
00:29:22,780 --> 00:29:29,010
第一个地方修改的更为简单

188
00:29:32,460 --> 00:29:42,030
如果是动态绑定的话，过程在定义的时候就无需关乎环境的问题

189
00:29:42,030 --> 00:30:01,290
所以我们看到，在lambda表达式的这一行，只需要返回exp本身就行了，不需要像之前那样加上类型标签'closure并且和环境结构绑定在一起

190
00:30:01,290 --> 00:30:02,540
就是exp本身

191
00:30:02,540 --> 00:30:06,440
相应的，解读lambda过程的地方也要修改一些

192
00:30:06,440 --> 00:30:14,290
另外要注意的是，在apply的时候必须要知道调用者的环境

193
00:30:14,290 --> 00:30:19,560
调用者的环境就在这里

194
00:30:19,560 --> 00:30:26,980
如果表达式是一个过程应用或者组合式，然后我们就执行过程，也就是操作符的值

195
00:30:29,840 --> 00:30:35,890
调用者的环境就是我们当前的环境

196
00:30:35,890 --> 00:30:41,490
所以我要把这个环境传递予apply

197
00:30:41,490 --> 00:31:06,810
我们再来看看apply，增加了一个环境参数，绑定参数的时候就来扩展这个环境，而不是去扩展原先绑定在'closure过程内的环境了

198
00:31:06,810 --> 00:31:14,130
为什么早期的Lisp如此来实现呢？原因也很清楚，碰巧实现了

199
00:31:14,130 --> 00:31:17,250
然后大家也就习惯了

200
00:31:17,250 --> 00:31:21,590
因此不少人就说Lisp就应该这样做

201
00:31:21,590 --> 00:31:35,460
不幸地是这导致了不小的问题，最严重的一点是，动态绑定破坏了模块性

202
00:31:35,460 --> 00:31:44,580
如果有两个人在一个大型系统上协同工作，其中一个重要的事情就是两个人的命名不能相互冲突

203
00:31:47,930 --> 00:31:59,850
这一点很重要，不能说 你使用了我代码中的命名就导致我的代码停止工作

204
00:31:59,850 --> 00:32:06,670
然而，很明显地 动态绑定和特定的模块性约束相冲突

205
00:32:06,670 --> 00:32:12,540
我们考虑一下，这样会发生什么

206
00:32:12,540 --> 00:32:19,810
假如我把next命名为别的

207
00:32:19,810 --> 00:32:28,970
假设两个人，一个人写sum过程，另一个人使用sum过程

208
00:32:28,970 --> 00:32:33,790
sum的编写者有权利来选择sum内部的命名

209
00:32:33,790 --> 00:32:36,760
假设我就是那个编写者

210
00:32:36,760 --> 00:32:39,300
刚巧，这里我不想用next来表示

211
00:32:39,300 --> 00:32:41,500
只写一个n

212
00:32:41,500 --> 00:32:48,140
所以下面的代码就把next都换成n

213
00:32:48,140 --> 00:32:49,940
哎呀

214
00:32:49,940 --> 00:32:56,110
我只是改变了过程内部的命名而已，但是整个程序就宕掉了

215
00:32:56,110 --> 00:32:59,730
不仅如此，这边也出现了问题

216
00:32:59,730 --> 00:33:02,260
为什么会这样？

217
00:33:02,260 --> 00:33:04,480
答案非常明显

218
00:33:04,480 --> 00:33:24,370
为了找出nth-powers中n的值，如果根据环境模型，这个n总是这个n

219
00:33:24,370 --> 00:33:30,700
lambda表达式总在n被定义的环境下运行

220
00:33:30,700 --> 00:33:37,320
然而如果是动态绑定，我必须追踪过程的调用链，就会有糟糕的事情发生

221
00:33:37,320 --> 00:33:44,780
这个lambda部分其实是在sum内作为term来调用

222
00:33:44,780 --> 00:33:47,350
这时再来查找n的定义

223
00:33:47,350 --> 00:33:50,700
这样我们找到的n就不是sum-powers的n了，而变成了sum这里的n

224
00:33:50,700 --> 00:33:54,680
因此，在过程的内部的小小修改就导致了整个程序停止工作

225
00:33:56,770 --> 00:34:00,020
这里的n就不再是一个量词了

226
00:34:02,700 --> 00:34:05,430
在这个lambda里n应该是一个量词才对

227
00:34:05,430 --> 00:34:24,040
一个事物所绑定的名字应该是不重要的，如果我在这里针对一个名字统一换成别的，表达式的含义也应该保持不变

228
00:34:24,040 --> 00:34:28,690
但是刚才我只是对next换成了n而已，就导致nth-powers改变了意思

229
00:34:28,690 --> 00:34:32,170
所以这里用lambda也就不妥当了

230
00:34:32,170 --> 00:34:34,550
这个问题非常严重

231
00:34:34,550 --> 00:34:48,090
因为这个原因，我和同事们放弃了动态绑定，相对的我更喜欢模块化原则

232
00:34:48,090 --> 00:34:54,530
这也是一种针对求值器的探索

233
00:34:54,530 --> 00:34:58,270
你可以尝试多种方法

234
00:34:58,270 --> 00:35:00,070
从中你会了解到 是什么使一个语言更加优雅

235
00:35:02,680 --> 00:35:04,990
所以元循环真的很重要

236
00:35:04,990 --> 00:35:10,880
现在我们来想想在动态绑定的前提下 怎么样使得这里的程序可以正常运行

237
00:35:10,880 --> 00:35:16,280
如何正确的利用动态绑定带来的好处呢？

238
00:35:16,280 --> 00:35:23,690
答案是，我只想要一个针对n求指数的过程

239
00:35:23,690 --> 00:35:26,280
给定一个n，它就返回一个求n次方的过程

240
00:35:26,280 --> 00:35:28,170
这非常简单

241
00:35:28,170 --> 00:35:30,570
换言之，我可以这样来写

242
00:35:35,450 --> 00:35:45,240
我定义一个过程PGEN，达到刚才所说的效果

243
00:35:50,240 --> 00:35:51,490
(lambda (n) (lambda (x) (expt x n)))

244
00:35:56,900 --> 00:36:07,890
这样来写的话会更好一些，封装就不会被改名的情况而破坏了

245
00:36:07,890 --> 00:36:37,590
(define sum-powers (lambda (a b n) (sum (pgen n) a 1+ b)))

246
00:36:42,490 --> 00:37:11,150
再定义product-powers，(define product-powers (lambda (a b n) (product (pgen n) a 1+ b)))

247
00:37:11,150 --> 00:37:17,280
当然，这里的这个例子针对的抽象很简单

248
00:37:17,280 --> 00:37:20,100
但是这样来写的话就导致要写更多的代码

249
00:37:20,100 --> 00:37:23,670
这样写的目的在于使其清晰一些

250
00:37:23,670 --> 00:37:28,200
确保这里的n引用的是正确的n

251
00:37:28,200 --> 00:37:34,050
pgen这里的n明显的就是product-powers这里的n

252
00:37:37,130 --> 00:37:40,210
你也可以认为这个过程调用是一个很长的名字

253
00:37:40,210 --> 00:37:49,220
这里我用一个n为参数可以生成新过程的过程来避免了之前的问题

254
00:37:55,080 --> 00:37:57,140
有什么问题吗？

255
00:37:57,140 --> 00:37:58,380
你说，David

256
00:37:58,380 --> 00:38:06,470
刚才那个问题只有这一种解决办法吗？

257
00:38:06,470 --> 00:38:12,402
换句话说，是不是只有那些过程可作为对象的语言才可以用这样的方法来解决？

258
00:38:12,402 --> 00:38:13,765
我想想

259
00:38:16,530 --> 00:38:28,190
我的解决方法是构造抽象，我没有把过程用lambda定义在sum里，而是定义在外面，然后这个过程生成一个新过程

260
00:38:28,190 --> 00:38:30,410
没错

261
00:38:30,410 --> 00:38:43,000
如果过程作为对象，我就不能这样来解决符号冲突的问题了

262
00:38:43,000 --> 00:38:45,610
你说的对

263
00:38:45,610 --> 00:39:03,700
我可以把过程作为函数返回值，也只能在过程是一类公民的语言中可以做到，这一点对于模块化编程非常重要

264
00:39:03,700 --> 00:39:07,440
有很多种方式来解决这个问题

265
00:39:07,440 --> 00:39:15,840
你需要的做的就是考虑所有你认为糟糕的情况，然后做一个feature来解决它

266
00:39:15,840 --> 00:39:17,930
你可以做一个包系统

267
00:39:17,930 --> 00:39:22,240
或者像Ada中的模块系统

268
00:39:22,240 --> 00:39:26,440
这些都可以，可能区别只是解决的程度不一

269
00:39:26,440 --> 00:39:45,590
过程作为返回值这一点可以解决所有问题，这种最简单的机制，却可以给予你最好的模块性

270
00:39:45,590 --> 00:39:48,248
好的，该休息一会儿了

271
00:39:48,248 --> 00:40:41,871
[MUSIC PLAYING]

272
00:40:41,871 --> 00:40:55,420
昨天你们学习流的时候，哈罗德向你们提到过求值顺序与过程参数延时求值的问题

273
00:40:55,420 --> 00:41:15,250
我们昨天讲了流，其中调用者和被调用者都必须了解参数是被delay的，然后被调用者对参数force而得到结果

274
00:41:15,250 --> 00:41:26,100
这样的话，过程的开发者和过程的使用者就需要太多的交流与协商

275
00:41:26,100 --> 00:41:45,900
这看起来很糟糕，但是对于流来说没什么不妥。但是，广泛着来看，我们想要的是一个广泛层面的设计决策，而且可以显式的清晰的表述出来

276
00:41:45,900 --> 00:41:59,500
所以，如果过程编写者和过程使用者需要花费不少的精力去协商比如参数是否求值、求值顺序的问题，那是十分不妥当的

277
00:41:59,500 --> 00:42:00,750
但是也不是太糟糕

278
00:42:00,750 --> 00:42:04,540
我的意思是，可能参数输入的是一个数字

279
00:42:04,540 --> 00:42:11,020
但是，如果其中一个人可以全权负责这部分的事情是再好不过了

280
00:42:11,020 --> 00:42:15,510
这个想法已经不算新潮了

281
00:42:15,510 --> 00:42:22,020
ALGOL就提供了完全不同的两种方式来执行过程

282
00:42:22,020 --> 00:42:25,590
参数作为名称传递或者值传递

283
00:42:25,590 --> 00:42:31,110
按名字传递的意思即这个参数会延时求值

284
00:42:31,110 --> 00:42:39,620
当你按名字传递一个参数，只有你去取它的值的时候，它的值才会被计算出来

285
00:42:42,290 --> 00:42:50,320
我们接下来，还要对语言进行一些小的修改

286
00:42:50,320 --> 00:42:53,370
这里，我们再添加一个新的feature

287
00:42:53,370 --> 00:43:00,430
可以称作为“名称参数”，或者你就理解为 延时参数 就行

288
00:43:00,430 --> 00:43:08,220
因为事实上，我们的Lisp中默认传递的是指针的值

289
00:43:08,220 --> 00:43:13,410
指针被复制了，但是它所指向的数据结构却没有变化 [在没有赋值与副作用的情况下，这不会造成什么影响]

290
00:43:13,410 --> 00:43:19,990
我也会讲到，如何来使用名称参数

291
00:43:19,990 --> 00:43:23,100
为什么我们需要这样的feature呢？

292
00:43:23,100 --> 00:43:29,720
语言中的保留字在eval中都属于特殊形式，假如我们开发出具有保留字那样的功能

293
00:43:29,720 --> 00:43:32,180
但是并不是添加新的保留字

294
00:43:32,180 --> 00:43:36,360
我想用一个过程来达到if的效果

295
00:43:36,360 --> 00:43:39,420
if很特殊，cond也是

296
00:43:39,420 --> 00:43:40,600
它们很一样

297
00:43:40,600 --> 00:43:50,840
if特殊在它会根据谓词的真假来判断是执行真语句还是假语句

298
00:43:50,840 --> 00:43:57,270
谓词的值决定了做不做后续的事

299
00:43:57,270 --> 00:44:08,670
然而像 + 之类的过程，它们的参数可以在过程应用之前求值

300
00:44:08,670 --> 00:44:19,452
假如我现在用保留字if来定义一个与if相反含义的过程

301
00:44:19,452 --> 00:44:20,702
叫它unless

302
00:44:24,890 --> 00:44:28,190
一个谓词，一个真语句，一个假语句

303
00:44:28,190 --> 00:44:32,440
接下来的是，哦，我用的是cond来定义，不是if，前面说错了

304
00:44:32,440 --> 00:44:45,350
(cond ((not p) c) (else a))

305
00:44:51,290 --> 00:44:56,920
在这种情况下，假设我继续做下面的

306
00:44:56,920 --> 00:45:11,350
(unless (= 1 0) 2 (/ 1 0))

307
00:45:15,980 --> 00:45:25,580
接下来要做的是进行代换，下面的1 2 3参数分别对应上面的p c a

308
00:45:25,580 --> 00:45:51,160
代换过后就像是，(cond ((not (= 1 0)) 2) (else (/ 1 0)))

309
00:45:54,480 --> 00:45:59,970
如果你直接把cond这一部分输入Lisp，会得到结果2

310
00:45:59,970 --> 00:46:02,910
没问题

311
00:46:02,910 --> 00:46:10,840
然而，如果我把unless这一部分输入Lisp，参数会在过程执行之前先求值，这样(/ 1 0)这里就会报错

312
00:46:13,380 --> 00:46:16,880
如果代换为cond，我可以得到正确的结果

313
00:46:16,880 --> 00:46:20,160
但是这里这种情况，代换并不能进行

314
00:46:22,920 --> 00:46:23,860
我得到了错误的结果

315
00:46:23,860 --> 00:46:24,670
没结果

316
00:46:24,670 --> 00:46:25,920
还是一个错误

317
00:46:28,420 --> 00:46:34,270
现在，我要想办法使这样的定义可以成功运行

318
00:46:34,270 --> 00:46:39,930
这里我要对 c 和 a 动点手脚

319
00:46:39,930 --> 00:46:42,715
我想使它们自动延时求值

320
00:46:46,300 --> 00:46:51,520
不想使它们在执行过程之前就求值

321
00:46:51,520 --> 00:46:55,600
所以按照惯例，我先构造一种语法描述，之后我们再来具体的实现它

322
00:46:55,600 --> 00:47:02,140
你们应该深信，我正在添加一个有趣的kluge[不知怎么译的准确]

323
00:47:02,140 --> 00:47:05,750
太多的kluge会使得系统混乱复杂

324
00:47:05,750 --> 00:47:10,120
还会搞砸以后要添加的功能

325
00:47:10,120 --> 00:47:13,860
新的语法描述，先来看，是否有语法上混淆的问题

326
00:47:13,860 --> 00:47:17,840
当然，这里我要写的是一个清晰的无二义的新语法

327
00:47:17,840 --> 00:47:21,670
但是接下来要做的却会导致另外的问题

328
00:47:21,670 --> 00:47:34,300
可能以后我们会为了优化系统或者编译器而引入类型声明的机制，我一会儿要定义的新语法可能会与之冲突

329
00:47:34,300 --> 00:47:40,570
或者会与那些声明参数类型这样的机制相冲突

330
00:47:40,570 --> 00:47:44,925
所以我这里要添加的机制并不是一个完整的机制

331
00:47:44,925 --> 00:47:46,750
只是能解决目前的问题而已

332
00:47:46,750 --> 00:47:51,010
具体怎么样完整就不在这里说了

333
00:47:51,010 --> 00:47:53,680
接下来

334
00:47:57,050 --> 00:48:14,930
我再来定义unless，一个谓词，真真假语句都按名称来传递，即(name c) (name a)

335
00:48:19,850 --> 00:48:25,280
哦没估计好，卡在黑板边了

336
00:48:31,240 --> 00:48:41,360
(cond ((not p) c) (else a))

337
00:48:44,670 --> 00:48:51,650
我可以显式的来声明，哪些参数按名称传递延时求值

338
00:48:55,008 --> 00:49:00,450
这样的话，要对求值器做出的修改可就比之前的feature要复杂多了

339
00:49:00,450 --> 00:49:09,280
之前的动态绑定，或者不定参数，相比比较简单

340
00:49:09,280 --> 00:49:12,120
但是这里，是一个基本原则的改变

341
00:49:12,120 --> 00:49:36,110
我们之前的解释器，解释组合式时，先求值操作符，再求值操作数，最后再用操作符应用于操作数得到结果

342
00:49:36,110 --> 00:49:46,810
然而这里，在我检测过整个过程的声明之前，我并不想立即求值操作数

343
00:49:49,590 --> 00:49:52,680
我们来看这个

344
00:49:52,680 --> 00:49:57,480
对求值器的修改

345
00:49:57,480 --> 00:50:09,750
这是从最开始的那个求值器修改得来的，不是动态绑定的那个  这里的修改和之前的有些相似

346
00:50:09,750 --> 00:50:19,360
如果我延时一个过程 -- 哦说错了 -- 延时一个过程的参数，就必须把当前的环境和参数关联在一起

347
00:50:19,360 --> 00:50:23,380
还记得哈罗德教授是怎么实现delay的吧

348
00:50:23,380 --> 00:50:31,180
哈罗德教授把delay实现为一个没有参数的过程，其中包含了要延时的操作

349
00:50:31,180 --> 00:50:32,670
就像这样

350
00:50:35,370 --> 00:50:36,620
(delay e)

351
00:50:39,180 --> 00:50:40,950
返回下面的(lambda () e)

352
00:50:44,520 --> 00:50:49,010
然而，我要执行这个lambda，就必须要在一定的环境下

353
00:50:51,410 --> 00:51:01,530
原因是因为其中有一些自由变量只有在正确的上下文中才能正确解读

354
00:51:04,010 --> 00:51:06,095
这也是 用lambda来实现delay的原因

355
00:51:06,095 --> 00:51:08,070
非常合适

356
00:51:08,070 --> 00:51:21,090
相对应的，对延时对象force就是执行这个无参数的过程

357
00:51:21,090 --> 00:51:24,100
和上面恰恰相对

358
00:51:24,100 --> 00:51:33,132
为过程调用生成了新的环境就是在过程定义的时候所附加的新frame

359
00:51:33,132 --> 00:51:36,240
这里就不细细讨论了

360
00:51:36,240 --> 00:51:51,980
我们再来看这张幻灯片，仔细看一会儿，会发现大部分都是相同的，只有最下面处理组合式的地方不同

361
00:51:51,980 --> 00:51:54,680
这种情况有两个部分

362
00:51:54,680 --> 00:52:00,425
一是我得先求值操作符

363
00:52:00,425 --> 00:52:02,380
也就是这一部分

364
00:52:02,380 --> 00:52:10,730
这里我要保证它已经被求出值的，也即用undelay来确保操作符不再是延时对象

365
00:52:10,730 --> 00:52:18,460
然后应用于操作数

366
00:52:18,460 --> 00:52:21,530
这里还要保存下当前的环境，作为第三个参数传递过去

367
00:52:21,530 --> 00:52:23,710
如果有一些参数是延时了的

368
00:52:23,710 --> 00:52:29,302
就需要用此时的环境来求值

369
00:52:29,302 --> 00:52:32,990
看起来已经十分复杂了

370
00:52:32,990 --> 00:52:34,240
再来看看apply

371
00:52:36,400 --> 00:52:42,610
这一部分还是判断基本过程，和之前一样

372
00:52:42,610 --> 00:52:44,390
组合过程的部分就比较有意思了

373
00:52:47,250 --> 00:53:00,290
我要在过程定义时绑定的环境下求值过程，但是参数要在和延时参数关联起来的环境下求值

374
00:53:00,290 --> 00:53:01,530
两个环境

375
00:53:01,530 --> 00:53:03,820
这个环境是定义过程时关联的环境

376
00:53:03,820 --> 00:53:08,040
静态绑定

377
00:53:08,040 --> 00:53:12,960
我还需要的是去掉name声明，获得变量的实际名字

378
00:53:12,960 --> 00:53:15,450
也就是vnames过程所要做的

379
00:53:15,450 --> 00:53:33,770
然后要做的就是，这些操作数，哪些要马上求值，哪些要先用延时封装起来

380
00:53:37,280 --> 00:53:45,820
另外，如果遇到的基本过程，操作数还是要马上求值

381
00:53:45,820 --> 00:53:47,690
也就是这里

382
00:53:47,690 --> 00:53:51,340
evlist中其中做了很多force的工作

383
00:53:51,340 --> 00:53:52,780
所以这里有两个evlist

384
00:53:52,780 --> 00:53:59,870
evlist和gevlist gevlist对要延时的参数加以封装，对其它的则马上求值

385
00:53:59,870 --> 00:54:07,900
evlist的话就是单纯的去求值

386
00:54:07,900 --> 00:54:12,250
来看evlist，这里我们只需做我们自己的事就行，大家已经很熟悉了

387
00:54:12,250 --> 00:54:19,730
这里不会有求值器传递过来的多种情况

388
00:54:19,730 --> 00:54:21,410
我们只需要一味求值就可以了

389
00:54:21,410 --> 00:54:29,930
在你感觉过这种方式之后，你将会看到另一种方式，这里你需要处理不同的设计决策，了解它们的具体意思，清楚它们如何相互关联

390
00:54:29,930 --> 00:54:33,160
任何语言都是这样

391
00:54:33,160 --> 00:54:37,200
普遍通用的规则与少量特殊的规则，协同构建一门合理的语言

392
00:54:37,200 --> 00:54:41,850
然后如果有太多的kluge，就会对语言造成破坏

393
00:54:41,850 --> 00:54:50,750
回到evlist上来，针对所有的操作数force求值

394
00:54:50,750 --> 00:54:56,050
无论操作数是否是延时对象

395
00:54:56,050 --> 00:55:04,040
下一个，gevlist

396
00:55:04,040 --> 00:55:09,810
这里，就会发现有很多种情况

397
00:55:09,810 --> 00:55:19,390
如果不是用name延时的参数，就像unless中谓词部分，对应这一部分代码

398
00:55:19,390 --> 00:55:23,340
这一部分就使用应用序求值

399
00:55:23,340 --> 00:55:25,630
就像以前一样

400
00:55:25,630 --> 00:55:37,900
然后递归求值，就是对CAR求值之后，再用gevlist对剩下的求值

401
00:55:37,900 --> 00:55:43,600
然而，有可能我们遇到一个延时参数

402
00:55:43,600 --> 00:56:02,790
如果是一个延时参数，就delay这个参数，还要记得封装当前的环境

403
00:56:02,790 --> 00:56:05,600
然后继续递归

404
00:56:09,070 --> 00:56:14,700
另一个有意思的地方是evcond

405
00:56:14,700 --> 00:56:18,550
人们可能认为这一部分没什么特别的，就草草写完

406
00:56:18,550 --> 00:56:20,510
这里有一个地方是需要force的，值得注意

407
00:56:20,510 --> 00:56:25,990
条件式必须先知道谓词的真假

408
00:56:25,990 --> 00:56:28,550
就像一个基本过程一样

409
00:56:28,550 --> 00:56:31,890
当你定义条件式的时候，你必须需要force

410
00:56:31,890 --> 00:56:34,350
剩下的细节就没什么特别的了

411
00:56:34,350 --> 00:56:36,750
就先不深究了

412
00:56:36,750 --> 00:56:38,990
剩下的就是delay的实现了

413
00:56:38,990 --> 00:56:44,840
delay就是一个数据结构，其中包括了类型'trunk，表达式和环境 

414
00:56:44,840 --> 00:56:46,680
'thunk标明这是一个trunk

415
00:56:46,680 --> 00:56:52,970
是从ALGOL借用过来的，原义大概是把什么压在栈中

416
00:56:52,970 --> 00:56:53,410
记不清了

417
00:56:53,410 --> 00:56:58,740
我对ALGOL了解的不深入

418
00:56:58,740 --> 00:57:00,270
但是我们就在这里借用它了

419
00:57:00,270 --> 00:57:07,860
undelay不断递归的force求值，直到遇到不是'trunk的对象

420
00:57:07,860 --> 00:57:12,050
这就是具体的实现

421
00:57:12,050 --> 00:57:15,210
全部都在这里了

422
00:57:15,210 --> 00:57:16,460
有什么问题吗？

423
00:57:26,840 --> 00:57:27,560
Gerry？

424
00:57:27,560 --> 00:57:29,626
你说，Vesko

425
00:57:29,626 --> 00:57:39,350
我注意到，在调用基本过程的时候，你避免用名字传递参数，这样做有什么原因吗？

426
00:57:39,350 --> 00:57:40,070
需要这样吗？

427
00:57:40,070 --> 00:57:47,140
Vesko想问的是 基本过程的参数如果按名字传递是否合理？

428
00:57:47,140 --> 00:57:49,270
答案是 是的

429
00:57:49,270 --> 00:57:52,930
有一种情况下是可以的，哦两种

430
00:57:56,050 --> 00:58:03,690
比如用cons来构建一个数组的数据结构

431
00:58:03,690 --> 00:58:07,440
没必要求值参数

432
00:58:07,440 --> 00:58:11,160
你只需要一个约定，一个需要计算参数的时候就可以得到结果的约定

433
00:58:11,160 --> 00:58:21,830
如果我用cons把两个东西连接起来，连接两个约定和连接两个实际的东西一样简单

434
00:58:21,830 --> 00:58:24,840
甚至在用CAR CDR取出的时候也不用计算

435
00:58:24,840 --> 00:58:28,260
直接把约定传递给其它人

436
00:58:28,260 --> 00:58:34,420
这也是阿隆佐 丘奇用lambda演算定义的cons能够说得通的原因

437
00:58:34,420 --> 00:58:40,760
因为在cons car cdr中并没有什么计算，它们不过是存东西取东西而已

438
00:58:40,760 --> 00:58:45,280
然而像 + 这样的过程必须要了解参数是什么

439
00:58:45,280 --> 00:58:52,460
因为 + 需要和实际组成数字的比特打交道，如果遇到一个lambda就搞笑了

440
00:58:52,460 --> 00:58:55,880
它要从数字的比特层面来实际计算

441
00:58:59,210 --> 00:59:13,300
可能在一种最懒惰的解释器实现中，数据构造器，数据选择器，包括像有副作用的一些对象都是不需要force求值的

442
00:59:16,460 --> 00:59:18,700
话说回来判断数据结构的谓词还是需要force的

443
00:59:21,710 --> 00:59:23,560
这是一个序对吗？

444
00:59:23,560 --> 00:59:24,640
或者是一个符号？

445
00:59:24,640 --> 00:59:25,690
最好搞清楚是什么

446
00:59:25,690 --> 00:59:26,940
这点还是挺重要的

447
00:59:30,300 --> 00:59:31,550
还有问题吗？

448
00:59:40,050 --> 00:59:41,610
没了，下面是休息时间

449
00:59:41,610 --> 00:59:42,106
下课

450
00:59:42,106 --> 01:00:02,950
[MUSIC PLAYING]

