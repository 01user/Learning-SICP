1
00:00:20,970 --> 00:00:24,080
教授：上节课 我们介绍了流
PROFESSOR: OK, well, we've been looking at streams,

2
00:00:24,080 --> 00:00:27,824
一种使用信号处理的方式来组织系统
this signal processing way of putting systems together.

3
00:00:28,870 --> 00:00:31,424
要记住的是，关键在于我们将程序看起来的运算顺序与实际在机器中计算的顺序分离开来
And remember, the key idea is that we decouple the apparent order of events in our programs from the actual order of events in the computer.

4
00:00:31,904 --> 00:00:32,960
要记住的是，关键在于我们将程序看起来的运算顺序与实际在机器中计算的顺序分离开来
And remember, the key idea is that we decouple the apparent order of events in our programs from the actual order of events in the computer.

5
00:00:34,208 --> 00:00:37,312
要记住的是，关键在于我们将程序看起来的运算顺序与实际在机器中计算的顺序分离开来
And remember, the key idea is that we decouple the apparent order of events in our programs from the actual order of events in the computer.

6
00:00:37,584 --> 00:00:40,176
要记住的是，关键在于我们将程序看起来的运算顺序与实际在机器中计算的顺序分离开来
And remember, the key idea is that we decouple the apparent order of events in our programs from the actual order of events in the computer.

7
00:00:41,072 --> 00:00:42,288
那就意味着，我们着手处理非常长的流，其中的元素只是在需要的时候才生成
And that means that we can start dealing with very long streams and only having to generate the elements on demand.

8
00:00:42,576 --> 00:00:44,144
那就意味着，我们着手处理非常长的流，其中的元素只是在需要的时候才生成
And that means that we can start dealing with very long streams and only having to generate the elements on demand.

9
00:00:44,896 --> 00:00:47,392
那就意味着，我们着手处理非常长的流，其中的元素只是在需要的时候才生成
And that means that we can start dealing with very long streams and only having to generate the elements on demand.

10
00:00:47,536 --> 00:00:49,392
这种按需计算的方式是内建在流的数据结构中的
That sort of on-demand computation is built into the stream's data structure.

11
00:00:49,520 --> 00:00:51,408
这种按需计算的方式是内建在流的数据结构中的
That sort of on-demand computation is built into the stream's data structure.

12
00:00:54,110 --> 00:00:57,080
即使这个流非常之长，我们也可以只计算我们需要的
So if we have a very long stream, we only compute what we need.

13
00:00:58,040 --> 00:01:00,750
只有当我们要求的时候，新的数据才会生成
The things only get computed when we actually ask for them.

14
00:01:00,750 --> 00:01:01,744
例子是什么呢？
Well, what are examples?

15
00:01:02,110 --> 00:01:03,600
真的像我们所说的那样吗？
Are they actually asking for them?

16
00:01:05,024 --> 00:01:06,016
举个例子，假如我们想要一个流中的第n个元素
For instance, we might ask for the n-th element of a stream.

17
00:01:09,216 --> 00:01:11,376
举个例子，假如我们想要一个流中的第n个元素
For instance, we might ask for the n-th element of a stream.

18
00:01:15,360 --> 00:01:18,928
这个过程可以计算出来
Here's a procedure that computes the n-th element of a stream.

19
00:01:20,090 --> 00:01:21,232
n代表第n个，s是一个流，剩下的只需要沿着流递归下去
An integer n, the n-th element of some stream s, and we just recursively walk down the stream.

20
00:01:21,248 --> 00:01:22,848
n代表第n个，s是一个流，剩下的只需要沿着流递归下去
An integer n, the n-th element of some stream s, and we just recursively walk down the stream.

21
00:01:23,408 --> 00:01:25,424
n代表第n个，s是一个流，剩下的只需要沿着流递归下去
An integer n, the n-th element of some stream s, and we just recursively walk down the stream.

22
00:01:25,570 --> 00:01:27,392
n是0的时候就是终点
And the end of 0, we compute the head.

23
00:01:27,960 --> 00:01:30,992
否则，就在流的TAIL查找第n-1个元素
Otherwise, it's the n-th the minus 1 element of the tail of the stream.

24
00:01:31,744 --> 00:01:32,800
否则，就在流的TAIL查找第n-1个元素
Otherwise, it's the n-th the minus 1 element of the tail of the stream.

25
00:01:34,310 --> 00:01:36,432
看起来是LISP中很普通的编程方式，但是不同之处在于，我们沿着流取值，只有途经的n个元素被计算出来
Those two are just like for Lisp, but the difference is those elements aren't going to get computed until we walk down, taking successive n-ths.

26
00:01:36,624 --> 00:01:38,768
看起来是LISP中很普通的编程方式，但是不同之处在于，我们沿着流取值，只有途经的n个元素被计算出来
Those two are just like for Lisp, but the difference is those elements aren't going to get computed until we walk down, taking successive n-ths.

27
00:01:38,864 --> 00:01:40,992
看起来是LISP中很普通的编程方式，但是不同之处在于，我们沿着流取值，只有途经的n个元素被计算出来
Those two are just like for Lisp, but the difference is those elements aren't going to get computed until we walk down, taking successive n-ths.

28
00:01:41,520 --> 00:01:44,784
因为它们被FORCE了
So that's one way that the stream elements might get forced.

29
00:01:45,776 --> 00:01:46,640
这里有另一个简单的过程，打印一个流
And another way, here's a little procedure that prints a stream.

30
00:01:47,184 --> 00:01:48,928
这里有另一个简单的过程，打印一个流
And another way, here's a little procedure that prints a stream.

31
00:01:49,300 --> 00:01:50,384
把流中的元素依次打印输出
We say print a stream, so to print a stream s.

32
00:01:51,904 --> 00:01:53,280
把流中的元素依次打印输出
We say print a stream, so to print a stream s.

33
00:01:54,150 --> 00:01:55,120
我们要怎么做呢？
Well, what do we do? We'll

34
00:01:55,744 --> 00:01:56,864
先打印流的head，流的head这时就被计算出来
We print the head of the stream, and that will cause the head to be computed.

35
00:01:57,744 --> 00:01:59,328
先打印流的head，流的head这时就被计算出来
We print the head of the stream, and that will cause the head to be computed.

36
00:01:59,720 --> 00:02:02,848
然后再递归打印流的tail
And then we recursively print stream the tail of the stream.

37
00:02:04,990 --> 00:02:06,032
如果流为空，就返回一个“done”的消息
And if we're already done, maybe we have to return something about the message done.

38
00:02:06,048 --> 00:02:08,576
如果流为空，就返回一个“done”的消息
And if we're already done, maybe we have to return something about the message done.

39
00:02:09,660 --> 00:02:11,392
如果你构造了一个流 这个流非常之长
OK, and then so if you make a stream, you could say here's the stream, this very long stream.

40
00:02:11,648 --> 00:02:13,648
如果你构造了一个流 这个流非常之长
OK, and then so if you make a stream, you could say here's the stream, this very long stream.

41
00:02:14,310 --> 00:02:16,336
这时你再来打印这个流 流中的元素会依次的计算并打印出来
And then you say print the stream, and the elements of the stream will get computed successively as that print calls them.

42
00:02:16,416 --> 00:02:19,776
这时你再来打印这个流 流中的元素会依次的计算并打印出来
And then you say print the stream, and the elements of the stream will get computed successively as that print calls them.

43
00:02:19,872 --> 00:02:21,120
这时你再来打印这个流 流中的元素会依次的计算并打印出来
And then you say print the stream, and the elements of the stream will get computed successively as that print calls them.

44
00:02:21,320 --> 00:02:22,816
并不会一次性的全部计算出来
They won't get all computed initially.

45
00:02:24,300 --> 00:02:25,664
正因为如此 我们就能处理非常长的流
So in this way, we can deal with some very long streams.

46
00:02:27,504 --> 00:02:29,610
正因为如此 我们就能处理非常长的流
So in this way, we can deal with some very long streams.

47
00:02:30,190 --> 00:02:31,920
多长呢？
Well, how long can a stream be?

48
00:02:33,744 --> 00:02:35,120
无穷
Well, it can be infinitely long.

49
00:02:35,904 --> 00:02:38,048
我们用电脑来实践一下
Let's look at an example here on the computer.

50
00:02:38,920 --> 00:02:41,968
在解释器里，我们输入(DEFINE (INTEGERS-FROM N) 定义一个从N开始的整数流
I could walk up to this computer, and I could say-- how about we'll define the stream of integers starting with some number N, the stream of positive integers starting with some number n.

51
00:02:43,488 --> 00:02:53,312
在解释器里，我们输入(DEFINE (INTEGERS-FROM N) 定义一个从N开始的整数流
I could walk up to this computer, and I could say-- how about we'll define the stream of integers starting with some number N, the stream of positive integers starting with some number n.

52
00:02:54,240 --> 00:02:57,136
在解释器里，我们输入(DEFINE (INTEGERS-FROM N) 定义一个从N开始的整数流
I could walk up to this computer, and I could say-- how about we'll define the stream of integers starting with some number N, the stream of positive integers starting with some number n.

53
00:03:00,368 --> 00:03:07,488
(CONS-STREAM N (INTEGERS-FROM (+ N 1))))
And that's cons-stream of n onto the integers from one more.

54
00:03:10,080 --> 00:03:19,010
(CONS-STREAM N (INTEGERS-FROM (+ N 1))))
And that's cons-stream of n onto the integers from one more.

55
00:03:24,416 --> 00:03:25,616
这样就我们要的全部整数
So there are the integers.

56
00:03:28,992 --> 00:03:31,500
现在我们用这个表示所有的整数
Then I could say let's get all the integers.

57
00:03:34,576 --> 00:03:38,400
(DEFINE INTEGERS (INTEGERS-FROM 1))
define the stream of integers to be the integers starting with 1.

58
00:03:41,328 --> 00:03:44,416
(DEFINE INTEGERS (INTEGERS-FROM 1))
define the stream of integers to be the integers starting with 1.

59
00:03:48,840 --> 00:03:55,808
现在执行 (NTH-STREAM 20 INTEGERS) 查看第20个元素
And now if I say something like what's the what's the 20th integer.

60
00:04:03,424 --> 00:04:05,536
得到21 因为我们以n=0为结束条件
So it's 21 because we start counting at 0.

61
00:04:06,848 --> 00:04:08,880
或者我们来点更复杂的
Or I can do more complicated things.

62
00:04:09,450 --> 00:04:10,840
我再来定义一个谓词
Let me to define a little predicate here.

63
00:04:11,776 --> 00:04:18,512
(DEFINE (NO-SEVEN X）
How about define no-seven.

64
00:04:19,580 --> 00:04:20,752
它可以检测一个整数，判断是否是7的倍数
It's going to test an integer, and it's going to say it's not.

65
00:04:21,792 --> 00:04:23,168
它可以检测一个整数，判断是否是7的倍数
It's going to test an integer, and it's going to say it's not.

66
00:04:28,820 --> 00:04:33,968
(NOT (= (REMAINDER X 7) 0))) X对7的余数不为0
I take the remainder of x by 7, I don't get 0.

67
00:04:36,624 --> 00:04:38,352
(NOT (= (REMAINDER X 7) 0))) X对7的余数不为0
I take the remainder of x by 7, I don't get 0.

68
00:04:43,808 --> 00:04:49,776
这时用NO-SEVEN这个谓词，过滤全部的整数
And then I could say define the integers with no sevens to be, take all the integers and filter them to have no sevens.

69
00:04:50,224 --> 00:04:59,120
这时用NO-SEVEN这个谓词，过滤全部的整数
And then I could say define the integers with no sevens to be, take all the integers and filter them to have no sevens.

70
00:05:11,570 --> 00:05:13,344
这样就得到了所有不是7的倍数的整数
So now I've got the stream of all the integers that are not divisible by seven.

71
00:05:13,632 --> 00:05:15,056
这样就得到了所有不是7的倍数的整数
So now I've got the stream of all the integers that are not divisible by seven.

72
00:05:16,480 --> 00:05:17,504
现在我来查看第100个不是7的倍数的整数
So if I say what's the 100th integer and the list not divisible by seven, I get 117.

73
00:05:22,320 --> 00:05:26,480
现在我来查看第100个不是7的倍数的整数
So if I say what's the 100th integer and the list not divisible by seven, I get 117.

74
00:05:26,864 --> 00:05:28,112
现在我来查看第100个不是7的倍数的整数
So if I say what's the 100th integer and the list not divisible by seven, I get 117.

75
00:05:28,320 --> 00:05:30,672
或者你也想知道这个流的全部元素
Or if I'd like to say well, gee, what are all of them?

76
00:05:32,304 --> 00:05:34,384
或者你也想知道这个流的全部元素
Or if I'd like to say well, gee, what are all of them?

77
00:05:35,270 --> 00:05:40,352
(PRINT-STREAM NS) 来尝试打印这个流 现在输出个不停
So I could say print stream all these integers with no seven, it goes off printing.

78
00:05:40,832 --> 00:05:41,792
(PRINT-STREAM NS) 来尝试打印这个流 现在输出个不停
So I could say print stream all these integers with no seven, it goes off printing.

79
00:05:45,100 --> 00:05:47,070
无穷的数应该永远打印不完吧
You may have to wait a very long time to see them all.

80
00:05:52,670 --> 00:05:53,840
你可能会问了，你写的这个INTEGERS真的是全部的整数吗？
Well, you can start asking, gee, is it really true that this data structure with the integers is really all the integers?

81
00:05:54,816 --> 00:05:57,008
你可能会问了，你写的这个INTEGERS真的是全部的整数吗？
Well, you can start asking, gee, is it really true that this data structure with the integers is really all the integers?

82
00:05:58,288 --> 00:06:00,656
你可能会问了，你写的这个INTEGERS真的是全部的整数吗？
Well, you can start asking, gee, is it really true that this data structure with the integers is really all the integers?

83
00:06:01,100 --> 00:06:04,053
现在我画一个图来表示下这个过程
And let me draw a picture of that program I just wrote.

84
00:06:08,000 --> 00:06:10,576
这是我们刚才对整数的定义，它组合起第一个整数和剩下的整数，现在我们画个图来看看
Here's the definition of the integers again that I just typed in, Right it's a cons of the first integer under the integer starting with the rest. Now, we can make a picture of that and see what it looks like.

85
00:06:12,336 --> 00:06:15,984
这是我们刚才对整数的定义，它组合起第一个整数和剩下的整数，现在我们画个图来看看
Here's the definition of the integers again that I just typed in, Right it's a cons of the first integer under the integer starting with the rest. Now, we can make a picture of that and see what it looks like.

86
00:06:17,616 --> 00:06:19,770
这是我们刚才对整数的定义，它组合起第一个整数和剩下的整数，现在我们画个图来看看
Here's the definition of the integers again that I just typed in, Right it's a cons of the first integer under the integer starting with the rest. Now, we can make a picture of that and see what it looks like.

87
00:06:22,720 --> 00:06:24,320
抽象地来看，我画一个盒子来表示从n开始的所有整数
Conceptually, what I have is a box that's the integer starting with n.

88
00:06:25,536 --> 00:06:27,184
抽象地来看，我画一个盒子来表示从n开始的所有整数
Conceptually, what I have is a box that's the integer starting with n.

89
00:06:27,420 --> 00:06:29,088
它接受一个参数n，然后返回一个流，这个流表示从n开始的所有整数
It takes in some number n, and it's going to return a stream of-- this infinite stream of all integers starting with n.

90
00:06:31,424 --> 00:06:32,976
它接受一个参数n，然后返回一个流，这个流表示从n开始的所有整数
It takes in some number n, and it's going to return a stream of-- this infinite stream of all integers starting with n.

91
00:06:35,024 --> 00:06:37,360
它接受一个参数n，然后返回一个流，这个流表示从n开始的所有整数
It takes in some number n, and it's going to return a stream of-- this infinite stream of all integers starting with n.

92
00:06:38,080 --> 00:06:38,736
接下来
And what do I do?

93
00:06:38,752 --> 00:06:42,384
哦 给盒子写上名字
Well, this is an integers from box.

94
00:06:45,070 --> 00:06:45,800
里面是什么样子
What's it got in it?

95
00:06:45,800 --> 00:06:48,608
取得参数n之后，将其 +1
Well, it takes in this n, and it increments it.

96
00:06:52,272 --> 00:06:53,920
取得参数n之后，将其 +1
Well, it takes in this n, and it increments it.

97
00:06:58,030 --> 00:07:00,080
然后递归的作为另一个INT-FROM盒子的参数
And then it puts the result into recursively another integer's from box.

98
00:07:00,240 --> 00:07:03,152
然后递归的作为另一个INT-FROM盒子的参数
And then it puts the result into recursively another integer's from box.

99
00:07:06,870 --> 00:07:09,600
最后的这个结果和n组合起来，构成了最后外层盒子所返回的流
It takes the result of that and the original n and puts those together with a cons and forms a stream.

100
00:07:10,112 --> 00:07:14,270
最后的这个结果和n组合起来，构成了最后外层盒子所返回的流
It takes the result of that and the original n and puts those together with a cons and forms a stream.

101
00:07:14,270 --> 00:07:18,530
刚才那个过程画出来就是这样子
So that's a picture of that program I wrote.

102
00:07:18,530 --> 00:07:18,780
很有意思
Let's see.

103
00:07:18,780 --> 00:07:23,320
这种画法是Peter Henderson发明的，就是之前绘图语言的发明者
These kind of diagrams we first saw drawn by Peter Henderson, the same guy who did the Escher language.

104
00:07:23,320 --> 00:07:28,530
这种图也被称为Henderson diagram  画这种图需要遵守一定的约定
We call them Henderson diagrams. And the convention here is that you put these things together.

105
00:07:28,530 --> 00:07:37,270
这些实线代表生成的流，这些虚线则作为盒子的输入初始值
And the solid lines are things coming out are streams, and dotted lines are initial values going in.

106
00:07:37,270 --> 00:07:43,070
这些有形状的盒子，它们则是取一个初始值输入，然后生成一个流
So this one has the shape of-- it takes in some integer, some initial value, and outputs a stream.

107
00:07:46,410 --> 00:07:48,380
现在，你可能又要问了
Again, you can ask.

108
00:07:48,380 --> 00:07:52,340
那个INTEGERS的数据结构真的代表着全部的整数吗？
Is that data structure integers really all the integers?

109
00:07:52,340 --> 00:07:58,190
或者它只是经过了你的精心组织，以至于我们总可以在其中找到我们需要的那个整数？
Or is it is something that's cleverly arranged so that whenever you look for an integer you find it there?

110
00:07:58,190 --> 00:07:59,780
这有点哲学的味道，不是么
That's sort of a philosophical question, right?

111
00:07:59,780 --> 00:08:04,450
一个东西你无论什么时候去看，它都在那里，但是它真的是一直的在那里吗？
If something is there whenever you look, is it really there or not?

112
00:08:04,450 --> 00:08:09,420
有点类似地，就比如你的存款是否一直在银行里一样
It's sort of the same sense in which the money in your savings account is in the bank.

113
00:08:12,380 --> 00:08:19,830
好的 我们再来看一个例子
Well, let me do another example.

114
00:08:19,830 --> 00:08:28,470
课程的一开始 我们讲了一个亚力山大海伦的计算平方根的算法
Gee, we started the course with an algorithm from Alexandria, which was Heron of Alexandria's algorithm for computing the square root.

115
00:08:28,470 --> 00:08:32,030
现在再来看一个同样来自亚力山大的算法
Let's take a look at another Alexandrian algorithm.

116
00:08:32,030 --> 00:08:39,110
Eratosthenes发明的计算所有质数的算法
This one is Eratosthenes method for computing all of the primes.

117
00:08:41,169 --> 00:08:42,830
它被称为Eratosthenes筛法
It is called the Sieve of Eratosthenes.

118
00:08:42,830 --> 00:08:53,880
它是这样的，一开始，先列举所有的整数，从2开始
And what you do is you start out, and you list all the integers, say, starting with 2.

119
00:08:53,880 --> 00:08:57,310
然后取第一个整数，哦，2是一个质数
And then you take the first integer, and you say, oh, that's prime.

120
00:08:57,310 --> 00:09:01,230
然后对于除了2以外的所有整数，划掉可以被2整除的数
And then you go look at the rest, and you cross out all the things divisible by 2.

121
00:09:01,230 --> 00:09:05,250
我把这个划掉，还有这个，这个...
So I cross out this and this and this.

122
00:09:05,250 --> 00:09:11,160
有点费时，因为我要把这一页上能划掉的都划掉
This takes a long time because I have to do it for all of the integers.

123
00:09:11,160 --> 00:09:22,010
我一个一个地划掉所有被2整除的数
So I go through the entire list of integers, crossing the ones divisible by 2.

124
00:09:22,010 --> 00:09:27,040
结束之后，回头看看我们还剩下点什么
And now when I finish with all of the integers, I go back and look and say what am I left with?

125
00:09:27,040 --> 00:09:29,330
好的，我们继续，下一个数就是3了
Well, the first thing that starts there is 3.

126
00:09:29,330 --> 00:09:30,770
3也是一个质数
So 3 is a prime.

127
00:09:30,770 --> 00:09:35,120
然后同样的，在除掉3的剩下的所有数中，划掉所有被3整除的数
And now I go back through what I'm left with, and I cross out all the things divisible by 3.

128
00:09:35,120 --> 00:09:44,050
划掉9 15 21 27 33等等
So let's see, 9 and 15 and 21 and 27 and 33 and so on.

129
00:09:44,050 --> 00:09:45,350
一页实在太多了，我先不划完
I won't finish.

130
00:09:45,350 --> 00:09:47,250
看看我们还剩下什么
Then I see what I'm left with.

131
00:09:47,250 --> 00:09:50,860
依次地下一个就是5了
And the next one I have is 5.

132
00:09:50,860 --> 00:09:54,540
同样地，从除5以外剩下的数中，划掉被5整除的数
Now I can through the rest, and I find the first one that's divisible by 5.

133
00:09:54,540 --> 00:09:58,030
这样继续开始划
I cross out from the remainder all the ones that are divisible by 5.

134
00:09:58,030 --> 00:10:01,890
做完这个之后，取一个数，也就是7
And I do that, and then I go through and find 7.

135
00:10:01,890 --> 00:10:06,810
同样划掉所有被7整除的数，然后一直这样下去
Go through all the rest, cross out things divisible 7, and I keep doing that forever.

136
00:10:06,810 --> 00:10:10,120
全部结束的时候，我也就得到了所有的质数
And when I'm done, what I'm left with is a list of all the primes.

137
00:10:10,120 --> 00:10:15,430
这就是Eratosthenes筛法
So that's the Sieve of Eratosthenes.

138
00:10:15,430 --> 00:10:17,930
我们来看下实际代码
Let's look at it as a computer program.

139
00:10:17,930 --> 00:10:19,550
这个过程命名为sieve
It's a procedure called sieve.

140
00:10:27,910 --> 00:10:30,480
我只是用代码表示了我们刚才那样筛选的过程
Now, I just write what I did.

141
00:10:30,480 --> 00:10:34,510
sieve，以一个流为参数
I'll say to sieve some stream s.

142
00:10:38,770 --> 00:10:41,870
返回一个新的流，第一个元素就是参数s流的第一个元素
I'm going to build a stream whose first element is the head of this.

143
00:10:41,870 --> 00:10:59,020
这和我们刚才演示的是相符合的，然后我们从(tail s)中过滤掉所有被(head s)整除的数，再用sieve来筛选，作为结果流的TAIL部分
Remember, I always found the first thing I was left with, and the rest of it is the result of taking the tail of this, filtering it to throw away all the things that are divisible by the head of this, and now sieving the result.

144
00:10:59,020 --> 00:11:01,980
就这么简单
That's just what I did.

145
00:11:01,980 --> 00:11:06,900
为了得到所有的质数，我们以从2开始的所有整数作为sieve的参数
And now to get the infinite stream of times, we just sieve all the integers starting from 2.

146
00:11:14,920 --> 00:11:16,300
我们来实践一下
Let's try that.

147
00:11:16,300 --> 00:11:19,760
这是可以运行的
We can actually do it.

148
00:11:19,760 --> 00:11:41,350
我已经预先输入过了sieve的定义，所以这里我直接输入primes的定义
I typed in the definition of sieve before, I hope, so I can say something like define the primes to be the result of sieving the integers starting with 2.

149
00:11:46,760 --> 00:11:48,100
解释器打印PRIMES
So now I've got this list of primes.

150
00:11:48,100 --> 00:11:50,990
这样就得到了所有的质数，是不是这样呢？
That's all of the primes, right?

151
00:11:50,990 --> 00:12:01,010
拿个例子来看一下，第20个质数是什么？
So, if for example, what's the 20th prime in that list?

152
00:12:01,010 --> 00:12:02,540
打印结果是73
73.

153
00:12:02,540 --> 00:12:07,750
看，我才刚按下回车，结果就输出了，非常快
See, and that little pause, it was only at the point when I started asking for the 20th prime is that it started computing.

154
00:12:10,370 --> 00:12:14,960
现在我要求打印所有的质数
Or I can say here let's look at all of the primes.

155
00:12:22,780 --> 00:12:25,350
解释器就开始打印所有的质数
And there it goes computing all of the primes.

156
00:12:25,350 --> 00:12:28,570
肯定输出不完的 现在我们把它停掉
Of course, it will take a while again if I want to look at all of them, so let's stop it.

157
00:12:32,030 --> 00:12:33,130
现在我用图形来表示这个过程
Let me draw you a picture of that.

158
00:12:33,130 --> 00:12:34,890
我已经画好了
Well, I've got a picture of that.

159
00:12:34,890 --> 00:12:37,900
这个过程的图形应该是什么样子呢？
What's that program really look like?

160
00:12:37,900 --> 00:12:42,610
就像其它所有的图一样，一开始就是一个盒子，名字是sieve
Again, some practice with these diagrams, I have a sieve box.

161
00:12:42,610 --> 00:12:43,560
它是如何运作的呢？
How does sieve work?

162
00:12:43,560 --> 00:12:44,810
它接收一个流作为输入
It takes in a stream.

163
00:12:48,850 --> 00:12:50,870
head 和 tail 分开
It splits off the head from the tail.

164
00:12:50,870 --> 00:12:54,970
sieve盒子输出的也是一个流，第一个元素就是head
And the first thing that's going to come out of the sieve is the head of the original stream.

165
00:12:57,796 --> 00:13:02,550
这个head也还用在了filter这里
Then it also takes the head and uses that.

166
00:13:02,550 --> 00:13:03,850
这里下面，取得tail流
It takes the stream.

167
00:13:03,850 --> 00:13:09,152
filter盒子过滤掉tail中所有整除head的数
It filters the tail and uses the head to filter for nondivisibility.

168
00:13:09,152 --> 00:13:15,130
输出的流又作为一个新的sieve盒子的输入，这个sieve输出的流最后和head一起构成了最外层sieve输出的流
It takes the result of nondivisibility and puts it through another sieve box and puts the result together.

169
00:13:15,130 --> 00:13:19,650
你也可以把sieve想像为一个过滤器，不过它是一个无穷递归的过滤器
So you can think of this sieve a filter, but notice that it's an infinitely recursive filter.

170
00:13:19,650 --> 00:13:27,130
因为这个sieve盒子内部还有一个sieve，内层的sieve内部肯定还有一个sieve，无穷下去
Because inside the sieve box is another sieve box, and inside that is another sieve box and another sieve box.

171
00:13:27,130 --> 00:13:28,960
我们已经开始接触一些不得了的东西了
So you see we start getting some very powerful things.

172
00:13:28,960 --> 00:13:36,690
我们开始把 以信号处理观察现实的视角和lisp计算中的递归结合在一起
We're starting to mix this signal processing view of the world with things like recursion that come from computation.

173
00:13:36,690 --> 00:13:40,970
你们可以用它来做很多事
And there are all sorts of interesting things you can do that are like this.

174
00:13:40,970 --> 00:13:42,220
好的，有什么问题吗？
All right, any questions?

175
00:13:48,190 --> 00:13:49,440
没有，那我们休息一下
OK, let's take a break.

176
00:14:28,820 --> 00:14:32,690
我们已经了解了许多如何用流进行编程的例子
Well, we've been looking at a couple of examples of stream programming.

177
00:14:34,790 --> 00:14:41,490
那些盒子都有一个共同的特征
All the stream procedures that we've looked at so far have the same kind of character.

178
00:14:41,490 --> 00:14:51,000
我们总是递归地一次生成一个元素，再用cons-stream连接起来。因此我们必须一起思考生成流的过程
We've been writing these recursive procedures that kind of generate these stream elements one at a time and put them together in cons-streams. So we've been thinking a lot about generators.

179
00:14:51,000 --> 00:15:07,350
这里我们用另一种方式来思考流，不是那种需要沿着流一个逐个元素来思考，而是把流作为一个整体
There's another way to think about stream processing, and that's to focus not on programs that sort of process these elements as you walk down the stream, but on things that kind of process the streams all at once.

180
00:15:07,350 --> 00:15:12,410
为了把意思表示清楚，我们来看两个过程
To show you what I mean, let me start by defining two procedures that will come in handy.

181
00:15:12,410 --> 00:15:22,330
第一个过程是 add-streams，两以两个流s1 s2作为参数
The first one's called add streams. Add streams takes two streams: s1 and s2.

182
00:15:22,330 --> 00:15:22,460
然后
and.

183
00:15:22,460 --> 00:15:32,970
生成一个新的流，其元素是两个流相应位置元素的和
It's going to produce a stream whose elements are the are the corresponding sums. We just sort of add them element-wise.

184
00:15:32,970 --> 00:15:36,810
如果其中一个流是空的，我们就返回另一个流
If either stream is empty, we just return the other one.

185
00:15:36,810 --> 00:15:50,090
否则，我们就构建一个新的流，head元素是两个参数head的和，然后再递归求tail部分
Otherwise, we're going to make a new stream whose head is the sum of the two heads and whose tail is the result of recursively adding the tails.

186
00:15:50,090 --> 00:15:53,150
这就是“逐个元素来思考”来表示的整个过程
So that will produce the element-wise sum of two streams.

187
00:15:53,150 --> 00:15:57,500
另一个过程是scale-stream
And then another useful thing to have around is scale stream.

188
00:15:57,500 --> 00:16:09,710
两个参数，c是一个常数，s是一个流，结果生成的流相当于是将流s整体缩放了c倍
Scale stream takes some constant number in a stream s and is going to produce the stream of elements of s multiplied by this constant.

189
00:16:09,710 --> 00:16:18,290
这个过程表述起来很简单，就是用map-stream和这个lambda对流s进行映射
And that's easy, that's just a map of the function of an element that multiplies it by the constant, and we map that down the stream.

190
00:16:20,520 --> 00:16:27,910
考虑清楚这两个例子的区别，现在我来具体用程序演示“将流作为整体来思考”到底是什么意思
So given those two, let me show you what I mean by programs that operate on streams all at once.

191
00:16:27,910 --> 00:16:30,200
我们来看这个
Let's look at this.

192
00:16:30,200 --> 00:16:31,680
假设这样
Suppose I write this.

193
00:16:31,680 --> 00:16:52,190
(DEFINE ONES (CONS-STREAM 1 ONES))
I say define--  I'll call it ones-- to be cons-stream of 1 onto ones.

194
00:16:54,860 --> 00:16:56,950
这是什么？
What's that?

195
00:16:56,950 --> 00:17:03,330
这是一个表示无穷个1的流，因为我们看到第一个元素是1
That's going to be an infinite stream of ones because the first thing is 1.

196
00:17:03,330 --> 00:17:11,780
tail部分是ONES，ONES的head也是1，ONES的tail又是ONES，其head又是1，以此类推
And the tail of it is a thing whose first thing is 1 and whose tail is a thing whose first thing is 1 and so on and so on and so on.

197
00:17:11,780 --> 00:17:15,130
这就是无穷个1的流
So that's an infinite stream of ones.

198
00:17:15,130 --> 00:17:18,599
现在根据ONES，我再给出另一种定义整数的方式
And now using that, let me give you another definition of the integers.

199
00:17:18,599 --> 00:17:48,270
(DEFINE INTEGERS (CONS-STREAM 1 (ADD-STREAM INTEGERS ONES)))
We can define the integers to be-- well, the first integer we'll take to be 1, this cons-stream of 1 onto the element-wise sum onto add streams of the integers to ones.

200
00:17:54,950 --> 00:18:06,640
整数的第一个数是1，其余的数则是将整数全部加1
The integers are a thing whose first element is 1, and the rest of them you get by taking those integers and incrementing each one by one.

201
00:18:06,640 --> 00:18:13,940
按这种方式，第二个整数就是第一个整数加1
So the second element of the integers is the first element of the integers incremented by one.

202
00:18:13,940 --> 00:18:31,250
得到第三个整数的过程也和得到第二个整数的过程类似，就是一个不断加1的过程
And the rest of that is the next one, and the third element of that is the same as the first element of the tail of the integers incremented by one, which is the same as the first element of the original integers incremented by one and incremented by one again and so on.

203
00:18:35,240 --> 00:18:36,310
它居然可以运行，有点匪夷所思，
That looks pretty suspicious.

204
00:18:36,310 --> 00:18:40,150
这样的过程可以正常运行的关键在于延时求值
See, notice that it works because of delay.

205
00:18:40,150 --> 00:18:43,870
我们来看这个ONES
See, this looks like-- let's take a look at ones.

206
00:18:43,870 --> 00:18:51,130
这看起来根本不可能，我想知道ONES是什么，你却告诉我说把1和ONES连接在一起就是ONES
This looks like it couldn't even be processed because it's suddenly saying in order to know what ones is, I say it's cons-stream of something onto ones.

207
00:18:51,130 --> 00:18:55,250
它之所以可以运行是因为暗中隐藏的delay
The reason that works is because of that very sneaky hidden delay in there.

208
00:18:55,250 --> 00:19:00,290
关键是，cons-stream是只是一个缩写
Because what this really is, remember, cons-stream is just an abbreviation.

209
00:19:00,290 --> 00:19:08,785
实际是(CONS 1 (DELAY ONES))
This really is cons of 1 onto delay of ones.

210
00:19:12,140 --> 00:19:15,500
再来实际看一下
So how does that work?

211
00:19:15,500 --> 00:19:18,020
这里定义ONES
You say I'm going to define ones.

212
00:19:18,020 --> 00:19:20,700
首先我发现ONES是一个CONS
First I see what ones is supposed to be defined as.

213
00:19:20,700 --> 00:19:32,710
CAR部分是1，CDR部分则是一个计算的约定
Well, ones is supposed to be defined as a cons whose first part is 1 and whose second part is, well, it's a promise to compute something that I don't worry about yet.

214
00:19:32,710 --> 00:19:37,270
不用担心说ONES还没有被定义，你这里怎么可以写一个ONES
So it doesn't bother me that at the point I do this definition, ones isn't defined.

215
00:19:37,270 --> 00:19:40,670
将运行整个定义的时候，ONES就被定义了
Having run the definition now, ones is defined.

216
00:19:40,670 --> 00:19:44,920
所以当我再访问到这个部分时，ONES已经被定义过了
So that when I go and look at the tail of it, it's defined.

217
00:19:44,920 --> 00:19:46,590
这一点非常隐讳
It's very sneaky.

218
00:19:46,590 --> 00:19:48,470
下面整数的定义也是如此
And an integer is the same way.

219
00:19:48,470 --> 00:19:53,210
我可以在这里使用INTEGERS也是因为CONS-STREAM的缘故
I can refer to integers here because hidden way down-- because of this cons-stream.

220
00:19:53,210 --> 00:19:57,050
CONS-STREAM把1和剩下的部分连接起来
It's the cons-stream of 1 onto something that I don't worry that yet.

221
00:19:57,050 --> 00:20:02,570
所以我根本不用关注INTEGERS有没有定义的问题
So I don't look at it, and I don't notice that integers isn't defined at the point where I try and run the definition.

222
00:20:06,320 --> 00:20:12,430
这个定义好像还是不那么牢靠的样子，这里我们用图形来表示一下
OK, let me draw a picture of that integers thing because it still maybe seems a little bit shaky.

223
00:20:12,430 --> 00:20:15,020
怎么画呢？
What do I do?

224
00:20:15,020 --> 00:20:26,590
ONES这个流，作为输出进入一个加法器，进行流的加法
I've got the stream of ones, and that sort of comes in and goes into an adder that's going to be this add streams thing.

225
00:20:29,310 --> 00:20:35,760
输出是INTEGERS
And that goes in-- that's going to put out the integers.

226
00:20:40,760 --> 00:20:48,060
加法器另一个加数则是INTEGERS，返过来构成一个循环
And the other thing that goes into the adder here is the integer, so there's a little feedback loop.

227
00:20:48,060 --> 00:20:53,180
还需要在这里加一个初始值1才算完成
And all I need to start it off is someplace I've got a stick that initial 1.

228
00:20:57,100 --> 00:21:02,910
要是在1这里加上一个延时的器件，看起来就完全和信号处理是一回事
In a real signal processing thing, this might be a delay element with that was initialized to 1.

229
00:21:02,910 --> 00:21:07,860
当然也得除去ONES这个部分
But there's a picture of that ones program.

230
00:21:07,860 --> 00:21:17,360
如果你了解信号处理的话，你会发现这个图很像一个有穷状态的accumulator
And in fact, that looks a lot like-- if you've seen real signal block diagram things, that looks a lot like accumulators, finite state accumulators.

231
00:21:17,360 --> 00:21:28,440
我们可以稍加修改，就可以将其变成一个有穷状态的accumulator
And in fact, we can modify this a little bit to change this into something that integrates a stream or a finite state accumulator, however you like to think about it.

232
00:21:28,440 --> 00:21:45,700
把ONES换成一个流，INTEGERS就应该是这个流的积分
So instead of the ones coming in and getting out the integers, what we'll do is say there's a stream s coming in, and we're going to get out the integral of this, successive values of that, and it looks almost the same.

233
00:21:45,700 --> 00:21:54,260
还需要修改的一点就是，在S输入加法器之前，先将其乘以dt
The only thing we're going to do is when s comes in here, before we just add it in we're going to multiply it by some number dt.

234
00:21:57,680 --> 00:22:00,000
剩下的就不用改了
And now what we have here, this is exactly the same thing.

235
00:22:00,000 --> 00:22:04,020
用盒子包裹起来，就是一个积分器
We have a box, which is an integrator.

236
00:22:09,790 --> 00:22:19,980
对一个流S进行积分，这里的1可以换成一个积分的初始值
And it takes in a stream s, and instead of 1 here, we can put the additional value for the integral.

237
00:22:19,980 --> 00:22:25,270
这个看起来就非常像是信号处理了
And that one looks very much like a signal processing block diagram program.

238
00:22:25,270 --> 00:22:27,980
这里，还有一个程序来表示这个图
In fact, here's the procedure that looks exactly like that.

239
00:22:31,490 --> 00:22:34,010
对一个流进行积分
Find the integral of a stream.

240
00:22:34,010 --> 00:22:42,230
接收一个流s，一个初始值和dt，产生一个新的流表示积分
So an integral's going to take a stream and produce a new stream, and it takes in an initial value and some time constant.

241
00:22:42,230 --> 00:22:43,040
然后呢？
And what do we do?

242
00:22:43,040 --> 00:22:49,400
内部定义一个流int，将其命名的原因在于可以回调它构成一个循环
Well, we internally define this thing int, and we make this internal name so we can feed it back, loop it around itself.

243
00:22:49,400 --> 00:23:01,280
这个int流初始值是initial-value
And int is defined to be something that starts out at the initial value, and the rest of it is gotten by adding together.

244
00:23:01,280 --> 00:23:06,880
剩下的则是将s缩放dt倍，和int相加
We take our input stream, scale it by dt, and add that to int.

245
00:23:06,880 --> 00:23:10,690
最后我们返回流int
And now we'll return from all that the value of integral is this thing int.

246
00:23:10,690 --> 00:23:15,920
我们为int命名是为了在int内部可以引用int
And we use this internal definition syntax so we could write a little internal definition that refers to itself.

247
00:23:21,880 --> 00:23:23,710
我们还可以做的更多
Well, there are all sorts of things we can do.

248
00:23:23,710 --> 00:23:25,500
来看这个
Let's try this one.

249
00:23:25,500 --> 00:23:26,895
斐波那契数
how about the Fibonacci numbers.

250
00:23:26,895 --> 00:23:32,625
定义FIBS
You can say define fibs.

251
00:23:36,350 --> 00:23:37,985
斐波那契数是什么呢？
Well, what are the Fibonacci numbers?

252
00:23:37,985 --> 00:23:50,090
从0开始，下一个是1
They're something that starts out with 0, and the next one is 1.

253
00:23:56,260 --> 00:24:11,000
剩下的就是FIBS和FIBS的tail的和
And the rest of the Fibonacci numbers are gotten by adding the Fibonacci numbers to their own tail.

254
00:24:17,570 --> 00:24:20,580
这样来定义斐波那契数
There's a definition of the Fibonacci numbers.

255
00:24:20,580 --> 00:24:21,430
这是如何运作的呢？
How does that work?

256
00:24:21,430 --> 00:24:31,870
假如开始计算斐波那契数，第一个是0，第二个是1
Well, we start off, and someone says compute for us the Fibonacci numbers, and we're going to tell you it starts out with 0 and 1.

257
00:24:35,790 --> 00:24:45,830
剩下的是两个流的和，一个流是FIBS本身，另一个是FIBS的tail
And everything after the 0 and 1 is gotten by summing two streams. One is the fibs themselves, and the other one is the tail of the fibs.

258
00:24:48,870 --> 00:24:58,360
现在的定义中，我已经能看到FIBS是以0,1开始 FIBS的tail则应该以1开始
So if I know that these start out with 0 and 1, I know that the fibs now start out with 0 and 1, and the tail of the fibs start out with 1.

259
00:24:58,360 --> 00:25:06,300
这样，FIBS的第三个数就应该是0+1=1，这里写上1，这是也写上1
So as soon as I know that, I know that the next one here is 0 plus 1 is 1, and that tells me that the next one here is 1 and the next one here is 1.

260
00:25:06,300 --> 00:25:09,390
知道了这些之后，下一个就是2
And as soon as I know that, I know that the next one is 2.

261
00:25:09,390 --> 00:25:11,700
这里和那里就写上2
So the next one here is 2 and the next one here is 2.

262
00:25:11,700 --> 00:25:12,950
下一个是3
And this is 3.

263
00:25:14,720 --> 00:25:18,530
这里就是3，这下面就是5了
This one goes to 3, and this is 5.

264
00:25:18,530 --> 00:25:21,500
非常精妙的定义
So it's a perfectly sensible definition.

265
00:25:21,500 --> 00:25:22,830
用不了一行
It's a one-line definition.

266
00:25:22,830 --> 00:25:30,150
我也可以把这个定义写到解释器里，然后要求输出FIBS，斐波那契数就开始刷屏了
And again, I could walk over to the computer and type that in, exactly that, and then say print stream the Fibonacci numbers, and they all come flying out.

267
00:25:32,790 --> 00:25:36,810
到了这里，相信我们对递归又多了一些理解
See, this is a lot like learning about recursion again.

268
00:25:36,810 --> 00:25:45,160
过程可以递归地定义，类似地数据对象也可以递归地定义
Instead of thinking that recursive procedures, we have recursively defined data objects.

269
00:25:45,160 --> 00:25:53,090
想想也比较合理，因为我们早就了解了过程与数据之间没有明显的界限
But that shouldn't surprise you at all, because by now, you should be coming to really believe that there's no difference really between procedures and data.

270
00:25:53,090 --> 00:25:58,210
具体地来讲，流也是由过程来实现的，只不过出于抽象的原因我们用流的时候并不想象的那么清楚罢了
In fact, in some sense, the underlying streams are procedures sitting there, although we don't think of them that way.

271
00:25:58,210 --> 00:26:03,630
因此，存在递归的过程，有递归的数据也就不足为怪了
So the fact that we have recursive procedures, well, then it should be natural that we have recursive data, too.

272
00:26:07,840 --> 00:26:09,720
非常和谐
OK, well, this is all pretty neat.

273
00:26:09,720 --> 00:26:14,990
不幸地是，流并非什么问题都能解决
Unfortunately, there are problems that streams aren't going to solve.

274
00:26:14,990 --> 00:26:17,580
我举个例子
Let me show you one of them.

275
00:26:17,580 --> 00:26:36,390
假如我们构建了模拟计算机来求解微分方程，比如 y' = y^2，还需要些初始值
See, in the same way, let's imagine that we're building an analog computer to solve some differential equation like, say, we want to solve the equation y prime dy dt is y squared, and I'm going to give you some initial value.

276
00:26:36,390 --> 00:26:38,030
y(0) = 1
I'll tell you y of 0 equals 1.

277
00:26:41,060 --> 00:26:43,690
dt = .0001
Let's say dt is equal to something.

278
00:26:46,770 --> 00:26:51,040
很久之间就有人构建模拟计算机来解决这类问题
Now, in the old days, people built analog computers to solve these kinds of things.

279
00:26:51,040 --> 00:26:53,020
原理非常简单
And the way you do that is really simple.

280
00:26:53,020 --> 00:27:03,055
先拿一个积分器
You get yourself an integrator, like that one, an integrator box.

281
00:27:03,055 --> 00:27:08,530
初始值是1
And we put in the initial value y of 0 is 1.

282
00:27:08,530 --> 00:27:13,890
还差一个输入和一个输出，输出的结果就是y
And now if we feed something in and get something out, we'll say, gee, what we're getting out is the answer.

283
00:27:13,890 --> 00:27:21,490
输入的是y的导数，在这是y' = y^2
And what we're going to feed in is the derivative, and the derivative is supposed to be the square of the answer.

284
00:27:21,490 --> 00:27:42,910
所以这里使用square进行map，返回去作为这里的输入，这就是用来求解这个微分方程的图
So if we take these values and map using square, and if I feed this around, that's how I build a block diagram for an analog computer that solves this differential equation.

285
00:27:42,910 --> 00:27:47,230
现在我们用代码来表示下这个过程
Now, what we'd like to do is write a stream program that looks exactly like that.

286
00:27:47,230 --> 00:27:49,390
这个图究竟表示的是什么呢？
And what do I mean exactly like that?

287
00:27:49,390 --> 00:28:13,790
y可以这样来定义，就是对dy进行积分，初始值是1，间隔是.0001
Well, I'd say define y to be the integral of dy starting at 1 with 0.001 as a time step.

288
00:28:13,790 --> 00:28:16,805
接下来
And I'd like to say that says this.

289
00:28:16,805 --> 00:28:20,850
来表示y' = y^2
And then I'd like to say, well, dy is gotten by mapping the square along y.

290
00:28:20,850 --> 00:28:33,510
dy就定义为(MAP SQUARE Y)
So define dy to be map square along y.

291
00:28:33,510 --> 00:28:41,410
这就是使用流对整个图的解释，不幸的是，并不能运行
So there's a stream description of this analog computer, and unfortunately, it doesn't work.

292
00:28:41,410 --> 00:28:51,190
你可以看到这为什么不行，因为这个定义y的地方，是dy的积分，额，dy是什么
And you can see why it doesn't work because when I come in and say define y to be the integral of dy, it says, oh, the integral of y-- huh?

293
00:28:51,190 --> 00:28:53,710
没定义啊
Oh, that's undefined.

294
00:28:53,710 --> 00:28:58,770
所以我得先定义dy
So I can't write this definition before I've written this one.

295
00:28:58,770 --> 00:29:03,580
另一方面，如果先定义了dy，又会发现(MAP SQUARE Y)
On the other hand, if I try and write this one first, it says, oh, I define y to be the map of square along y?

296
00:29:03,580 --> 00:29:05,770
y也没有定义
Oh, that's not defined yet.

297
00:29:05,770 --> 00:29:11,580
这个不能先写，那个也不能，没法玩儿了
So I can't write this one first, and I can't write that one first. So I can't quite play this game.

298
00:29:17,560 --> 00:29:20,460
有没有什么解决办法呢？
Well, is there a way out?

299
00:29:20,460 --> 00:29:22,200
所幸的是这可以解决
See, we can do that with ones.

300
00:29:22,200 --> 00:29:34,770
这边，我们可以用ONES来定义ONES是因为CONS-STREAM中ONES可以延时求值
See, over here, we did this thing ones, and we were able to define ones in terms of ones because of this delay that was built inside because cons-stream had a delay.

301
00:29:34,770 --> 00:29:36,070
巧妙在什么地方呢？
Now, why's it sensible?

302
00:29:36,070 --> 00:29:40,730
为什么CONS-STREAM增加了DELAY就变得巧妙了呢？
Why's it sensible for cons-stream to be built with this delay?

303
00:29:40,730 --> 00:29:45,950
原因在于CONS-STERAM这样做之后就完全不用关心TAIL的部分了
The reason is that cons-stream can do a useful thing without looking at its tail.

304
00:29:45,950 --> 00:29:54,870
只用关心我把1和什么东西连接在一起了，而且那个东西以1开始
See, if I say this is cons-stream of 1 onto something without knowing anything about something, I know that the stream starts off with 1.

305
00:29:54,870 --> 00:29:57,910
CONS-STREAM就巧妙在这里
That's why it was sensible to build something like cons-stream.

306
00:29:59,960 --> 00:30:06,320
增加了一个DELAY，就可以进行自引用的定义了
So we put a delay in there, and that allows us to have this sort of self-referential definition.

307
00:30:06,320 --> 00:30:08,190
INTEGRAL也可以用这种方式来解决
Well, integral is a little bit the same way.

308
00:30:08,190 --> 00:30:17,580
我们回头再看看INTEGRAL的定义
See, notice for an integral, I can-- let's go back and look at integral for a second.

309
00:30:17,580 --> 00:30:28,970
求积分的时候，只需要关心我们从initial-value开始积分，并不需要了解整个流
See, notice integral, it makes sense to say what's the first thing in the integral without knowing the stream that you're integrating.

310
00:30:28,970 --> 00:30:33,140
因为积分结果的第一个元素肯定是initial-value
Because the first thing in the integral is always going to be the initial value that you're handed.

311
00:30:33,140 --> 00:30:37,090
integral的内部就是cons-stream实现的
So integral could be a procedure like cons-stream.

312
00:30:37,090 --> 00:30:46,710
我们可以这样定义，甚至不用知道要积分的流是什么，只需要知道初始值是什么就行了
You could define it, and then even before it knows what it's supposed to be integrating, it knows enough to say what its initial value is.

313
00:30:46,710 --> 00:30:58,430
INTEGRAL还可以修改地更为精妙，以一个初始值和一个流进行积分，我甚至不用关心这个流是什么，直到积分的时候再来查看这个流
So we can make a smarter integral, which is aha, you're going to give me a stream to integrate and an initial value, but I really don't have to look at that stream that I'm supposed to integrate until you ask me to work down the stream.

314
00:30:58,430 --> 00:31:03,710
换句话说，这个INTEGRAL就像CONS-STREAM一样，被积分的流延时求值
In other words, integral can be like cons-stream, and you can expect that there's going to be a delay around its integrand.

315
00:31:03,710 --> 00:31:05,610
我们这样修改
And we can write that.

316
00:31:05,610 --> 00:31:07,650
来看这个过程
Here's a procedure that does that.

317
00:31:07,650 --> 00:31:17,110
改动的并不多，只是这里的s变成了delay-s，一个经过DELAY的流
Another version of integral, and this is almost like the previous one, except the stream it's going to get in is going to expect to be a delayed object.

318
00:31:17,110 --> 00:31:18,850
这个INTEGRAL又是怎么运作的呢？
And how does this integral work?

319
00:31:18,850 --> 00:31:32,300
内部还是一个CONS-STREAM，初始值就是initial-value，这里还要记住，delay-s是一个被DELAY过的流
Well, the little thing it's going to define inside of itself says on the cons-stream, the initial value is the initial value, but only inside of that cons-stream, and remember, there's going to be a hidden delay inside here.

320
00:31:34,950 --> 00:31:43,180
到了实际计算的时候，就用FORCE来查看流的实际内容
Only inside of that cons-stream will I start looking at what the actual delayed object is.

321
00:31:43,180 --> 00:31:45,970
第一个元素是initial-value
So my answer is the first thing's the initial value.

322
00:31:45,970 --> 00:31:59,260
如果有人想要查看流的实际内容是什么，就对延时对象应用FORCE，这里称其为s，然后做流的加法。整个过程有点像CONS-STREAM的感觉
If anybody now asks me for my tail, at that point, I'm going to force that delayed object-- and I'll call that s-- and I do the add streams. So this is an integral which is sort of like cons-stream.

323
00:31:59,260 --> 00:32:07,330
这个被积分的流是什么我根本不会去深究，直到你需要它的时候我才会去查看这个流
It's not going to actually try and see what you handed it as the thing to integrate until you look past the first element.

324
00:32:10,120 --> 00:32:27,090
如果这样的话，对于y' = y^2的问题也就解决了，只需要将Y的定义中dt改为(DELAY DY)
And if we do that and we can make this work, all we have to do here is say define y to the integral of delay of y, of delay of dy.

325
00:32:27,090 --> 00:32:35,280
Y就是对(DELAY Y)的积分，这样一来就可以了
So y is going to be the integral of delay of dy starting at 1, and now this will work.

326
00:32:35,280 --> 00:32:44,600
我输入Y的定义，要求一个什么的积分，具体是什么我也不关心，因为是一个延时对象
Because I type in the definition of y, and that says, oh, I'm supposed to use the integral of something I don't care about right now because it's a delay.

327
00:32:44,600 --> 00:32:46,320
这之后，再定义dy
And these things, now you define dy.

328
00:32:46,320 --> 00:32:47,550
没有问题了，因为y已经被定义了
Now, y is defined.

329
00:32:47,550 --> 00:32:51,700
所以在dy内部引用y并没有问题
So when I define dy, it can see that definition for y.

330
00:32:51,700 --> 00:32:52,840
一切都正常了
Everything is now started up.

331
00:32:52,840 --> 00:32:54,920
这两个流都有初始值
Both streams have their first element.

332
00:32:54,920 --> 00:33:00,590
当用SQUARE进行MAP的时候，查看后继的元素并不会引发什么问题，y和dy都被定义过了
And then when I start mapping down, looking at successive elements, both y and dy are defined.

333
00:33:00,590 --> 00:33:08,660
DELAY除了在CONS-STREAM之内还是很有用的不是吗？好的，大家有问题么
So there's a little game you can play that goes a little bit beyond just using the delay that's hidden inside streams. Questions?

334
00:33:13,178 --> 00:33:14,428
没有的话，休息一下吧
OK, let's take a break.

335
00:34:07,300 --> 00:34:14,320
在刚才休息的时候，我不知道你们有没有发现什么事不对劲
Well, just before the break, I'm not sure if you noticed it, but something nasty started to happen.

336
00:34:14,320 --> 00:34:34,389
我们通过流将程序表面表现的时间关系与实际在计算机中运行的时间关系分离开来，可以这样分离的原因在于流中的DELAY。在某些时候，我们为了利用这种优势，需要更多的DELAY
We've been going along with the streams and divorcing time in the programs from time in the computers, and all that divorcing got hidden inside the streams. And then at the very end, we saw that sometimes in order to really take advantage of this method, you have to pull out other delays.

337
00:34:34,389 --> 00:34:39,030
也就是要显式地来使用DELAY
You have to write some explicit delays that are not hidden inside that cons-stream.

338
00:34:39,030 --> 00:34:49,929
我已经用微分方程示例过了，如果你遇到非常复杂的系统，其中有很多自引用的循环，这时你需要在什么地方用DELAY就非常模糊了
And I did a very simple example with differential equations, but if you have some very complicated system with all kinds of self-loops, it becomes very, very difficult to see where you need those delays.

339
00:34:49,929 --> 00:34:55,550
假如你一不小心漏了一个，程序会出错而且你还不知道哪里出了错
And if you leave them out by mistake, it becomes very, very difficult to see why the thing maybe isn't working.

340
00:34:55,550 --> 00:35:08,690
我们显式使用DELAY获得的力量不足以克服大型的复杂的系统，因为它们并不能像流一样把DELAY隐藏起来，这非常混乱
So that's kind of mess, that by getting this power and allowing us to use delay, we end up with some very complicated programming sometimes, because it can't all be hidden inside the streams.

341
00:35:08,690 --> 00:35:11,036
有没有什么解决方案呢？
Well, is there a way out of that?

342
00:35:11,036 --> 00:35:13,480
所幸地是 有
Yeah, there is a way out of that.

343
00:35:13,480 --> 00:35:25,450
我可以改变整个语言，所有过程表现起来就像CONS-STREAM一样，因此每一个过程都对其参数延时求值
We could change the language so that all procedures acted like cons-stream, so that every procedure automatically has an implicit delay around its arguments.

344
00:35:25,450 --> 00:35:27,520
什么意思呢？
And what would that mean?

345
00:35:27,520 --> 00:35:32,210
就是说 你执行一个过程，并不马上对参数求值
That would mean when you call a procedure, the arguments wouldn't get evaluated.

346
00:35:32,210 --> 00:35:39,260
相反地，它们只有在需要被求值的时候才会被求值，因此它们可以不被求值的传递至其它过程中，一直这样传递下去
Instead, they'd only be evaluated when you need them, so they might be passed off to some other procedure, which wouldn't evaluate them either.

347
00:35:39,260 --> 00:35:42,150
过程传递的只是计算的约定而已
So all these procedures would be passing promises around.

348
00:35:42,150 --> 00:35:52,380
直到最后你需要查看某个值的时候，这才真正的求出这个部分的值
And then finally maybe when you finally got down to having to look at the value of something that was handed to a primitive operator would you actually start calling in all those promises.

349
00:35:52,380 --> 00:36:02,920
假如我们这样做了，就不需要显式的使用DELAY了，任何东西都有DELAY，它完全内建在语言之中了
If we did that, since everything would have a uniform delay, then you wouldn't have to write any explicit delays, because it would be automatically built into the way the language works.

350
00:36:02,920 --> 00:36:34,560
换句话说，技术上这是一种正则序求值的语言，和我们一直使用的应用序求值不同
Or another way to say that, technically what I'm describing is what's called-- if we did that, our language would be so-called normal-order evaluation language versus what we've actually been working with, which is called applicative order--  versus applicative-order evaluation.

351
00:36:34,560 --> 00:36:36,835
还记得应用序吧
And remember the substitution model for applicative order.

352
00:36:36,835 --> 00:36:43,590
就是你求值一个表达式的时候，每个部分都要预先计算出来
It says when you go and evaluate a combination, you find the values of all the pieces.

353
00:36:43,590 --> 00:36:47,600
参数具体求值之后，才代换入过程
You evaluate the arguments and then you substitute them in the body of the procedure.

354
00:36:47,600 --> 00:36:49,890
正则序则不是这样
Normal order says no, don't do that.

355
00:36:49,890 --> 00:36:58,640
代换的过程是一样的，不过并不先对参数求值，只是代换入了一个计算的约定
What you do is effectively substitute in the body of the procedure, but instead of evaluating the arguments, you just put a promise to compute them there.

356
00:36:58,640 --> 00:37:09,340
换句话说，这个表达式作为参数，就直接的把这个表达式代换入过程，并不进行求值直到需要求值的时候
Or another way to say that is you take the expressions for the arguments, if you like, and substitute them in the body of the procedure and go on, and never really simplify anything until you get down to a primitive operator.

357
00:37:09,340 --> 00:37:11,840
这就是所谓的正则序求值语言
So that would be a normal-order language.

358
00:37:11,840 --> 00:37:13,490
为什么不这样做呢？
Well, why don't we do that?

359
00:37:13,490 --> 00:37:18,940
这样做了之后，我们就获得了延时求值的所有优点
Because if we did, we'd get all the advantages of delayed evaluation with none of the mess.

360
00:37:18,940 --> 00:37:24,710
CONS也会是延时求值的，就和CONS-STREAM一样
In fact, if we did that and cons was just a delayed procedure, that would make cons the same as cons-stream.

361
00:37:24,710 --> 00:37:32,350
也不需要流了，因为列表会自动的像流那样，所有的数据对象都会被延时求值
We wouldn't need streams of all because lists would automatically be streams. That's how lists would behave, and data structures would behave that way.

362
00:37:32,350 --> 00:37:35,270
所有的，不是么？
Everything would behave that way, right?

363
00:37:35,270 --> 00:37:41,020
直到需要答案的时候才去实际的求值
You'd never really do any computation until you actually needed the answer.

364
00:37:41,020 --> 00:37:44,790
也不用担心这些显式的DELAY了
You wouldn't have to worry about all these explicit annoying delays.

365
00:37:44,790 --> 00:37:47,160
为什么不这样做呢？
Well, why don't we do that?

366
00:37:47,160 --> 00:37:49,230
首先，已经有人这样做过了
First of all, I should say people do do that.

367
00:37:49,230 --> 00:37:51,850
这是一类十分优雅的语言
There's some very beautiful languages.

368
00:37:51,850 --> 00:38:00,710
其中最为人称道的是一门名为Miranda的语言，是肯特大学的David Turner发明的
One of the very nicest is a language called Miranda, which is developed by David Turner at the University of Kent.

369
00:38:00,710 --> 00:38:01,930
它就是用这样的原理实现的
And that's how this language works.

370
00:38:01,930 --> 00:38:14,970
正则序求值，列表就像流一样。如果你用Miranda来解决像质数，八皇后这样的问题，写出来的过程看起来就很普通
It's a normal-order language and its data structures, which look like lists, are actually streams. And you write ordinary procedures in Miranda, and they do these prime things and eight queens things, just without anything special.

371
00:38:14,970 --> 00:38:17,790
DELAY已经内建入语言了
It's all built in there.

372
00:38:17,790 --> 00:38:19,040
但是这样也有不足之处
But there's a price.

373
00:38:21,190 --> 00:38:23,170
还记得我们为什么引入流了吗
Remember how we got here.

374
00:38:23,170 --> 00:38:27,480
我们把程序的时间和它实际执行的时间相分离
We're decoupling time in the programs from time in the machines.

375
00:38:27,480 --> 00:38:33,140
如果我们在所有地方都引入了DELAY，这也是我们现在正在做的
And if we put delay, that sort of decouples it everywhere, not just in streams. Remember what we're trying to do.

376
00:38:33,140 --> 00:38:39,300
编程就完全是单纯地描述解决方案的事了
We're trying to think about programming as a way to specify processes.

377
00:38:39,300 --> 00:38:47,030
我们完全放弃了对时间的控制，尽管语言变的优雅起来，但是牺牲了太多东西
And if we give up too much time, our language becomes more elegant, but it becomes a little bit less expressive.

378
00:38:47,030 --> 00:38:51,480
并且还有一些致命的缺陷
There are certain distinctions that we can't draw.

379
00:38:51,480 --> 00:38:53,980
其中之一就是迭代
One of them, for instance, is iteration.

380
00:38:53,980 --> 00:39:01,230
我们以前写过，迭代的来求阶乘
Remember this old procedure, iterative factorial, that we looked at quite a long time ago.

381
00:39:01,230 --> 00:39:12,120
fact-iter内部定义一个过程iter，它时刻记录着product和counter的状态，就这样迭代的求解
Iterative factorial had a thing, and it said there was an internal procedure, and there was a state which was a product and a counter, and we iterate that going around the loop.

382
00:39:12,120 --> 00:39:15,730
我们说这是一个迭代过程是因为它并没有把状态堆积给解释器
And we said that was an iterative procedure because it didn't build up state.

383
00:39:15,730 --> 00:39:23,900
因为状态时刻作为参数传递给了自身
And the reason it didn't build up state is because this iter that's called is just passing these things around to itself.

384
00:39:23,900 --> 00:39:31,660
也可以用代换具体的实践来看，这个迭代的过程，并没有状态堆积导致表达式增长的情况
Or in the substitution model, you could see in the substitution model that Jerry did, that in an iterative procedure, that state doesn't have to grow.

385
00:39:31,660 --> 00:39:34,840
因此这是一个迭代过程
And in fact, we said it doesn't, so this is an iteration.

386
00:39:34,840 --> 00:39:41,150
但是现在用正则序的思维来看
But now think about this exact same text if we had a normal-order language.

387
00:39:41,150 --> 00:39:45,650
这个迭代过程会变成什么样子
What would happen is this would no longer be an iterative procedure?

388
00:39:45,650 --> 00:39:52,330
如果你用正则序去进行代换，一直代换下去表达式就会变得越来越长
And if you really think about the details of the substitution model, which I'm not going to do here, this expression would grow.

389
00:39:52,330 --> 00:39:53,280
为什么会这样？
Why would it grow?

390
00:39:53,280 --> 00:39:58,080
因为iter递归的调用自己，把product代换为(* counter product)
It's because when iter calls itself, it calls itself with this product.

391
00:39:58,080 --> 00:40:02,510
在正则序里，这个乘法在这里并没有求值
If it's a normal-order language, that multiplication is not going to get done.

392
00:40:02,510 --> 00:40:06,670
传递并代换的只是这个乘法计算的约定
That's going to say I'm to call myself with a promise to compute this product.

393
00:40:06,670 --> 00:40:09,760
然后iter继续代换下去
And now iter goes around again.

394
00:40:09,760 --> 00:40:18,400
用这样的计算约定反复的递归代换
And I'm going to call myself with a promise to compute this product where now one of the one factors is a promise.

395
00:40:18,400 --> 00:40:19,430
代换
And I call myself again.

396
00:40:19,430 --> 00:40:31,790
如果你实际模拟下这个过程，你会清楚的看到状态的堆积，所有的约定直到最后才被计算
And if you write out the substitution model for that iterative process, you'll see exactly the same growth in state, all those promises that are getting remembered that have to get called in at the very end.

397
00:40:31,790 --> 00:40:36,980
所以正则序不能表达迭代的计算过程
So one of the disadvantages is that you can't really express iteration.

398
00:40:36,980 --> 00:40:54,610
或许这个问题有更深层次的理论上的原因，事实上许多写操作系统的人都很头疼这类问题。比如你用这类语言实现了一个文本编辑器
Maybe that's a little theoretical reason why not, but in fact, people who are trying to write real operating systems in these languages are running into exactly these types of problems. Like it's perfectly possible to implement a text editor in languages like these.

399
00:40:54,610 --> 00:41:10,230
但是你才用了一会儿，就会发现已经占用了3MB空间，充斥了未被计算的约定，这个应该是被称为拖尾问题，就因为不能表示迭代过程的缘故
But after you work a while, you suddenly have 3 megabytes of stuff, which is-- I guess they call them the dragging tail problem of people who are looking at these, of promises that sort of haven't been called in because you couldn't quite express an iteration.

400
00:41:10,230 --> 00:41:20,110
一个针对这种语言的研究方向就是如何采用一种编译技术来避免拖尾问题
And one of the research questions in these kinds of languages are figuring out the right compiler technology to get rid of the so-called dragging tails.

401
00:41:20,110 --> 00:41:23,940
非常困难
It's not simple.

402
00:41:23,940 --> 00:41:32,056
在不能表示迭代之外，正则序求值还有另一个缺点
But there's another kind of more striking issue about why you just don't go ahead and make your language normal order.

403
00:41:32,056 --> 00:41:42,000
很遗憾的是，正则序求值与赋值副作用是不相容的
And the reason is that normal-order evaluation and side effects just don't mix.

404
00:41:42,000 --> 00:41:45,350
它们在一起效果并不好
They just don't go together very well.

405
00:41:45,350 --> 00:42:00,400
你不能对有局部状态的对象同时应用正则序求值来分离时间延时求值
Somehow, you can't-- it's sort of you can't simultaneously go around trying to model objects with local state and change and at the same time do these normal-order tricks of de-coupling time.

406
00:42:00,400 --> 00:42:03,790
我来举一个非常简单的例子
Let me just show you a really simple example, very, very simple.

407
00:42:03,790 --> 00:42:07,520
假设语言是正则序求值
Suppose we had a normal-order language.

408
00:42:07,520 --> 00:42:09,550
例子是这样的
And I'm going to start out in this language.

409
00:42:09,550 --> 00:42:10,520
注意现在是正则序求值
This is now normal order.

410
00:42:10,520 --> 00:42:13,570
定义x是0
I'm going to define x to be 0.

411
00:42:13,570 --> 00:42:15,750
初始化的变量
It's just some variable I'll initialize.

412
00:42:15,750 --> 00:42:22,640
下面这个过程 id 比较有趣
And now I'm going to define this little funny function, which is an identity function.

413
00:42:22,640 --> 00:42:26,770
它用x来记录上一次id过程的参数值
And what it does, it keeps track of the last time you called it using x.

414
00:42:31,620 --> 00:42:36,760
这个过程最后只是返回了n，但是还把x赋值为n
So the identity of n just returns n, but it sets x to be n.

415
00:42:36,760 --> 00:42:42,580
最后再定义一个过程inc，也非常简单
And now I'll define a little increment function, which is a very little, simple scenario.

416
00:42:42,580 --> 00:42:47,230
假设在正则序求值的语言里，求值下面的表达式
Now, imagine I'm interacting with this in the normal-order language, and I type the following.

417
00:42:47,230 --> 00:42:54,190
(define y (inc (id 3)))，y的值应该是4
I say define y to be increment the identity function of 3, so y is going to be 4.

418
00:42:57,410 --> 00:42:59,520
x应该是多少呢？
Now, I say what's x?

419
00:42:59,520 --> 00:43:04,710
x应该是上一次我们执行过程id的参数值
Well, x should have been the value that was remembered last when I called the identity function.

420
00:43:04,710 --> 00:43:08,530
你可能会想，这里x应该是3，但是并不是这样
So you'd expect to say, well, x is 3 at this point, but it's not.

421
00:43:08,530 --> 00:43:17,000
因为我定义y的时候，只是一个计算的约定
Because when I defined y here, what I really defined y to be increment of a promise to do this thing.

422
00:43:17,000 --> 00:43:21,560
所以(id 3)的这部分并没有求值
So I didn't look at y, so that identity function didn't get run.

423
00:43:21,560 --> 00:43:25,320
我输入这个定义之后，x并没有改变，还是0
So if I type in this definition and look at x, I'm going to get 0.

424
00:43:28,360 --> 00:43:38,342
现在我输入y，要求对y求值，y就是4，(id 3)就在求值y的过程中被求值
Now, if I go look at y and say what's y, say y is 4, looking at y, that very active looking at y caused the identity function to be run.

425
00:43:38,342 --> 00:43:40,740
所以再来看x，x就应该是3
And now x will get remembered as 3.

426
00:43:40,740 --> 00:43:42,020
上面这里的x是0
So here x will be 0.

427
00:43:42,020 --> 00:43:43,280
下面这里是3
Here, x will be 3.

428
00:43:43,280 --> 00:43:57,100
这是一个非常简单的模拟场景，但是你可以观察到当你用正则序求值，甚至连变量的值都很难弄清楚
That's a tiny, little, simple scenario, but you can see what kind of a mess that's going to make for debugging interactive programs when you have normal-order evaluation.

429
00:43:57,100 --> 00:43:59,690
很令人迷惑
It's very confusing.

430
00:43:59,690 --> 00:44:09,780
深层次的原因，我想应该是所有都有了DELAY之后，我们也就完全脱离了时间的概念
But it's very confusing for a very deep reason, which is that the whole idea of putting in delays is that you throw away time.

431
00:44:09,780 --> 00:44:11,750
也因为如此我们可以处理一些无穷的情况
That's why we can have these infinite processes.

432
00:44:11,750 --> 00:44:17,790
脱离了时间之后，就没有必要非要等到哪一刻才开始运行，不是吗？
Since we've thrown away time, we don't have to wait for them to run, right?

433
00:44:17,790 --> 00:44:28,760
这样我就把程序所表示的时间顺序与实际运行的时间顺序分离开来。但是当我们谈及状态、赋值和改变，它们都和时间相关
We decouple the order of events in the computer from what we write in our programs. But when we talk about state and set and change, that's exactly what we do want control of.

434
00:44:28,760 --> 00:44:34,570
从根本上相矛盾
So it's almost as if there's this fundamental contradiction in what you want.

435
00:44:34,570 --> 00:44:42,410
这仿佛是一个哲学问题，从什么样的角度观察世界，构建什么样的模型
And that brings us back to these sort of philosophical mutterings about what is it that you're trying to model and how do you look at the world.

436
00:44:42,410 --> 00:44:47,140
有时这也被称为“函数式程序设计的争论”
Or sometimes this is called the debate over functional programming.

437
00:44:53,570 --> 00:45:00,440
所谓完全函数式的语言是那种完全没有副作用的语言
A so-called purely functional language is one that just doesn't have any side effects.

438
00:45:00,440 --> 00:45:06,360
没有副作用，没有赋值，也不用担心有什么糟糕的后果
Since you have no side effects, there's no assignment operator, so there are no terrible consequences of it.

439
00:45:06,360 --> 00:45:07,930
可以使用代换模型
You can use a substitution-like thing.

440
00:45:07,930 --> 00:45:15,050
程序更像是数学计算，而不是构建模型或对象
Programs really are like mathematics and not like models in the real world, not like objects in the real world.

441
00:45:15,050 --> 00:45:17,170
函数式语言有很多了不起的特性
There are a lot of wonderful things about functional languages.

442
00:45:17,170 --> 00:45:29,260
没有时间的概念，所以完全不用担心同步的问题。如果你把这些应用在并行算法上，就可以并行计算不同的部分
Since there's no time, you never have any synchronization problems. And if you want to put something into a parallel algorithm, you can run the pieces of that parallel processing any way you want.

443
00:45:29,260 --> 00:45:33,640
从来不担心同步问题，这几乎是与生俱来的
There's just never any synchronization to worry that, and it's a very congenial environment for doing this.

444
00:45:33,640 --> 00:45:35,450
代价是放弃了赋值
The price is you give up assignment.

445
00:45:39,060 --> 00:45:44,520
一些函数式编程的狂热分子会说，这点代价算不了什么
So an advocate of a functional language would say, gee, that's just a tiny price to pay.

446
00:45:44,520 --> 00:45:46,510
确实，在大部分情况下不用赋值也可以
You probably shouldn't use assignment most of the time anyway.

447
00:45:46,510 --> 00:45:54,190
如果用你用赋值，就得想办法用其它方式来解决原来用对象解决的问题
And if you just give up assignment, you can be in this much, much nicer world than this place with objects.

448
00:45:54,190 --> 00:45:56,300
有没有什么例子呢？
Well, what's the rejoinder to that?

449
00:45:56,300 --> 00:46:00,300
想想我们如何走到这一步的
Remember how we got into this mess.

450
00:46:00,300 --> 00:46:04,440
我们构造有独立状态的对象
We started trying to model things that had local state.

451
00:46:04,440 --> 00:46:06,840
还记得Jerry的随机数生成器吧
So remember Jerry's random number generator.

452
00:46:06,840 --> 00:46:14,080
随机数生成器内部有一个状态，根据这个状态计算下一个随机数，下下一个等等
There was this random number generator that had some little state in it to compute the next random number and the next random number and the next random number.

453
00:46:14,080 --> 00:46:21,050
我们可以将随机数生成与蒙特卡洛算法分离开来，因此赋值在这里就异常重要了
And we wanted to hide that state away from the Cesaro compute part process, and that's why we needed set.

454
00:46:21,050 --> 00:46:24,070
我们用模块化来封装状态
We wanted to package that stated modularly.

455
00:46:24,070 --> 00:46:27,560
使用函数式编程的程序员可能会说，“你搞错了”
Well, a functional programming person would say, well, you're just all wet.

456
00:46:27,560 --> 00:46:29,840
“我的意思是，你能写出另一种更具模块化的程序”
I mean, you can write a perfectly good modular program.

457
00:46:29,840 --> 00:46:33,250
“从另一种角度来思考模块化”
It's just you're thinking about modularity wrong.

458
00:46:33,250 --> 00:46:36,880
一直为生成一个又一个的随机数所烦恼
You're hung up in this next random number and the next random number and the next random number.

459
00:46:36,880 --> 00:46:39,880
为什么不写一个这样的程序
Why don't you just say let's write a program.

460
00:46:39,880 --> 00:46:44,445
写一个枚举器，生成一个无穷的随机数的流
Let's write an enumerator which just generates an infinite stream of random numbers.

461
00:46:49,010 --> 00:46:54,540
一次性就生成所有的随机数，而且还可以为其它地方使用
We can sort of have that stream all at once, and that's going to be our source of random numbers.

462
00:46:54,540 --> 00:47:06,880
如果你想的话，就可以把这个流接过来，到这个蒙特卡洛测试的过程
And then if you like, you can put that through some sort of processor, which is-- I don't know-- a Cesaro test, and that can do what it wants.

463
00:47:06,880 --> 00:47:28,140
输出的是一个流，其中是一连串的对PI的估计值
And what would come out of there would be a stream of successive approximations to pi.

464
00:47:28,140 --> 00:47:35,540
和前面讲的类似，这样用流的连接，可以“拖出“无限个随机数来计算蒙特卡洛测试
So as we looked further down this stream, we'd tug on this Cesaro thing, and it would pull out more and more random numbers.

465
00:47:35,540 --> 00:47:39,720
我们使用的随机数越多，最后对PI的估计值就越准
And the further and further we look down the stream, the better an approximation we'd get to pi.

466
00:47:39,720 --> 00:47:43,890
具体的计算过程还是一样的，只不过使用了另一种模块化的方式
And it would do exactly the same as the other computation, except we're thinking about the modularity different.

467
00:47:43,890 --> 00:47:49,400
我们假如一次性生成了所有的随机数
We're saying imagine we had all those infinite streams of random numbers all at once.

468
00:47:49,400 --> 00:47:53,860
这个过程的细节在书上有
You can see the details of this procedure in the book.

469
00:47:53,860 --> 00:48:03,280
相似地还有别的例子，我们也习惯于一次一次来，但完全可以不这么来想
Similarly, there are other things that we tend to get locked into on this one and that one and the next one and the next one, which don't have to be that way.

470
00:48:03,280 --> 00:48:08,900
我们来思考一下银行系统
Like you might think about like a banking system, which is a very simple idea.

471
00:48:08,900 --> 00:48:12,210
假设我们这里这个程序代表了银行帐户
Imagine we have a program that sort of represents a bank account.

472
00:48:18,810 --> 00:48:31,510
如果我们以信息传递的角度来看，银行帐户应该是一个对象，内部保存着局部状态balance金额
The bank account might have in it-- if we looked at this in a sort of message-passing view of the world, we'd say a bank account is an object that has some local state in there, which is the balance, say.

473
00:48:34,110 --> 00:48:48,560
如果一个用户发出交易申请，比如存钱，这个银行帐户就会用最新的balance金额作出回应
And a user using this system comes and sends a transaction request. So the user sends a transaction request, like deposit some money, and the bank account maybe-- let's say the bank account always responds with what the current balance is.

474
00:48:48,560 --> 00:48:54,350
比如我们存点钱，帐户就会返回存钱后总金额是多少
The user says let's deposits some money, and the bank account sends back a message which is the balance.

475
00:48:54,350 --> 00:48:59,150
用户发出信息，帐户反馈信息
And the user says deposit some more, and the bank account sends back a message.

476
00:48:59,150 --> 00:49:03,200
就随机数生成器一样，我们得用赋值才可以
And just like the random number generator, you'd say, gee, we would like to use set.

477
00:49:03,200 --> 00:49:09,570
帐户的内部保存了局部状态balance，因此就把用户的状态和帐户的状态分离开来
We'd like to have balance be a piece of local state inside this bank account because we want to separate the state of the user from the state of the bank account.

478
00:49:13,280 --> 00:49:16,420
这是从信息传递的角度来看
Well, that's the message-processing view.

479
00:49:16,420 --> 00:49:22,740
如果从流的角度来看，就不需要赋值或副作用之类
There's a stream view with that thing, which does the same thing without any set or side effects.

480
00:49:22,740 --> 00:49:31,180
我们不想任何有关局部状态的事
And the idea is again we don't think about anything having local state.

481
00:49:31,180 --> 00:49:38,640
可以认为银行帐户是一个处理一系列交易请求的东西
We think about the bank account as something that's going to process a stream of transaction requests.

482
00:49:38,640 --> 00:49:49,490
帐户不是一个处理信息的对象了，而是处理交易请求流的东西
So think about this bank account not as something that goes message by message, but something that takes in a stream of transaction requests like maybe successive deposit announced.

483
00:49:49,490 --> 00:49:55,940
比如1 2 2 4，连续的存钱交易
1, 2, 2, 4, those might be successive amounts to deposit.

484
00:49:55,940 --> 00:50:03,770
从帐户出来的流应该是1 3 5 9
And then coming out of it is the successive balances 1, 3, 5, 9.

485
00:50:03,770 --> 00:50:10,820
帐户没有局部状态，它只是一个流处理器
So we think of the bank account not as something that has state, but something that acts sort of on the infinite stream of requests.

486
00:50:10,820 --> 00:50:12,370
记住，这样想的话，就没有了时间的概念
But remember, we've thrown away time.

487
00:50:12,370 --> 00:50:30,010
如果这里有一个用户，我们把他的所有交易看做是无穷的流，帐户一次处理一个元素，所有的balance金额也作为一个流
So what we can do is if the user's here, we can have this infinite stream of requests being generated one at a time coming from the user and this transaction stream coming back on a printer being printed one at a time.

488
00:50:30,010 --> 00:50:39,560
如果在这里划一条线，用户从外面来看，根本不能分辨银行帐户到底有没有状态
And if we drew a little line here, right there to the user, the user couldn't tell that this system doesn't have state.

489
00:50:39,560 --> 00:50:42,660
因为它们对外表现是一样的
It looks just like the other one, but there's no state in there.

490
00:50:45,120 --> 00:50:53,835
哦，顺便提一个，这里有一个具体的代码实现 -- 假设我们只存钱
And by the way, just to show you, here's an actual implementation of this-- we'll call it make deposit account because you can only deposit.

491
00:50:53,835 --> 00:51:00,020
这个过程接受一个balance初始值和一个存钱交易流
It takes an initial balance and then a stream of deposits you might make.

492
00:51:00,020 --> 00:51:00,820
具体怎么做呢？
And what is it?

493
00:51:00,820 --> 00:51:18,300
很简单，只不过是用CONS-STREAM把初始金额和递归调用make-deposit-account的结果组合在一起，递归调用的时候，金额参数要加上第一次要存的钱，流参数变为交易流的TAIL
Well, it's just cons-stream of the balance onto make a new account stream whose initial balance is the old balance plus the first thing in the deposit stream and make deposit account works on the rest of which is the tail of the deposit stream.

494
00:51:18,300 --> 00:51:28,790
原来用面向对象解决的问题，我们用流就可以解决
So there's sort of a very typical message-passing, object-oriented thing that's done without side effects at all.

495
00:51:28,790 --> 00:51:32,250
很多地方都可以这样思考
There are very many things you can do this way.

496
00:51:32,250 --> 00:51:36,400
可能你会想了，我能不用赋值做所有的事情吗？
Well, can you do everything without assignment?

497
00:51:36,400 --> 00:51:40,050
可以只用纯函数式语言来编程吗？
Can everybody go over to purely functional languages?

498
00:51:40,050 --> 00:51:48,100
这个问题谁也说不清，好像有些地方用函数式编程不太妥当
Well, we don't know, but there seem to be places where purely functional programming breaks down.

499
00:51:48,100 --> 00:51:58,850
比如关于银行帐户的一个更复杂的例子，函数式也会有点吃力因为我们混入了共享的问题，这里两个用户共享一个帐户
Where it starts hurting is when you have things like this, but you also mix it up with the other things that we had to worry that, which are objects and sharing and two independent agents being the same.

500
00:51:58,850 --> 00:52:02,960
在这种情况下，假如你来扩展这个帐户
So under a typical one, suppose you want to extend this bank account.

501
00:52:02,960 --> 00:52:04,210
这是一个帐户
So here's a bank account.

502
00:52:12,220 --> 00:52:18,780
帐户取一个交易流，生成一个新的流
Bank accounts take in a stream of transaction requests and put out streams of, say, balances or responses to that.

503
00:52:18,780 --> 00:52:26,090
假如这个帐户是两个独立的用户共享的会怎么样
But suppose you want to model the fact that this is a joint bank account between two independent people.

504
00:52:26,090 --> 00:52:33,140
假设两个人Bill和Dave，共享一个帐户
So suppose there are two people, say, Bill and Dave, who have a joint bank account.

505
00:52:35,960 --> 00:52:36,850
怎么来建模呢？
How would you model this?

506
00:52:36,850 --> 00:52:45,880
Bill有一个交易流，Dave也有一个交易流，可以把这两个流合并在一起再输入帐户
Well, Bill puts out a stream of transaction requests, and Dave puts out a stream of transaction requests, and somehow, they have to merge into this bank account.

507
00:52:45,880 --> 00:53:01,190
所以我们只需要一个merge的过程，将这两个流合并为一个流就行
So what you might do is write a little stream processing thing called merge, which sort of takes these, merges them together, produces a single stream for the bank account.

508
00:53:01,190 --> 00:53:03,610
现在他们就共享一个帐户了
Now they're both talking to the same bank account.

509
00:53:03,610 --> 00:53:06,600
看起来不错，问题是怎么来实现merge
That's all great, but how do you write merge?

510
00:53:06,600 --> 00:53:09,730
merge根据什么来合并？
What's this procedure merge?

511
00:53:09,730 --> 00:53:12,760
而且要合并的合理
You want to do something that's reasonable.

512
00:53:12,760 --> 00:53:24,150
第一反应可能这样想，两个流依次一个一个取，但是如果突然Dave外出度假了两年会怎么样？
Your first guess might be to say, well, we'll take alternate requests from Bill and Dave. But what happens if suddenly in the middle of this thing, Dave goes away on vacation for two years?

513
00:53:24,150 --> 00:53:27,690
Bill的交易就完全被阻塞了
Then Bill's sort of stuck.

514
00:53:27,690 --> 00:53:29,750
你想要的是
So what you want to do is-- well, it's hard to describe.

515
00:53:29,750 --> 00:53:33,380
是一种公平的合并
What you want to do is what people call fair merge.

516
00:53:38,410 --> 00:53:46,010
这个所谓公平的合并应该是交替地一次处理一个，但是如果一个人没有了交易，应该继续去处理另一个人的交易
The idea of fair merge is it sort of should do them alternately, but if there's nothing waiting here, it should take one twice.

517
00:53:46,010 --> 00:53:48,450
你们可以注意到我完全没有谈论时间
Notice I can't even say that without talking about time.

518
00:53:51,300 --> 00:54:18,010
一个在函数式编程研究方面比较活跃的课题之一就是发明一种公平合并的方式，取代原来用面向对象开发的系统，避免赋值与状态带来的问题
So one of the other active researcher areas in functional languages is inventing little things like fair merge and maybe some others, which will take the places where I used to need side effects and objects and sort of hide them away in some very well-defined modules of the system so that all the problems of assignment don't sort of leak out all over the system but are captured in some fairly well-understood things.

519
00:54:20,780 --> 00:54:38,360
你们也看到了，我现在所触及的是计算机科学方面非常根本的一个问题，如何开发一种语言，使其可以延时求值同时又可以面向对象
More generally, I think what you're seeing is that we're running across what I think is a very basic problem in computer science, which is how to define languages that somehow can talk about delayed evaluation, but also be able to reflect this view that there are objects in the world.

520
00:54:38,360 --> 00:54:41,230
怎么样才能两者兼有之？
How do we somehow get both?

521
00:54:41,230 --> 00:54:43,040
想来这很困难
And I think that's a very hard problem.

522
00:54:43,040 --> 00:54:53,840
但是这个很困难的问题却和计算机科学的关系不大，它真正涉及的是两个看待世界不同的方式
And it may be that it's a very hard problem that has almost nothing to do with computer science, that it really is a problem having to do with two very incompatible ways of looking at the world.

523
00:54:53,840 --> 00:54:55,090
大家有问题吗？
OK, questions?

524
00:55:17,556 --> 00:55:25,890
你之前提到过，一旦引入了赋值，就不能使用代换模型了
AUDIENCE: You mentioned earlier that once you introduce assignment, the general rule for using the substitution model is you can't.

525
00:55:25,890 --> 00:55:27,570
除非你非常小心
Unless you're very careful, you can't.

526
00:55:27,570 --> 00:55:28,260
对的
PROFESSOR: Right.

527
00:55:28,260 --> 00:55:40,300
有什么方法或者什么原则来说明清楚这个“很小心”是怎么回事吗？
AUDIENCE: Is there a set of techniques or a set of guidelines for localizing the effects of assignment so that the very careful becomes defined?

528
00:55:40,300 --> 00:55:42,890
我不知道
PROFESSOR: I don't know.

529
00:55:42,890 --> 00:55:45,430
我想想
Let me think.

530
00:55:45,430 --> 00:55:51,480
当然，在实现DELAY中的memo-proc也使用了赋值，但是它被隐藏了起来
Well, certainly, there was an assignment inside memo proc, but that was sort of hidden away.

531
00:55:51,480 --> 00:55:53,480
因为它没有对结果造成其它的不同
It ended up not making any difference.

532
00:55:53,480 --> 00:56:00,390
部分原因之一在于一旦这个过程被求值，得到answer，answer就不会再变化了
Part of the reason for that is once this thing triggered that it had run and gotten an answer, that answer will never change.

533
00:56:00,390 --> 00:56:02,080
有点像一次赋值
So that was sort of a one-time assignment.

534
00:56:02,080 --> 00:56:11,250
所以如果你只用这种一次赋值并且它不再改变，我想应该不会有太大问题
So one very general thing you can do is if you only do what's called a one-time assignment and never change anything, then you can do better.

535
00:56:11,250 --> 00:56:18,490
还有一个问题在于merge -- 让我想想对不对
One of the problems in this merge thing, people have-- let me see if this is right.

536
00:56:18,490 --> 00:56:30,820
我认为有了公平合并这一技术，在其它的地方你都可以有效的来模拟赋值
I think it's true that with fair merge, with just fair merge, you can begin effectively simulating assignment in the rest of the language.

537
00:56:30,820 --> 00:56:39,520
这有点像你把要做的事转移到了外面 -- 我不知道这对于公平合并是否准确，但是对一些更广泛的事是适用的
It seems like anything you do to go outside-- I'm not quite sure that's true for fair merge, but it's true of a little bit more general things that people have been doing.

538
00:56:39,520 --> 00:56:47,970
所以可能真的实现了这种技术，突然你能用这种语言来做任何事，其实应该和你拥有了赋值一样也会遇到糟糕的情况
So it might be that any little bit you put in, suddenly if they allow you to build arbitrary stuff, it's almost as bad as having assignment altogether.

539
00:56:47,970 --> 00:56:51,590
这也是人们在研究的一个领域
But that's an area that people are thinking about now.

540
00:56:51,590 --> 00:57:04,730
在merge这一点我有点问题，如是Bill是一个过程，当我调用Bill的时候，Bill就应该来存款或者说构造一个元素来输入
AUDIENCE: I guess I don't see the problem here with merge if I call Bill, if Bill is a procedure, then Bill is going to increment the bank account or build the list that 's going to put in the next element.

541
00:57:04,730 --> 00:57:07,170
如果我调用Dave两次，他肯定也会存款两次
If I call Dave twice in a row, that will do that.

542
00:57:07,170 --> 00:57:09,350
所以何来的公平合并呢
I'm not sure where fair merge has to be involved.

543
00:57:09,350 --> 00:57:11,200
关键在于你得把这些当作真人一样
PROFESSOR: The problem is imagine these really as people.

544
00:57:11,200 --> 00:57:14,850
就是，这里有一个用户来操作帐户
See, here I have the user who's interacting with this bank account.

545
00:57:14,850 --> 00:57:17,070
请求一次，得到结果
Put in a request, get an answer.

546
00:57:17,070 --> 00:57:18,200
对
AUDIENCE: Right.

547
00:57:18,200 --> 00:57:24,220
但是如果我交替的来处理两个人的请求 AUDIENCE：为什么要交替着？
PROFESSOR: But if the only way I can process request is to alternate them from two people-- AUDIENCE: Well, why would you alternate them?

548
00:57:24,220 --> 00:57:25,070
为什么不呢？
PROFESSOR: Why don't I?

549
00:57:25,070 --> 00:57:26,140
嗯？
AUDIENCE: Yes.

550
00:57:26,140 --> 00:57:26,580
为什么要？
Why do you?

551
00:57:26,580 --> 00:57:27,640
假设这些是现实中的人，对吗？
PROFESSOR: Think of them as real people, right?

552
00:57:27,640 --> 00:57:29,280
这个人外出一年
This guy might go away for a year.

553
00:57:29,280 --> 00:57:35,480
你只能空守在帐户旁边就是不能处理两个请求，因为你还得等这个度假的人
And you're sitting here at the bank account window, and you can't put in two requests because it's waiting for this guy.

554
00:57:35,480 --> 00:57:37,380
为什么非得等他呢？
AUDIENCE: Why does it have to be waiting for one?

555
00:57:37,380 --> 00:57:39,110
因为这里是在计算一个函数
PROFESSOR: Because it's trying to compute a function.

556
00:57:39,110 --> 00:57:41,720
我必须定义一个函数
I have to define a function.

557
00:57:41,720 --> 00:57:51,690
换种方式来说，merge的输出并不是merge输入的函数
Another way to say that is the answer to what comes out of this merge box is not a function of what goes in.

558
00:57:51,690 --> 00:57:53,490
明白了吗？再来看看这个merge是怎么运行的
Because, see, what would the function be?

559
00:57:53,490 --> 00:58:03,470
假设Bill输入 1 1 1 1，Dave输入2 2 2 2
Suppose he puts in 1, 1, 1, 1, and he puts in 2, 2, 2, 2.

560
00:58:03,470 --> 00:58:05,910
merge应该输出什么呢？
What's the answer supposed to be?

561
00:58:05,910 --> 00:58:08,740
这里应该是1 2 1 2 1 2
It's not good enough to say it's 1, 2, 1, 2, 1, 2.

562
00:58:08,740 --> 00:58:09,390
我明白了
AUDIENCE: I understand.

563
00:58:09,390 --> 00:58:11,560
当Bill再输入1 1，merge再输出两个11
But when Bill puts in 1, 1 goes in.

564
00:58:11,560 --> 00:58:13,950
Dave再输入两个2，merge就输出两个2
When Dave puts in 2 twice, 2 goes in twice.

565
00:58:13,950 --> 00:58:15,450
就是这样
When Bill puts in-- PROFESSOR: Right.

566
00:58:15,450 --> 00:58:23,980
为什么不能在输入的数据上加上时间信息呢？PROFESSOR：因为这里没有时间这个概念
AUDIENCE: Why can't it be hooked to the time of the input-- the actual procedural-- PROFESSOR: Because I don't have time.

567
00:58:23,980 --> 00:58:26,900
我只是定义一个函数
See, all I can say is I'm going to define a function.

568
00:58:26,900 --> 00:58:28,150
没有时间概念
I don't have time.

569
00:58:32,070 --> 00:58:38,420
除掉那种没人在需要等他的情况，如果我们交替的来merge
There's no concept if it's going to alternate, except if nobody's there, it's going to wait a while for him.

570
00:58:38,420 --> 00:58:47,810
这里有两个流，一个是Dave生成的与时间无关的无穷长度的流
It's just going to say I have the stream of requests, the timeless infinite streams of all the requests that Dave would have made, right?

571
00:58:47,810 --> 00:58:51,690
另一个是Bill的，我现在要操作这些东西
And the timeless infinite stream of all the requests Bill would have made, and I want to operate on them.

572
00:58:51,690 --> 00:58:53,510
这就是银行帐户的工作原理
See, that's how this bank account is working.

573
00:58:56,710 --> 00:59:05,340
带来的问题就是倒霉的人可能提出了交易，但是并不能及时的得到回复
And the problem is that these poor people who are sitting at the bank account windows have the misfortune to exist in time.

574
00:59:05,340 --> 00:59:10,070
他们也没有意识到他们所做过的交易是以一种流的方式来处理的
They don't see their infinite stream of all the requests they would have ever made.

575
00:59:10,070 --> 00:59:11,550
他们只是等着，等待帐户的响应
They're waiting now, and they want an answer.

576
00:59:14,290 --> 00:59:25,290
假设你坐在屏幕前操作着一台分时系统的计算机，你输入一些指令想看到结果
So if you're sitting there-- if this is the screen operation on some time-sharing system and it's working functionally, you want an answer then when you talk the character.

577
00:59:25,290 --> 00:59:30,910
但是你并不想主机在处理完所有其它人的命令之后再来处理你的命令
You don't want it to have to wait for everybody in the whole system to have typed one character before it can get around to service you.

578
00:59:30,910 --> 00:59:33,890
这就是问题所在
So that's the problem.

579
00:59:33,890 --> 00:59:36,850
我的意思是，人们总能及时的得到结果
I mean, the fact that people live in time, apparently.

580
00:59:36,850 --> 00:59:38,620
如果没有，这也不能算作一个问题
If they didn't, it wouldn't be a problem.

581
00:59:49,100 --> 00:59:54,740
我想我还是不太理解这个银行交易中没有时间概念这一要点
AUDIENCE: I'm afraid I miss the point of having no time in this banking transaction.

582
00:59:54,740 --> 00:59:56,880
时间不重要吗？
Isn't time very important?

583
00:59:56,880 --> 01:00:00,790
举例说，有一系列事件
For instance, the sequence of events.

584
01:00:00,790 --> 01:00:08,400
比如Dave取款$100，这些顺序应该很重要才对
If Dave take out $100, then the timing sequence should be important.

585
01:00:08,400 --> 01:00:11,260
你怎么能把它们看作是流呢？
How do you treat transactions as streams?

586
01:00:11,260 --> 01:00:14,260
这个问题非常好
PROFESSOR: Well, that's the thing I'm saying.

587
01:00:14,260 --> 01:00:17,510
在这个例子中确实做不到那一点
This is an example where you can't.

588
01:00:17,510 --> 01:00:18,610
做不到
You can't.

589
01:00:18,610 --> 01:00:24,170
关键在于这里的输出不只是这两个流的函数
The point is what comes out of here is simply not a function of the stream going in here and the stream going in here.

590
01:00:24,170 --> 01:00:32,860
它是这两个流和某种关于时间的信息的函数，但是由于正则序语言的原因，这种时间信息表示不出来
It's a function of the stream going in here and the stream going in here and some kind of information about time, which is precisely what a normal-order language won't let you say.

591
01:00:34,810 --> 01:00:46,400
为了让这个银行系统更为有效，我们能不能把时间戳信息加在Bill和Dave的交易请求之前，以便merge可以根据这个来运作？
AUDIENCE: In order to brings this back into a more functional perspective, could we just explicitly time stamp all the inputs from Bill and Dave and define fair merge to just be the sort on those time stamps?

592
01:00:49,150 --> 01:00:49,550
当然，当然可以
PROFESSOR: Yeah, you can do that.

593
01:00:49,550 --> 01:00:50,600
你可以那样做
You can do that sort of thing.

594
01:00:50,600 --> 01:01:00,970
我们可以想像这个merge每毫秒读一次输入，如果这个时间点没有请求，就什么都不做
Another thing you could say is imagine that really what this function is, is that it does a read every microsecond, and then if there's none there, that's considered an empty one.

595
01:01:00,970 --> 01:01:03,610
这和你刚刚说的那种方式是相同的
That's about equivalent to what you said.

596
01:01:03,610 --> 01:01:07,110
当然可以这样做，但是那不是我们关注的重点
And yes, you can do that, but that's a clg.

597
01:01:07,110 --> 01:01:10,170
我们不只是关心函数的具体实现
So it's not quite only implementation we're worried about.

598
01:01:10,170 --> 01:01:18,824
我们更关心语言的表现力，现在我们遇到的问题主要在于我们能轻松表达出来的和我们想要表达的不相符
We're worried about expressive power in the language, and what we're running across is a real mismatch between what we can say easily and what we'd like to say.

599
01:01:18,824 --> 01:01:26,080
听起来好像如果两个人同时发出请求，这个方法就会出问题
AUDIENCE: It sounds like where we're getting hung up with that is the fact it expects one input from both Bill and Dave at the same time.

600
01:01:26,080 --> 01:01:28,530
也不是特指这一个问题，而是关乎你如何来定义这个函数的问题
PROFESSOR: It's not quite one, but it's anything you define.

601
01:01:28,530 --> 01:01:36,110
你也可以说Dave一次性处理两个请求，但是如果你预先定义些什么，这种方式也会出问题
So you can say Dave can go twice as often, but if anything you predefine, it's not the right thing.

602
01:01:36,110 --> 01:01:41,930
所以说交易有很多种方式，你无法根据特定的交易情况来决定如何定义
You can't decide at some particular function of their input requests.

603
01:01:41,930 --> 01:01:47,290
有一个更坏的消息是，甚至有一些情况连merge也处理不了
Worse yet, I mean, worse yet, there are things that even merge can't do.

604
01:01:47,290 --> 01:01:52,470
假如你把更多的人关联在这个银行帐户上
One thing you might want to do that's even more general is suddenly you add somebody else to this bank account system.

605
01:01:52,470 --> 01:01:56,030
假如这个人是John
You go and you add John to this bank account system.

606
01:01:56,030 --> 01:02:02,040
这个流我就先不往上画了，也同样连接在merge上
And now there's yet another stream that's going to come into the picture at some time which we haven't prespecified.

607
01:02:02,040 --> 01:02:08,860
这种情况甚至公平合并也无法给出合理的合并，我们称其为natagers还是什么我记不清了
So that's something even fair merge can't do, and they're things called-- I forget-- natagers or something.

608
01:02:08,860 --> 01:02:11,790
需要一种更为广泛化的公平合并也解决
That's a generalization of fair merge to allow that.

609
01:02:11,790 --> 01:02:19,580
有很多研究都在讨论，引入越来越多的机制，函数式思维能达到怎样的程度？
There's a whole sort of research discipline saying how far can you push this functional perspective by adding more and more mechanism?

610
01:02:19,580 --> 01:02:25,610
到什么样的程度它也会出问题，就和我们使用赋值一样
And how far does that go before the whole thing breaks down and you might as well been using set anyway.

611
01:02:25,610 --> 01:02:28,960
干脆自动取款好了
AUDIENCE: You need to set him up on automatic deposit.

612
01:02:28,960 --> 01:02:39,630
[笑声]
[LAUGHTER]

613
01:02:39,630 --> 01:02:40,880
好的，今天就到这里
PROFESSOR: OK, thank you.

