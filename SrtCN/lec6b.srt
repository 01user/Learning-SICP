1
00:00:20,970 --> 00:00:24,080
教授：上节课 我们介绍了流
PROFESSOR: OK, well, we've been looking at streams,

2
00:00:24,080 --> 00:00:27,824
按照信号处理的方式来组织系统
this signal processing way of putting systems together.

3
00:00:28,870 --> 00:00:31,424
要记住的是 关键点在于
And remember, the key idea is that

4
00:00:31,904 --> 00:00:32,960
我们分离开
we decouple

5
00:00:34,208 --> 00:00:37,312
程序中 事件表面上的顺序
the apparent order of events in our programs

6
00:00:37,584 --> 00:00:40,176
与机器中的实际计算顺序
from the actual order of events in the computer.

7
00:00:41,072 --> 00:00:42,288
那就意味着 我们可以
And that means that we can start

8
00:00:42,576 --> 00:00:44,144
着手处理非常长的流
dealing with very long streams

9
00:00:44,896 --> 00:00:47,392
并且只有在需要的时候才生成其中的元素
and only having to generate the elements on demand.

10
00:00:47,536 --> 00:00:49,392
这种按需计算的方式
That sort of on-demand computation

11
00:00:49,520 --> 00:00:51,408
是内建在流的数据结构中的
is built into the stream's data structure.

12
00:00:54,110 --> 00:00:55,648
即使这个流非常之长
So if we have a very long stream,

13
00:00:55,664 --> 00:00:57,080
我们只计算所需要的
we only compute what we need.

14
00:00:58,040 --> 00:01:00,750
只有当我们要求的时候 新的数据才会生成
The things only get computed when we actually ask for them.

15
00:01:00,750 --> 00:01:01,744
要举个什么样的例子呢？
Well, what are examples?

16
00:01:02,110 --> 00:01:03,600
这个“按需”是什么个情况呢？
Are they actually asking for them?

17
00:01:05,024 --> 00:01:06,016
举个例子 
For instance, we might

18
00:01:09,216 --> 00:01:11,376
我们可能会想要一个流中的第N个元素
might ask for the n-th element of a stream.

19
00:01:15,360 --> 00:01:18,928
这个过程可以用于计算流的第N个元素
Here's a procedure that computes the n-th element of a stream.

20
00:01:20,090 --> 00:01:21,232
一个参数为索引N
An integer n,

21
00:01:21,248 --> 00:01:22,848
另一个参数是流S
the n-th element of some stream s,

22
00:01:23,408 --> 00:01:25,424
递归遍历这个流即可求解
and we just recursively walk down the stream.

23
00:01:25,570 --> 00:01:27,392
如果N为0 我们就计算头部分
And if n is 0, we compute the head.

24
00:01:27,960 --> 00:01:30,992
否则 就在流的尾部分
Otherwise, it's the n-th the minus 1 element

25
00:01:31,744 --> 00:01:32,800
查找第N-1个元素
of the stream.

26
00:01:34,310 --> 00:01:36,432
看起来是LISP中很普通的编程方式 但是不同的是
Those two are just like for Lisp, but the difference

27
00:01:36,624 --> 00:01:38,768
知道我们不断遍历 取得相继的N个元素
is those elements aren't going to get computed

28
00:01:38,864 --> 00:01:40,992
这些元素才被计算出来
until we walk down, taking successive n-ths.

29
00:01:41,520 --> 00:01:44,784
这是这些流元素可能被FORCE的一种方式
So that's one way that the stream elements might get forced.

30
00:01:45,776 --> 00:01:46,640
另外一种方式则是
And another way,

31
00:01:47,184 --> 00:01:48,928
这里有个简单的过程 用来打印一个流
here's a little procedure that prints a stream.

32
00:01:49,300 --> 00:01:50,384
它的定义是
We say print a stream,

33
00:01:51,904 --> 00:01:53,280
打印流S的过程PRINT-STREAM的定义是
so to print a stream s.

34
00:01:54,150 --> 00:01:55,120
我们要怎么做呢？
Well, what do we do? We'll

35
00:01:55,744 --> 00:01:56,864
先打印流的头部分
We print the head of the stream,

36
00:01:57,744 --> 00:01:59,328
流的头部分在这时就被计算出来
and that will cause the head to be computed.

37
00:01:59,720 --> 00:02:02,848
然后我们再递归地打印流的尾部分
And then we recursively print stream the tail of the stream.

38
00:02:04,990 --> 00:02:06,032
如果流为空
And if we're already done,

39
00:02:06,048 --> 00:02:08,576
就返回一个的表示完成的消息 “DONE”
maybe we have to return something about the message done.

40
00:02:09,660 --> 00:02:11,392
如果你构造了一个流长
OK, and then so if you make a stream,

41
00:02:11,648 --> 00:02:13,648
这个流非常的长
you could say here's the stream, this very long stream.

42
00:02:14,310 --> 00:02:16,336
当你调用这个过程
And then you say print the stream,

43
00:02:16,416 --> 00:02:19,776
流中的元素会随着PRINT-STREAM的调用
and the elements of the stream will get computed successively

44
00:02:19,872 --> 00:02:21,120
而被依次计算出来
as that print calls them.

45
00:02:21,320 --> 00:02:22,816
不会在一开始就全部计算出来
They won't get all computed initially.

46
00:02:24,300 --> 00:02:25,664
正因为如此 我们能够
So in this way, we can

47
00:02:27,504 --> 00:02:29,610
我们能够处理非常长的流
So in this way, we can deal with some very long streams.

48
00:02:30,190 --> 00:02:31,920
多长呢？
Well, how long can a stream be?

49
00:02:33,744 --> 00:02:35,120
可以是无限长
Well, it can be infinitely long.

50
00:02:35,904 --> 00:02:38,048
我们在计算机上实践一下
Let's look at an example here on the computer.

51
00:02:38,920 --> 00:02:41,968
我可以在计算机前输入
I could walk up to this computer, and I could say--

52
00:02:43,488 --> 00:02:53,312
我先定义一个函数 (INTEGERS-FROM N)
how about we'll define the stream of integers starting with some number N,

53
00:02:54,240 --> 00:02:57,136
用于生成一个从N开始的正整数流
the stream of positive integers starting with some number n.

54
00:03:00,360 --> 00:03:19,168
也就是 (CONS-STREAM N (INTEGERS-FROM (+ N 1))))
And that's cons-stream of n onto the integers from one more.

55
00:03:24,416 --> 00:03:25,616
这样就我们要的全部整数
So there are the integers.

56
00:03:28,992 --> 00:03:31,500
现在我们用这个表示所有的整数 #TBD
Then I could say let's get all the integers.

57
00:03:34,570 --> 00:03:44,336
(DEFINE INTEGERS (INTEGERS-FROM 1))
define the stream of integers to be the integers starting with 1.

58
00:03:48,840 --> 00:03:50,944
如果现在我执行 (NTH-STREAM 20 INTEGERS)
And now if I say something like

59
00:03:54,416 --> 00:03:55,800
来查看第20个元素
what's the what's the 20th integer.

60
00:04:03,424 --> 00:04:05,536
得到21 因为索引是从0开始的
So it's 21 because we start counting at 0.

61
00:04:06,848 --> 00:04:08,880
或者我们来点更复杂的
Or I can do more complicated things.

62
00:04:09,450 --> 00:04:10,840
我再来定义一个谓词
Let me to define a little predicate here.

63
00:04:11,776 --> 00:04:18,512
谓词 NO-SEVEN 用来检测是否为7的倍数
How about define no-seven.

64
00:04:19,580 --> 00:04:20,752
它的判定标准是
It's going to test an integer,

65
00:04:21,792 --> 00:04:23,168
如果整数X不是7的倍数
and it's going to say it's not.

66
00:04:28,820 --> 00:04:33,968
我取X除7的余数
I take the remainder of x by 7,

67
00:04:36,624 --> 00:04:38,352
余数不应该为0
I don't get 0.

68
00:04:43,808 --> 00:04:49,776
这时用NO-SEVEN这个谓词
And then I could say define the integers with no sevens

69
00:04:50,224 --> 00:04:59,120
过滤全部的整数
take all the integers and filter them to have no sevens.

70
00:05:11,570 --> 00:05:13,344
这样我就得到了所有的
So now I've got the stream of all the integers

71
00:05:13,632 --> 00:05:15,056
不是7的倍数的整数构成的流
that are not divisible by seven.

72
00:05:16,490 --> 00:05:23,440
如果我问 这些不是7的倍数的整数中
So if I say what's the 100th integer

73
00:05:24,704 --> 00:05:26,480
的第100个数是多少？
and the list not divisible by seven,

74
00:05:26,864 --> 00:05:28,112
结果是117
I get 117.

75
00:05:28,320 --> 00:05:30,672
或者我也可以问
Or if I'd like to say well, I could say ah..

76
00:05:32,304 --> 00:05:34,384
这个流的所有元素都是些什么？
well, gee, what are all of them?

77
00:05:35,270 --> 00:05:40,352
我可以用(PRINT-STREAM NS) 来尝试打印这个流
So I could say print stream all these integers with no seven,

78
00:05:40,832 --> 00:05:41,792
它就会输出个不停
it goes off printing.

79
00:05:45,100 --> 00:05:47,070
你可能需要等上很久才能得到全部结果
You may have to wait a very long time to see them all.

80
00:05:52,670 --> 00:05:53,840
你可能会问了
Well, you can start asking, gee,

81
00:05:54,816 --> 00:05:57,008
这个数据结构
you know, is it really true that this data structure

82
00:05:58,288 --> 00:06:00,656
#TBD
with the integers is really all the integers?

83
00:06:01,100 --> 00:06:04,053
现在我画一个图来演示下刚写的那个程序
And let me draw a picture of that program I just wrote.

84
00:06:04,960 --> 00:06:10,570
这是我刚才键入的整数定义
Here's the, right, here's the definition of the integers again that I just typed in,

85
00:06:12,336 --> 00:06:15,984
它是一个由第一个整数和由下一个整数生成的流 所构成的序对
Right it's a cons of the first integer under the integer starting with the rest.

86
00:06:17,616 --> 00:06:19,770
现在我们画个图来看看它到底是什么样
Now, we can make a picture of that and see what it looks like.

87
00:06:22,720 --> 00:06:24,320
从概念上来说 这应该是一个盒子
Conceptually, what I have is a box

88
00:06:25,536 --> 00:06:27,184
这个盒子是(INTEGER-FROM N)
that's the integer starting with n.

89
00:06:27,420 --> 00:06:29,088
它接受一个参数N
It takes in some number n,

90
00:06:31,424 --> 00:06:32,976
然后返回一个流
and it's going to return a stream of--

91
00:06:35,024 --> 00:06:37,360
这个无穷流表示从N开始的所有整数
this infinite stream of all integers starting with n.

92
00:06:38,080 --> 00:06:38,736
#TBD
And what do I do?

93
00:06:38,752 --> 00:06:42,384
呃 这个是 INT-FROM 盒子
Well, this is an integers-from box.

94
00:06:45,070 --> 00:06:45,800
里面是什么样子呢？
What's it got in it?

95
00:06:45,800 --> 00:06:48,608
取得参数N之后
Well, it takes in this n,

96
00:06:52,272 --> 00:06:53,920
将其 +1
and it increments it.

97
00:06:57,952 --> 00:07:03,150
然后把结果递归地传递给另一个INT-FROM盒子
And then it puts the result into recursively another integer's from box.

98
00:07:06,870 --> 00:07:09,600
把这个盒子的结果和最初的N
It takes the result of that and the original n

99
00:07:10,240 --> 00:07:12,784
用CONS组合起来
and puts those together with a cons

100
00:07:13,392 --> 00:07:14,360
就形成了一个流
and forms a stream.

101
00:07:14,576 --> 00:07:17,264
我刚才写的那个过程 画出来就是这样子
So that's a picture of that program I wrote. And this is a ...

102
00:07:18,528 --> 00:07:20,320
我们看到的这类图像
Let's see. These kind of diagrams we first saw

103
00:07:20,784 --> 00:07:21,740
首先是由 Peter Henderson 提出的
drawn by Peter Henderson,

104
00:07:21,760 --> 00:07:23,320
也就是前面课程中绘图语言的发明者
the same guy who did the Escher language.

105
00:07:23,320 --> 00:07:24,752
我们把这种图叫做 Henderson 图
We call them Henderson diagrams.

106
00:07:25,376 --> 00:07:27,904
画这种图需要遵守一定的约定
And the convention here is that you put these things together.

107
00:07:28,530 --> 00:07:32,512
这些实线代表输出的流
And the solid lines are things coming out are streams,

108
00:07:33,024 --> 00:07:36,208
这些虚线则是初始的输入值
and dotted lines are initial values going in.

109
00:07:37,270 --> 00:07:39,024
而这个图描述的形状是——
So this one has the shape of--

110
00:07:39,408 --> 00:07:41,600
它会取一个整数作为初始值
it takes in some integer, some initial value,

111
00:07:41,808 --> 00:07:42,912
然后输出一个流
and outputs a stream.

112
00:07:46,352 --> 00:07:48,224
现在 你可能又要问了 #TBD
Again, you can ask. You know it's really

113
00:07:48,380 --> 00:07:50,880
那个INTEGERS的数据结构真的代表着全部的整数吗？
Is that data structure integers really all the integers?

114
00:07:52,090 --> 00:07:54,912
或者它只是经过了精心组织
Alright? Or is it is something that's cleverly arranged

115
00:07:54,940 --> 00:07:56,432
以至于我们总可以在其中找到
so that whenever you look for an integer

116
00:07:56,448 --> 00:07:57,240
我们需要的那个整数？
you find it there?

117
00:07:57,950 --> 00:07:59,744
这有点像个哲学问题 不是么？
That's sort of a philosophical question, right?

118
00:07:59,780 --> 00:08:01,696
#TBD
If something is there

119
00:08:02,144 --> 00:08:03,968
#TBD
whenever you look, is it really there or not?

120
00:08:04,450 --> 00:08:07,344
这就有点像
It's sort of the same sense in which

121
00:08:07,360 --> 00:08:09,420
你在银行中的存款那样
the money in your savings account is in the bank.

122
00:08:12,380 --> 00:08:12,640
好吧
Well

123
00:08:16,352 --> 00:08:17,488
我们再来看一个例子
let me do another example.

124
00:08:18,680 --> 00:08:20,704
第一节课刚开始
Umm, Gee, we started the course

125
00:08:20,720 --> 00:08:22,720
我们就讲了一个来自于亚历山大的算法
with an algorithm from Alexandria,

126
00:08:23,296 --> 00:08:25,800
来自亚历山大的 Heron 提出的
which was Heron of Alexandria's algorithm

127
00:08:25,824 --> 00:08:26,944
一个用于计算平方根的算法
for computing the square root.

128
00:08:28,470 --> 00:08:32,030
现在再来看一个 同样来自于亚力山大的算法
Let's take a look at another Alexandrian algorithm.

129
00:08:32,030 --> 00:08:35,088
这个被称为 Eratosthenes 算法的方法
This one is Eratosthenes method for

130
00:08:36,192 --> 00:08:38,448
用于计算所有的质数
for computing all of the primes.

131
00:08:41,169 --> 00:08:42,830
它被称为 Eratosthenes 筛法
It is called the Sieve of Eratosthenes.

132
00:08:42,830 --> 00:08:49,728
它是这样的 一开始
And what you do is you start out,

133
00:08:50,992 --> 00:08:52,288
先列举所有的整数
and you list all the integers,

134
00:08:52,608 --> 00:08:53,536
从 2 开始
say, starting with 2.

135
00:08:53,880 --> 00:08:55,040
然后取第一个整数
And then you take the first integer, and you say,

136
00:08:55,088 --> 00:08:56,670
然后你发现 哦 2是一个质数
and you say, oh, that's prime.

137
00:08:57,310 --> 00:08:58,352
然后你考察剩余的整数
And then you go look at the rest,

138
00:08:58,688 --> 00:09:00,880
划掉其中可以被 2 整除的数
and you cross out all the things divisible by 2.

139
00:09:01,520 --> 00:09:04,736
我把这个划掉 还有这个 这个
So I cross out this and this and this.

140
00:09:05,250 --> 00:09:06,352
有点费时
This takes a long time

141
00:09:06,368 --> 00:09:08,912
我要对所有的整数进行这样的操作
because I have to do it for all of the integers.

142
00:09:11,160 --> 00:09:15,392
我遍历整个整数表
So I go through the entire list of integers,

143
00:09:18,272 --> 00:09:20,944
划掉所有被 2 整除的数
crossing the ones divisible by 2.

144
00:09:22,112 --> 00:09:24,384
所有的整数都操作完后
And now when I finish with all of the integers,

145
00:09:24,784 --> 00:09:26,720
回过头再来看还剩些什么
I go back and look and say what am I left with?

146
00:09:27,040 --> 00:09:28,800
好的 我们继续 下一个数就是3了
Well, the first thing that starts there is 3.

147
00:09:29,330 --> 00:09:30,336
3也是一个质数
So 3 is a prime.

148
00:09:30,770 --> 00:09:33,056
现在 我会继续在剩下的数中
And now I go back through what I'm left with,

149
00:09:33,360 --> 00:09:35,072
划掉所有被3整除的数
and I cross out all the things divisible by 3.

150
00:09:35,080 --> 00:09:43,808
划掉 9、15、21、27、33 等等
So let's see, 9 and 15 and 21 and 27 and 33 and so on.

151
00:09:44,336 --> 00:09:45,120
我就不往下划了
I won't finish.

152
00:09:45,350 --> 00:09:46,528
然后看看我们还剩下什么
Then I see what I'm left with.

153
00:09:47,250 --> 00:09:49,840
而下一个就是5了
And the next one I have is 5.

154
00:09:50,496 --> 00:09:52,048
我又遍历剩下的数
Now I can through the rest,

155
00:09:52,432 --> 00:09:54,512
我找到第一个能被5整除的数
and I find the first one that's divisible by 5.

156
00:09:54,540 --> 00:09:57,616
我把剩下的能被 5 整除的数都划掉
I cross out from the remainder all the ones that are divisible by 5.

157
00:09:58,352 --> 00:09:59,248
做完这个之后
And I did that,

158
00:09:59,824 --> 00:10:01,890
下一个数就是7
and then I go through and find 7.

159
00:10:01,890 --> 00:10:02,720
再遍历剩下的数
Go through all the rest,

160
00:10:02,760 --> 00:10:03,952
划掉所有被 7 整除的数
cross out things divisible 7,

161
00:10:03,984 --> 00:10:05,470
然后一直这样下去
and I keep doing that forever.

162
00:10:06,810 --> 00:10:07,408
全部结束的时候
And when I'm done,

163
00:10:07,408 --> 00:10:09,104
我也就得到了所有的质数
what I'm left with is a list of all the primes.

164
00:10:09,904 --> 00:10:13,312
这就是 Eratosthenes 筛法
So that's the Sieve of Eratosthenes.

165
00:10:15,430 --> 00:10:17,696
我们来看下实际代码
Let's look at it as a computer program.

166
00:10:17,930 --> 00:10:19,856
这个过程命名为 SIEVE
It's a procedure called sieve.

167
00:10:27,910 --> 00:10:29,408
这是我刚才的操作的代码表示
Now, I just write what I did.

168
00:10:30,336 --> 00:10:34,480
SIEVE过程 以一个流 S 为参数
I'll say to sieve some stream s.

169
00:10:38,770 --> 00:10:39,936
返回一个新的流
I'm going to build a stream

170
00:10:40,272 --> 00:10:41,840
新的流的头部分 就是流 S 的头部分
whose first element is the head of this.

171
00:10:41,870 --> 00:10:44,432
回忆一下 我总是取剩下的数中的第一个
Remember, I always found the first thing I was left with,

172
00:10:44,912 --> 00:10:48,752
而尾部分则是把流 S 的尾部分
and the rest of it is the result of taking the tail of S,

173
00:10:51,088 --> 00:10:55,328
过滤掉所有能被 S 头部分整除的数
filtering it to throw away all the things that are divisible by the head of S,

174
00:10:56,416 --> 00:10:57,568
然后再对结果筛选
and now sieving the result.

175
00:10:59,020 --> 00:11:00,096
这个代码就是这样
That's just what I did.

176
00:11:01,980 --> 00:11:04,688
现在 为了得到由质数构成的无穷流
And now to get the infinite stream of times,

177
00:11:05,024 --> 00:11:06,900
我们对从2开始的整数流进行 SIEVE
we just sieve all the integers starting from 2.

178
00:11:14,920 --> 00:11:15,568
我们来实践一下
Let's try that.

179
00:11:16,300 --> 00:11:18,304
实际上 我们可以在计算机中运行
We can actually do it.

180
00:11:19,760 --> 00:11:22,128
我希望我已经预先输入过 SIEVE 的定义了
I typed in the definition of sieve before, I hope,

181
00:11:22,864 --> 00:11:24,064
所以我可以定义
so I can say something like

182
00:11:24,928 --> 00:11:33,456
我可以把 PRIMES 定义为
define the primes to be

183
00:11:34,640 --> 00:11:41,456
(SIEVE (INTEGERS-FROM 2))
the result of sieving the integers starting with 2.

184
00:11:46,760 --> 00:11:48,100
现在我就得到了质数构成的表
So now I've got this list of primes.

185
00:11:48,100 --> 00:11:50,990
这样就得到了所有的质数 对吧？
That's all of the primes, right?

186
00:11:50,990 --> 00:11:53,520
比如我可以问 第20个质数是什么？
So, if for example, what's the 20th prime in that list?

187
00:12:00,736 --> 00:12:01,680
结果是73
73.

188
00:12:02,540 --> 00:12:03,344
那个短促的停顿
See, and that little pause,

189
00:12:03,360 --> 00:12:04,928
这就是在我向它询问第20个元素时
it was only at the point

190
00:12:04,944 --> 00:12:07,680
它才进行实际的计算
when I started asking for the 20th prime is that it started computing.

191
00:12:10,370 --> 00:12:11,296
在这里 我也可以要求
Or I can say here

192
00:12:13,808 --> 00:12:14,880
打印所有的质数
Or I can say here let's look at all of the primes.

193
00:12:22,640 --> 00:12:24,400
解释器就开始计算并打印所有的质数
And there it goes computing all of the primes.

194
00:12:25,350 --> 00:12:27,616
如果想要完整打印的话 得花上好一会儿
Of course, it will take a while again if I want to look at all of them,

195
00:12:27,792 --> 00:12:28,570
所以先把它停掉
so let's stop it.

196
00:12:32,030 --> 00:12:33,130
现在我用图形来表示这个过程
Let me draw you a picture of that.

197
00:12:33,130 --> 00:12:34,176
我已经画好了
Well, I've got a picture of that.

198
00:12:34,890 --> 00:12:36,192
这个过程的图形应该是什么样子呢？
What's that program really look like?

199
00:12:37,900 --> 00:12:39,776
用这类图形的约定来说
Again, some practice with these diagrams,

200
00:12:39,824 --> 00:12:40,544
我有一个叫 SIEVE 的盒子
I have a sieve box.

201
00:12:42,610 --> 00:12:43,560
它是如何运作的呢？
How does sieve work?

202
00:12:43,560 --> 00:12:44,810
它以一个流作为输入
It takes in a stream.

203
00:12:48,850 --> 00:12:50,592
分离流的 HEAD 部分和 TAIL 部分
It splits off the head from the tail.

204
00:12:50,870 --> 00:12:53,264
从 SIEVE 盒子出来的第一个东西
And the first thing that's going to come out of the sieve

205
00:12:53,488 --> 00:12:54,976
就是原来流的 HEAD 部分
is the head of the original stream.

206
00:12:58,208 --> 00:13:00,928
这个 HEAD 同样也用于这个盒子
Then it also takes the head and uses that.

207
00:13:02,550 --> 00:13:05,104
这个盒子会过滤流的 TAIL 部分
It takes the stream. It filters the tail

208
00:13:05,552 --> 00:13:08,336
过滤的依据是 能否被 HEAD 部分整除
It filters the tail and uses the head to filter for nondivisibility.

209
00:13:09,536 --> 00:13:11,184
过滤得到的不可整除的那些数
It takes the result of nondivisibility

210
00:13:11,248 --> 00:13:13,120
再放入另一个 SIEVE 盒子
and puts it through another sieve box

211
00:13:13,904 --> 00:13:15,130
然后把它们组合输出
and puts the result together.

212
00:13:15,130 --> 00:13:16,896
你可以把 SIEVE 想象为一个过滤器
So you can think of this sieve a filter,

213
00:13:17,200 --> 00:13:19,232
只不过它是一个无穷递归的过滤器
but notice that it's an infinitely recursive filter.

214
00:13:19,650 --> 00:13:20,880
这是因为在 SIEVE 盒子中
Because inside the sieve box

215
00:13:21,520 --> 00:13:22,608
还有另外一个 SIEVE 盒子
is another sieve box,

216
00:13:23,376 --> 00:13:25,856
内部的盒子里面还有另外一个 SIEVE 盒子
and inside that is another sieve box and another sieve box.

217
00:13:27,130 --> 00:13:28,960
#TBD
So you see we start getting some very powerful things.

218
00:13:28,960 --> 00:13:32,848
我们开始把 以信号处理对于世界的看法#TBD
We're starting to mix this signal processing view of the world

219
00:13:33,904 --> 00:13:36,416
与计算中的递归结合在一起
with things like recursion that come from computation.

220
00:13:37,424 --> 00:13:39,824
还有很多像是这样的事
And there are all sorts of interesting things you can do that are like this.

221
00:13:40,970 --> 00:13:42,096
好的 有什么问题吗？
All right, any questions?

222
00:13:48,190 --> 00:13:49,168
好吧 那我们休息一下
OK, let's take a break.

223
00:14:28,656 --> 00:14:32,096
我们已经看了好几个流式程序设计的例子
Well, we've been looking at a couple of examples of stream programming.

224
00:14:34,790 --> 00:14:39,216
我们目前接触到的流过程
All the stream procedures that we've looked at so far

225
00:14:39,728 --> 00:14:41,328
都有一个共同的特征
have the same kind of character.

226
00:14:41,490 --> 00:14:43,632
这些过程总是递归地
We've been writing these recursive procedures

227
00:14:44,160 --> 00:14:46,496
一次生成一个元素
that kind of generate these stream elements one at a time

228
00:14:46,510 --> 00:14:48,720
再用CONS-STREAM连接起来
and put them together in cons-streams.

229
00:14:49,152 --> 00:14:50,864
因此 我们一直讨论的是生成器
So we've been thinking a lot about generators.

230
00:14:50,928 --> 00:14:53,632
还有一种思考流式程序设计的方法
There's another way to think about stream processing,

231
00:14:53,790 --> 00:14:56,960
我们不认为程序是
and that's to focus not on programs that sort of

232
00:14:57,360 --> 00:14:59,930
沿着流逐一处理元素
process these elements as you walk down the stream,

233
00:15:00,256 --> 00:15:05,680
而是一下子处理了整个流
but on things that kind of process the streams all at once.

234
00:15:07,180 --> 00:15:09,168
我用两个非常有用的例子
To show you what I mean, let me start by defining

235
00:15:09,232 --> 00:15:11,500
来详细说明
two procedures that will come in handy.

236
00:15:12,410 --> 00:15:13,600
第一个过程是 ADD-STREAMS
The first one's called add streams.

237
00:15:15,360 --> 00:15:18,256
它接受两个流作为参数
Add streams takes two streams:

238
00:15:18,816 --> 00:15:20,880
S1 和 S2
s1 and s2.

239
00:15:22,300 --> 00:15:24,672
它生成一个新的流
And it's going to produce a stream

240
00:15:24,992 --> 00:15:28,176
其元素是两个流相应位置元素的和
whose elements are the are the corresponding sums

241
00:15:30,224 --> 00:15:31,888
相当于是“按元素”的加
We just sort of add them element-wise.

242
00:15:32,970 --> 00:15:33,952
如果其中一个流是空的
If either stream is empty,

243
00:15:33,968 --> 00:15:35,390
我们就返回另一个
we just return the other one.

244
00:15:36,810 --> 00:15:38,960
否则 我们就构建一个新的流
Otherwise, we're going to make a new stream

245
00:15:39,904 --> 00:15:42,960
新流的 HEAD 部分是两个流 HEAD 部分之和
whose head is the sum of the two heads

246
00:15:44,000 --> 00:15:44,880
而新流的尾 TAIL 部分
whose tail

247
00:15:46,000 --> 00:15:48,624
则是递归地加和 TAIL 部分
is the result of recursively adding the tails.

248
00:15:50,090 --> 00:15:52,736
这就会产生“按元素”地加的效果
So that will produce the element-wise sum of two streams.

249
00:15:53,150 --> 00:15:57,040
另一个过程是 SCALE-STREAM
And then another useful thing to have around is scale stream.

250
00:15:57,500 --> 00:16:01,664
SCALE-STREAM 有两个参数 常数 C 和流 S
Scale stream takes some constant number in a stream s

251
00:16:04,112 --> 00:16:06,624
结果生成的流
and is going to produce the stream

252
00:16:07,184 --> 00:16:09,504
相当于是将流 S 的所有元素乘上了 C
of elements of s multiplied by this constant.

253
00:16:09,710 --> 00:16:11,216
这很简单 就是一个 MAP
And that's easy, that's just a map

254
00:16:12,208 --> 00:16:16,224
变换函数是把参数 X 乘以 C
of the function of an element that multiplies it by the constant,

255
00:16:16,352 --> 00:16:17,808
把这个函数 MAP 于整个流
and we map that down the stream.

256
00:16:20,064 --> 00:16:21,472
有了这两个过程
So given those two,

257
00:16:22,640 --> 00:16:24,368
我来给你们解释 什么叫做
let me show you what I mean by programs that

258
00:16:24,704 --> 00:16:27,008
“一下子处理整个流”
that operate on streams all at once.

259
00:16:28,128 --> 00:16:28,736
我们来看这个
Let's look at this.

260
00:16:30,200 --> 00:16:30,928
假设这样
Suppose I write this.

261
00:16:31,680 --> 00:16:52,352
(DEFINE ONES (CONS-STREAM 1 ONES))
I say define--  I'll call it ones-- to be cons-stream of 1 onto ones.

262
00:16:54,860 --> 00:16:55,520
这是什么？
What's that?

263
00:16:56,950 --> 00:16:58,944
这是一个表示无穷个1的流
That's going to be an infinite stream of ones

264
00:16:59,968 --> 00:17:01,440
因为 HEAD 部分是1
because the first thing is 1.

265
00:17:03,330 --> 00:17:05,152
TAIL 部分则是
And the tail of it is a thing

266
00:17:05,552 --> 00:17:06,832
TAIL 部分的 HEAD 部分是1
whose first thing is 1

267
00:17:07,630 --> 00:17:09,024
TAIL 部分的 TAIL 部分
whose tail is a thing

268
00:17:09,120 --> 00:17:10,240
其 HEAD 又为 1
whose first thing is 1

269
00:17:10,528 --> 00:17:11,780
以此类推
and so on and so on.

270
00:17:11,780 --> 00:17:13,328
这就是无穷个1的流
So that's an infinite stream of ones.

271
00:17:15,130 --> 00:17:15,936
现在根据ONES
And now using that,

272
00:17:16,128 --> 00:17:18,032
我再给出另一种定义整数的方式
let me give you another definition of the integers.

273
00:17:19,472 --> 00:17:27,360
(DEFINE INTEGERS
We can define the integers to be--

274
00:17:28,240 --> 00:17:30,768
当然 第一个数是1
well, the first integer we'll take to be 1,

275
00:17:32,752 --> 00:17:38,576
(CONS-STREAM 1 (ADD-STREAM
his cons-stream of 1 onto the element-wise sum

276
00:17:40,224 --> 00:17:48,270
INTEGERS ONES)))
onto add streams of the integers to ones.

277
00:17:55,100 --> 00:17:56,352
整数流是这样的：
The integers are a thing

278
00:17:57,248 --> 00:17:59,984
它的第一个元素是1
whose first element is 1,

279
00:18:00,880 --> 00:18:02,320
而其余部分则是
and the rest of them you get

280
00:18:03,120 --> 00:18:06,144
依次把每个整数加1
by taking those integers and incrementing each one by one.

281
00:18:06,640 --> 00:18:08,192
因此 整数流的第二个元素则是
So the second element of the integers

282
00:18:08,512 --> 00:18:11,968
整数流的第一个元素加 1
is the first element of the integers incremented by one.

283
00:18:13,920 --> 00:18:15,184
#TBD
And the rest of that is the next one,

284
00:18:15,200 --> 00:18:16,480
第三个元素则是
and the third element of that

285
00:18:16,624 --> 00:18:21,968
整数流尾部分 TAIL 部分第一个元素加1
is the same as the first element of the tail of the integers incremented by one,

286
00:18:22,512 --> 00:18:23,760
这也就相当于
which is the same as the

287
00:18:25,088 --> 00:18:28,656
最初整数流的第一个元素加 1
first element of the original integers incremented by one

288
00:18:28,864 --> 00:18:31,250
然后再加 1 以此类推
and incremented by one again and so on.

289
00:18:35,240 --> 00:18:36,310
这看起来有点匪夷所思
That looks pretty suspicious.

290
00:18:36,310 --> 00:18:37,472
这样的过程可以正常运行
See, notice that it works

291
00:18:38,128 --> 00:18:38,990
关键在于延时求值
because of delay.

292
00:18:40,150 --> 00:18:43,328
我们来看这个ONES
See, this looks like-- let's take a look at ones.

293
00:18:43,870 --> 00:18:45,920
这看起来根本不可能
This looks like it couldn't even be processed

294
00:18:46,256 --> 00:18:47,632
#TBD
because it's suddenly saying

295
00:18:47,792 --> 00:18:48,960
为了知道 ONES 是什么
in order to know what ones is,

296
00:18:49,008 --> 00:18:50,912
而我发现它的定义依赖于它本身
I say it's cons-stream of something onto ones.

297
00:18:51,130 --> 00:18:52,080
它之所以可以运行是因为
The reason that works

298
00:18:52,096 --> 00:18:54,040
这里暗中隐藏着延时求值
because of that very sneaky hidden delay in there.

299
00:18:55,250 --> 00:18:56,560
这个代码实际上是
Because what this really is,

300
00:18:57,792 --> 00:18:59,696
回忆下 CONS-STREAM是只是一个缩写
remember, cons-stream is just an abbreviation.

301
00:19:00,290 --> 00:19:01,152
实际上则是
This really is

302
00:19:01,856 --> 00:19:08,992
(CONS 1 (DELAY ONES))
cons of 1 onto delay of ones.

303
00:19:12,140 --> 00:19:13,216
它又是怎么运作的呢？
So how does that work?

304
00:19:15,500 --> 00:19:16,880
你想要定义 ONES
You say I'm going to define ones.

305
00:19:18,020 --> 00:19:20,240
我来看看 ONES 要被定义成什么样
First I see what ones is supposed to be defined as.

306
00:19:20,700 --> 00:19:23,408
ONES 被定义为一个序对
Well, ones is supposed to be defined as

307
00:19:24,896 --> 00:19:28,112
其 CAR 部分为 1
a cons whose first part is 1

308
00:19:28,320 --> 00:19:29,456
而 CDR 部分则是
and the second part is,

309
00:19:29,450 --> 00:19:30,736
是一个计算某物的 PROMISE
well, it's a promise to compute something

310
00:19:30,752 --> 00:19:31,690
我现在还不用关心
that I don't worry about yet.

311
00:19:32,710 --> 00:19:34,256
所以虽然在这个时候 ONES 还没有被定义
So it doesn't bother me that at the point

312
00:19:34,288 --> 00:19:36,300
但对我并不造成什么影响
I do this definition, ones isn't defined.

313
00:19:37,270 --> 00:19:39,456
一旦运行了整个定义 ONES 就被定义了
Having run the definition, now ones is defined.

314
00:19:40,670 --> 00:19:42,832
所以它的 TAIL 部分在此时是有定义的
So that when I go and look at the tail of it, it's defined.

315
00:19:44,920 --> 00:19:46,064
这一点非常隐讳
It's very sneaky.

316
00:19:46,590 --> 00:19:47,904
整数流的定义也是如此
And an integer is the same way.

317
00:19:48,470 --> 00:19:50,464
我可以在这里引用 INTEGERS 是因为
I can refer to integers here because

318
00:19:51,136 --> 00:19:53,210
是因为这个 CONS-STREAM 的缘故
hidden way down-- because of this cons-stream.

319
00:19:53,856 --> 00:19:57,050
用 CONS-STREAM 把 1 和一个不立即需要的东西组合起来
It's the cons-stream of 1 onto something that I don't worry that yet.

320
00:19:57,050 --> 00:19:59,600
所以我在运行 INTEGERS 的定义的时候
So I don't look at it, and I don't notice that integers isn't defined

321
00:20:00,224 --> 00:20:01,904
并不会发现 INTEGER 没有定义过
at the point where I try and run the definition.

322
00:20:06,320 --> 00:20:08,272
听上去非常玄乎
OK, let me draw a picture of that integers thing

323
00:20:08,448 --> 00:20:11,504
让我用图像来演示一下 INTEGERS 的原理
because it still maybe seems a little bit shaky.

324
00:20:12,430 --> 00:20:14,720
怎么画呢？
What do I do? Uh...

325
00:20:15,020 --> 00:20:16,304
首先是 ONES 这个流
I've got the stream of ones,

326
00:20:20,510 --> 00:20:21,888
它作为参数输入
and that sort of comes in

327
00:20:23,264 --> 00:20:26,590
进入一个加法器 进行流的加法运算
comes in and goes into an adder that's going to be this add streams thing.

328
00:20:29,310 --> 00:20:35,872
输出则是整数流 INTEGERS
And that goes in-- that's going to put out the integers.

329
00:20:40,760 --> 00:20:42,704
这里 还有一些东西进入加法器
And the other thing that goes into the adder here

330
00:20:44,944 --> 00:20:46,976
这个整数流形成了一个小型的反馈回路
is the integer, so there's a little feedback loop.

331
00:20:48,060 --> 00:20:49,424
我需要在某处接入最初的 ONES
And all I need to start it off

332
00:20:50,096 --> 00:20:52,880
才能让它生效
is someplace I've got a stick that initial 1.

333
00:20:57,100 --> 00:20:58,640
在真实的信号处理中
In a real signal processing thing,

334
00:20:58,720 --> 00:21:02,480
这里是一个被初始化为 1 的延时元件
this might be a delay element with that was initialized to 1.

335
00:21:02,910 --> 00:21:05,904
这里还有一份 ONES 程序的图示
But there's a picture of that ones program.

336
00:21:07,860 --> 00:21:09,632
事实上 这个非常像
And in fact, that looks a lot like--

337
00:21:09,808 --> 00:21:13,776
如果你见过真正的信号方块图的话
if you've seen real signal block diagram things,

338
00:21:13,776 --> 00:21:16,304
这个图形非常像积累器 #TBD
that looks a lot like accumulators,

339
00:21:16,352 --> 00:21:17,488
有穷状态积累器 #TBD
finite state accumulators.

340
00:21:17,980 --> 00:21:20,064
事实上 我们可以稍加修改
And in fact, we can modify this a little bit

341
00:21:21,184 --> 00:21:23,968
就可以让它对一个流做积分
to change this into something that integrates a stream

342
00:21:25,370 --> 00:21:26,976
或者说是有穷状态积累器 #TBD
or a finite state accumulator,

343
00:21:27,008 --> 00:21:28,040
你怎么认为都可以
however you like to think about it.

344
00:21:28,440 --> 00:21:30,864
现在 不再是输入 ONES 输出 INTEGERS
So instead of the ones coming in and getting out the integers,

345
00:21:31,680 --> 00:21:32,384
我们要做的是
what we'll do is

346
00:21:32,912 --> 00:21:34,832
这里有一个流 S 为输入
say there's a stream s coming in,

347
00:21:35,760 --> 00:21:40,560
我们要计算这个流的积分
and we're going to get out the integral of this.

348
00:21:42,600 --> 00:21:45,632
#TBD
successive values of that, and it looks almost the same.

349
00:21:45,660 --> 00:21:46,848
我们要做的就是
The only thing we're going to do is

350
00:21:47,024 --> 00:21:48,080
当 S 从这里输入时
when s comes in here,

351
00:21:49,216 --> 00:21:50,640
在把它求和之前
before we just add it in

352
00:21:50,912 --> 00:21:54,260
先将其乘以 dt
we're going to multiply it by some number dt.

353
00:21:57,680 --> 00:22:00,000
剩下的就不用改了
And now what we have here, this is exactly the same thing.

354
00:22:00,000 --> 00:22:00,912
我们就得到了一个盒子
We have a box,

355
00:22:03,360 --> 00:22:04,560
一个积分器
We have a box, which is an integrator.

356
00:22:09,790 --> 00:22:11,264
对一个流 S 进行积分
And it takes in a stream s,

357
00:22:11,904 --> 00:22:14,512
吧这里的 ONES 替换为
and instead of 1 here,

358
00:22:14,944 --> 00:22:18,352
该积分的初始值
we can put the additional value for the integral.

359
00:22:19,980 --> 00:22:24,864
这个看起来就非常像是信号处理中的方框图了
And that one looks very much like a signal processing block diagram program.

360
00:22:25,270 --> 00:22:28,112
事实上 这个图示对应的是这样一个过程
In fact, here's the procedure that looks exactly like that.

361
00:22:31,490 --> 00:22:33,616
对一个流进行积分
Find the integral of a stream.

362
00:22:34,010 --> 00:22:35,488
INTEGRAL 函数接收一个流
So an integral's going to take a stream

363
00:22:35,680 --> 00:22:36,864
返回一个新的流
Sand produce a new stream,

364
00:22:37,530 --> 00:22:40,672
它还接收一个初始值和某个时间常量
and it takes in an initial value and some time constant.

365
00:22:42,230 --> 00:22:42,976
然后呢？
And what do we do?

366
00:22:43,040 --> 00:22:45,056
首先在内部定义一个流 INT
Well, we internally define this thing int,

367
00:22:45,200 --> 00:22:46,320
之所以要给它一个内部名字
and we make this internal name

368
00:22:46,336 --> 00:22:48,860
原因在于可以使它反馈 以形成循环
so we can feed it back, loop it around itself.

369
00:22:49,400 --> 00:22:50,800
INT 的定义是
And int is defined to be

370
00:22:51,104 --> 00:22:53,328
一个以 INITIA-VALUE 开始的流
something that starts out at the initial value,

371
00:22:54,976 --> 00:23:00,144
而其余的元素则是把它们加起来
and the rest of it is gotten by adding together.

372
00:23:01,280 --> 00:23:03,616
我们把输入流乘以 dt
We take our input stream, scale it by dt,

373
00:23:03,872 --> 00:23:04,928
然后和INT相加
and add that to int.

374
00:23:06,880 --> 00:23:09,664
整个 INTEGRAL 函数的结果就是这个 INT
And now we'll return from all that the value of integral is this thing int.

375
00:23:10,690 --> 00:23:12,944
我们使用这种内部定义的语法
And we use this internal definition syntax so we could

376
00:23:13,344 --> 00:23:15,664
是为了可以在内部引用它自己
write a little internal definition that refers to itself.

377
00:23:21,880 --> 00:23:23,710
我们还可以做更多的事情
Well, there are all sorts of things we can do.

378
00:23:23,710 --> 00:23:24,512
来看这个
Let's try this one.

379
00:23:25,632 --> 00:23:26,890
斐波那契数
how about the Fibonacci numbers.

380
00:23:26,895 --> 00:23:32,625
(DEFINE FIBS
You can say define fibs.

381
00:23:36,350 --> 00:23:37,632
斐波那契数是什么呢？
Well, what are the Fibonacci numbers?

382
00:23:37,980 --> 00:23:46,544
它从 0 开始
They're something that starts out with 0,

383
00:23:48,656 --> 00:23:50,090
下一个是1
and the next one is 1.

384
00:23:56,260 --> 00:23:59,168
的其余的斐波那契数是通过
And the rest of the Fibonacci numbers are gotten by

385
00:23:59,872 --> 00:24:11,000
把它们的 TAIL 部分求和而得来
adding the Fibonacci numbers to their own tail.

386
00:24:17,570 --> 00:24:19,280
这样来定义斐波那契数
There's a definition of the Fibonacci numbers.

387
00:24:20,580 --> 00:24:21,430
这是如何运作的呢？
How does that work?

388
00:24:21,430 --> 00:24:24,192
我们来试试
Well, we start off,

389
00:24:24,208 --> 00:24:26,490
假如开始计算斐波那契数
and someone says compute for us the Fibonacci numbers,

390
00:24:29,648 --> 00:24:31,920
首先告诉你的是 它以 0 和 1 开始
and we're going to tell you it starts out with 0 and 1.

391
00:24:35,790 --> 00:24:38,224
而 0 和 1 之后的数则是
And everything after the 0 and 1

392
00:24:39,184 --> 00:24:40,864
通过加和两个流而得
is gotten by summing two streams.

393
00:24:41,120 --> 00:24:42,592
一个流是 FIBS 本身
One is the fibs themselves,

394
00:24:44,064 --> 00:24:45,696
另一个是 FIBS 的 TAIL 部分
and the other one is the tail of the fibs.

395
00:24:49,120 --> 00:24:51,168
如果我知道这是以 0 和 1 起始的
So if I know that these start out with 0 and 1,

396
00:24:51,790 --> 00:24:55,424
我就能知道 FIBS 是以 0 和 1 起始的
I know that the fibs now start out with 0 and 1,

397
00:24:55,744 --> 00:24:57,408
那么 FIBS 的 TAIL 则应该以1开始
and the tail of the fibs start out with 1.

398
00:24:58,360 --> 00:24:59,456
一旦我知道了这点
So as soon as I know that,

399
00:24:59,664 --> 00:25:02,112
我就知道 FIBS 的下一个数就是 0+1=1
I know that the next one here is 0 plus 1 is 1,

400
00:25:02,960 --> 00:25:04,608
它也同样告诉我这里是 1
and that tells me that the next one here is 1

401
00:25:04,624 --> 00:25:05,728
这里也是 1
and the next one here is 1.

402
00:25:06,300 --> 00:25:07,280
知道了这些之后
And as soon as I know that,

403
00:25:07,296 --> 00:25:08,760
我就知道下一个是 2
I know that the next one is 2.

404
00:25:09,390 --> 00:25:11,700
这里是2 这里也是2
So the next one here is 2 and the next one here is 2.

405
00:25:11,700 --> 00:25:12,560
下一个是3
And this is 3.

406
00:25:14,720 --> 00:25:15,792
这里就是3，这下面就是5了
This one goes to 3, and this is 5.

407
00:25:16,192 --> 00:25:17,136
这里就是3，这下面就是5了
This one goes to 3, and this is 5.

408
00:25:18,672 --> 00:25:19,968
这个定义完全说得通
So it's a perfectly sensible definition.

409
00:25:21,500 --> 00:25:22,784
这个定义只有一行
It's a one-line definition.

410
00:25:22,830 --> 00:25:25,008
当然 我也可以在计算机中
And again, I could walk over to the computer

411
00:25:25,008 --> 00:25:26,624
原原本本地键入计算机中
and type that in, exactly that,

412
00:25:27,040 --> 00:25:28,944
然后要求输出斐波那契数
and then say print stream the Fibonacci numbers,

413
00:25:28,944 --> 00:25:30,150
然后它就会不断输出
and they all come flying out.

414
00:25:32,790 --> 00:25:35,200
#TBD
See, this is a lot like learning about recursion again.

415
00:25:36,810 --> 00:25:39,792
过程可以被递归定义
Instead of thinking that recursive procedures,

416
00:25:40,992 --> 00:25:43,504
我们也有递归定义的数据对象
we have recursively defined data objects.

417
00:25:45,160 --> 00:25:46,928
但你们一点儿不应该感到吃惊
But that shouldn't surprise you at all,

418
00:25:47,120 --> 00:25:49,504
因为现在 你们应该真正相信
because by now, you should be coming to really believe

419
00:25:49,520 --> 00:25:53,056
过程与数据之间没有区别
that there's no difference really between procedures and data.

420
00:25:53,090 --> 00:25:53,920
事实上 就某种意义上来说
In fact, in some sense,

421
00:25:53,936 --> 00:25:56,416
流也是由过程来实现的
the underlying streams are procedures sitting there,

422
00:25:56,432 --> 00:25:57,790
只不过我们不把它看做过程而已
although we don't think of them that way.

423
00:25:58,210 --> 00:26:00,384
因此既然我们有递归过程
So the fact that we have recursive procedures,

424
00:26:00,704 --> 00:26:03,630
那么 有递归数据也就不足为奇了
well, then it should be natural that we have recursive data, too.

425
00:26:07,728 --> 00:26:09,696
虽然流非常简洁
OK, well, this is all pretty neat.

426
00:26:09,720 --> 00:26:13,920
但不幸的是 有些问题流无法解决
Unfortunately, there are problems that streams aren't going to solve.

427
00:26:14,990 --> 00:26:16,480
我来举个例子
Let me show you one of them.

428
00:26:17,580 --> 00:26:20,352
同样地 我们来想象一下
See, in the same way, let's imagine that we're

429
00:26:20,768 --> 00:26:23,616
我们正在构建求解微分方程的模拟计算机
building an analog computer to solve some differential equation

430
00:26:25,200 --> 00:26:34,304
比如求解方程 y' = y^2
like, say, we want to solve the equation y prime dy dt is y squared,

431
00:26:34,760 --> 00:26:36,160
我会给你一个初值
and I'm going to give you some initial value.

432
00:26:36,390 --> 00:26:38,030
y(0) = 1
I'll tell you y of 0 equals 1.

433
00:26:41,488 --> 00:26:44,064
dt = .0001
Let's say dt is equal to something.

434
00:26:46,770 --> 00:26:47,536
很久之前
Now, in the old days,

435
00:26:48,000 --> 00:26:50,650
就有人构建模拟计算机 来解决这类问题
people built analog computers to solve these kinds of things.

436
00:26:51,360 --> 00:26:53,020
原理非常简单
And the way you do that is really simple.

437
00:26:53,020 --> 00:26:54,416
你首先需要一个积分器
You get yourself an integrator,

438
00:27:00,048 --> 00:27:01,696
比如这个 INT 盒子
like that one, an integrator box.

439
00:27:03,050 --> 00:27:06,480
我们设定初始值 y(0) = 1
And we put in the initial value y of 0 is 1.

440
00:27:08,530 --> 00:27:10,928
现在如果我们送入一个输入 就会得到输出
And now if we feed something in and get something out,

441
00:27:10,960 --> 00:27:13,168
输出的结果就是y
we'll say, gee, what we're getting out is the answer.

442
00:27:14,256 --> 00:27:16,960
输入的是 y 的导数
And what we're going to feed in is the derivative,

443
00:27:17,520 --> 00:27:20,528
在这里 导数 y' = y^2
and the derivative is supposed to be the square of the answer.

444
00:27:21,490 --> 00:27:27,072
如果我们用 MAP 把 SQUARE 映射在这些值上
So if we take these values and map using square,

445
00:27:30,736 --> 00:27:32,096
然后把这个引过来
and if I feed this around,

446
00:27:36,280 --> 00:27:38,480
这个方块图
that's how I build a block diagram

447
00:27:38,576 --> 00:27:41,088
就是用于求解这个微分方程的模拟计算机
for an analog computer that solves this differential equation.

448
00:27:42,910 --> 00:27:46,784
现在我们用代码来表示下这个过程
Now, what we'd like to do is write a stream program that looks exactly like that.

449
00:27:47,230 --> 00:27:48,720
这个图究竟表示的是什么呢？
And what do I mean exactly like that?

450
00:27:49,390 --> 00:27:58,304
(DEFINE Y
Well, I'd say define y to be the integral

451
00:28:04,288 --> 00:28:11,680
(INTEGRAL DY 1 .001))
of dy starting at 1 with 0.001 as a time step.

452
00:28:13,790 --> 00:28:15,456
接下来
And I'd like to say that says this.

453
00:28:16,805 --> 00:28:20,850
来表示y' = y^2
And then I'd like to say, well, dy is gotten by mapping the square along y.

454
00:28:20,850 --> 00:28:32,816
(DEFINE DY (MAP SQUARE Y))
So define dy to be map square along y.

455
00:28:33,510 --> 00:28:36,800
这就是这个模拟计算机的流式描述
So there's a stream description of this analog computer,

456
00:28:38,624 --> 00:28:40,320
不幸的是 它并不起效
and unfortunately, it doesn't work.

457
00:28:41,410 --> 00:28:42,672
你也可以发现这是为什么
And you can see why it doesn't work

458
00:28:42,976 --> 00:28:47,856
因为我把 Y 定义为 DY 的积分
because when I come in and say define y to be the integral of dy

459
00:28:49,040 --> 00:28:50,656
它会问 对什么的积分？
it says, oh, the integral of what-- huh?

460
00:28:51,190 --> 00:28:52,128
没定义啊
Oh, that's undefined.

461
00:28:53,710 --> 00:28:57,632
所以这个定义必须写在这个定义的后面
So I can't write this definition before I've written this one.

462
00:28:58,770 --> 00:29:00,512
另一方面 如果先定义了 dy
On the other hand, if I try and write this one first,

463
00:29:00,512 --> 00:29:03,024
定义为 (MAP SQUARE 某个东西)
it says, oh, I define y to be the map of square along what?

464
00:29:03,580 --> 00:29:04,640
这个也还没有定义
Oh, that's not defined yet.

465
00:29:05,770 --> 00:29:08,176
我既不能先写这个 又不能先写那个
So I can't write this one first, and I can't write that one first.

466
00:29:09,088 --> 00:29:11,580
所以我不能这样来玩这个游戏#TBD
So I can't quite play this game.

467
00:29:17,560 --> 00:29:18,512
怎样来解决呢？
Well, is there a way out?

468
00:29:20,608 --> 00:29:21,840
我们可以用 ONES 来解决
See, we can do that with ones.

469
00:29:22,200 --> 00:29:25,824
所以 我们在这里定义的 ONES
See, over here, we did this thing ones,

470
00:29:27,248 --> 00:29:29,904
我们之所以可以使用 ONES 来定义 ONES
and we were able to define ones in terms of ones because

471
00:29:30,400 --> 00:29:32,032
这是因为其中的延时求值
of this delay that was built inside

472
00:29:32,432 --> 00:29:34,128
CONS-STREAM 是延时求值的
because cons-stream had a delay.

473
00:29:34,770 --> 00:29:35,792
那么 这又为什么说得通呢？
Now, why's it sensible?

474
00:29:35,920 --> 00:29:38,512
#TBD
Why's it sensible for cons-stream to be built with this delay?

475
00:29:40,730 --> 00:29:43,136
原因在于 CONS-STREAM 不需要其 TAIL 部分
The reason is that cons-stream can do a useful thing

476
00:29:43,488 --> 00:29:44,880
就可以完成有意义的事
without looking at its tail.

477
00:29:45,950 --> 00:29:46,848
比如我说
See, if I say

478
00:29:47,488 --> 00:29:49,648
这个是 1 和某个东西组成的流
this is cons-stream of 1 onto something

479
00:29:49,920 --> 00:29:51,696
虽然我对它一无所知
without knowing anything about something,

480
00:29:52,160 --> 00:29:54,032
但我却知道整个流是以 1 开始的
I know that the stream starts off with 1.

481
00:29:54,870 --> 00:29:57,296
所以用 CONS-STREAM 来构造是有意义的
That's why it was sensible to build something like cons-stream.

482
00:29:59,960 --> 00:30:01,248
我们在这里放了一个 DELAY
So we put a delay in there,

483
00:30:01,424 --> 00:30:04,656
这就使得我们能够进行某种自引用的定义
and that allows us to have this sort of self-referential definition.

484
00:30:06,320 --> 00:30:07,952
INTEGRAL 也可以用这种方式来解决
Well, integral is a little bit the same way.

485
00:30:08,190 --> 00:30:12,528
注意 对于 INTEGRAL 来说  我可以
See, notice for an integral, I can--

486
00:30:14,608 --> 00:30:16,080
让我们回过头来再看看 INTEGRAL 的定义
let's go back and look at integral for a second.

487
00:30:17,580 --> 00:30:18,560
求积分的时候
See, notice integral,

488
00:30:21,392 --> 00:30:25,008
我们能够知道 INTEGRAL 中第一个元素是什么
it makes sense to say what's the first thing in the integral

489
00:30:26,048 --> 00:30:27,872
尽管还不知道整个流是什么样的
without knowing the stream that you're integrating.

490
00:30:28,970 --> 00:30:30,176
这是因为 INTEGRAL 中第一个元素
Because the first thing in the integral

491
00:30:30,200 --> 00:30:32,160
总会是你传递过来的 INITIAL-VALUE
is always going to be the initial value that you're handed.

492
00:30:33,140 --> 00:30:36,112
所以 INTEGRAL 可以用 CONS-STREAM 来实现
So integral could be a procedure like cons-stream.

493
00:30:37,090 --> 00:30:37,984
我们可以定义它
You could define it,

494
00:30:38,256 --> 00:30:40,880
甚至不用知道要积分的流是什么
and then even before it knows what it's supposed to be integrating,

495
00:30:42,848 --> 00:30:45,184
只需要知道初始值是什么就行了
it knows enough to say what its initial value is.

496
00:30:46,710 --> 00:30:48,176
INTEGRAL 还可以修改得更为智能
So we can make a smarter integral,

497
00:30:48,416 --> 00:30:50,688
我们给它一个待积分的流
which is aha, you're going to give me a stream to integrate

498
00:30:50,832 --> 00:30:51,920
以及一个初值
and an initial value,

499
00:30:52,112 --> 00:30:54,992
直到你要求我沿着这个流求解积分时
but I really don't have to look at that stream that I'm supposed to integrate

500
00:30:55,216 --> 00:30:56,976
我才关机这个流是什么
until you ask me to work down the stream.

501
00:30:58,430 --> 00:31:00,512
换句话说 INTEGRAL 可以像 CONS-STREAM 一样
In other words, integral can be like cons-stream,

502
00:31:00,570 --> 00:31:03,744
你可以认为 INTEGRAL 被放在 DELAY 之中
and you can expect that there's going to be a delay around its integrand.

503
00:31:03,760 --> 00:31:04,864
我们这样修改
And we can write that.

504
00:31:05,610 --> 00:31:07,024
这个过程是像这样的
Here's a procedure that does that.

505
00:31:07,650 --> 00:31:08,752
这是另一个版本的 INTEGRAL
Another version of integral,

506
00:31:08,896 --> 00:31:10,544
这个跟之前的版本非常相似
and this is almost like the previous one,

507
00:31:11,104 --> 00:31:13,344
只不过作为参数的流
except the stream it's going to get in

508
00:31:13,776 --> 00:31:15,696
必须要是一个延时对象
is going to expect to be a delayed object.

509
00:31:17,110 --> 00:31:18,432
这个 INTEGRAL 又是如何运作的呢？
And how does this integral work?

510
00:31:18,850 --> 00:31:21,792
我们在内部定义的 INT 则是
Well, the little thing it's going to define inside of itself

511
00:31:22,144 --> 00:31:24,192
用 CONS-STREAM 构造一个流
says on the cons-stream,

512
00:31:24,736 --> 00:31:26,448
初值还是 INITIAL-VALUE
the initial value is the initial value,

513
00:31:27,160 --> 00:31:29,680
但是在 CONS-STREAM 中
but only inside of that cons-stream,

514
00:31:29,744 --> 00:31:32,300
要注意 这里面有个隐藏的 DELAY
and remember, there's going to be a hidden delay inside here.

515
00:31:34,950 --> 00:31:39,072
只有在这个 CONS-STREAM 的内部
Only inside of that cons-stream will I start looking at

516
00:31:39,824 --> 00:31:42,110
我才会查看延时对象的实际内容
what the actual delayed object is.

517
00:31:43,180 --> 00:31:45,792
所以 第一个元素将会是初值
So my answer is the first thing's the initial value.

518
00:31:45,970 --> 00:31:47,904
如果有人想访问我的 TAIL 部分
If anybody now asks me for my tail,

519
00:31:48,400 --> 00:31:49,424
此时
at that point,

520
00:31:50,000 --> 00:31:51,728
我会 FORCE 该延迟对象
I'm going to force that delayed object--

521
00:31:52,624 --> 00:31:53,600
把结果记作 S
and I'll call that s--

522
00:31:54,448 --> 00:31:55,600
然后再进行 ADD-STREAMS
and I do the add streams.

523
00:31:56,368 --> 00:31:59,260
这个 INTEGRAL 就有点像 CONS-STREAM
So this is an integral which is sort of like cons-stream.

524
00:31:59,260 --> 00:32:02,592
#TBD
It's not going to actually try and see what you handed it

525
00:32:03,888 --> 00:32:07,136
#TBD
as the thing to integrate until you look past the first element.

526
00:32:10,120 --> 00:32:11,024
如果这样的话
And if we do that

527
00:32:11,520 --> 00:32:12,832
也就能求解 y' = y^2 了
and we can make this work,

528
00:32:13,360 --> 00:32:15,200
这里我们只需要
all we have to do here is

529
00:32:16,000 --> 00:32:25,312
我们只需要把 DY 变成一个延时对象
define y to the integral of delay of y, of delay of dy.

530
00:32:27,090 --> 00:32:28,224
所以 Y 的定义就变成了
So y is going to be

531
00:32:28,400 --> 00:32:34,368
(INTEGRAL (DELAY DY) 1 .001)
the integral of delay of dy starting at 1,

532
00:32:34,384 --> 00:32:35,130
这样一来就可以了
and now this will work.

533
00:32:35,280 --> 00:32:37,440
因为我输入 Y 的定义
Because I type in the definition of y,

534
00:32:38,000 --> 00:32:39,680
它是某个东西的积分
and that says, oh, I'm supposed to use the integral of

535
00:32:40,208 --> 00:32:42,688
但这是个延迟对象 我现在还不用关心
something I don't care about right now because it's a delay.

536
00:32:44,600 --> 00:32:46,320
这之后 再定义 DY
And these things, now you define dy.

537
00:32:46,320 --> 00:32:47,376
现在 Y 就有定义了
Now, y is defined.

538
00:32:47,550 --> 00:32:48,896
所以我在定义 DY 时
So when I define dy,

539
00:32:49,136 --> 00:32:50,672
它可以知道 Y 的定义
it can see that definition for y.

540
00:32:51,700 --> 00:32:52,840
一切都正常了
Everything is now started up.

541
00:32:52,840 --> 00:32:54,336
两个流都有第一个元素
Both streams have their first element.

542
00:32:54,920 --> 00:32:56,256
当我不断取得下一个元素
And then when I start mapping down,

543
00:32:56,272 --> 00:32:57,312
沿着流做 MAP 运算时
looking at successive elements,

544
00:32:57,376 --> 00:32:58,880
Y 和 DY 都被定义过了
both y and dy are defined.

545
00:33:00,590 --> 00:33:04,240
#TBD
So there's a little game you can play that goes a little bit beyond

546
00:33:04,670 --> 00:33:07,136
而不只是使用隐藏在流中的隐藏 DELAY
just using the delay that's hidden inside streams.

547
00:33:08,368 --> 00:33:08,976
有问题么？
Questions?

548
00:33:13,520 --> 00:33:14,272
没有的话，休息一下吧
OK, let's take a break.

549
00:34:07,300 --> 00:34:10,048
在上一节课中
Well, just before the break, um..

550
00:34:10,896 --> 00:34:13,552
我不知道你们是否注意到事情正变得糟糕起来
I'm not sure if you noticed it, but something nasty started to happen.

551
00:34:14,832 --> 00:34:18,400
我们讲了很多关于 流
We've been going along with the streams

552
00:34:19,168 --> 00:34:22,688
以及分离程序中的时间和计算机中的时间
and divorcing time in the programs from time in the computers,

553
00:34:22,864 --> 00:34:26,288
这些分离都被隐藏在流中了
and all that divorcing got hidden inside the streams.

554
00:34:27,280 --> 00:34:29,504
上节课快结束时我们发现
And then at the very end, we saw that sometimes

555
00:34:29,710 --> 00:34:32,192
为了真正发挥这种方法的优势
in order to really take advantage of this method,

556
00:34:32,224 --> 00:34:34,380
我们需要另外的 DELAY
you have to pull out other delays.

557
00:34:34,380 --> 00:34:35,856
不只需要隐藏在 CONS-STREAM 中的 DELAY
You have to write some explicit delays

558
00:34:36,096 --> 00:34:37,950
还需要显式地使用 DELAY
that are not hidden inside that cons-stream.

559
00:34:39,030 --> 00:34:41,888
我只是用微分方程举了一个很简单的例子
And I did a very simple example with differential equations,

560
00:34:42,350 --> 00:34:44,080
但是如果你有一个非常复杂的系统
but if you have some very complicated system

561
00:34:44,128 --> 00:34:45,408
里面充斥着各种各样的自循环
with all kinds of self-loops,

562
00:34:45,950 --> 00:34:47,840
那就很难再发现
it becomes very, very difficult to

563
00:34:47,904 --> 00:34:49,310
在什么地方需要额外的 DELAY 了
see where you need those delays.

564
00:34:49,920 --> 00:34:51,184
假如你一不小心漏了一个
And if you leave them out by mistake,

565
00:34:51,456 --> 00:34:54,368
就很难发现程序为什么不起效
it becomes very, very difficult to see why the thing maybe isn't working.

566
00:34:55,550 --> 00:34:57,152
这是一种混乱
So that's kind of mess,

567
00:34:57,792 --> 00:35:01,712
让我们能够使用 DELAY
that by getting this power and allowing us to use delay,

568
00:35:02,080 --> 00:35:04,704
有时却会让程序设计变得非常复杂
we end up with some very complicated programming sometimes,

569
00:35:04,720 --> 00:35:06,800
因为它们不能完全隐藏在流中
because it can't all be hidden inside the streams.

570
00:35:08,512 --> 00:35:09,792
那么 有没有什么解决方案呢？
Well, is there a way out of that?

571
00:35:11,136 --> 00:35:12,672
所幸的是 有
Yeah, there is a way out of that.

572
00:35:13,480 --> 00:35:16,080
我们可以修改整个语言
We could change the language so that

573
00:35:16,144 --> 00:35:18,192
使得所有的过程都表现得像 CONS-STREAM 一样
all procedures acted like cons-stream,

574
00:35:19,104 --> 00:35:21,488
这样所有的过程都会
so that every procedure automatically

575
00:35:22,320 --> 00:35:25,450
自动地隐式地为它的参数加上 DELAY
has an implicit delay around its arguments.

576
00:35:25,450 --> 00:35:26,432
这是什么意思呢？
And what would that mean?

577
00:35:27,520 --> 00:35:29,536
就是说 当你调用一个过程时
That would mean when you call a procedure,

578
00:35:30,160 --> 00:35:31,888
参数并不会立即求值
the arguments wouldn't get evaluated.

579
00:35:32,210 --> 00:35:34,704
只有在需要被求值的时候 它们才会被求值
Instead, they'd only be evaluated when you need them,

580
00:35:34,896 --> 00:35:36,720
它们也可能被传递给其它的过程
so they might be passed off to some other procedure,

581
00:35:36,768 --> 00:35:38,128
而这个过程也不会求值这些参数
which wouldn't evaluate them either.

582
00:35:39,260 --> 00:35:41,904
因此这些过程间传递的是 PROMISE
So all these procedures would be passing promises around.

583
00:35:42,150 --> 00:35:44,464
直到最后
And then finally maybe when you finally got down

584
00:35:44,656 --> 00:35:47,344
你需要查看某个值的时候
to having to look at the value of something

585
00:35:47,360 --> 00:35:48,992
可能是因为一个基本运算所需要
that was handed to a primitive operator

586
00:35:49,376 --> 00:35:51,488
这是你才实际求值这些 PROMISE
which you actually start calling in all those promises.

587
00:35:52,380 --> 00:35:53,168
像这样修改语言之后
If we did that,

588
00:35:53,360 --> 00:35:55,376
由于所有的东西都是统一被延时的
since everything would have a uniform delay,

589
00:35:57,168 --> 00:35:59,008
我们就不需要写任何显式的 DELAY 了
then you wouldn't have to write any explicit delays,

590
00:35:59,040 --> 00:36:01,552
因为它自动地内建在语言之中了
because it would be automatically built into the way the language works.

591
00:36:03,248 --> 00:36:04,384
换句话来说
Or another way to say that,

592
00:36:05,100 --> 00:36:08,144
从技术上来说 我所描述的
technically what I'm describing is what's called

593
00:36:09,024 --> 00:36:10,768
如果修改后的语言被称作
if we did that, our language would be

594
00:36:12,192 --> 00:36:16,576
所谓的“正则序求值”语言
so-called normal-order evaluation language

595
00:36:20,208 --> 00:36:23,470
这个跟我们一直使用的语言不同
versus what we've actually been working with,

596
00:36:23,872 --> 00:36:33,792
我们所用的是“应用序求值”语言
which is called applicative order--  versus applicative-order evaluation.

597
00:36:34,560 --> 00:36:36,835
还记得应用序求值的代换模型吧
And remember the substitution model for applicative order.

598
00:36:36,830 --> 00:36:40,496
当你求值一个组合式的时候
It says when you go and evaluate a combination,

599
00:36:40,512 --> 00:36:42,112
你需要先计算出每一个元素的值
you find the values of all the pieces.

600
00:36:43,590 --> 00:36:45,408
先求值所有的参数
You evaluate the arguments and then you

601
00:36:45,720 --> 00:36:47,424
再把它们代换入过程的体
substitute them in the body of the procedure.

602
00:36:47,600 --> 00:36:49,552
正则序则不是这样
Normal order says no, don't do that.

603
00:36:49,890 --> 00:36:51,904
你所做的则是
What you do is effectively

604
00:36:52,768 --> 00:36:54,416
直接将参数代换入过程的体
substitute in the body of the procedure,

605
00:36:54,448 --> 00:36:56,192
而不先对参数求值
but instead of evaluating the arguments,

606
00:36:56,544 --> 00:36:58,080
只是代换入了一个计算参数的 PROMISE
you just put a promise to compute them there.

607
00:36:58,816 --> 00:36:59,904
换句话说就是
Or another way to say that

608
00:36:59,920 --> 00:37:02,096
把作为参数的整个表达式
you take the expressions for the arguments, if you like,

609
00:37:02,288 --> 00:37:04,848
直接代入过程的体进行代换
and substitute them in the body of the procedure and go on,

610
00:37:05,168 --> 00:37:06,880
在此之间从不进行任何化简
and never really simplify anything

611
00:37:07,168 --> 00:37:08,768
直到遇到一个基本运算符
until you get down to a primitive operator.

612
00:37:09,472 --> 00:37:10,992
这就是所谓的正则序求值语言
So that would be a normal-order language.

613
00:37:12,176 --> 00:37:13,120
为什么不这样做呢？ #TBD
Well, why don't we do that?

614
00:37:13,824 --> 00:37:14,608
这样做了之后
Because if we did,

615
00:37:15,008 --> 00:37:17,344
我们就获得了延时求值的所有优点
we'd get all the advantages of delayed evaluation

616
00:37:17,904 --> 00:37:18,800
而不会一片混乱
with none of the mess.

617
00:37:18,940 --> 00:37:20,192
事实上 如果我们这样做了之后
In fact, if we did that

618
00:37:20,432 --> 00:37:22,672
CONS 也会是延时求值的
and cons was just a delayed procedure,

619
00:37:22,688 --> 00:37:24,570
就和 CONS-STREAM 一样
that would make cons the same as cons-stream.

620
00:37:24,710 --> 00:37:25,824
我们就不再需要流了
We wouldn't need streams at all

621
00:37:26,368 --> 00:37:28,544
因为表自动成为了流
because lists would automatically be streams.

622
00:37:29,552 --> 00:37:30,704
表和流有一样的行为
That's how lists would behave,

623
00:37:30,752 --> 00:37:32,350
所有的数据结构也会像那样
all data structures would behave that way.

624
00:37:32,350 --> 00:37:33,648
所有的都是
Everything would behave that way.

625
00:37:35,070 --> 00:37:37,632
直到需要答案的时候
Right, You'd never really do any computation

626
00:37:37,664 --> 00:37:39,424
才会去实际的求值
until you actually needed the answer.

627
00:37:40,800 --> 00:37:43,584
也需要担心什么时候需要显式地标注 DELAY
You wouldn't have to worry about all these explicit annoying delays.

628
00:37:44,790 --> 00:37:46,160
为什么不这样做呢？
Well, why don't we do that?

629
00:37:47,160 --> 00:37:48,816
首先 已经有人这样做过了
First of all, I should say people do do that.

630
00:37:49,230 --> 00:37:51,850
这是一门十分优雅的语言
There's some very beautiful languages.

631
00:37:51,850 --> 00:37:55,216
其中最为人称道的是一门名为 Miranda 的语言
One of the very nicest is a language called Miranda,

632
00:37:55,776 --> 00:37:56,768
它是由
which is, um..

633
00:37:57,440 --> 00:37:59,808
肯特大学的 David Turner 开发的
developed by David Turner at the University of Kent.

634
00:38:00,710 --> 00:38:01,930
它就是用这样的原理实现的
And that's how this language works.

635
00:38:01,930 --> 00:38:03,344
Miranda 是正则序求值语言
It's a normal-order language

636
00:38:04,272 --> 00:38:05,552
它的数据结构
and its data structures,

637
00:38:06,160 --> 00:38:08,416
看起来像表 实际上确实流
which look like lists, are actually streams.

638
00:38:08,960 --> 00:38:10,912
你不需要任何特殊的功能
And you write ordinary procedures in Miranda,

639
00:38:11,280 --> 00:38:13,280
就可以在 Miranda 中编写普通的过程
and they do these prime things and eight queens things,

640
00:38:13,328 --> 00:38:14,970
来解决质数、八皇后这样的问题
just without anything special.

641
00:38:14,970 --> 00:38:16,352
这些都是语言的内建功能
It's all built in there.

642
00:38:17,936 --> 00:38:18,912
但这样做也要付出代价
But there's a price.

643
00:38:21,190 --> 00:38:22,368
还记得我们为什么引入流了吗 #TBD
Remember how we got here.

644
00:38:23,170 --> 00:38:27,480
我们解耦了程序的时间和它实际执行的时间
We're decoupling time in the programs from time in the machines.

645
00:38:27,968 --> 00:38:28,880
如果我们引入了 DELAY
And if we put delay,

646
00:38:29,040 --> 00:38:30,336
这样就在所有的地方完成了解耦
that sort of decouples it everywhere,

647
00:38:30,400 --> 00:38:31,424
而不单单是在流中
not just in streams.

648
00:38:32,192 --> 00:38:33,140
#TBD
Remember what we're trying to do.

649
00:38:33,140 --> 00:38:38,112
#TBD
We're trying to think about programming as a way to specify processes.

650
00:38:39,300 --> 00:38:40,624
如果我们放弃了对时间的控制
And if we give up too much time,

651
00:38:40,656 --> 00:38:42,416
尽管语言变得优雅起来
our language becomes more elegant,

652
00:38:43,744 --> 00:38:45,872
但是它的表达力却有所下降
but it becomes a little bit less expressive.

653
00:38:47,030 --> 00:38:49,840
并且还有一些致命的缺陷 #TBD
There are certain distinctions that we can't draw.

654
00:38:51,480 --> 00:38:53,152
其中之一就是迭代
One of them, for instance, is iteration.

655
00:38:53,980 --> 00:38:56,448
还记得这个程序吗？
Remember this old procedure,

656
00:38:56,960 --> 00:38:58,288
迭代式的阶乘
iterative factorial,

657
00:38:58,448 --> 00:39:00,480
这是我们很早之前就研究过的
that we looked at quite a long time ago.

658
00:39:01,230 --> 00:39:02,976
过程 FACT-ITER
Iterative factorial had a thing,

659
00:39:03,040 --> 00:39:04,912
有一个内部过程 ITER
and it said there was an internal procedure,

660
00:39:05,184 --> 00:39:07,504
它含有两个状态 PRODUCT 和 COUNTER
and there was a state which was a product and a counter,

661
00:39:08,704 --> 00:39:10,960
它们随着循环不断迭代
and we iterate that going around the loop.

662
00:39:12,120 --> 00:39:13,680
之所以说这个过程是迭代的
And we said that was an iterative procedure

663
00:39:13,712 --> 00:39:14,832
是因为它没有创建新状态
because it didn't build up state.

664
00:39:15,730 --> 00:39:17,456
之所以没有创建新状态
And the reason it didn't build up state is

665
00:39:17,472 --> 00:39:20,256
是因为在调用 ITER 时
because this iter that's called

666
00:39:20,304 --> 00:39:22,864
作为参数传递的始终是这些东西（位置）
is just passing these things around to itself.

667
00:39:23,900 --> 00:39:25,392
在代换模型中
Or in the substitution model that,

668
00:39:25,552 --> 00:39:27,792
Jerry 教授给你们讲解过
you could see in the substitution model that Jerry did,

669
00:39:28,720 --> 00:39:30,016
在迭代过程中
that in an iterative procedure,

670
00:39:30,032 --> 00:39:31,440
状态并不需要增长
that state doesn't have to grow.

671
00:39:31,824 --> 00:39:34,224
因此这是一个迭代过程
And in fact, we said it doesn't, so this is an iteration.

672
00:39:34,992 --> 00:39:37,472
但是如果用正则序语言
But now think about this exact same text

673
00:39:37,472 --> 00:39:39,104
来运行这段程序
if we had a normal-order language.

674
00:39:41,150 --> 00:39:42,176
这就会导致
What would happen is

675
00:39:42,880 --> 00:39:44,960
这个过程不再是迭代式了
this would no longer be an iterative procedure

676
00:39:45,650 --> 00:39:48,672
如果你仔细地思考代换模型
And if you really think about the details of the substitution model,

677
00:39:48,672 --> 00:39:49,904
在这里我就不细说了
which I'm not going to do here,

678
00:39:51,200 --> 00:39:52,352
这个表达式会不断增长
this expression would grow.

679
00:39:52,368 --> 00:39:53,184
为什么会这样？
Why would it grow?

680
00:39:53,280 --> 00:39:55,200
因为当 ITER 调用自己时
It's because when iter calls itself,

681
00:39:55,856 --> 00:39:57,312
参数是这个乘法表达式
it calls itself with this product.

682
00:39:58,080 --> 00:39:59,360
而在正则序语言中
If it's a normal-order language,

683
00:39:59,392 --> 00:40:01,168
这个乘法并不会在这里求值
that multiplication is not going to get done.

684
00:40:02,510 --> 00:40:05,680
传递并代换的只是这个乘法计算的 PROMISE
That's going to say I'm to call myself with a promise to compute this product.

685
00:40:06,670 --> 00:40:08,032
然后继续代换下去
And now iter goes around again.

686
00:40:09,760 --> 00:40:11,552
我调用自己
And I'm going to call myself

687
00:40:11,840 --> 00:40:14,048
用的是计算这个乘式的 PROMISE
with a promise to compute this product

688
00:40:14,048 --> 00:40:17,820
但其中的一个因数也是个 PROMISE
where now one of the one factors is a promise.

689
00:40:18,400 --> 00:40:19,430
然后我又自调用
And I call myself again.

690
00:40:19,430 --> 00:40:21,136
如果你用代换模型
And if you write out the substitution model

691
00:40:21,984 --> 00:40:23,600
来推演这个迭代步骤
for that iterative process,

692
00:40:23,776 --> 00:40:26,832
你会发现同样的状态增长
you'll see exactly the same growth in state,

693
00:40:27,160 --> 00:40:28,960
所有的 PROMISE 都需要被记住
all those promises that are getting remembered

694
00:40:28,976 --> 00:40:30,760
以便在最后被调用
that have to get called in at the very end.

695
00:40:31,790 --> 00:40:35,024
所以 正则序的缺点之一
So one of the disadvantages

696
00:40:35,056 --> 00:40:36,864
就是无法有效地表达迭代
is that you can't really express iteration.

697
00:40:36,980 --> 00:40:39,600
也许这个理由有点偏理论
Maybe that's a little theoretical reason why not,

698
00:40:39,616 --> 00:40:43,904
但事实上 那些使用这类语言来编写
but in fact, people who are trying to write real operating systems

699
00:40:44,272 --> 00:40:47,568
实际操作系统的人 也都遇到了这类问题
in these languages are running into exactly these types of problems.

700
00:40:48,208 --> 00:40:50,752
当然 完全可以
Like it's perfectly possible to

701
00:40:51,648 --> 00:40:54,384
用这类语言实现一个文本编辑器
implement a text editor in languages like these.

702
00:40:54,610 --> 00:40:56,080
但是你才用了一会儿
But after you work a while,

703
00:40:56,720 --> 00:40:59,392
就发现已经占用了 3MB 空间
you suddenly have 3 megabytes of stuff,

704
00:40:59,440 --> 00:41:02,048
我想 那些遇到这类问题的人
which is-- I guess they call them

705
00:41:02,160 --> 00:41:05,600
把它叫做 “拖尾问题”
the dragging tail problem who are looking at these,

706
00:41:05,824 --> 00:41:08,208
#TBD
of stuff of promises that sort of haven't been called in

707
00:41:08,240 --> 00:41:10,464
#TBD
because you couldn't quite express an iteration.

708
00:41:10,720 --> 00:41:14,816
针对这种语言的一个研究方向就是
And one of the research questions in these kinds of languages

709
00:41:14,832 --> 00:41:17,488
找出一种有效的编译器技术
are figuring out the right compiler technology

710
00:41:17,824 --> 00:41:19,856
来避免这种所谓的“拖尾问题”
to get rid of the so-called dragging tails.

711
00:41:20,176 --> 00:41:21,616
这并不简单
It's not simple.

712
00:41:23,940 --> 00:41:27,312
但是 还有一个很突出的问题
But there's another kind of more striking issue

713
00:41:27,968 --> 00:41:31,040
使你不能让你的语言使用正则序
about why you just don't go ahead and make your language normal order.

714
00:41:32,512 --> 00:41:33,296
原因就是
And the reason is

715
00:41:35,056 --> 00:41:38,096
正则序和副作用
that normal-order evaluation and side effects

716
00:41:38,896 --> 00:41:40,192
是不相容的
just don't mix.

717
00:41:42,000 --> 00:41:43,968
它们不能很好地相互配合
They just don't go together very well.

718
00:41:45,440 --> 00:41:46,656
这是因为 你不能
Somehow, you can't-

719
00:41:48,288 --> 00:41:50,800
你不能一边
it's sort of you can't simultaneously

720
00:41:51,008 --> 00:41:54,336
建模具有局部状态的对象
go around trying to model objects with local state and change

721
00:41:55,728 --> 00:41:56,960
同时又
at the same time

722
00:41:57,184 --> 00:41:59,552
使用正则序的技巧来解耦时间
do these normal-order tricks of de-coupling time.

723
00:42:00,400 --> 00:42:03,552
我来举一个非常简单的例子
Let me just show you a really simple example, very, very simple.

724
00:42:03,790 --> 00:42:05,504
假设语言是正则序求值
Suppose we had a normal-order language.

725
00:42:07,520 --> 00:42:09,550
例子是这样的
And I'm going to start out in this language.

726
00:42:09,550 --> 00:42:10,520
注意现在是正则序求值
This is now normal order.

727
00:42:10,520 --> 00:42:12,224
(DEFINE X 0)
I'm going to define x to be 0.

728
00:42:13,570 --> 00:42:15,568
这只是变量的初始化
It's just some variable I'll initialize.

729
00:42:15,750 --> 00:42:17,696
现在我要定义一个有趣的函数
And now I'm going to define this little funny function,

730
00:42:18,576 --> 00:42:20,448
它就是恒等函数
which is an identity function.

731
00:42:22,640 --> 00:42:23,904
它所做的就是
And what it does,

732
00:42:24,112 --> 00:42:26,608
用 X 来记录上一次调用它时 N 的值
it keeps track of the last time you called it using x.

733
00:42:31,400 --> 00:42:34,160
因此 (ID N) 就返回 N
Right? So the identity of n just returns n,

734
00:42:34,176 --> 00:42:35,390
但还要把 X 赋值为 N
but it sets x to be n.

735
00:42:36,760 --> 00:42:38,544
最后再定义一个过程 INC
And now I'll define a little increment function,

736
00:42:39,552 --> 00:42:42,304
也非常简单
which is a very little, simple scenario.

737
00:42:42,580 --> 00:42:45,344
假设在正则序求值的语言里
Now, imagine I'm interacting with this in the normal-order language,

738
00:42:46,272 --> 00:42:47,230
求值下面的表达式
and I type the following.

739
00:42:47,230 --> 00:42:52,832
我输入 (DEFINE Y (INC (ID 3)))
I say define y to be increment the identity function of 3,

740
00:42:52,832 --> 00:42:53,968
因此 Y 的值应该是 4
so y is going to be 4.

741
00:42:57,410 --> 00:42:58,352
X 应该是多少呢？
Now, I say what's x?

742
00:42:59,520 --> 00:43:02,160
X 应该是最后一次被记住的值
Well, x should have been the value that was remembered last

743
00:43:02,640 --> 00:43:04,016
也就是我调用 ID 函数的时候
when I called the identity function.

744
00:43:04,710 --> 00:43:06,736
你可能会想 这里 X 应该是 3
So you'd expect to say, well, x is 3 at this point,

745
00:43:06,912 --> 00:43:07,520
但是并不是这样
but it's not.

746
00:43:08,530 --> 00:43:11,152
这是因为当我在这里定义 Y 的时候
Because when I defined here, y here,

747
00:43:11,792 --> 00:43:13,456
Y 的真正定义却是
what I really defined y to be

748
00:43:13,472 --> 00:43:15,712
一个调用 ID 函数的 PROMISE 的增量
increment of a promise to do this thing.

749
00:43:17,000 --> 00:43:18,176
因为我没有访问 Y
So I didn't look at y,

750
00:43:18,368 --> 00:43:20,256
所以增量函数没有运行
so that identity function didn't get run.

751
00:43:21,560 --> 00:43:23,200
我输入这个定义之后
So if I type in this definition

752
00:43:23,312 --> 00:43:24,800
然后查询 X 得到的结果是 0
and look at x, I'm going to get 0.

753
00:43:28,360 --> 00:43:31,200
现在 我输入 Y 查询它的值
Now, if I go look at y and say what's y,

754
00:43:31,520 --> 00:43:32,432
就会得到结果 4
say y is 4,

755
00:43:32,670 --> 00:43:35,168
对 Y 的主动查询
looking at y, that very active looking at y

756
00:43:35,296 --> 00:43:37,424
会导致恒等函数运行
caused the identity function to be run.

757
00:43:38,720 --> 00:43:40,480
现在 X=3 就被记住
And now x will get remembered as 3.

758
00:43:40,740 --> 00:43:41,872
所以上面这里的 X 就应该是 0
So here x will be 0.

759
00:43:41,936 --> 00:43:42,960
下面这里是 3
Here, x will be 3.

760
00:43:43,280 --> 00:43:46,160
这是一个非常简单的场景
That's a tiny, little, simple scenario,

761
00:43:46,304 --> 00:43:49,280
但你会发现 对于正则序的语言
but you can see what kind of a mess that's going to make

762
00:43:50,368 --> 00:43:53,344
调试交互式的程序
for debugging interactive programs

763
00:43:54,128 --> 00:43:55,888
会变得相当混乱
when you have normal-order evaluation.

764
00:43:57,100 --> 00:43:58,128
很令人迷惑
It's very confusing.

765
00:43:59,690 --> 00:44:02,048
导致这样的深层次的原因
But it's very confusing for a very deep reason,

766
00:44:02,800 --> 00:44:06,416
也就是引入 DELAY 的根本理念
which is that the whole idea of putting in delays

767
00:44:06,928 --> 00:44:08,432
是因为我们抛弃了时间的概念
is that you throw away time.

768
00:44:09,780 --> 00:44:11,750
也因为如此我们可以处理一些无穷的情况
That's why we can have these infinite processes.

769
00:44:11,750 --> 00:44:12,976
我们抛弃了时间
Since we've thrown away time,

770
00:44:12,992 --> 00:44:14,270
就没有必要等它们运行
we don't have to wait for them to run,

771
00:44:17,550 --> 00:44:20,448
我们把计算机中事件发生的顺序
Right? We decouple the order of events in the computer

772
00:44:20,832 --> 00:44:22,112
与程序中的顺序 分离开来
from what we write in our programs.

773
00:44:22,352 --> 00:44:25,280
但是当我们谈及状态、赋值和改变的时候
But when we talk about state and set and change,

774
00:44:25,488 --> 00:44:27,424
这些又都是我们想要控制的
that's exactly what we do want control of.

775
00:44:28,760 --> 00:44:33,824
我们的目的有着根本性的矛盾
So it's almost as if there's this fundamental contradiction in what you want.

776
00:44:34,570 --> 00:44:39,120
这又让我们进入了一个哲学问题
And that brings us back to these sort of philosophical mutterings

777
00:44:39,136 --> 00:44:40,752
用什么样的模型
what is it that you're trying to model

778
00:44:40,784 --> 00:44:41,776
和从什么角度来看这个世界
and how do you look at the world.

779
00:44:42,410 --> 00:44:44,304
有时这也被称为
Or sometimes this is called the

780
00:44:44,768 --> 00:44:46,608
“函数式程序设计的争论”
the debate over functional programming.

781
00:44:54,192 --> 00:44:56,608
所谓的“纯函数式语言”
A so-called purely functional language

782
00:44:57,072 --> 00:44:59,200
是完全没有副作用的
is one that just doesn't have any side effects.

783
00:45:00,440 --> 00:45:03,024
没有赋值运算符 也就没有副作用
Since you have no side effects, there's no assignment operator,

784
00:45:03,344 --> 00:45:05,728
也就没有什么糟糕的后果
so there are no terrible consequences of it.

785
00:45:06,360 --> 00:45:07,930
可以使用类似代换模型
You can use a substitution-like thing.

786
00:45:07,930 --> 00:45:10,480
程序更像是数学
Programs really are like mathematics and not like

787
00:45:10,768 --> 00:45:13,824
而不像识现实世界中的模型和对象
not like models in the real world, not like objects in the real world.

788
00:45:15,050 --> 00:45:17,170
函数式语言有很多了不起的特性
There are a lot of wonderful things about functional languages.

789
00:45:17,170 --> 00:45:19,632
没有时间的概念 所以完全不用担心同步的问题
Since there's no time, you never have any synchronization problems.

790
00:45:20,640 --> 00:45:23,728
如果你想在并行算法中应用一些东西
And if you want to put something into a parallel algorithm,

791
00:45:24,720 --> 00:45:28,208
#TBD
you can run the pieces of that parallel processing any way you want.

792
00:45:29,408 --> 00:45:31,440
从来不担心同步问题
There's just never any synchronization to worry that,

793
00:45:31,504 --> 00:45:33,344
在这种环境下这样做是非常方便的
and it's a very congenial environment for doing this.

794
00:45:33,640 --> 00:45:35,712
代价则是 放弃了赋值
The price is you give up assignment.

795
00:45:39,104 --> 00:45:41,328
函数式语言的支持者会认为
So an advocate of a functional language would say,

796
00:45:41,344 --> 00:45:43,040
这点代价算不了什么
gee, that's just a tiny price to pay.

797
00:45:44,520 --> 00:45:46,510
在大部分情况下 你都不应该使用赋值
You probably shouldn't use assignment most of the time anyway.

798
00:45:46,880 --> 00:45:48,272
如果用你放弃了赋值
And if you just give up assignment,

799
00:45:48,432 --> 00:45:51,408
#TBD
you can be in this much, much nicer world

800
00:45:51,968 --> 00:45:53,248
#TBD
than this place with objects.

801
00:45:54,190 --> 00:45:56,300
有没有什么例子呢？#TBD
Well, what's the rejoinder to that?

802
00:45:56,300 --> 00:45:58,592
想想 我们如何走到这一步的
Remember how we got into this mess.

803
00:46:00,064 --> 00:46:03,792
我们尝试建模具有局部状态的对象
We started trying to model things that had local state.

804
00:46:04,440 --> 00:46:06,496
想一想 Gerald 教授给你们讲的随机数生成器
So remember Gerry's random number generator.

805
00:46:07,168 --> 00:46:08,672
这里有一个随机数生成器
There was this random number generator

806
00:46:09,280 --> 00:46:10,624
它内部有一些状态
that had some little state in it

807
00:46:10,830 --> 00:46:12,080
用来计算下一个随机数
to compute the next random number

808
00:46:12,128 --> 00:46:14,080
下下一个 以及再下一个
and the next random number and the next random number.

809
00:46:14,288 --> 00:46:16,144
我们想要把这些状态跟
And we wanted to hide that state away from the

810
00:46:16,432 --> 00:46:18,960
计算 π 的 Cesaro 算法分离开来
the Cesaro compute pi process,

811
00:46:19,840 --> 00:46:20,928
这就是我们为什么需要赋值
and that's why we needed set!

812
00:46:20,976 --> 00:46:22,912
我们想要把状态封装在模块中
We wanted to package that stated modularly.

813
00:46:24,070 --> 00:46:26,368
函数式语言程序员可能会说
Well, a functional programming person would say,

814
00:46:26,384 --> 00:46:27,560
“你搞错了”
well, you're just all wet.

815
00:46:27,560 --> 00:46:29,840
“我的意思是 你能写出另一种更具模块化的程序”
I mean, you can write a perfectly good modular program.

816
00:46:29,840 --> 00:46:32,464
“你对模块化的认识并不正确”
It's just you're thinking about modularity wrong.

817
00:46:33,088 --> 00:46:36,880
#TBD
You're hung up in this next random number and the next random number and the next random number.

818
00:46:36,880 --> 00:46:39,424
为什么不写一个这样的程序
Why don't you just say let's write a program.

819
00:46:40,090 --> 00:46:41,296
写一个枚举器
Let's write an enumerator

820
00:46:41,952 --> 00:46:44,480
它会生成一个随机数的无穷流
which just generates an infinite stream of random numbers.

821
00:46:49,010 --> 00:46:50,912
你可以立即生成这个流
We can sort of have that stream all at once,

822
00:46:52,640 --> 00:46:54,540
这样就可以用作随机数的源泉
and that's going to be our source of random numbers.

823
00:46:54,540 --> 00:46:55,248
如果有需要的话
And then if you like,

824
00:46:55,536 --> 00:46:57,472
你可以把它跟某个处理过程相连
you can put that through some sort of processor,

825
00:46:57,776 --> 00:47:01,168
比如说 Cesaro 算法
which is-- I don't know-- a Cesaro test,

826
00:47:04,944 --> 00:47:06,224
然后这个处理过程进行自己的计算
and that can do what it wants.

827
00:47:06,880 --> 00:47:08,560
从这里出来的则是
And what would come out of there

828
00:47:08,720 --> 00:47:27,456
其中是一串的对 PI 的估计值组成的流
would be a stream of successive approximations to pi.

829
00:47:28,140 --> 00:47:30,656
随着我们深入访问这个流
So as we looked further down this stream,

830
00:47:30,768 --> 00:47:32,384
相当于去拽这个 Cesaro 盒子
we'd tug on this Cesaro thing,

831
00:47:33,120 --> 00:47:35,360
它就会拉取出许多随机数
and it would pull out more and more random numbers.

832
00:47:35,540 --> 00:47:37,216
随着我们对流的深入访问
And the further and further we look down the stream,

833
00:47:37,232 --> 00:47:38,960
得到的对 π 的估计值就越准
the better an approximation we'd get to pi.

834
00:47:39,720 --> 00:47:41,664
具体的计算过程还是一样的
And it would do exactly the same as the other computation,

835
00:47:41,664 --> 00:47:43,792
只不过使用了另一种模块化的方式
except we're thinking about the modularity different.

836
00:47:43,890 --> 00:47:47,600
我们可以想象成一下子就有了这所有的随机数
We're saying imagine we had all those infinite streams of random numbers all at once.

837
00:47:49,280 --> 00:47:52,240
这个过程的细节在书上有
You can see the details of this procedure in the book.

838
00:47:53,610 --> 00:47:57,856
我们同样也陷于另外一些类似的事情中
But similarly, there are other things that we tend to get locked into

839
00:47:58,272 --> 00:48:01,200
这种关于 这个、下一个以及在下一个的范式
on this one and that one and the next one and the next one,

840
00:48:01,376 --> 00:48:02,816
完全可以不这么来做
which don't have to be that way.

841
00:48:03,280 --> 00:48:06,544
我们来思考一下银行系统
Like you might think about like a banking system,

842
00:48:07,680 --> 00:48:08,900
想法非常简单 #TBD
which is a very simple idea.

843
00:48:08,900 --> 00:48:12,210
我们假设这个程序代表了银行帐户
Imagine we have a program that sort of represents a bank account.

844
00:48:18,810 --> 00:48:20,848
银行账户中可能有
The bank account might have in it--

845
00:48:22,784 --> 00:48:26,224
如果我们以消息传递的角度来看
if we looked at this in a sort of message-passing view of the world,

846
00:48:26,448 --> 00:48:28,128
我们认为银行账户是一个对象
we'd say a bank account is an object

847
00:48:28,592 --> 00:48:31,510
内部保存着标识余额的局部状态 BALANCE
that has some local state in there, which is the balance, say.

848
00:48:34,110 --> 00:48:36,000
如果一个用户使用这个系统
And a user using this system comes

849
00:48:36,448 --> 00:48:38,144
发出交易请求
and sends a transaction request.

850
00:48:39,312 --> 00:48:41,056
用户发出的交易请求可能是
So the user sends a transaction request,

851
00:48:41,072 --> 00:48:42,208
存一些钱
like deposit some money,

852
00:48:42,288 --> 00:48:43,536
银行账户就会
and the bank account maybe--

853
00:48:43,920 --> 00:48:46,784
我们假设银行账户总是以当前余额作为回应
let's say the bank account always responds with what the current balance is.

854
00:48:48,220 --> 00:48:50,048
用户存了一些钱
The user says let's deposits some money,

855
00:48:50,064 --> 00:48:53,210
银行账户就会返回一个消息指明当前余额
and the bank account sends back a message which is the balance.

856
00:48:54,350 --> 00:48:57,424
用户再存一些钱
And the user says deposit some more,

857
00:48:57,456 --> 00:48:58,816
银行就再返回消息
and the bank account sends back a message.

858
00:48:59,150 --> 00:49:00,752
就像生成随机数一样
And just like the random number generating

859
00:49:00,784 --> 00:49:02,128
我们想使用赋值来实现
you'd say, gee, we would like to use set.

860
00:49:03,200 --> 00:49:06,880
帐户的内部保存了局部状态 BALANCE
We'd like to have balance be a piece of local state inside this bank account

861
00:49:06,880 --> 00:49:08,400
因为我们想要把用户状态
because we want to separate the state of the user

862
00:49:08,416 --> 00:49:09,570
和银行账户的状态分离开来
from the state of the bank account.

863
00:49:13,280 --> 00:49:16,420
这是从消息传递的角度来看
Well, that's the message-processing view.

864
00:49:16,420 --> 00:49:18,208
如果从流的角度来看
There's a stream view with that thing,

865
00:49:19,488 --> 00:49:22,192
不需要赋值或副作用就可以达到同样的效果
which does the same thing without any set or side effects.

866
00:49:22,740 --> 00:49:26,736
再次强调 想法是这样的
And the idea is again

867
00:49:27,376 --> 00:49:30,256
我们认为对象都没有局部状态
we don't think about anything having local state.

868
00:49:31,180 --> 00:49:33,088
我们把银行账户看作是
We think about the bank account as something

869
00:49:33,408 --> 00:49:37,712
能够处理一系列交易请求的东西
that's going to process a stream of transaction requests.

870
00:49:38,640 --> 00:49:42,000
不把银行账户看做处理消息的对象
So think about this bank account not as something that goes message by message,

871
00:49:42,448 --> 00:49:45,856
而是处理某种交易请求流的东西
but something that takes in a stream of transaction requests

872
00:49:45,872 --> 00:49:48,496
这个请求流可能是一些列的存款声明
like maybe successive deposit announced.

873
00:49:49,490 --> 00:49:54,944
比如 1 2 2 4 这样的连续存钱请求
1, 2, 2, 4, those might be successive amounts to deposit.

874
00:49:55,940 --> 00:50:02,448
从帐户出来的流应该是 1 3 5 9
And then coming out of it is the successive balances 1, 3, 5, 9.

875
00:50:03,770 --> 00:50:06,144
我们不把银行账户看做某种具有状态的东西
So we think of the bank account not as something that has state,

876
00:50:06,400 --> 00:50:07,264
而是某种能够处理
but something that acts

877
00:50:08,928 --> 00:50:10,820
有关请求的无穷流的东西
sort of on the infinite stream of requests.

878
00:50:10,820 --> 00:50:12,304
但要注意 我们抛弃了时间
But remember, we've thrown away time.

879
00:50:12,370 --> 00:50:14,272
如果这里有一个用户
So what we can do is if the user's here,

880
00:50:16,120 --> 00:50:19,136
这个无穷请求流的元素
we can have this infinite stream of requests

881
00:50:19,184 --> 00:50:22,540
我们可以一次生成一个
being generated one at a time coming from the user

882
00:50:24,064 --> 00:50:26,576
而这个交易流
and this transaction stream

883
00:50:26,570 --> 00:50:28,800
则会一次一个地打印在输出器上
coming back on a printer being printed one at a time.

884
00:50:30,010 --> 00:50:31,376
如果在这里划一条线
And if we drew a little line here,

885
00:50:32,560 --> 00:50:33,088
就在这里
right there to the user,

886
00:50:33,280 --> 00:50:34,912
对用户来说 他根本无法分辨
the user couldn't tell that this system doesn't have state.

887
00:50:36,192 --> 00:50:37,712
这个系统是否有内部状态
that this system doesn't have state.

888
00:50:39,560 --> 00:50:41,136
这个跟消息传递那种是一样的
It looks just like the other one,

889
00:50:41,296 --> 00:50:42,464
只不过这个没有状态
but there's no state in there.

890
00:50:42,848 --> 00:50:45,872
哦 顺便提一下
And by the way,

891
00:50:46,720 --> 00:50:49,472
这是具体的代码实现
just to show you, here's an actual implementation

892
00:50:50,528 --> 00:50:52,304
我们把它叫做 MAKE-DEPOSIT-ACCOUNT
of this-- we'll call it make deposit account

893
00:50:52,320 --> 00:50:53,328
因为它只能够存钱
because you can only deposit.

894
00:50:54,176 --> 00:50:55,776
这个过程接受一个初始余额
It takes an initial balance

895
00:50:56,096 --> 00:50:58,096
以及一个可能发起的存款流
and then a stream of deposits you might make.

896
00:51:00,020 --> 00:51:00,820
具体怎么做呢？
And what is it?

897
00:51:00,820 --> 00:51:02,544
它只是用 CONS-STREAM 把余额 BALANCE
Well, it's just cons-stream of the balance

898
00:51:03,232 --> 00:51:05,312
和一个新的存款账户流组合在一起
onto make a new account stream

899
00:51:06,240 --> 00:51:07,328
新存款流的初始余额
whose initial balance

900
00:51:07,488 --> 00:51:10,272
就是之前 BALANCE 的值加上存款流的第一个元素
is the old balance plus the first thing in the deposit stream

901
00:51:10,864 --> 00:51:13,408
而其余部分则是
whose rest, right and,

902
00:51:13,760 --> 00:51:17,376
存款流的 TAIL 部分
make deposit account works on the rest of which is the tail of the deposit stream.

903
00:51:18,300 --> 00:51:23,840
因此这种非常典型的消息传递式、面向对象的问题
So there's sort of a very typical message-passing,

904
00:51:23,952 --> 00:51:27,552
完全可以不用副作用来解决
message-passing, object-oriented thing that's done without side effects at all.

905
00:51:29,056 --> 00:51:30,768
很多地方都可以这样做
There are very many things you can do this way.

906
00:51:32,250 --> 00:51:35,232
那么 我们可以完全不用赋值么？
Well, can you do everything without assignment?

907
00:51:36,400 --> 00:51:39,008
可以只用纯函数式语言吗？
Can everybody go over to purely functional languages?

908
00:51:40,050 --> 00:51:42,048
这个问题谁也说不清
Well, we don't know,

909
00:51:42,272 --> 00:51:43,440
好像有些地方
but there seem to be places

910
00:51:43,920 --> 00:51:46,032
纯函数式语言无法派上用场
where purely functional programming breaks down.

911
00:51:48,100 --> 00:51:50,272
#TBD
Where it starts hurting is when you have things like this,

912
00:51:50,432 --> 00:51:52,320
#TBD
but you also mix it up with

913
00:51:52,608 --> 00:51:54,272
#TBD
the other things that we had to worry that,

914
00:51:54,304 --> 00:51:55,648
有关对象和共享
which are objects and sharing

915
00:51:55,904 --> 00:51:58,528
以及两个独立的主体共享同一个东西
and two independent agents being the same.

916
00:51:58,850 --> 00:51:59,936
举一个典型的例子
So under a typical one,

917
00:51:59,968 --> 00:52:01,632
假如你来扩展这个帐户
suppose you want to extend this bank account.

918
00:52:03,248 --> 00:52:04,272
这是一个帐户
So here's a bank account.

919
00:52:12,220 --> 00:52:14,752
帐户接受一个交易请求流
Bank accounts take in a stream of transaction requests

920
00:52:15,200 --> 00:52:18,448
输出的流则是关于余额的回复
and put out streams of, say, balances or responses to that.

921
00:52:18,780 --> 00:52:20,160
假设你所建模的是联合账户
But suppose you want to model the fact

922
00:52:20,176 --> 00:52:24,368
而由两个独立的用户共享
that this is a joint bank account between two independent people.

923
00:52:25,680 --> 00:52:28,656
我们假设 假设有两个人
Right? I don't know. So suppose there are two people,

924
00:52:28,976 --> 00:52:30,960
比如说 Bill 和 Dave
say, Bill and Dave,

925
00:52:31,776 --> 00:52:33,140
他们俩共享一个帐户
who have a joint bank account.

926
00:52:35,960 --> 00:52:36,850
怎么来建模呢？
How would you model this?

927
00:52:36,880 --> 00:52:39,800
你或许会让 Bill 输出一个交易请求流
Well, you might, Bill puts out a stream of transaction requests,

928
00:52:40,240 --> 00:52:42,256
Dave 也产生一个这样的流
and Dave puts out a stream of transaction requests,

929
00:52:42,256 --> 00:52:45,168
这两个流需要以某种方式合并到银行账户中
and somehow, they have to merge into this bank account.

930
00:52:45,880 --> 00:52:50,656
因此你需要编写一个 MERGE 过程来处理这些流
So what you might do is write a little stream processing thing called merge,

931
00:52:57,232 --> 00:52:59,136
它把这些流合并在一起
which sort of takes these, merges them together,

932
00:52:59,344 --> 00:53:01,190
形成单个流 送入银行账户
produces a single stream for the bank account.

933
00:53:01,190 --> 00:53:02,992
现在他们就共享一个帐户了
Now they're both talking to the same bank account.

934
00:53:03,610 --> 00:53:05,488
看起来不错 问题是怎么来实现 MERGE
That's all great, but how do you write merge?

935
00:53:05,936 --> 00:53:08,240
MERGE 怎么来合并？
What, What's this procedure merge?

936
00:53:09,730 --> 00:53:11,424
需要合理的合并依据
You want to do something that's reasonable.

937
00:53:12,380 --> 00:53:13,808
你可能首先会想这样来结局
Your first guess might be to say,

938
00:53:13,808 --> 00:53:16,688
我们从 Bill 和 Dave 中选一个请求来处理
well, we'll take alternate requests from Bill and Dave.

939
00:53:18,190 --> 00:53:20,976
但是如果在这中途
But what happens if But what happens if suddenly in the middle thing

940
00:53:21,184 --> 00:53:23,088
Dave 突然外出度假两年 会怎么样？
Dave goes away on vacation for two years?

941
00:53:24,150 --> 00:53:25,408
Bill 的交易就完全被阻塞了
Then Bill's sort of stuck.

942
00:53:27,690 --> 00:53:29,750
你想要的是
So what you want to do is-- well, it's hard to describe.

943
00:53:29,750 --> 00:53:33,648
是一种公平的合并
What you want to do is what people call fair merge.

944
00:53:38,410 --> 00:53:40,176
这个所谓公平的合并
The idea of fair merge is

945
00:53:40,736 --> 00:53:42,464
应该是交替地一次处理一个
is it sort of should do them alternately,

946
00:53:42,496 --> 00:53:43,920
但是如果一个人没有了交易
but if there's nothing waiting here,

947
00:53:43,968 --> 00:53:44,912
应该继续去处理另一个人的交易
it should take one twice.

948
00:53:46,010 --> 00:53:48,450
你们可以注意到我完全没有谈论时间 #TBD
Notice I can't even say that without talking about time.

949
00:53:51,300 --> 00:53:56,416
函数式语言的另一个活跃研究领域就是
So one of the other active researcher areas in functional languages

950
00:53:56,432 --> 00:53:59,488
发明类似于“公平合并”的算法
is inventing little things like fair merge

951
00:54:00,350 --> 00:54:01,312
又或者是其它的东西
maybe some others,

952
00:54:01,568 --> 00:54:06,256
用于取代原来的副作用和对象
which will take the places where I used to need side effects and objects

953
00:54:06,800 --> 00:54:10,528
用一种良好定义的模块化系统来隐藏它们
and sort of hide them away in some very well-defined modules of the system

954
00:54:10,860 --> 00:54:13,504
这样 系统中就不会到处产生
so that all the problems of assignment

955
00:54:13,520 --> 00:54:15,344
赋值所带来的问题
don't sort of leak out all over the system but

956
00:54:15,408 --> 00:54:17,880
因为赋值可以被一些容易理解的概念所描述 #TBD
are captured in some fairly well-understood things.

957
00:54:20,780 --> 00:54:22,704
推而广之 我想你们也发现了
More generally, I think what you're seeing

958
00:54:23,120 --> 00:54:24,064
我们正面对
is that we're running across

959
00:54:24,080 --> 00:54:26,670
我所认为的 计算机科学中最基本的问题
what I think is a very basic problem in computer science,

960
00:54:26,976 --> 00:54:27,824
也就是
which is how to

961
00:54:28,240 --> 00:54:32,032
我们如何定义一门支持延迟求值的语言
how to define languages that somehow can talk about delayed evaluation

962
00:54:34,144 --> 00:54:35,088
但同时又能够
But also

963
00:54:35,872 --> 00:54:38,256
又能够把事物看做对象来操作
be able to reflect this view that there are objects in the world.

964
00:54:38,360 --> 00:54:40,368
怎么样才能两者兼有之？
How do we somehow get both?

965
00:54:41,230 --> 00:54:43,040
我认为这个问题很困难
And I think that's a very hard problem.

966
00:54:43,040 --> 00:54:45,520
但是这个很困难的问题
And it may be that it's a very hard problem

967
00:54:45,856 --> 00:54:48,176
却和计算机科学的关系不大
that has almost nothing to do with computer science,

968
00:54:48,590 --> 00:54:50,240
它真正涉及的是
that it really is a problem having to do with

969
00:54:50,272 --> 00:54:52,736
两种不相容的看待世界的方式
two very incompatible ways of looking at the world.

970
00:54:54,144 --> 00:54:54,720
有问题吗？
OK, questions?

971
00:55:17,550 --> 00:55:19,200
学生：你之前提到过
AUDIENCE: You mentioned earlier that

972
00:55:20,112 --> 00:55:21,328
一旦引入了赋值
once you introduce assignment,

973
00:55:21,328 --> 00:55:25,890
就不能使用代换模型了
the general rule for using the substitution model is you can't.

974
00:55:25,890 --> 00:55:27,570
除非你非常小心
Unless you're very careful, you can't.

975
00:55:27,570 --> 00:55:27,968
教授：对的
PROFESSOR: Right.

976
00:55:28,260 --> 00:55:33,280
学生：有什么技术或者指导方针
AUDIENCE: Is there a set of techniques or a set of guidelines

977
00:55:33,424 --> 00:55:35,920
来确定赋值的影响
for localizing the effects of assignment

978
00:55:36,528 --> 00:55:40,300
以便说g清楚这个“很小心”是怎么回事吗？
so that the very careful becomes defined?

979
00:55:40,300 --> 00:55:42,608
教授：我不知道
PROFESSOR: I don't know. Um...

980
00:55:42,890 --> 00:55:43,584
我想想
Let me think.

981
00:55:45,430 --> 00:55:48,944
当然 实现 MEM-PROC 也使用了赋值
Well, certainly, there was an assignment inside memo proc,

982
00:55:50,128 --> 00:55:51,480
但是它被隐藏了起来
but that was sort of hidden away.

983
00:55:51,480 --> 00:55:53,008
因为它没有对结果造成影响
It ended up not making any difference.

984
00:55:53,480 --> 00:55:56,448
部分原因之一在于 一旦触发这个过程
Part of the reason for that is once this thing triggered

985
00:55:57,152 --> 00:55:58,832
它被求值并得到结果
that it had run and gotten an answer,

986
00:55:58,832 --> 00:56:00,064
这个结果不会再变化
that answer will never change.

987
00:56:00,608 --> 00:56:02,336
有点像单次赋值
So that was sort of a one-time assignment.

988
00:56:02,350 --> 00:56:03,856
一个一般性原则就是
So one very general thing you can do

989
00:56:04,304 --> 00:56:06,352
如果你只用这种单次赋值
is if you only do what's called a one-time assignment

990
00:56:08,048 --> 00:56:10,544
并且它不再改变 我想应该不会有太大问题
and never change anything, then you can do better.

991
00:56:11,250 --> 00:56:14,128
还有一个问题在于 MERGE --
One of the problems in this merge thing, people have--

992
00:56:14,672 --> 00:56:18,320
让我想想对不对
people have-- let me see if this is right.

993
00:56:18,490 --> 00:56:21,552
我认为有了公平合并这一技术
I think it's true that with fair merge,

994
00:56:22,256 --> 00:56:26,096
有了这一技术 你可以在语言的其它地方
with just fair merge, you can begin effectively simulating

995
00:56:27,024 --> 00:56:28,896
有效地模拟赋值
assignment in the rest of the language.

996
00:56:30,820 --> 00:56:33,296
#TBD
It seems like anything you do to go outside--

997
00:56:33,504 --> 00:56:35,504
#TBD
I'm not quite sure that's true for fair merge,

998
00:56:35,536 --> 00:56:39,312
#TBD
but it's true of a little bit more general things that people have been doing.

999
00:56:39,520 --> 00:56:41,344
所以可能真的实现了这种技术 #TBD
So it might be that any little bit you put in,

1000
00:56:41,616 --> 00:56:44,144
突然你能用这种语言来做任何事 #TBD
suddenly if they allow you to build arbitrary stuff,

1001
00:56:44,160 --> 00:56:46,512
其实应该和你拥有了赋值一样也会遇到糟糕的情况 #TBD
it's almost as bad as having assignment altogether.

1002
00:56:47,970 --> 00:56:50,672
这也是人们在研究的一个领域
But that's an area that people are thinking about now.

1003
00:56:51,590 --> 00:56:54,304

AUDIENCE: I guess I don't see the problem here with merge

1004
00:56:54,830 --> 00:56:59,200
如果我调用 Bill 它是个过程
if, you know the sense, I call Bill, if Bill is a procedure,

1005
00:56:59,216 --> 00:57:02,416
那么 Bill 就会增加银行账户
then Bill is going to increment the bank account

1006
00:57:02,448 --> 00:57:04,730
或者创建一个表 用于放置下一个存款
or build the list that 's going to put in the next element.

1007
00:57:04,730 --> 00:57:06,848
如果我调用Dave两次 他肯定也会存款两次 #TBD
If I call Dave twice in a row, that will do that.

1008
00:57:07,170 --> 00:57:09,350
我并不清楚 FAIR-MERGE 是在哪里被调用的
I'm not sure where fair merge has to be involved.

1009
00:57:09,350 --> 00:57:11,200
教授：关键在于你得把这些当作真人一样
PROFESSOR: The problem is imagine these really as people.

1010
00:57:11,200 --> 00:57:14,208
这里有一个用户在操作帐户
See, here I have the user who's interacting with this bank account.

1011
00:57:14,850 --> 00:57:17,070
请求一次 得到结果
Put in a request, get an answer. Put in a request, get an answer.

1012
00:57:17,200 --> 00:57:17,568
学生：对
AUDIENCE: Right.

1013
00:57:18,200 --> 00:57:22,256
教授：但是如果我交替的来处理两个人的请求
PROFESSOR: But if the only way I can process request is to alternate them from two people--

1014
00:57:22,912 --> 00:57:24,220
学生：为什么要交替着？
AUDIENCE: Well, why would you alternate them?

1015
00:57:24,220 --> 00:57:25,232
教授：为什么不呢？
PROFESSOR: Why don't I?

1016
00:57:25,456 --> 00:57:25,808
学生：对啊 为什么要这样呢？
AUDIENCE: Yes. Why do you?

1017
00:57:26,608 --> 00:57:27,728
教授：假设这些是现实中的人，对吗？
PROFESSOR: Think of them as real people, right?

1018
00:57:27,760 --> 00:57:28,976
这个人外出一年
This guy might go away for a year.

1019
00:57:29,280 --> 00:57:31,744
你只能在银行账户窗口旁边等待
And you're sitting here at the bank account window,

1020
00:57:32,430 --> 00:57:33,728
就是不能处理两个请求
and you can't put in two requests

1021
00:57:33,744 --> 00:57:34,944
因为你还得等这个人
because it's waiting for this guy.

1022
00:57:35,480 --> 00:57:37,072
学生：为什么非得等他呢？
AUDIENCE: Why does it have to be waiting for one?

1023
00:57:37,380 --> 00:57:39,110
教授：因为这里是在计算一个函数
PROFESSOR: Because it's trying to compute a function.

1024
00:57:39,110 --> 00:57:40,928
我必须定义一个函数
I have to define a function.

1025
00:57:41,720 --> 00:57:42,608
换种方式来说
Another way to say that

1026
00:57:42,848 --> 00:57:44,992
这个 MERGE 盒子的输出
is the answer to what comes out of this merge box

1027
00:57:46,240 --> 00:57:49,488
并不是输入的函数
is not a function of what goes in.

1028
00:57:51,690 --> 00:57:53,490
明白了吗？再来看看这个 MERGE 是怎么运行的
Because, see, what would the function be?

1029
00:57:53,490 --> 00:57:58,864
假设 Bill 输入 1 1 1 1
Suppose he puts in 1, 1, 1, 1,

1030
00:57:59,824 --> 00:58:02,784
Dave输入2 2 2 2
and he puts in 2, 2, 2, 2.

1031
00:58:03,470 --> 00:58:04,800
MERGE 应该输出什么呢？
What's the answer supposed to be?

1032
00:58:05,584 --> 00:58:08,740
这里并不一定是 1 2 1 2 1 2
It's not good enough to say it's 1, 2, 1, 2, 1, 2.

1033
00:58:08,740 --> 00:58:09,390
学生：我明白了
AUDIENCE: I understand.

1034
00:58:09,390 --> 00:58:11,560
当 Bill 再输入 1  1 也就进去了
But when Bill puts in 1, 1 goes in.

1035
00:58:11,560 --> 00:58:13,950
Dave 再输入两个 2 MERGE 就输出两个 2
When Dave puts in 2, twice 2 goes in twice.

1036
00:58:13,950 --> 00:58:14,736
学生：当 Bill 输入
AUDIENCE: When Bill puts in--

1037
00:58:14,768 --> 00:58:15,088
教授：对的
PROFESSOR: Right.

1038
00:58:15,130 --> 00:58:18,432
学生：为什么不能在输入的数据
AUDIENCE: Why can't it be hooked to the time of the input--

1039
00:58:18,592 --> 00:58:20,064
上加上时间信息呢？
the actual procedural--

1040
00:58:20,128 --> 00:58:21,840
PROFESSOR：因为这里没有时间这个概念
PROFESSOR: Because I don't have time.

1041
00:58:23,980 --> 00:58:26,900
我只是定义一个函数
See, all I can say is I'm going to define a function.

1042
00:58:26,900 --> 00:58:28,150
没有时间概念
I don't have time.

1043
00:58:32,000 --> 00:58:34,192
#TBD
There's no concept if it's going to alternate,

1044
00:58:34,192 --> 00:58:36,544
#TBD
except if nobody's there, it's going to wait a while for him.

1045
00:58:38,420 --> 00:58:41,360
它只会说 我有一个请求流
It's just going to say I have the stream of requests,

1046
00:58:41,740 --> 00:58:43,344
这是是 Dave 生成的
the timeless infinite streams

1047
00:58:43,360 --> 00:58:45,296
没有时刻的、无穷长度的请求流
of all the requests that Dave would have made, right?

1048
00:58:47,550 --> 00:58:50,416
Bill 可能生成的没有时刻的无穷请求流
And the timeless infinite stream of all the requests Bill would have made,

1049
00:58:50,544 --> 00:58:51,690
我想对这些东西做运算
and I want to operate on them.

1050
00:58:51,690 --> 00:58:53,510
这就是银行帐户的工作原理
See, that's how this bank account is working.

1051
00:58:56,710 --> 00:58:57,584
问题是
And the problem is

1052
00:58:57,610 --> 00:59:00,752
这些坐在银行窗口前的倒霉蛋们
that these poor people who are sitting at the bank account windows

1053
00:59:00,768 --> 00:59:03,824
来得并不是时候
have the misfortune to exist in time.

1054
00:59:05,296 --> 00:59:07,136
#TBD
They don't see their infinite stream

1055
00:59:07,696 --> 00:59:09,536
#TBD
of all the requests they would have ever made.

1056
00:59:10,070 --> 00:59:11,550
他们只是等着 等待帐户的响应
They're waiting now, and they want an answer.

1057
00:59:14,480 --> 00:59:15,760
假设你坐在屏幕前
So if you're sitting there--

1058
00:59:16,240 --> 00:59:20,864
操作着一台分时系统的计算机
if this is the screen operation on some time-sharing system

1059
00:59:21,520 --> 00:59:22,608
而且它还是函数式的
and it's working functionally,

1060
00:59:22,640 --> 00:59:24,592
输入指令后你就希望看到结果
you want an answer then when you talk the character.

1061
00:59:25,290 --> 00:59:27,424
但是你并不想主机在处理完所有其它人的命令
You don't want it to have to wait for everybody in the whole system

1062
00:59:27,456 --> 00:59:29,920
之后再来处理你的命令
to have typed one character before it can get around to service you.

1063
00:59:30,910 --> 00:59:31,920
这就是问题所在
So that's the problem.

1064
00:59:34,000 --> 00:59:36,384
我的意思就是 用户的世界当然是存在时间概念的
I mean, the fact that people live in time, apparently.

1065
00:59:37,216 --> 00:59:38,620
如果没有 这就不构成问题
If they didn't, it wouldn't be a problem.

1066
00:59:49,100 --> 00:59:51,024
学生：我想我还是不太理解
AUDIENCE: I'm afraid I miss the point of

1067
00:59:51,088 --> 00:59:54,240
银行交易中为什么没有时间概念这一要点
having no time in this banking transaction.

1068
00:59:54,740 --> 00:59:56,656
难道时间不是非常重要吗？
Isn't time very important?

1069
00:59:56,880 --> 00:59:59,056
举例说 有一系列事件
For instance, the sequence of events.

1070
00:59:59,950 --> 01:00:05,024
比如 Dave 取款 $100
As if, If Dave take out $100, and then

1071
01:00:06,304 --> 01:00:08,400
比如Dave取款$100，这些顺序应该很重要才对
As if, If Dave take out $100, then the timing sequence should be important.

1072
01:00:08,400 --> 01:00:10,864
你怎么能把它们看作是流呢？
How do you treat transactions as streams?

1073
01:00:11,260 --> 01:00:14,260
这个问题非常好
PROFESSOR: Well, that's the thing I'm saying.

1074
01:00:14,260 --> 01:00:15,616
在这个例子中确实做不到那一点
This is an example where you can't.

1075
01:00:17,510 --> 01:00:18,128
做不到
You can't.

1076
01:00:18,160 --> 01:00:20,080
关键在于 这里的输出
What goes, The point is what comes out of here

1077
01:00:20,240 --> 01:00:21,888
并不是这两个输入流
 is simply not a function of the stream going in here

1078
01:00:21,920 --> 01:00:23,600
的函数
going in here and the stream going in here.

1079
01:00:24,170 --> 01:00:25,984
这个函数跟这个输入流有关
It's a function of the stream going in here

1080
01:00:26,192 --> 01:00:27,264
还跟这个输入流有关
and the stream going in here

1081
01:00:27,360 --> 01:00:29,072
还包括某种有关时间的信息
and some kind of information about time,

1082
01:00:29,376 --> 01:00:32,368
这也正是正则序语言不想让你知道的
which is precisely what a normal-order language won't let you say.

1083
01:00:34,810 --> 01:00:37,952
学生：为了让这个系统更加函数式
AUDIENCE: In order to brings this back into a more functional perspective,

1084
01:00:38,544 --> 01:00:42,048
我们能不能把 Bill 和 Dave 的交易请求附上时间戳
could we just explicitly time stamp all the inputs from Bill and Dave

1085
01:00:42,544 --> 01:00:46,400
而使用时间戳作为公平合并的依据？
and define fair merge to just be the sort on those time stamps?

1086
01:00:48,416 --> 01:00:49,550
教授：当然 当然可以
PROFESSOR: Yeah, you can do that.

1087
01:00:49,550 --> 01:00:50,600
你可以那样做
You can do that sort of thing.

1088
01:00:50,600 --> 01:00:52,560
或者 我们可以这样来想象
Another thing you could say is imagine

1089
01:00:52,768 --> 01:00:54,448
我们把这个函数看作是
that really what this function is,

1090
01:00:54,784 --> 01:00:56,880
MERGE 每毫秒读一次输入
is that it does a read every microsecond,

1091
01:00:58,864 --> 01:01:00,970
如果没有读到东西 就认为没有请求
and then if there's none there, that's considered an empty one.

1092
01:01:00,970 --> 01:01:03,392
这和你刚刚说的那种方式是等价的
That's about equivalent to what you said.

1093
01:01:03,610 --> 01:01:06,080
当然可以这样做 但是那不是我们关注的重点 #TBD
And yes, you can do that, but that's a glitch.

1094
01:01:07,110 --> 01:01:10,144
我们不只是关心函数的具体实现 #TBD
So it's not quite only implementation we're worried about.

1095
01:01:10,768 --> 01:01:12,736
我们关心的是语言的表达力
We're worried about expressive power in the language,

1096
01:01:12,752 --> 01:01:14,672
我们遇到的困难是
and what we're running across is a real mismatch

1097
01:01:14,992 --> 01:01:17,440
我们不能很容易地表达我们想要表达的东西
between what we can say easily and what we'd like to say.

1098
01:01:19,880 --> 01:01:22,016
学生：听起来好像如果两个人同时发出请求
AUDIENCE: It sounds like where we're getting hung up with that

1099
01:01:22,064 --> 01:01:26,090
这个方法就会出问题
one input from both Bill and Dave at the same time.

1100
01:01:26,120 --> 01:01:28,432
也不是特指这一个问题，而是关乎你如何来定义这个函数的问题 #TBD
PROFESSOR: It's not quite one, but it's anything you define.

1101
01:01:28,530 --> 01:01:30,576
你也可以说Dave一次性处理两个请求 #TBD
So you can say Dave can go twice as often,

1102
01:01:30,720 --> 01:01:32,320
但是如果你预先定义些什么 #TBD
but if anything you predefine,

1103
01:01:32,688 --> 01:01:33,872
这种方式也会出问题 #TBD
it's not the right thing.

1104
01:01:36,110 --> 01:01:40,704
#TBD
You can't decide at some particular function of their input requests.

1105
01:01:41,930 --> 01:01:43,376
但是还有更坏的情况
Worse yet, I mean, worse yet,

1106
01:01:44,128 --> 01:01:45,728
有一些情况甚至 MERGE 也处理不了
there are things that even merge can't do.

1107
01:01:47,290 --> 01:01:49,696
比如突然有一天你想要
One thing you might want to do that's even more general is suddenly

1108
01:01:50,240 --> 01:01:52,470
把另一个人关联在这个银行帐户上
you add somebody else to this bank account system.

1109
01:01:52,470 --> 01:01:54,512
假如这个人是 John
You go and you add John to this bank account system.

1110
01:01:56,030 --> 01:01:58,896
现在图上就要多一个流
And now there's yet another stream that's going to come into the picture

1111
01:01:58,912 --> 01:02:00,704
在一个我们未曾指定的时候
at some time which we haven't prespecified.

1112
01:02:02,040 --> 01:02:04,000
这种情况甚至公平合并也无法给出合理的合并
So that's something even fair merge can't do,

1113
01:02:04,000 --> 01:02:08,256
还需要有经理一类的东西#TBD
and they're things called-- I forget-- manager or something.

1114
01:02:08,860 --> 01:02:11,790
需要一种更一般性的公平合并来解决
That's a generalization of fair merge to allow that.

1115
01:02:11,790 --> 01:02:13,984
有很多研究都在讨论
There's a whole sort of research discipline saying

1116
01:02:14,000 --> 01:02:16,300
通过不断引入新机制
how far can you push this functional perspective

1117
01:02:16,592 --> 01:02:18,720
函数式思维能应用到哪种程度？
by adding more and more mechanism?

1118
01:02:19,580 --> 01:02:21,792
在我们不得不使用赋值之前
And how far does that go before the whole thing breaks down

1119
01:02:21,824 --> 01:02:23,408
函数式程序设计能干成什么样？
and you might as well been using set anyway.

1120
01:02:25,984 --> 01:02:28,000
学生：看来自动存款就不行
AUDIENCE: But not automatic deposit.

1121
01:02:39,328 --> 01:02:40,496
教授：好的 下课
PROFESSOR: OK, thank you.

