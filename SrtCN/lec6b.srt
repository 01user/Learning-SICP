1
00:00:20,970 --> 00:00:24,080
教授：上节课 我们介绍了流
PROFESSOR: OK, well, we've been looking at streams,

2
00:00:24,080 --> 00:00:27,824
一种使用信号处理的方式来组织系统
this signal processing way of putting systems together.

3
00:00:28,870 --> 00:00:31,424
要记住的是 关键点在于
And remember, the key idea is that

4
00:00:31,904 --> 00:00:32,960
我们把
we decouple

5
00:00:34,208 --> 00:00:37,312
程序中事件表面上的顺序
the apparent order of events in our programs

6
00:00:37,584 --> 00:00:40,176
与机器中的实际计算顺序分离开来
from the actual order of events in the computer.

7
00:00:41,072 --> 00:00:42,288
那就意味着 我们可以
And that means that we can start

8
00:00:42,576 --> 00:00:44,144
着手处理非常长的流
dealing with very long streams

9
00:00:44,896 --> 00:00:47,392
并且只有在需要的时候才生成其中的元素
and only having to generate the elements on demand.

10
00:00:47,536 --> 00:00:49,392
这种按需计算的方式
That sort of on-demand computation

11
00:00:49,520 --> 00:00:51,408
是内建在流的数据结构中的
is built into the stream's data structure.

12
00:00:54,110 --> 00:00:55,648
即使这个流非常之长
So if we have a very long stream,

13
00:00:55,664 --> 00:00:57,080
我们只计算所需要的
we only compute what we need.

14
00:00:58,040 --> 00:01:00,750
只有当我们要求的时候 新的数据才会生成
The things only get computed when we actually ask for them.

15
00:01:00,750 --> 00:01:01,744
要举个什么样的例子呢？
Well, what are examples?

16
00:01:02,110 --> 00:01:03,600
真的像我们所说的那样吗？#TBD
Are they actually asking for them?

17
00:01:05,024 --> 00:01:06,016
举个例子 我们可能会
For instance, we might

18
00:01:09,216 --> 00:01:11,376
会想要一个流中的第N个元素
might ask for the n-th element of a stream.

19
00:01:15,360 --> 00:01:18,928
这个过程可以用于计算流的第N个元素
Here's a procedure that computes the n-th element of a stream.

20
00:01:20,090 --> 00:01:21,232
一个参数为索引 N
An integer n,

21
00:01:21,248 --> 00:01:22,848
另一个参数是流 S
the n-th element of some stream s,

22
00:01:23,408 --> 00:01:25,424
递归遍历这个流即可求解
and we just recursively walk down the stream.

23
00:01:25,570 --> 00:01:27,392
如果N为0 我们就计算头部分
And if n is 0, we compute the head.

24
00:01:27,960 --> 00:01:30,992
否则 就在流的尾部分
Otherwise, it's the n-th the minus 1 element

25
00:01:31,744 --> 00:01:32,800
查找第N-1个元素
of the stream.

26
00:01:34,310 --> 00:01:36,432
看起来是LISP中很普通的编程方式 但是不同的是
Those two are just like for Lisp, but the difference

27
00:01:36,624 --> 00:01:38,768
知道我们不断遍历 取得相继的N个元素
is those elements aren't going to get computed

28
00:01:38,864 --> 00:01:40,992
这些元素才被计算出来
until we walk down, taking successive n-ths.

29
00:01:41,520 --> 00:01:44,784
这是这些流元素可能被FORCE的一种方式
So that's one way that the stream elements might get forced.

30
00:01:45,776 --> 00:01:46,640
另外一种方式则是
And another way,

31
00:01:47,184 --> 00:01:48,928
这里有个简单的过程 用来打印一个流
here's a little procedure that prints a stream.

32
00:01:49,300 --> 00:01:50,384
它的定义是
We say print a stream,

33
00:01:51,904 --> 00:01:53,280
打印流S的过程PRINT-STREAM的定义是
so to print a stream s.

34
00:01:54,150 --> 00:01:55,120
我们要怎么做呢？
Well, what do we do? We'll

35
00:01:55,744 --> 00:01:56,864
先打印流的头部分
We print the head of the stream,

36
00:01:57,744 --> 00:01:59,328
流的头部分在这时就被计算出来
and that will cause the head to be computed.

37
00:01:59,720 --> 00:02:02,848
然后我们再递归地打印流的尾部分
And then we recursively print stream the tail of the stream.

38
00:02:04,990 --> 00:02:06,032
如果流为空
And if we're already done,

39
00:02:06,048 --> 00:02:08,576
就返回一个的表示完成的消息 “DONE”
maybe we have to return something about the message done.

40
00:02:09,660 --> 00:02:11,392
如果你构造了一个流长
OK, and then so if you make a stream,

41
00:02:11,648 --> 00:02:13,648
这个流非常的长
you could say here's the stream, this very long stream.

42
00:02:14,310 --> 00:02:16,336
当你调用这个过程
And then you say print the stream,

43
00:02:16,416 --> 00:02:19,776
流中的元素会随着PRINT-STREAM的调用
and the elements of the stream will get computed successively

44
00:02:19,872 --> 00:02:21,120
而被依次计算出来
as that print calls them.

45
00:02:21,320 --> 00:02:22,816
不会在一开始就全部计算出来
They won't get all computed initially.

46
00:02:24,300 --> 00:02:25,664
正因为如此 我们能够
So in this way, we can

47
00:02:27,504 --> 00:02:29,610
我们能够处理非常长的流
So in this way, we can deal with some very long streams.

48
00:02:30,190 --> 00:02:31,920
多长呢？
Well, how long can a stream be?

49
00:02:33,744 --> 00:02:35,120
可以是无限长
Well, it can be infinitely long.

50
00:02:35,904 --> 00:02:38,048
我们在计算机上实践一下
Let's look at an example here on the computer.

51
00:02:38,920 --> 00:02:41,968
我可以在计算机前输入
I could walk up to this computer, and I could say--

52
00:02:43,488 --> 00:02:53,312
我先定义一个函数 (INTEGERS-FROM N)
how about we'll define the stream of integers starting with some number N,

53
00:02:54,240 --> 00:02:57,136
用于生成一个从N开始的正整数流
the stream of positive integers starting with some number n.

54
00:03:00,360 --> 00:03:19,168
也就是 (CONS-STREAM N (INTEGERS-FROM (+ N 1))))
And that's cons-stream of n onto the integers from one more.

55
00:03:24,416 --> 00:03:25,616
这样就我们要的全部整数
So there are the integers.

56
00:03:28,992 --> 00:03:31,500
现在我们用这个表示所有的整数 #TBD
Then I could say let's get all the integers.

57
00:03:34,570 --> 00:03:44,336
(DEFINE INTEGERS (INTEGERS-FROM 1))
define the stream of integers to be the integers starting with 1.

58
00:03:48,840 --> 00:03:50,944
如果现在我执行 (NTH-STREAM 20 INTEGERS)
And now if I say something like

59
00:03:54,416 --> 00:03:55,800
来查看第20个元素
what's the what's the 20th integer.

60
00:04:03,424 --> 00:04:05,536
得到21 因为索引是从0开始的
So it's 21 because we start counting at 0.

61
00:04:06,848 --> 00:04:08,880
或者我们来点更复杂的
Or I can do more complicated things.

62
00:04:09,450 --> 00:04:10,840
我再来定义一个谓词
Let me to define a little predicate here.

63
00:04:11,776 --> 00:04:18,512
谓词 NO-SEVEN 用来检测是否为7的倍数
How about define no-seven.

64
00:04:19,580 --> 00:04:20,752
它的判定标准是
It's going to test an integer,

65
00:04:21,792 --> 00:04:23,168
如果整数X不是7的倍数
and it's going to say it's not.

66
00:04:28,820 --> 00:04:33,968
我取X除7的余数
I take the remainder of x by 7,

67
00:04:36,624 --> 00:04:38,352
余数不应该为0
I don't get 0.

68
00:04:43,808 --> 00:04:49,776
这时用NO-SEVEN这个谓词
And then I could say define the integers with no sevens

69
00:04:50,224 --> 00:04:59,120
过滤全部的整数
take all the integers and filter them to have no sevens.

70
00:05:11,570 --> 00:05:13,344
这样我就得到了所有的
So now I've got the stream of all the integers

71
00:05:13,632 --> 00:05:15,056
不是7的倍数的整数构成的流
that are not divisible by seven.

72
00:05:16,490 --> 00:05:23,440
如果我问 这些不是7的倍数的整数中
So if I say what's the 100th integer

73
00:05:24,704 --> 00:05:26,480
的第100个数是多少？
and the list not divisible by seven,

74
00:05:26,864 --> 00:05:28,112
结果是117
I get 117.

75
00:05:28,320 --> 00:05:30,672
或者我也可以问
Or if I'd like to say well, I could say ah..

76
00:05:32,304 --> 00:05:34,384
这个流的所有元素都是些什么？
well, gee, what are all of them?

77
00:05:35,270 --> 00:05:40,352
我可以用(PRINT-STREAM NS) 来尝试打印这个流
So I could say print stream all these integers with no seven,

78
00:05:40,832 --> 00:05:41,792
它就会输出个不停
it goes off printing.

79
00:05:45,100 --> 00:05:47,070
你可能需要等上很久才能得到全部结果
You may have to wait a very long time to see them all.

80
00:05:52,670 --> 00:05:53,840
你可能会问了
Well, you can start asking, gee,

81
00:05:54,816 --> 00:05:57,008
这个数据结构
you know, is it really true that this data structure

82
00:05:58,288 --> 00:06:00,656
#TBD
with the integers is really all the integers?

83
00:06:01,100 --> 00:06:04,053
现在我画一个图来演示下刚写的那个程序
And let me draw a picture of that program I just wrote.

84
00:06:04,960 --> 00:06:10,570
这是我刚才键入的整数定义
Here's the, right, here's the definition of the integers again that I just typed in,

85
00:06:12,336 --> 00:06:15,984
它是一个由第一个整数和由下一个整数生成的流 所构成的序对
Right it's a cons of the first integer under the integer starting with the rest.

86
00:06:17,616 --> 00:06:19,770
现在我们画个图来看看它到底是什么样
Now, we can make a picture of that and see what it looks like.

87
00:06:22,720 --> 00:06:24,320
从概念上来说 这应该是一个盒子
Conceptually, what I have is a box

88
00:06:25,536 --> 00:06:27,184
这个盒子是(INTEGER-FROM N)
that's the integer starting with n.

89
00:06:27,420 --> 00:06:29,088
它接受一个参数N
It takes in some number n,

90
00:06:31,424 --> 00:06:32,976
然后返回一个流
and it's going to return a stream of--

91
00:06:35,024 --> 00:06:37,360
这个无穷流表示从N开始的所有整数
this infinite stream of all integers starting with n.

92
00:06:38,080 --> 00:06:38,736
#TBD
And what do I do?

93
00:06:38,752 --> 00:06:42,384
呃 这个是 INT-FROM 盒子
Well, this is an integers-from box.

94
00:06:45,070 --> 00:06:45,800
里面是什么样子呢？
What's it got in it?

95
00:06:45,800 --> 00:06:48,608
取得参数N之后
Well, it takes in this n,

96
00:06:52,272 --> 00:06:53,920
将其 +1
and it increments it.

97
00:06:57,952 --> 00:07:03,150
然后把结果递归地传递给另一个INT-FROM盒子
And then it puts the result into recursively another integer's from box.

98
00:07:06,870 --> 00:07:09,600
把这个盒子的结果和最初的N
It takes the result of that and the original n

99
00:07:10,240 --> 00:07:12,784
用CONS组合起来
and puts those together with a cons

100
00:07:13,392 --> 00:07:14,360
就形成了一个流
and forms a stream.

101
00:07:14,576 --> 00:07:17,264
我刚才写的那个过程 画出来就是这样子
So that's a picture of that program I wrote. And this is a ...

102
00:07:18,528 --> 00:07:20,320
我们看到的这类图像
Let's see. These kind of diagrams we first saw

103
00:07:20,784 --> 00:07:21,740
首先是由 Peter Henderson 提出的
drawn by Peter Henderson,

104
00:07:21,760 --> 00:07:23,320
也就是前面课程中绘图语言的发明者
the same guy who did the Escher language.

105
00:07:23,320 --> 00:07:24,752
我们把这种图叫做 Henderson 图
We call them Henderson diagrams.

106
00:07:25,376 --> 00:07:27,904
画这种图需要遵守一定的约定
And the convention here is that you put these things together.

107
00:07:28,530 --> 00:07:32,512
这些实线代表输出的流
And the solid lines are things coming out are streams,

108
00:07:33,024 --> 00:07:36,208
这些虚线则是初始的输入值
and dotted lines are initial values going in.

109
00:07:37,270 --> 00:07:39,024
而这个图描述的形状是——
So this one has the shape of--

110
00:07:39,408 --> 00:07:41,600
它会取一个整数作为初始值
it takes in some integer, some initial value,

111
00:07:41,808 --> 00:07:42,912
然后输出一个流
and outputs a stream.

112
00:07:46,352 --> 00:07:48,224
现在 你可能又要问了 #TBD
Again, you can ask. You know it's really

113
00:07:48,380 --> 00:07:50,880
那个INTEGERS的数据结构真的代表着全部的整数吗？
Is that data structure integers really all the integers?

114
00:07:52,090 --> 00:07:54,912
或者它只是经过了精心组织
Alright? Or is it is something that's cleverly arranged

115
00:07:54,940 --> 00:07:56,432
以至于我们总可以在其中找到
so that whenever you look for an integer

116
00:07:56,448 --> 00:07:57,240
我们需要的那个整数？
you find it there?

117
00:07:57,950 --> 00:07:59,744
这有点像个哲学问题 不是么？
That's sort of a philosophical question, right?

118
00:07:59,780 --> 00:08:01,696
#TBD
If something is there

119
00:08:02,144 --> 00:08:03,968
#TBD
whenever you look, is it really there or not?

120
00:08:04,450 --> 00:08:07,344
这就有点像
It's sort of the same sense in which

121
00:08:07,360 --> 00:08:09,420
你在银行中的存款那样
the money in your savings account is in the bank.

122
00:08:12,380 --> 00:08:12,640
好吧
Well

123
00:08:16,352 --> 00:08:17,488
我们再来看一个例子
let me do another example.

124
00:08:18,680 --> 00:08:20,704
第一节课刚开始
Umm, Gee, we started the course

125
00:08:20,720 --> 00:08:22,720
我们就讲了一个来自于亚历山大的算法
with an algorithm from Alexandria,

126
00:08:23,296 --> 00:08:25,800
来自亚历山大的 Heron 提出的
which was Heron of Alexandria's algorithm

127
00:08:25,824 --> 00:08:26,944
一个用于计算平方根的算法
for computing the square root.

128
00:08:28,470 --> 00:08:32,030
现在再来看一个 同样来自于亚力山大的算法
Let's take a look at another Alexandrian algorithm.

129
00:08:32,030 --> 00:08:35,088
这个被称为 Eratosthenes 算法的方法
This one is Eratosthenes method for

130
00:08:36,192 --> 00:08:38,448
用于计算所有的质数
for computing all of the primes.

131
00:08:41,169 --> 00:08:42,830
它被称为 Eratosthenes 筛法
It is called the Sieve of Eratosthenes.

132
00:08:42,830 --> 00:08:49,728
它是这样的 一开始
And what you do is you start out,

133
00:08:50,992 --> 00:08:52,288
先列举所有的整数
and you list all the integers,

134
00:08:52,608 --> 00:08:53,536
从 2 开始
say, starting with 2.

135
00:08:53,880 --> 00:08:55,040
然后取第一个整数
And then you take the first integer, and you say,

136
00:08:55,088 --> 00:08:56,670
然后你发现 哦 2是一个质数
and you say, oh, that's prime.

137
00:08:57,310 --> 00:08:58,352
然后你考察剩余的整数
And then you go look at the rest,

138
00:08:58,688 --> 00:09:00,880
划掉其中可以被 2 整除的数
and you cross out all the things divisible by 2.

139
00:09:01,520 --> 00:09:04,736
我把这个划掉 还有这个 这个
So I cross out this and this and this.

140
00:09:05,250 --> 00:09:06,352
有点费时
This takes a long time

141
00:09:06,368 --> 00:09:08,912
我要对所有的整数进行这样的操作
because I have to do it for all of the integers.

142
00:09:11,160 --> 00:09:15,392
我遍历整个整数表
So I go through the entire list of integers,

143
00:09:18,272 --> 00:09:20,944
划掉所有被 2 整除的数
crossing the ones divisible by 2.

144
00:09:22,112 --> 00:09:24,384
所有的整数都操作完后
And now when I finish with all of the integers,

145
00:09:24,784 --> 00:09:26,720
回过头再来看还剩些什么
I go back and look and say what am I left with?

146
00:09:27,040 --> 00:09:28,800
好的 我们继续 下一个数就是3了
Well, the first thing that starts there is 3.

147
00:09:29,330 --> 00:09:30,336
3也是一个质数
So 3 is a prime.

148
00:09:30,770 --> 00:09:33,056
现在 我会继续在剩下的数中
And now I go back through what I'm left with,

149
00:09:33,360 --> 00:09:35,072
划掉所有被3整除的数
and I cross out all the things divisible by 3.

150
00:09:35,080 --> 00:09:43,808
划掉 9、15、21、27、33 等等
So let's see, 9 and 15 and 21 and 27 and 33 and so on.

151
00:09:44,336 --> 00:09:45,120
我就不往下划了
I won't finish.

152
00:09:45,350 --> 00:09:46,528
然后看看我们还剩下什么
Then I see what I'm left with.

153
00:09:47,250 --> 00:09:49,840
而下一个就是5了
And the next one I have is 5.

154
00:09:50,496 --> 00:09:52,048
我又遍历剩下的数
Now I can through the rest,

155
00:09:52,432 --> 00:09:54,512
我找到第一个能被5整除的数
and I find the first one that's divisible by 5.

156
00:09:54,540 --> 00:09:57,616
我把剩下的能被 5 整除的数都划掉
I cross out from the remainder all the ones that are divisible by 5.

157
00:09:58,352 --> 00:09:59,248
做完这个之后
And I did that,

158
00:09:59,824 --> 00:10:01,890
下一个数就是7
and then I go through and find 7.

159
00:10:01,890 --> 00:10:02,720
再遍历剩下的数
Go through all the rest,

160
00:10:02,760 --> 00:10:03,952
划掉所有被 7 整除的数
cross out things divisible 7,

161
00:10:03,984 --> 00:10:05,470
然后一直这样下去
and I keep doing that forever.

162
00:10:06,810 --> 00:10:07,408
全部结束的时候
And when I'm done,

163
00:10:07,408 --> 00:10:09,104
我也就得到了所有的质数
what I'm left with is a list of all the primes.

164
00:10:09,904 --> 00:10:13,312
这就是 Eratosthenes 筛法
So that's the Sieve of Eratosthenes.

165
00:10:15,430 --> 00:10:17,696
我们来看下实际代码
Let's look at it as a computer program.

166
00:10:17,930 --> 00:10:19,856
这个过程命名为 SIEVE
It's a procedure called sieve.

167
00:10:27,910 --> 00:10:29,408
这是我刚才的操作的代码表示
Now, I just write what I did.

168
00:10:30,336 --> 00:10:34,480
SIEVE过程 以一个流 S 为参数
I'll say to sieve some stream s.

169
00:10:38,770 --> 00:10:39,936
返回一个新的流
I'm going to build a stream

170
00:10:40,272 --> 00:10:41,840
新的流的头部分 就是流 S 的头部分
whose first element is the head of this.

171
00:10:41,870 --> 00:10:44,432
回忆一下 我总是取剩下的数中的第一个
Remember, I always found the first thing I was left with,

172
00:10:44,912 --> 00:10:48,752
而尾部分则是把流 S 的尾部分
and the rest of it is the result of taking the tail of S,

173
00:10:51,088 --> 00:10:55,328
过滤掉所有能被 S 头部分整除的数
filtering it to throw away all the things that are divisible by the head of S,

174
00:10:56,416 --> 00:10:57,568
然后再对结果筛选
and now sieving the result.

175
00:10:59,020 --> 00:11:00,096
这个代码就是这样
That's just what I did.

176
00:11:01,980 --> 00:11:04,688
现在 为了得到由质数构成的无穷流
And now to get the infinite stream of times,

177
00:11:05,024 --> 00:11:06,900
我们对从2开始的整数流进行 SIEVE
we just sieve all the integers starting from 2.

178
00:11:14,920 --> 00:11:15,568
我们来实践一下
Let's try that.

179
00:11:16,300 --> 00:11:18,304
实际上 我们可以在计算机中运行
We can actually do it.

180
00:11:19,760 --> 00:11:22,128
我希望我已经预先输入过 SIEVE 的定义了
I typed in the definition of sieve before, I hope,

181
00:11:22,864 --> 00:11:24,064
所以我可以定义
so I can say something like

182
00:11:24,928 --> 00:11:33,456
我可以把 PRIMES 定义为
define the primes to be

183
00:11:34,640 --> 00:11:41,456
(SIEVE (INTEGERS-FROM 2))
the result of sieving the integers starting with 2.

184
00:11:46,760 --> 00:11:48,100
现在我就得到了质数构成的表
So now I've got this list of primes.

185
00:11:48,100 --> 00:11:50,990
这样就得到了所有的质数 对吧？
That's all of the primes, right?

186
00:11:50,990 --> 00:11:53,520
比如我可以问 第20个质数是什么？
So, if for example, what's the 20th prime in that list?

187
00:12:00,736 --> 00:12:01,680
结果是73
73.

188
00:12:02,540 --> 00:12:03,344
那个短促的停顿
See, and that little pause,

189
00:12:03,360 --> 00:12:04,928
这就是在我向它询问第20个元素时
it was only at the point

190
00:12:04,944 --> 00:12:07,680
它才进行实际的计算
when I started asking for the 20th prime is that it started computing.

191
00:12:10,370 --> 00:12:11,296
在这里 我也可以要求
Or I can say here

192
00:12:13,808 --> 00:12:14,880
打印所有的质数
Or I can say here let's look at all of the primes.

193
00:12:22,640 --> 00:12:24,400
解释器就开始计算并打印所有的质数
And there it goes computing all of the primes.

194
00:12:25,350 --> 00:12:27,616
如果想要完整打印的话 得花上好一会儿
Of course, it will take a while again if I want to look at all of them,

195
00:12:27,792 --> 00:12:28,570
所以先把它停掉
so let's stop it.

196
00:12:32,030 --> 00:12:33,130
现在我用图形来表示这个过程
Let me draw you a picture of that.

197
00:12:33,130 --> 00:12:34,176
我已经画好了
Well, I've got a picture of that.

198
00:12:34,890 --> 00:12:36,192
这个过程的图形应该是什么样子呢？
What's that program really look like?

199
00:12:37,900 --> 00:12:39,776
用这类图形的约定来说
Again, some practice with these diagrams,

200
00:12:39,824 --> 00:12:40,544
我有一个叫 SIEVE 的盒子
I have a sieve box.

201
00:12:42,610 --> 00:12:43,560
它是如何运作的呢？
How does sieve work?

202
00:12:43,560 --> 00:12:44,810
它接收一个流作为输入
It takes in a stream.

203
00:12:48,850 --> 00:12:50,592
head 和 tail 分开
It splits off the head from the tail.

204
00:12:50,870 --> 00:12:53,264
sieve盒子输出的也是一个流，第一个元素就是head
And the first thing that's going to come out of the sieve is the head of the original stream.

205
00:12:53,488 --> 00:12:54,976
sieve盒子输出的也是一个流，第一个元素就是head
And the first thing that's going to come out of the sieve is the head of the original stream.

206
00:12:58,208 --> 00:13:00,928
这个head也还用在了filter这里
Then it also takes the head and uses that.

207
00:13:02,550 --> 00:13:03,504
这里下面，取得tail流
It takes the stream.

208
00:13:03,850 --> 00:13:05,056
filter盒子过滤掉tail中所有整除head的数
It filters the tail and uses the head to filter for nondivisibility.

209
00:13:05,552 --> 00:13:08,336
filter盒子过滤掉tail中所有整除head的数
It filters the tail and uses the head to filter for nondivisibility.

210
00:13:09,536 --> 00:13:11,184
输出的流又作为一个新的sieve盒子的输入，这个sieve输出的流最后和head一起构成了最外层sieve输出的流
It takes the result of nondivisibility and puts it through another sieve box and puts the result together.

211
00:13:11,248 --> 00:13:13,120
输出的流又作为一个新的sieve盒子的输入，这个sieve输出的流最后和head一起构成了最外层sieve输出的流
It takes the result of nondivisibility and puts it through another sieve box and puts the result together.

212
00:13:13,904 --> 00:13:15,130
输出的流又作为一个新的sieve盒子的输入，这个sieve输出的流最后和head一起构成了最外层sieve输出的流
It takes the result of nondivisibility and puts it through another sieve box and puts the result together.

213
00:13:15,130 --> 00:13:16,896
你也可以把sieve想像为一个过滤器，不过它是一个无穷递归的过滤器
So you can think of this sieve a filter, but notice that it's an infinitely recursive filter.

214
00:13:17,200 --> 00:13:19,232
你也可以把sieve想像为一个过滤器，不过它是一个无穷递归的过滤器
So you can think of this sieve a filter, but notice that it's an infinitely recursive filter.

215
00:13:19,650 --> 00:13:20,880
因为这个sieve盒子内部还有一个sieve，内层的sieve内部肯定还有一个sieve，无穷下去
Because inside the sieve box is another sieve box, and inside that is another sieve box and another sieve box.

216
00:13:21,520 --> 00:13:22,608
因为这个sieve盒子内部还有一个sieve，内层的sieve内部肯定还有一个sieve，无穷下去
Because inside the sieve box is another sieve box, and inside that is another sieve box and another sieve box.

217
00:13:23,376 --> 00:13:25,856
因为这个sieve盒子内部还有一个sieve，内层的sieve内部肯定还有一个sieve，无穷下去
Because inside the sieve box is another sieve box, and inside that is another sieve box and another sieve box.

218
00:13:27,130 --> 00:13:28,960
我们已经开始接触一些不得了的东西了
So you see we start getting some very powerful things.

219
00:13:28,960 --> 00:13:32,848
我们开始把 以信号处理观察现实的视角和lisp计算中的递归结合在一起
We're starting to mix this signal processing view of the world with things like recursion that come from computation.

220
00:13:33,904 --> 00:13:36,416
我们开始把 以信号处理观察现实的视角和lisp计算中的递归结合在一起
We're starting to mix this signal processing view of the world with things like recursion that come from computation.

221
00:13:37,424 --> 00:13:39,824
你们可以用它来做很多事
And there are all sorts of interesting things you can do that are like this.

222
00:13:40,970 --> 00:13:42,096
好的，有什么问题吗？
All right, any questions?

223
00:13:48,190 --> 00:13:49,168
没有，那我们休息一下
OK, let's take a break.

224
00:14:28,656 --> 00:14:32,096
我们已经了解了许多如何用流进行编程的例子
Well, we've been looking at a couple of examples of stream programming.

225
00:14:34,790 --> 00:14:39,216
那些盒子都有一个共同的特征
All the stream procedures that we've looked at so far have the same kind of character.

226
00:14:39,728 --> 00:14:41,328
那些盒子都有一个共同的特征
All the stream procedures that we've looked at so far have the same kind of character.

227
00:14:41,490 --> 00:14:43,632
我们总是递归地一次生成一个元素，再用cons-stream连接起来。因此我们必须一起思考生成流的过程
We've been writing these recursive procedures that kind of generate these stream elements one at a time and put them together in cons-streams. So we've been thinking a lot about generators.

228
00:14:44,160 --> 00:14:45,968
我们总是递归地一次生成一个元素，再用cons-stream连接起来。因此我们必须一起思考生成流的过程
We've been writing these recursive procedures that kind of generate these stream elements one at a time and put them together in cons-streams. So we've been thinking a lot about generators.

229
00:14:45,968 --> 00:14:45,984
我们总是递归地一次生成一个元素，再用cons-stream连接起来。因此我们必须一起思考生成流的过程
We've been writing these recursive procedures that kind of generate these stream elements one at a time and put them together in cons-streams. So we've been thinking a lot about generators.
我们总是递归地一次生成一个元素，再用cons-stream连接起来。因此我们必须一起思考生成流的过程
We've been writing these recursive procedures that kind of generate these stream elements one at a time and put them together in cons-streams. So we've been thinking a lot about generators.

230
00:14:45,984 --> 00:14:48,720
我们总是递归地一次生成一个元素，再用cons-stream连接起来。因此我们必须一起思考生成流的过程
We've been writing these recursive procedures that kind of generate these stream elements one at a time and put them together in cons-streams. So we've been thinking a lot about generators.

231
00:14:49,152 --> 00:14:50,864
我们总是递归地一次生成一个元素，再用cons-stream连接起来。因此我们必须一起思考生成流的过程
We've been writing these recursive procedures that kind of generate these stream elements one at a time and put them together in cons-streams. So we've been thinking a lot about generators.

232
00:14:50,928 --> 00:14:53,632
这里我们用另一种方式来思考流，不是那种需要沿着流一个逐个元素来思考，而是把流作为一个整体
There's another way to think about stream processing, and that's to focus not on programs that sort of process these elements as you walk down the stream, but on things that kind of process the streams all at once.

233
00:14:53,792 --> 00:14:54,784
这里我们用另一种方式来思考流，不是那种需要沿着流一个逐个元素来思考，而是把流作为一个整体
There's another way to think about stream processing, and that's to focus not on programs that sort of process these elements as you walk down the stream, but on things that kind of process the streams all at once.

234
00:14:55,210 --> 00:14:59,936
这里我们用另一种方式来思考流，不是那种需要沿着流一个逐个元素来思考，而是把流作为一个整体
There's another way to think about stream processing, and that's to focus not on programs that sort of process these elements as you walk down the stream, but on things that kind of process the streams all at once.

235
00:15:00,256 --> 00:15:05,680
这里我们用另一种方式来思考流，不是那种需要沿着流一个逐个元素来思考，而是把流作为一个整体
There's another way to think about stream processing, and that's to focus not on programs that sort of process these elements as you walk down the stream, but on things that kind of process the streams all at once.

236
00:15:07,180 --> 00:15:09,584
为了把意思表示清楚，我们来看两个过程
To show you what I mean, let me start by defining two procedures that will come in handy.

237
00:15:09,744 --> 00:15:11,500
为了把意思表示清楚，我们来看两个过程
To show you what I mean, let me start by defining two procedures that will come in handy.

238
00:15:12,410 --> 00:15:13,824
第一个过程是 add-streams，两以两个流s1 s2作为参数
The first one's called add streams. Add streams takes two streams: s1 and s2.

239
00:15:15,360 --> 00:15:18,256
第一个过程是 add-streams，两以两个流s1 s2作为参数
The first one's called add streams. Add streams takes two streams: s1 and s2.

240
00:15:18,816 --> 00:15:20,880
第一个过程是 add-streams，两以两个流s1 s2作为参数
The first one's called add streams. Add streams takes two streams: s1 and s2.

241
00:15:22,300 --> 00:15:24,672
生成一个新的流，其元素是两个流相应位置元素的和
And it's going to produce a stream whose elements are the are the corresponding sums. We just sort of add them element-wise.

242
00:15:24,992 --> 00:15:28,176
生成一个新的流，其元素是两个流相应位置元素的和
And it's going to produce a stream whose elements are the are the corresponding sums. We just sort of add them element-wise.

243
00:15:30,224 --> 00:15:31,888
生成一个新的流，其元素是两个流相应位置元素的和
And it's going to produce a stream whose elements are the are the corresponding sums. We just sort of add them element-wise.

244
00:15:32,970 --> 00:15:33,936
如果其中一个流是空的，我们就返回另一个流
If either stream is empty, we just return the other one.

245
00:15:33,936 --> 00:15:33,952
如果其中一个流是空的，我们就返回另一个流
If either stream is empty, we just return the other one.
如果其中一个流是空的，我们就返回另一个流
If either stream is empty, we just return the other one.

246
00:15:33,952 --> 00:15:35,440
如果其中一个流是空的，我们就返回另一个流
If either stream is empty, we just return the other one.

247
00:15:36,810 --> 00:15:38,960
否则，我们就构建一个新的流，head元素是两个参数head的和，然后再递归求tail部分
Otherwise, we're going to make a new stream whose head is the sum of the two heads and whose tail is the result of recursively adding the tails.

248
00:15:39,904 --> 00:15:42,960
否则，我们就构建一个新的流，head元素是两个参数head的和，然后再递归求tail部分
Otherwise, we're going to make a new stream whose head is the sum of the two heads and whose tail is the result of recursively adding the tails.

249
00:15:44,000 --> 00:15:44,880
否则，我们就构建一个新的流，head元素是两个参数head的和，然后再递归求tail部分
Otherwise, we're going to make a new stream whose head is the sum of the two heads and whose tail is the result of recursively adding the tails.

250
00:15:46,000 --> 00:15:48,624
否则，我们就构建一个新的流，head元素是两个参数head的和，然后再递归求tail部分
Otherwise, we're going to make a new stream whose head is the sum of the two heads and whose tail is the result of recursively adding the tails.

251
00:15:50,090 --> 00:15:52,736
这就是“逐个元素来思考”来表示的整个过程
So that will produce the element-wise sum of two streams.

252
00:15:53,150 --> 00:15:54,528
另一个过程是scale-stream
And then another useful thing to have around is scale stream.

253
00:15:55,488 --> 00:15:57,056
另一个过程是scale-stream
And then another useful thing to have around is scale stream.

254
00:15:57,500 --> 00:16:01,664
两个参数，c是一个常数，s是一个流，结果生成的流相当于是将流s整体缩放了c倍
Scale stream takes some constant number in a stream s and is going to produce the stream of elements of s multiplied by this constant.

255
00:16:04,112 --> 00:16:06,624
两个参数，c是一个常数，s是一个流，结果生成的流相当于是将流s整体缩放了c倍
Scale stream takes some constant number in a stream s and is going to produce the stream of elements of s multiplied by this constant.

256
00:16:07,184 --> 00:16:09,504
两个参数，c是一个常数，s是一个流，结果生成的流相当于是将流s整体缩放了c倍
Scale stream takes some constant number in a stream s and is going to produce the stream of elements of s multiplied by this constant.

257
00:16:09,710 --> 00:16:11,216
这个过程表述起来很简单，就是用map-stream和这个lambda对流s进行映射
And that's easy, that's just a map of the function of an element that multiplies it by the constant, and we map that down the stream.

258
00:16:12,208 --> 00:16:16,224
这个过程表述起来很简单，就是用map-stream和这个lambda对流s进行映射
And that's easy, that's just a map of the function of an element that multiplies it by the constant, and we map that down the stream.

259
00:16:16,352 --> 00:16:17,808
这个过程表述起来很简单，就是用map-stream和这个lambda对流s进行映射
And that's easy, that's just a map of the function of an element that multiplies it by the constant, and we map that down the stream.

260
00:16:20,064 --> 00:16:21,472
考虑清楚这两个例子的区别，现在我来具体用程序演示“将流作为整体来思考”到底是什么意思
So given those two, let me show you what I mean by programs that operate on streams all at once.

261
00:16:22,640 --> 00:16:24,368
考虑清楚这两个例子的区别，现在我来具体用程序演示“将流作为整体来思考”到底是什么意思
So given those two, let me show you what I mean by programs that operate on streams all at once.

262
00:16:24,704 --> 00:16:27,008
考虑清楚这两个例子的区别，现在我来具体用程序演示“将流作为整体来思考”到底是什么意思
So given those two, let me show you what I mean by programs that operate on streams all at once.

263
00:16:28,128 --> 00:16:28,736
我们来看这个
Let's look at this.

264
00:16:30,200 --> 00:16:30,928
假设这样
Suppose I write this.

265
00:16:31,680 --> 00:16:52,352
(DEFINE ONES (CONS-STREAM 1 ONES))
I say define--  I'll call it ones-- to be cons-stream of 1 onto ones.

266
00:16:54,860 --> 00:16:55,520
这是什么？
What's that?

267
00:16:56,950 --> 00:16:58,944
这是一个表示无穷个1的流，因为我们看到第一个元素是1
That's going to be an infinite stream of ones because the first thing is 1.

268
00:16:59,968 --> 00:17:01,440
这是一个表示无穷个1的流，因为我们看到第一个元素是1
That's going to be an infinite stream of ones because the first thing is 1.

269
00:17:03,330 --> 00:17:05,152
tail部分是ONES，ONES的head也是1，ONES的tail又是ONES，其head又是1，以此类推
And the tail of it is a thing whose first thing is 1 and whose tail is a thing whose first thing is 1 and so on and so on and so on.

270
00:17:05,552 --> 00:17:06,832
tail部分是ONES，ONES的head也是1，ONES的tail又是ONES，其head又是1，以此类推
And the tail of it is a thing whose first thing is 1 and whose tail is a thing whose first thing is 1 and so on and so on and so on.

271
00:17:07,630 --> 00:17:09,024
tail部分是ONES，ONES的head也是1，ONES的tail又是ONES，其head又是1，以此类推
And the tail of it is a thing whose first thing is 1 and whose tail is a thing whose first thing is 1 and so on and so on and so on.

272
00:17:09,120 --> 00:17:10,240
tail部分是ONES，ONES的head也是1，ONES的tail又是ONES，其head又是1，以此类推
And the tail of it is a thing whose first thing is 1 and whose tail is a thing whose first thing is 1 and so on and so on and so on.

273
00:17:10,528 --> 00:17:11,780
tail部分是ONES，ONES的head也是1，ONES的tail又是ONES，其head又是1，以此类推
And the tail of it is a thing whose first thing is 1 and whose tail is a thing whose first thing is 1 and so on and so on and so on.

274
00:17:11,780 --> 00:17:13,328
这就是无穷个1的流
So that's an infinite stream of ones.

275
00:17:15,130 --> 00:17:15,936
现在根据ONES，我再给出另一种定义整数的方式
And now using that, let me give you another definition of the integers.

276
00:17:16,128 --> 00:17:18,032
现在根据ONES，我再给出另一种定义整数的方式
And now using that, let me give you another definition of the integers.

277
00:17:19,130 --> 00:17:27,360
(DEFINE INTEGERS (CONS-STREAM 1 (ADD-STREAM INTEGERS ONES)))
We can define the integers to be-- well, the first integer we'll take to be 1, this cons-stream of 1 onto the element-wise sum onto add streams of the integers to ones.

278
00:17:28,240 --> 00:17:30,768
(DEFINE INTEGERS (CONS-STREAM 1 (ADD-STREAM INTEGERS ONES)))
We can define the integers to be-- well, the first integer we'll take to be 1, this cons-stream of 1 onto the element-wise sum onto add streams of the integers to ones.

279
00:17:32,752 --> 00:17:38,576
(DEFINE INTEGERS (CONS-STREAM 1 (ADD-STREAM INTEGERS ONES)))
We can define the integers to be-- well, the first integer we'll take to be 1, this cons-stream of 1 onto the element-wise sum onto add streams of the integers to ones.

280
00:17:40,224 --> 00:17:48,270
(DEFINE INTEGERS (CONS-STREAM 1 (ADD-STREAM INTEGERS ONES)))
We can define the integers to be-- well, the first integer we'll take to be 1, this cons-stream of 1 onto the element-wise sum onto add streams of the integers to ones.

281
00:17:55,100 --> 00:17:56,352
整数的第一个数是1，其余的数则是将整数全部加1
The integers are a thing whose first element is 1, and the rest of them you get by taking those integers and incrementing each one by one.

282
00:17:57,248 --> 00:17:59,984
整数的第一个数是1，其余的数则是将整数全部加1
The integers are a thing whose first element is 1, and the rest of them you get by taking those integers and incrementing each one by one.

283
00:18:00,880 --> 00:18:02,320
整数的第一个数是1，其余的数则是将整数全部加1
The integers are a thing whose first element is 1, and the rest of them you get by taking those integers and incrementing each one by one.

284
00:18:03,120 --> 00:18:06,144
整数的第一个数是1，其余的数则是将整数全部加1
The integers are a thing whose first element is 1, and the rest of them you get by taking those integers and incrementing each one by one.

285
00:18:06,640 --> 00:18:08,192
按这种方式，第二个整数就是第一个整数加1
So the second element of the integers is the first element of the integers incremented by one.

286
00:18:08,512 --> 00:18:11,968
按这种方式，第二个整数就是第一个整数加1
So the second element of the integers is the first element of the integers incremented by one.

287
00:18:13,920 --> 00:18:15,184
得到第三个整数的过程也和得到第二个整数的过程类似，就是一个不断加1的过程
And the rest of that is the next one, and the third element of that is the same as the first element of the tail of the integers incremented by one, which is the same as the first element of the original integers incremented by one and incremented by one again and so on.

288
00:18:15,200 --> 00:18:16,480
得到第三个整数的过程也和得到第二个整数的过程类似，就是一个不断加1的过程
And the rest of that is the next one, and the third element of that is the same as the first element of the tail of the integers incremented by one, which is the same as the first element of the original integers incremented by one and incremented by one again and so on.

289
00:18:16,624 --> 00:18:21,968
得到第三个整数的过程也和得到第二个整数的过程类似，就是一个不断加1的过程
And the rest of that is the next one, and the third element of that is the same as the first element of the tail of the integers incremented by one, which is the same as the first element of the original integers incremented by one and incremented by one again and so on.

290
00:18:22,512 --> 00:18:23,760
得到第三个整数的过程也和得到第二个整数的过程类似，就是一个不断加1的过程
And the rest of that is the next one, and the third element of that is the same as the first element of the tail of the integers incremented by one, which is the same as the first element of the original integers incremented by one and incremented by one again and so on.

291
00:18:25,088 --> 00:18:28,656
得到第三个整数的过程也和得到第二个整数的过程类似，就是一个不断加1的过程
And the rest of that is the next one, and the third element of that is the same as the first element of the tail of the integers incremented by one, which is the same as the first element of the original integers incremented by one and incremented by one again and so on.

292
00:18:28,864 --> 00:18:31,250
得到第三个整数的过程也和得到第二个整数的过程类似，就是一个不断加1的过程
And the rest of that is the next one, and the third element of that is the same as the first element of the tail of the integers incremented by one, which is the same as the first element of the original integers incremented by one and incremented by one again and so on.

293
00:18:35,240 --> 00:18:36,310
它居然可以运行，有点匪夷所思，
That looks pretty suspicious.

294
00:18:36,310 --> 00:18:37,472
这样的过程可以正常运行的关键在于延时求值
See, notice that it works because of delay.

295
00:18:38,128 --> 00:18:38,990
这样的过程可以正常运行的关键在于延时求值
See, notice that it works because of delay.

296
00:18:40,150 --> 00:18:41,280
我们来看这个ONES
See, this looks like-- let's take a look at ones.

297
00:18:42,368 --> 00:18:43,344
我们来看这个ONES
See, this looks like-- let's take a look at ones.

298
00:18:43,870 --> 00:18:45,920
这看起来根本不可能，我想知道ONES是什么，你却告诉我说把1和ONES连接在一起就是ONES
This looks like it couldn't even be processed because it's suddenly saying in order to know what ones is, I say it's cons-stream of something onto ones.

299
00:18:46,256 --> 00:18:47,632
这看起来根本不可能，我想知道ONES是什么，你却告诉我说把1和ONES连接在一起就是ONES
This looks like it couldn't even be processed because it's suddenly saying in order to know what ones is, I say it's cons-stream of something onto ones.

300
00:18:47,792 --> 00:18:48,960
这看起来根本不可能，我想知道ONES是什么，你却告诉我说把1和ONES连接在一起就是ONES
This looks like it couldn't even be processed because it's suddenly saying in order to know what ones is, I say it's cons-stream of something onto ones.

301
00:18:49,008 --> 00:18:50,912
这看起来根本不可能，我想知道ONES是什么，你却告诉我说把1和ONES连接在一起就是ONES
This looks like it couldn't even be processed because it's suddenly saying in order to know what ones is, I say it's cons-stream of something onto ones.

302
00:18:51,130 --> 00:18:55,250
它之所以可以运行是因为暗中隐藏的delay
The reason that works is because of that very sneaky hidden delay in there.

303
00:18:55,250 --> 00:19:00,290
关键是，cons-stream是只是一个缩写
Because what this really is, remember, cons-stream is just an abbreviation.

304
00:19:00,290 --> 00:19:08,785
实际是(CONS 1 (DELAY ONES))
This really is cons of 1 onto delay of ones.

305
00:19:12,140 --> 00:19:15,500
再来实际看一下
So how does that work?

306
00:19:15,500 --> 00:19:18,020
这里定义ONES
You say I'm going to define ones.

307
00:19:18,020 --> 00:19:20,700
首先我发现ONES是一个CONS
First I see what ones is supposed to be defined as.

308
00:19:20,700 --> 00:19:32,710
CAR部分是1，CDR部分则是一个计算的约定
Well, ones is supposed to be defined as a cons whose first part is 1 and whose second part is, well, it's a promise to compute something that I don't worry about yet.

309
00:19:32,710 --> 00:19:37,270
不用担心说ONES还没有被定义，你这里怎么可以写一个ONES
So it doesn't bother me that at the point I do this definition, ones isn't defined.

310
00:19:37,270 --> 00:19:40,670
将运行整个定义的时候，ONES就被定义了
Having run the definition now, ones is defined.

311
00:19:40,670 --> 00:19:44,920
所以当我再访问到这个部分时，ONES已经被定义过了
So that when I go and look at the tail of it, it's defined.

312
00:19:44,920 --> 00:19:46,590
这一点非常隐讳
It's very sneaky.

313
00:19:46,590 --> 00:19:48,470
下面整数的定义也是如此
And an integer is the same way.

314
00:19:48,470 --> 00:19:53,210
我可以在这里使用INTEGERS也是因为CONS-STREAM的缘故
I can refer to integers here because hidden way down-- because of this cons-stream.

315
00:19:53,210 --> 00:19:57,050
CONS-STREAM把1和剩下的部分连接起来
It's the cons-stream of 1 onto something that I don't worry that yet.

316
00:19:57,050 --> 00:20:02,570
所以我根本不用关注INTEGERS有没有定义的问题
So I don't look at it, and I don't notice that integers isn't defined at the point where I try and run the definition.

317
00:20:06,320 --> 00:20:12,430
这个定义好像还是不那么牢靠的样子，这里我们用图形来表示一下
OK, let me draw a picture of that integers thing because it still maybe seems a little bit shaky.

318
00:20:12,430 --> 00:20:15,020
怎么画呢？
What do I do?

319
00:20:15,020 --> 00:20:26,590
ONES这个流，作为输出进入一个加法器，进行流的加法
I've got the stream of ones, and that sort of comes in and goes into an adder that's going to be this add streams thing.

320
00:20:29,310 --> 00:20:35,760
输出是INTEGERS
And that goes in-- that's going to put out the integers.

321
00:20:40,760 --> 00:20:48,060
加法器另一个加数则是INTEGERS，返过来构成一个循环
And the other thing that goes into the adder here is the integer, so there's a little feedback loop.

322
00:20:48,060 --> 00:20:53,180
还需要在这里加一个初始值1才算完成
And all I need to start it off is someplace I've got a stick that initial 1.

323
00:20:57,100 --> 00:21:02,910
要是在1这里加上一个延时的器件，看起来就完全和信号处理是一回事
In a real signal processing thing, this might be a delay element with that was initialized to 1.

324
00:21:02,910 --> 00:21:07,860
当然也得除去ONES这个部分
But there's a picture of that ones program.

325
00:21:07,860 --> 00:21:17,360
如果你了解信号处理的话，你会发现这个图很像一个有穷状态的accumulator
And in fact, that looks a lot like-- if you've seen real signal block diagram things, that looks a lot like accumulators, finite state accumulators.

326
00:21:17,360 --> 00:21:28,440
我们可以稍加修改，就可以将其变成一个有穷状态的accumulator
And in fact, we can modify this a little bit to change this into something that integrates a stream or a finite state accumulator, however you like to think about it.

327
00:21:28,440 --> 00:21:45,700
把ONES换成一个流，INTEGERS就应该是这个流的积分
So instead of the ones coming in and getting out the integers, what we'll do is say there's a stream s coming in, and we're going to get out the integral of this, successive values of that, and it looks almost the same.

328
00:21:45,700 --> 00:21:54,260
还需要修改的一点就是，在S输入加法器之前，先将其乘以dt
The only thing we're going to do is when s comes in here, before we just add it in we're going to multiply it by some number dt.

329
00:21:57,680 --> 00:22:00,000
剩下的就不用改了
And now what we have here, this is exactly the same thing.

330
00:22:00,000 --> 00:22:04,020
用盒子包裹起来，就是一个积分器
We have a box, which is an integrator.

331
00:22:09,790 --> 00:22:19,980
对一个流S进行积分，这里的1可以换成一个积分的初始值
And it takes in a stream s, and instead of 1 here, we can put the additional value for the integral.

332
00:22:19,980 --> 00:22:25,270
这个看起来就非常像是信号处理了
And that one looks very much like a signal processing block diagram program.

333
00:22:25,270 --> 00:22:27,980
这里，还有一个程序来表示这个图
In fact, here's the procedure that looks exactly like that.

334
00:22:31,490 --> 00:22:34,010
对一个流进行积分
Find the integral of a stream.

335
00:22:34,010 --> 00:22:42,230
接收一个流s，一个初始值和dt，产生一个新的流表示积分
So an integral's going to take a stream and produce a new stream, and it takes in an initial value and some time constant.

336
00:22:42,230 --> 00:22:43,040
然后呢？
And what do we do?

337
00:22:43,040 --> 00:22:49,400
内部定义一个流int，将其命名的原因在于可以回调它构成一个循环
Well, we internally define this thing int, and we make this internal name so we can feed it back, loop it around itself.

338
00:22:49,400 --> 00:23:01,280
这个int流初始值是initial-value
And int is defined to be something that starts out at the initial value, and the rest of it is gotten by adding together.

339
00:23:01,280 --> 00:23:06,880
剩下的则是将s缩放dt倍，和int相加
We take our input stream, scale it by dt, and add that to int.

340
00:23:06,880 --> 00:23:10,690
最后我们返回流int
And now we'll return from all that the value of integral is this thing int.

341
00:23:10,690 --> 00:23:15,920
我们为int命名是为了在int内部可以引用int
And we use this internal definition syntax so we could write a little internal definition that refers to itself.

342
00:23:21,880 --> 00:23:23,710
我们还可以做的更多
Well, there are all sorts of things we can do.

343
00:23:23,710 --> 00:23:25,500
来看这个
Let's try this one.

344
00:23:25,500 --> 00:23:26,895
斐波那契数
how about the Fibonacci numbers.

345
00:23:26,895 --> 00:23:32,625
定义FIBS
You can say define fibs.

346
00:23:36,350 --> 00:23:37,985
斐波那契数是什么呢？
Well, what are the Fibonacci numbers?

347
00:23:37,985 --> 00:23:50,090
从0开始，下一个是1
They're something that starts out with 0, and the next one is 1.

348
00:23:56,260 --> 00:24:11,000
剩下的就是FIBS和FIBS的tail的和
And the rest of the Fibonacci numbers are gotten by adding the Fibonacci numbers to their own tail.

349
00:24:17,570 --> 00:24:20,580
这样来定义斐波那契数
There's a definition of the Fibonacci numbers.

350
00:24:20,580 --> 00:24:21,430
这是如何运作的呢？
How does that work?

351
00:24:21,430 --> 00:24:31,870
假如开始计算斐波那契数，第一个是0，第二个是1
Well, we start off, and someone says compute for us the Fibonacci numbers, and we're going to tell you it starts out with 0 and 1.

352
00:24:35,790 --> 00:24:45,830
剩下的是两个流的和，一个流是FIBS本身，另一个是FIBS的tail
And everything after the 0 and 1 is gotten by summing two streams. One is the fibs themselves, and the other one is the tail of the fibs.

353
00:24:48,870 --> 00:24:58,360
现在的定义中，我已经能看到FIBS是以0,1开始 FIBS的tail则应该以1开始
So if I know that these start out with 0 and 1, I know that the fibs now start out with 0 and 1, and the tail of the fibs start out with 1.

354
00:24:58,360 --> 00:25:06,300
这样，FIBS的第三个数就应该是0+1=1，这里写上1，这是也写上1
So as soon as I know that, I know that the next one here is 0 plus 1 is 1, and that tells me that the next one here is 1 and the next one here is 1.

355
00:25:06,300 --> 00:25:09,390
知道了这些之后，下一个就是2
And as soon as I know that, I know that the next one is 2.

356
00:25:09,390 --> 00:25:11,700
这里和那里就写上2
So the next one here is 2 and the next one here is 2.

357
00:25:11,700 --> 00:25:12,950
下一个是3
And this is 3.

358
00:25:14,720 --> 00:25:18,530
这里就是3，这下面就是5了
This one goes to 3, and this is 5.

359
00:25:18,530 --> 00:25:21,500
非常精妙的定义
So it's a perfectly sensible definition.

360
00:25:21,500 --> 00:25:22,830
用不了一行
It's a one-line definition.

361
00:25:22,830 --> 00:25:30,150
我也可以把这个定义写到解释器里，然后要求输出FIBS，斐波那契数就开始刷屏了
And again, I could walk over to the computer and type that in, exactly that, and then say print stream the Fibonacci numbers, and they all come flying out.

362
00:25:32,790 --> 00:25:36,810
到了这里，相信我们对递归又多了一些理解
See, this is a lot like learning about recursion again.

363
00:25:36,810 --> 00:25:45,160
过程可以递归地定义，类似地数据对象也可以递归地定义
Instead of thinking that recursive procedures, we have recursively defined data objects.

364
00:25:45,160 --> 00:25:53,090
想想也比较合理，因为我们早就了解了过程与数据之间没有明显的界限
But that shouldn't surprise you at all, because by now, you should be coming to really believe that there's no difference really between procedures and data.

365
00:25:53,090 --> 00:25:58,210
具体地来讲，流也是由过程来实现的，只不过出于抽象的原因我们用流的时候并不想象的那么清楚罢了
In fact, in some sense, the underlying streams are procedures sitting there, although we don't think of them that way.

366
00:25:58,210 --> 00:26:03,630
因此，存在递归的过程，有递归的数据也就不足为怪了
So the fact that we have recursive procedures, well, then it should be natural that we have recursive data, too.

367
00:26:07,840 --> 00:26:09,720
非常和谐
OK, well, this is all pretty neat.

368
00:26:09,720 --> 00:26:14,990
不幸地是，流并非什么问题都能解决
Unfortunately, there are problems that streams aren't going to solve.

369
00:26:14,990 --> 00:26:17,580
我举个例子
Let me show you one of them.

370
00:26:17,580 --> 00:26:36,390
假如我们构建了模拟计算机来求解微分方程，比如 y' = y^2，还需要些初始值
See, in the same way, let's imagine that we're building an analog computer to solve some differential equation like, say, we want to solve the equation y prime dy dt is y squared, and I'm going to give you some initial value.

371
00:26:36,390 --> 00:26:38,030
y(0) = 1
I'll tell you y of 0 equals 1.

372
00:26:41,060 --> 00:26:43,690
dt = .0001
Let's say dt is equal to something.

373
00:26:46,770 --> 00:26:51,040
很久之间就有人构建模拟计算机来解决这类问题
Now, in the old days, people built analog computers to solve these kinds of things.

374
00:26:51,040 --> 00:26:53,020
原理非常简单
And the way you do that is really simple.

375
00:26:53,020 --> 00:27:03,055
先拿一个积分器
You get yourself an integrator, like that one, an integrator box.

376
00:27:03,055 --> 00:27:08,530
初始值是1
And we put in the initial value y of 0 is 1.

377
00:27:08,530 --> 00:27:13,890
还差一个输入和一个输出，输出的结果就是y
And now if we feed something in and get something out, we'll say, gee, what we're getting out is the answer.

378
00:27:13,890 --> 00:27:21,490
输入的是y的导数，在这是y' = y^2
And what we're going to feed in is the derivative, and the derivative is supposed to be the square of the answer.

379
00:27:21,490 --> 00:27:42,910
所以这里使用square进行map，返回去作为这里的输入，这就是用来求解这个微分方程的图
So if we take these values and map using square, and if I feed this around, that's how I build a block diagram for an analog computer that solves this differential equation.

380
00:27:42,910 --> 00:27:47,230
现在我们用代码来表示下这个过程
Now, what we'd like to do is write a stream program that looks exactly like that.

381
00:27:47,230 --> 00:27:49,390
这个图究竟表示的是什么呢？
And what do I mean exactly like that?

382
00:27:49,390 --> 00:28:13,790
y可以这样来定义，就是对dy进行积分，初始值是1，间隔是.0001
Well, I'd say define y to be the integral of dy starting at 1 with 0.001 as a time step.

383
00:28:13,790 --> 00:28:16,805
接下来
And I'd like to say that says this.

384
00:28:16,805 --> 00:28:20,850
来表示y' = y^2
And then I'd like to say, well, dy is gotten by mapping the square along y.

385
00:28:20,850 --> 00:28:33,510
dy就定义为(MAP SQUARE Y)
So define dy to be map square along y.

386
00:28:33,510 --> 00:28:41,410
这就是使用流对整个图的解释，不幸的是，并不能运行
So there's a stream description of this analog computer, and unfortunately, it doesn't work.

387
00:28:41,410 --> 00:28:51,190
你可以看到这为什么不行，因为这个定义y的地方，是dy的积分，额，dy是什么
And you can see why it doesn't work because when I come in and say define y to be the integral of dy, it says, oh, the integral of y-- huh?

388
00:28:51,190 --> 00:28:53,710
没定义啊
Oh, that's undefined.

389
00:28:53,710 --> 00:28:58,770
所以我得先定义dy
So I can't write this definition before I've written this one.

390
00:28:58,770 --> 00:29:03,580
另一方面，如果先定义了dy，又会发现(MAP SQUARE Y)
On the other hand, if I try and write this one first, it says, oh, I define y to be the map of square along y?

391
00:29:03,580 --> 00:29:05,770
y也没有定义
Oh, that's not defined yet.

392
00:29:05,770 --> 00:29:11,580
这个不能先写，那个也不能，没法玩儿了
So I can't write this one first, and I can't write that one first. So I can't quite play this game.

393
00:29:17,560 --> 00:29:20,460
有没有什么解决办法呢？
Well, is there a way out?

394
00:29:20,460 --> 00:29:22,200
所幸的是这可以解决
See, we can do that with ones.

395
00:29:22,200 --> 00:29:34,770
这边，我们可以用ONES来定义ONES是因为CONS-STREAM中ONES可以延时求值
See, over here, we did this thing ones, and we were able to define ones in terms of ones because of this delay that was built inside because cons-stream had a delay.

396
00:29:34,770 --> 00:29:36,070
巧妙在什么地方呢？
Now, why's it sensible?

397
00:29:36,070 --> 00:29:40,730
为什么CONS-STREAM增加了DELAY就变得巧妙了呢？
Why's it sensible for cons-stream to be built with this delay?

398
00:29:40,730 --> 00:29:45,950
原因在于CONS-STERAM这样做之后就完全不用关心TAIL的部分了
The reason is that cons-stream can do a useful thing without looking at its tail.

399
00:29:45,950 --> 00:29:54,870
只用关心我把1和什么东西连接在一起了，而且那个东西以1开始
See, if I say this is cons-stream of 1 onto something without knowing anything about something, I know that the stream starts off with 1.

400
00:29:54,870 --> 00:29:57,910
CONS-STREAM就巧妙在这里
That's why it was sensible to build something like cons-stream.

401
00:29:59,960 --> 00:30:06,320
增加了一个DELAY，就可以进行自引用的定义了
So we put a delay in there, and that allows us to have this sort of self-referential definition.

402
00:30:06,320 --> 00:30:08,190
INTEGRAL也可以用这种方式来解决
Well, integral is a little bit the same way.

403
00:30:08,190 --> 00:30:17,580
我们回头再看看INTEGRAL的定义
See, notice for an integral, I can-- let's go back and look at integral for a second.

404
00:30:17,580 --> 00:30:28,970
求积分的时候，只需要关心我们从initial-value开始积分，并不需要了解整个流
See, notice integral, it makes sense to say what's the first thing in the integral without knowing the stream that you're integrating.

405
00:30:28,970 --> 00:30:33,140
因为积分结果的第一个元素肯定是initial-value
Because the first thing in the integral is always going to be the initial value that you're handed.

406
00:30:33,140 --> 00:30:37,090
integral的内部就是cons-stream实现的
So integral could be a procedure like cons-stream.

407
00:30:37,090 --> 00:30:46,710
我们可以这样定义，甚至不用知道要积分的流是什么，只需要知道初始值是什么就行了
You could define it, and then even before it knows what it's supposed to be integrating, it knows enough to say what its initial value is.

408
00:30:46,710 --> 00:30:58,430
INTEGRAL还可以修改地更为精妙，以一个初始值和一个流进行积分，我甚至不用关心这个流是什么，直到积分的时候再来查看这个流
So we can make a smarter integral, which is aha, you're going to give me a stream to integrate and an initial value, but I really don't have to look at that stream that I'm supposed to integrate until you ask me to work down the stream.

409
00:30:58,430 --> 00:31:03,710
换句话说，这个INTEGRAL就像CONS-STREAM一样，被积分的流延时求值
In other words, integral can be like cons-stream, and you can expect that there's going to be a delay around its integrand.

410
00:31:03,710 --> 00:31:05,610
我们这样修改
And we can write that.

411
00:31:05,610 --> 00:31:07,650
来看这个过程
Here's a procedure that does that.

412
00:31:07,650 --> 00:31:17,110
改动的并不多，只是这里的s变成了delay-s，一个经过DELAY的流
Another version of integral, and this is almost like the previous one, except the stream it's going to get in is going to expect to be a delayed object.

413
00:31:17,110 --> 00:31:18,850
这个INTEGRAL又是怎么运作的呢？
And how does this integral work?

414
00:31:18,850 --> 00:31:32,300
内部还是一个CONS-STREAM，初始值就是initial-value，这里还要记住，delay-s是一个被DELAY过的流
Well, the little thing it's going to define inside of itself says on the cons-stream, the initial value is the initial value, but only inside of that cons-stream, and remember, there's going to be a hidden delay inside here.

415
00:31:34,950 --> 00:31:43,180
到了实际计算的时候，就用FORCE来查看流的实际内容
Only inside of that cons-stream will I start looking at what the actual delayed object is.

416
00:31:43,180 --> 00:31:45,970
第一个元素是initial-value
So my answer is the first thing's the initial value.

417
00:31:45,970 --> 00:31:59,260
如果有人想要查看流的实际内容是什么，就对延时对象应用FORCE，这里称其为s，然后做流的加法。整个过程有点像CONS-STREAM的感觉
If anybody now asks me for my tail, at that point, I'm going to force that delayed object-- and I'll call that s-- and I do the add streams. So this is an integral which is sort of like cons-stream.

418
00:31:59,260 --> 00:32:07,330
这个被积分的流是什么我根本不会去深究，直到你需要它的时候我才会去查看这个流
It's not going to actually try and see what you handed it as the thing to integrate until you look past the first element.

419
00:32:10,120 --> 00:32:27,090
如果这样的话，对于y' = y^2的问题也就解决了，只需要将Y的定义中dt改为(DELAY DY)
And if we do that and we can make this work, all we have to do here is say define y to the integral of delay of y, of delay of dy.

420
00:32:27,090 --> 00:32:35,280
Y就是对(DELAY Y)的积分，这样一来就可以了
So y is going to be the integral of delay of dy starting at 1, and now this will work.

421
00:32:35,280 --> 00:32:44,600
我输入Y的定义，要求一个什么的积分，具体是什么我也不关心，因为是一个延时对象
Because I type in the definition of y, and that says, oh, I'm supposed to use the integral of something I don't care about right now because it's a delay.

422
00:32:44,600 --> 00:32:46,320
这之后，再定义dy
And these things, now you define dy.

423
00:32:46,320 --> 00:32:47,550
没有问题了，因为y已经被定义了
Now, y is defined.

424
00:32:47,550 --> 00:32:51,700
所以在dy内部引用y并没有问题
So when I define dy, it can see that definition for y.

425
00:32:51,700 --> 00:32:52,840
一切都正常了
Everything is now started up.

426
00:32:52,840 --> 00:32:54,920
这两个流都有初始值
Both streams have their first element.

427
00:32:54,920 --> 00:33:00,590
当用SQUARE进行MAP的时候，查看后继的元素并不会引发什么问题，y和dy都被定义过了
And then when I start mapping down, looking at successive elements, both y and dy are defined.

428
00:33:00,590 --> 00:33:08,660
DELAY除了在CONS-STREAM之内还是很有用的不是吗？好的，大家有问题么
So there's a little game you can play that goes a little bit beyond just using the delay that's hidden inside streams. Questions?

429
00:33:13,178 --> 00:33:14,428
没有的话，休息一下吧
OK, let's take a break.

430
00:34:07,300 --> 00:34:14,320
在刚才休息的时候，我不知道你们有没有发现什么事不对劲
Well, just before the break, I'm not sure if you noticed it, but something nasty started to happen.

431
00:34:14,320 --> 00:34:34,389
我们通过流将程序表面表现的时间关系与实际在计算机中运行的时间关系分离开来，可以这样分离的原因在于流中的DELAY。在某些时候，我们为了利用这种优势，需要更多的DELAY
We've been going along with the streams and divorcing time in the programs from time in the computers, and all that divorcing got hidden inside the streams. And then at the very end, we saw that sometimes in order to really take advantage of this method, you have to pull out other delays.

432
00:34:34,389 --> 00:34:39,030
也就是要显式地来使用DELAY
You have to write some explicit delays that are not hidden inside that cons-stream.

433
00:34:39,030 --> 00:34:49,929
我已经用微分方程示例过了，如果你遇到非常复杂的系统，其中有很多自引用的循环，这时你需要在什么地方用DELAY就非常模糊了
And I did a very simple example with differential equations, but if you have some very complicated system with all kinds of self-loops, it becomes very, very difficult to see where you need those delays.

434
00:34:49,929 --> 00:34:55,550
假如你一不小心漏了一个，程序会出错而且你还不知道哪里出了错
And if you leave them out by mistake, it becomes very, very difficult to see why the thing maybe isn't working.

435
00:34:55,550 --> 00:35:08,690
我们显式使用DELAY获得的力量不足以克服大型的复杂的系统，因为它们并不能像流一样把DELAY隐藏起来，这非常混乱
So that's kind of mess, that by getting this power and allowing us to use delay, we end up with some very complicated programming sometimes, because it can't all be hidden inside the streams.

436
00:35:08,690 --> 00:35:11,036
有没有什么解决方案呢？
Well, is there a way out of that?

437
00:35:11,036 --> 00:35:13,480
所幸地是 有
Yeah, there is a way out of that.

438
00:35:13,480 --> 00:35:25,450
我可以改变整个语言，所有过程表现起来就像CONS-STREAM一样，因此每一个过程都对其参数延时求值
We could change the language so that all procedures acted like cons-stream, so that every procedure automatically has an implicit delay around its arguments.

439
00:35:25,450 --> 00:35:27,520
什么意思呢？
And what would that mean?

440
00:35:27,520 --> 00:35:32,210
就是说 你执行一个过程，并不马上对参数求值
That would mean when you call a procedure, the arguments wouldn't get evaluated.

441
00:35:32,210 --> 00:35:39,260
相反地，它们只有在需要被求值的时候才会被求值，因此它们可以不被求值的传递至其它过程中，一直这样传递下去
Instead, they'd only be evaluated when you need them, so they might be passed off to some other procedure, which wouldn't evaluate them either.

442
00:35:39,260 --> 00:35:42,150
过程传递的只是计算的约定而已
So all these procedures would be passing promises around.

443
00:35:42,150 --> 00:35:52,380
直到最后你需要查看某个值的时候，这才真正的求出这个部分的值
And then finally maybe when you finally got down to having to look at the value of something that was handed to a primitive operator would you actually start calling in all those promises.

444
00:35:52,380 --> 00:36:02,920
假如我们这样做了，就不需要显式的使用DELAY了，任何东西都有DELAY，它完全内建在语言之中了
If we did that, since everything would have a uniform delay, then you wouldn't have to write any explicit delays, because it would be automatically built into the way the language works.

445
00:36:02,920 --> 00:36:34,560
换句话说，技术上这是一种正则序求值的语言，和我们一直使用的应用序求值不同
Or another way to say that, technically what I'm describing is what's called-- if we did that, our language would be so-called normal-order evaluation language versus what we've actually been working with, which is called applicative order--  versus applicative-order evaluation.

446
00:36:34,560 --> 00:36:36,835
还记得应用序吧
And remember the substitution model for applicative order.

447
00:36:36,835 --> 00:36:43,590
就是你求值一个表达式的时候，每个部分都要预先计算出来
It says when you go and evaluate a combination, you find the values of all the pieces.

448
00:36:43,590 --> 00:36:47,600
参数具体求值之后，才代换入过程
You evaluate the arguments and then you substitute them in the body of the procedure.

449
00:36:47,600 --> 00:36:49,890
正则序则不是这样
Normal order says no, don't do that.

450
00:36:49,890 --> 00:36:58,640
代换的过程是一样的，不过并不先对参数求值，只是代换入了一个计算的约定
What you do is effectively substitute in the body of the procedure, but instead of evaluating the arguments, you just put a promise to compute them there.

451
00:36:58,640 --> 00:37:09,340
换句话说，这个表达式作为参数，就直接的把这个表达式代换入过程，并不进行求值直到需要求值的时候
Or another way to say that is you take the expressions for the arguments, if you like, and substitute them in the body of the procedure and go on, and never really simplify anything until you get down to a primitive operator.

452
00:37:09,340 --> 00:37:11,840
这就是所谓的正则序求值语言
So that would be a normal-order language.

453
00:37:11,840 --> 00:37:13,490
为什么不这样做呢？
Well, why don't we do that?

454
00:37:13,490 --> 00:37:18,940
这样做了之后，我们就获得了延时求值的所有优点
Because if we did, we'd get all the advantages of delayed evaluation with none of the mess.

455
00:37:18,940 --> 00:37:24,710
CONS也会是延时求值的，就和CONS-STREAM一样
In fact, if we did that and cons was just a delayed procedure, that would make cons the same as cons-stream.

456
00:37:24,710 --> 00:37:32,350
也不需要流了，因为列表会自动的像流那样，所有的数据对象都会被延时求值
We wouldn't need streams of all because lists would automatically be streams. That's how lists would behave, and data structures would behave that way.

457
00:37:32,350 --> 00:37:35,270
所有的，不是么？
Everything would behave that way, right?

458
00:37:35,270 --> 00:37:41,020
直到需要答案的时候才去实际的求值
You'd never really do any computation until you actually needed the answer.

459
00:37:41,020 --> 00:37:44,790
也不用担心这些显式的DELAY了
You wouldn't have to worry about all these explicit annoying delays.

460
00:37:44,790 --> 00:37:47,160
为什么不这样做呢？
Well, why don't we do that?

461
00:37:47,160 --> 00:37:49,230
首先，已经有人这样做过了
First of all, I should say people do do that.

462
00:37:49,230 --> 00:37:51,850
这是一类十分优雅的语言
There's some very beautiful languages.

463
00:37:51,850 --> 00:38:00,710
其中最为人称道的是一门名为Miranda的语言，是肯特大学的David Turner发明的
One of the very nicest is a language called Miranda, which is developed by David Turner at the University of Kent.

464
00:38:00,710 --> 00:38:01,930
它就是用这样的原理实现的
And that's how this language works.

465
00:38:01,930 --> 00:38:14,970
正则序求值，列表就像流一样。如果你用Miranda来解决像质数，八皇后这样的问题，写出来的过程看起来就很普通
It's a normal-order language and its data structures, which look like lists, are actually streams. And you write ordinary procedures in Miranda, and they do these prime things and eight queens things, just without anything special.

466
00:38:14,970 --> 00:38:17,790
DELAY已经内建入语言了
It's all built in there.

467
00:38:17,790 --> 00:38:19,040
但是这样也有不足之处
But there's a price.

468
00:38:21,190 --> 00:38:23,170
还记得我们为什么引入流了吗
Remember how we got here.

469
00:38:23,170 --> 00:38:27,480
我们把程序的时间和它实际执行的时间相分离
We're decoupling time in the programs from time in the machines.

470
00:38:27,480 --> 00:38:33,140
如果我们在所有地方都引入了DELAY，这也是我们现在正在做的
And if we put delay, that sort of decouples it everywhere, not just in streams. Remember what we're trying to do.

471
00:38:33,140 --> 00:38:39,300
编程就完全是单纯地描述解决方案的事了
We're trying to think about programming as a way to specify processes.

472
00:38:39,300 --> 00:38:47,030
我们完全放弃了对时间的控制，尽管语言变的优雅起来，但是牺牲了太多东西
And if we give up too much time, our language becomes more elegant, but it becomes a little bit less expressive.

473
00:38:47,030 --> 00:38:51,480
并且还有一些致命的缺陷
There are certain distinctions that we can't draw.

474
00:38:51,480 --> 00:38:53,980
其中之一就是迭代
One of them, for instance, is iteration.

475
00:38:53,980 --> 00:39:01,230
我们以前写过，迭代的来求阶乘
Remember this old procedure, iterative factorial, that we looked at quite a long time ago.

476
00:39:01,230 --> 00:39:12,120
fact-iter内部定义一个过程iter，它时刻记录着product和counter的状态，就这样迭代的求解
Iterative factorial had a thing, and it said there was an internal procedure, and there was a state which was a product and a counter, and we iterate that going around the loop.

477
00:39:12,120 --> 00:39:15,730
我们说这是一个迭代过程是因为它并没有把状态堆积给解释器
And we said that was an iterative procedure because it didn't build up state.

478
00:39:15,730 --> 00:39:23,900
因为状态时刻作为参数传递给了自身
And the reason it didn't build up state is because this iter that's called is just passing these things around to itself.

479
00:39:23,900 --> 00:39:31,660
也可以用代换具体的实践来看，这个迭代的过程，并没有状态堆积导致表达式增长的情况
Or in the substitution model, you could see in the substitution model that Jerry did, that in an iterative procedure, that state doesn't have to grow.

480
00:39:31,660 --> 00:39:34,840
因此这是一个迭代过程
And in fact, we said it doesn't, so this is an iteration.

481
00:39:34,840 --> 00:39:41,150
但是现在用正则序的思维来看
But now think about this exact same text if we had a normal-order language.

482
00:39:41,150 --> 00:39:45,650
这个迭代过程会变成什么样子
What would happen is this would no longer be an iterative procedure?

483
00:39:45,650 --> 00:39:52,330
如果你用正则序去进行代换，一直代换下去表达式就会变得越来越长
And if you really think about the details of the substitution model, which I'm not going to do here, this expression would grow.

484
00:39:52,330 --> 00:39:53,280
为什么会这样？
Why would it grow?

485
00:39:53,280 --> 00:39:58,080
因为iter递归的调用自己，把product代换为(* counter product)
It's because when iter calls itself, it calls itself with this product.

486
00:39:58,080 --> 00:40:02,510
在正则序里，这个乘法在这里并没有求值
If it's a normal-order language, that multiplication is not going to get done.

487
00:40:02,510 --> 00:40:06,670
传递并代换的只是这个乘法计算的约定
That's going to say I'm to call myself with a promise to compute this product.

488
00:40:06,670 --> 00:40:09,760
然后iter继续代换下去
And now iter goes around again.

489
00:40:09,760 --> 00:40:18,400
用这样的计算约定反复的递归代换
And I'm going to call myself with a promise to compute this product where now one of the one factors is a promise.

490
00:40:18,400 --> 00:40:19,430
代换
And I call myself again.

491
00:40:19,430 --> 00:40:31,790
如果你实际模拟下这个过程，你会清楚的看到状态的堆积，所有的约定直到最后才被计算
And if you write out the substitution model for that iterative process, you'll see exactly the same growth in state, all those promises that are getting remembered that have to get called in at the very end.

492
00:40:31,790 --> 00:40:36,980
所以正则序不能表达迭代的计算过程
So one of the disadvantages is that you can't really express iteration.

493
00:40:36,980 --> 00:40:54,610
或许这个问题有更深层次的理论上的原因，事实上许多写操作系统的人都很头疼这类问题。比如你用这类语言实现了一个文本编辑器
Maybe that's a little theoretical reason why not, but in fact, people who are trying to write real operating systems in these languages are running into exactly these types of problems. Like it's perfectly possible to implement a text editor in languages like these.

494
00:40:54,610 --> 00:41:10,230
但是你才用了一会儿，就会发现已经占用了3MB空间，充斥了未被计算的约定，这个应该是被称为拖尾问题，就因为不能表示迭代过程的缘故
But after you work a while, you suddenly have 3 megabytes of stuff, which is-- I guess they call them the dragging tail problem of people who are looking at these, of promises that sort of haven't been called in because you couldn't quite express an iteration.

495
00:41:10,230 --> 00:41:20,110
一个针对这种语言的研究方向就是如何采用一种编译技术来避免拖尾问题
And one of the research questions in these kinds of languages are figuring out the right compiler technology to get rid of the so-called dragging tails.

496
00:41:20,110 --> 00:41:23,940
非常困难
It's not simple.

497
00:41:23,940 --> 00:41:32,056
在不能表示迭代之外，正则序求值还有另一个缺点
But there's another kind of more striking issue about why you just don't go ahead and make your language normal order.

498
00:41:32,056 --> 00:41:42,000
很遗憾的是，正则序求值与赋值副作用是不相容的
And the reason is that normal-order evaluation and side effects just don't mix.

499
00:41:42,000 --> 00:41:45,350
它们在一起效果并不好
They just don't go together very well.

500
00:41:45,350 --> 00:42:00,400
你不能对有局部状态的对象同时应用正则序求值来分离时间延时求值
Somehow, you can't-- it's sort of you can't simultaneously go around trying to model objects with local state and change and at the same time do these normal-order tricks of de-coupling time.

501
00:42:00,400 --> 00:42:03,790
我来举一个非常简单的例子
Let me just show you a really simple example, very, very simple.

502
00:42:03,790 --> 00:42:07,520
假设语言是正则序求值
Suppose we had a normal-order language.

503
00:42:07,520 --> 00:42:09,550
例子是这样的
And I'm going to start out in this language.

504
00:42:09,550 --> 00:42:10,520
注意现在是正则序求值
This is now normal order.

505
00:42:10,520 --> 00:42:13,570
定义x是0
I'm going to define x to be 0.

506
00:42:13,570 --> 00:42:15,750
初始化的变量
It's just some variable I'll initialize.

507
00:42:15,750 --> 00:42:22,640
下面这个过程 id 比较有趣
And now I'm going to define this little funny function, which is an identity function.

508
00:42:22,640 --> 00:42:26,770
它用x来记录上一次id过程的参数值
And what it does, it keeps track of the last time you called it using x.

509
00:42:31,620 --> 00:42:36,760
这个过程最后只是返回了n，但是还把x赋值为n
So the identity of n just returns n, but it sets x to be n.

510
00:42:36,760 --> 00:42:42,580
最后再定义一个过程inc，也非常简单
And now I'll define a little increment function, which is a very little, simple scenario.

511
00:42:42,580 --> 00:42:47,230
假设在正则序求值的语言里，求值下面的表达式
Now, imagine I'm interacting with this in the normal-order language, and I type the following.

512
00:42:47,230 --> 00:42:54,190
(define y (inc (id 3)))，y的值应该是4
I say define y to be increment the identity function of 3, so y is going to be 4.

513
00:42:57,410 --> 00:42:59,520
x应该是多少呢？
Now, I say what's x?

514
00:42:59,520 --> 00:43:04,710
x应该是上一次我们执行过程id的参数值
Well, x should have been the value that was remembered last when I called the identity function.

515
00:43:04,710 --> 00:43:08,530
你可能会想，这里x应该是3，但是并不是这样
So you'd expect to say, well, x is 3 at this point, but it's not.

516
00:43:08,530 --> 00:43:17,000
因为我定义y的时候，只是一个计算的约定
Because when I defined y here, what I really defined y to be increment of a promise to do this thing.

517
00:43:17,000 --> 00:43:21,560
所以(id 3)的这部分并没有求值
So I didn't look at y, so that identity function didn't get run.

518
00:43:21,560 --> 00:43:25,320
我输入这个定义之后，x并没有改变，还是0
So if I type in this definition and look at x, I'm going to get 0.

519
00:43:28,360 --> 00:43:38,342
现在我输入y，要求对y求值，y就是4，(id 3)就在求值y的过程中被求值
Now, if I go look at y and say what's y, say y is 4, looking at y, that very active looking at y caused the identity function to be run.

520
00:43:38,342 --> 00:43:40,740
所以再来看x，x就应该是3
And now x will get remembered as 3.

521
00:43:40,740 --> 00:43:42,020
上面这里的x是0
So here x will be 0.

522
00:43:42,020 --> 00:43:43,280
下面这里是3
Here, x will be 3.

523
00:43:43,280 --> 00:43:57,100
这是一个非常简单的模拟场景，但是你可以观察到当你用正则序求值，甚至连变量的值都很难弄清楚
That's a tiny, little, simple scenario, but you can see what kind of a mess that's going to make for debugging interactive programs when you have normal-order evaluation.

524
00:43:57,100 --> 00:43:59,690
很令人迷惑
It's very confusing.

525
00:43:59,690 --> 00:44:09,780
深层次的原因，我想应该是所有都有了DELAY之后，我们也就完全脱离了时间的概念
But it's very confusing for a very deep reason, which is that the whole idea of putting in delays is that you throw away time.

526
00:44:09,780 --> 00:44:11,750
也因为如此我们可以处理一些无穷的情况
That's why we can have these infinite processes.

527
00:44:11,750 --> 00:44:17,790
脱离了时间之后，就没有必要非要等到哪一刻才开始运行，不是吗？
Since we've thrown away time, we don't have to wait for them to run, right?

528
00:44:17,790 --> 00:44:28,760
这样我就把程序所表示的时间顺序与实际运行的时间顺序分离开来。但是当我们谈及状态、赋值和改变，它们都和时间相关
We decouple the order of events in the computer from what we write in our programs. But when we talk about state and set and change, that's exactly what we do want control of.

529
00:44:28,760 --> 00:44:34,570
从根本上相矛盾
So it's almost as if there's this fundamental contradiction in what you want.

530
00:44:34,570 --> 00:44:42,410
这仿佛是一个哲学问题，从什么样的角度观察世界，构建什么样的模型
And that brings us back to these sort of philosophical mutterings about what is it that you're trying to model and how do you look at the world.

531
00:44:42,410 --> 00:44:47,140
有时这也被称为“函数式程序设计的争论”
Or sometimes this is called the debate over functional programming.

532
00:44:53,570 --> 00:45:00,440
所谓完全函数式的语言是那种完全没有副作用的语言
A so-called purely functional language is one that just doesn't have any side effects.

533
00:45:00,440 --> 00:45:06,360
没有副作用，没有赋值，也不用担心有什么糟糕的后果
Since you have no side effects, there's no assignment operator, so there are no terrible consequences of it.

534
00:45:06,360 --> 00:45:07,930
可以使用代换模型
You can use a substitution-like thing.

535
00:45:07,930 --> 00:45:15,050
程序更像是数学计算，而不是构建模型或对象
Programs really are like mathematics and not like models in the real world, not like objects in the real world.

536
00:45:15,050 --> 00:45:17,170
函数式语言有很多了不起的特性
There are a lot of wonderful things about functional languages.

537
00:45:17,170 --> 00:45:29,260
没有时间的概念，所以完全不用担心同步的问题。如果你把这些应用在并行算法上，就可以并行计算不同的部分
Since there's no time, you never have any synchronization problems. And if you want to put something into a parallel algorithm, you can run the pieces of that parallel processing any way you want.

538
00:45:29,260 --> 00:45:33,640
从来不担心同步问题，这几乎是与生俱来的
There's just never any synchronization to worry that, and it's a very congenial environment for doing this.

539
00:45:33,640 --> 00:45:35,450
代价是放弃了赋值
The price is you give up assignment.

540
00:45:39,060 --> 00:45:44,520
一些函数式编程的狂热分子会说，这点代价算不了什么
So an advocate of a functional language would say, gee, that's just a tiny price to pay.

541
00:45:44,520 --> 00:45:46,510
确实，在大部分情况下不用赋值也可以
You probably shouldn't use assignment most of the time anyway.

542
00:45:46,510 --> 00:45:54,190
如果用你用赋值，就得想办法用其它方式来解决原来用对象解决的问题
And if you just give up assignment, you can be in this much, much nicer world than this place with objects.

543
00:45:54,190 --> 00:45:56,300
有没有什么例子呢？
Well, what's the rejoinder to that?

544
00:45:56,300 --> 00:46:00,300
想想我们如何走到这一步的
Remember how we got into this mess.

545
00:46:00,300 --> 00:46:04,440
我们构造有独立状态的对象
We started trying to model things that had local state.

546
00:46:04,440 --> 00:46:06,840
还记得Jerry的随机数生成器吧
So remember Jerry's random number generator.

547
00:46:06,840 --> 00:46:14,080
随机数生成器内部有一个状态，根据这个状态计算下一个随机数，下下一个等等
There was this random number generator that had some little state in it to compute the next random number and the next random number and the next random number.

548
00:46:14,080 --> 00:46:21,050
我们可以将随机数生成与蒙特卡洛算法分离开来，因此赋值在这里就异常重要了
And we wanted to hide that state away from the Cesaro compute part process, and that's why we needed set.

549
00:46:21,050 --> 00:46:24,070
我们用模块化来封装状态
We wanted to package that stated modularly.

550
00:46:24,070 --> 00:46:27,560
使用函数式编程的程序员可能会说，“你搞错了”
Well, a functional programming person would say, well, you're just all wet.

551
00:46:27,560 --> 00:46:29,840
“我的意思是，你能写出另一种更具模块化的程序”
I mean, you can write a perfectly good modular program.

552
00:46:29,840 --> 00:46:33,250
“从另一种角度来思考模块化”
It's just you're thinking about modularity wrong.

553
00:46:33,250 --> 00:46:36,880
一直为生成一个又一个的随机数所烦恼
You're hung up in this next random number and the next random number and the next random number.

554
00:46:36,880 --> 00:46:39,880
为什么不写一个这样的程序
Why don't you just say let's write a program.

555
00:46:39,880 --> 00:46:44,445
写一个枚举器，生成一个无穷的随机数的流
Let's write an enumerator which just generates an infinite stream of random numbers.

556
00:46:49,010 --> 00:46:54,540
一次性就生成所有的随机数，而且还可以为其它地方使用
We can sort of have that stream all at once, and that's going to be our source of random numbers.

557
00:46:54,540 --> 00:47:06,880
如果你想的话，就可以把这个流接过来，到这个蒙特卡洛测试的过程
And then if you like, you can put that through some sort of processor, which is-- I don't know-- a Cesaro test, and that can do what it wants.

558
00:47:06,880 --> 00:47:28,140
输出的是一个流，其中是一连串的对PI的估计值
And what would come out of there would be a stream of successive approximations to pi.

559
00:47:28,140 --> 00:47:35,540
和前面讲的类似，这样用流的连接，可以“拖出“无限个随机数来计算蒙特卡洛测试
So as we looked further down this stream, we'd tug on this Cesaro thing, and it would pull out more and more random numbers.

560
00:47:35,540 --> 00:47:39,720
我们使用的随机数越多，最后对PI的估计值就越准
And the further and further we look down the stream, the better an approximation we'd get to pi.

561
00:47:39,720 --> 00:47:43,890
具体的计算过程还是一样的，只不过使用了另一种模块化的方式
And it would do exactly the same as the other computation, except we're thinking about the modularity different.

562
00:47:43,890 --> 00:47:49,400
我们假如一次性生成了所有的随机数
We're saying imagine we had all those infinite streams of random numbers all at once.

563
00:47:49,400 --> 00:47:53,860
这个过程的细节在书上有
You can see the details of this procedure in the book.

564
00:47:53,860 --> 00:48:03,280
相似地还有别的例子，我们也习惯于一次一次来，但完全可以不这么来想
Similarly, there are other things that we tend to get locked into on this one and that one and the next one and the next one, which don't have to be that way.

565
00:48:03,280 --> 00:48:08,900
我们来思考一下银行系统
Like you might think about like a banking system, which is a very simple idea.

566
00:48:08,900 --> 00:48:12,210
假设我们这里这个程序代表了银行帐户
Imagine we have a program that sort of represents a bank account.

567
00:48:18,810 --> 00:48:31,510
如果我们以信息传递的角度来看，银行帐户应该是一个对象，内部保存着局部状态balance金额
The bank account might have in it-- if we looked at this in a sort of message-passing view of the world, we'd say a bank account is an object that has some local state in there, which is the balance, say.

568
00:48:34,110 --> 00:48:48,560
如果一个用户发出交易申请，比如存钱，这个银行帐户就会用最新的balance金额作出回应
And a user using this system comes and sends a transaction request. So the user sends a transaction request, like deposit some money, and the bank account maybe-- let's say the bank account always responds with what the current balance is.

569
00:48:48,560 --> 00:48:54,350
比如我们存点钱，帐户就会返回存钱后总金额是多少
The user says let's deposits some money, and the bank account sends back a message which is the balance.

570
00:48:54,350 --> 00:48:59,150
用户发出信息，帐户反馈信息
And the user says deposit some more, and the bank account sends back a message.

571
00:48:59,150 --> 00:49:03,200
就随机数生成器一样，我们得用赋值才可以
And just like the random number generator, you'd say, gee, we would like to use set.

572
00:49:03,200 --> 00:49:09,570
帐户的内部保存了局部状态balance，因此就把用户的状态和帐户的状态分离开来
We'd like to have balance be a piece of local state inside this bank account because we want to separate the state of the user from the state of the bank account.

573
00:49:13,280 --> 00:49:16,420
这是从信息传递的角度来看
Well, that's the message-processing view.

574
00:49:16,420 --> 00:49:22,740
如果从流的角度来看，就不需要赋值或副作用之类
There's a stream view with that thing, which does the same thing without any set or side effects.

575
00:49:22,740 --> 00:49:31,180
我们不想任何有关局部状态的事
And the idea is again we don't think about anything having local state.

576
00:49:31,180 --> 00:49:38,640
可以认为银行帐户是一个处理一系列交易请求的东西
We think about the bank account as something that's going to process a stream of transaction requests.

577
00:49:38,640 --> 00:49:49,490
帐户不是一个处理信息的对象了，而是处理交易请求流的东西
So think about this bank account not as something that goes message by message, but something that takes in a stream of transaction requests like maybe successive deposit announced.

578
00:49:49,490 --> 00:49:55,940
比如1 2 2 4，连续的存钱交易
1, 2, 2, 4, those might be successive amounts to deposit.

579
00:49:55,940 --> 00:50:03,770
从帐户出来的流应该是1 3 5 9
And then coming out of it is the successive balances 1, 3, 5, 9.

580
00:50:03,770 --> 00:50:10,820
帐户没有局部状态，它只是一个流处理器
So we think of the bank account not as something that has state, but something that acts sort of on the infinite stream of requests.

581
00:50:10,820 --> 00:50:12,370
记住，这样想的话，就没有了时间的概念
But remember, we've thrown away time.

582
00:50:12,370 --> 00:50:30,010
如果这里有一个用户，我们把他的所有交易看做是无穷的流，帐户一次处理一个元素，所有的balance金额也作为一个流
So what we can do is if the user's here, we can have this infinite stream of requests being generated one at a time coming from the user and this transaction stream coming back on a printer being printed one at a time.

583
00:50:30,010 --> 00:50:39,560
如果在这里划一条线，用户从外面来看，根本不能分辨银行帐户到底有没有状态
And if we drew a little line here, right there to the user, the user couldn't tell that this system doesn't have state.

584
00:50:39,560 --> 00:50:42,660
因为它们对外表现是一样的
It looks just like the other one, but there's no state in there.

585
00:50:45,120 --> 00:50:53,835
哦，顺便提一个，这里有一个具体的代码实现 -- 假设我们只存钱
And by the way, just to show you, here's an actual implementation of this-- we'll call it make deposit account because you can only deposit.

586
00:50:53,835 --> 00:51:00,020
这个过程接受一个balance初始值和一个存钱交易流
It takes an initial balance and then a stream of deposits you might make.

587
00:51:00,020 --> 00:51:00,820
具体怎么做呢？
And what is it?

588
00:51:00,820 --> 00:51:18,300
很简单，只不过是用CONS-STREAM把初始金额和递归调用make-deposit-account的结果组合在一起，递归调用的时候，金额参数要加上第一次要存的钱，流参数变为交易流的TAIL
Well, it's just cons-stream of the balance onto make a new account stream whose initial balance is the old balance plus the first thing in the deposit stream and make deposit account works on the rest of which is the tail of the deposit stream.

589
00:51:18,300 --> 00:51:28,790
原来用面向对象解决的问题，我们用流就可以解决
So there's sort of a very typical message-passing, object-oriented thing that's done without side effects at all.

590
00:51:28,790 --> 00:51:32,250
很多地方都可以这样思考
There are very many things you can do this way.

591
00:51:32,250 --> 00:51:36,400
可能你会想了，我能不用赋值做所有的事情吗？
Well, can you do everything without assignment?

592
00:51:36,400 --> 00:51:40,050
可以只用纯函数式语言来编程吗？
Can everybody go over to purely functional languages?

593
00:51:40,050 --> 00:51:48,100
这个问题谁也说不清，好像有些地方用函数式编程不太妥当
Well, we don't know, but there seem to be places where purely functional programming breaks down.

594
00:51:48,100 --> 00:51:58,850
比如关于银行帐户的一个更复杂的例子，函数式也会有点吃力因为我们混入了共享的问题，这里两个用户共享一个帐户
Where it starts hurting is when you have things like this, but you also mix it up with the other things that we had to worry that, which are objects and sharing and two independent agents being the same.

595
00:51:58,850 --> 00:52:02,960
在这种情况下，假如你来扩展这个帐户
So under a typical one, suppose you want to extend this bank account.

596
00:52:02,960 --> 00:52:04,210
这是一个帐户
So here's a bank account.

597
00:52:12,220 --> 00:52:18,780
帐户取一个交易流，生成一个新的流
Bank accounts take in a stream of transaction requests and put out streams of, say, balances or responses to that.

598
00:52:18,780 --> 00:52:26,090
假如这个帐户是两个独立的用户共享的会怎么样
But suppose you want to model the fact that this is a joint bank account between two independent people.

599
00:52:26,090 --> 00:52:33,140
假设两个人Bill和Dave，共享一个帐户
So suppose there are two people, say, Bill and Dave, who have a joint bank account.

600
00:52:35,960 --> 00:52:36,850
怎么来建模呢？
How would you model this?

601
00:52:36,850 --> 00:52:45,880
Bill有一个交易流，Dave也有一个交易流，可以把这两个流合并在一起再输入帐户
Well, Bill puts out a stream of transaction requests, and Dave puts out a stream of transaction requests, and somehow, they have to merge into this bank account.

602
00:52:45,880 --> 00:53:01,190
所以我们只需要一个merge的过程，将这两个流合并为一个流就行
So what you might do is write a little stream processing thing called merge, which sort of takes these, merges them together, produces a single stream for the bank account.

603
00:53:01,190 --> 00:53:03,610
现在他们就共享一个帐户了
Now they're both talking to the same bank account.

604
00:53:03,610 --> 00:53:06,600
看起来不错，问题是怎么来实现merge
That's all great, but how do you write merge?

605
00:53:06,600 --> 00:53:09,730
merge根据什么来合并？
What's this procedure merge?

606
00:53:09,730 --> 00:53:12,760
而且要合并的合理
You want to do something that's reasonable.

607
00:53:12,760 --> 00:53:24,150
第一反应可能这样想，两个流依次一个一个取，但是如果突然Dave外出度假了两年会怎么样？
Your first guess might be to say, well, we'll take alternate requests from Bill and Dave. But what happens if suddenly in the middle of this thing, Dave goes away on vacation for two years?

608
00:53:24,150 --> 00:53:27,690
Bill的交易就完全被阻塞了
Then Bill's sort of stuck.

609
00:53:27,690 --> 00:53:29,750
你想要的是
So what you want to do is-- well, it's hard to describe.

610
00:53:29,750 --> 00:53:33,380
是一种公平的合并
What you want to do is what people call fair merge.

611
00:53:38,410 --> 00:53:46,010
这个所谓公平的合并应该是交替地一次处理一个，但是如果一个人没有了交易，应该继续去处理另一个人的交易
The idea of fair merge is it sort of should do them alternately, but if there's nothing waiting here, it should take one twice.

612
00:53:46,010 --> 00:53:48,450
你们可以注意到我完全没有谈论时间
Notice I can't even say that without talking about time.

613
00:53:51,300 --> 00:54:18,010
一个在函数式编程研究方面比较活跃的课题之一就是发明一种公平合并的方式，取代原来用面向对象开发的系统，避免赋值与状态带来的问题
So one of the other active researcher areas in functional languages is inventing little things like fair merge and maybe some others, which will take the places where I used to need side effects and objects and sort of hide them away in some very well-defined modules of the system so that all the problems of assignment don't sort of leak out all over the system but are captured in some fairly well-understood things.

614
00:54:20,780 --> 00:54:38,360
你们也看到了，我现在所触及的是计算机科学方面非常根本的一个问题，如何开发一种语言，使其可以延时求值同时又可以面向对象
More generally, I think what you're seeing is that we're running across what I think is a very basic problem in computer science, which is how to define languages that somehow can talk about delayed evaluation, but also be able to reflect this view that there are objects in the world.

615
00:54:38,360 --> 00:54:41,230
怎么样才能两者兼有之？
How do we somehow get both?

616
00:54:41,230 --> 00:54:43,040
想来这很困难
And I think that's a very hard problem.

617
00:54:43,040 --> 00:54:53,840
但是这个很困难的问题却和计算机科学的关系不大，它真正涉及的是两个看待世界不同的方式
And it may be that it's a very hard problem that has almost nothing to do with computer science, that it really is a problem having to do with two very incompatible ways of looking at the world.

618
00:54:53,840 --> 00:54:55,090
大家有问题吗？
OK, questions?

619
00:55:17,556 --> 00:55:25,890
你之前提到过，一旦引入了赋值，就不能使用代换模型了
AUDIENCE: You mentioned earlier that once you introduce assignment, the general rule for using the substitution model is you can't.

620
00:55:25,890 --> 00:55:27,570
除非你非常小心
Unless you're very careful, you can't.

621
00:55:27,570 --> 00:55:28,260
对的
PROFESSOR: Right.

622
00:55:28,260 --> 00:55:40,300
有什么方法或者什么原则来说明清楚这个“很小心”是怎么回事吗？
AUDIENCE: Is there a set of techniques or a set of guidelines for localizing the effects of assignment so that the very careful becomes defined?

623
00:55:40,300 --> 00:55:42,890
我不知道
PROFESSOR: I don't know.

624
00:55:42,890 --> 00:55:45,430
我想想
Let me think.

625
00:55:45,430 --> 00:55:51,480
当然，在实现DELAY中的memo-proc也使用了赋值，但是它被隐藏了起来
Well, certainly, there was an assignment inside memo proc, but that was sort of hidden away.

626
00:55:51,480 --> 00:55:53,480
因为它没有对结果造成其它的不同
It ended up not making any difference.

627
00:55:53,480 --> 00:56:00,390
部分原因之一在于一旦这个过程被求值，得到answer，answer就不会再变化了
Part of the reason for that is once this thing triggered that it had run and gotten an answer, that answer will never change.

628
00:56:00,390 --> 00:56:02,080
有点像一次赋值
So that was sort of a one-time assignment.

629
00:56:02,080 --> 00:56:11,250
所以如果你只用这种一次赋值并且它不再改变，我想应该不会有太大问题
So one very general thing you can do is if you only do what's called a one-time assignment and never change anything, then you can do better.

630
00:56:11,250 --> 00:56:18,490
还有一个问题在于merge -- 让我想想对不对
One of the problems in this merge thing, people have-- let me see if this is right.

631
00:56:18,490 --> 00:56:30,820
我认为有了公平合并这一技术，在其它的地方你都可以有效的来模拟赋值
I think it's true that with fair merge, with just fair merge, you can begin effectively simulating assignment in the rest of the language.

632
00:56:30,820 --> 00:56:39,520
这有点像你把要做的事转移到了外面 -- 我不知道这对于公平合并是否准确，但是对一些更广泛的事是适用的
It seems like anything you do to go outside-- I'm not quite sure that's true for fair merge, but it's true of a little bit more general things that people have been doing.

633
00:56:39,520 --> 00:56:47,970
所以可能真的实现了这种技术，突然你能用这种语言来做任何事，其实应该和你拥有了赋值一样也会遇到糟糕的情况
So it might be that any little bit you put in, suddenly if they allow you to build arbitrary stuff, it's almost as bad as having assignment altogether.

634
00:56:47,970 --> 00:56:51,590
这也是人们在研究的一个领域
But that's an area that people are thinking about now.

635
00:56:51,590 --> 00:57:04,730
在merge这一点我有点问题，如是Bill是一个过程，当我调用Bill的时候，Bill就应该来存款或者说构造一个元素来输入
AUDIENCE: I guess I don't see the problem here with merge if I call Bill, if Bill is a procedure, then Bill is going to increment the bank account or build the list that 's going to put in the next element.

636
00:57:04,730 --> 00:57:07,170
如果我调用Dave两次，他肯定也会存款两次
If I call Dave twice in a row, that will do that.

637
00:57:07,170 --> 00:57:09,350
所以何来的公平合并呢
I'm not sure where fair merge has to be involved.

638
00:57:09,350 --> 00:57:11,200
关键在于你得把这些当作真人一样
PROFESSOR: The problem is imagine these really as people.

639
00:57:11,200 --> 00:57:14,850
就是，这里有一个用户来操作帐户
See, here I have the user who's interacting with this bank account.

640
00:57:14,850 --> 00:57:17,070
请求一次，得到结果
Put in a request, get an answer.

641
00:57:17,070 --> 00:57:18,200
对
AUDIENCE: Right.

642
00:57:18,200 --> 00:57:24,220
但是如果我交替的来处理两个人的请求 AUDIENCE：为什么要交替着？
PROFESSOR: But if the only way I can process request is to alternate them from two people-- AUDIENCE: Well, why would you alternate them?

643
00:57:24,220 --> 00:57:25,070
为什么不呢？
PROFESSOR: Why don't I?

644
00:57:25,070 --> 00:57:26,140
嗯？
AUDIENCE: Yes.

645
00:57:26,140 --> 00:57:26,580
为什么要？
Why do you?

646
00:57:26,580 --> 00:57:27,640
假设这些是现实中的人，对吗？
PROFESSOR: Think of them as real people, right?

647
00:57:27,640 --> 00:57:29,280
这个人外出一年
This guy might go away for a year.

648
00:57:29,280 --> 00:57:35,480
你只能空守在帐户旁边就是不能处理两个请求，因为你还得等这个度假的人
And you're sitting here at the bank account window, and you can't put in two requests because it's waiting for this guy.

649
00:57:35,480 --> 00:57:37,380
为什么非得等他呢？
AUDIENCE: Why does it have to be waiting for one?

650
00:57:37,380 --> 00:57:39,110
因为这里是在计算一个函数
PROFESSOR: Because it's trying to compute a function.

651
00:57:39,110 --> 00:57:41,720
我必须定义一个函数
I have to define a function.

652
00:57:41,720 --> 00:57:51,690
换种方式来说，merge的输出并不是merge输入的函数
Another way to say that is the answer to what comes out of this merge box is not a function of what goes in.

653
00:57:51,690 --> 00:57:53,490
明白了吗？再来看看这个merge是怎么运行的
Because, see, what would the function be?

654
00:57:53,490 --> 00:58:03,470
假设Bill输入 1 1 1 1，Dave输入2 2 2 2
Suppose he puts in 1, 1, 1, 1, and he puts in 2, 2, 2, 2.

655
00:58:03,470 --> 00:58:05,910
merge应该输出什么呢？
What's the answer supposed to be?

656
00:58:05,910 --> 00:58:08,740
这里应该是1 2 1 2 1 2
It's not good enough to say it's 1, 2, 1, 2, 1, 2.

657
00:58:08,740 --> 00:58:09,390
我明白了
AUDIENCE: I understand.

658
00:58:09,390 --> 00:58:11,560
当Bill再输入1 1，merge再输出两个11
But when Bill puts in 1, 1 goes in.

659
00:58:11,560 --> 00:58:13,950
Dave再输入两个2，merge就输出两个2
When Dave puts in 2 twice, 2 goes in twice.

660
00:58:13,950 --> 00:58:15,450
就是这样
When Bill puts in-- PROFESSOR: Right.

661
00:58:15,450 --> 00:58:23,980
为什么不能在输入的数据上加上时间信息呢？PROFESSOR：因为这里没有时间这个概念
AUDIENCE: Why can't it be hooked to the time of the input-- the actual procedural-- PROFESSOR: Because I don't have time.

662
00:58:23,980 --> 00:58:26,900
我只是定义一个函数
See, all I can say is I'm going to define a function.

663
00:58:26,900 --> 00:58:28,150
没有时间概念
I don't have time.

664
00:58:32,070 --> 00:58:38,420
除掉那种没人在需要等他的情况，如果我们交替的来merge
There's no concept if it's going to alternate, except if nobody's there, it's going to wait a while for him.

665
00:58:38,420 --> 00:58:47,810
这里有两个流，一个是Dave生成的与时间无关的无穷长度的流
It's just going to say I have the stream of requests, the timeless infinite streams of all the requests that Dave would have made, right?

666
00:58:47,810 --> 00:58:51,690
另一个是Bill的，我现在要操作这些东西
And the timeless infinite stream of all the requests Bill would have made, and I want to operate on them.

667
00:58:51,690 --> 00:58:53,510
这就是银行帐户的工作原理
See, that's how this bank account is working.

668
00:58:56,710 --> 00:59:05,340
带来的问题就是倒霉的人可能提出了交易，但是并不能及时的得到回复
And the problem is that these poor people who are sitting at the bank account windows have the misfortune to exist in time.

669
00:59:05,340 --> 00:59:10,070
他们也没有意识到他们所做过的交易是以一种流的方式来处理的
They don't see their infinite stream of all the requests they would have ever made.

670
00:59:10,070 --> 00:59:11,550
他们只是等着，等待帐户的响应
They're waiting now, and they want an answer.

671
00:59:14,290 --> 00:59:25,290
假设你坐在屏幕前操作着一台分时系统的计算机，你输入一些指令想看到结果
So if you're sitting there-- if this is the screen operation on some time-sharing system and it's working functionally, you want an answer then when you talk the character.

672
00:59:25,290 --> 00:59:30,910
但是你并不想主机在处理完所有其它人的命令之后再来处理你的命令
You don't want it to have to wait for everybody in the whole system to have typed one character before it can get around to service you.

673
00:59:30,910 --> 00:59:33,890
这就是问题所在
So that's the problem.

674
00:59:33,890 --> 00:59:36,850
我的意思是，人们总能及时的得到结果
I mean, the fact that people live in time, apparently.

675
00:59:36,850 --> 00:59:38,620
如果没有，这也不能算作一个问题
If they didn't, it wouldn't be a problem.

676
00:59:49,100 --> 00:59:54,740
我想我还是不太理解这个银行交易中没有时间概念这一要点
AUDIENCE: I'm afraid I miss the point of having no time in this banking transaction.

677
00:59:54,740 --> 00:59:56,880
时间不重要吗？
Isn't time very important?

678
00:59:56,880 --> 01:00:00,790
举例说，有一系列事件
For instance, the sequence of events.

679
01:00:00,790 --> 01:00:08,400
比如Dave取款$100，这些顺序应该很重要才对
If Dave take out $100, then the timing sequence should be important.

680
01:00:08,400 --> 01:00:11,260
你怎么能把它们看作是流呢？
How do you treat transactions as streams?

681
01:00:11,260 --> 01:00:14,260
这个问题非常好
PROFESSOR: Well, that's the thing I'm saying.

682
01:00:14,260 --> 01:00:17,510
在这个例子中确实做不到那一点
This is an example where you can't.

683
01:00:17,510 --> 01:00:18,610
做不到
You can't.

684
01:00:18,610 --> 01:00:24,170
关键在于这里的输出不只是这两个流的函数
The point is what comes out of here is simply not a function of the stream going in here and the stream going in here.

685
01:00:24,170 --> 01:00:32,860
它是这两个流和某种关于时间的信息的函数，但是由于正则序语言的原因，这种时间信息表示不出来
It's a function of the stream going in here and the stream going in here and some kind of information about time, which is precisely what a normal-order language won't let you say.

686
01:00:34,810 --> 01:00:46,400
为了让这个银行系统更为有效，我们能不能把时间戳信息加在Bill和Dave的交易请求之前，以便merge可以根据这个来运作？
AUDIENCE: In order to brings this back into a more functional perspective, could we just explicitly time stamp all the inputs from Bill and Dave and define fair merge to just be the sort on those time stamps?

687
01:00:49,150 --> 01:00:49,550
当然，当然可以
PROFESSOR: Yeah, you can do that.

688
01:00:49,550 --> 01:00:50,600
你可以那样做
You can do that sort of thing.

689
01:00:50,600 --> 01:01:00,970
我们可以想像这个merge每毫秒读一次输入，如果这个时间点没有请求，就什么都不做
Another thing you could say is imagine that really what this function is, is that it does a read every microsecond, and then if there's none there, that's considered an empty one.

690
01:01:00,970 --> 01:01:03,610
这和你刚刚说的那种方式是相同的
That's about equivalent to what you said.

691
01:01:03,610 --> 01:01:07,110
当然可以这样做，但是那不是我们关注的重点
And yes, you can do that, but that's a clg.

692
01:01:07,110 --> 01:01:10,170
我们不只是关心函数的具体实现
So it's not quite only implementation we're worried about.

693
01:01:10,170 --> 01:01:18,824
我们更关心语言的表现力，现在我们遇到的问题主要在于我们能轻松表达出来的和我们想要表达的不相符
We're worried about expressive power in the language, and what we're running across is a real mismatch between what we can say easily and what we'd like to say.

694
01:01:18,824 --> 01:01:26,080
听起来好像如果两个人同时发出请求，这个方法就会出问题
AUDIENCE: It sounds like where we're getting hung up with that is the fact it expects one input from both Bill and Dave at the same time.

695
01:01:26,080 --> 01:01:28,530
也不是特指这一个问题，而是关乎你如何来定义这个函数的问题
PROFESSOR: It's not quite one, but it's anything you define.

696
01:01:28,530 --> 01:01:36,110
你也可以说Dave一次性处理两个请求，但是如果你预先定义些什么，这种方式也会出问题
So you can say Dave can go twice as often, but if anything you predefine, it's not the right thing.

697
01:01:36,110 --> 01:01:41,930
所以说交易有很多种方式，你无法根据特定的交易情况来决定如何定义
You can't decide at some particular function of their input requests.

698
01:01:41,930 --> 01:01:47,290
有一个更坏的消息是，甚至有一些情况连merge也处理不了
Worse yet, I mean, worse yet, there are things that even merge can't do.

699
01:01:47,290 --> 01:01:52,470
假如你把更多的人关联在这个银行帐户上
One thing you might want to do that's even more general is suddenly you add somebody else to this bank account system.

700
01:01:52,470 --> 01:01:56,030
假如这个人是John
You go and you add John to this bank account system.

701
01:01:56,030 --> 01:02:02,040
这个流我就先不往上画了，也同样连接在merge上
And now there's yet another stream that's going to come into the picture at some time which we haven't prespecified.

702
01:02:02,040 --> 01:02:08,860
这种情况甚至公平合并也无法给出合理的合并，我们称其为natagers还是什么我记不清了
So that's something even fair merge can't do, and they're things called-- I forget-- natagers or something.

703
01:02:08,860 --> 01:02:11,790
需要一种更为广泛化的公平合并也解决
That's a generalization of fair merge to allow that.

704
01:02:11,790 --> 01:02:19,580
有很多研究都在讨论，引入越来越多的机制，函数式思维能达到怎样的程度？
There's a whole sort of research discipline saying how far can you push this functional perspective by adding more and more mechanism?

705
01:02:19,580 --> 01:02:25,610
到什么样的程度它也会出问题，就和我们使用赋值一样
And how far does that go before the whole thing breaks down and you might as well been using set anyway.

706
01:02:25,610 --> 01:02:28,960
干脆自动取款好了
AUDIENCE: You need to set him up on automatic deposit.

707
01:02:28,960 --> 01:02:39,630
[笑声]
[LAUGHTER]

708
01:02:39,630 --> 01:02:40,880
好的，今天就到这里
PROFESSOR: OK, thank you.

