1
00:00:15,792 --> 00:00:17,328
教授：今天我们将学习一些
PROFESSOR: Well today we're going to learn about something

2
00:00:17,520 --> 00:00:18,410
非同一般的东西
quite amazing.

3
00:00:19,200 --> 00:00:21,888
我们将对计算机程序
We're going to understand what we mean by a program

4
00:00:22,592 --> 00:00:25,216
有更深层次的理解
a little bit more profoundly than we have up till now.

5
00:00:26,800 --> 00:00:29,120
目前为止 我们一直把程序看作
Up till now, we've been thinking

6
00:00:29,264 --> 00:00:32,096
对机器的描述
programs as describing machines.

7
00:00:32,720 --> 00:00:37,216
举个例子 在这个幻灯片上
So for example, looking at this still store

8
00:00:37,936 --> 00:00:41,776
我们可以看到一个计算阶乘的程序
we see here is a program for factorial.

9
00:00:42,800 --> 00:00:47,312
你可以把这串字符看作
And what it is, is a character string description, if you will,

10
00:00:47,664 --> 00:00:51,984
一个无穷机器的电路图的描述
 of the wiring diagram of a potentially infinite machine.

11
00:00:52,496 --> 00:00:54,800
我们可以稍稍地看下 它描述的是什么
And we can look at that a little bit and just see the idea.

12
00:00:55,130 --> 00:00:58,208
这种紧凑的记法 描述的是：
That this is a sort of compact notation which says, 

13
00:00:58,544 --> 00:01:00,170
如果N是0 结果就是1
if n is 0, the result is one.

14
00:01:00,170 --> 00:01:02,000
N是从这里进入机器的
Well here comes n coming into this machine,

15
00:01:02,336 --> 00:01:03,520
如果它是0的话
and if it's 0,

16
00:01:03,744 --> 00:01:05,200
那么我就控制这个开关
then I control this switch

17
00:01:05,472 --> 00:01:08,208
把它掰到输出为1的那一端
in such a way that the switch allows the output to be one.

18
00:01:09,340 --> 00:01:10,080
否则的话
Otherwise,

19
00:01:10,384 --> 00:01:12,832
就是(* N (FACT (- N 1)))
it's n times factorial of n minus one.

20
00:01:12,970 --> 00:01:15,136
在这里先计算(* FACT (- N 1))
Well, I'm computing factorial of n minus one

21
00:01:15,290 --> 00:01:16,688
把结果乘以N
and multiplying that by n,

22
00:01:16,848 --> 00:01:18,912
这样如果N不为0的话
in the case that it's not 0,

23
00:01:18,912 --> 00:01:20,608
这个开关就会输出这里的结果
this switch makes the output come from there.

24
00:01:21,900 --> 00:01:25,136
当然 这个机器可能有无穷多个部件
Of course, this is a machine with a potentially infinite number of parts,

25
00:01:25,488 --> 00:01:28,128
因为FACT内部又调用了FACT
because factorial occurs within factorial,

26
00:01:28,432 --> 00:01:30,176
因此我们不能知道调用栈有多深
so we don't know how deep it has to be.

27
00:01:31,070 --> 00:01:33,552
但这就基本上是
But that's basically what our notation 

28
00:01:34,224 --> 00:01:37,696
这段代码所描述的东西了
for programs really means to us at this point.

29
00:01:38,310 --> 00:01:40,592
这种用字符来描述的线路图
It's a character string description, if you will,

30
00:01:41,280 --> 00:01:44,160
你也可以用其它方式来描画
of a wiring diagram that could also be drawn some other way.

31
00:01:44,900 --> 00:01:46,608
事实上 很多人都向我提议
And, in fact, many people have proposed to me,

32
00:01:46,848 --> 00:01:49,040
说程序设计语言应该像这个一样是图形的
programming languages look graphical like this.

33
00:01:49,490 --> 00:01:51,808
不过我不认为用图形表示会有很多优势
I'm not sure I believe there are many advantages.

34
00:01:52,000 --> 00:01:53,792
当然 最主要的劣势就是
The major disadvantage, of course,

35
00:01:53,808 --> 00:01:55,632
它需要占用很大的平面空间
is that it takes up more space on a page,

36
00:01:55,968 --> 00:01:59,952
所以展示和修改起来就非常地麻烦
and, therefore, it's harder to pack into a listing or to edit very well.

37
00:02:01,344 --> 00:02:02,160
但是不管怎样
But in any case,

38
00:02:03,580 --> 00:02:07,056
在计算理论中 还有一个非常重要的东西
there's something very remarkable that can happen in the competition world 

39
00:02:07,648 --> 00:02:10,640
也就是所谓的“通用机器”
which is that you can have something called a universal machine.

40
00:02:10,730 --> 00:02:15,248
我们再来看第二张幻灯片
If we look at the second slide,

41
00:02:16,048 --> 00:02:17,184
我们看到的就是
what we see is

42
00:02:18,144 --> 00:02:19,888
名为EVAL的特殊机器
a special machine called eval.

43
00:02:21,260 --> 00:02:22,864
这个叫做EVAL的机器
There is a machine called eval,

44
00:02:22,880 --> 00:02:24,240
也就是我今天要讲解的
and I'm going to show it to you today.

45
00:02:25,824 --> 00:02:26,672
它非常简单
It's very simple.

46
00:02:27,780 --> 00:02:30,800
甚至它可以完全地写在黑板上
What is remarkable is that it will fit on the blackboard.

47
00:02:33,350 --> 00:02:35,792
然而 EVAL这个机器
However, eval is a machine

48
00:02:36,000 --> 00:02:39,840
是以其它机器的描述作为输入的
which takes as input a description of another machine.

49
00:02:40,450 --> 00:02:42,128
它可以接收一个
It could take the wiring diagram

50
00:02:42,400 --> 00:02:45,584
阶乘机器的线路图作为输入
of a factorial machine as input.

51
00:02:46,490 --> 00:02:47,664
这样一来
Having done so,

52
00:02:48,496 --> 00:02:52,570
它就可以模拟那台阶乘机器
it becomes a simulator for the factorial machine

53
00:02:53,136 --> 00:02:53,792
这样的话
such that,

54
00:02:54,160 --> 00:02:56,368
如果输入6 就会得到720
if you put a six in, out comes a 720.

55
00:02:58,910 --> 00:03:01,680
这是一个非常了不起的机器
That's a very remarkable sort of machine.

56
00:03:02,130 --> 00:03:03,584
而最让人惊奇的是
And the most amazing part of it

57
00:03:03,776 --> 00:03:05,136
它竟然可以写在一个黑板内
it is that it fits on a blackboard.

58
00:03:05,590 --> 00:03:06,656
与之相反的是
By contrast,

59
00:03:07,320 --> 00:03:10,448
我们可以想象一下电子世界中的
one could imagine in the analog electronics world

60
00:03:11,552 --> 00:03:12,864
一台非常不同的机器
a very different machine.

61
00:03:14,576 --> 00:03:16,336
这台机器呢
a machine where, a machine

62
00:03:16,528 --> 00:03:18,816
某种意义上 同样也是“通用机器”
which also was, in some sense, universal,

63
00:03:19,260 --> 00:03:23,120
只要你输入一个电路图
where you gave a circuit diagram as one of the inputs,

64
00:03:23,824 --> 00:03:25,744
比如这个小型的低通滤波器
for example, of this little low-pass filter,

65
00:03:26,016 --> 00:03:27,488
单极低通滤波器之类的
one-pole low-pass filter.

66
00:03:28,050 --> 00:03:29,536
你可以想像
And you can imagine that

67
00:03:29,710 --> 00:03:33,152
如果我们扫描这个元件得到扫描线
you could, for example, scan this out-- the scan lines

68
00:03:34,432 --> 00:03:37,130
得到的信号描述的就是
Right? are the signal that's describing

69
00:03:37,392 --> 00:03:40,400
这个机器所模拟的
what this machine is to simulate--

70
00:03:40,784 --> 00:03:43,392
电路构成了这个模拟电路机器EVAL
then the analog of eval which is made out of electrical circuits,

71
00:03:43,680 --> 00:03:45,152
它可以把自己配置成一个滤波器
which configure itself into a filter

72
00:03:45,184 --> 00:03:48,040
响应由电路图指定的频率
has the frequency response specified by the circuit diagram.

73
00:03:49,890 --> 00:03:51,488
这种机器很难制造出来
That's a very hard machine to make,

74
00:03:51,616 --> 00:03:54,064
当然 更不可能用一个黑板就把它说清楚
and, surely, there's no chance that I could put it on a blackboard.

75
00:03:55,670 --> 00:03:57,584
所以说 #TBD
So we're going to see an amazing thing today.

76
00:03:58,430 --> 00:04:00,816
我们将在黑板上见证
We're going to see, on the blackboard,

77
00:04:01,168 --> 00:04:02,496
通用机器
the universal machine.

78
00:04:02,790 --> 00:04:04,416
跟其它程序比起来
And we'll see that among other things,

79
00:04:04,528 --> 00:04:05,808
它真是非常简单
it's extremely simple.

80
00:04:06,780 --> 00:04:08,752
现在 我们已经非常接近
Now, we're getting very close

81
00:04:09,088 --> 00:04:10,976
计算机中真正的精灵了
the real spirit in the computer at this point.

82
00:04:11,280 --> 00:04:14,624
所以 为了保持足够的尊重
So I have to show a certain amount of reverence and respect,

83
00:04:15,184 --> 00:04:17,328
所以我特地穿上外套
so I'm going to wear a suit jacket for the only time

84
00:04:17,520 --> 00:04:19,296
你们应该从没见我穿过
that you'll ever see me wear a suit jacket here.

85
00:04:20,470 --> 00:04:22,736
在这个盛重的场合
And I think I'm also going to

86
00:04:23,552 --> 00:04:26,704
我想我还得戴上一顶合适的帽子
put on an appropriate hat for the occasion.

87
00:04:28,780 --> 00:04:31,440
开讲前再给大家提个醒
Now, this is a lecturer which I have to warn you--

88
00:04:34,140 --> 00:04:38,496
那些40岁以下以及没有孩子的人
let's see, normally, people under 40 and who don't have several children

89
00:04:38,672 --> 00:04:40,496
你们可要小心了
are advised to be careful.

90
00:04:40,490 --> 00:04:41,968
如果真的受不了 可以选择离开
If they're really worried, they should leave.

91
00:04:43,344 --> 00:04:47,136
因为一会儿要发生非常神秘的事情
Because there's a certain amount of mysticism that will appear here

92
00:04:47,744 --> 00:04:51,056
可能使你的大脑异常混乱
which may be disturbing and cause trouble in your minds.

93
00:04:51,820 --> 00:04:54,288
好了 无论如何
Well in any case, let's see,

94
00:04:55,712 --> 00:05:01,104
我要带你们写一个Lisp求值器
I wish to write for you the evaluator for Lisp.

95
00:05:02,510 --> 00:05:04,288
求值器并不复杂
Now the evaluator isn't very complicated.

96
00:05:05,020 --> 00:05:07,632
很像我们以前见到过的程序
It's very much like all the programs we've seen already.

97
00:05:08,240 --> 00:05:09,488
这也是它令人吃惊的地方
That's the amazing part of it.

98
00:05:10,860 --> 00:05:13,104
现在我开始写这个程序
It's going to be-- and I'm going to write it right here--

99
00:05:15,280 --> 00:05:16,620
我把这个程序叫做EVAL
it's a program called eval.

100
00:05:22,900 --> 00:05:26,240
这个过程接收两个参数
And it's a procedure of two arguments

101
00:05:26,280 --> 00:05:29,440
表达式EXP和环境ENV
expression and an environment.

102
00:05:31,860 --> 00:05:33,792
跟所有有用的过程一样
And like every interesting procedure,

103
00:05:34,016 --> 00:05:35,136
它是个“按情况分析”语句
it's a case analysis.

104
00:05:40,460 --> 00:05:41,872
但是在我开始之前
But before I start on this,

105
00:05:42,528 --> 00:05:43,904
我还想你们注意一下
I want to tell you some things.

106
00:05:44,448 --> 00:05:46,064
我将要在黑板上写的程序
The program we're going to write on the blackboard

107
00:05:46,560 --> 00:05:50,240
非常丑陋、混乱、令人作呕
is ugly, dirty, disgusting,

108
00:05:50,944 --> 00:05:53,168
并不是一种专业的写法
not the way I would write this is a professional.

109
00:05:54,320 --> 00:05:56,576
它用具体的语法写就的
It is written with concrete syntax,

110
00:05:57,248 --> 00:05:58,832
也就是说用了很多CAR、CDR
meaning you've got really to use lots of CARs and CDRs

111
00:05:58,848 --> 00:06:00,624
我之前告诉过你们这样写并不好
which is exactly what I told you not to do.

112
00:06:02,944 --> 00:06:05,616
在这里是故意这样来写的
That's on purpose in this case,

113
00:06:06,112 --> 00:06:10,400
因为我想让它尽量精简 能写在黑板内
because I want it to be small, compact, fit on the blackboard

114
00:06:10,432 --> 00:06:11,856
你们就可以看到整个代码
so you can get the whole thing.

115
00:06:12,420 --> 00:06:14,800
我就不像平时那样 使用很多很长的名字了
So I don't want to use long names like I normally use.

116
00:06:15,600 --> 00:06:17,296
就用CAR、CDR 因为它们短小
I want to use CAR-CDR because it's short.

117
00:06:18,060 --> 00:06:20,784
这算是一种取舍
Okay, I wanna, it's a whole, that's a trade-off.

118
00:06:20,896 --> 00:06:22,816
我不希望你们这样来写程序
I don't want you writing programs like this.

119
00:06:23,570 --> 00:06:25,088
这里单纯地想达到一种简洁的效果
This is purely for an effect.

120
00:06:25,850 --> 00:06:27,616
因此你们读起来可能有些费力
Now, you're going to have to work a little harder to read it,

121
00:06:27,776 --> 00:06:30,192
我尽量写得清楚一些
but I'm going to try to make it clear as I'm writing it.

122
00:06:31,270 --> 00:06:34,400
这个解释器已经比较完整了
I'm also-- this is a pretty much complete interpreter,

123
00:06:34,512 --> 00:06:36,240
但是还是缺少一些功能
but there's going to be room for putting in more things--

124
00:06:36,256 --> 00:06:38,608
我就不写定义和赋值的部分了
I'm going to leave out definition and assignment,

125
00:06:39,104 --> 00:06:42,416
因为它们都不是最本质的
just because they are not essential,

126
00:06:42,880 --> 00:06:46,464
稍后我就会跟大家解释 这是数学上的原因
and a, for a mathematical reason I'll show you later

127
00:06:46,928 --> 00:06:49,968
当然啦 黑板也没有那么大
and also they take up more space.

128
00:06:51,888 --> 00:06:53,648
但是 我们怎么做呢？
But, in any case, what do we have to do?

129
00:06:53,952 --> 00:06:55,664
我们需要一个分派
We have to do a dispatch

130
00:06:56,096 --> 00:06:57,904
它根据表达式的类型
which breaks the types of expressions up

131
00:06:58,288 --> 00:07:00,384
把它们划分为几类
into particular classes.

132
00:07:01,728 --> 00:07:03,264
这就是现在要做的
Okay? So that's what we're going to have here.

133
00:07:03,824 --> 00:07:05,150
这里的表达式应该是什么？
Well, what expressions are there?

134
00:07:05,150 --> 00:07:06,368
我们先来看几种表达式
Let's look at the kinds of expressions.

135
00:07:06,810 --> 00:07:09,600
比如说 数字“3”就是一个表达式
We can have things like the numeral three.

136
00:07:10,420 --> 00:07:11,584
它是什么意思呢？
What do I want that to do?

137
00:07:12,720 --> 00:07:14,752
我有很多选择 但是就现在而言
I can make choices, but I think right now,

138
00:07:15,056 --> 00:07:16,208
我就想让它表示数字3
I want it to be a three.

139
00:07:17,050 --> 00:07:17,888
这就是我要的
That's what I want.

140
00:07:18,720 --> 00:07:19,696
这个足够简单
So that's easy enough.

141
00:07:20,032 --> 00:07:22,912
那就意味着 如果表达式是数字
That means I want, if the thing is a number,

142
00:07:27,290 --> 00:07:31,680
表达式本身就应该是求值结果
that I want the expression itself as the answer.

143
00:07:35,420 --> 00:07:36,768
另外一种情况是
Now the next possibility

144
00:07:36,896 --> 00:07:38,864
表达式还可能是符号
is things that we represent as symbols.

145
00:07:39,390 --> 00:07:46,752
比如EXP、ENV、EVAL、NUMBER、X之类
Examples of symbols are things like x, n, eval, number, x.

146
00:07:48,016 --> 00:07:49,184
它们意味着什么？
What do I mean them to be?

147
00:07:50,160 --> 00:07:51,632
它们是一类代表其它事物的事物
Those are things that stand for other things.

148
00:07:51,632 --> 00:07:53,232
也就是我们语言中所谓的变量
Those are the variables of our language.

149
00:07:54,770 --> 00:07:56,880
因此我想要能够 比如说
And so I want to be able to say, for example,

150
00:07:57,056 --> 00:08:01,040
对X求值 可能会得到3
that x, for example, transforms to it's value which might be three.

151
00:08:02,640 --> 00:08:05,760
又可能是CAR
Or I might ask something like car.

152
00:08:07,760 --> 00:08:09,408
我希望它的值是
I want to have as its value--

153
00:08:09,632 --> 00:08:11,344
某种类似于过程的东西
be something like some procedure,

154
00:08:16,512 --> 00:08:18,432
我不需要知道它内部指什么
which I don't know what is inside there,

155
00:08:18,640 --> 00:08:21,152
可能是一些机器码 或者类似的东西
 perhaps a machine language code or something like that.

156
00:08:22,848 --> 00:08:24,272
到这是还是相对简单的
Ok? So, well, that's easy enough.

157
00:08:24,430 --> 00:08:26,896
我想把这部分交给其他人来写
I'm going to push that off on someone else.

158
00:08:27,808 --> 00:08:28,896
如果我们有一个符号
If something is a symbol,

159
00:08:30,800 --> 00:08:32,480
假如表达式是符号
if the expression is a symbol,

160
00:08:33,424 --> 00:08:34,880
那么我求值它的结果就应该是
then I want the answer to be the result,

161
00:08:34,912 --> 00:08:40,240
在当前环境中查找该表达式的值
looking up the expression in the environment.

162
00:08:46,480 --> 00:08:48,992
环境是一个字典
Now the environment is a dictionary

163
00:08:49,968 --> 00:08:54,060
它把符号映射成一个值
which maps the symbol names to their values.

164
00:08:54,288 --> 00:08:55,168
就这么简单
And that's all it is.

165
00:08:56,280 --> 00:08:57,200
怎么完成的呢？
How it's done?

166
00:08:57,530 --> 00:08:58,528
稍后我们再谈这个
Well, we'll see that later.

167
00:08:59,680 --> 00:09:00,576
其实并不难
It's very easy.

168
00:09:01,670 --> 00:09:04,288
编写一个能容纳各种各样东西的表并不难 #TBD
It's easy to make data structures that are tables of various sorts.

169
00:09:04,840 --> 00:09:05,744
但它不仅仅是一个表
But it's only a table,

170
00:09:05,776 --> 00:09:07,560
这是一个存取某个表的过程
and this is the access routine for some table.

171
00:09:09,552 --> 00:09:12,560
好的 接下来 下一种可能
Ok? Well, the next thing, another kind of expression--

172
00:09:12,672 --> 00:09:15,568
表达式可能是一些不是数字的常量
you have things that are described constants that are not numbers,

173
00:09:16,064 --> 00:09:17,430
比如 'FOO
like 'foo.

174
00:09:20,170 --> 00:09:21,296
为了方便起见
Well, for my convenience,

175
00:09:21,312 --> 00:09:23,360
我想在语法上
I want to syntactically transform that

176
00:09:24,736 --> 00:09:26,800
把它转换成表结构
into a list structure which is,

177
00:09:26,848 --> 00:09:31,520
比如说是(QUOTE FOO)
which is, quote foo.

178
00:09:35,140 --> 00:09:37,184
一个被引用起来的对象 无论它是什么
A quoted object, whatever it is,

179
00:09:38,352 --> 00:09:40,832
都实际上是一个缩写
 is going to be actually an abbreviation,

180
00:09:41,040 --> 00:09:42,592
求值器并不复杂这一部分
which is not part of the evaluator

181
00:09:43,216 --> 00:09:44,464
这是在其它地方完成的
 but happens somewhere else,

182
00:09:44,752 --> 00:09:47,792
左边的符号就是右边表达式的缩略形式
an abbreviation for an expression that looks like this.

183
00:09:48,780 --> 00:09:50,480
这样 我就可以
This way, I can test for

184
00:09:50,576 --> 00:09:53,120
依据表达式的CAR部分\ the type of the expression as being a quotation

185
00:09:53,312 --> 00:09:55,952
来判断它的类型了
by examining the car of the expression.

186
00:09:58,460 --> 00:10:01,088
因此这一部分也不会出现在求值器中
So I'm not going to worry about that in the evaluator.

187
00:10:01,650 --> 00:10:03,792
这在更早时候 比如源代码读取阶段完成
It's happening somewhere earlier in the reader or something.

188
00:10:05,540 --> 00:10:15,040
如果表达式是引用表达式
If the expression of the expression is quote,

189
00:10:18,272 --> 00:10:19,104
那么求值的结果就是
then what I want,

190
00:10:19,630 --> 00:10:25,136
我想让(QUOTE FOO)求值为自身FOO
 I want quote foo to itself evaluate to foo.

191
00:10:25,140 --> 00:10:25,952
一个常量
It's a constant.

192
00:10:27,530 --> 00:10:28,928
这条代码是说
This is just a way of saying

193
00:10:29,088 --> 00:10:30,736
这类表达式求值为它自己
that this evaluates to itself.

194
00:10:31,792 --> 00:10:33,660
怎么才能把它取出来呢？
Ok? So thats the. What is that?

195
00:10:33,660 --> 00:10:36,368
这是列表第二个元素的第一个部分
That's the first of the second of the list.

196
00:10:36,592 --> 00:10:37,584
也就是表的第二个元素
That's the second of the list.

197
00:10:38,496 --> 00:10:40,320
也就是CADR
The second element of the list is it's CADR.

198
00:10:41,280 --> 00:10:42,384
所以这里我就写CADR
So I'm just going to write here, CADR.

199
00:10:51,088 --> 00:10:52,352
表达式还可能是什么类型呢？
OK? What else do we have here?

200
00:10:52,510 --> 00:10:53,808
还有LAMBDA表达式
We have lambda expressions,

201
00:10:55,008 --> 00:11:03,296
比如 (LAMBDA (X) (+ X Y))
for example, lambda of x plus x y.

202
00:11:04,160 --> 00:11:06,336
我还得找到某种表示方法
Well, I going have to have some representation for the procedure

203
00:11:06,336 --> 00:11:07,856
来表示过程
which is the value of an expression,

204
00:11:08,112 --> 00:11:09,088
也就是LAMBDA表达式求值的结果
of a lambda expression.

205
00:11:09,600 --> 00:11:12,624
过程并不就是表达式(LAMBDA (x))
The procedure here is not the expression lambda x.

206
00:11:13,136 --> 00:11:15,568
表达式只是过程的代码描述
That's the description of it, the textual description.

207
00:11:16,416 --> 00:11:18,330
如果在词法作用域的语言中实现过程
However, what what I going to expect to see here

208
00:11:18,560 --> 00:11:21,200
那么我希望在表示过程的时候
is something which contains an environment as one of its parts

209
00:11:23,232 --> 00:11:25,360
能够把当前的求值环境包括进来
if I'm implementing a lexical language.

210
00:11:25,840 --> 00:11:29,072
所以这里我还需要
And so what I'd like to see

211
00:11:29,200 --> 00:11:30,672
一些类型标志
is some type flags.

212
00:11:30,704 --> 00:11:33,904
这样后面我就可以用它们来区分过程
I'm going to have to be able to distinguish procedures later,

213
00:11:34,304 --> 00:11:36,592
看哪些是由LAMBDA表达式生成的
procedures which were produced by lambdas,

214
00:11:36,816 --> 00:11:38,032
哪些是基本过程
from ones that may be primitive.

215
00:11:39,060 --> 00:11:41,968
所以这里是个类型标志
And so I'm going to have some flag,

216
00:11:41,984 --> 00:11:43,568
出于历史原因
which I'll just arbitrarily call closure,

217
00:11:43,568 --> 00:11:45,104
我用CLOSURE作为类型标志
just for historical reasons.

218
00:11:47,680 --> 00:11:49,600
现在来看看 哪部分比较重要
Now, to say what parts of this are important.

219
00:11:49,920 --> 00:11:51,120
我需要知道
I'm going to need to know

220
00:11:51,248 --> 00:11:52,928
绑定变量表和过程的体
the bound variable list and the body.

221
00:11:54,220 --> 00:11:55,408
这是它的CDR部分
Well, that's the CDR of this,

222
00:11:56,096 --> 00:12:01,856
这里就是((X) (+ X Y))
so it's going to be x and plus x y and some environment.

223
00:12:03,040 --> 00:12:03,872
以及某个环境<ENV>
and some environment.

224
00:12:08,170 --> 00:12:12,208
用户不应该看到这个东西
Now this is not something that users should ever see,

225
00:12:13,536 --> 00:12:16,192
这只是过程对象的
this is purely a representation, internally,

226
00:12:16,768 --> 00:12:18,304
一种内部表示
for a procedure object.

227
00:12:18,520 --> 00:12:20,528
它包括绑定变量表
It contains a bound variable list,

228
00:12:20,704 --> 00:12:22,624
过程的体和某个环境
a body, and an environment,

229
00:12:23,536 --> 00:12:25,808
以及表示自身为过程类型的标志
and some type tag saying, I am a procedure.

230
00:12:26,340 --> 00:12:27,376
接下来写代码
I'm going to make one now.

231
00:12:28,080 --> 00:12:38,720
如果表达式的CAR部分是'LAMBDA
So if the CAR of the expression is quote lambda,

232
00:12:43,472 --> 00:12:44,816
这里 我就要
then what I'm going to put here

233
00:12:45,648 --> 00:12:51,840
创建一个表 表头是'CLOSURE
is-- I'm going to make a list of closure,

234
00:12:55,150 --> 00:13:00,736
接着是 过程代码的CDR部分
the CDR of the procedure description

235
00:13:01,568 --> 00:13:02,976
也就是除开LAMBDA的其它部分
was everything except the lambda,

236
00:13:07,744 --> 00:13:08,864
以及当前的环境
and the current environment.

237
00:13:10,250 --> 00:13:15,328
这样就实现了环境模型中的那些规则
This implements the rule for environments in the environment model.

238
00:13:15,456 --> 00:13:18,528
这是从LAMBDA表达式中构建过程所必须遵守的
It has to do with construction of procedures from lambda expressions.

239
00:13:19,408 --> 00:13:20,976
这个在求值器遇到
The environment that was around

240
00:13:21,488 --> 00:13:24,320
一个LAMBDA表达式时的环境
at the time the evaluator encountered the lambda expression

241
00:13:25,040 --> 00:13:28,464
在过程运行的时候
is the environment where the procedure resulting interprets it's free variables.

242
00:13:28,688 --> 00:13:31,776
会去这个环境中查找自由变量的值
where the procedure resulting interprets it's free variables.

243
00:13:34,720 --> 00:13:35,824
所以需要把它囊括进来
So that's part of that.

244
00:13:35,920 --> 00:13:37,552
因此我们必须把求值时的环境
And so we have to capture that environment

245
00:13:37,568 --> 00:13:38,860
作为过程对象的一部分
as part of the procedure object.

246
00:13:39,210 --> 00:13:40,624
之后再来看它的作用
And we'll see how that gets used later.

247
00:13:42,032 --> 00:13:43,776
我们也有COND表达式
There are also conditional expressions

248
00:13:44,592 --> 00:13:52,816
像是(COND (P1 E1) (P2 E2) ...)这样的
of things like COND of say, p one, e one, p two, e two.

249
00:13:54,400 --> 00:13:56,096
P1是谓词
Where this is a predicate,

250
00:13:56,352 --> 00:13:58,432
谓词总是返回TRUE或者FALSE
a predicate is a thing that is either true or false,

251
00:13:58,992 --> 00:14:01,760
如果谓词P1为真时 表达式E1才被求值
and the expression to be evaluated if the predicate is true.

252
00:14:03,440 --> 00:14:06,080
当然 你也可以列这么一组子句
A set of clauses, if you will, that's the name for such a thing.

253
00:14:06,790 --> 00:14:09,360
#TBD
So I'm going put that somewhere else.

254
00:14:09,360 --> 00:14:11,568
#TBD
We're going to worry about that in another piece of code.

255
00:14:12,420 --> 00:14:21,280
如果表达式的CAR部分是'COND的话
So EQ--  if the CAR of the expression is COND,

256
00:14:24,000 --> 00:14:26,848
那么我就用EVCOND来求值这个表达式
then I'm going to do nothing more than evaluate the COND,

257
00:14:30,208 --> 00:14:31,424
求值表达式的CDR部分
the CDR of the expression.

258
00:14:34,400 --> 00:14:38,496
记得带上环境
That's all the clauses in the environment that I'm given.

259
00:14:41,430 --> 00:14:42,608
好的 还有一种情况
Well, there's one more case,

260
00:14:44,096 --> 00:14:48,224
任意的像(+ X 3)这样的表达式
arbitrary thing like the sum of x and three,

261
00:14:50,624 --> 00:14:53,952
这是把运算符应用在运算对象上
where this is an operator applied to operands,

262
00:14:55,136 --> 00:14:56,590
这并没有什么特殊的
and there's nothing special about it.

263
00:14:56,590 --> 00:14:59,632
就是说 它不属于这里的特殊形式
It's not one of the special cases, the special forms.

264
00:14:59,850 --> 00:15:01,424
上面写的这些都是特殊形式
These are the special forms.

265
00:15:09,650 --> 00:15:12,128
再说明一下 如果我要把这个程序写得专业一点
And if I were writing here a professional program, again,

266
00:15:12,368 --> 00:15:14,176
我会把它设计成数据导向的
I would somehow make this data directed.

267
00:15:14,480 --> 00:15:16,528
那样的话这里就不会是一系列的条件判断
So there wouldn't be a sequence of conditionals here,

268
00:15:16,656 --> 00:15:18,208
而是根据一些比特位来做分派
there'd be a dispatch on some bits

269
00:15:19,424 --> 00:15:22,256
这样来设计会更加专业一些
if I were trying to do this in a more professional way.

270
00:15:22,360 --> 00:15:24,144
并且 我不用大量修改程序
So that, in fact, I can add to the thing

271
00:15:24,688 --> 00:15:26,384
就可以添加规则
without changing my program much.

272
00:15:26,710 --> 00:15:28,464
这样来做可能运行得更快
So, for example, they would run fast,

273
00:15:29,040 --> 00:15:30,432
但这里我并不打算这么做
but I'm not worried about that.

274
00:15:31,280 --> 00:15:33,984
现在的目的是把握EVAL过程的整体
Here we're trying to look at this in its entirety.

275
00:15:35,072 --> 00:15:35,808
那么 最后一种情况
So it's else.

276
00:15:37,696 --> 00:15:38,560
要怎么做呢？
Well, what do we do?

277
00:15:38,560 --> 00:15:41,232
在这种情况下 我需要进行加法运算
In this case, I have to somehow do an addition.

278
00:15:44,350 --> 00:15:46,160
那么我就得搞清楚 '+到底是什么
Well, I could find out what the plus is.

279
00:15:46,848 --> 00:15:49,296
我还得知道X和3又代表什么
I have to find out what the x and the three are.

280
00:15:50,550 --> 00:15:53,968
然后再把'+的所代表的东西
And then I have to apply the result of finding what the plus is

281
00:15:54,432 --> 00:15:57,008
应用于'X与3所代表的东西上
to the result of finding out what the x and the three are.

282
00:15:58,112 --> 00:15:59,392
具体来写一下
We'll have a name for that.

283
00:16:04,080 --> 00:16:09,552
我要把表达式CAR部分的求值结果
So I'm going to apply the result of evaluating the CAR

284
00:16:11,200 --> 00:16:12,140
应用在
of the expression--

285
00:16:13,216 --> 00:16:15,504
表达式的CAR部分就是运算符
the car of the expression is the operator--

286
00:16:17,200 --> 00:16:18,512
要在给定的环境中进行
in the environment given.

287
00:16:20,512 --> 00:16:22,896
对运算符求值会得到一个过程
So evaluating the operator gets me the procedure.

288
00:16:24,050 --> 00:16:26,784
现在 我要求值所有的运算对象来取得参数
Now I have to evaluate all the operands to get the arguments.

289
00:16:27,290 --> 00:16:28,224
我将调用EVLIST
I'll call that EVLIST,

290
00:16:31,264 --> 00:16:35,536
来求值表达式的CDR部分 也就是运算对象
the CDR of the operands, of the expression,

291
00:16:36,768 --> 00:16:39,008
当然是在相应的环境中
with respect to the environment.

292
00:16:41,940 --> 00:16:43,136
我们待会儿再定义EVLIST
EVLIST will come up later--

293
00:16:43,264 --> 00:16:48,070
（闭合括号中）
EVLIST, apply, COND pair, COND, lambda, define.

294
00:16:50,900 --> 00:16:52,336
你现在看到的
So that what you are seeing here

295
00:16:52,670 --> 00:16:56,112
基本上就是一个完整的求值器
is pretty much all there is in the evaluator itself.

296
00:16:56,496 --> 00:17:01,000
它根据表达式的类型分情况处理
It's the case dispatch on the type of the expression

297
00:17:01,248 --> 00:17:07,952
默认的情况是表达式应用或者说是组合式
with the default being a general application or a combination.

298
00:17:17,520 --> 00:17:19,520
不过还有好些过程 我们没有定义
Now there is lots of things we haven't defined yet.

299
00:17:20,080 --> 00:17:21,600
接下来就看这些未定义的部分
Let's just look at them and see what they are.

300
00:17:21,780 --> 00:17:24,128
我们稍后再定义EVCOND
We're going to have to do this later, evcond.

301
00:17:25,480 --> 00:17:26,672
我得定义apply
We have to write apply.

302
00:17:27,570 --> 00:17:28,624
还有evlist，lookup
We're going to have to write EVLIST. We're going to write LOOKUP.

303
00:17:28,944 --> 00:17:30,208
还有evlist，lookup
We're going to have to write EVLIST. We're going to write LOOKUP.

304
00:17:31,790 --> 00:17:33,430
我看看，没别的了吧？
I think that's everything, isn't there?

305
00:17:33,430 --> 00:17:37,184
剩下的就是一些简单基本的东西了
Everything else is something which is simple, or primitive, or something like that.

306
00:17:38,570 --> 00:17:39,488
当然，这里可以写很多特殊形式，但是对于一个语言来说无疑很糟糕
And, of course, we could many more special forms here, but that would be a bad idea in general in a language.

307
00:17:39,696 --> 00:17:42,064
当然，这里可以写很多特殊形式，但是对于一个语言来说无疑很糟糕
And, of course, we could many more special forms here, but that would be a bad idea in general in a language.

308
00:17:42,256 --> 00:17:44,450
当然，这里可以写很多特殊形式，但是对于一个语言来说无疑很糟糕
And, of course, we could many more special forms here, but that would be a bad idea in general in a language.

309
00:17:44,450 --> 00:17:45,920
那会让语言变得很复杂
You make a language very complicated by putting a lot of things in there.

310
00:17:46,000 --> 00:17:47,488
那会让语言变得很复杂
You make a language very complicated by putting a lot of things in there.

311
00:17:47,690 --> 00:17:50,352
保留字就不该比你能记住几个手指脚指的数目还多
The number of reserve words that should exist in a language should be no more than a person could remember on his fingers and toes.

312
00:17:50,768 --> 00:17:53,616
保留字就不该比你能记住几个手指脚指的数目还多
The number of reserve words that should exist in a language should be no more than a person could remember on his fingers and toes.

313
00:17:54,160 --> 00:17:55,536
看到有些语言的保留字有上百个，我都不知道该说什么
And I get very upset with languages which have hundreds of reserve words.

314
00:17:55,568 --> 00:17:58,208
看到有些语言的保留字有上百个，我都不知道该说什么
And I get very upset with languages which have hundreds of reserve words.

315
00:17:59,410 --> 00:18:00,710
特殊形式也就是所谓定义保留字的地方
But that's where the reserve words go.

316
00:18:04,750 --> 00:18:06,544
好的，接下来，我们来看第二个核心的部分，apply
Well, now let's get to the next part of this, the kernel, apply.

317
00:18:06,560 --> 00:18:07,690
好的，接下来，我们来看第二个核心的部分，apply
Well, now let's get to the next part of this, the kernel, apply.

318
00:18:09,640 --> 00:18:10,752
它还做些什么呢？
What else is this doing?

319
00:18:11,590 --> 00:18:14,944
apply主要是将过程应用于实际参数，这里所说的是过程和参数的符号求值的结果，而不是过程和参数的符号
Well, apply's job is to take a procedure and apply it to its arguments after both have been evaluated to come up with a procedure and the arguments rather the operator symbols and the operand symbols, whatever they are-- symbolic expressions.

320
00:18:15,888 --> 00:18:17,552
apply主要是将过程应用于实际参数，这里所说的是过程和参数的符号求值的结果，而不是过程和参数的符号
Well, apply's job is to take a procedure and apply it to its arguments after both have been evaluated to come up with a procedure and the arguments rather the operator symbols and the operand symbols, whatever they are-- symbolic expressions.

321
00:18:17,664 --> 00:18:20,688
apply主要是将过程应用于实际参数，这里所说的是过程和参数的符号求值的结果，而不是过程和参数的符号
Well, apply's job is to take a procedure and apply it to its arguments after both have been evaluated to come up with a procedure and the arguments rather the operator symbols and the operand symbols, whatever they are-- symbolic expressions.

322
00:18:20,912 --> 00:18:23,856
apply主要是将过程应用于实际参数，这里所说的是过程和参数的符号求值的结果，而不是过程和参数的符号
Well, apply's job is to take a procedure and apply it to its arguments after both have been evaluated to come up with a procedure and the arguments rather the operator symbols and the operand symbols, whatever they are-- symbolic expressions.

323
00:18:24,096 --> 00:18:26,960
apply主要是将过程应用于实际参数，这里所说的是过程和参数的符号求值的结果，而不是过程和参数的符号
Well, apply's job is to take a procedure and apply it to its arguments after both have been evaluated to come up with a procedure and the arguments rather the operator symbols and the operand symbols, whatever they are-- symbolic expressions.

324
00:18:33,270 --> 00:18:35,088
所以我们定义apply过程，接受两个参数分别代表将应用的过程和这个过程的参数列表
So we will define apply to be a procedure of two arguments, a procedure and arguments.

325
00:18:38,352 --> 00:18:40,656
所以我们定义apply过程，接受两个参数分别代表将应用的过程和这个过程的参数列表
So we will define apply to be a procedure of two arguments, a procedure and arguments.

326
00:18:40,752 --> 00:18:43,440
所以我们定义apply过程，接受两个参数分别代表将应用的过程和这个过程的参数列表
So we will define apply to be a procedure of two arguments, a procedure and arguments.

327
00:18:47,248 --> 00:18:48,128
具体怎么来写呢？
And what does it do?

328
00:18:48,144 --> 00:18:49,552
其实并不复杂
It does nothing very complicated.

329
00:18:49,936 --> 00:18:50,784
分两种情况就够了
It's got two cases.

330
00:18:53,580 --> 00:18:55,168
如果这个过程是基本过程 -- 我不知道这个谓词具体是根据什么来判断的
Either the procedure is primitive--  And I don't know exactly how that is done.

331
00:19:03,424 --> 00:19:06,416
如果这个过程是基本过程 -- 我不知道这个谓词具体是根据什么来判断的
Either the procedure is primitive--  And I don't know exactly how that is done.

332
00:19:06,864 --> 00:19:10,240
可能原理就像我们用'closure标志来表示组合结构的类型一样，我想可能是这样
It's possible there's some type information just like we made closure for, here, being the description of the type of a compound thing-- probably so.

333
00:19:10,384 --> 00:19:12,416
可能原理就像我们用'closure标志来表示组合结构的类型一样，我想可能是这样
It's possible there's some type information just like we made closure for, here, being the description of the type of a compound thing-- probably so.

334
00:19:12,688 --> 00:19:15,056
可能原理就像我们用'closure标志来表示组合结构的类型一样，我想可能是这样
It's possible there's some type information just like we made closure for, here, being the description of the type of a compound thing-- probably so.

335
00:19:16,336 --> 00:19:17,792
可能原理就像我们用'closure标志来表示组合结构的类型一样，我想可能是这样
It's possible there's some type information just like we made closure for, here, being the description of the type of a compound thing-- probably so.

336
00:19:18,550 --> 00:19:20,208
但是深究这个谓词并不必要，事实上你可能已经知道或是演绎过，我们并不需要任何基本过程
But it is not essential how that works, and, in fact, it turns out, as you probably know or have deduced, that you don't need any primitives anyway.

337
00:19:20,688 --> 00:19:22,016
但是深究这个谓词并不必要，事实上你可能已经知道或是演绎过，我们并不需要任何基本过程
But it is not essential how that works, and, in fact, it turns out, as you probably know or have deduced, that you don't need any primitives anyway.

338
00:19:22,192 --> 00:19:23,856
但是深究这个谓词并不必要，事实上你可能已经知道或是演绎过，我们并不需要任何基本过程
But it is not essential how that works, and, in fact, it turns out, as you probably know or have deduced, that you don't need any primitives anyway.

339
00:19:23,872 --> 00:19:25,472
但是深究这个谓词并不必要，事实上你可能已经知道或是演绎过，我们并不需要任何基本过程
But it is not essential how that works, and, in fact, it turns out, as you probably know or have deduced, that you don't need any primitives anyway.

340
00:19:27,350 --> 00:19:29,280
我们没有基本过程只用lambda也照样可以正常计算
You can compute anything without them because some of the lambda that I've been playing with.

341
00:19:30,464 --> 00:19:33,190
我们没有基本过程只用lambda也照样可以正常计算
You can compute anything without them because some of the lambda that I've been playing with.

342
00:19:33,616 --> 00:19:34,768
但是有它们总归方便点儿
But it's nice to have them.

343
00:19:34,816 --> 00:19:37,472
接下来就是精彩的部分了，我先不细讲
So here we're going to do some magic which I'm not going to explain.

344
00:19:38,060 --> 00:19:41,440
转到机器语言，执行apply-primop
Go to machine language, apply primop.

345
00:19:42,912 --> 00:19:43,808
加法就是这样运算的
Here's how it adds.

346
00:19:44,992 --> 00:19:46,100
执行加法指令
Execute an add instruction.

347
00:19:50,620 --> 00:19:52,224
然而一门语言有趣的部分在于谓词是如何组合在一起的
However, the interesting part of a language is the glue by which the predicates are glued together.

348
00:19:52,240 --> 00:19:54,272
然而一门语言有趣的部分在于谓词是如何组合在一起的
However, the interesting part of a language is the glue by which the predicates are glued together.

349
00:19:54,912 --> 00:19:55,904
我们接着往下看
So let's look at that.

350
00:19:56,910 --> 00:20:00,768
另一种可能就是这是一个求值lambda得到的过程，一个复合过程
Well, the other possibility is that this is a compound made up by executing a lambda expression, this is a compound procedure.

351
00:20:00,912 --> 00:20:04,144
另一种可能就是这是一个求值lambda得到的过程，一个复合过程
Well, the other possibility is that this is a compound made up by executing a lambda expression, this is a compound procedure.

352
00:20:04,976 --> 00:20:07,056
另一种可能就是这是一个求值lambda得到的过程，一个复合过程
Well, the other possibility is that this is a compound made up by executing a lambda expression, this is a compound procedure.

353
00:20:07,620 --> 00:20:09,360
我们检测它的类型标志
Well, we'll check its type.

354
00:20:10,110 --> 00:20:17,072
如果是'closure，我就得求值这个过程体
If it is closure, if it's one of those, then I have to do an eval of the body.

355
00:20:20,512 --> 00:20:24,096
如果是'closure，我就得求值这个过程体
If it is closure, if it's one of those, then I have to do an eval of the body.

356
00:20:24,190 --> 00:20:25,472
这里我要将过程应用于其参数，也就是 将形参与实参绑定，添加入过程的运行环境，然后在此环境下对过程求值
The way I do this, the way I deal with this at all, is the way I evaluate the application of a procedure to its arguments, is by evaluating the body of the procedure in the environment resulting from extending the environment of the procedure with the bindings of the formal parameters of the procedure to the arguments that were passed to it.

357
00:20:25,760 --> 00:20:27,328
这里我要将过程应用于其参数，也就是 将形参与实参绑定，添加入过程的运行环境，然后在此环境下对过程求值
The way I do this, the way I deal with this at all, is the way I evaluate the application of a procedure to its arguments, is by evaluating the body of the procedure in the environment resulting from extending the environment of the procedure with the bindings of the formal parameters of the procedure to the arguments that were passed to it.

358
00:20:28,080 --> 00:20:31,696
这里我要将过程应用于其参数，也就是 将形参与实参绑定，添加入过程的运行环境，然后在此环境下对过程求值
The way I do this, the way I deal with this at all, is the way I evaluate the application of a procedure to its arguments, is by evaluating the body of the procedure in the environment resulting from extending the environment of the procedure with the bindings of the formal parameters of the procedure to the arguments that were passed to it.

359
00:20:31,720 --> 00:20:33,710
这里我要将过程应用于其参数，也就是 将形参与实参绑定，添加入过程的运行环境，然后在此环境下对过程求值
The way I do this, the way I deal with this at all, is the way I evaluate the application of a procedure to its arguments, is by evaluating the body of the procedure in the environment resulting from extending the environment of the procedure with the bindings of the formal parameters of the procedure to the arguments that were passed to it.

360
00:20:34,192 --> 00:20:37,808
这里我要将过程应用于其参数，也就是 将形参与实参绑定，添加入过程的运行环境，然后在此环境下对过程求值
The way I do this, the way I deal with this at all, is the way I evaluate the application of a procedure to its arguments, is by evaluating the body of the procedure in the environment resulting from extending the environment of the procedure with the bindings of the formal parameters of the procedure to the arguments that were passed to it.

361
00:20:37,920 --> 00:20:40,480
这里我要将过程应用于其参数，也就是 将形参与实参绑定，添加入过程的运行环境，然后在此环境下对过程求值
The way I do this, the way I deal with this at all, is the way I evaluate the application of a procedure to its arguments, is by evaluating the body of the procedure in the environment resulting from extending the environment of the procedure with the bindings of the formal parameters of the procedure to the arguments that were passed to it.

362
00:20:41,024 --> 00:20:43,680
这里我要将过程应用于其参数，也就是 将形参与实参绑定，添加入过程的运行环境，然后在此环境下对过程求值
The way I do this, the way I deal with this at all, is the way I evaluate the application of a procedure to its arguments, is by evaluating the body of the procedure in the environment resulting from extending the environment of the procedure with the bindings of the formal parameters of the procedure to the arguments that were passed to it.

363
00:20:46,704 --> 00:20:47,872
这句话很长
That was a long sentence.

364
00:20:51,130 --> 00:20:52,160
但是描述的内容足够简单
Well that's easy enough.

365
00:20:52,820 --> 00:20:54,480
一会儿可能会出现许多CAR CDR CADR ...
Now here's going to be a lot of CAR-CDRing.

366
00:20:56,384 --> 00:20:58,112
现在我先要得到过程体
I have to get the body of the procedure.

367
00:20:59,400 --> 00:21:02,304
过程体如何取出呢？
Where's the body of the procedure in here?

368
00:21:02,960 --> 00:21:04,080
这一部分是CAR，剩下的是CDR部分
Well here's the CAR, here's the CDR is the whole rest of this.

369
00:21:04,496 --> 00:21:06,130
这一部分是CAR，剩下的是CDR部分
Well here's the CAR, here's the CDR is the whole rest of this.

370
00:21:06,130 --> 00:21:06,960
然后这里就是CADR，我看看，过程体就在整个过程第二部分的第二部分
So here's the CADR. And so I see, what I have here is the body is the second element of the second element of the procedure.

371
00:21:07,400 --> 00:21:08,912
然后这里就是CADR，我看看，过程体就在整个过程第二部分的第二部分
So here's the CADR. And so I see, what I have here is the body is the second element of the second element of the procedure.

372
00:21:08,928 --> 00:21:13,040
然后这里就是CADR，我看看，过程体就在整个过程第二部分的第二部分
So here's the CADR. And so I see, what I have here is the body is the second element of the second element of the procedure.

373
00:21:13,200 --> 00:21:15,152
也就是CADR的CADR，或者简写为CADADR
So it's the CADR of the CADR or the CADADR.

374
00:21:19,170 --> 00:21:27,495
这里取整个过程的CADADR
It's the C-A-D-A-D-R, CADADR of the procedure.

375
00:21:30,260 --> 00:21:33,824
为了在参数绑定后的新环境之中执行这个过程，我还得取到过程的形式参数，形参怎么取呢？
To evaluate the body in the result of binding that's making up more environment, well I need the formal parameters of the of the procedure, what is that?

376
00:21:34,944 --> 00:21:36,480
为了在参数绑定后的新环境之中执行这个过程，我还得取到过程的形式参数，形参怎么取呢？
To evaluate the body in the result of binding that's making up more environment, well I need the formal parameters of the of the procedure, what is that?

377
00:21:38,096 --> 00:21:42,720
为了在参数绑定后的新环境之中执行这个过程，我还得取到过程的形式参数，形参怎么取呢？
To evaluate the body in the result of binding that's making up more environment, well I need the formal parameters of the of the procedure, what is that?

378
00:21:43,500 --> 00:21:45,136
就是CDR的CAR，很混乱不是吗？
That's the CAR of the CDR. It's horrible isn't it?

379
00:21:46,528 --> 00:21:48,780
就是CDR的CAR，很混乱不是吗？
That's the CAR of the CDR. It's horrible isn't it?

380
00:21:52,656 --> 00:21:53,632
过程的CADR
--of the procedure.

381
00:21:55,440 --> 00:22:00,864
绑定形参实参添加进环境中，环境也是随着过程被传递进来
Bind that to the arguments that were passed in the environment, which is passed also as part of the procedure.

382
00:22:00,896 --> 00:22:04,144
绑定形参实参添加进环境中，环境也是随着过程被传递进来
Bind that to the arguments that were passed in the environment, which is passed also as part of the procedure.

383
00:22:04,540 --> 00:22:07,904
也就是CDR的CDR的CAR，过程的CADDR
Well, that's the CAR of the CDR of the CDR of this, CADDR, of the procedure.

384
00:22:09,792 --> 00:22:16,624
也就是CDR的CDR的CAR，过程的CADDR
Well, that's the CAR of the CDR of the CDR of this, CADDR, of the procedure.

385
00:22:20,290 --> 00:22:24,960
(bind (caadr proc) args (caddr proc)) 如果我有点强迫症，这里就会非常谨慎，我会在后面多加一个判断来处理错误情况，比如你对参数应用的是一个过程吗？
Bind, eval, pair, COND, lamda, define-- Now, of course, if I were being really a neat character, and I was being very careful, I would actually put an extra case here for checking for certain errors like, did you try to apply one to an argument?

386
00:22:26,144 --> 00:22:29,680
(bind (caadr proc) args (caddr proc)) 如果我有点强迫症，这里就会非常谨慎，我会在后面多加一个判断来处理错误情况，比如你对参数应用的是一个过程吗？
Bind, eval, pair, COND, lamda, define-- Now, of course, if I were being really a neat character, and I was being very careful, I would actually put an extra case here for checking for certain errors like, did you try to apply one to an argument?

387
00:22:29,872 --> 00:22:31,344
(bind (caadr proc) args (caddr proc)) 如果我有点强迫症，这里就会非常谨慎，我会在后面多加一个判断来处理错误情况，比如你对参数应用的是一个过程吗？
Bind, eval, pair, COND, lamda, define-- Now, of course, if I were being really a neat character, and I was being very careful, I would actually put an extra case here for checking for certain errors like, did you try to apply one to an argument?

388
00:22:32,240 --> 00:22:34,040
(bind (caadr proc) args (caddr proc)) 如果我有点强迫症，这里就会非常谨慎，我会在后面多加一个判断来处理错误情况，比如你对参数应用的是一个过程吗？
Bind, eval, pair, COND, lamda, define-- Now, of course, if I were being really a neat character, and I was being very careful, I would actually put an extra case here for checking for certain errors like, did you try to apply one to an argument?

389
00:22:34,384 --> 00:22:35,984
(bind (caadr proc) args (caddr proc)) 如果我有点强迫症，这里就会非常谨慎，我会在后面多加一个判断来处理错误情况，比如你对参数应用的是一个过程吗？
Bind, eval, pair, COND, lamda, define-- Now, of course, if I were being really a neat character, and I was being very careful, I would actually put an extra case here for checking for certain errors like, did you try to apply one to an argument?

390
00:22:36,176 --> 00:22:38,416
(bind (caadr proc) args (caddr proc)) 如果我有点强迫症，这里就会非常谨慎，我会在后面多加一个判断来处理错误情况，比如你对参数应用的是一个过程吗？
Bind, eval, pair, COND, lamda, define-- Now, of course, if I were being really a neat character, and I was being very careful, I would actually put an extra case here for checking for certain errors like, did you try to apply one to an argument?

391
00:22:39,000 --> 00:22:41,696
如果不是，这里就是未定义的过程类型
You get a undefined procedure type.

392
00:22:42,570 --> 00:22:44,096
这里保持原样
So I may as well do that anyway.

393
00:22:45,808 --> 00:22:55,968
下面加上else，如果出现错误情况
--else, some sort of error, like that.

394
00:22:57,610 --> 00:23:01,616
插个话，目前很多专业用途的系统中，内部的结构也与这类似，主要是分条件判断，分配处理不同情况
Now, of course, again, in some sort of more real system, written for professional reasons, this would be written with a case analysis done by some sort of dispatch.

395
00:23:02,560 --> 00:23:04,224
插个话，目前很多专业用途的系统中，内部的结构也与这类似，主要是分条件判断，分配处理不同情况
Now, of course, again, in some sort of more real system, written for professional reasons, this would be written with a case analysis done by some sort of dispatch.

396
00:23:05,320 --> 00:23:09,904
插个话，目前很多专业用途的系统中，内部的结构也与这类似，主要是分条件判断，分配处理不同情况
Now, of course, again, in some sort of more real system, written for professional reasons, this would be written with a case analysis done by some sort of dispatch.

397
00:23:10,750 --> 00:23:12,672
回到这里，我可能还会添加新的条件判断，比如这是编译过的代码吗？
Over here, I would probably have other cases like, is this compiled code?

398
00:23:12,672 --> 00:23:12,688
回到这里，我可能还会添加新的条件判断，比如这是编译过的代码吗？
Over here, I would probably have other cases like, is this compiled code?
回到这里，我可能还会添加新的条件判断，比如这是编译过的代码吗？
Over here, I would probably have other cases like, is this compiled code?

399
00:23:12,688 --> 00:23:14,160
回到这里，我可能还会添加新的条件判断，比如这是编译过的代码吗？
Over here, I would probably have other cases like, is this compiled code?

400
00:23:16,220 --> 00:23:16,848
这很重要
It's very important.

401
00:23:16,880 --> 00:23:18,352
这样的话我就可以区分一段代码是我通过解释代码对lambda求值得到的结果还是通过编译器编译代码得到的结果
I might have distinguished the kind of code that's produced by a directly evaluating a lambda in interpretation from code that was produced by somebody's compiler or something like that.

402
00:23:18,384 --> 00:23:22,336
这样的话我就可以区分一段代码是我通过解释代码对lambda求值得到的结果还是通过编译器编译代码得到的结果
I might have distinguished the kind of code that's produced by a directly evaluating a lambda in interpretation from code that was produced by somebody's compiler or something like that.

403
00:23:22,944 --> 00:23:25,872
这样的话我就可以区分一段代码是我通过解释代码对lambda求值得到的结果还是通过编译器编译代码得到的结果
I might have distinguished the kind of code that's produced by a directly evaluating a lambda in interpretation from code that was produced by somebody's compiler or something like that.

404
00:23:26,112 --> 00:23:27,230
之后再讨论这个话题
And we'll talk about that later.

405
00:23:27,230 --> 00:23:29,616
又或许是我必须要执行的一段Frotran代码
Or is this a piece Fortran program I have to go off and execute.

406
00:23:30,510 --> 00:23:32,512
如果这种可能发生了，记住，就在这里把情况加进去
It's a perfectly possible thing, at this point, to do that.

407
00:23:32,920 --> 00:23:36,416
事实上，我在写这个求值器的时候，有一个内在的假定即这是一种Lisp语言的实现方式，因为我大量使用了CAR CDR之类
In fact, in this concrete syntax evaluator I'm writing here, there's an assumption built in that this is Lisp, because I'm using CARs and CDRs.

408
00:23:37,456 --> 00:23:40,864
事实上，我在写这个求值器的时候，有一个内在的假定即这是一种Lisp语言的实现方式，因为我大量使用了CAR CDR之类
In fact, in this concrete syntax evaluator I'm writing here, there's an assumption built in that this is Lisp, because I'm using CARs and CDRs.

409
00:23:42,304 --> 00:23:43,824
事实上，我在写这个求值器的时候，有一个内在的假定即这是一种Lisp语言的实现方式，因为我大量使用了CAR CDR之类
In fact, in this concrete syntax evaluator I'm writing here, there's an assumption built in that this is Lisp, because I'm using CARs and CDRs.

410
00:23:43,840 --> 00:23:46,640
CAR意味着操作符，CDR意味着操作数
CAR means the operator, and CDR means the operand.

411
00:23:46,750 --> 00:23:49,968
在这种情形下，就可以想像已经存在了一个抽象的语法解析器，通过它我们就可以取到操作符操作数等等
In the text, there is an abstract syntax evaluator for which these could be-- these are given abstract names like operator, and operand, and all these other things are like that.

412
00:23:50,352 --> 00:23:53,312
在这种情形下，就可以想像已经存在了一个抽象的语法解析器，通过它我们就可以取到操作符操作数等等
In the text, there is an abstract syntax evaluator for which these could be-- these are given abstract names like operator, and operand, and all these other things are like that.

413
00:23:53,312 --> 00:23:53,328
在这种情形下，就可以想像已经存在了一个抽象的语法解析器，通过它我们就可以取到操作符操作数等等
In the text, there is an abstract syntax evaluator for which these could be-- these are given abstract names like operator, and operand, and all these other things are like that.
在这种情形下，就可以想像已经存在了一个抽象的语法解析器，通过它我们就可以取到操作符操作数等等
In the text, there is an abstract syntax evaluator for which these could be-- these are given abstract names like operator, and operand, and all these other things are like that.

414
00:23:53,328 --> 00:23:55,824
在这种情形下，就可以想像已经存在了一个抽象的语法解析器，通过它我们就可以取到操作符操作数等等
In the text, there is an abstract syntax evaluator for which these could be-- these are given abstract names like operator, and operand, and all these other things are like that.

415
00:23:56,160 --> 00:23:56,864
在清楚了这个假定之后，你完全可以用ALGOL再来实现这个求值器
And, in that case, you could reprogram it to be ALGOL with no problem.

416
00:23:57,024 --> 00:24:00,912
在清楚了这个假定之后，你完全可以用ALGOL再来实现这个求值器
And, in that case, you could reprogram it to be ALGOL with no problem.

417
00:24:03,360 --> 00:24:06,400
写完apply之后，发现又引入了一些未定义的过程
Well, here we have added another couple of things that we haven't defined.

418
00:24:07,200 --> 00:24:08,432
写完apply之后，发现又引入了一些未定义的过程
Well, here we have added another couple of things that we haven't defined.

419
00:24:10,810 --> 00:24:12,576
我先不操心这两个，下面这个BIND还是挺有意思的
I don't think I'll worry about these at all, however, this one will be interesting later.

420
00:24:13,392 --> 00:24:15,050
我先不操心这两个，下面这个BIND还是挺有意思的
I don't think I'll worry about these at all, however, this one will be interesting later.

421
00:24:17,184 --> 00:24:19,760
现在我们来快速过一遍，结束这一部分
Let's just proceed through this and get it done.

422
00:24:20,550 --> 00:24:22,656
只剩下两块黑板了，因此它们加起来代码并不多
There's only two more blackboards so it can't be very long.

423
00:24:27,408 --> 00:24:29,088
不过代码还得精心剪裁一番才可以全部放的进黑板
It's carefully tailored to exactly fit.

424
00:24:30,070 --> 00:24:30,980
嗯，还剩下点什么？
Well, what do we have left?

425
00:24:30,980 --> 00:24:33,200
我们得定义那边的evlist
We have to define EVLIST, which is over here.

426
00:24:33,730 --> 00:24:35,072
evlist不过是遍历一串操作数生成实际参数
And EVLIST is nothing more than a map down a bunch of operands producing arguments.

427
00:24:35,264 --> 00:24:43,088
evlist不过是遍历一串操作数生成实际参数
And EVLIST is nothing more than a map down a bunch of operands producing arguments.

428
00:24:44,304 --> 00:24:45,408
但是还是写出来看看
But I'm going to write it out.

429
00:24:45,820 --> 00:24:48,304
还要把它写出来是为了一个神秘的原因，就是我想要求值器简单到可以求值自身
And one of the reasons I'm going to write this out is for a mystical reason, which is I want to make this evaluator so simple that it can understand itself.

430
00:24:49,888 --> 00:24:52,048
还要把它写出来是为了一个神秘的原因，就是我想要求值器简单到可以求值自身
And one of the reasons I'm going to write this out is for a mystical reason, which is I want to make this evaluator so simple that it can understand itself.

431
00:24:52,064 --> 00:24:53,568
还要把它写出来是为了一个神秘的原因，就是我想要求值器简单到可以求值自身
And one of the reasons I'm going to write this out is for a mystical reason, which is I want to make this evaluator so simple that it can understand itself.

432
00:24:56,450 --> 00:24:58,096
这一点还是有点重要的
I'm going to really worry about that a little bit.

433
00:25:00,230 --> 00:25:01,744
现在我就把它完全写在这里
So let's write it out completely.

434
00:25:02,850 --> 00:25:04,240
看，我完全不用操心是否传递入的参数是一个过程
See, I don't want to worry about whether or not the thing can pass functional arguments.

435
00:25:04,272 --> 00:25:06,080
看，我完全不用操心是否传递入的参数是一个过程
See, I don't want to worry about whether or not the thing can pass functional arguments.

436
00:25:06,272 --> 00:25:08,064
求值器并不会真正使用到它们
The value evaluator is not going to use them.

437
00:25:08,980 --> 00:25:10,784
求值器也不会生成一个是过程的值
The evaluator is not going to produce functional values.

438
00:25:10,880 --> 00:25:12,672
因此，如果有一个不同的，和scheme非常相似的语言，它也可以像scheme一样求值比如使用过程参数，返回过程为值，允许过程作为数据
So even if there were a different, alternative language that were very close to this, this evaluates a complex language like Scheme which does allow procedural arguments, procedural values, and procedural data.

439
00:25:12,800 --> 00:25:13,968
因此，如果有一个不同的，和scheme非常相似的语言，它也可以像scheme一样求值比如使用过程参数，返回过程为值，允许过程作为数据
So even if there were a different, alternative language that were very close to this, this evaluates a complex language like Scheme which does allow procedural arguments, procedural values, and procedural data.

440
00:25:15,160 --> 00:25:17,792
因此，如果有一个不同的，和scheme非常相似的语言，它也可以像scheme一样求值比如使用过程参数，返回过程为值，允许过程作为数据
So even if there were a different, alternative language that were very close to this, this evaluates a complex language like Scheme which does allow procedural arguments, procedural values, and procedural data.

441
00:25:17,808 --> 00:25:23,120
因此，如果有一个不同的，和scheme非常相似的语言，它也可以像scheme一样求值比如使用过程参数，返回过程为值，允许过程作为数据
So even if there were a different, alternative language that were very close to this, this evaluates a complex language like Scheme which does allow procedural arguments, procedural values, and procedural data.

442
00:25:24,070 --> 00:25:25,952
值得注意的是，如果我对ALGOL语言求值，也可以使用这个求值器，尽管ALGOL并不允许过程作为返回值
But even if I were evaluating ALGOL, which doesn't allow procedural values, I could use this evaluator.

443
00:25:27,344 --> 00:25:28,960
值得注意的是，如果我对ALGOL语言求值，也可以使用这个求值器，尽管ALGOL并不允许过程作为返回值
But even if I were evaluating ALGOL, which doesn't allow procedural values, I could use this evaluator.

444
00:25:29,472 --> 00:25:30,592
值得注意的是，如果我对ALGOL语言求值，也可以使用这个求值器，尽管ALGOL并不允许过程作为返回值
But even if I were evaluating ALGOL, which doesn't allow procedural values, I could use this evaluator.

445
00:25:31,580 --> 00:25:33,920
因为这个解释器并没有对这些事情做过什么假定
And this evaluator is not making any assumptions about that.

446
00:25:34,272 --> 00:25:37,216
事实上，如果被求值的语言真的被限定了不能做这做那，没关系，只能算它们没有使用到这些高级功能
And, in fact, if this value were to be restricted to not being able to that, it wouldn't matter, because it doesn't use any of those clever things.

447
00:25:37,248 --> 00:25:39,936
事实上，如果被求值的语言真的被限定了不能做这做那，没关系，只能算它们没有使用到这些高级功能
And, in fact, if this value were to be restricted to not being able to that, it wouldn't matter, because it doesn't use any of those clever things.

448
00:25:40,640 --> 00:25:42,416
这也是为什么我可以将求值器组织的如此简单
So that's why I'm arranging this to be super simple.

449
00:25:44,070 --> 00:25:46,464
这几乎是所有现存语言求值器的核心
This is sort of the kernel of all possible language evaluators.

450
00:25:47,810 --> 00:25:48,480
回到这个定义上来
How about that?

451
00:25:49,420 --> 00:25:53,568
evlise，它是什么呢？
Evlist--  well, what is it?

452
00:25:53,820 --> 00:25:57,040
这个过程也有两个参数，l和env，l是所有参数的列表，如果l为空，就返回一个空列表，否则就先在环境中求值第一个参数
It's the procedure of two arguments, l and an environment,

453
00:25:58,096 --> 00:25:59,088
这个过程也有两个参数，l和env，l是所有参数的列表，如果l为空，就返回一个空列表，否则就先在环境中求值第一个参数
It's the procedure of two arguments, l and an environment, where l is a list such that if the list of arguments is the empty list, then the result is the empty list. Otherwise, I want to cons up the result of evaluating the CAR of the list of operands in the environment.

454
00:25:59,584 --> 00:26:08,272
这个过程也有两个参数，l和env，l是所有参数的列表，如果l为空，就返回一个空列表，否则就先在环境中求值第一个参数
It's the procedure of two arguments, l and an environment, where l is a list such that if the list of arguments is the empty list, then the result is the empty list. Otherwise, I want to cons up the result of evaluating the CAR of the list of operands in the environment.

455
00:26:10,192 --> 00:26:12,688
这个过程也有两个参数，l和env，l是所有参数的列表，如果l为空，就返回一个空列表，否则就先在环境中求值第一个参数
It's the procedure of two arguments, l and an environment, where l is a list such that if the list of arguments is the empty list, then the result is the empty list. Otherwise, I want to cons up the result of evaluating the CAR of the list of operands in the environment.

456
00:26:14,032 --> 00:26:19,232
这个过程也有两个参数，l和env，l是所有参数的列表，如果l为空，就返回一个空列表，否则就先在环境中求值第一个参数
It's the procedure of two arguments, l and an environment, where l is a list such that if the list of arguments is the empty list, then the result is the empty list. Otherwise, I want to cons up the result of evaluating the CAR of the list of operands in the environment.

457
00:26:20,752 --> 00:26:26,672
这个过程也有两个参数，l和env，l是所有参数的列表，如果l为空，就返回一个空列表，否则就先在环境中求值第一个参数
It's the procedure of two arguments, l and an environment, where l is a list such that if the list of arguments is the empty list, then the result is the empty list. Otherwise, I want to cons up the result of evaluating the CAR of the list of operands in the environment.

458
00:26:28,160 --> 00:26:32,512
这个过程也有两个参数，l和env，l是所有参数的列表，如果l为空，就返回一个空列表，否则就先在环境中求值第一个参数
It's the procedure of two arguments, l and an environment, where l is a list such that if the list of arguments is the empty list, then the result is the empty list. Otherwise, I want to cons up the result of evaluating the CAR of the list of operands in the environment.

459
00:26:33,344 --> 00:26:35,712
求值第一个参数之后，我想要在当前环境递归evlist求值CDR部分，和第一个求值结果连接为列表
So I want the first operand evaluated, and I'm going to make a list of the results by CONSing that onto the result of this EVLISTing as a CDR recursion, the CDR of the list relative to the same environment.

460
00:26:35,984 --> 00:26:38,400
求值第一个参数之后，我想要在当前环境递归evlist求值CDR部分，和第一个求值结果连接为列表
So I want the first operand evaluated, and I'm going to make a list of the results by CONSing that onto the result of this EVLISTing as a CDR recursion, the CDR of the list relative to the same environment.

461
00:26:38,976 --> 00:26:45,424
求值第一个参数之后，我想要在当前环境递归evlist求值CDR部分，和第一个求值结果连接为列表
So I want the first operand evaluated, and I'm going to make a list of the results by CONSing that onto the result of this EVLISTing as a CDR recursion, the CDR of the list relative to the same environment.

462
00:26:46,224 --> 00:26:50,130
求值第一个参数之后，我想要在当前环境递归evlist求值CDR部分，和第一个求值结果连接为列表
So I want the first operand evaluated, and I'm going to make a list of the results by CONSing that onto the result of this EVLISTing as a CDR recursion, the CDR of the list relative to the same environment.

463
00:26:53,088 --> 00:26:58,240
闭合括号evlist cons else cond lambda define，还有一个过程我也想写在这里
Evlist, cons, else, COND, lambda, define--  And I have one more that I want to put on the blackboard.

464
00:26:59,664 --> 00:27:03,360
闭合括号evlist cons else cond lambda define，还有一个过程我也想写在这里
Evlist, cons, else, COND, lambda, define--  And I have one more that I want to put on the blackboard.

465
00:27:03,620 --> 00:27:05,216
它是整件事的关键部分
It's the essence of this whole thing.

466
00:27:05,648 --> 00:27:08,130
还要深入一个层次
And there's some sort of next layer down.

467
00:27:14,540 --> 00:27:15,440
条件式 -- 在剩下的过程中，条件式是唯一一个非常重要的过程
Conditionals-- conditionals are the only thing left that are sort of substantial.

468
00:27:15,696 --> 00:27:18,170
条件式 -- 在剩下的过程中，条件式是唯一一个非常重要的过程
Conditionals-- conditionals are the only thing left that are sort of substantial.

469
00:27:18,880 --> 00:27:20,752
除了这个，我们还有lookup bind的过程要讨论
Then below that, we have to worry about things like lookup and bind, and we'll look at that in a second.

470
00:27:21,072 --> 00:27:22,944
除了这个，我们还有lookup bind的过程要讨论
Then below that, we have to worry about things like lookup and bind, and we'll look at that in a second.

471
00:27:23,568 --> 00:27:25,360
除了这个，我们还有lookup bind的过程要讨论
Then below that, we have to worry about things like lookup and bind, and we'll look at that in a second.

472
00:27:25,530 --> 00:27:27,936
但是在这个讨论事情相对具体的层次上，下一个重要的事就是你如何处理条件式
But of the substantial stuff at this level of detail, next important thing is how you deal with conditionals.

473
00:27:28,656 --> 00:27:30,624
但是在这个讨论事情相对具体的层次上，下一个重要的事就是你如何处理条件式
But of the substantial stuff at this level of detail, next important thing is how you deal with conditionals.

474
00:27:31,600 --> 00:27:33,330
这里，条件式具体要怎么写？
Well, how do we have a conditional thing?

475
00:27:36,976 --> 00:27:45,008
它是一个过程，参数是一串子句和环境
It's a procedure of a set of clauses and an environment.

476
00:27:47,712 --> 00:27:48,512
它做些什么呢？
And what does it do?

477
00:27:49,820 --> 00:27:55,472
如果这里没有子句，我得有一个返回值
It says, if I've no more clauses, well, I have to give this a value.

478
00:28:02,608 --> 00:28:03,968
如果这里没有子句，我得有一个返回值
It says, if I've no more clauses, well, I have to give this a value.

479
00:28:04,704 --> 00:28:05,872
可能是一个错误
It could be that it was an error.

480
00:28:06,540 --> 00:28:08,592
假设它遍历完了所有条件，都没有符合的，接下来发生什么还真不好说
Supposing it run off the end of a conditional, it's pretty arbitrary.

481
00:28:09,152 --> 00:28:10,060
假设它遍历完了所有条件，都没有符合的，接下来发生什么还真不好说
Supposing it run off the end of a conditional, it's pretty arbitrary.

482
00:28:10,060 --> 00:28:12,880
这完全取决于我，作为一个程序员可以选择应该怎么处理
It's up to me as programmer to choose what I want to happen.

483
00:28:13,650 --> 00:28:15,456
对我来说实在太方便了，现在我写一个空列表作为返回值，完全无碍
It's convenient for me, right now, to write down that this has a value which is the empty list, doesn't matter.

484
00:28:15,632 --> 00:28:17,536
对我来说实在太方便了，现在我写一个空列表作为返回值，完全无碍
It's convenient for me, right now, to write down that this has a value which is the empty list, doesn't matter.

485
00:28:18,144 --> 00:28:18,832
对我来说实在太方便了，现在我写一个空列表作为返回值，完全无碍
It's convenient for me, right now, to write down that this has a value which is the empty list, doesn't matter.

486
00:28:20,100 --> 00:28:20,880
如是有些人倾向于错误检测，他们可以在这里写点别的
For error checking, some people might prefer something else.

487
00:28:20,896 --> 00:28:22,760
如是有些人倾向于错误检测，他们可以在这里写点别的
For error checking, some people might prefer something else.

488
00:28:23,110 --> 00:28:24,816
下面的更有意思
But the interesting things are the following ones.

489
00:28:25,392 --> 00:28:27,248
这里有一系列的子句，每个子句都是一个列表，假如我遇到一个else子句，子句的谓词部分应该是子句的CAAR
If I've got an else clause--  You see, if I have a list of clauses, then each clause is a list. And so the predicate part is the CAAR of the clauses.

490
00:28:31,000 --> 00:28:32,736
这里有一系列的子句，每个子句都是一个列表，假如我遇到一个else子句，子句的谓词部分应该是子句的CAAR
If I've got an else clause--  You see, if I have a list of clauses, then each clause is a list. And so the predicate part is the CAAR of the clauses.

491
00:28:33,216 --> 00:28:34,416
这里有一系列的子句，每个子句都是一个列表，假如我遇到一个else子句，子句的谓词部分应该是子句的CAAR
If I've got an else clause--  You see, if I have a list of clauses, then each clause is a list. And so the predicate part is the CAAR of the clauses.

492
00:28:35,440 --> 00:28:40,528
这里有一系列的子句，每个子句都是一个列表，假如我遇到一个else子句，子句的谓词部分应该是子句的CAAR
If I've got an else clause--  You see, if I have a list of clauses, then each clause is a list. And so the predicate part is the CAAR of the clauses.

493
00:28:43,560 --> 00:28:45,024
所有子句中第一个子句的第一个部分
It's the CAR, which is the first part of the first clause in the list of clauses.

494
00:28:45,040 --> 00:28:49,008
所有子句中第一个子句的第一个部分
It's the CAR, which is the first part of the first clause in the list of clauses.

495
00:28:51,090 --> 00:28:51,840
如果是else，就意味着整个条件式的结果就是执行这个else子句中表达式的结果
If it's an else, then it means I want my result of the conditional to be the result of evaluating the matching expression.

496
00:28:54,320 --> 00:28:56,510
如果是else，就意味着整个条件式的结果就是执行这个else子句中表达式的结果
If it's an else, then it means I want my result of the conditional to be the result of evaluating the matching expression.

497
00:28:56,640 --> 00:28:59,152
如果是else，就意味着整个条件式的结果就是执行这个else子句中表达式的结果
If it's an else, then it means I want my result of the conditional to be the result of evaluating the matching expression.

498
00:28:59,800 --> 00:29:22,195
所以接着对CADAR部分在当前环境下求值，就是第一个子句的第二个部分
So I eval the CADAR. So this is the first clause, the second element of it, CADAR-- CADAR of a CAR-- of the clauses, with respect to the environment.

499
00:29:26,620 --> 00:29:29,630
下一种可能性更有意思
Now the next possibility is more interesting.

500
00:29:29,630 --> 00:29:44,360
如果不是else子句，而且子句的谓词结果是false -- 我们接着写
If it's false, if the first predicate in the predicate list is not an else, and it's not false, if it's not the word else, and if it's not a false thing-- Let's write down what it is if it's a false thing.

501
00:29:44,360 --> 00:30:04,180
在当前环境下求值子句的谓词部分，如果是false，这就意味着还得接着判断下面的子句
If the result of evaluating the first predicate, the clauses--  respect the environment, if that evaluation yields false, then it means, I want to look at the next clause.

502
00:30:04,180 --> 00:30:05,990
第一个就扔掉不管了
So I want to discard the first one.

503
00:30:05,990 --> 00:30:16,700
我们还得在当前环境下，继续递归evcond循环子句的CDR部分
So we just go around loop, evcond, the CDR of the clauses relative to that environment.

504
00:30:21,240 --> 00:30:41,960
又或者，我遇到了一个真子句，即求值子句的谓词部分结果为真
And otherwise, I had a true clause, in which case, what I want is to evaluate the CADAR of the clauses relative to that environment.

505
00:30:48,200 --> 00:30:51,210
条件式就要到尾声了
Boy, it's almost done.

506
00:30:51,210 --> 00:30:53,730
非常近了
It's quite close to done.

507
00:30:53,730 --> 00:30:56,210
把这一部分结束
I think we're going to finish this part off.

508
00:30:56,210 --> 00:31:01,220
回到全局再看一遍求值器，你已经对它有一个完整的把握了
So just buzzing through this evaluator, but so far you're seeing almost everything.

509
00:31:01,220 --> 00:31:04,040
接着来看一张幻灯片
Let's look at the next transparency here.

510
00:31:08,980 --> 00:31:11,980
bind的定义
Here is bind.

511
00:31:11,980 --> 00:31:15,460
bind在环境中添加新的绑定
Bind is for making more table.

512
00:31:15,460 --> 00:31:22,800
我们这里先依照环境的数据结构构造一个frame
And what we are going to do here is make a-- we're going to make a no-frame for an environment structure.

513
00:31:22,800 --> 00:31:28,080
环境就是由一系列的frame组成的
The environment structure is going to be represented as a list of frames.

514
00:31:28,080 --> 00:31:49,690
所以对于环境来说，我把一个新的frame和环境连接在一起就构成了新的环境，新的frame是由pair-up对形参与实参进行绑定得到的结果
So given an existing environment structure, I'm going to make a new environment structure by consing a new frame onto the existing environment structure, where the new frame consists of the result of pairing up the variables, which are the bound variables of the procedure I'm applying, to the values which are the arguments that were passed that procedure.

515
00:31:49,690 --> 00:31:58,391
环境也就是一个列表而已，构造一个新frame元素，添加入列表就构成了新环境
This is just making a list, adding a new element to our list of frames, which is an environment structure, to make a new environment.

516
00:31:58,391 --> 00:32:01,540
其实pair-up非常简单
Where pair-up is very simple.

517
00:32:01,540 --> 00:32:09,720
对于一个变量的列表和一个值的列表，两个列表中元素个数应该相同
Pair-up is nothing more than if I have a list of variables and a list of values, well, if I run out of variables and if I run out of values, everything's OK.

518
00:32:09,720 --> 00:32:12,990
如果不同，就是实参的数目不对了
Otherwise, I've given too many arguments.

519
00:32:12,990 --> 00:32:18,560
假如值遍历完了，还剩下有变量，说明实参给少了
If I've not run out of variables, but I've run out of values, that I have too few arguments.

520
00:32:18,560 --> 00:32:42,950
如果没有遇到错误，即变量和值是可以对上号的，就应该用第一个变量和第一个值构造一个序对，和pair-up对两列表CDR的求值结果相连接
And in the general case, where I don't have any errors, and I'm not done, then I really am just adding a new pair of the first variable with the first argument, the first value, onto a list resulting from pairing-up the rest of the variables with the rest of the values.

521
00:32:42,950 --> 00:32:46,620
lookup也简单
Lookup is of course equally simple.

522
00:32:46,620 --> 00:32:54,650
假使我要在环境中查找一个变量，环境是空的，这个变量就是未绑定的
If I have to look up a symbol in an environment, well, if the environment is empty, then I've got an unbound variable.

523
00:32:54,650 --> 00:33:05,930
否则，就调用一个新的过程来从环境的第一个frame开始查找变量
Otherwise, what I'm going to do is use a special pair list lookup procedure, which we'll have very shortly, of the symbol in the first frame of the environment.

524
00:33:05,930 --> 00:33:09,200
因为环境不是空的，所以一定有第一个frame
Since I know the environment is not empty, it must have a first frame.

525
00:33:09,200 --> 00:33:11,140
所以我就在第一个frame中查找
So I lookup the symbol in the first frame.

526
00:33:11,140 --> 00:33:15,150
找到的序对也就是这里的vcell
That becomes the value cell here.

527
00:33:15,150 --> 00:33:23,720
如果vcell为空，我就需要在环境中剩下的frame中查找
And then, if the value cell is empty, if there is no such value cell, then I have to continue and look at the rest of the frames.

528
00:33:23,720 --> 00:33:25,990
vcell为空意味着当前frame没有找到变量
It means there was nothing found there.

529
00:33:25,990 --> 00:33:32,010
如果没有找到，assq就会返回空值
So that's a property of ASSQ is it returns emptiness if it doesn't find something.

530
00:33:32,010 --> 00:33:41,050
如果找到了，值就应该是vcell的CDR部分，因为vcell是一个变量和值的序对
but if it did find something, then I'm going to use the CDR of the value cell here, which is the thing that was the pair consisting of the variable and the value.

531
00:33:41,050 --> 00:33:45,000
因此CDR就取到了值
So the CDR of it is the value part.

532
00:33:45,000 --> 00:33:47,970
assq这个过程你们之前见过
Finally, ASSQ is something you've probably seen already.

533
00:33:47,970 --> 00:33:53,760
assq取一个符号和一系列序对的列表，如果列表为空，变返回'()
ASSQ takes a symbol and a list of pairs, and if the list is empty, it's empty.

534
00:33:53,760 --> 00:33:59,820
如果符号等于列表中第一个 -- 这里写错了
If the symbol is the first thing in the list-- That's an error.

535
00:33:59,820 --> 00:34:04,160
应该是CAAR，大家注意了
That should be CAAR, C-A-A-R. Everybody note that.

536
00:34:07,730 --> 00:34:08,980
就是这里，看见了吗？
Right there, OK?

537
00:34:13,121 --> 00:34:35,190
如果符号等于列表的CAAR，然后就取列表的第一个序对元素作为返回值，这就是我们要找的绑定；如果符号与之不相同，就在剩下的列表中继续查找。很抱歉刚才幻灯片上面写错了
And in any case, if the symbol is the CAAR of the A list, then I want the first, the first pair, in the A list. So, in other words, if this is the key matching the right entry, otherwise, I want to look up that symbol in the rest. Sorry for producing a bug, bugs appear.

538
00:34:35,190 --> 00:34:39,639
到现在为止，你们也已看到了全貌
Well, in any case, you're pretty much seeing the whole thing now.

539
00:34:41,880 --> 00:34:49,600
虽然用很难看的编程方式书写出来，但是仍然不能掩盖它的美丽与优雅，这正是语言的核心所在
It's a very beautiful thing, even though it's written in an ugly style, being the kernel of every language.

540
00:34:49,600 --> 00:34:51,460
这样优美的程序，我们可以多看一会儿[骗人啊，说好的只写一黑板呢，又刷出N张幻灯片啊]
I suggest that we just-- let's look at it for a while.

541
00:34:56,749 --> 00:35:49,750
[MUSIC PLAYING]
[MUSIC PLAYING]

542
00:35:49,750 --> 00:35:51,000
大家有什么问题吗？
Are there any questions?

543
00:36:01,180 --> 00:36:04,044
没有的话就休息一会儿吧
Alright, I suppose it's time to take a small break then.

544
00:36:04,044 --> 00:36:56,780
[MUSIC PLAYING]
[MUSIC PLAYING]

545
00:36:56,780 --> 00:37:03,470
这一节我们用一个实例来理解一下求值器的运作过程
OK, now we're just going to do a little bit of practice understanding what it is we've just shown you.

546
00:37:03,470 --> 00:37:11,500
我们根据求值器的工作过程，手写出解释器中的代换过程
What we're going to do is go through, in detail, an evaluation by informally substituting through the interpreter.

547
00:37:11,500 --> 00:37:25,330
因为这个求值器的并没有赋值与定义的实现，所以我们只管放心的代换，不用担心任何副作用
And since we have no assignments or definitions in this interpreter, we have no possible side effects, and so the we can do substitution with impunity and not worry about results.

548
00:37:25,330 --> 00:37:30,690
我举一个特别点儿的例子吧
So the particular problem I'd like to look at is it an interesting one.

549
00:37:30,690 --> 00:37:59,890
(eval '(((lambda(x) (lambda(y) (+ x y))) 3) 4) <e0>)
It's the evaluation of quote, open, open, open, lambda of x, lambda of y plus x y, lambda, lambda, applied to three, applied to four, in some global environment which I'll call e0.

550
00:38:04,930 --> 00:38:14,300
一个参数为x的过程，生成一个参数为y的过程，其中运算x + y
So what we have here is a procedure of one argument x, which produces as its value a procedure of one argument y, which adds x to y.

551
00:38:14,300 --> 00:38:17,960
外层的这个过程应用于数字3
We are applying the procedure of one argument x to three.

552
00:38:17,960 --> 00:38:21,400
所以x应该是3
So x should become three.

553
00:38:21,400 --> 00:38:26,167
生成的结果应该是一个参数为y的过程，应用于数字4
And the result of that should be procedure of one argument y, which will then apply to 4.

554
00:38:28,910 --> 00:38:34,790
然后要做的也很简单，得到x与y的和
And there is a very simple case, they will then add those results.

555
00:38:34,790 --> 00:38:37,660
具体做之前，先来构造环境
And now in order to do that, I want to make a very simple environment model.

556
00:38:37,660 --> 00:38:44,460
我相信你们对于环境已经了然于胸
And at this point, you should already have in your mind the environments that this produces.

557
00:38:44,460 --> 00:38:56,740
我们从全局环境开始，称之为e0
But we're going to start out with a global environment, which I'll call e0, which is that.

558
00:38:56,740 --> 00:39:31,270
里面应该有+、*的过程定义 -- 我这里用希腊字母来表示过程对象，有没有很好玩儿 -- 还有 - / CAR CDR CONS EQ?等等，所有你能想到的基本过程都在这里
And it's going to have in it things, definitions for plus, and times, and-- using Greek letters, isn't that interesting, for the objects-- and minus, and quotient, and CAR, and CDR, and CONS, and EQ, and everything else you might imagine in a global environment.

559
00:39:31,270 --> 00:39:39,220
每个符号都有一个过程对象，由机器底层实现的，这就是环境e0
It's got something there for each of those things, something the machine is born with, that's e0.

560
00:39:39,220 --> 00:39:42,940
这对求值意味着什么呢？
Now what does it mean to do this evaluation?

561
00:39:42,940 --> 00:39:48,670
现在我们开始求值这个例子，从特殊形式开始查找，第一，这不是一个数字
Well, we go through the set of special forms. First of all, this is not a number.

562
00:39:48,670 --> 00:39:50,380
也不是符号
This is not a symbol.

563
00:39:53,210 --> 00:39:56,520
这不是一个引用表达式
Gee, it's not a quoted expression.

564
00:39:56,520 --> 00:40:00,600
这其实是一个被引用的表达式，但不是我们所关注的那种 引用表达式
This is a quoted expression, but that's not what I interested in.

565
00:40:00,600 --> 00:40:05,890
问题在于，是否被引的就一定是引用表达式？
The question is, whether or not the thing which is quoted is quoted expression?

566
00:40:05,890 --> 00:40:07,960
现在求值这个表达式
I'm evaluating an expression.

567
00:40:07,960 --> 00:40:11,410
可以理解为 ' 说明这是一个特殊的表达式
This just says it's this particular expression.

568
00:40:11,410 --> 00:40:12,660
并非是引用表达式
This is not a quoted expression.

569
00:40:15,230 --> 00:40:19,120
继续我们对特殊形式的判断中来，表达式也不以lambda开头
It's not a thing that begins with lambda.

570
00:40:19,120 --> 00:40:22,030
也不以cond开头
It's not a thing that begins with COND.

571
00:40:22,030 --> 00:40:26,310
因此它不在特殊形式之列，它属于操作符应用于操作数之类
Therefore, it's an application of its of an operated operands.

572
00:40:26,310 --> 00:40:28,570
这是一个组合式
It's a combination.

573
00:40:28,570 --> 00:40:36,480
这一部分是它的操作符，这里是操作数
The combination thus has this as the operator and this is the operands.

574
00:40:40,130 --> 00:41:24,450
根据eval的规则，变换成为(apply (eval '((lambda(x) (lambda(y) (+ x y))) 3) <e0>) (evlist '(4) <e0>)
Well, that means that what I'm going to do is transform this into apply of eval, of quote, open, open lambda of x, lambda of y-- I'm evaluating the operator-- plus x y, in the environment, also e0, with the operands that I'm going to apply this to, the arguments being the result of EVLIST, the list containing four, fin e0.

575
00:41:29,010 --> 00:41:36,840
我把e0写的很特别是来强调它是环境的身份
I'm using this funny notation here for e0 because this should be that environment.

576
00:41:36,840 --> 00:41:39,890
我无法为它命名，因为命名需要其它环境
I haven't a name for it, because I have no environment to name it in.

577
00:41:41,960 --> 00:41:47,730
这些就是引用表达式的表示形式
So this is just a representation of what would be a quoted expression, if you will.

578
00:41:47,730 --> 00:41:53,040
环境是那样来表示的
The data structure, which is the environment, goes there.

579
00:41:53,040 --> 00:41:55,850
好的，经过变换就成了这样
Well, that's what we're seeing here.

580
00:41:55,850 --> 00:41:59,610
为了执行apply，我得先执行eval和evlist
Well in order to do this, I have to do this, and I have to do that.

581
00:41:59,610 --> 00:42:03,770
evlist简单点，我们先计算这个吧
Well this one's easy, so why don't we do that one first.

582
00:42:03,770 --> 00:42:09,520
上面的一行复制下来
This turns into apply of eval-- just copying something now.

583
00:42:09,520 --> 00:42:11,000
代换的过程中我们得重复不少笔墨
Most of the substitution rule is copying.

584
00:42:18,530 --> 00:42:23,350
抄写的时候我就不说什么了，这样快一点儿
So I'm going to not say the words when I copy, because it's faster.

585
00:42:26,100 --> 00:42:48,910
下面evlist的部分就代换成为 (cons (eval '4 <e0>) (evlist '() <e0>))
And then the EVLIST is going to turn into a cons, of eval, of four, in e0--  because it was not an empty list-- onto the result of EVLISTing, on the empty list, in e0.

586
00:42:52,580 --> 00:42:55,800
步骤开始有点乏味，我开始想略过一点了
And I'm going to start leaving out steps soon, because it's going to get boring.

587
00:42:59,870 --> 00:43:20,240
上面的再抄下来
But this is basically the same thing as apply, of eval--  I'm going to keep doing this-- the lambda of x, the lambda of y, plus xy, 3, close, e0.

588
00:43:20,240 --> 00:43:21,490
一字不差吧
I'm a pretty good machine.

589
00:43:24,690 --> 00:43:28,790
到下面的eval，4是一个数字
Well, eval of four, that's meets the question, is it a number.

590
00:43:28,790 --> 00:43:35,280
4求值出来还是4
So that's cons, cons of 4.

591
00:43:35,280 --> 00:43:39,240
evlist这里参数是空列表，结果相应也是空列表
And EVLIST of the empty list is the empty list, so that's this.

592
00:43:43,270 --> 00:43:48,710
一起代换过来，就是(cons 4 '())
And that's very simple to understand, because that means the list containing four itself.

593
00:43:48,710 --> 00:44:13,940
上面的再抄下来，下面的(cons 4 '())就是'(4)
So this is nothing more than apply of eval, quote, open, open, lambda of x, lambda of y, plus x y, three applied to, e0, applied to the list four-- bang.

594
00:44:13,940 --> 00:44:15,190
变换结果就是这样
So that's that step.

595
00:44:18,100 --> 00:44:20,360
我们来看下一个有趣的部分
Now let's look at the next, more interesting thing.

596
00:44:20,360 --> 00:44:23,070
这一行怎么来变换？
What do I do to evaluate that?

597
00:44:23,070 --> 00:44:29,460
变换这一行之前我得先变换eval这部分
Evaluating this means I have to evaluate-- Well, it's not.

598
00:44:29,460 --> 00:44:31,680
这一部分的表达式也属于操作符应用操作数的类型
It's nothing but an application.

599
00:44:31,680 --> 00:44:33,570
也不属于特殊形式
It's not one of the special things.

600
00:44:33,570 --> 00:44:46,570
操作符是这一大部分，应用于操作数，整体是一个组合式
If the application of this operator, which we see here-- here's the operator-- applied to this operands, that combination.

601
00:44:46,570 --> 00:44:52,370
我们很清楚变换的规则，它就在eval内部条件式的最后
But we know how to do that, because that's the last case of the conditional.

602
00:44:52,370 --> 00:45:01,160
变换这一部分，就大概像(apply (eval operator) (evlist operands))这样
So substituting in for this evaluation, it's apply of eval of the operator in the EVLIST of the operands.

603
00:45:01,160 --> 00:45:25,350
我们接着写，(apply (apply (eval '(lambda(x) (lambda(y) (+ x y))) <e0>)
Well, it's apply, of apply, of eval, of quote, open, lambda of x, lambda of y, plus x y, lambda, lambda, in environment e0.

604
00:45:30,520 --> 00:45:35,230
操作数这里的变换我就直接写结果了，因为和前面是一样的
I'm going to short circuit the evaluation of the operands , because they're the same as they were before.

605
00:45:35,230 --> 00:45:39,330
过程应用于列表'(3)，再应用于'(4)
I got a list containing three, apply that, and apply that to four.

606
00:45:42,780 --> 00:45:44,410
我们接着看
Well let's see.

607
00:45:44,410 --> 00:45:49,450
求值lambda表达式生成一个过程对象
Eval of a lambda expression produces a procedure object.

608
00:45:52,030 --> 00:46:12,130
继续变换，(apply (apply '(closure ((x) (lambda(y) (+ x y))))
So this is apply, of apply, of the procedure object closure, which contains the body of the procedure, x, which is lambda-- which binds x [UNINTELLIGIBLE]

609
00:46:12,130 --> 00:46:20,630
这个过程内部返回一个形参为y的过程，对x和y求和
the internals of the body, it returns the procedure of one argument y, which adds x to y.

610
00:46:23,210 --> 00:46:30,340
还要记得环境e0，因为在环境下求值才有意义
Environment e0 is now captured in it, because this was evaluated with respect to e0.

611
00:46:30,340 --> 00:46:33,040
e0现在也是closure对象的一部分了
e0 is part now of the closure object.

612
00:46:33,040 --> 00:46:41,300
应用予'(3)，再应用于'(4)
Apply that to open, three, close, apply, to open, 4, close, apply.

613
00:46:47,390 --> 00:46:57,150
这样一步步的变换过来，现在构造了一个过程对象，并且包含了环境e0
So going from this step to this step meant that I made up a procedure object which captured in it e0 as part of the procedure object.

614
00:46:57,150 --> 00:46:58,620
现在是过程应用参数求值的时候了
Now, we're going to pass those to apply.

615
00:46:58,620 --> 00:47:02,710
我们得把过程应用于实际参数
We have to apply this procedure to that set of arguments.

616
00:47:02,710 --> 00:47:07,380
这里的过程并不是基本过程
Well, but that procedure is not primitive.

617
00:47:07,380 --> 00:47:13,710
事实上看到标志'closure就已经知道这不是基本过程了，而且这里我们还需要进行参数绑定
It's, in fact, a thing which has got the tag closure, and, therefore, what we have to do is do a bind.

618
00:47:13,710 --> 00:47:15,830
必须要绑定
We have to bind.

619
00:47:15,830 --> 00:47:28,230
这里构造一个新环境，父环境是e0
A new environment is made at this point, which has as its parent environment the one over here, e0, that environment.

620
00:47:30,320 --> 00:47:31,570
命名这个环境为e1
And we'll call this one, e1.

621
00:47:34,620 --> 00:47:36,040
这里要绑定些什么呢？
Now what's bound in there?

622
00:47:36,040 --> 00:47:38,620
变量x绑定为值3
x is bound to three.

623
00:47:38,620 --> 00:47:41,480
这里写x=3
So I have x equal three.

624
00:47:41,480 --> 00:47:42,730
这样就行
That's what's in there.

625
00:47:44,940 --> 00:47:46,240
新环境叫e1
And we'll call that e1.

626
00:47:46,240 --> 00:48:00,290
这样的话，里面的过程，即(lambda(y) (+ x y))就应该在e1的环境下来求值了
So what this transforms into is an eval of the body of this, which is this, the body of that procedure, in the environment that you just saw.

627
00:48:00,290 --> 00:48:16,520
即 (apply (eval '(lambda(y) (+ x y)) <e1>)
So that's an apply, of eval, quote, open, lambda of y, plus x y-- the body--  in e1.

628
00:48:20,660 --> 00:48:28,680
应用于参数列表'(4)
And apply the result of that to four, open, close, 4-- list of arguments.

629
00:48:28,680 --> 00:48:33,110
到了这里，变换过程就变得很清晰了，我知道该做什么
Well, that's sensible enough because evaluating a lambda, I know what to do.

630
00:48:33,110 --> 00:48:52,150
这和上面的很类似，继续变换(apply '(closure ((y) (+ x y)) <e1>)
That means I apply, the procedure which is closure, binds one argument y, adds x to y, with e1 captured in it.

631
00:48:55,790 --> 00:48:57,800
你应该已经知道了
And you should really see this.

632
00:48:57,800 --> 00:49:00,140
我构造了一个closure对象
I somehow manufactured a closure.

633
00:49:00,140 --> 00:49:01,790
放在这里
I should've put this here.

634
00:49:01,790 --> 00:49:03,040
这里也有一个，是前面lambda (x)的那个
There was one over here too.

635
00:49:06,230 --> 00:49:08,080
这是现在的这个
Well, there's one here now.

636
00:49:08,080 --> 00:49:17,880
closure内部是有参数为y的过程体和环境e1
I've captured e1, and this is the procedure of one argument y, whatever this is.

637
00:49:17,880 --> 00:49:20,435
这就是这里的closure
That's what that is there, that closure.

638
00:49:23,040 --> 00:49:26,230
将这个过程应用于'(4)
I'm going to apply that to four.

639
00:49:30,690 --> 00:49:31,940
很简单
Well, that's easy enough.

640
00:49:36,830 --> 00:49:49,540
这就意味着我还得构造一个新环境，绑定变量y为数字4
That means I have to make a new environment by copying this pointer, which was the pointer of the procedure, which binds y equal 4 with that environment.

641
00:49:49,540 --> 00:49:52,460
这个是新环境，称为e2
And here's my new environment, which I'll call e2.

642
00:49:55,870 --> 00:50:01,910
接着就是在环境e2中求值过程体(+ x y)
And, of course, this application then is evaluate the body in e2.

643
00:50:01,910 --> 00:50:13,710
然后变换为，(eval '(+ x y) <e2>)
So this is eval, the body, which is plus x y, in the environment e2.

644
00:50:13,710 --> 00:50:37,340
继续变换，(apply (eval '+ <e2>) (evlist '(x y) <e2>))
But this is an application, so this is the apply, of eval, plus in e2, an EVLIST, quote, open, x y, in e2.

645
00:50:44,880 --> 00:50:45,590
我们来看
Well, but let's see.

646
00:50:45,590 --> 00:50:54,190
接着写，(apply ，eval这部分在环境中寻找符号'+
That is apply, the object which is a result of that and plus.

647
00:50:54,190 --> 00:51:01,780
所以我们从e2开始找，它不在这里，也不在e1，哦，它是一个基本操作符
So here we are in e2, plus is not here, it's not here, oh, yes, but's here as some primitive operator.

648
00:51:01,780 --> 00:51:04,745
用于做加法
So it's the primitive operator for addition.

649
00:51:08,490 --> 00:51:14,370
把它应用于x y在e2中解析到的结果
Apply that to the result of evaluating x and y in e2.

650
00:51:14,370 --> 00:51:18,340
我们知道x是3 y是4
But we can see that x is three and y is four.

651
00:51:18,340 --> 00:51:23,936
所以这里写'(3 4)
So that's a three and four, here.

652
00:51:23,936 --> 00:51:26,280
然后就神奇的得到结果7
And that magically produces for me a seven.

653
00:51:30,520 --> 00:51:40,470
我把这个例子具体的演示一遍是想让你们清楚的看到，求值过程中实际传递的是什么，每一部分的职能又是什么
I wanted to go through this so you would see, essentially, one important ingredient, which is what's being passed around, and who owns what, and what his job is.

654
00:51:40,470 --> 00:51:41,700
所以这里是一些什么呢？
So what do we have here?

655
00:51:41,700 --> 00:51:46,520
一个eval，一个apply，两个主角
We have eval, and we have apply, the two main players.

656
00:51:49,370 --> 00:51:52,320
在它们之间是一个大循环
And there is a big loop the goes around like this.

657
00:51:52,320 --> 00:52:06,270
eval将过程与参数传递予apply
Which is eval produces a procedure and arguments for apply.

658
00:52:06,270 --> 00:52:09,710
也有些事情eval可以自己做
Now some things eval could do by itself.

659
00:52:09,710 --> 00:52:10,860
一些内部的事情吧
Those are little self things here.

660
00:52:10,860 --> 00:52:12,700
没多大意思
They're not interesting.

661
00:52:12,700 --> 00:52:16,240
eval也逐个解析每个形参
Also eval evaluates all of the arguments, one after another.

662
00:52:16,240 --> 00:52:17,650
也没什么意思
That's not very interesting.

663
00:52:17,650 --> 00:52:22,300
apply实际执行一些过程比如+
Apply can apply some procedures like plus, not very interesting.

664
00:52:22,300 --> 00:52:32,880
然而如果不是基本过程不能直接执行，它就再度将表达式与环境传递予eval
However, if apply can't apply a procedure like plus, it produces an expression and environment for eval.

665
00:52:35,470 --> 00:52:43,740
参数和过程记录了计算的状态和环境下的表达式
The procedural arguments wrap up essentially the state of a computation and, certainly, the expression of environment.

666
00:52:43,740 --> 00:52:48,820
我们接下来并不是对全局状态一下得出结果，因为它并不知道全局状态是什么
And so what we're actually going to do next is not the complete state, because it doesn't say who wants the answers.

667
00:52:51,280 --> 00:52:58,970
我们要做的只是得到环境和表达式或者过程与参数，一直不断的反复循环
But what we're going to do-- it's always got something like an expression of environment or procedure and arguments as the main loop that we're going around.

668
00:52:58,970 --> 00:53:12,280
这里也有一些副循环比如eval中的evlist、evcond和apply中的apply
There are minor little sub loops like eval through EVLIST, or eval through evcond, or apply through a primitive apply.

669
00:53:16,140 --> 00:53:18,500
但是它们并不是最主要的
But they're not the essential things.

670
00:53:18,500 --> 00:53:21,860
这整个就是我想让你们看到的
So that's what I wanted you to see.

671
00:53:21,860 --> 00:53:23,110
有什么问题吗？
Are there any questions?

672
00:53:25,930 --> 00:53:28,690
你说
Yes.

673
00:53:28,690 --> 00:53:37,070
我不明白为什么x是3而不是4
AUDIENCE: I'm trying to understand how x got down to three instead of four.

674
00:53:37,070 --> 00:53:41,310
在那个部分 教授：这里
At the early part of the-- PROFESSOR: Here.

675
00:53:41,310 --> 00:53:43,310
x为什么是3？
You want to know how x got down to three?

676
00:53:43,310 --> 00:53:51,040
x是外层过程的参数，y是内层过程的参数
AUDIENCE: Because x is the outer procedure, and x and y are the inner procedure.

677
00:53:51,040 --> 00:53:52,570
哦，明白了
PROFESSOR: Fine.

678
00:53:52,570 --> 00:53:55,280
变换的过程中我已经非常注意了
Well, I was very careful and mechanical.

679
00:53:55,280 --> 00:54:00,610
现在我把这个示例的过程按照美观的排版方式给你再写一遍
First of all, I should write those procedures again for you, pretty printed.

680
00:54:00,610 --> 00:54:03,830
这样做的原因是因为你可以读错了这个程序
First order of business, because you're probably not reading them well.

681
00:54:03,830 --> 00:54:26,140
所以我本着美观打印的原则把这个例子再写一遍
So I have here that procedure of-- was it x over there-- which is-- value of that procedure of y, which adds x to y, lambda, lambda, applied that to three, takes the result of that, and applied that to four.

682
00:54:26,140 --> 00:54:28,810
这个和刚才写的那个是一样的
Is that not what I wrote?

683
00:54:28,810 --> 00:54:40,735
然后你会发现最外层是一个过程调用 -- 我换根白粉笔 -- 这一部分是一个过程调用
Now, you should immediately see that here is an application-- let me get a white piece of chalk-- here is an application, a combination.

684
00:54:44,300 --> 00:54:51,040
这一部分是操作符，下面的3是操作数
That combination has this as the operator and this as the operand.

685
00:54:51,040 --> 00:54:54,900
所以x应该是3
The three is going in for the x here.

686
00:54:54,900 --> 00:55:01,530
这个过程执行后的结果是一个参数为y的过程，再应用于4
The result of this is a procedure of one argument y, which gets applied to four.

687
00:55:01,530 --> 00:55:04,190
所以你可能刚刚看错了
So you just weren't reading the expression right.

688
00:55:04,190 --> 00:55:13,340
刚才你所指的那里，过程对象和x
The way you see that over here is that here I have the actual procedure object, x.

689
00:55:13,340 --> 00:55:18,980
这个过程应用于下面的列表 '(3)
It's getting applied to three, the list containing three.

690
00:55:18,980 --> 00:55:24,080
应用后得到的结果再应用于'(4)
What I'm left over with is something which gets applied to four.

691
00:55:24,080 --> 00:55:25,330
还有疑问吗？
Are there any other questions?

692
00:55:28,600 --> 00:55:30,900
那就休息一下吧
Time for our next small break then.

693
00:55:30,900 --> 00:55:33,735
嗯
Thank you.

694
00:55:33,735 --> 00:56:08,410
[MUSIC PLAYING]
[MUSIC PLAYING]

695
00:56:08,410 --> 00:56:17,960
现在大家可能开始嘀咕了，GJS说了这么多没用的有什么意义？
Let's see, at this point, you should be getting the feeling, what's this nonsense this Sussman character is feeding me?

696
00:56:20,740 --> 00:56:24,800
很多话没多大意义，而且还不好理解
There's an awful lot of strange nonsense here.

697
00:56:24,800 --> 00:56:30,892
毕竟他还是给我详细解释了Lisp，并且还在黑板上写了程序
After all, he purported to explain to me Lisp, and he wrote me a Lisp program on the blackboard.

698
00:56:30,892 --> 00:56:38,370
这个程序是用Lisp所写的Lisp的解释器，但是要运行它你必须得先有一个Lisp解释器啊
The Lisp program was intended to be interpreted for Lisp, but you need a Lisp interpreter in order to understand that program.

699
00:56:38,370 --> 00:56:44,150
理解了这个程序就算是完全了解Lisp了吗？
How could that program have told me anything there is to be known about Lisp?

700
00:56:44,150 --> 00:56:45,795
这不是很空洞吗？
How is that not completely vacuous?

701
00:56:48,490 --> 00:56:50,990
而且非常诡异
It's a very strange thing.

702
00:56:50,990 --> 00:56:52,430
它是不是还隐藏了什么？
Does it tell me anything at all?

703
00:56:56,070 --> 00:57:03,105
我们想想看，这整件事是否很像幻灯片上这幅埃舍尔所画的手
Well, you see, the whole thing is sort of like these Escher's hands that we see on this slide.

704
00:57:06,180 --> 00:57:17,110
eval和apply彼此画出彼此，组成了整个程序，它完全是自己画出了自己
Yes, eval and apply each sort of draw each other and construct the real thing, which can sit out and draw itself.

705
00:57:17,110 --> 00:57:20,550
埃舍尔聪明绝顶，他看透了其中的玄机不过却没有为其命名
Escher was a very brilliant man, he just didn't know the names of these spirits.

706
00:57:23,910 --> 00:57:36,090
我现在要做的就是，使你们相信，这一切都是有意义的，顺便地提到，我们甚至连定义都不需要
Well, I'm going to do now, is I'm going to try to convince you that both this mean something, and, as a aside, I'm going to show you why you don't need definitions.

707
00:57:36,090 --> 00:57:44,890
这可能有点打破常规了，我们要做实际计算却不需要定义，这有点违反数学直觉
Just turns out that that sort of falls out, why definitions are not essential in a mathematical sense for doing all the things we need to do for computing.

708
00:57:49,070 --> 00:57:50,690
我们来实际的看一下
Well, let's see here.

709
00:57:50,690 --> 00:57:54,870
考虑下面的这一小段程序，它有什么作用？
Consider the following small program, what does it mean?

710
00:57:54,870 --> 00:57:57,035
一个计算指数的程序
This is a program for computing exponentials.

711
00:58:07,270 --> 00:58:22,070
(define expt (lambda (x n) (cond ((= n 0) 1)
The exponential of x to the nth power is if--  and is zero, then the result is one.

712
00:58:22,070 --> 00:58:33,930
(else (* x (expt x (- n 1))))
Otherwise, I want the product of x and the result of exponentiating x to the n minus one power.

713
00:58:42,858 --> 00:58:46,630
应该没错
I think I got it right.

714
00:58:46,630 --> 00:58:49,470
一个递归定义
Now this is a recursive definition.

715
00:58:49,470 --> 00:58:56,410
用expt自身来定义expt
It's a definition of the exponentiation procedure in terms of itself.

716
00:58:56,410 --> 00:59:05,650
之前提到过，你的高中几何老师教这里的时候一定费了不少功夫
And, as it has been mentioned before, your high school geometry teacher probably gave you a hard time about things like that.

717
00:59:05,650 --> 00:59:07,910
这样定义合理吗？
Was that justified?

718
00:59:07,910 --> 00:59:13,430
为什么这种自己定义自己的无赖方式会说得过去呢？
Why does this self referential definition make any sense?

719
00:59:13,430 --> 00:59:17,600
首先我要说的是，高中老师教的那一套确实说不过去
Well, first of all, I'm going to convince you that your high school geometry teacher was I telling you nonsense.

720
00:59:20,370 --> 00:59:24,490
比如来看几组方程
Consider the following set of definitions here.

721
00:59:24,490 --> 00:59:33,070
x + y = 3    x - y = 1
x plus y equals three, and x minus y equal one.

722
00:59:33,070 --> 00:59:37,490
看，这个用y来告诉你x是什么，下面这个用x来告诉你y是什么
Well, gee, this tells you x in terms of y, and this one tells you y in terms of x, presumably.

723
00:59:40,150 --> 00:59:42,950
碰巧这组方程有唯一的解
And yet this happens to have a unique solution in x and y.

724
00:59:55,910 --> 01:00:06,600
然而，如果我写 2x + 2y = 6
However, I could also write two x plus two y is six.

725
01:00:06,600 --> 01:00:09,610
上面这两个联立，就有无穷个解了
These two equations have an infinite number solutions.

726
01:00:15,730 --> 01:00:24,070
我再写 x - y = 2，下面的这两个联立完全没有解
And I could write you, for example, x minus y equal 2, and these two equations have no solutions.

727
01:00:29,820 --> 01:00:39,510
这里三组方程式，这组，这组和这组
Well, I have here three sets of simultaneous linear equations, this set, this set, and this set.

728
01:00:39,510 --> 01:00:42,900
它们的解的数目完全不同
But they have different numbers of solutions.

729
01:00:42,900 --> 01:00:45,760
解的数目通过方程的形式是看不出来的
The number of solutions is not in the form of the equations.

730
01:00:45,760 --> 01:00:48,350
三组方程看起来形式一样
They all three sets have the same form.

731
01:00:48,350 --> 01:00:50,205
判断解的数目需要具体的来看方程的内容
The number of solutions is in the content.

732
01:00:53,000 --> 01:00:59,660
我不能看一眼方程的外貌就判断出解的数目来，必须要仔细辨别方程的内容
I can't tell by looking at the form of a definition whether it makes sense, only by its detailed content.

733
01:00:59,660 --> 01:01:05,100
比如，这个线性方程，我们具体看方程的系数是什么？
What are the coefficients, for example, in the case of linear equations?

734
01:01:05,100 --> 01:01:16,030
所以我不能仅仅依照方程形式就来判断解是什么样子，就比如这个，你说，expt是这个递归方程的解
So I shouldn't expect to be able to tell looking at something like this, from some simple things like, oh yes, EXPT is the solution of this recursion equation.

735
01:01:16,030 --> 01:01:26,040
你还说，expt这个过程，你在这里调用，它就真的计算返回相应的指数
Expt is the procedure which if substituted in here, gives me EXPT back.

736
01:01:26,040 --> 01:01:37,200
我也不清楚，简单看看这个方程的形式，我也不知道expt是有一个解，无限个解还是根本没有解
I can't tell, looking at this form, whether or not there's a single, unique solution for EXPT, an infinite number of solutions, or no solutions.

737
01:01:37,200 --> 01:01:40,490
要做具体的判断必须明白 它是如何计算的 类似的具体的细节
It's got to be how it counts and things like that, the details.

738
01:01:40,490 --> 01:01:42,900
在编程中弄清楚可不像在线性代数中那么简单了
And it's harder in programming than linear algebra.

739
01:01:42,900 --> 01:01:45,210
在编程中定理并不多
There aren't too many theorems about it in programming.

740
01:01:48,450 --> 01:01:53,970
现在我先把这些个方程重写一遍
Well, I want to rewrite these equations a little bit, these over here.

741
01:01:53,970 --> 01:01:56,770
因为我们要讨论的是这种形式的方程
Because what we're investigating is equations like this.

742
01:01:56,770 --> 01:02:04,730
我只是想在这几个方程上做一些变换，以便于我们理解那边的方程
But I want to play a little with equations like this that we understand, just so we get some insight into this kind of question.

743
01:02:04,730 --> 01:02:19,380
我们把中间这个方程组重写为 x = 3 - y   y = x - 1
We could rewrite our equations here, say these two, the ones that are interesting, as x equals three minus y, and y equals x minus one.

744
01:02:22,010 --> 01:02:24,050
这种变换叫什么来着？
What do we call this transformation?

745
01:02:24,050 --> 01:02:26,095
一个线性变换，记为t
This is a linear transformation, t.

746
01:02:29,430 --> 01:02:37,370
所以这组方程也可以写作 <x y> = T<x y>
Then what we're getting here is an equation x y equals t of x y.

747
01:02:42,990 --> 01:02:44,560
我在找什么？
What am I looking for?

748
01:02:44,560 --> 01:02:47,040
我在找T的不动点
I'm looking for a fixed point of t.

749
01:02:47,040 --> 01:02:59,350
不动点也就是方程的解
The solution is a fixed point of t.

750
01:03:01,910 --> 01:03:10,880
所以我们已知的求不动点的方法也可以用在这里
So the methods we should have for looking for solutions to equations, if I can do it by fixed points, might be applicable.

751
01:03:10,880 --> 01:03:22,410
假如我有一个根据不动点来求得方程不动点的方法 -- 可能不管用 -- 可能也适用于这种情况的方程
If I have a means of finding a solution to an equations by fixed points-- just, might not work-- but it might be applicable to investigating solutions of equations like this.

752
01:03:27,240 --> 01:03:30,260
我们来把这个想像为方程，感受一下
But what I want you to feel is that this is an equation.

753
01:03:30,260 --> 01:03:45,010
这个表达式，其中有一些名字，上面对应着值的约束，不仅仅只用机械的代换来看它
It's an expression with several instances of various names which puts a constraint on the name, saying what that name could have as its value, rather than some sort of mechanical process of substitution right now.

754
01:03:47,740 --> 01:03:51,220
这个方程就是我要求解的方程
This is an equation which I'm going to try to solve.

755
01:03:51,220 --> 01:03:53,960
我们来试试看
Well, let's play around and solve it.

756
01:03:53,960 --> 01:04:00,320
首先，类比T的形式我先写一个函数
First of all, I want to write down the function which corresponds to t.

757
01:04:00,320 --> 01:04:06,960
这个函数的不动点就是我们想要的答案
First I want to write down the function which corresponds to t whose fixed point is the answer to this question.

758
01:04:11,950 --> 01:04:14,240
来看这个过程  F
Well, let's consider the following procedure f.

759
01:04:16,870 --> 01:04:19,340
用F来计算函数
I claim it computes that function.

760
01:04:19,340 --> 01:04:33,430
F有一个参数g，g是一个过程，有两个参数x和n
f is that procedure of one argument g, which is that procedure of two arguments x and n.

761
01:04:33,430 --> 01:05:00,690
g的过程体是 (cond ((= n 0) 1) (else (* x (g (x (- n 1))))))
Which have the property that if n is zero, then the result is one, otherwise, the result is the product of x and g, applied to x, and minus n1.

762
01:05:03,370 --> 01:05:30,930
f是一个过程，如果这个方程有解，如果我有一个计算指数的过程，我用f来调用这个过程，结果也应该是一个计算指数的过程
g, times, else, COND, lambda, lambda--  Here f is a procedure, which if I had a solution to that equation, if I had a good exponentiation procedure, and I applied f to that procedure, then the result would be a good exponentiation procedure.

763
01:05:37,460 --> 01:05:39,420
它是怎么做的呢？
Because, what does it do?

764
01:05:39,420 --> 01:05:54,670
假设g是一个指数计算过程，代入这里，生成一个有两个参数x和n的过程，其中如果n=0，结果就是1，这一点符合指数的定义
Well, all it is is exposing g were a good exponentiation procedure, well then this would produce, as its value, a procedure to arguments x and n, such that if n were 0, the result would be one, which is certainly true of exponentiation.

765
01:05:54,670 --> 01:06:03,470
否则，就返回指数过程g计算得到的x^n-1与x的乘积
Otherwise, it will be the result of multiplying x by the exponentiation procedure given to me with x and n minus one as arguments.

766
01:06:03,470 --> 01:06:14,620
如果对x^n-1的计算没有问题，那么返回的这个过程计算x^n也一定没有问题，这就是正确的指数计算过程
So if this computed the correct exponentiation for n minus one, then this would be the correct exponentiation for exponent n, so this would have been the right exponentiation procedure.

767
01:06:17,500 --> 01:06:32,320
所以，expt是F方程的不动点
So what I really want to say here is E-X-P-T is a fixed point of f.

768
01:06:37,550 --> 01:06:40,060
现在我们的问题在于，万一不止一个不动点
Now our problem is there might be more than one fixed point.

769
01:06:40,060 --> 01:06:43,270
万一根本没有不动点
There might be no fixed points.

770
01:06:43,270 --> 01:06:44,810
所以我们必须求出不动点
I have to go hunting for the fixed points.

771
01:06:48,290 --> 01:06:49,540
解出方程
Got to solve this equation.

772
01:06:52,160 --> 01:06:55,580
求不动点有很多种方式
Well there are various ways to hunt for fixed points.

773
01:06:55,580 --> 01:07:00,815
我们一开始的时候举过cos的例子
Of course, the one we played with at the beginning of this term worked for cosine.

774
01:07:06,080 --> 01:07:16,090
计算器调成弧度制，然后一直按cosine，最后数字会稳定在0.73 0.74左右
Go into radians mode on your calculator and push cosine, and just keep doing it, and you get to some number which is about 0.73 or 0.74.

775
01:07:16,090 --> 01:07:17,340
记不清是哪个了
I can't remember which.

776
01:07:22,900 --> 01:07:33,770
类似的，不断进行迭代，说不定就可以找出方程的不动点
By iterating a function, whose fixed point I'm searching for, it is sometimes the case that that function will converge in producing the fixed point.

777
01:07:33,770 --> 01:07:39,910
碰碰运气，来试试这种方法
I think we luck out in this case, so let's look for it.

778
01:07:39,910 --> 01:07:48,030
来看这张幻灯片
Let's look at this slide.

779
01:07:48,030 --> 01:07:51,390
这有一连串的过程
Consider the following sequence of procedures.

780
01:07:56,400 --> 01:08:02,940
e0什么也不做
e0 over here is the procedure which does nothing at all.

781
01:08:02,940 --> 01:08:07,780
如果将它应用于参数肯定会报错
It's the procedure which produces an error for any arguments you give it.

782
01:08:07,780 --> 01:08:09,030
没什么用
It's basically useless.

783
01:08:14,480 --> 01:08:20,080
然而，我可以应用F逐渐逼近
Well, however, I can make an approximation.

784
01:08:20,080 --> 01:08:26,990
e0应该是最差的近似了，因为它什么也做不了
Let's consider it the worst possible approximation to exponentiation, because it does nothing.

785
01:08:26,990 --> 01:08:37,380
假设我用调用过程F应用于e0
Well, supposing I substituted e0 for g by calling f, as you see over here on e0.

786
01:08:37,380 --> 01:08:40,729
e0代换了g，就在这里
So you see over here, have e0 there.

787
01:08:40,729 --> 01:08:43,859
我们来看看，e1是什么？
Then gee, what's e1?

788
01:08:43,859 --> 01:08:49,325
e1是一个可以计算x的0次方的过程，没什么问题
e1 is a procedure which exponentiate things to the 0th power, with no trouble.

789
01:08:49,325 --> 01:08:54,250
如果n=0值就是1，n!=0的话就会报错
It gets the right answer, anything to the zero is one, and it makes an error on anything else.

790
01:08:57,390 --> 01:09:07,310
如果我对e1再次调用F会发生什么？
Well, now what if I take e1 and I substitute if for g by calling f on e1?

791
01:09:10,500 --> 01:09:15,670
哦，还是得到了一个有两个参数的过程
Oh gosh, I have here a procedure of two arguments.

792
01:09:15,670 --> 01:09:24,200
记住，e1是F应用e0得到的近似，原本什么都做不了，现在可以计算0次方
Now remember e1 was appropriate for taking exponentiations of 0, for raising to the 0 exponent.

793
01:09:24,200 --> 01:09:29,520
来看e2，如果n=0，结果就是1，也是符合指数计算原则的
So here, is n is 0, the result is one, so this guy is good for that too.

794
01:09:29,520 --> 01:09:35,979
然而，这里的乘法使得原本只能计算0次方的过程现在可以计算1次方
However, I can use something for raising to the 0th power to multiply it by x to raise something to the first power.

795
01:09:35,979 --> 01:09:39,670
所以e2可以计算0和1次方
So e2 is good for both power 0 and one.

796
01:09:43,800 --> 01:09:47,899
e3的推导过程和e2是类似的
And e3 is constructed from e2 in the same way.

797
01:09:47,899 --> 01:09:55,120
即E3可以用来计算0、1、2次方
And e3, of course, by the same argument is good for powers 0, one, and two.

798
01:09:55,120 --> 01:10:02,520
因此我就不加证明的断言，不动点就是一个指数计算过程，这个证明十分的困难
And so I will assert for you, without proof, because the proof is horribly difficult.

799
01:10:02,520 --> 01:10:07,710
这也就是人们所谓的指称语义学家所做的事
And that's the sort of thing that people called denotational semanticists do.

800
01:10:07,710 --> 01:10:10,265
这个伟大的想法最先是从Scott和Strachey开始的
This great idea was invented by Scott and Strachey.

801
01:10:14,240 --> 01:10:24,240
他们是非常出色的数学家，也就是他们发明了那些程序的解释方式，就是我刚才讲的
They're very famous mathematician types who invented the interpretation for these programs that we have that I'm talking to you about right now.

802
01:10:24,240 --> 01:10:32,220
他们用拓扑学的知识证明了，刚才我们的那个例子是存在固定点的
And they proved, by topology that there is such a fixed point in the cases that we want.

803
01:10:32,220 --> 01:10:43,680
但是结论是，expt是 n趋于无穷时Em的极限值
But the assertion is E-X-P-T is limit as n goes to infinity of em.

804
01:10:43,680 --> 01:10:47,900
我们也可以这样写
and And that we've constructed this by the following way.

805
01:10:50,520 --> 01:11:01,120
expt = (f (f (f (f .... (f 丄)....)
--is Well, it's f of, f of, f of, f of, f of-- f applied to anything at all.

806
01:11:01,120 --> 01:11:05,320
不用管丄是什么，因为它总会生成一个错误
It didn't matter what that was, because, in fact, this always produces an error.

807
01:11:07,540 --> 01:11:16,380
无穷的调用F
Applied to this--  That's by infinite nesting of f's.

808
01:11:16,380 --> 01:11:19,760
现在我们的问题又变成了如何构造出无穷调用
So now my problem is to make some infinite things.

809
01:11:22,590 --> 01:11:24,920
我们需要这些
We need some infinite things.

810
01:11:24,920 --> 01:11:28,980
我怎么来无穷次的执行F呢？
How am I going to nest up an f an infinite number of times?

811
01:11:28,980 --> 01:11:32,380
我得把它构造出来
I'd better construct this.

812
01:11:32,380 --> 01:11:32,930
好吧我不知道
Well, I don't know.

813
01:11:32,930 --> 01:11:34,810
到底怎么样构建一个无穷循环呢？
How would I make an infinite loop at all?

814
01:11:34,810 --> 01:11:38,340
我们先来看一个非常简单的无穷循环，我能想到的最简单的
Let's take a very simple infinite loop, the simplest infinite loop imaginable.

815
01:11:43,550 --> 01:12:07,440
比如这样  ((lambda(x) (x x)) (lambda(x) (x x)))，这样就是一个无限的循环了
If I were to take that procedure of one argument x which applies x to x and apply that to the procedure of one argument x which applies x to x, then this is an infinite loop.

816
01:12:07,440 --> 01:12:09,980
现在来解释它是无限循环的原因
The reason why this is an infinite loop is as follows.

817
01:12:09,980 --> 01:12:18,850
只需要参数代换入过程体即可
The way I understand this is I substitute the argument for the formal parameter in the body.

818
01:12:18,850 --> 01:12:29,660
其中的每个x都要代换为(lambda(x) (x x))，这也就又回到了这个表达式上来，我们就从这里开始，一个最简单的循环
But if I do that, I take for each of these x's, I substitute one of these, making a copy of the original expression I just started with, the simplest infinite loop.

819
01:12:35,440 --> 01:12:43,090
我想要讲的是一个特别的操作符，只需对这个无穷循环做一点点小的改动
Now I want to tell you about a particular operator which is constructed by a perturbation from this infinite loop.

820
01:12:47,040 --> 01:12:48,290
我称其为Y
I'll call it y.

821
01:12:52,290 --> 01:13:04,480
这被称为Curry Y不动点组合子，是由20世纪30年代的逻辑学家Curry发明的
This is called Curry's Paradoxical Combinator of y after a fellow by the name of Curry, who was a logician of the 1930s also.

822
01:13:04,480 --> 01:13:09,330
Y是一个接受一个参数的过程，具体怎么写呢？
And if I have a procedure of one argument f, what's it going to have in it?

823
01:13:09,330 --> 01:13:27,899
内部需要构建出无限循环，((lambda(x) (f (x x))) (lambda(x) (f (x x))))
It's going to have a kind of infinite loop in it, which is that procedure of one argument x which applies f to x of x, applied to that procedure of one argument x, which applies f to f of x.

824
01:13:32,300 --> 01:13:34,590
这个是怎么运作的？
Now what's this do?

825
01:13:34,590 --> 01:13:42,950
假设执行(Y F)
Suppose we apply y to F. Well, that's easy enough.

826
01:13:42,950 --> 01:13:46,910
就是那边那个大写的F
That's this capital F over here.

827
01:13:46,910 --> 01:13:49,920
很简单，把F代换进来
Well, the easiest thing to say there is, I substitute F for here.

828
01:13:55,320 --> 01:14:02,800
里面的lambda代换进去
So that's going to give me, basically-- because then I'm going to substitute this for x in here.

829
01:14:08,970 --> 01:14:11,730
我逐步的代换一次，你就可以明白是怎么回事了
Let me actually do it in steps, so you can see it completely.

830
01:14:11,730 --> 01:14:15,020
我会非常谨慎
I'm going to be very careful.

831
01:14:15,020 --> 01:14:37,910
也就是 ((lambda(x) (F (x x))) (lambda(x) (F (x x))))
This is open, open, lambda of x , capital F, x, x, applied to itself, F of x of x.

832
01:14:37,910 --> 01:15:11,510
lambda代换进来，也就是 (F (lambda(x) (F (x x))) (lambda(x) (F (x x))))
Substituting this for this in here, this is F applied to-- what is it-- substituting this in here, open, open, lambda of x, F, of x and x, applied to lambda of x, F of x of x, F, lambda, pair, F.

833
01:15:11,510 --> 01:15:13,420
哇，这一部分是什么？
Oh, but what is this?

834
01:15:13,420 --> 01:15:20,030
也就是我们上面要计算的这部分
This thing over here that I just computed, is this thing over here.

835
01:15:20,030 --> 01:15:23,370
不同的是在外层应用了过程F
But I just wrapped another F around it.

836
01:15:23,370 --> 01:15:27,850
以此类推，就构造出了无穷个F迭代应用的过程
So by applying y to F, I make an infinite series of F's.

837
01:15:27,850 --> 01:15:33,170
我们一直这样代换下去，就会在外层得到越来越多的F
If I just let this run forever, I'll just keep making more and more F's outside.

838
01:15:33,170 --> 01:15:36,855
运行一个无穷循环看似无用，但是我们还要注意到循环过程中内部的变化
I ran an infinite loop which is useless, but it doesn't matter that the inside is useless.

839
01:15:40,220 --> 01:16:04,450
(Y F) => (F (Y F))，Y这个过程很神奇，应用于一个过程，就可以求出这个过程的不动点，当然是在不动点存在的前提下
So y of F is F applied to y of F. So y is a magical thing which, when applied to some function, produces the object which is the fixed point of that function, if it exists, and if this all works.

840
01:16:07,910 --> 01:16:11,630
因为，这里把(Y F)作为一个整体，F应用于(Y F)结果还是(Y F)
Because, indeed, if I take y of F and put it into F, I get y of F out.

841
01:16:16,240 --> 01:16:23,860
我们用这种方式来理解我们的eval-apply解释器
Now I want you to think this in terms of the eval-apply interpreter for a bit.

842
01:16:23,860 --> 01:16:28,540
这里我已经写了一整串的递归方程
I wrote down a whole bunch of recursion equations out there.

843
01:16:28,540 --> 01:16:31,470
它们都是联立方程
They're simultaneous in the same way these are simultaneous equations.

844
01:16:31,470 --> 01:16:33,310
expt不是联立方程
Exponentiation was not a simultaneous equation.

845
01:16:33,310 --> 01:16:38,150
我们只用关心一个变量的解
It was only one variable I was looking for a meaning for.

846
01:16:38,150 --> 01:16:58,220
我们这样来理解，Lisp是一个过程的不动点，在这个过程里，假定我们知道Lisp是什么，就像刚才的递归方程一样，对它反复应用eval apply，如果这真是Lisp，变换一次依然应该是Lisp
But what Lisp is is the fixed point of the process which says, if I knew what Lisp was and substituted it in for eval, and apply, and so on, on the right hand sides of all those recursion equations, then if it was a real good Lisp, is a real one, then the left hand side would also be Lisp.

847
01:16:58,220 --> 01:16:59,565
这样，我们之前所讲的就说的通了
So I made sense of that definition.

848
01:17:02,420 --> 01:17:05,410
不过是否有解却不太明显
Now whether or not there's an answer isn't so obvious.

849
01:17:05,410 --> 01:17:07,740
我也说不清
I can't attack that.

850
01:17:07,740 --> 01:17:10,660
现在我们来看点别的例子，这里我给出的论据有点陷阱
Now these arguments that I'm giving you now are quite dangerous.

851
01:17:10,660 --> 01:17:13,570
具体看这里
Let's look over here.

852
01:17:13,570 --> 01:17:14,610
这些都是关于极限的论据
These are limit arguments.

853
01:17:14,610 --> 01:17:21,255
我们要讨论极限，就需要一些微积分或者拓扑学那之类的一些知识来分析
We're talking about limits, and it's really calculus, or topology, or something like that, a kind of analysis.

854
01:17:21,255 --> 01:17:23,380
这里摆着的论据相信大家都会认同
Now here's an argument that you all believe.

855
01:17:23,380 --> 01:17:29,660
我只是确认一下你们是否会意识到我蒙骗到了你们
And I want to make sure you realize that I could be bullshitting you.

856
01:17:29,660 --> 01:17:30,910
这个是？
What is this?

857
01:17:34,250 --> 01:17:42,820
u = 1 + 1/2 + 1/4 + .......
u is the sum of 1/2, 1/4, and 1/8, and so on, the sum of a geometric series.

858
01:17:42,820 --> 01:17:44,820
下面，做一点变换
And, of course, I could play a game here.

859
01:17:44,820 --> 01:17:47,570
u - 1 = 1/2 + 1/4 + ......
u minus one is 1/2, plus 1/4, plus 1/8, and so on.

860
01:17:53,590 --> 01:17:56,680
然后继续
What I could do here-- oops.

861
01:17:56,680 --> 01:17:58,920
哦，这里少写了括号
There is a parentheses error here.

862
01:17:58,920 --> 01:18:03,990
2(u - 1) = 1 + 1/2 + 1/4 + ........
But I can put here two times u minus one is one plus 1/2, plus 1/4, plus 1/8.

863
01:18:07,570 --> 01:18:08,820
这里能修改一下吗？
Can I fix that?

864
01:18:14,010 --> 01:18:16,125
哦，可以
Yes, well.

865
01:18:19,520 --> 01:18:30,300
这样，2(u - 1) = u，结果得出u = 2
But that gives me back two times u minus one is u, therefore, we conclude that u is two.

866
01:18:30,300 --> 01:18:31,830
有理有据
And this actually is true.

867
01:18:31,830 --> 01:18:33,910
没有任何问题
There's no problem like that.

868
01:18:33,910 --> 01:18:38,540
但是假设这样的情况
But supposing I did something different.

869
01:18:38,540 --> 01:18:41,470
假设我开始计算一些明显没有固定结果的求和
Supposing I start up with something which manifestly has no sum.

870
01:18:41,470 --> 01:18:47,390
v = 1 + 2 + 4 + ........
v is one, plus two, plus four, plus 8, plus dot, dot, dot.

871
01:18:47,390 --> 01:18:52,010
v - 1 = 2 + 4 + 8 + ......
Well, v minus one is surely two, plus four, plus eight, plus dot, dot, dot.

872
01:18:52,010 --> 01:18:57,410
(v - 1)/2 = v
v minus one over two, gee, that looks like v again.

873
01:18:57,410 --> 01:19:03,070
所以我就可以算出v是多少 -- 哦这里又写错了
From that I should be able to conclude that-- that's also wrong, apparently.

874
01:19:03,070 --> 01:19:04,510
v = -1
v equals minus one.

875
01:19:12,455 --> 01:19:15,280
这里应该是-1
That should be a minus one.

876
01:19:15,280 --> 01:19:16,735
结论明显是错误的
And that's certainly a false conclusion.

877
01:19:22,000 --> 01:19:30,750
当你计算极限的时候，这种方式可能是对的，但是应用于别的就不对了
So when you play with limits, arguments that may work in one case they may not work in some other case.

878
01:19:30,750 --> 01:19:32,240
要多加注意
You have to be very careful.

879
01:19:32,240 --> 01:19:35,752
论据必须符合一定的形式
The arguments have to be well formed.

880
01:19:35,752 --> 01:19:43,270
关于刚才那个我也很难用理论说明到底是为什么
And I don't know, in general, what the story is about arguments like this.

881
01:19:43,270 --> 01:19:46,060
你可以了解一些拓扑学找到答案
We can read a pile of topology and find out.

882
01:19:46,060 --> 01:19:53,260
但是至少你现在理解了，这个例子对于黑板上我们写的这些有很大意义
But, surely, at least you understand now, why it might be some meaning to the things we've been writing on the blackboard.

883
01:19:53,260 --> 01:19:56,480
并且你也理解了(Y F) = (F (Y F))
And you understand what that might mean.

884
01:19:56,480 --> 01:20:09,320
我想，应该庆祝你们，成为递归lambda演算黑客的一员
So, I suppose, it's almost about time for you to merit being made a member of the grand recursive order of lambda calculus hackers.

885
01:20:09,320 --> 01:20:10,820
这是我们的徽章
This is the badge.

886
01:20:10,820 --> 01:20:21,890
因为你已经理解了 (Y F) = (F (Y F))
Because you now understand, for example, what it says at the very top, y F equals F y F. Thank you.

887
01:20:21,890 --> 01:20:24,710
有什么问题吗？
Are there any questions?

888
01:20:24,710 --> 01:20:25,150
你说
Yes, Lev.

889
01:20:25,150 --> 01:20:34,090
目前的状况来看，正如你之前提到过的，我们已经不需要define去预先定义一个过程之后再应用它
AUDIENCE: With this, it seems that then there's no need to define, as you imply, to just remember a value, to apply it later.

890
01:20:34,090 --> 01:20:36,490
define在语言中好像有一些副作用
Defines were kind of a side-effect it seemed in the language.

891
01:20:36,490 --> 01:20:39,300
就会存在秩序依赖[猜的，不确定]
[INTERPOSING] are order dependent.

892
01:20:39,300 --> 01:20:43,150
我们现在是否已经排除了副作用  教授：是这样
Does this eliminate the side-effect from the. Well

893
01:20:43,150 --> 01:20:49,180
答案在于，define并不是按你所提的那样运行的
PROFESSOR: The answer is, this is not the way these things were implemented.

894
01:20:49,180 --> 01:21:03,690
define这个操作，确实修改了环境，修改了当前环境的frame
Define, indeed is implemented as an operation that actually modifies an environment structure, changes the frame that the define is executed in.

895
01:21:03,690 --> 01:21:11,340
这样是出于很多目的，其中之一就是方便交互式系统
And there are many reasons for that, but a lot of this has to do with making an interactive system.

896
01:21:11,340 --> 01:21:24,090
就是说，如果你造了一个系统，你不打算调试而且你也知道所要计算的全部内容，你就可以直接要求系统来求解
What this is saying is that if you've made a system, and you know you're not going to do any debugging or anything like that, and you know everything there is all at once, and you want to say, what is the meaning of a final set of equations?

897
01:21:24,090 --> 01:21:25,790
然后系统返回你相应的值
This gives you a meaning for it.

898
01:21:25,790 --> 01:21:35,000
但是为了构建一个交互式的系统，你就得做到改变一个东西的含义但是又不改变剩下的其它部分，增量的变化，没有define就不易做到了
But in order to make an interactive system, where you can change the meaning of one thing without changing everything else, incrementally, you can't do that by implementing it this way.

899
01:21:40,990 --> 01:21:41,860
你说
Yes.

900
01:21:41,860 --> 01:21:44,650
关于刚才你那个“有陷阱”的幻灯片有点疑问
AUDIENCE: Another question on your danger slide.

901
01:21:44,650 --> 01:21:50,300
好像你举的两个例子和收敛与不收敛有点关系？
It seemed that the two examples that you gave had to do with convergence and non-convergence?

902
01:21:50,300 --> 01:22:05,430
可能这个函数理论也会让你想到线性系统非线性系统的一些东西，所以收敛性和变换F所必须的一些性质之间到底有什么关系呢？
And that may or may not have something to do with function theory in a way which would lead you to think of it in terms of linear systems, or non-linear systems. How does this convergence relate to being able to see a priori what properties of that might be violated?

903
01:22:05,430 --> 01:22:07,680
我不知道
PROFESSOR: I don't know.

904
01:22:07,680 --> 01:22:10,610
问题在于我不知道在什么样的环境下
The answer is, I don't know under what circumstances.

905
01:22:10,610 --> 01:22:16,910
不下一个小时肯定是说不完的
I don't know how to translate that into less than an hour of talk more.

906
01:22:16,910 --> 01:22:22,720
我们判断收敛的条件是什么？
What are the conditions under which, for which we know that these things converge?

907
01:22:22,720 --> 01:22:32,810
就v来看，如果你不了解收敛性，我告诉你说根据收敛性这个没有解，你肯定也是云里雾里的
And v, all that was telling you that arguments that are based on convergence are flaky if you don't know the convergence beforehand.

908
01:22:32,810 --> 01:22:34,440
你能构造错误的论据
You can make wrong arguments.

909
01:22:34,440 --> 01:22:40,690
你也可以演绎，就像是你知道答案，并且没有被什么明显的矛盾所阻碍
You can make deductions, as if you know the answer, and not be stopped somewhere by some obvious contradiction.

910
01:22:40,690 --> 01:23:03,020
我们可以说 如果F是一个收敛的数学变换，然后递归的性质就 教授：我想是有这样的一种F，针对F有具体的技术性的描述，如果F具有某些性质，你迭代的时候就会收敛
AUDIENCE: So can we say then that if F is a convergent mathematical expression, then the recursion property can be-- PROFESSOR: Well, I think there's a technical kind of F, there is a technical description of those F's that have the property that when you iteratively apply them like this, you converge.

911
01:23:03,020 --> 01:23:09,370
比如单调的，连续的，我忘了还有些什么
Things that are monotonic, and continuous, and I forgot what else.

912
01:23:09,370 --> 01:23:13,430
有很多这样的条件可以作为性质
There is a whole bunch of little conditions like that which have this property.

913
01:23:13,430 --> 01:23:22,010
困难的地方在于，对于一个F，我来判断它是否有我们所提到的这些性质，这有点难
Now the real problem is deducing from looking at the F, its definition here, whether not it has those properties, and that's very hard.

914
01:23:22,010 --> 01:23:23,280
提到那些性质当然简单
The properties are easy.

915
01:23:23,280 --> 01:23:24,580
你都可以把它们写下来
You can write them down.

916
01:23:24,580 --> 01:23:26,930
你可以看一本Joe Stoy写的书
You can look in a book by Joe Stoy.

917
01:23:26,930 --> 01:23:29,910
非常不错
It's a great book-- Stoy.

918
01:23:31,780 --> 01:23:41,800
叫做The Scott-Strachey Method of Denotational Semantics，作者Joe Stoy，MIT出版
It's called, The Scott-Strachey Method of Denotational Semantics, and it's by Joe Stoy, MIT Press.

919
01:23:47,960 --> 01:23:51,880
他对这一方面研究的非常透彻
And he works out all this in great detail, enough to horrify you.

920
01:23:55,080 --> 01:23:56,330
而且还很有可读性
But it really is readable.

921
01:24:09,150 --> 01:24:11,490
好的，没问题了
OK, well, thank you.

922
01:24:11,490 --> 01:24:13,780
这节课到此为止
Time for the bigger break, I suppose.

