1
00:00:16,300 --> 00:00:18,080
教授：我想大家已经意识到
PROFESSOR: Well, I hope you appreciate that we have

2
00:00:20,010 --> 00:00:22,730
我们介绍了一些真正的魔法
we have inducted you into some real magic,

3
00:00:24,200 --> 00:00:27,240
创造新语言的魔法
the magic of building languages

4
00:00:27,420 --> 00:00:28,720
用来创造全新的语言
really building new languages.

5
00:00:29,690 --> 00:00:30,400
我们学了些什么？
What have we looked at?

6
00:00:30,430 --> 00:00:32,780
我们学习了一门用来操作图片的Escher的语言
We've looked at an Escher picture language.

7
00:00:38,920 --> 00:00:41,150
这门语言由Peter Henderson发明
OK? this language invented by Peter Henderson.

8
00:00:42,010 --> 00:00:46,490
我们还学习了数字逻辑语言
We looked at digital logic language.

9
00:00:53,160 --> 00:00:55,550
以及 我们还学习了查询语言
Let's see.We've looked at the query language.

10
00:00:59,700 --> 00:01:00,780
然而你需要明白的是
And the thing you should realize is,

11
00:01:00,810 --> 00:01:03,100
尽管它们都是“玩具级”的语言
even though these were toy examples,

12
00:01:04,700 --> 00:01:07,610
它们也确实是实用工具的核心
they really are the kernels of really useful things.

13
00:01:08,250 --> 00:01:09,480
比如说
So, for instance,

14
00:01:10,120 --> 00:01:12,000
Escher图片语言
the Escher picture language was taken by

15
00:01:12,370 --> 00:01:14,410
就被MIT的学生Henry Wu拿去
Henry Wu, who's a student at MIT,

16
00:01:14,880 --> 00:01:19,450
开发成了一门实用的电路板布局语言
and developed into a real language for laying out PC boards,

17
00:01:20,350 --> 00:01:22,560
它就是在这些结构上扩展而来
based just on extending those structures.

18
00:01:23,240 --> 00:01:24,650
至于数字逻辑语言
And the digital logic language,

19
00:01:24,680 --> 00:01:26,080
Gerry教授在上课的时候也提到过
Gerry mentioned when he showed it to you,

20
00:01:26,430 --> 00:01:29,920
它被扩展为了一个仿真器的基础
was really extended to be used as the basis for a simulator

21
00:01:30,850 --> 00:01:32,960
用来设计真实的计算机
that was used to design a real computer.

22
00:01:33,460 --> 00:01:34,320
至于查询语言
And the query language,

23
00:01:34,350 --> 00:01:36,440
当然就是Prolog语言的一种核心
of course, is kind of the germ of prolog.

24
00:01:37,510 --> 00:01:39,070
我们构造的这些语言
So we built all of these languages,

25
00:01:39,550 --> 00:01:40,650
全都是用Lisp编写
they're all based on LISP.

26
00:01:43,630 --> 00:01:44,590
很多人问
A lot of people ask

27
00:01:45,270 --> 00:01:48,730
Lisp适合用来解决哪一类问题？
what particular problems is LISP good for solving for?

28
00:01:48,750 --> 00:01:49,930
答案就是
The answer is LISP is not...

29
00:01:50,330 --> 00:01:52,650
Lisp不适合解决任何一类问题
LISP is not good for solving any particular problems.

30
00:01:53,530 --> 00:01:54,600
Lisp擅长的是
What LISP is good for

31
00:01:54,730 --> 00:01:57,150
用它来构造一门合适的语言
is constructing within it the right language

32
00:01:57,180 --> 00:01:58,570
来解决你的问题
to solve the problems you want to solve,

33
00:01:59,170 --> 00:02:00,440
你应该像这样看待Lisp
and that's how you should think about it.

34
00:02:01,470 --> 00:02:03,390
那么既然这些语言都基于Lisp
So all of these languages were based on LISP.

35
00:02:04,570 --> 00:02:05,720
那Lisp又基于什么？
Now, what's LISP based on?

36
00:02:06,970 --> 00:02:07,880
它又从何而来？
Where's that come from?

37
00:02:07,900 --> 00:02:09,400
这个我们也学过
Well, we looked at that too.

38
00:02:09,580 --> 00:02:16,090
我们学过元循环求值器
We looked at the meta-circular evaluator

39
00:02:21,530 --> 00:02:23,400
学习了元循环求值器后 我们说
the meta-circular evaluator and sort of said

40
00:02:23,420 --> 00:02:25,760
Lisp就是基于Lisp的
well, LISP is based on LISP.

41
00:02:25,800 --> 00:02:27,480
而让我们研究它的时候
And when we start looking at that,

42
00:02:28,270 --> 00:02:29,950
我们必须得施展一些真正的魔法 对吧？
we've got to do some real magic, right?

43
00:02:29,950 --> 00:02:31,740
这又是什么意思呢？
So what does that mean, right?

44
00:02:31,740 --> 00:02:34,960
Y算子、不动点
Y operators, and fixed points,

45
00:02:35,760 --> 00:02:38,330
以及这样的一个观念--
and the idea that what this means is

46
00:02:38,360 --> 00:02:41,440
Lisp实际上是一个方程的不动点
that LISP is somehow the fixed-point equation for the

47
00:02:42,200 --> 00:02:45,420
一个通过自身来定义的有趣方程
for this funny set of things which are defined in terms of themselves.

48
00:02:47,400 --> 00:02:48,560
这确实是神奇的魔法
Now, it's real magic.

49
00:02:49,070 --> 00:02:52,350
那么今天 作为魔法的最后一步
Well, today, for a final piece of magic,

50
00:02:52,620 --> 00:02:54,030
我们要把它们通通消除掉
we're going to make all the magic go away.

51
00:03:06,800 --> 00:03:07,980
我们已经知道怎么做了
We already know how to do that.

52
00:03:09,770 --> 00:03:12,730
核心要思想是 将Lisp语言
The idea is, we're going to take the register machine architecture

53
00:03:13,360 --> 00:03:15,500
实现在使用寄存器架构的机器上
and show how to implement LISP on terms of that.

54
00:03:15,500 --> 00:03:20,080
回想一下 寄存器机器的关键之处在于
And, remember, the idea of the register machine is that

55
00:03:21,320 --> 00:03:24,680
机器的一部分是确定且有穷的
there's a fixed and finite part of the machine.

56
00:03:24,720 --> 00:03:26,120
它有一个有穷状态控制器
There's a finite-state controller,

57
00:03:26,120 --> 00:03:29,310
它用特定的硬件去做特定的事情
which dose particular thing with a particular amount of hardware.

58
00:03:30,510 --> 00:03:31,740
其中还有一些运算所需的
There are particular data paths,

59
00:03:31,760 --> 00:03:33,240
特殊数据通路
the operation the machine does

60
00:03:33,550 --> 00:03:35,290
然后 为了实现递归
And then, in order to implement recursion

61
00:03:35,530 --> 00:03:37,600
并且维持无穷的假象
and sustain the illusion of infinity,

62
00:03:37,820 --> 00:03:39,770
还使用了一种称作“栈”的大内存
there's some large amount of memory, which is the stack.

63
00:03:42,060 --> 00:03:45,500
所以如果我们要在寄存器机器上实现Lisp
So, if we implement LISP in terms of a register machine,

64
00:03:47,020 --> 00:03:48,350
那么这个时候
then everything ought to become,

65
00:03:48,400 --> 00:03:49,850
所有的东西都会完全具体化
at this point,completely concrete.

66
00:03:49,850 --> 00:03:51,230
所有的魔法都会消除
All the magic should go away.

67
00:03:51,650 --> 00:03:53,520
这堂课结束时
And, by the end of this talk,

68
00:03:53,530 --> 00:03:54,780
我想让你感觉到
I want you get the feeling

69
00:03:55,140 --> 00:03:59,050
相对于神秘的元循环求值器
that, as opposed to this very mysterious meta-circular evaluator

70
00:03:59,670 --> 00:04:02,600
Lisp求值器是非常具体的东西
that a LISP evaluator really is something that's concrete enough

71
00:04:02,850 --> 00:04:04,570
你甚至可以把它放在手心中
that you can hold in the palm of your hand.

72
00:04:04,760 --> 00:04:06,240
你可以想象一下
You should be able to imagine holding

73
00:04:06,570 --> 00:04:07,900
手里拿着一个Lisp解释器的情景
holding a LISP interpreter there.

74
00:04:09,630 --> 00:04:10,940
好 那我们怎么做呢？
All right, how are we going to do this?

75
00:04:10,950 --> 00:04:12,760
所有的原料都已经齐全
We already have all the ingredients.

76
00:04:13,960 --> 00:04:17,450
上节课Gerry教了你们
See, what you learned last time from Gerry

77
00:04:17,600 --> 00:04:21,470
对一个任意的Lisp过程
is how to take any particular couple of LISP procedures.

78
00:04:22,600 --> 00:04:24,280
如何手动地把它们
and hand-translate them

79
00:04:24,750 --> 00:04:26,670
翻译成在寄存器机器上运行的代码
into something that runs on a register machine.

80
00:04:28,200 --> 00:04:30,520
那么 要在寄存器机器上实现Lisp本身
So, to implement all of LISP on a register machine,

81
00:04:30,570 --> 00:04:31,440
我们只需要
all we have to do

82
00:04:31,690 --> 00:04:33,450
把最关键的过程
is take the particular procedures

83
00:04:33,680 --> 00:04:35,420
也就是元循环求值器
that are the meta-circular evaluator

84
00:04:36,170 --> 00:04:38,110
手工翻译成寄存器机器的代码
and hand-translate them for a register machine.

85
00:04:39,040 --> 00:04:40,250
这就实现了整个Lisp
And that does all of LISP

86
00:04:42,140 --> 00:04:44,430
因此 我们已经清楚了实现的原理
Right? So, in principle, we already know how to do this.

87
00:04:45,380 --> 00:04:48,800
而且实际上 这跟翻译
And, indeed, it's going to be no different, in kind,

88
00:04:50,000 --> 00:04:53,400
递归版的阶乘或递归版的斐波那契数列
from in say recursive factorial

89
00:04:53,420 --> 00:04:54,670
没什么区别
or recursive Fibonacci.

90
00:04:54,670 --> 00:04:56,000
只是它规模更大 代码更多
It's just bigger and there's more of it.

91
00:04:56,840 --> 00:04:58,030
只是包含了更多细节
So it'd just be more details,

92
00:04:58,040 --> 00:04:59,660
但是没有任何新的概念
but nothing really conceptually new.

93
00:05:01,480 --> 00:05:03,020
当我们完成这个以后
And also, when we've done that,

94
00:05:03,080 --> 00:05:04,760
所有的东西都变得明确了
and the thing is completely explicit,

95
00:05:04,870 --> 00:05:06,910
当我们看到如何用一系列的
and we see how to implement LISP

96
00:05:06,940 --> 00:05:10,080
寄存器操作来实现Lisp之后
in terms of the actual sequential register operations,

97
00:05:10,160 --> 00:05:11,630
它就成为了我们整个课程中
that's going to be our final

98
00:05:11,950 --> 00:05:14,160
最明确的Lisp模型
most explicit model of LISP in this course.

99
00:05:14,810 --> 00:05:16,950
回忆一下 这个过程贯穿了整个课程
And, remember, that's a progression through this course.

100
00:05:16,950 --> 00:05:18,250
我们先从代换模型开始
We started out with substitution,

101
00:05:18,280 --> 00:05:19,580
它和代数有点相似
which is sort of like algebra.

102
00:05:20,240 --> 00:05:21,870
然后学习了环境模型
And then we went to the environment model,

103
00:05:21,880 --> 00:05:24,000
它引入了“框架”的概念
which talked about the actual frames

104
00:05:24,030 --> 00:05:25,310
以及框架之间的关联
and how they got linked together.

105
00:05:26,320 --> 00:05:27,880
然后我们在元循环求值器中
And then we made that more concrete

106
00:05:27,900 --> 00:05:29,360
做了更具体的讨论
in the meta-circular evaluator.

107
00:05:31,050 --> 00:05:31,640
但是有的事情
There are things

108
00:05:31,870 --> 00:05:33,980
元循环求值器没有告诉我们
the meta-circular evaluator doesn't tell us.

109
00:05:34,360 --> 00:05:35,340
你应该认识到这点
You should realize that.

110
00:05:36,090 --> 00:05:38,640
比如说 我们还不知道
For instance, it left unanswered the question

111
00:05:38,730 --> 00:05:42,670
像这里的递归阶乘过程
of how a procedure, like recursive factorial here,

112
00:05:45,170 --> 00:05:47,130
为何不断地申请新的空间
somehow takes space that grows.

113
00:05:47,210 --> 00:05:47,980
另一方面
On the other hand,

114
00:05:48,160 --> 00:05:51,940
一个语法上看起来像是递归的过程
a procedure which also looks syntactically recursive,

115
00:05:52,110 --> 00:05:55,070
比如FACT-ITER 并不占用栈空间
called fact-iter, somehow doesn't take space.

116
00:05:55,100 --> 00:05:59,160
我们通过代换模型来证明
We justify that it doesn't need to take space

117
00:06:00,500 --> 00:06:01,960
它不占用空间
by showing the substitution model.

118
00:06:01,960 --> 00:06:02,940
但我们并没有说清楚
But we didn't really say

119
00:06:03,420 --> 00:06:06,760
机器是如何做到这一点的
how it happens that the machine manages to do that,

120
00:06:07,310 --> 00:06:08,910
这涉及到一些细节
that that has to do with the details

121
00:06:09,020 --> 00:06:11,120
比如参数是如何传递给过程的
of how arguments are passed to procedures

122
00:06:12,480 --> 00:06:13,690
这是我们在元循环求值器中
And that's the thing we didn't see

123
00:06:13,710 --> 00:06:15,340
没有看到的
in the meta-circular evaluator

124
00:06:15,360 --> 00:06:17,400
完全是因为在所实现的Lisp中
precisely because the way arguments

125
00:06:17,420 --> 00:06:19,200
把参数传递给过程的方式
got passed to procedures in this LISP

126
00:06:19,700 --> 00:06:20,590
取决于
depended on

127
00:06:21,020 --> 00:06:23,500
外部Lisp的传参方式
the way arguments got passed to procedures in this LISP.

128
00:06:25,870 --> 00:06:29,020
但现在 这一点将变得非常明确
But, now, that's going to become extremely explicit.

129
00:06:30,740 --> 00:06:31,120
好
OK.

130
00:06:31,230 --> 00:06:34,300
在开始研究求值器之前
Well, before going on to the evaluator,

131
00:06:34,360 --> 00:06:35,530
我先让你们感受一下
let me just give you a sense of

132
00:06:35,550 --> 00:06:37,000
一个完整Lisp系统是怎么样的
what a whole LISP system looks like

133
00:06:37,600 --> 00:06:39,360
这样你就可以知道 我们要讨论哪部分
so you can see the parts we're going to talk about

134
00:06:39,400 --> 00:06:40,810
不讨论哪些部分
and the parts we're not going to talk about.

135
00:06:43,180 --> 00:06:47,420
首先 这里有一个快乐的Lisp用户
Let's see, over here is a happy LISP user,

136
00:06:48,670 --> 00:06:52,650
他正在和一个叫做读取器的东西交流
and the LISP user is talking to something called the reader.

137
00:07:00,360 --> 00:07:01,530
读取器的工作是
The reader's job in life

138
00:07:01,950 --> 00:07:13,230
读取用户输入的字符串
is to take characters from the user

139
00:07:14,170 --> 00:07:16,620
把它们转化成一种称作
and turn them into data structures

140
00:07:17,200 --> 00:07:19,370
表结构内存的数据结构
in something called a list structure memory.

141
00:07:30,000 --> 00:07:31,720
读取器会读取--
All right, so the reader is going to take

142
00:07:32,650 --> 00:07:33,950
你敲出来的符号、括号
symbols, parentheses,

143
00:07:34,480 --> 00:07:37,120
A和B、1和3这些东西
and A's and B's, and 1s and 3s that you type in,

144
00:07:37,180 --> 00:07:39,040
并把它们变成表结构
and turn these into actual list structure:

145
00:07:39,150 --> 00:07:40,540
变成序对、指针等等
pairs, and pointers, and things.

146
00:07:42,350 --> 00:07:43,920
所以当求值器运行的时候
And so, by the time evaluator is going,

147
00:07:43,930 --> 00:07:45,100
环境里已经不存在原始字符了
there are no characters in the world.

148
00:07:45,850 --> 00:07:48,160
当然 在更现代的Lisp系统中
And, of course, in more modern Lisp systems, there's

149
00:07:49,000 --> 00:07:50,440
可能还有一大团东西
there's sort a big morass here

150
00:07:50,440 --> 00:07:52,170
存在于在读取器和用户之间
that might sit between the user and the reader:

151
00:07:52,410 --> 00:07:54,520
最顶层首先是视窗系统
you know, Windows systems, in top levels,

152
00:07:54,770 --> 00:07:56,030
以及鼠标之类的东西
and mice, and all kinds of things.

153
00:07:56,280 --> 00:07:58,200
但从概念上来说 都是在输入字符
But conceptually, characters are coming in.

154
00:07:59,930 --> 00:08:04,320
总之 读取器把它们都变成指针
All right, the reader transforms these into pointers

155
00:08:05,560 --> 00:08:07,280
指向内存中的对象
pointers to stuff in this memory,

156
00:08:08,270 --> 00:08:10,940
这是求值器的所能看到的东西
and that's what the evaluator sees

157
00:08:15,550 --> 00:08:16,040
明白吗？
OK?

158
00:08:17,020 --> 00:08:18,880
求值器有一些辅助函数
The evaluator has a bunch of helpers.

159
00:08:19,780 --> 00:08:23,160
包括你需要的所有基本运算
It has all possible primitive operators you might want.

160
00:08:23,160 --> 00:08:24,910
也就是说这里另有一盒子东西
So there's a completely separate box,

161
00:08:28,400 --> 00:08:30,250
像一个浮点单元
a floating point unit,

162
00:08:32,220 --> 00:08:34,400
或者其它类似的东西来执行这些运算
or all sorts of things, which do the primitive operators.

163
00:08:35,390 --> 00:08:37,680
如果你想要更多的基本操运算
there's and, if you want more special primitives,

164
00:08:37,710 --> 00:08:39,020
你就实现更多的运算符
you build more primitive operators,

165
00:08:39,050 --> 00:08:40,480
但它们和求值器都是分离的
but they're separate from the evaluator.

166
00:08:42,080 --> 00:08:43,770
求值器最终算出结果
The evaluator finally gets an answer

167
00:08:45,168 --> 00:08:46,768
并且把它们告诉打印程序
and communicates that to the printer.

168
00:08:50,624 --> 00:08:52,016
现在 打印程序的任务就是
And now, the printer's job in life

169
00:08:52,016 --> 00:08:54,544
从求值器取得这个表结构
is this list structure coming from the evaluator,

170
00:08:55,392 --> 00:08:56,992
再把它们变回字符
and turn it back into characters,

171
00:09:01,856 --> 00:09:04,070
然后通过某种界面
and communicate them to the user through

172
00:09:04,288 --> 00:09:05,664
展示给用户
whatever interface there is.

173
00:09:08,050 --> 00:09:11,232
那么 今天我们要讨论的是这个求值器
OK. Well, today, what we're going to talk about is this evaluator.

174
00:09:12,670 --> 00:09:15,200
基本运算和Lisp没有什么特别的关系
The primitive operators have nothing particular to do with LISP,

175
00:09:15,200 --> 00:09:18,144
它们只取决于你怎么实现基本运算
they're however you like to implement primitive operations.

176
00:09:19,360 --> 00:09:22,180
读取器和打印程序实际上很复杂
The reader and printer are actually complicated,

177
00:09:22,180 --> 00:09:23,552
但是我们不去讨论它们
but we're not going to talk about them.

178
00:09:24,688 --> 00:09:27,100
从字符构建列表的过程中
They sort of have to do with details of how you might build

179
00:09:27,100 --> 00:09:28,928
它们需要处理很多细节
build up list structure from characters.

180
00:09:29,900 --> 00:09:31,184
说来话长
So that is a long story,

181
00:09:31,184 --> 00:09:32,320
我们就不讨论它了
but we're not going to talk about it,

182
00:09:32,490 --> 00:09:33,696
关于表结构内存
the list structure memory,

183
00:09:34,368 --> 00:09:35,632
我们下次再来讨论
we'll talk about next time.

184
00:09:36,930 --> 00:09:39,728
那么去除了读取和打印的细节
So, pretty much, except for the details of reading and printing,

185
00:09:40,120 --> 00:09:41,712
关于这个求值器
the only mystery that's going to be left

186
00:09:41,728 --> 00:09:43,056
所剩下的唯一谜团
after you see the evaluator

187
00:09:43,250 --> 00:09:45,856
几乎就只有怎么在传统内存上构建表结构了
is how you build list structure on conventional memories.

188
00:09:46,656 --> 00:09:48,208
不过我们把那也放到下次来讨论
But we'll worry about that next time too.

189
00:09:50,580 --> 00:09:51,040
好
OK.

190
00:09:53,344 --> 00:09:56,110
那么 我们先来看看这个求值器
Well, let's start talking about the evaluator.

191
00:09:56,200 --> 00:09:58,320
我将要展示的这个求值器
The one that we're going to show you,

192
00:09:58,496 --> 00:10:01,120
我想 它并没有什么特别的
of course, is not, I think, nothing special about it.

193
00:10:01,152 --> 00:10:04,560
它只是一台专门运行Lisp的寄存器机器
It's just a particular register machine that runs LISP.

194
00:10:04,810 --> 00:10:06,096
它有七个寄存器
And it has seven registers,

195
00:10:07,888 --> 00:10:09,264
这是它的七个寄存器
and here are the seven registers.

196
00:10:09,890 --> 00:10:12,384
这个寄存器叫EXP
There's a register, called EXP

197
00:10:14,120 --> 00:10:15,536
它的任务是存放
and its job is to hold

198
00:10:16,368 --> 00:10:18,032
将要被求值的表达式
the expression to be evaluated.

199
00:10:18,370 --> 00:10:19,808
具体来说
And by that, I mean

200
00:10:20,384 --> 00:10:21,648
它存放的是一个指针
it's going to hold a pointer

201
00:10:22,032 --> 00:10:23,552
指针指向存放着求值的表达式
to someplace in list structure memory

202
00:10:23,568 --> 00:10:25,328
的一处表结构内存
the expression to be evaluated.

203
00:10:26,550 --> 00:10:27,824
还有一个叫做ENV的寄存器
There's a register, called ENV,

204
00:10:28,880 --> 00:10:30,288
它存放着环境
which holds the environment

205
00:10:31,000 --> 00:10:33,056
也就是表达式的求值环境
in which this expression is to be evaluated.

206
00:10:34,070 --> 00:10:35,024
同样的 这也是一个指针
And, again, I made a pointer.

207
00:10:35,024 --> 00:10:36,752
环境是一种数据结构
The environment is some data structure.

208
00:10:38,240 --> 00:10:40,144
这个叫做FUN的寄存器--
There's a register, called FUN, which will

209
00:10:40,752 --> 00:10:42,544
当你在应用一个过程时
which will hold the procedure to be applied

210
00:10:42,576 --> 00:10:43,968
它会存放这个过程
when you go to apply a procedure.

211
00:10:44,560 --> 00:10:46,240
还有寄存器ARGL
A register, called ARGL,

212
00:10:47,360 --> 00:10:49,344
它存放的是已求值的参数
which holds the list of evaluated arguments.

213
00:10:50,540 --> 00:10:51,600
从这里开始你能看到
What you can start seeing here is

214
00:10:51,632 --> 00:10:53,140
求值器的基本构造
the basic structure of the evaluator.

215
00:10:53,140 --> 00:10:54,490
回忆一下它是怎么工作的
Remember how evaluators work.

216
00:10:54,490 --> 00:10:56,624
对这一块输入表达式和环境
There's a piece that takes expressions and environments,

217
00:10:57,670 --> 00:10:59,712
而这一块接收函数
and there's a piece that takes functions

218
00:10:59,744 --> 00:11:02,144
或者说 过程以及参数
or procedures and arguments.

219
00:11:03,480 --> 00:11:06,304
EVAL-APPLY循环使用这些寄存器工作
And going back and forth around here is the eval/apply loop.

220
00:11:07,408 --> 00:11:09,696
所以这些是EVAL-APPLY的基本组成部分
So those are the basic pieces of the eval and apply.

221
00:11:10,208 --> 00:11:11,610
还有一些别的东西 比如CONTINUE寄存器
Then there's some other things, there's continue.


222
00:11:11,610 --> 00:11:15,340
你之前已经见过CONTINUE寄存器
You just saw before how the continue register is used to

223
00:11:15,340 --> 00:11:18,048
是如何实现递归以及栈操作的
implement recursion and stack discipline.

224
00:11:18,940 --> 00:11:20,688
还有个寄存器用来存放
There's a register that's going to hold the

225
00:11:20,944 --> 00:11:22,520
某个求值的结果
result of some evaluation.

226
00:11:24,140 --> 00:11:24,896
然后 除了这些以外
And then, besides that,

227
00:11:24,896 --> 00:11:26,432
还有一个临时寄存器
there's one temporary register,

228
00:11:26,700 --> 00:11:27,296
它就是UNEV
called UNEV,

229
00:11:27,296 --> 00:11:29,040
一般来讲 在求值器中
which typically, in the evaluator,

230
00:11:29,280 --> 00:11:32,720
它是用来存放正在求值的表达式
is going to be used to hold temporary pieces of the

231
00:11:32,896 --> 00:11:33,950
的临时部分
expression you're working on,

232
00:11:33,950 --> 00:11:35,728
就是那些尚未求值的部分
which you haven't gotten around to evaluate yet

233
00:11:36,976 --> 00:11:39,824
那么 这就是我的七寄存器机器
Right? So there's my machine: a seven-register machine.

234
00:11:40,960 --> 00:11:42,980
当然 你可能想造一台
And, of course, you might want to make a machine with

235
00:11:42,980 --> 00:11:44,960
有更多寄存器的机器 来取得更好性能
a lot more registers to get better performance,

236
00:11:44,976 --> 00:11:47,056
但我们这个只是一台小型机器
but this is just a tiny, minimal one.

237
00:11:48,480 --> 00:11:49,584
那么数据通路呢？
Well, how about the data paths?

238
00:11:49,780 --> 00:11:53,664
这台机器有很多专为Lisp设计的运算
This machine has a lot of special operations for LISP.

239
00:11:55,100 --> 00:11:58,080
这里有几条典型的数据通路
So, here are some typical data paths.

240
00:12:00,120 --> 00:12:01,040
其中一条可能是
A typical one might be,

241
00:12:01,370 --> 00:12:04,800
将EXP寄存器的值赋给VAL寄存器
oh, assign to the VAL register the contents of the EXP register.

242
00:12:05,710 --> 00:12:08,016
用我们之前的数据通路图来说
That's in terms of those diagrams you saw,

243
00:12:08,032 --> 00:12:10,816
就是一条箭头上的小按钮
that's a little button on some arrow.

244
00:12:11,900 --> 00:12:13,136
这还有一个更复杂的
Here's a more complicated one.

245
00:12:13,690 --> 00:12:14,800
它判断
It says branch,

246
00:12:15,230 --> 00:12:19,584
如果EXP寄存器的内容是COND语句
if the thing in the expression register is a conditional

247
00:12:20,496 --> 00:12:22,720
那么这里就会跳转到EV-COND标号处
to some label here, called the ev-conditional.

248
00:12:23,808 --> 00:12:26,230
你可以想象出很多种实现它的方法
And you can imagine this implemented in a lot of different ways.

249
00:12:26,230 --> 00:12:28,368
你可以把这个判断看作是
You might imagine this conditional test

250
00:12:28,368 --> 00:12:29,984
一个特殊意图的子过程
as a special purpose sub-routine,

251
00:12:30,600 --> 00:12:33,952
而条件被表示成某种数据抽象
and conditional might be represented as some data abstraction

252
00:12:33,968 --> 00:12:36,000
你在这个层面上不用考虑它
that you don't care about at this level of detail.

253
00:12:36,610 --> 00:12:37,980
那么它可以用子过程实现
So that might be done as a sub-routine.

254
00:12:37,980 --> 00:12:40,672
如果机器通过硬件来判断表达式类型
This might be a machine with hardware-types,

255
00:12:40,900 --> 00:12:44,048
那么某些特定比特就代表了COND语句
and conditional might be testing some bits for a particular code.

256
00:12:45,350 --> 00:12:46,410
有很多种实现办法
There are all sorts of ways that's

257
00:12:46,410 --> 00:12:48,480
它们都低于我们关注的这一层抽象
beneath the level of abstraction we're looking at.

258
00:12:50,190 --> 00:12:51,712
然后还有另一种操作
Another kind of operation,

259
00:12:51,712 --> 00:12:53,240
以及其它很多操作
and there are a lot of different operations

260
00:12:53,240 --> 00:12:56,656
把EXP的第一个子句赋值给EXP
assigned to EXP, the first clause of what's in EXP.

261
00:12:56,840 --> 00:12:58,896
这可能是处理COND语句的一部分
This might be part of processing a conditional.

262
00:12:59,260 --> 00:13:01,808
同样 FIRST-SELECTOR这个选择子
And, again, first clause is some selector

263
00:13:03,072 --> 00:13:04,480
我们也不需要关心它的细节
whose details we don't care about.

264
00:13:04,496 --> 00:13:06,464
同样可以把那也看成一个子过程
And you can, again, imagine that as a sub-routine

265
00:13:06,460 --> 00:13:07,904
用来进行一些表操作
which'll do some list operations,

266
00:13:08,224 --> 00:13:09,180
或者你也可以想象成
or you can imagine that as

267
00:13:09,180 --> 00:13:10,736
一个直接构建在硬件中的东西
something that's built directly into hardware.

268
00:13:12,170 --> 00:13:13,712
我之所以强调
The reason I keep saying you can imagine it

269
00:13:14,032 --> 00:13:15,220
你可以把它想象成硬件直接实现
built directly into hardware

270
00:13:15,220 --> 00:13:17,808
是因为尽管有很多的运算
is even though there are a lot of operations,

271
00:13:18,360 --> 00:13:19,740
但也它们的数量也是固定的
there are still a fixed number of them.

272
00:13:20,128 --> 00:13:21,808
我记不清有多少 大概有150个
I forget how many, maybe 150.

273
00:13:22,370 --> 00:13:25,392
所以假设用硬件实现它们是合理的
So, it's plausible to think of building these directly into hardware.

274
00:13:26,416 --> 00:13:27,680
而这一条更加复杂
Here's a more complicated one.

275
00:13:28,270 --> 00:13:29,472
你会发现 这条涉及到
You can see this has to do with

276
00:13:29,472 --> 00:13:31,104
查找变量的值
looking up the values of variables.

277
00:13:31,500 --> 00:13:33,280
它会查找某条表达式中
It says assign to the VAL register

278
00:13:33,456 --> 00:13:36,912
某个变量的值
the result of looking up the variable value

279
00:13:36,992 --> 00:13:38,528
并赋值给VAL寄存器
of some particular expression,

280
00:13:39,180 --> 00:13:40,304
在本例中 也就是
which, in this case, is supposed to be

281
00:13:40,336 --> 00:13:42,000
在某个环境中查找变量
a variable in some environment.

282
00:13:42,800 --> 00:13:44,688
然后这个操作
And this'll be some operation

283
00:13:45,210 --> 00:13:47,504
会搜索整个环境结构
that search through the environment structure,

284
00:13:47,520 --> 00:13:48,976
无论环境是如何表示的
however it is represented,

285
00:13:49,376 --> 00:13:50,912
并查找该变量
and goes and looks up that variable.

286
00:13:52,176 --> 00:13:53,952
同样 它也不在我们思考的
And, again, that's below the level of detail

287
00:13:53,960 --> 00:13:54,864
的抽象层面上
that we're thinking about.

288
00:13:54,896 --> 00:13:57,300
它需要处理的细节是
This is... this has to do with the details of

289
00:13:57,552 --> 00:13:59,440
用来表示环境的数据结构
the data structures for representing environments.

290
00:14:00,070 --> 00:14:03,472
但是不管怎么说 这就是这个寄存器机器的
But, anyway, there is this fixed and finite number

291
00:14:04,112 --> 00:14:06,080
有穷数量的固定操作
of operations in the register machine.

292
00:14:08,500 --> 00:14:11,600
那么 它的整体结构是什么样子的？
Well, what's its overall structure?

293
00:14:11,720 --> 00:14:13,232
这有几个典型的运算
Those are some typical operations.

294
00:14:14,768 --> 00:14:16,336
想一想 我们要做什么
Remember what we have to do,

295
00:14:16,440 --> 00:14:18,400
我们需要把元循环求值器
we have to take the meta-circular evaluator--

296
00:14:20,432 --> 00:14:22,760
这就是元循环求值器的一部分
and here's a piece of the meta-circular evaluator.

297
00:14:22,760 --> 00:14:26,896
这是书中使用抽象代码的版本
This is the one using abstract syntax that's in the book.

298
00:14:28,224 --> 00:14:31,536
它和Gerry教授给你们展示的有些不同
It's a little bit different from the one that Gerry shows you.

299
00:14:33,500 --> 00:14:35,104
关于求值器
And the main thing

300
00:14:35,136 --> 00:14:37,870
主要需要记住的是
to remember about the evaluator is that

301
00:14:37,870 --> 00:14:40,960
它是某种针对表达式类型的分情况分析
it's doing some sort of case analysis on the kinds of expressions:

302
00:14:43,420 --> 00:14:48,560
so if it's either self-evaluated, or quoted, or whatever else.
看它是自求值的，还是一个引用，还是别的什么

303
00:14:48,560 --> 00:14:50,860
And then, in the general case where
而在大部分情况下

304
00:14:50,860 --> 00:14:53,550
the expression it's looking at is an application,
它处理的是一个应用过程

305
00:14:53,550 --> 00:14:55,750
there's some tricky recursions going on.
那么里面有一些技巧性的递归过程

306
00:14:55,750 --> 00:15:00,730
First of all, eval has to call itself both to evaluate the
首先，eval要调用它自己，

307
00:15:00,730 --> 00:15:05,880
operator and to evaluate all the operands.
求值操作符并且求值所有的操作数

308
00:15:05,880 --> 00:15:10,850
So there's this sort of red recursion of values walking down the tree
那么这个红色的递归在树上向下进行

309
00:15:10,850 --> 00:15:12,270
that's really the easy recursion.
这是很简单的递归

310
00:15:12,270 --> 00:15:14,750
That's just eval walking down this tree of expressions.
只有一个eval在这棵树上行走

311
00:15:14,750 --> 00:15:16,300
Then, in the evaluator, there's a hard recursion.
然后在求值器中，有一个复杂的递归

312
00:15:16,300 --> 00:15:21,650
There's the red to green. Eval calls apply.
也就是从红色到绿色，eval调用apply

313
00:15:22,470 --> 00:15:26,450
That's the case where evaluating a procedure or argument
这发生在对过程或者参数的求值

314
00:15:26,450 --> 00:15:30,370
reduces to applying the procedure to the list of arguments.
归约到对参数列表应用过程的时候

315
00:15:30,370 --> 00:15:33,870
And then, apply comes over here.
然后请看apply

316
00:15:34,770 --> 00:15:37,650
Apply takes a procedure and arguments
apply获取到过程和参数

317
00:15:37,650 --> 00:15:41,050
and, in the general case where there's a compound procedure,
一般情况下这是一个复合过程

318
00:15:41,050 --> 00:15:44,560
apply goes around and green calls red. Eval --
apply进行#TBD，绿色调用红色。Eval——

319
00:15:44,560 --> 00:15:48,170
Apply comes around and calls eval again.
Apply进行并且再次调用eval

320
00:15:48,170 --> 00:15:51,330
Eval's the body of the procedure in the result of
eval是过程的过程体，来自于

321
00:15:51,330 --> 00:15:55,480
extending the environment with the parameters of the procedure
用过程的参数扩展环境

322
00:15:55,480 --> 00:15:57,370
by binding the arguments.
用绑定变量的方式

323
00:15:59,620 --> 00:16:01,620
Except in the primitive case, where it just calls something else
除非在最基本的情况，它只需要调用一个

324
00:16:01,620 --> 00:16:05,980
primitive-apply, which is not really the business of the evaluator.
primitive-apply(apply基本过程)，而那又不是求值器的工作了

325
00:16:05,980 --> 00:16:11,240
So this sort of red to green, to red to green, that's the
那么像这样从红到绿，又到红又到绿，

326
00:16:11,240 --> 00:16:13,970
that's the eval/apply loop,
这就是eval/apply循环

327
00:16:13,970 --> 00:16:19,470
and that's the thing that we're going to want to see in the evaluator.
这就是我们在求值器里想看到的东西

328
00:16:19,470 --> 00:16:21,070
Well, it won't surprise you at all that
那么当你发现

329
00:16:21,070 --> 00:16:27,470
the two big pieces of this evaluator correspond to eval and apply.
这个求值器的两个很大的部分正与eval和apply相符的时候也不会太惊讶

330
00:16:27,470 --> 00:16:29,540
There's a piece called eval-dispatch,
第一个部分叫eval-dispatch

331
00:16:29,540 --> 00:16:31,910
and a piece called apply-dispatch.
第二个部分叫apply-dispatch

332
00:16:31,910 --> 00:16:34,090
And, before we get into the details of the code,
在我们关注代码细节之前

333
00:16:34,090 --> 00:16:37,760
the way to understand this is to think, again, in terms of
理解它的方法就是再次去思考

334
00:16:37,760 --> 00:16:41,870
these pieces of the evaluator having contracts with the rest of the world.
求值器的这些部分和这个世界中其它的部分有一些约定

335
00:16:41,870 --> 00:16:45,780
What do they do from the outside before getting into the grungy details?
#TBD它们在涉及到这些蹩脚的合约之前在外面做什么？

336
00:16:45,780 --> 00:16:51,300
Well, the contract for eval-dispatch-- remember, it corresponds to eval.
针对eval-dispatch的约定，记住它和eval对应

337
00:16:51,300 --> 00:16:54,100
It's got to evaluate an expression in an environment.
它要在环境中求值一个表达式

338
00:16:54,100 --> 00:16:56,520
So, in particular, what this one is going to do,
那么这一个东西要做的

339
00:16:56,520 --> 00:16:59,920
eval-dispatch will assume that, when you call it, that
eval-dispatch会假设当你调用它的时候

340
00:16:59,920 --> 00:17:03,640
the expression you want to evaluate is in the EXP register.
你想要求值的表达式就保存在EXP寄存器中

341
00:17:03,640 --> 00:17:07,750
The environment in which you want the evaluation to take place
而求值发生的环境

342
00:17:07,750 --> 00:17:09,560
is in the ENV register.
在ENV寄存器中

343
00:17:09,560 --> 00:17:11,890
And continue tells you the place where the machine should
而continue告诉你求值完成时

344
00:17:11,890 --> 00:17:14,570
go next when the evaluation is done.
机器需要执行哪里

345
00:17:17,440 --> 00:17:21,070
Eval-dispatch's contract is that it'll actually perform that evaluation,
eval-dispatch的约束是它要去实际执行那个求值

346
00:17:21,070 --> 00:17:26,610
and, at the end of which, it'll end up at the place specified by continue.
并且在求值后，它会转到由continue寄存器指定的位置

347
00:17:26,610 --> 00:17:29,820
The result of the evaluation will be in the VAL register.
求值的位置会保存在VAL寄存器中

348
00:17:29,820 --> 00:17:32,960
And it just warns you, it makes no promises about
需要提醒的是，它对于寄存器发生什么

349
00:17:32,960 --> 00:17:35,230
what happens to the registers.
不做任何保证

350
00:17:35,230 --> 00:17:37,490
All other registers might be destroyed.
可能所有的寄存器都被毁坏了

351
00:17:37,490 --> 00:17:41,410
So, there's one piece, OK?
那么这是一部分

352
00:17:41,410 --> 00:17:45,920
Together, the pieces, apply-dispatch that corresponds to apply,
这些部分一起，apply-dispatch和apply相对应

353
00:17:45,920 --> 00:17:48,730
it's got to apply a procedure to some arguments,
它要对一些参数应用一个过程

354
00:17:48,730 --> 00:17:51,430
so it assumes that this register, ARGL,
所以它假设ARGL寄存器

355
00:17:51,430 --> 00:17:54,540
contains a list of the evaluated arguments.
包含了被求值的参数的列表

356
00:17:54,540 --> 00:17:57,220
FUN contains the procedure.
FUN寄存器包含那个过程

357
00:17:57,220 --> 00:17:59,500
Those correspond to the arguments to the apply
这些和元循环求值器中

358
00:17:59,500 --> 00:18:02,300
procedure in the meta-circular evaluator.
apply过程的参数是相对应的

359
00:18:03,970 --> 00:18:07,670
And apply, in this particular evaluator, we're going to use a discipline which says
然后apply过程，在这个求值器中，我们要遵循的原则是

360
00:18:07,670 --> 00:18:12,550
the place the machine should go to next when apply is done
当apply完成后机器需要去到的位置

361
00:18:12,550 --> 00:18:17,070
is, at the moment apply-dispatch is called at the top of the stack
是apply-dispatch被调用时的栈顶元素

362
00:18:17,070 --> 00:18:21,840
that's just discipline for the way this particular machine's organized.
这是只针对这台机器的一条规则

363
00:18:21,840 --> 00:18:23,700
And now apply's contract is given all that.
现在已经给出了apply的全部约束

364
00:18:23,700 --> 00:18:25,540
It'll perform the application.
它会去应用过程

365
00:18:25,540 --> 00:18:28,890
The result of that application will end up in VAL.
这个应用的结果将会保存在VAL寄存器中

366
00:18:28,890 --> 00:18:31,120
The stack will be popped.
栈会被弹出

367
00:18:31,120 --> 00:18:34,840
And, again, the contents of all the other registers may be destroyed.
而且同样，所有其它寄存器的内容都可能毁坏

368
00:18:34,840 --> 00:18:39,760
All right? So that's the basic organization of this machine.
好吗？那么这就是这台机器的基本构造

369
00:18:39,760 --> 00:18:41,110
Let's break for a little bit and see if there are any
我们稍微休息一下看看有没有什么问题

370
00:18:41,110 --> 00:18:42,700
questions, and then we'll do a real example.
然后我们看一个真实的例子

371
00:19:47,850 --> 00:19:50,170
Well, let's take the register machine now,
我们现在看这个寄存器机器

372
00:19:50,170 --> 00:19:52,170
and actually step through,
并且步步跟进

373
00:19:52,200 --> 00:19:58,700
and really, in real detail, so you see completely concrete
真正细致地跟进，让你能完全看到

374
00:19:58,700 --> 00:20:03,400
how some expressions are evaluated, all right?
表达式是怎么被求值的，好吗

375
00:20:03,400 --> 00:20:09,300
So, let's start with a very simple expression.
那么我们从一个非常简单的表达式开始

376
00:20:09,620 --> 00:20:14,150
Let's evaluate the expression 1.
我们要求值的表达式只有一个1

377
00:20:18,770 --> 00:20:21,270
And we need an environment, so let's imagine that
我们需要一个环境，所以想象

378
00:20:21,270 --> 00:20:24,020
somewhere there's an environment, we'll call it E,0.
有一个环境，我们叫它E0

379
00:20:30,260 --> 00:20:35,620
And just, since we'll use these later,
而且虽然我们之后要用到

380
00:20:35,620 --> 00:20:38,360
we obviously don't really need anything to evaluate 1.
我们显然并不需要其它的东西来求值1

381
00:20:38,360 --> 00:20:41,200
But, just for reference later, let's assume that E,0 has in it
但是为了之后指代方便，我们假设环境E0中

382
00:20:41,200 --> 00:20:49,140
an X that's bound to 3 and a Y that's bound to 4, OK?
有一个变量X与3绑定，Y与4绑定，好吗

383
00:20:49,140 --> 00:20:53,700
And now what we're going to do is we're going to evaluate 1
现在我们要做的是我们在这个环境中

384
00:20:53,700 --> 00:20:59,650
in this environment, and so the ENV register has a pointer
求值1这个表达式，所以ENV寄存器里有一个指针

385
00:20:59,650 --> 00:21:03,560
to this environment, E,0, all right?
指向这个环境，E0，对吗

386
00:21:03,560 --> 00:21:05,650
So let's watch that thing go.
那么我们来看它怎么进行

387
00:21:05,650 --> 00:21:08,260
What I'm going to do is step through the code.
我要做的是步步跟进代码

388
00:21:08,260 --> 00:21:09,780
And, let's see, I'll be the controller.
大家看，我会作为控制器

389
00:21:09,780 --> 00:21:12,980
And now what I need, since this gets rather complicated,
现在我需要的，虽说这个通常很复杂

390
00:21:12,980 --> 00:21:16,830
is a very little execution unit.
是一个小小的执行单元

391
00:21:16,830 --> 00:21:21,310
So here's the execution unit, OK?
那么请上我们的执行单元，好吗

392
00:21:22,620 --> 00:21:23,870
OK.
好的

393
00:21:27,080 --> 00:21:28,590
OK.

394
00:21:28,590 --> 00:21:30,530
All right, now we're going to start.
好，现在我们要开始了

395
00:21:30,530 --> 00:21:33,700
We're going to start the machine at eval-dispatch, right?
我们要从eval-dispatch启动机器，对吗

396
00:21:33,700 --> 00:21:35,870
That's the beginning of this.
那是这个过程的开始

397
00:21:35,870 --> 00:21:39,320
Eval-dispatch is going to look at the expression in dispatch,
eval-dispatch会查看被分发的表达式

398
00:21:39,320 --> 00:21:40,870
just like eval
就像eval

399
00:21:40,870 --> 00:21:41,760
where we look at the very first thing.
最开始在eval里寻找东西

400
00:21:41,760 --> 00:21:47,950
We branch on whether or not this expression is self-evaluating.
我们判断这个表达式是不是自求值的

401
00:21:47,950 --> 00:21:52,170
Self-evaluating is some abstraction we put into the machine--
self-evaluating（自求值）是我们放进机器的一个抽象

402
00:21:52,170 --> 00:21:53,510
it's going to be true for numbers--
它对于数字来说为真

403
00:21:53,510 --> 00:21:56,770
to a place called ev-self-eval, right?
放在一个叫ev-self-eval的地方，对吗

404
00:21:56,770 --> 00:22:00,010
So me, being the controller, looks at ev-self-eval,
那么我，作为控制器，查看ev-self-eval

405
00:22:00,010 --> 00:22:02,600
so we'll go over to there.
所以我们要跳到那里

406
00:22:02,600 --> 00:22:08,120
Ev-self-eval says fine, assign to val
Ev-self-eval说好，给VAL寄存器赋值

407
00:22:08,120 --> 00:22:15,220
whatever is in the expression unit, OK?
把表达式单元（EXP）中的东西赋给它，好吗

408
00:22:15,220 --> 00:22:17,600
And I have a bug
然后我有一个bug

409
00:22:17,600 --> 00:22:17,650
because what I didn't do when I initialized this machine

410
00:22:17,650 --> 00:22:21,620
because what I didn't do when I initialized this machine
因为我初始化机器的时候没有做一件事情

411
00:22:21,620 --> 00:22:24,650
is also say what's supposed to happen when it's done,
就是说好完成的时候应该做什么

412
00:22:24,650 --> 00:22:27,640
so I should have started out the machine with
所以我应该在启动机器的时候

413
00:22:27,640 --> 00:22:32,050
done being in the continue register, OK?
让continue寄存器的内容为done，对吗

414
00:22:32,050 --> 00:22:33,070
So we assign to VAL.
所以我们给VAL赋值

415
00:22:33,070 --> 00:22:38,000
And now go to fetch of continue, and now change--
现在取出continue里的东西，并且修改

416
00:22:38,000 --> 00:22:40,000
OK.
好

417
00:22:40,000 --> 00:22:42,160
OK, let's try something harder.
好，我们看一点更难的

418
00:22:42,160 --> 00:22:44,780
Let's reset the machine here,
我们在这里重置机器

419
00:22:44,780 --> 00:22:51,560
and we'll put in the expression register, X, OK?
然后我们要把表达式X放进EXP里

420
00:22:56,710 --> 00:22:59,610
Start again at eval-dispatch.
重新从eval-dispatch开始

421
00:22:59,610 --> 00:23:01,690
Check, is it self-evaluating?
看，它是自求值的吗

422
00:23:01,690 --> 00:23:02,650
No.
不是

423
00:23:02,650 --> 00:23:04,630
Is it a variable?
它是变量吗

424
00:23:04,630 --> 00:23:05,560
Yes.
是的

425
00:23:05,560 --> 00:23:08,380
We go off to ev-variable.
我们执行ev-variable

426
00:23:08,380 --> 00:23:12,130
It says assign to VAL,
它说给VAL赋值

427
00:23:12,130 --> 00:23:16,150
look up the variable value in the expression register, OK?
查询EXP寄存器里变量的值，对吧

428
00:23:21,070 --> 00:23:23,620
Go to fetch of continue.
取出continue的内容

429
00:23:23,620 --> 00:23:24,870
PROFESSOR: Done.
好了

430
00:23:27,250 --> 00:23:28,950
PROFESSOR: OK.
好

431
00:23:28,950 --> 00:23:29,430
All right.
好

432
00:23:29,430 --> 00:23:31,330
Well, that's the basic idea.
那这是基本的想法

433
00:23:31,330 --> 00:23:32,680
That's a simple operation of the machine.
这是这个机器上一个简单的操作

434
00:23:32,680 --> 00:23:36,070
Now, let's actually do something a little bit more interesting.
现在我们实际做一些有趣一点的事情

435
00:23:36,070 --> 00:23:49,670
Let's look at the expression the sum of x and y.
我们看这个表达式，x和y求和

436
00:23:49,670 --> 00:23:50,130
OK.
好

437
00:23:50,130 --> 00:23:54,350
And now we'll see how you start unrolling these expression trees.
现在我们会看到怎么开始展开表达式树

438
00:23:56,620 --> 00:23:59,430
Well, start again at eval-dispatch.
再次从eval-dispatch开始

439
00:24:04,610 --> 00:24:05,930
Self-evaluating?
是自求值的吗

440
00:24:05,930 --> 00:24:06,850
No.
不是

441
00:24:06,850 --> 00:24:07,850
Variable? No.
是变量吗？不是

442
00:24:07,850 --> 00:24:10,270
All the other special forms which I didn't write down,
其他我没写在这里的所有特殊形式

443
00:24:10,270 --> 00:24:12,480
like quote, and lambda, and set, and whatever,
引用，lambda，集合，其他什么东西

444
00:24:12,480 --> 00:24:13,260
it's none of those.
它全都不是

445
00:24:13,260 --> 00:24:15,880
It turns out to be an application,
那么它是一个过程应用

446
00:24:15,880 --> 00:24:19,970
so we go off to ev-application, OK?
所以我们去到ev-application这里，对吗

447
00:24:19,970 --> 00:24:25,580
Ev-application, remember what it's going to do overall.
记住ev-application需要做什么

448
00:24:25,580 --> 00:24:28,310
It is going to evaluate the operator.
它需要求值操作符

449
00:24:28,310 --> 00:24:32,220
It's going to evaluate the arguments,
它需要求值那些参数

450
00:24:32,220 --> 00:24:35,060
and then it's going to go apply them.
然后它需要应用过程

451
00:24:35,060 --> 00:24:37,880
So, before we start, since we're being very literal,
所以在我们开始之前，为了保持字面上的严谨#TBD

452
00:24:37,880 --> 00:24:40,430
we'd better remember that, somewhere in this environment,
我们最好记住，这个环境的某一个地方

453
00:24:40,430 --> 00:24:44,470
it's linked to another environment in which
链接到了另一个环境

454
00:24:44,470 --> 00:24:51,470
plus is bound to the primitive procedure plus
在那里加号与加法这个基本过程相绑定

455
00:24:51,470 --> 00:24:55,340
before we get an unknown variable in our machine.
以防止我们在机器中拿到一个未知变量#TBD

456
00:24:55,340 --> 00:24:58,620
OK, so we're at ev-application.
好，那么我们看ev-application

457
00:24:59,700 --> 00:25:04,400
OK, assign to UNEV the operands
给UNEV赋值操作数

458
00:25:04,400 --> 00:25:07,920
of what's in the expression register, OK?
EXP寄存器里的东西的操作数，对吗

459
00:25:07,920 --> 00:25:09,230
Those are the operands.
这些是操作数

460
00:25:09,230 --> 00:25:13,220
UNEV's a temporary register where we're going to save them.
UNEV是一个用来保存它们的临时寄存器

461
00:25:13,220 --> 00:25:13,860
PROFESSOR: I'm assigning.
我正在赋值

462
00:25:13,860 --> 00:25:18,070
PROFESSOR: Assign to EXP the operator.
给EXP赋值这个操作符

463
00:25:18,070 --> 00:25:21,840
Now, notice we've destroyed that expression in x,
现在，注意到我们已经销毁了这个关于x的表达式#TBD

464
00:25:21,840 --> 00:25:25,820
but the piece that we need is now in UNEV. OK.
但是我们需要的部分在UNEV中，好

465
00:25:25,820 --> 00:25:28,750
Now, we're going to get set up to recursively evaluate the operator.
现在我们要准备好递归求值这个操作符

466
00:25:28,750 --> 00:25:32,820
Save the continue register on the stack.
把continue寄存器保存在栈上

467
00:25:34,870 --> 00:25:37,600
Save the environment.
保存环境

468
00:25:40,520 --> 00:25:43,590
Save UNEV.
保存UNEV

469
00:25:49,400 --> 00:25:56,230
OK, assign to continue a label called eval-args.
给continue赋值一个叫做eval-args的标签

470
00:26:01,400 --> 00:26:01,950
Now, what have we done?
我们做了什么

471
00:26:01,950 --> 00:26:04,380
We've set up for a recursive call.
我们为递归调用做了必要的准备

472
00:26:04,380 --> 00:26:06,280
We're about to go to eval-dispatch.
我们要开始执行eval-dispatch

473
00:26:06,280 --> 00:26:10,230
We've set up for a recursive call to eval-dispatch.
我们为递归调用eval-dispatch做了准备

474
00:26:10,230 --> 00:26:11,020
What did we do?
我们做了哪些事情

475
00:26:11,020 --> 00:26:14,420
We took the things we're going to need later,
我们把之后要用到的东西

476
00:26:14,420 --> 00:26:16,360
those operands that were in UNEV;
UNEV里面的这些操作数

477
00:26:16,360 --> 00:26:19,070
the environment in which we're going to eventually have to,
还有这个环境，我们最后要在里面

478
00:26:19,070 --> 00:26:22,120
maybe, evaluate those operands;
可能要求值操作数

479
00:26:22,120 --> 00:26:25,260
the place we eventually want to go to, which, in this case, was done;
还有这个我们最后要回到的位置，这个例子里是done

480
00:26:25,260 --> 00:26:27,270
we've saved them on the stack.
我们把这些东西存在了栈上

481
00:26:27,270 --> 00:26:28,720
The reason we saved them on the stack is because
我们把它们存在栈上的原因是

482
00:26:28,720 --> 00:26:33,550
eval-dispatch makes no promises about what registers it may destroy.
eval-dispatch不保证它不会毁坏寄存器

483
00:26:33,550 --> 00:26:35,020
So all that stuff is saved on the stack.
那么所有这些东西都存在了栈上

484
00:26:35,020 --> 00:26:37,380
Now, we've set up eval-dispatch's contract.
现在我们准备好了eval-dispatch的约束

485
00:26:37,380 --> 00:26:40,960
There's a new expression, which is the operator plus;
有一个新的表达式，也就是加法操作符

486
00:26:40,960 --> 00:26:44,250
a new environment, although, in this case, it's the same one;
一个新的环境，尽管在这里和刚才一样

487
00:26:44,250 --> 00:26:47,600
and a new place to go to when you're done, which is eval-args.
和一个新的，完成时要返回的位置，也就是eval-args

488
00:26:47,600 --> 00:26:48,130
So that's set up.
那么我们准备好了

489
00:26:48,130 --> 00:26:50,890
Now, we're going to go off to eval-dispatch.
现在我们来执行eval-dispatch

490
00:26:50,890 --> 00:26:53,090
Here we are back at eval-dispatch.
我们回到了eval-dispatch

491
00:26:53,090 --> 00:26:54,490
It's not self-evaluating.
它不是自求值的

492
00:26:54,490 --> 00:27:00,140
Oh, it's a variable, so we'd better go off to ev-variable, right?
哦，它是一个变量，所以我们最好调用ev-variable，对吧

493
00:27:00,140 --> 00:27:02,880
Ev-variable is assigned to VAL.
给VAL赋值ev-variable

494
00:27:02,880 --> 00:27:08,770
Look up the variable value of the expression, OK?
查询表达式里变量的值

495
00:27:08,770 --> 00:27:13,000
So VAL is the primitive procedure plus, OK?
那么VAL寄存器中应该是加法基本操作

496
00:27:13,000 --> 00:27:15,020
And go to fetch of continue.
然后去读取continue

497
00:27:15,020 --> 00:27:16,050
PROFESSOR: Eval-args.
是eval-args

498
00:27:16,050 --> 00:27:19,340
PROFESSOR: Right, which is now eval-args not done.
对，是现在还没有完成的eval-args

499
00:27:19,340 --> 00:27:23,070
So we come back here at eval-args, and what do we do?
所以我们回到eval-args，我们应该做什么

500
00:27:23,070 --> 00:27:29,050
We're going to restore the stuff that we saved, so we restore UNEV.
我们应该取回我们保存起来的东西，所以我们恢复UNEV

501
00:27:29,050 --> 00:27:32,900
And notice, there, it wasn't necessary, although, in general, it would be.
注意这里，尽管它不是必须的，但是通常来说是，

502
00:27:32,900 --> 00:27:35,430
It might be some arbitrary evaluation that happened.
它可能是发生的任何求值过程

503
00:27:35,430 --> 00:27:54,900
We restore ENV. OK, we assign to FUN fetch of VAL.
我们恢复ENV，好，我们给FUN赋值VAL的值

504
00:27:58,620 --> 00:28:04,340
OK, now, we're going to go off and start evaluating some arguments.
现在我们要开始求值参数

505
00:28:04,340 --> 00:28:08,330
Well, first thing we'd better do is save FUN because some
我们最好先把FUN寄存器保存起来

506
00:28:08,330 --> 00:28:13,670
arbitrary stuff might happen in that evaluation.
因为求值过程中可能发生任何事情

507
00:28:15,330 --> 00:28:20,750
We initialize the argument list. Assign to argl an empty argument list,
我们初始化参数列表，给ARGL赋值一个空的参数列表

508
00:28:20,750 --> 00:28:25,460
and go to eval-arg-loop, OK?
然后调用eval-arg-loop，对吗

509
00:28:25,460 --> 00:28:29,580
At eval-arg-loop, the idea of this is we're going to
在eval-arg-loop这里，它的想法是我们要

510
00:28:29,580 --> 00:28:33,540
evaluate the pieces of the expressions that are in UNEV, one by one,
一个一个地求值UNEV中的表达式的部分

511
00:28:33,540 --> 00:28:35,680
and move them from unevaluated in UNEV
然后把它们从保存未求值表达式的UNEV

512
00:28:35,680 --> 00:28:38,090
to evaluated in the arg list, OK?
移到求值完成的参数列表中，对吗

513
00:28:38,090 --> 00:28:42,400
So we save argl.
那么保存ARGL

514
00:28:43,950 --> 00:28:49,140
We assign to EXP the first operand of the stuff in UNEV.
我们给EXP赋值UNEV里面东西的第一个操作数

515
00:28:53,770 --> 00:28:55,890
Now, we check and see if that was the last operand.
现在我们检查那是不是最后一个

516
00:28:55,890 --> 00:28:59,190
In this case, it is not, all right?
现在它不是，对吧

517
00:28:59,190 --> 00:29:02,970
So we save the environment.
那么我们保存环境

518
00:29:07,850 --> 00:29:13,500
We save UNEV because those are all things we might need later.
我们把UNEV存起来因为里面有我们之后需要的所有东西

519
00:29:13,500 --> 00:29:15,800
We're going to need the environment to do some more evaluations.
我们需要这个环境来执行更多的求值

520
00:29:15,800 --> 00:29:20,340
We're going to need UNEV to look at what the rest of those arguments were.
我们需要UNEV来查询剩下的参数是什么

521
00:29:20,340 --> 00:29:26,050
We're going to assign continue a place called accumulate-args, or accumulate-arg.
我们要给continue赋值一个叫做accumulate-args的东西，或者accumulate-arg

522
00:29:30,890 --> 00:29:36,810
OK, now, we've set up for another call to eval-dispatch, OK?
好，现在我们已经准备好再次调用eval-dispatch了，对吗

523
00:29:36,810 --> 00:29:39,120
All right, now, let me short-circuit this
现在让我们把这个短路掉

524
00:29:39,120 --> 00:29:41,090
so we don't go through the details of eval-dispatch.
这里我们不跟进eval-dispatch的细节

525
00:29:41,090 --> 00:29:45,100
Eval-dispatch's contract says I'm going to end up,
eval-dispatch的约束说我要在结束时

526
00:29:45,100 --> 00:29:48,240
the world will end up, with the value of evaluating this expression
这个世界最终变成，求值这个表达式得到的值

527
00:29:48,240 --> 00:29:50,270
in this environment in the VAL register,
在这个环境中保存在VAL寄存器里

528
00:29:50,270 --> 00:29:51,320
and I'll end up there.
我在这里结束

529
00:29:51,320 --> 00:29:58,010
So we short-circuit all of this, and a 3 ends up in VAL.
那么我们把这些全都短路掉，最后VAL的内容是3

530
00:29:58,010 --> 00:29:59,760
And, when we return from eval-dispatch,
并且当我们从eval-dispatch返回的时候

531
00:29:59,760 --> 00:30:02,110
we're going to return to accumulate-arg.
我们会返回到accumulate-arg这里

532
00:30:02,110 --> 00:30:03,550
PROFESSOR: Accumulate-arg.
accumulate-arg

533
00:30:06,180 --> 00:30:08,720
PROFESSOR: With 3 in the VAL register, OK?
VAL寄存器里是3，对吧

534
00:30:08,720 --> 00:30:10,650
So that short-circuited that evaluation.
求值被短路了

535
00:30:10,650 --> 00:30:11,320
Now, what do we do?
现在我们做什么

536
00:30:11,320 --> 00:30:13,680
We're going to go back and look at the rest of the arguments,
我们返回继续看剩下的参数

537
00:30:13,680 --> 00:30:15,600
so we restore UNEV.
所以我们恢复UNEV

538
00:30:17,510 --> 00:30:28,650
We restore ENV. We restore argl.
恢复ENV，恢复ARGL

539
00:30:28,650 --> 00:30:29,170
One thing.
这件事

540
00:30:29,170 --> 00:30:30,530
PROFESSOR: Oops!
哦

541
00:30:30,530 --> 00:30:31,290
Parity error.
奇偶错误

542
00:30:31,290 --> 00:30:33,460
[LAUGHTER]
（笑声）

543
00:30:33,460 --> 00:30:34,900
PROFESSOR: Restore argl.
恢复ARGL

544
00:30:41,650 --> 00:30:42,900
PROFESSOR: OK.
好的

545
00:30:45,570 --> 00:30:50,400
OK, we assign to argl consing on
好，我们给ARGL cons上一个

546
00:30:50,400 --> 00:30:53,130
fetch of the value register to what's in argl.
把从VAL寄存器中读到的值cons到ARGL上

547
00:30:58,980 --> 00:31:05,020
OK, we assign to UNEV the rest of the operands in fetch of UNEV,
我们给UNEV赋值，从UNEV中读取剩下的操作数

548
00:31:08,700 --> 00:31:11,510
and we go back to eval-arg-loop.
然后我们返回eval-arg-loop

549
00:31:11,510 --> 00:31:12,280
PROFESSOR: Eval-arg-loop.
eval-arg-loop

550
00:31:12,280 --> 00:31:13,530
PROFESSOR: OK.

551
00:31:15,880 --> 00:31:17,370
Now, we're about to do the next argument,
现在我们处理下一个参数

552
00:31:17,370 --> 00:31:19,800
so the first thing we do is save argl.
所以首先我们要保存ARGL

553
00:31:25,400 --> 00:31:31,800
OK, we assign to EXP the first operand of fetch of UNEV.
好，我们给EXP赋值从UNEV里读到的第一个操作数

554
00:31:34,650 --> 00:31:38,920
OK,we test and see if that's the last operand.In this case, it is
我们检查那是不是最后一个操作数，在这里它是的

555
00:31:38,920 --> 00:31:43,170
so we're going to go to a special place that says evaluate the last argument
所以我们跳到一个特殊的地方，它来求值最后一个参数

556
00:31:43,170 --> 00:31:44,960
because, notice,after evaluating the argument,
因为请注意，在求值这个参数之后

557
00:31:44,960 --> 00:31:47,440
we don't need the environment any more.
我们就不再需要这个环境了

558
00:31:47,440 --> 00:31:50,250
That's going to be the difference.
那就是区别

559
00:31:50,250 --> 00:31:52,050
So here, at eval-last-arg,
在这里，在eval-last-arg这里

560
00:31:52,050 --> 00:31:55,380
which is assigned to continue accumulate-last-arg,
continue被赋值了了accumulate-last-arg

561
00:32:04,270 --> 00:32:06,900
now, we're set up again for eval-dispatch.
现在我们再次为eval-dispatch做准备

562
00:32:06,900 --> 00:32:08,620
We've got a place to go to when we're done.
我们有一个完成时要跳到的地方

563
00:32:08,620 --> 00:32:09,840
We've got an expression.
我们有一个表达式

564
00:32:09,840 --> 00:32:11,330
We've got an environment.
我们有一个环境

565
00:32:11,330 --> 00:32:14,370
OK, so we'll short-circuit the call to eval-dispatch.
好，那么我们短路对eval-dispatch的调用

566
00:32:14,370 --> 00:32:16,700
And what'll happen is there's a y there,
现在情况是这里有一个Y

567
00:32:16,700 --> 00:32:21,060
it's 4 in that environment, so VAL will end up with 4 in it.
它在这个环境里是4，所以VAL寄存器最后将会存着4

568
00:32:21,060 --> 00:32:25,450
And, then, we're going to end up at accumulate-last-arg, OK?
那么然后我们要在accumulate-last-arg这里结束了，对吧

569
00:32:25,450 --> 00:32:30,520
So, at accumulate-last-arg, we restore argl.
所以在accumulate-last-arg这里我们恢复ARGL寄存器

570
00:32:41,490 --> 00:32:45,830
We assign to argl cons of fetch of the new value onto it,
我们给ARGL赋值它和读到的新值cons后的结果

571
00:32:45,830 --> 00:32:49,850
so we cons a 4 onto that.
所以我们在那上面cons一个4

572
00:32:49,850 --> 00:32:53,440
We restore what was saved in the function register.
我们恢复保存在函数寄存器（FUN）中的东西

573
00:32:53,440 --> 00:32:56,270
And notice, in this case, it had not been destroyed,
注意在这里它没有被销毁

574
00:32:56,270 --> 00:32:59,130
but in general, it will be.
但是通常来讲它会的

575
00:32:59,130 --> 00:33:02,850
And now, we're ready to go off to apply-dispatch, all right?
现在我们准备好调用apply-dispatch了，对吗

576
00:33:02,850 --> 00:33:04,510
So we've just gone through the eval.
所以我们刚刚步步跟进了eval过程

577
00:33:04,510 --> 00:33:07,980
We evaluated the argument, the operator, and the arguments,
我们求值了参数，操作数和参数列表，

578
00:33:07,980 --> 00:33:09,580
and now, we're about to apply them.
现在我们要应用过程

579
00:33:09,580 --> 00:33:17,480
So we come off to apply-dispatch here, OK?
所以我们来到apply-dispatch这里，好吗

580
00:33:17,480 --> 00:33:20,570
We come off to apply-dispatch,
我们来到apply-dispatch

581
00:33:20,570 --> 00:33:23,450
and we're going to check whether it's a primitive or a compound procedure.
我们要检查它是一个基本过程还是复合过程

582
00:33:23,450 --> 00:33:24,110
PROFESSOR: Yes.
对

583
00:33:24,110 --> 00:33:24,830
PROFESSOR: All right.
好的

584
00:33:24,830 --> 00:33:27,370
So, in this case, it's a primitive procedure,
那么在这种情况下它是一个基本过程

585
00:33:27,370 --> 00:33:29,790
and we go off to primitive-apply.
我们去调用primitive-apply（基本应用）

586
00:33:29,790 --> 00:33:34,130
So we go off to primitive-apply, and it says
那么我们看primitive-apply，它说

587
00:33:34,130 --> 00:33:38,360
assign to VAL the result of applying primitive procedure
给VAL赋值对参数列表应用

588
00:33:38,360 --> 00:33:40,940
of the function to the argument list.
应用函数中的基本过程后的结果

589
00:33:40,940 --> 00:33:42,540
PROFESSOR: I don't know how to add.
我不知道怎么做加法

590
00:33:42,540 --> 00:33:43,990
I'm just an execution unit.
我只是一个执行单元

591
00:33:43,990 --> 00:33:45,350
PROFESSOR: Well, I don't know how to add either.
我也不知道

592
00:33:45,350 --> 00:33:48,360
I'm just the evaluator, so we need a primitive operator.
我只是一个求值器，所以我们需要一个基本操作符

593
00:33:48,360 --> 00:33:50,920
Let's see, so the primitive operator, what's the
我看看，那么这位基本操作符，

594
00:33:50,920 --> 00:33:52,600
What's the sum of 3 and 4?
3+4等于多少？

595
00:33:52,600 --> 00:33:53,200
AUDIENCE: 7.
观众：7

596
00:33:53,200 --> 00:33:55,050
PROFESSOR: OK, 7.
教授：好的，7

597
00:33:55,050 --> 00:33:55,990
PROFESSOR: Thank you.
谢谢

598
00:33:58,830 --> 00:34:00,850
PROFESSOR: Now, we restore continue,
现在我们恢复continue

599
00:34:11,270 --> 00:34:12,900
and we go to fetch of continue.
读取里面的东西

600
00:34:12,900 --> 00:34:13,880
PROFESSOR: Done.
好了

601
00:34:13,880 --> 00:34:14,920
PROFESSOR: OK.
好

602
00:34:14,920 --> 00:34:18,410
Well, that was in as much detail as you will ever see.
这些是你能看到的最细致的过程了

603
00:34:18,410 --> 00:34:21,590
We'll never do it in as much detail again.
我们再也不会讲得这么细了

604
00:34:21,590 --> 00:34:25,230
One very important thing to notice is that
一个很重要的事情是

605
00:34:25,230 --> 00:34:29,780
we just executed a recursive procedure, right?
我们刚刚执行了一个递归过程，是吧

606
00:34:29,780 --> 00:34:31,170
This whole thing, we used a stack
整个东西，我们使用了栈

607
00:34:31,170 --> 00:34:33,070
and the evaluator was recursive.
而且求值器是递归的

608
00:34:33,070 --> 00:34:36,480
A lot of people think the reason that you need a stack
有很多人以为我们在求值器中

609
00:34:36,480 --> 00:34:39,090
and recursion in an evaluator is because you might be
需要栈和递归的理由是你可能

610
00:34:39,090 --> 00:34:42,150
evaluating recursive procedures like factorial or Fibonacci.
会用它求值像阶乘或者斐波那契这样的递归过程

611
00:34:42,150 --> 00:34:43,670
It's not true.
那是错误的

612
00:34:43,670 --> 00:34:46,110
So you notice we did recursion here, and all we evaluated was
你看我们在这里做了递归，而我们求值的只有

613
00:34:46,110 --> 00:34:48,010
plus X, Y, all right?
x加上y，对吧

614
00:34:48,010 --> 00:34:51,210
The reason that you need recursion in the evaluator is
在求值器中需要递归的理由是

615
00:34:51,210 --> 00:34:54,450
because the evaluation process, itself, is recursive, all right?
是因为求值这个过程本身，就是递归的，好吗

616
00:34:54,450 --> 00:34:57,760
It's not because the procedure that you might be evaluating in LISP
而不是因为你要用LISP求值的过程

617
00:34:57,760 --> 00:34:59,270
is a recursive procedure.
可能是一个递归过程

618
00:34:59,270 --> 00:35:00,410
So that's an important thing
所以那是一件很重要的事情

619
00:35:00,410 --> 00:35:03,010
that people get confused about a lot.
人们经常在这里被迷惑

620
00:35:03,010 --> 00:35:06,280
The other thing to notice is that, when we're done here,
另一点要注意的是，我们在这里完成之后，

621
00:35:06,280 --> 00:35:07,120
we're really done.
我们就真的完成了

622
00:35:07,120 --> 00:35:10,870
Not only are we at done, but
不仅完成了，而且

623
00:35:10,870 --> 00:35:13,810
there's no accumulated stuff on the stack, right?
栈上没有堆起来的东西了，对吧

624
00:35:13,810 --> 00:35:17,170
The machine is back to its initial state, all right?
这个机器返回最开始的状态了，是吧

625
00:35:17,170 --> 00:35:19,710
So that's part of what it means to be done.
那就是“完成”的其中一部分意义

626
00:35:19,710 --> 00:35:26,410
Another way to say that is the evaluation process has reduced
从另一个角度来看是，求值过程

627
00:35:26,410 --> 00:35:33,240
the expression, plus X, Y, to the value here, 7.
把+ x y这个表达式归约到了7这个值

628
00:35:33,240 --> 00:35:36,010
And by reduced, I mean a very particular thing.
我说归约（减少），指的是一个特定的事情

629
00:35:36,010 --> 00:35:38,180
It means that there's nothing left on the stack.
那意味着栈上没剩下任何东西了

630
00:35:38,180 --> 00:35:40,740
The machine is now in the same state,
机器现在在与开始相同的状态

631
00:35:40,740 --> 00:35:42,720
except there's something in the value register.
除了VAL寄存器里有一些东西

632
00:35:42,720 --> 00:35:44,520
It's not part of a sub-problem of anything.
它不是任何问题的子问题

633
00:35:44,520 --> 00:35:46,210
There's nothing to go back to.
不需要回到任何步骤

634
00:35:46,210 --> 00:35:46,440
OK.
好

635
00:35:46,440 --> 00:35:47,690
Let's break.
我们休息

636
00:35:49,710 --> 00:35:50,150
Question?
有问题吗

637
00:35:50,150 --> 00:35:54,020
AUDIENCE: The question here, in the stack,
观众：关于栈有一个问题

638
00:35:54,020 --> 00:35:55,820
is because the data may be recursive.
是数据有可能是递归的

639
00:35:55,820 --> 00:35:59,310
You may have embedded expressions, for instance.
例如你可能会遇到嵌套的表达式

640
00:35:59,310 --> 00:36:02,080
PROFESSOR: Yes, because you might have embedded expressions.
教授：是的，因为你可能遇到嵌套的表达式

641
00:36:02,080 --> 00:36:04,770
But, again, don't confuse that
但是再说一遍，不要搞混

642
00:36:04,770 --> 00:36:07,710
with what people sometimes mean by the data may be recursive,
有时候人们说数据是递归的

643
00:36:07,710 --> 00:36:12,930
which is to say you have these list-structured, recursive data list operations.
他们说的是存在这些列表结构的，递归的数据列表操作

644
00:36:12,930 --> 00:36:13,800
That has nothing to do with it.
那和这没有关系

645
00:36:13,800 --> 00:36:17,360
It's simply that the expressions contain sub-expressions.
这只是包含子表达式的表达式而已

646
00:36:17,360 --> 00:36:19,610
Yeah?
嗯

647
00:36:19,610 --> 00:36:23,450
AUDIENCE: Why is it that the order of the arguments in the arg list got reversed?
观众：为什么参数列表中参数的顺序是反过来的

648
00:36:23,450 --> 00:36:27,260
PROFESSOR: Ah! Yes, I should've mentioned that.
教授：啊！是，我应该提到这个的

649
00:36:27,260 --> 00:36:29,070
Here, the reason the order is reversed--
这里顺序反过来的原因是

650
00:36:32,500 --> 00:36:36,050
it's a question of what you mean by reversed.
问题在于你怎么定义“反过来”

651
00:36:36,050 --> 00:36:40,620
I believe it was Newton.
我记得应该是牛顿

652
00:36:40,620 --> 00:36:43,800
In the very early part of optics, people realized that,
在光学发展的很早期，人们意识到

653
00:36:43,800 --> 00:36:45,500
when you look through the lens of your eye,
你用眼睛通过透镜看东西的时候

654
00:36:45,500 --> 00:36:46,730
the image was up-side down.
图像是上下颠倒的

655
00:36:46,730 --> 00:36:48,040
And there was a lot of argument about
当时有很多的争论说

656
00:36:48,040 --> 00:36:51,280
why that didn't mean you saw things up-side down.
为什么不能是你眼睛平时看见的都是上下颠倒的

657
00:36:51,280 --> 00:36:52,860
So it's sort of the same issue.
这实际上是一样的道理

658
00:36:52,860 --> 00:36:54,810
Reversed from what?
和什么相比反过来了

659
00:36:54,810 --> 00:36:57,940
So we just need some convention.
我们只是需要一个约定

660
00:36:57,940 --> 00:37:01,730
The reason that they're coming at 4, 3 is because we're
它们作为4,3出现的原因是

661
00:37:01,730 --> 00:37:04,520
taking UNEV and consing the result onto argl.
我们从UNEV中取出东西并且cons到了ARGL上面

662
00:37:04,520 --> 00:37:06,770
So you have to realize you've made that convention.
那么你要意识到你已经做了这个约定

663
00:37:06,770 --> 00:37:09,980
The place that you have to realize that--
你需要意识到这点的地方有

664
00:37:09,980 --> 00:37:11,230
well, there's actually two places.
实际上有两个地方

665
00:37:11,230 --> 00:37:12,910
One is in apply-primitive-operator,
第一个在apply-primitive-operator（应用基本操作）这里

666
00:37:12,910 --> 00:37:16,610
which has to realize that the arguments to primitives go in,
你要意识到参数进入基本操作的顺序

667
00:37:16,610 --> 00:37:19,490
in the opposite order from the way you're writing them down.
和你把它们写下来的顺序相反

668
00:37:19,490 --> 00:37:21,000
And the other one is, we'll see later
另一个地方，我们之后会看到

669
00:37:21,000 --> 00:37:24,010
when you actually go to bind a function's parameters,
当你要绑定一个函数的参数的时候

670
00:37:24,010 --> 00:37:25,740
you should realize the arguments are going to come in
你要意识到参数进入的顺序

671
00:37:25,740 --> 00:37:28,870
from the opposite order of the variables to which you're binding them.
和你要绑定这些变量时的顺序相反

672
00:37:28,870 --> 00:37:31,830
So, if you just keep track of that, there's no problem.
所以如果你注意这些，就没有问题了

673
00:37:31,830 --> 00:37:33,900
Also, this is completely arbitrary
同样，这是完全随意的

674
00:37:33,900 --> 00:37:37,420
because, if we'd done, say, an iteration through a vector assigning them,
因为如果我们做了一个，比如，给向量的各个维度赋值的迭代

675
00:37:37,420 --> 00:37:40,730
they might come out in the other order, OK?
它们可能会以其他顺序输出，对吗

676
00:37:40,730 --> 00:37:45,080
So it's just a convention of the way this particular evaluator works.
那么这只是这个求值器工作时的一个约定

677
00:37:45,080 --> 00:37:46,330
All right, let's take a break.
好，我们休息一下

678
00:38:41,840 --> 00:38:45,600
We just saw evaluating an expression and,

679
00:38:45,600 --> 00:38:46,950
of course, that was very simple one.

680
00:38:46,950 --> 00:38:50,240
But, in essence, it would be no different

681
00:38:50,240 --> 00:38:52,030
if it was some big nested expression,

682
00:38:52,030 --> 00:38:55,130
so there would just be deeper recursion on the stack.

683
00:38:55,130 --> 00:38:56,470
But what I want to do now is show you the last piece.

684
00:38:56,470 --> 00:39:01,010
I want to walk you around this eval and apply loop, right?

685
00:39:01,010 --> 00:39:03,000
That's the thing we haven't seen, really.

686
00:39:03,000 --> 00:39:05,200
We haven't seen any compound procedures

687
00:39:05,200 --> 00:39:07,920
where evalutation of procedure reduces to

688
00:39:07,920 --> 00:39:12,250
where applying of procedure reduces to evaluating the body of the procedure,

689
00:39:12,250 --> 00:39:15,810
so let's just suppose we had this.

690
00:39:15,810 --> 00:39:18,070
Suppose we were looking at the procedure

691
00:39:18,070 --> 00:39:33,990
define F of A and B to be the sum of A and B.

692
00:39:33,990 --> 00:39:37,320
So, as we typed in that procedure previously,

693
00:39:37,320 --> 00:39:42,270
and now we're going to evaluate F of X and Y

694
00:39:42,270 --> 00:39:44,200
again, in this environment, E,0,

695
00:39:44,200 --> 00:39:47,280
where X is bound to 3 and Y is bound to 4.

696
00:39:50,650 --> 00:39:53,820
When the defined is executed, remember, there's a lambda here,

697
00:39:53,820 --> 00:39:55,950
and lambdas create procedures.

698
00:39:55,950 --> 00:40:00,810
And, basically, what will happen is, in E,0,

699
00:40:00,810 --> 00:40:03,560
we'll end up with a binding for F,

700
00:40:03,560 --> 00:40:07,150
which will say F is a procedure,

701
00:40:07,150 --> 00:40:16,490
and its args are A and B, and its body is plus a,b.

702
00:40:17,840 --> 00:40:21,050
So that's what the environment would have looked like

703
00:40:21,050 --> 00:40:22,670
had we made that definition.

704
00:40:24,220 --> 00:40:28,600
Then, when we go to evaluate F of X and Y,

705
00:40:28,600 --> 00:40:31,610
we'll go through exactly the same process that we did before.

706
00:40:31,610 --> 00:40:33,090
It's even the same expression.

707
00:40:33,090 --> 00:40:36,030
The only difference is that F, instead of having primitive

708
00:40:36,030 --> 00:40:39,250
"plus" in it, will have this thing.

709
00:40:41,040 --> 00:40:43,600
And so we'll go through exactly the same process,

710
00:40:43,600 --> 00:40:47,860
except this time, when we end up at apply-dispatch,

711
00:40:47,860 --> 00:40:50,280
the function register, instead of having primitive plus,

712
00:40:50,280 --> 00:40:54,300
will have a thing that will represent it saying procedure,

713
00:40:54,300 --> 00:41:06,270
where the args are A and B, and the body is plus A, B.

714
00:41:07,870 --> 00:41:11,090
And, again, what I mean, by its ENV, I mean there's a pointer to it,

715
00:41:11,090 --> 00:41:13,280
so don't worry that I'm writing a lot of stuff there.

716
00:41:13,280 --> 00:41:15,630
There's a pointer to this procedure data structure.

717
00:41:17,170 --> 00:41:20,960
OK, so, we're in exactly the same situation.

718
00:41:20,960 --> 00:41:26,480
We get to apply-dispatch, so, here, we come to apply-dispatch.

719
00:41:26,480 --> 00:41:30,010
Last time, we branched off to a primitive procedure.

720
00:41:30,010 --> 00:41:34,550
Here, it says oh, we now have a compound procedure,

721
00:41:34,550 --> 00:41:36,910
so we're going to go off to compound-apply.

722
00:41:38,470 --> 00:41:40,070
Now, what's compound-apply?

723
00:41:41,920 --> 00:41:45,090
Well, remember what the meta-circular evaluator did?

724
00:41:45,090 --> 00:41:49,900
Compound-apply said we're going to evaluate

725
00:41:49,900 --> 00:41:54,120
the body of the procedure in some new environment.

726
00:41:54,120 --> 00:41:56,730
Where does that new environment come from?

727
00:41:56,730 --> 00:42:01,360
We take the environment that was packaged with the procedure,

728
00:42:03,020 --> 00:42:05,790
we bind the parameters of the procedure

729
00:42:05,790 --> 00:42:09,750
to the arguments that we're passing in,

730
00:42:09,750 --> 00:42:14,990
and use that as a new frame to extend the procedure environment.

731
00:42:14,990 --> 00:42:21,630
And that's the environment in which we evaluate the procedure body, right?

732
00:42:21,630 --> 00:42:24,470
That's going around the apply/eval loop.

733
00:42:24,470 --> 00:42:27,980
That's apply coming back to call eval, all right?

734
00:42:30,910 --> 00:42:32,860
OK.

735
00:42:32,860 --> 00:42:36,780
So, now, that's all we have to do in compound-apply.

736
00:42:36,780 --> 00:42:37,720
What are we going to do?

737
00:42:37,720 --> 00:42:40,970
We're going to manufacture a new environment.

738
00:42:43,550 --> 00:42:46,760
And we're going to manufacture a new environment that,

739
00:42:46,760 --> 00:42:48,310
let's see, that we'll call E,1.

740
00:42:52,900 --> 00:42:57,310
E,1 is going to be some environment where the

741
00:42:57,310 --> 00:43:01,760
where the parameters of the procedure, where A is bound to 3

742
00:43:01,760 --> 00:43:05,760
and B is bound to 4, and it's linked to E,0

743
00:43:05,760 --> 00:43:09,270
because that's where f is defined.

744
00:43:09,270 --> 00:43:12,050
And, in this environment, we're going to evaluate the body of the procedure.

745
00:43:12,050 --> 00:43:13,870
So let's look at that, all right?

746
00:43:16,520 --> 00:43:20,690
All right, here we are at compound-apply, which says

747
00:43:20,690 --> 00:43:24,500
assign to the expression register

748
00:43:24,500 --> 00:43:28,160
the body of the procedure that's in the function register.

749
00:43:28,160 --> 00:43:42,450
So I assign to the expression register the procedure body, OK?

750
00:43:42,450 --> 00:43:45,820
That's going to be evaluated in an environment

751
00:43:45,820 --> 00:43:51,300
which is formed by making some bindings

752
00:43:51,300 --> 00:43:53,670
using information determined by the procedure--

753
00:43:53,670 --> 00:43:55,320
that's what's in FUN--

754
00:43:55,320 --> 00:43:57,800
and the argument list.

755
00:43:57,800 --> 00:44:00,230
And let's not worry about exactly what that does,

756
00:44:00,230 --> 00:44:01,930
but you can see the information's there.

757
00:44:01,930 --> 00:44:05,940
So make bindings will say oh, the procedure, itself,

758
00:44:05,940 --> 00:44:07,950
had an environment attached to it.

759
00:44:07,950 --> 00:44:09,320
I didn't write that quite here.

760
00:44:09,320 --> 00:44:11,300
I should've said in environment

761
00:44:11,300 --> 00:44:13,660
because every procedure gets built with an environment.

762
00:44:13,660 --> 00:44:16,600
So, from that environment, it knows

763
00:44:16,600 --> 00:44:19,290
what the procedure's definition environment is.

764
00:44:19,290 --> 00:44:21,830
It knows what the arguments are.

765
00:44:21,830 --> 00:44:24,280
It looks at argl, and then you see a reversal convention here.

766
00:44:24,280 --> 00:44:27,060
It just has to know that argl is reversed,

767
00:44:27,060 --> 00:44:29,990
and it builds this frame, E,1.

768
00:44:29,990 --> 00:44:33,360
All right, so, let's assume that that's what make bindings returns,

769
00:44:33,360 --> 00:44:36,220
so it assigns to ENV this thing, E,1.

770
00:44:41,490 --> 00:44:46,890
All right, the next thing it says is restore continue.

771
00:44:46,890 --> 00:44:48,760
Remember what continue was here?

772
00:44:48,760 --> 00:44:52,240
It got put up in the last segment.

773
00:44:52,240 --> 00:44:54,020
Continue got stored.

774
00:44:54,020 --> 00:44:56,560
That was the original done, which said what are you going to do

775
00:44:56,560 --> 00:44:59,920
after you're done with this particular application?

776
00:44:59,920 --> 00:45:01,560
It was one of the very first things that happened

777
00:45:01,560 --> 00:45:03,920
when we evaluated the application.

778
00:45:03,920 --> 00:45:06,860
And now, finally, we're going to restore continue.

779
00:45:06,860 --> 00:45:09,290
Remember apply-dispatch's contract.

780
00:45:09,290 --> 00:45:12,030
It assumes that where it should go to next was on the stack,

781
00:45:12,030 --> 00:45:13,590
and there it was on the stack.

782
00:45:13,590 --> 00:45:19,940
Continue has done, and now we're going to go back to eval-dispatch.

783
00:45:19,940 --> 00:45:20,970
We're set up again.

784
00:45:20,970 --> 00:45:25,510
We have an expression, an environment, and a place to go to.

785
00:45:25,510 --> 00:45:29,940
We're not going to go through that because it's sort of the same expression.

786
00:45:35,160 --> 00:45:39,340
OK, but the thing, again, to notice is, at this point,

787
00:45:39,340 --> 00:45:44,830
we have reduced the original expression, F,X,Y, right?

788
00:45:44,830 --> 00:45:48,750
We've reduced evaluating F,X,Y in environment E,0

789
00:45:48,750 --> 00:45:52,670
to evaluate plus A, B in E,1.

790
00:45:52,670 --> 00:45:55,720
And notice, nothing's on the stack, right?

791
00:45:55,720 --> 00:45:56,830
It's a reduction.

792
00:45:56,830 --> 00:46:01,760
At this point, the machine does not contain, as part of its state,

793
00:46:01,760 --> 00:46:05,490
the fact that it's in the middle of evaluating some procedure called f,

794
00:46:05,490 --> 00:46:07,660
that's gone, right?

795
00:46:07,660 --> 00:46:13,070
There's no accumulated state, OK?

796
00:46:13,070 --> 00:46:14,370
Again, that's a very important idea.

797
00:46:14,370 --> 00:46:18,390
That's the meaning of, when we used to write in the substitution model,

798
00:46:18,390 --> 00:46:21,350
this expression reduces to that expression.

799
00:46:21,350 --> 00:46:22,660
And you don't have to remember anything.

800
00:46:22,660 --> 00:46:24,500
And here, you see the meaning of reduction.

801
00:46:24,500 --> 00:46:26,160
At this point, there is nothing on the stack.

802
00:46:31,590 --> 00:46:35,240
See, that has very important consequences.

803
00:46:35,240 --> 00:46:38,320
Let's go back and look at iterative factorial,

804
00:46:40,420 --> 00:46:45,130
all right? Remember, this was some sort of loop and doing iter.

805
00:46:45,130 --> 00:46:49,430
And we kept saying that's an iterative procedure, right?

806
00:46:49,430 --> 00:47:04,660
And what we wrote, remember, are things like, we said,

807
00:47:04,660 --> 00:47:12,360
fact-iter of 5.

808
00:47:12,360 --> 00:47:19,030
We wrote things like reduces to iter of 1, and 1, and 5,

809
00:47:19,030 --> 00:47:25,320
which reduces to iter of 1, and 2, and 5,

810
00:47:25,320 --> 00:47:27,070
and so on, and so on, and so on.

811
00:47:27,070 --> 00:47:28,170
And we kept saying well, look,

812
00:47:28,170 --> 00:47:31,720
you don't have to build up any storage to do that.

813
00:47:31,720 --> 00:47:35,040
And we waved our hands, and said in principle, there's no storage needed.

814
00:47:35,040 --> 00:47:36,170
Now, you see no storage needed.

815
00:47:36,170 --> 00:47:39,090
Each of these is a real reduction, right?

816
00:47:39,090 --> 00:47:42,820
As you walk through these expressions,

817
00:47:47,300 --> 00:47:51,370
As you walk through these expressions, what you'll see

818
00:47:51,370 --> 00:47:53,750
are these expressions on the stack

819
00:47:53,750 --> 00:47:56,420
in some particular environment,

820
00:47:56,420 --> 00:48:00,020
and then these expressions in the EXP register

821
00:48:00,020 --> 00:48:01,570
in some particular environment.

822
00:48:01,570 --> 00:48:04,360
And, at each point, there'll be no accumulated stuff on the stack

823
00:48:04,360 --> 00:48:06,100
because each one's a real reduction, OK?

824
00:48:09,130 --> 00:48:10,580
All right, so, for example,

825
00:48:10,580 --> 00:48:13,460
just to go through it in a little bit more care,

826
00:48:13,460 --> 00:48:17,100
if I start out with an expression that says something like,

827
00:48:17,820 --> 00:48:34,400
oh, say, fact-iter of 5 in some environment

828
00:48:41,900 --> 00:48:46,810
that will, at some point, create an environment

829
00:48:46,810 --> 00:48:48,540
in which n is down to 5.

830
00:48:51,340 --> 00:48:52,590
Let's call that--

831
00:48:55,750 --> 00:49:02,750
And, at some point, the machine will reduce this whole thing

832
00:49:02,750 --> 00:49:07,670
to a thing that says that's really iter

833
00:49:07,670 --> 00:49:15,870
of 1, and 1, and n, evaluated in this environment, E,1

834
00:49:15,870 --> 00:49:17,160
with nothing on the stack.

835
00:49:17,160 --> 00:49:20,710
See, at this moment, the machine is not remembering

836
00:49:20,710 --> 00:49:22,500
that evaluating this expression, iter--

837
00:49:25,000 --> 00:49:29,360
which is the loop-- is part of this thing called iterative factorial.

838
00:49:29,360 --> 00:49:30,590
It's not remembering that.

839
00:49:30,590 --> 00:49:33,170
It's just reducing the expression to that, right?

840
00:49:33,170 --> 00:49:38,050
If we look again at the body of iterative factorial,

841
00:49:38,050 --> 00:49:42,810
this expression has reduced to that expression.

842
00:49:42,810 --> 00:49:44,060
Oh, I shouldn't have the n there.

843
00:49:46,590 --> 00:49:53,340
It's a slightly different convention from the slide to the program, OK?

844
00:49:53,340 --> 00:49:56,120
And, then, what's the body of iter?

845
00:49:56,120 --> 00:49:58,620
Well, iter's going to be an if,

846
00:49:58,620 --> 00:50:00,060
and I won't go through the details of if.

847
00:50:00,060 --> 00:50:02,220
It'll evaluate the predicate.

848
00:50:02,220 --> 00:50:03,810
In this case, it'll be false.

849
00:50:03,810 --> 00:50:09,850
And this iter will now reduce to the expression

850
00:50:09,850 --> 00:50:21,620
iter of whatever it says, star, counter product, and--

851
00:50:21,620 --> 00:50:22,650
what does it say--

852
00:50:22,650 --> 00:50:32,970
plus counter 1 in some other environment, by this time, E,2,

853
00:50:32,970 --> 00:50:43,200
where E,2 will be set up having bindings for product and counter, right?

854
00:50:43,200 --> 00:50:45,140
And it'll reduce to that, right?

855
00:50:45,140 --> 00:50:47,150
It won't be remembering that it's part of

856
00:50:47,150 --> 00:50:49,340
something that it has to return to.

857
00:50:49,340 --> 00:50:53,050
And when iter calls iter again, it'll reduce to another thing that looks like this

858
00:50:53,050 --> 00:50:59,160
in some environment, E,3, which has new bindings for product and counter.

859
00:50:59,160 --> 00:51:08,450
So, if you're wondering, see, if you've always been queasy

860
00:51:08,450 --> 00:51:10,670
about how it is we've been saying those procedures

861
00:51:10,670 --> 00:51:12,450
that look syntactically recursive,

862
00:51:12,450 --> 00:51:18,100
are, in fact, iterative, run in constant space,

863
00:51:18,100 --> 00:51:19,750
well, I don't know if this makes you less queasy,

864
00:51:19,750 --> 00:51:21,230
but at least it shows you what's happening.

865
00:51:21,230 --> 00:51:22,830
There really isn't any buildup there.

866
00:51:25,910 --> 00:51:27,980
Now, you might ask well, is there buildup

867
00:51:27,980 --> 00:51:31,710
in principle in these environment frames?

868
00:51:31,710 --> 00:51:32,370
And the answer is yeah,

869
00:51:32,370 --> 00:51:33,840
you have to make these new environment frames,

870
00:51:33,840 --> 00:51:36,440
but you don't have to hang onto them when you're done.

871
00:51:36,440 --> 00:51:40,720
They can be garbage collected, or the space can be reused automatically.

872
00:51:40,720 --> 00:51:43,250
But you see the control structure of the evaluator

873
00:51:43,250 --> 00:51:47,020
is really using this idea that you actually have a reduction,

874
00:51:47,020 --> 00:51:50,130
so these procedures really are iterative procedures.

875
00:51:50,130 --> 00:51:51,380
All right, let's stop for questions.

876
00:52:02,280 --> 00:52:03,530
All right, let's break.

877
00:52:48,770 --> 00:52:52,770
Let me contrast the iterative procedure

878
00:52:52,770 --> 00:52:56,000
just so you'll see where space does build up with a recursive procedure,

879
00:52:56,000 --> 00:52:58,030
so you can see the difference.

880
00:52:58,030 --> 00:53:02,880
Let's look at the evaluation of recursive factorial, all right?

881
00:53:02,880 --> 00:53:07,220
So, here's fact-recursive, or standard factorial definition.

882
00:53:07,220 --> 00:53:09,910
We said this one is still a recursive procedure,

883
00:53:09,910 --> 00:53:13,750
but this is actually a recursive process.

884
00:53:13,750 --> 00:53:16,560
And then, just to link it back to the way we started,

885
00:53:16,560 --> 00:53:20,530
we said oh, you can see that it's going to be recursive process

886
00:53:20,530 --> 00:53:22,120
by the substitution model

887
00:53:22,120 --> 00:53:30,450
because, if I say recursive factorial of 5,

888
00:53:30,450 --> 00:53:36,000
that turns into 5 times--

889
00:53:36,000 --> 00:53:37,980
what is it, fact-rec, or record fact--

890
00:53:42,620 --> 00:53:54,230
5 times recursive factorial of 4, which turns into 5 times 4

891
00:53:54,230 --> 00:54:08,090
times fact-rec of 3, which returns into 5 times 4 times 3

892
00:54:08,090 --> 00:54:15,240
times, and so on, right?

893
00:54:15,240 --> 00:54:18,100
The idea is there was this chain of stuff building up,

894
00:54:18,100 --> 00:54:21,520
which justified, in the substitution model, the fact that it's recursive.

895
00:54:21,520 --> 00:54:24,180
And now, let's actually see that chain of stuff build up

896
00:54:24,180 --> 00:54:27,460
and where it is in the machine, OK?

897
00:54:27,460 --> 00:54:30,230
All right, well, let's imagine we're going to start out again.

898
00:54:30,230 --> 00:54:41,450
We'll tell it to evaluate recursive factorial of 5

899
00:54:41,450 --> 00:54:45,000
in some environment, again, E,0

900
00:54:45,000 --> 00:54:49,270
where recursive factorial is defined, OK?

901
00:54:49,270 --> 00:54:52,490
Well, now we know what's eventually going to happen.

902
00:54:52,490 --> 00:54:53,920
This is going to come along,

903
00:54:53,920 --> 00:54:57,070
it'll evaluate those things, figure out it's a procedure,

904
00:54:57,070 --> 00:55:00,250
build somewhere over here an environment, E,1,

905
00:55:00,250 --> 00:55:06,720
which has n bound to 5, which hangs off of E,0,

906
00:55:07,800 --> 00:55:10,840
which would be, presumably, the definition environment

907
00:55:10,840 --> 00:55:12,840
of recursive factorial, OK?

908
00:55:14,610 --> 00:55:19,670
And, in this environment, it's going to go off and evaluate the body.

909
00:55:19,670 --> 00:55:27,000
So, again, the evaluation here will reduce to

910
00:55:27,000 --> 00:55:29,950
evaluating the body in E,1.

911
00:55:29,950 --> 00:55:33,530
That's going to look at an if, and I won't go through the details of if.

912
00:55:33,530 --> 00:55:34,880
It'll look at the predicate.

913
00:55:34,880 --> 00:55:37,840
It'll decide it eventually has to evaluate the alternative.

914
00:55:37,840 --> 00:55:41,300
So this whole thing, again, will reduce to

915
00:55:41,300 --> 00:55:47,130
the alternative of recursive factorial, the alternative clause,

916
00:55:47,130 --> 00:55:53,070
which says that this whole thing reduces to times n

917
00:55:53,070 --> 00:56:08,720
of recursive factorial of n minus 1 in the environment E,1, OK?

918
00:56:08,720 --> 00:56:11,200
So the original expression, now, is going to reduce to

919
00:56:11,200 --> 00:56:13,750
evaluating that expression, all right?

920
00:56:13,750 --> 00:56:16,280
Now we have an application.

921
00:56:16,280 --> 00:56:18,220
We did an application before.

922
00:56:18,220 --> 00:56:20,390
Remember what happens in an application?

923
00:56:20,390 --> 00:56:21,970
The first thing you do is you go off and you

924
00:56:21,970 --> 00:56:25,350
save the value of the continue register on the stack.

925
00:56:25,350 --> 00:56:27,360
So the stack here is going to have done in it.

926
00:56:29,980 --> 00:56:35,130
And then you're going to set up to evaluate the sub-parts, OK?

927
00:56:35,130 --> 00:56:37,200
So here we go off to evaluate the sub-parts.

928
00:56:39,370 --> 00:56:41,450
First thing we're going to do is evaluate the operator.

929
00:56:44,490 --> 00:56:47,250
What happens when we evaluate an operator?

930
00:56:47,250 --> 00:56:51,480
Well, we arrange things so that the operator ends up in the expression register.

931
00:56:51,480 --> 00:56:54,630
The environments in the ENV register continue someplace

932
00:56:54,630 --> 00:56:56,590
where we're going to go evaluate the arguments.

933
00:56:56,590 --> 00:56:59,520
And, on the stack, we've saved the original continue,

934
00:56:59,520 --> 00:57:01,720
which is where we wanted to be when we're all done.

935
00:57:01,720 --> 00:57:03,400
And then the things we needed

936
00:57:03,400 --> 00:57:05,800
when we're going to get done evaluating the operator,

937
00:57:05,800 --> 00:57:08,330
the things we'll need to evaluate the arguments, namely,

938
00:57:08,330 --> 00:57:14,000
the environment and those arguments, those unevaluated arguments,

939
00:57:14,000 --> 00:57:15,620
so there they are sitting on the stack.

940
00:57:15,620 --> 00:57:18,370
And we're about to go off to evaluate the operator.

941
00:57:23,130 --> 00:57:26,920
Well, when we return from this particular call--

942
00:57:26,920 --> 00:57:29,380
so we're about to call eval-dispatch here--

943
00:57:29,380 --> 00:57:32,730
when we return from this call, the value of that operator,

944
00:57:32,730 --> 00:57:36,270
which, in this case, is going to be the primitive multiplier procedure,

945
00:57:36,270 --> 00:57:42,800
will end up in the FUN register, all right?

946
00:57:42,800 --> 00:57:44,530
We're going to evaluate some arguments.

947
00:57:44,530 --> 00:57:47,730
They will evaluate n here.

948
00:57:47,730 --> 00:57:50,250
That'll give us 5, in this case.

949
00:57:50,250 --> 00:57:52,900
We're going to put that in the argl register,

950
00:57:52,900 --> 00:57:57,460
and then we'll go off to evaluate the second operand.

951
00:57:57,460 --> 00:58:00,360
So, at the point where we go off to evaluate the second operand--

952
00:58:00,360 --> 00:58:03,630
and I'll skip details like computing, and minus 1, and all of that--

953
00:58:03,630 --> 00:58:06,380
but, when we go off to evaluate the second operand,

954
00:58:06,380 --> 00:58:10,730
that will eventually reduce to another call to fact-recursive.

955
00:58:12,000 --> 00:58:16,520
And, what we've got on the stack here is

956
00:58:16,520 --> 00:58:19,940
the operator from that combination that we're going to use it in

957
00:58:19,940 --> 00:58:23,790
and the other argument, OK?

958
00:58:23,790 --> 00:58:30,200
So, now, we're set up for another call to recursive factorial.

959
00:58:30,200 --> 00:58:31,430
And, when we're done with this one,

960
00:58:31,430 --> 00:58:33,930
we're going to go to accumulate the last arg.

961
00:58:33,930 --> 00:58:35,200
And remember what that'll do?

962
00:58:35,200 --> 00:58:36,420
That'll say oh,

963
00:58:36,420 --> 00:58:39,280
whatever the result of this has to get combined with that,

964
00:58:39,280 --> 00:58:41,690
and we're going to multiply them.

965
00:58:41,690 --> 00:58:45,720
But, notice now, we're at another recursive factorial.

966
00:58:45,720 --> 00:58:49,320
We're about to call eval-dispatch again,

967
00:58:49,320 --> 00:58:53,700
except we haven't really reduced it because there's stuff on the stack now.

968
00:58:53,700 --> 00:58:55,240
The stuff on the stack says oh, when you get back,

969
00:58:55,240 --> 00:58:58,430
you'd better multiply it by the 5 you had hanging there.

970
00:58:58,430 --> 00:59:07,120
So, when we go off to make another call,

971
00:59:07,120 --> 00:59:09,300
we evaluate the n minus 1.

972
00:59:09,300 --> 00:59:11,250
That gives us another environment

973
00:59:11,250 --> 00:59:14,600
in which the new n's going to be down to 4.

974
00:59:14,600 --> 00:59:18,930
And we're about to call eval-dispatch again, right?

975
00:59:18,930 --> 00:59:21,350
We get another call.

976
00:59:21,350 --> 00:59:26,040
That 4 is going to end up in the same situation.

977
00:59:26,040 --> 00:59:30,020
We'll end up with another call to fact-recursive n.

978
00:59:30,020 --> 00:59:32,680
And sitting on the stack will be the stuff from the original one

979
00:59:32,680 --> 00:59:35,360
and, now, the subsidiary one we're doing.

980
00:59:35,360 --> 00:59:36,910
And both of them are waiting for the same thing.

981
00:59:36,910 --> 00:59:40,600
They're going to go to accumulate a last argument.

982
00:59:40,600 --> 00:59:43,250
And then, of course, when we go to the fourth call,

983
00:59:43,250 --> 00:59:45,640
the same thing happens, right?

984
00:59:45,640 --> 00:59:47,300
And this goes on, and on, and on.

985
00:59:47,300 --> 00:59:50,070
And what you see here on the stack,

986
00:59:50,100 --> 00:59:52,220
exactly what's sitting here on the stack,

987
00:59:52,220 --> 00:59:54,960
the thing that says times and 5.

988
00:59:54,960 --> 01:00:00,470
And what you're going to do with that is accumulate that into a last argument.

989
01:00:00,470 --> 01:00:02,760
That's exactly this, right?

990
01:00:02,760 --> 01:00:05,650
This is exactly where that stuff is hanging.

991
01:00:05,650 --> 01:00:11,650
Effectively, the operator you're going to apply,

992
01:00:11,650 --> 01:00:13,620
the other argument

993
01:00:13,670 --> 01:00:15,300
that it's got to be multiplied by when you get back

994
01:00:15,300 --> 01:00:16,870
and the parentheses,

995
01:00:16,870 --> 01:00:19,620
which says yeah, what you wanted to do was accumulate them.

996
01:00:19,620 --> 01:00:22,560
So, you see, the substitution model is not such a lie.

997
01:00:22,560 --> 01:00:27,190
That really is, in some sense, what's sitting right on the stack.

998
01:00:27,190 --> 01:00:29,040
OK.

999
01:00:29,040 --> 01:00:33,260
All right, so that, in some sense, should explain for you,

1000
01:00:33,260 --> 01:00:36,590
or at least convince you, that,

1001
01:00:36,590 --> 01:00:39,870
somehow, this evaluator is managing

1002
01:00:39,870 --> 01:00:42,950
to take these procedures and execute some of them iteratively

1003
01:00:42,950 --> 01:00:46,410
and some of them recursively, even though,

1004
01:00:46,410 --> 01:00:49,210
as syntactically, they look like recursive procedures.

1005
01:00:49,210 --> 01:00:50,660
How's it managing to do that?

1006
01:00:50,660 --> 01:00:53,720
Well, the basic reason it's managing to do that

1007
01:00:53,720 --> 01:01:01,090
is the evaluator is set up to save only what it needs later.

1008
01:01:01,090 --> 01:01:04,670
So, for example, at the point where you've reduced

1009
01:01:04,670 --> 01:01:07,680
evaluating an expression and an environment

1010
01:01:07,680 --> 01:01:10,520
to applying a procedure to some arguments,

1011
01:01:10,520 --> 01:01:13,370
it doesn't need that original environment anymore

1012
01:01:13,370 --> 01:01:17,670
because any environment stuff will be packaged inside the procedures

1013
01:01:17,670 --> 01:01:20,160
where the application's going to happen.

1014
01:01:20,160 --> 01:01:23,650
All right, similarly, when you're going along evaluating an argument list,

1015
01:01:23,650 --> 01:01:25,910
when you've finished evaluating the list,

1016
01:01:25,910 --> 01:01:28,200
when you're finished evaluating the last argument,

1017
01:01:28,200 --> 01:01:31,500
you don't need that argument list any more, right?

1018
01:01:31,500 --> 01:01:32,940
And you don't need the environment where

1019
01:01:32,940 --> 01:01:36,690
those arguments would be evaluated, OK?

1020
01:01:36,690 --> 01:01:40,890
So the basic reason that this interpreter is being so smart

1021
01:01:40,890 --> 01:01:43,050
is that it's not being smart at all, it's being stupid.

1022
01:01:43,050 --> 01:01:46,010
It's just saying I'm only going to save what I really need.

1023
01:01:48,700 --> 01:01:51,000
Well, let me show you here.

1024
01:01:54,880 --> 01:01:58,310
Here's the actual thing that's making a tail recursive.

1025
01:01:58,310 --> 01:02:00,130
Remember, it's the restore of continue.

1026
01:02:00,130 --> 01:02:08,800
It's saying when I go off to evaluate the procedure body,

1027
01:02:08,800 --> 01:02:11,250
I should tell eval to come back to

1028
01:02:11,250 --> 01:02:15,170
the place where that original evaluation was supposed to come back to.

1029
01:02:15,170 --> 01:02:17,700
So, in some sense, you want to say what's the actual line

1030
01:02:17,700 --> 01:02:18,770
that makes a tail recursive?

1031
01:02:18,770 --> 01:02:19,920
It's that one.

1032
01:02:19,920 --> 01:02:23,680
If I wanted to build a non-tail recursive evaluator,

1033
01:02:23,680 --> 01:02:27,120
for some strange reason, all I would need to do is,

1034
01:02:27,120 --> 01:02:32,750
instead of restoring continue at this point, I'd set up a label down here

1035
01:02:32,750 --> 01:02:37,450
called, "Where to come back after you've finished applying the procedure."

1036
01:02:37,450 --> 01:02:39,920
Instead, I'd set continue to that.

1037
01:02:39,920 --> 01:02:41,290
I'd go to eval-dispatch,

1038
01:02:41,290 --> 01:02:43,790
and then eval-dispatch would come back here.

1039
01:02:43,790 --> 01:02:47,920
At that point, I would restore continue and go to the original one.

1040
01:02:47,920 --> 01:02:51,070
So here, the only consequence of that

1041
01:02:51,070 --> 01:02:52,840
would be to make it non-tail recursive.

1042
01:02:52,840 --> 01:02:54,620
It would give you exactly the same answers,

1043
01:02:54,620 --> 01:02:56,650
except if you did that iterative factorial

1044
01:02:56,650 --> 01:02:59,870
and all those iterative procedures, it would execute recursively.

1045
01:03:02,900 --> 01:03:05,760
Well, I lied to you a little bit, but just a little bit,

1046
01:03:05,760 --> 01:03:08,550
because I showed you a slightly over-simplified evaluator

1047
01:03:08,550 --> 01:03:11,220
where it assumes that each procedure --

1048
01:03:11,220 --> 01:03:13,890
each procedure body has only one expression.

1049
01:03:13,890 --> 01:03:17,870
Remember, in general, a procedure has a sequence of expressions in it.

1050
01:03:17,870 --> 01:03:20,490
So there's nothing really conceptually new.

1051
01:03:20,490 --> 01:03:22,720
Let me just show you the actual evaluator

1052
01:03:22,720 --> 01:03:24,730
that handles sequences of expressions.

1053
01:03:28,470 --> 01:03:32,070
This is compound-apply now, and the only difference from the old one

1054
01:03:32,070 --> 01:03:35,980
is that, instead of going off to eval directly,

1055
01:03:35,980 --> 01:03:38,030
it takes the whole body of the procedure,

1056
01:03:38,030 --> 01:03:40,150
which, in this case, is a sequence of expressions,

1057
01:03:40,150 --> 01:03:42,320
and goes off to eval-sequence.

1058
01:03:42,320 --> 01:03:47,900
And eval-sequence is a little loop that, basically,

1059
01:03:47,900 --> 01:03:49,980
does these evaluations one at a time.

1060
01:03:52,630 --> 01:03:53,900
So it does an evaluation.

1061
01:03:53,900 --> 01:03:58,440
Says oh, when I come back, I'd better come back here to do the next one.

1062
01:03:58,440 --> 01:04:01,030
And, when I'm all done, when I want to get the last expression,

1063
01:04:01,030 --> 01:04:06,410
I just restore my continue and go off to eval-dispatch.

1064
01:04:06,410 --> 01:04:08,200
And, again, if you wanted for some reason to

1065
01:04:08,200 --> 01:04:10,490
break tail recursion in this evaluator,

1066
01:04:10,490 --> 01:04:14,900
all you need to do is not handle the last expression, especially.

1067
01:04:14,900 --> 01:04:17,240
Just say, after you've done the last expression,

1068
01:04:17,240 --> 01:04:21,900
come back to some other place after which you restore continue.

1069
01:04:21,900 --> 01:04:26,550
And, for some reason, a lot of LISP evaluators tended to work that way.

1070
01:04:26,550 --> 01:04:28,540
And the only consequence of that is that

1071
01:04:28,540 --> 01:04:31,610
iterative procedures built up stack.

1072
01:04:31,610 --> 01:04:35,670
And it's not clear why that happened.

1073
01:04:35,670 --> 01:04:36,210
All right.

1074
01:04:36,210 --> 01:04:38,090
Well, let me just sort of summarize,

1075
01:04:38,090 --> 01:04:41,120
since this is a lot of details in a big program.

1076
01:04:41,120 --> 01:04:44,040
But the main point is that it's no different,

1077
01:04:44,040 --> 01:04:47,060
conceptually, from translating any other program.

1078
01:04:47,060 --> 01:04:50,150
And the main idea is that we have this universal evaluator program,

1079
01:04:50,150 --> 01:04:51,870
the meta-circular evaluator.

1080
01:04:51,870 --> 01:04:54,560
If we translate that into LISP, then we have all of LISP.

1081
01:04:54,560 --> 01:04:57,980
And that's all we did, OK?

1082
01:04:57,980 --> 01:04:59,680
The second point is that the magic's gone away.

1083
01:04:59,680 --> 01:05:01,970
There should be no more magic in this whole system, right?

1084
01:05:01,970 --> 01:05:08,720
In principle, it should all be very clear except, maybe, for

1085
01:05:08,720 --> 01:05:10,940
how list structured memory works, and

1086
01:05:10,940 --> 01:05:12,640
we'll see that later.

1087
01:05:12,640 --> 01:05:15,450
But that's not very hard.

1088
01:05:15,450 --> 01:05:18,720
The third point is that all this tail recursion came from

1089
01:05:18,720 --> 01:05:22,550
the discipline of eval being very careful

1090
01:05:22,550 --> 01:05:25,870
to save only what it needs next time.

1091
01:05:25,870 --> 01:05:28,180
It's not some arbitrary thing where we're saying well,

1092
01:05:28,180 --> 01:05:29,860
whenever we call a sub-routine,

1093
01:05:29,860 --> 01:05:33,940
we'll save all the registers in the world and come back, right?

1094
01:05:33,940 --> 01:05:37,150
See, sometimes it pays to really worry about efficiency.

1095
01:05:37,150 --> 01:05:40,450
And, when you're down in the guts of your evaluator machine,

1096
01:05:40,450 --> 01:05:42,560
it really pays to think about things like that

1097
01:05:42,560 --> 01:05:45,230
because it makes big consequences.

1098
01:05:45,230 --> 01:05:47,840
Well, I hope what this has done

1099
01:05:47,840 --> 01:05:52,560
is really made the evaluator seem concrete, right?

1100
01:05:52,560 --> 01:05:56,630
I hope you really believe that somebody could hold a LISP

1101
01:05:56,630 --> 01:05:59,070
LISP evaluator in the palm of their hand.

1102
01:05:59,070 --> 01:06:02,540
Maybe to help you believe that, here's a LISP evaluator

1103
01:06:02,540 --> 01:06:06,160
that I'm holding the palm of my hand, right?

1104
01:06:06,160 --> 01:06:10,730
And this is a chip which is actually

1105
01:06:10,730 --> 01:06:13,700
quite a bit more complicated than the evaluator I showed you.

1106
01:06:17,810 --> 01:06:19,200
Maybe, here's a better picture of it.

1107
01:06:22,070 --> 01:06:24,730
What there is, is you can see the same overall structure.

1108
01:06:24,730 --> 01:06:26,940
This is a register array.

1109
01:06:26,940 --> 01:06:27,910
These are the data paths.

1110
01:06:27,910 --> 01:06:29,800
Here's a finite state controller.

1111
01:06:29,800 --> 01:06:32,810
And again, finite state, that's all there is.

1112
01:06:32,810 --> 01:06:34,160
And somewhere there's external memory

1113
01:06:34,160 --> 01:06:35,750
that'll worry about things.

1114
01:06:35,750 --> 01:06:37,550
And this particular one is very complicated

1115
01:06:37,550 --> 01:06:39,660
because it's trying to run LISP fast.

1116
01:06:39,660 --> 01:06:42,970
And it has some very, very fast parallel operations in there

1117
01:06:42,970 --> 01:06:46,650
like, if you want to index into an array,

1118
01:06:46,650 --> 01:06:50,360
simultaneously check that the index is an integer,

1119
01:06:50,360 --> 01:06:52,860
check that it doesn't exceed the array bands,

1120
01:06:52,860 --> 01:06:57,120
and go off and do the memory access, and do all those things simultaneously.

1121
01:06:57,120 --> 01:06:58,970
And then, later, if they're all OK, actually

1122
01:06:58,970 --> 01:07:00,420
get the value there.

1123
01:07:00,420 --> 01:07:02,320
So there are a lot of complicated operations

1124
01:07:02,320 --> 01:07:06,550
in these data paths for making LISP run in parallel.

1125
01:07:06,550 --> 01:07:10,640
It's a completely non-risk philosophy of evaluating LISP.

1126
01:07:10,640 --> 01:07:13,740
And then, this microcode is pretty complicated.

1127
01:07:13,740 --> 01:07:17,740
Let's see, there's what?

1128
01:07:17,740 --> 01:07:24,070
There's about 389 instructions of 220-bit microcode sitting here

1129
01:07:24,070 --> 01:07:27,940
because these are very complicated data paths.

1130
01:07:27,940 --> 01:07:33,580
And the whole thing has about 89,000 transistors, OK?

1131
01:07:33,580 --> 01:07:33,840
OK.

1132
01:07:33,840 --> 01:07:37,970
Well, I hope that that takes away a lot of the mystery.

1133
01:07:37,970 --> 01:07:39,240
Maybe somebody wants to look at this.

1134
01:07:42,040 --> 01:07:43,290
Yeah.

1135
01:07:46,260 --> 01:07:46,480
OK.

1136
01:07:46,480 --> 01:07:47,730
Let's stop.

1137
01:07:55,890 --> 01:07:57,810
Questions?

1138
01:07:57,810 --> 01:08:00,420
AUDIENCE: OK, now, it sounds like what you're saying is that,

1139
01:08:00,420 --> 01:08:04,600
with the restore continue put in the proper place, that

1140
01:08:04,600 --> 01:08:09,420
procedures that would invoke a recursive process

1141
01:08:09,420 --> 01:08:12,670
now invoke an integer process

1142
01:08:12,670 --> 01:08:15,160
just by the way that the eval signature is?

1143
01:08:15,160 --> 01:08:17,540
PROFESSOR: I think the way I'd prefer to put it is that,

1144
01:08:17,540 --> 01:08:20,550
with restore continue put in the wrong place,

1145
01:08:20,550 --> 01:08:25,880
you can cause any syntactically-looking recursive procedure, in fact,

1146
01:08:25,880 --> 01:08:28,020
to build up stack as it runs.

1147
01:08:28,020 --> 01:08:33,150
But there's no reason for that,

1148
01:08:33,150 --> 01:08:35,660
so you might want to play around with it.

1149
01:08:35,660 --> 01:08:38,180
You can just switch around two or three instructions

1150
01:08:38,180 --> 01:08:41,120
in the way compound-apply comes back,

1151
01:08:41,120 --> 01:08:45,060
and you'll get something which isn't tail recursive.

1152
01:08:45,060 --> 01:08:47,670
But the thing I wanted to emphasize is there's no magic.

1153
01:08:47,670 --> 01:08:52,450
It's not as if there's some very clever pre-processing program

1154
01:08:52,450 --> 01:08:57,420
that's looking at this procedure, factorial iter, and say oh, gee,

1155
01:08:57,420 --> 01:09:01,060
I really notice that I don't have to push stack in order to do this.

1156
01:09:01,060 --> 01:09:03,760
Some people think that that's what's going on.

1157
01:09:03,760 --> 01:09:05,380
It's something much, much more dumb than that,

1158
01:09:05,380 --> 01:09:08,880
it's this one place you're putting the restore instruction.

1159
01:09:08,880 --> 01:09:10,350
It's just automatic.

1160
01:09:10,350 --> 01:09:11,600
AUDIENCE: OK.

1161
01:09:14,210 --> 01:09:17,850
AUDIENCE: But that's not affecting the time complexity is it?

1162
01:09:17,850 --> 01:09:18,270
PROFESSOR: No.

1163
01:09:18,270 --> 01:09:21,810
AUDIENCE: It's just that it's handling it recursively

1164
01:09:21,810 --> 01:09:23,020
instead of iteratively.

1165
01:09:23,020 --> 01:09:27,170
But, in terms of the order of time it takes to finish the operation,

1166
01:09:27,170 --> 01:09:29,220
it's the same one way or the other, right?

1167
01:09:29,220 --> 01:09:29,920
PROFESSOR: Yes.

1168
01:09:29,920 --> 01:09:32,600
Tail recursion is not going to change the time complexity of anything

1169
01:09:32,600 --> 01:09:36,020
because, in some sense, it's the same algorithm that's going on.

1170
01:09:36,020 --> 01:09:41,210
What it's doing is really making this thing run as an iteration, right?

1171
01:09:41,210 --> 01:09:44,750
Not going to run out of memory counting up to a giant number

1172
01:09:44,750 --> 01:09:47,680
simply because the stack would get pushed.

1173
01:09:47,680 --> 01:09:51,640
See, the thing you really have to believe is that, when we write--

1174
01:09:51,640 --> 01:09:53,780
see, we've been writing all these things called iterations,

1175
01:09:53,780 --> 01:09:57,990
infinite loops, define loop to be called loop.

1176
01:10:00,320 --> 01:10:03,650
That's is as much an iteration

1177
01:10:03,650 --> 01:10:07,630
as if we wrote do forever loop, right?

1178
01:10:07,630 --> 01:10:09,280
It's just syntactic sugar as the difference.

1179
01:10:09,280 --> 01:10:14,730
These things are real, honest to god, iterations, right?

1180
01:10:14,730 --> 01:10:16,680
They don't change the time complexity, but they

1181
01:10:16,680 --> 01:10:18,530
turn them into real iterations.

1182
01:10:21,680 --> 01:10:23,800
All right, thank you.

