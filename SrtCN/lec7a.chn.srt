1
00:00:15,314 --> 00:00:18,410
今天我们学习一些非同一般的东西

2
00:00:18,410 --> 00:00:26,800
我们借助一些程序来理解更为深刻的理论

3
00:00:26,800 --> 00:00:32,729
到目前为止，我们一直把程序看作可描述的机器

4
00:00:32,729 --> 00:00:42,800
举个例子，这个幻灯片上有一个计算阶乘的程序

5
00:00:42,800 --> 00:00:52,230
它不过就是一连串字符串描述的东西，如果想的话，你也可以用可能无限递归的机器的布线图来表示

6
00:00:52,230 --> 00:00:55,130
我们只消看一点就明白程序是怎么回事

7
00:00:55,130 --> 00:01:00,170
这种记法很简洁，这句描述的是，如果n是0，结果就是1

8
00:01:00,170 --> 00:01:09,340
这里n输入机器，如果是0，就控制这个开关转到输出为1的方向

9
00:01:09,340 --> 00:01:12,970
否则，开关就转到输出为 n乘以n-1的阶乘 的方向

10
00:01:12,970 --> 00:01:21,900
下面计算的是n乘以n-1的阶乘，当n不是0的时候，开关就转到这个方向，输出这部分的计算

11
00:01:21,900 --> 00:01:31,070
当然，这个机器可能是有无数个部件，因为factorial内部又调用了factorial，因此我们也不知道递归的深度是多少

12
00:01:31,070 --> 00:01:38,310
这就是程序的记法所告诉我们的

13
00:01:38,310 --> 00:01:44,900
字符串可以描述程序，如果你想，用布线图表示也是可以的

14
00:01:44,900 --> 00:01:49,490
事实上，很多人都对我说过，说编程语言和这种图形很相似

15
00:01:49,490 --> 00:01:51,500
不过我不认为用图形表示会有很多优势

16
00:01:51,500 --> 00:02:01,090
一个缺点就是表示出来需要占用很大的平面空间，所以就很难一次性表示很大的程序，而且编辑修改起来也不方便

17
00:02:01,090 --> 00:02:10,450
但是不管怎样，有一个叫做“通用机”的机器还是很值得我们注意的

18
00:02:10,450 --> 00:02:21,260
我们再来看第二张幻灯片，这个特殊的机器名为eval

19
00:02:21,260 --> 00:02:25,720
这个eval也就是今天要讲的

20
00:02:25,720 --> 00:02:27,780
它非常简单

21
00:02:27,780 --> 00:02:30,490
甚至在黑板这么小的空间里都能把它写出来

22
00:02:33,350 --> 00:02:40,450
要注意的是，eval的输入比较特殊，它以对其它机器的描述作为输入

23
00:02:40,450 --> 00:02:46,490
这里它以一个计算阶乘的机器的布线图描述作为输入

24
00:02:46,490 --> 00:02:58,910
这样一来，eval变成了计算阶乘机器的模拟器，对eval输入6，得到阶乘结果720

25
00:02:58,910 --> 00:03:02,130
这种机器非同一般

26
00:03:02,130 --> 00:03:05,590
最让人吃惊的是只消在黑板这么小的空间内就可以描述完它

27
00:03:05,590 --> 00:03:28,050
我们可以类比着来看，假设在现实里的模拟电路中，有这样一种通用的机器，它以电路设计图纸为输入，像是低通滤波器、 单极点低通滤波器之类的  

28
00:03:28,050 --> 00:03:49,890
你可以这样想像，用这个机器进行扫描输出 -- 扫描线应该可以描述出通用机在模拟的这个机器 -- 使用响应特定频率的滤波电路图的通用机模拟的效果应该和真实的滤波器达到的效果一样

29
00:03:49,890 --> 00:03:55,670
这种机器很难制造出来，我肯定也不能只在黑板这么大的空间就具体的表述出它

30
00:03:55,670 --> 00:03:58,430
所以说，今天是我们见证奇迹的时刻

31
00:03:58,430 --> 00:04:02,790
我们将会见证，在黑板上，我就可以“制造”出通用机

32
00:04:02,790 --> 00:04:06,780
除了部分事情以外，它其实非常简单

33
00:04:06,780 --> 00:04:11,280
我们也逐渐触碰到活在计算机中真正的神灵

34
00:04:11,280 --> 00:04:20,470
这里务必要保持足够的尊敬，所以我特地穿上西服外套，你们应该从没见我穿过

35
00:04:20,470 --> 00:04:26,980
我想我还得戴上一顶合适的帽子

36
00:04:28,780 --> 00:04:40,370
开讲前再给大家提个醒 -- 40岁以下以及还没有几个孩子的人要小心了

37
00:04:40,370 --> 00:04:51,820
如果你真的受不了，可以选择离开 因为一会儿要发生的事情非常神秘，可能使你的思想异常混乱

38
00:04:51,820 --> 00:05:02,510
好了，无论如何，我还是要向你们写一下Lisp的求值程序

39
00:05:02,510 --> 00:05:05,020
求值程序并不复杂

40
00:05:05,020 --> 00:05:08,240
很像我们以前见到过的程序

41
00:05:08,240 --> 00:05:10,860
这也是它令人吃惊的地方

42
00:05:10,860 --> 00:05:16,620
现在我开始写这个程序，叫做eval

43
00:05:22,900 --> 00:05:30,030
它是一个接受两个参数的过程，exp是表达式，env是表达式执行的环境

44
00:05:31,860 --> 00:05:34,940
和很多有趣的过程一样，过程内部按情况分析

45
00:05:40,460 --> 00:05:44,210
但是在我开始之前，我还想告诉你们一些其它的

46
00:05:44,210 --> 00:05:54,210
这里的这个程序非常丑陋、混乱、令人作呕，并不是一种专业的写法

47
00:05:54,210 --> 00:06:02,550
它用具体的语法写就，也就是说我们用很多CAR CDR之类，我之前告诉过你们这样写并不好

48
00:06:02,550 --> 00:06:12,420
在这里是故意这样来写的，因为我想使其娇小，简洁，达到可以写在黑板上的规模

49
00:06:12,420 --> 00:06:15,800
我就不像平时那样使用很多很长的命名了

50
00:06:15,800 --> 00:06:19,580
就用CAR CDR，很简洁

51
00:06:19,580 --> 00:06:20,950
这算是一种权衡

52
00:06:20,950 --> 00:06:23,570
我不希望你们这样来写程序

53
00:06:23,570 --> 00:06:26,090
这里单纯地想达到一种简洁的效果

54
00:06:26,090 --> 00:06:31,270
因此你们读起来可能有些费力，我尽量写的清楚

55
00:06:31,270 --> 00:06:51,670
这个求值器比较完整，但是并不完全，我就不写define和assignment的部分了，不是它们不重要，而是出于一些数学上的原因，再说黑板地方也不大

56
00:06:51,670 --> 00:06:54,170
但是，我们怎么做呢？

57
00:06:54,170 --> 00:07:02,030
这里需要做一个分配，把表达式分类

58
00:07:02,030 --> 00:07:03,525
这就是现在要做的

59
00:07:03,525 --> 00:07:05,150
这里的表达式应该是什么？

60
00:07:05,150 --> 00:07:06,810
我们先来看几种表达式

61
00:07:06,810 --> 00:07:10,420
表达式数字3

62
00:07:10,420 --> 00:07:12,720
要怎么做？

63
00:07:12,720 --> 00:07:17,050
我有很多选择，但是我马上想到，它就应该是数字3

64
00:07:17,050 --> 00:07:18,860
这就是我要的

65
00:07:18,860 --> 00:07:19,800
这个足够简单

66
00:07:19,800 --> 00:07:31,970
那就意味着，如果表达式是数字，表达式本身就应该是求值结果

67
00:07:35,420 --> 00:07:39,390
表达式还可能是符号

68
00:07:39,390 --> 00:07:47,614
比如x n eval number之类

69
00:07:47,614 --> 00:07:49,630
它们意味着什么？

70
00:07:49,630 --> 00:07:51,690
它们是一类代表其它事物的事物

71
00:07:51,690 --> 00:07:54,770
也就是我们语言中所谓的变量

72
00:07:54,770 --> 00:08:02,930
因此，假如这有一个x，求值结果应该是它代表的那个值，我随便写一个3

73
00:08:02,930 --> 00:08:07,920
又假如符号是car

74
00:08:07,920 --> 00:08:23,100
这时候来求值，结果应该是一个过程，具体内部可能是机器码或是别的，不过这里我们并不需要关心

75
00:08:23,100 --> 00:08:24,430
到这是还是相对简单的

76
00:08:24,430 --> 00:08:27,890
我还是想把符号求值的具体部分交给别人来写

77
00:08:27,890 --> 00:08:40,159
假如表达式是符号，就执行(lookup exp env)，得到表达式在当前环境的结果

78
00:08:46,480 --> 00:08:54,060
这里的环境就相当于一本字典，根据符号名字就可以查找到相应的值

79
00:08:54,060 --> 00:08:56,280
就这么简单

80
00:08:56,280 --> 00:08:57,530
env在这里到底是什么？

81
00:08:57,530 --> 00:08:59,760
稍后我们再谈这个

82
00:08:59,760 --> 00:09:01,670
其实并不难

83
00:09:01,670 --> 00:09:04,670
就是一个融合了多种排序的表结构

84
00:09:04,670 --> 00:09:10,040
可以简单理解为它就是一个表，lookup过程可以查找这个表

85
00:09:10,040 --> 00:09:17,430
好的，接下来，下一种可能 -- 表达式可能是一些不是数字的常数，比如'foo

86
00:09:20,170 --> 00:09:31,520
这里方便起见，我把它转化为语法上等同的形式(quote foo)

87
00:09:35,140 --> 00:09:48,780
求值器并不处理引号，一个被引的表达式，无论它是什么，都是一个缩写，像是(quote foo)这种形式的缩写

88
00:09:48,780 --> 00:09:55,615
这样我就可以依据表达式的car来判断表达式的类型了

89
00:09:58,460 --> 00:10:01,650
因此这一部分也不难写

90
00:10:01,650 --> 00:10:05,540
It's happening somewhere earlier in the reader or something.

91
00:10:05,540 --> 00:10:25,140
如果表达式被引，求值结果是，这里(quote foo)的求值结果应该是foo自身

92
00:10:25,140 --> 00:10:27,530
一个常量

93
00:10:27,530 --> 00:10:30,645
也就是说求值结果是它自身

94
00:10:33,150 --> 00:10:33,660
该怎么来写呢？

95
00:10:33,660 --> 00:10:51,290
也就是列表的第二个部分了，应该是列表的CADR，所以这里我就写CADR

96
00:10:51,290 --> 00:10:52,510
表达式还可能是什么类型呢？

97
00:10:52,510 --> 00:11:04,160
还有lambda表达式，比如，(lambda (x) (+ x y))

98
00:11:04,160 --> 00:11:09,600
这样的话，我就必须得有方法来表示过程，也就是lambda求值的结果

99
00:11:09,600 --> 00:11:13,030
过程并不是lambda (x)表达式

100
00:11:13,030 --> 00:11:16,170
表达式只是对过程的文字描述

101
00:11:16,170 --> 00:11:27,360
相对地，我更希望执行过程的时候还要考虑环境的因素

102
00:11:27,360 --> 00:11:30,790
所以这里我们需要一些类型标志

103
00:11:30,790 --> 00:11:39,060
因为之后我们要凭借标志来区分哪些是过程，即lambda和一些原子元素求值的结果

104
00:11:39,060 --> 00:11:44,935
这里考虑历史因素，我就用closure作为类型标志

105
00:11:47,760 --> 00:11:49,920
现在来看看，哪些部分必不可少

106
00:11:49,920 --> 00:11:54,220
我需要形参列表和过程体

107
00:11:54,220 --> 00:12:03,795
也就是lambda的CDR，最后还有执行环境env

108
00:12:08,170 --> 00:12:18,520
单纯的语言使用者肯定没见过像这样的，它只是内部对过程对象的一种表示方法吧

109
00:12:18,520 --> 00:12:26,340
它包含了形参列表，过程体，执行环境，和表示自身为过程类型的标志

110
00:12:26,340 --> 00:12:28,080
接下来写代码

111
00:12:28,080 --> 00:13:10,250
如果表达式的CAR是'lambda，求值结果就是(list 'closure (cdr exp) env)

112
00:13:10,250 --> 00:13:15,190
这样就实现了环境模型中的那些规则

113
00:13:15,190 --> 00:13:19,210
对于从lambda构建一个过程是必不可少的

114
00:13:19,210 --> 00:13:32,240
而且closure里的这个环境就是过程真正执行的时候查找自由变量的地方

115
00:13:34,720 --> 00:13:35,920
所以这里应该有环境env

116
00:13:35,920 --> 00:13:39,210
必须把环境作为过程对象的一部分

117
00:13:39,210 --> 00:13:41,750
之后我们再来细看环境在其中的作用

118
00:13:41,750 --> 00:13:54,520
下一种情况，条件表达式，(cond (p1 e1) (p2 e2) ...)

119
00:13:54,520 --> 00:14:03,480
p是谓词，谓词求值结果非真即假，e是表达式，只有在谓词为真的时候才被求值

120
00:14:03,480 --> 00:14:06,790
如果不介意，我暂时称其为一组子句

121
00:14:06,790 --> 00:14:09,360
具体的求值过程写在别的地方

122
00:14:09,360 --> 00:14:12,420
让别人来考虑具体求值的部分

123
00:14:12,420 --> 00:14:32,050
这里继续写，如果(car exp)是'cond，然后就求值(cdr exp)

124
00:14:34,080 --> 00:14:38,380
记得带上环境

125
00:14:41,430 --> 00:14:56,590
好的，还有一种情况，比如(+ x 3)，一个操作符应用于操作数，它并不特殊

126
00:14:56,590 --> 00:14:59,850
就是说，它不属于这里的特殊形式

127
00:14:59,850 --> 00:15:09,650
上面写的这些都是特殊形式

128
00:15:09,650 --> 00:15:14,370
还是再提一下，如果这里用数据导向的方式来写，会更加的专业

129
00:15:14,370 --> 00:15:22,360
那样的话这里就不会是一系列的条件判断，数据导向会把这种按条件分配的过程表示的更为优雅

130
00:15:22,360 --> 00:15:26,710
并且，我还可以在不改动代码的情况下添加新的条件判断

131
00:15:26,710 --> 00:15:31,280
也可能那样会执行的更快，虽然有很多优势，这里我并不考虑那样来写

132
00:15:31,280 --> 00:15:34,890
现在的目的是把握eval过程的全局

133
00:15:34,890 --> 00:15:37,360
好吧，接着写

134
00:15:37,360 --> 00:15:38,560
要怎么做呢？

135
00:15:38,560 --> 00:15:40,965
这个(+ x 3)的例子里，我得做加法

136
00:15:44,350 --> 00:15:46,565
那样的话我就得清楚 + 到底是什么

137
00:15:46,565 --> 00:15:50,550
接着弄清楚 x 和 3 是什么

138
00:15:50,550 --> 00:15:58,020
然后再把 + 的结果应用于 x 与 3 的结果

139
00:15:58,020 --> 00:15:59,830
具体来写一下

140
00:15:59,830 --> 00:16:20,480
(apply (eval (car exp) env)，(car exp)就是操作符的部分

141
00:16:20,480 --> 00:16:24,050
执行(eval (car exp) env)就得到操作符的结果

142
00:16:24,050 --> 00:16:27,290
我还得求值操作数来得到具体参数

143
00:16:27,290 --> 00:16:38,835
执行evlist来求值操作数

144
00:16:41,940 --> 00:16:48,070
(evlist (cdr exp) env)，这个evlist稍后细讲

145
00:16:50,900 --> 00:16:56,590
你现在看到的就是一个完整的求值器

146
00:16:56,590 --> 00:17:07,470
它针对表达式的类型分情况处理，表达式可以是一个完整的程序或者简单表达式的组合

147
00:17:17,520 --> 00:17:20,089
不过我们还有些过程没有被定义

148
00:17:20,089 --> 00:17:21,780
接下来就看这些未定义的部分

149
00:17:21,780 --> 00:17:25,480
evcond稍后再说

150
00:17:25,480 --> 00:17:27,579
我得定义apply

151
00:17:27,579 --> 00:17:31,790
还有evlist，lookup

152
00:17:31,790 --> 00:17:33,430
我看看，没别的了吧？

153
00:17:33,430 --> 00:17:38,570
剩下的就是一些简单基本的东西了

154
00:17:38,570 --> 00:17:44,450
当然，这里可以写很多特殊形式，但是对于一个语言来说无疑很糟糕

155
00:17:44,450 --> 00:17:47,690
那会让语言变得很复杂

156
00:17:47,690 --> 00:17:54,010
保留字就不该比你能记住几个手指脚指的数目还多

157
00:17:54,010 --> 00:17:59,410
看到有些语言的保留字有上百个，我都不知道该说什么

158
00:17:59,410 --> 00:18:00,710
特殊形式也就是所谓定义保留字的地方

159
00:18:04,750 --> 00:18:09,640
好的，接下来，我们来看第二个核心的部分，apply

160
00:18:09,640 --> 00:18:11,590
What else is this doing?

161
00:18:11,590 --> 00:18:26,610
Well, apply's job is to take a procedure and apply it to its arguments after both have been evaluated to come up with a procedure and the arguments rather the operator symbols and the operand symbols, whatever they are-- symbolic expressions.

162
00:18:33,270 --> 00:18:43,280
So we will define apply to be a procedure of two arguments, a procedure and arguments.

163
00:18:47,110 --> 00:18:48,080
And what does it do?

164
00:18:48,080 --> 00:18:49,720
It does nothing very complicated.

165
00:18:49,720 --> 00:18:50,970
It's got two cases.

166
00:18:53,580 --> 00:19:06,930
Either the procedure is primitive--  And I don't know exactly how that is done.

167
00:19:06,930 --> 00:19:18,550
It's possible there's some type information just like we made closure for, here, being the description of the type of a compound thing-- probably so.

168
00:19:18,550 --> 00:19:27,350
But it is not essential how that works, and, in fact, it turns out, as you probably know or have deduced, that you don't need any primitives anyway.

169
00:19:27,350 --> 00:19:33,190
You can compute anything without them because some of the lambda that I've been playing with.

170
00:19:33,190 --> 00:19:34,750
But it's nice to have them.

171
00:19:34,750 --> 00:19:38,060
So here we're going to do some magic which I'm not going to explain.

172
00:19:38,060 --> 00:19:42,860
Go to machine language, apply primop.

173
00:19:42,860 --> 00:19:44,850
Here's how it adds.

174
00:19:44,850 --> 00:19:46,100
Execute an add instruction.

175
00:19:50,360 --> 00:19:54,940
However, the interesting part of a language is the glue by which the predicates are glued together.

176
00:19:54,940 --> 00:19:56,910
So let's look at that.

177
00:19:56,910 --> 00:20:07,620
Well, the other possibility is that this is a compound made up by executing a lambda expression, this is a compound procedure.

178
00:20:07,620 --> 00:20:10,110
Well, we'll check its type.

179
00:20:10,110 --> 00:20:24,500
If it is closure, if it's one of those, then I have to do an eval of the body.

180
00:20:24,500 --> 00:20:44,260
The way I do this, the way I deal with this at all, is the way I evaluate the application of a procedure to its arguments, is by evaluating the body of the procedure in the environment resulting from extending the environment of the procedure with the bindings of the formal parameters of the procedure to the arguments that were passed to it.

181
00:20:47,030 --> 00:20:48,280
That was a long sentence.

182
00:20:51,130 --> 00:20:52,822
Well that's easy enough.

183
00:20:52,822 --> 00:20:56,214
Now here's going to be a lot of CAR-CDRing.

184
00:20:56,214 --> 00:20:59,400
I have to get the body of the procedure.

185
00:20:59,400 --> 00:21:02,960
Where's the body of the procedure in here?

186
00:21:02,960 --> 00:21:06,130
Well here's the CAR, here's the CDR is the whole rest of this.

187
00:21:06,130 --> 00:21:13,200
So here's the CADR. And so I see, what I have here is the body is the second element of the second element of the procedure.

188
00:21:13,200 --> 00:21:19,170
So it's the CADR of the CADR or the CADADR.

189
00:21:19,170 --> 00:21:27,495
It's the C-A-D-A-D-R, CADADR of the procedure.

190
00:21:30,260 --> 00:21:43,500
To evaluate the body in the result of binding that's making up more environment, well I need the formal parameters of the of the procedure, what is that?

191
00:21:43,500 --> 00:21:48,780
That's the CAR of the CDR. It's horrible isn't it?

192
00:21:52,440 --> 00:21:55,440
--of the procedure.

193
00:21:55,440 --> 00:22:04,540
Bind that to the arguments that were passed in the environment, which is passed also as part of the procedure.

194
00:22:04,540 --> 00:22:16,315
Well, that's the CAR of the CDR of the CDR of this, CADDR, of the procedure.

195
00:22:20,290 --> 00:22:39,000
Bind, eval, pair, COND, lamda, define-- Now, of course, if I were being really a neat character, and I was being very careful, I would actually put an extra case here for checking for certain errors like, did you try to apply one to an argument?

196
00:22:39,000 --> 00:22:42,570
You get a undefined procedure type.

197
00:22:42,570 --> 00:22:45,500
So I may as well do that anyway.

198
00:22:45,500 --> 00:22:57,610
--else, some sort of error, like that.

199
00:22:57,610 --> 00:23:10,750
Now, of course, again, in some sort of more real system, written for professional reasons, this would be written with a case analysis done by some sort of dispatch.

200
00:23:10,750 --> 00:23:16,220
Over here, I would probably have other cases like, is this compiled code?

201
00:23:16,220 --> 00:23:17,020
It's very important.

202
00:23:17,020 --> 00:23:25,880
I might have distinguished the kind of code that's produced by a directly evaluating a lambda in interpretation from code that was produced by somebody's compiler or something like that.

203
00:23:25,880 --> 00:23:27,230
And we'll talk about that later.

204
00:23:27,230 --> 00:23:30,510
Or is this a piece Fortran program I have to go off and execute.

205
00:23:30,510 --> 00:23:32,920
It's a perfectly possible thing, at this point, to do that.

206
00:23:32,920 --> 00:23:44,360
In fact, in this concrete syntax evaluator I'm writing here, there's an assumption built in that this is Lisp, because I'm using CARs and CDRs.

207
00:23:44,360 --> 00:23:46,750
CAR means the operator, and CDR means the operand.

208
00:23:46,750 --> 00:23:56,160
In the text, there is an abstract syntax evaluator for which these could be-- these are given abstract names like operator, and operand, and all these other things are like that.

209
00:23:56,160 --> 00:24:01,570
And, in that case, you could reprogram it to be ALGOL with no problem.

210
00:24:03,760 --> 00:24:08,660
Well, here we have added another couple of things that we haven't defined.

211
00:24:10,810 --> 00:24:15,050
I don't think I'll worry about these at all, however, this one will be interesting later.

212
00:24:17,930 --> 00:24:20,550
Let's just proceed through this and get it done.

213
00:24:20,550 --> 00:24:23,060
There's only two more blackboards so it can't be very long.

214
00:24:27,056 --> 00:24:30,070
It's carefully tailored to exactly fit.

215
00:24:30,070 --> 00:24:30,980
Well, what do we have left?

216
00:24:30,980 --> 00:24:33,730
We have to define EVLIST, which is over here.

217
00:24:33,730 --> 00:24:44,240
And EVLIST is nothing more than a map down a bunch of operands producing arguments.

218
00:24:44,240 --> 00:24:45,820
But I'm going to write it out.

219
00:24:45,820 --> 00:24:53,610
And one of the reasons I'm going to write this out is for a mystical reason, which is I want to make this evaluator so simple that it can understand itself.

220
00:24:56,450 --> 00:25:00,230
I'm going to really worry about that a little bit.

221
00:25:00,230 --> 00:25:02,850
So let's write it out completely.

222
00:25:02,850 --> 00:25:06,080
See, I don't want to worry about whether or not the thing can pass functional arguments.

223
00:25:06,080 --> 00:25:08,980
The value evaluator is not going to use them.

224
00:25:08,980 --> 00:25:10,880
The evaluator is not going to produce functional values.

225
00:25:10,880 --> 00:25:24,070
So even if there were a different, alternative language that were very close to this, this evaluates a complex language like Scheme which does allow procedural arguments, procedural values, and procedural data.

226
00:25:24,070 --> 00:25:31,580
But even if I were evaluating ALGOL, which doesn't allow procedural values, I could use this evaluator.

227
00:25:31,580 --> 00:25:34,050
And this evaluator is not making any assumptions about that.

228
00:25:34,050 --> 00:25:40,640
And, in fact, if this value were to be restricted to not being able to that, it wouldn't matter, because it doesn't use any of those clever things.

229
00:25:40,640 --> 00:25:44,070
So that's why I'm arranging this to be super simple.

230
00:25:44,070 --> 00:25:47,810
This is sort of the kernel of all possible language evaluators.

231
00:25:47,810 --> 00:25:49,420
How about that?

232
00:25:49,420 --> 00:25:53,820
Evlist--  well, what is it?

233
00:25:53,820 --> 00:26:33,260
It's the procedure of two arguments, l and an environment, where l is a list such that if the list of arguments is the empty list, then the result is the empty list. Otherwise, I want to cons up the result of evaluating the CAR of the list of operands in the environment.

234
00:26:33,260 --> 00:26:50,130
So I want the first operand evaluated, and I'm going to make a list of the results by CONSing that onto the result of this EVLISTing as a CDR recursion, the CDR of the list relative to the same environment.

235
00:26:53,350 --> 00:27:03,620
Evlist, cons, else, COND, lambda, define--  And I have one more that I want to put on the blackboard.

236
00:27:03,620 --> 00:27:05,470
It's the essence of this whole thing.

237
00:27:05,470 --> 00:27:08,130
And there's some sort of next layer down.

238
00:27:14,540 --> 00:27:18,880
Conditionals-- conditionals are the only thing left that are sort of substantial.

239
00:27:18,880 --> 00:27:25,530
Then below that, we have to worry about things like lookup and bind, and we'll look at that in a second.

240
00:27:25,530 --> 00:27:31,600
But of the substantial stuff at this level of detail, next important thing is how you deal with conditionals.

241
00:27:31,600 --> 00:27:33,330
Well, how do we have a conditional thing?

242
00:27:37,670 --> 00:27:44,720
It's a procedure of a set of clauses and an environment.

243
00:27:47,340 --> 00:27:49,820
And what does it do?

244
00:27:49,820 --> 00:28:04,520
It says, if I've no more clauses, well, I have to give this a value.

245
00:28:04,520 --> 00:28:06,540
It could be that it was an error.

246
00:28:06,540 --> 00:28:10,060
Supposing it run off the end of a conditional, it's pretty arbitrary.

247
00:28:10,060 --> 00:28:13,650
It's up to me as programmer to choose what I want to happen.

248
00:28:13,650 --> 00:28:20,100
It's convenient for me, right now, to write down that this has a value which is the empty list, doesn't matter.

249
00:28:20,100 --> 00:28:23,110
For error checking, some people might prefer something else.

250
00:28:23,110 --> 00:28:25,570
But the interesting things are the following ones.

251
00:28:25,570 --> 00:28:40,265
If I've got an else clause--  You see, if I have a list of clauses, then each clause is a list. And so the predicate part is the CAAR of the clauses.

252
00:28:43,560 --> 00:28:51,090
It's the CAR, which is the first part of the first clause in the list of clauses.

253
00:28:51,090 --> 00:28:59,800
If it's an else, then it means I want my result of the conditional to be the result of evaluating the matching expression.

254
00:28:59,800 --> 00:29:22,195
So I eval the CADR. So this is the first clause, the second element of it, CADAR-- CADAR of a CAR-- of the clauses, with respect to the environment.

255
00:29:26,620 --> 00:29:29,630
Now the next possibility is more interesting.

256
00:29:29,630 --> 00:29:44,360
If it's false, if the first predicate in the predicate list is not an else, and it's not false, if it's not the word else, and if it's not a false thing-- Let's write down what it is if it's a false thing.

257
00:29:44,360 --> 00:30:04,180
If the result of evaluating the first predicate, the clauses--  respect the environment, if that evaluation yields false, then it means, I want to look at the next clause.

258
00:30:04,180 --> 00:30:05,990
So I want to discard the first one.

259
00:30:05,990 --> 00:30:16,700
So we just go around loop, evcond, the CDR of the clauses relative to that environment.

260
00:30:21,240 --> 00:30:41,960
And otherwise, I had a true clause, in which case, what I want is to evaluate the CADAR of the clauses relative to that environment.

261
00:30:48,200 --> 00:30:51,210
Boy, it's almost done.

262
00:30:51,210 --> 00:30:53,730
It's quite close to done.

263
00:30:53,730 --> 00:30:56,210
I think we're going to finish this part off.

264
00:30:56,210 --> 00:31:01,220
So just buzzing through this evaluator, but so far you're seeing almost everything.

265
00:31:01,220 --> 00:31:04,040
Let's look at the next transparency here.

266
00:31:08,980 --> 00:31:11,980
Here is bind.

267
00:31:11,980 --> 00:31:15,460
Bind is for making more table.

268
00:31:15,460 --> 00:31:22,800
And what we are going to do here is make a-- we're going to make a no-frame for an environment structure.

269
00:31:22,800 --> 00:31:28,080
The environment structure is going to be represented as a list of frames.

270
00:31:28,080 --> 00:31:49,690
So given an existing environment structure, I'm going to make a new environment structure by consing a new frame onto the existing environment structure, where the new frame consists of the result of pairing up the variables, which are the bound variables of the procedure I'm applying, to the values which are the arguments that were passed that procedure.

271
00:31:49,690 --> 00:31:58,391
This is just making a list, adding a new element to our list of frames, which is an environment structure, to make a new environment.

272
00:31:58,391 --> 00:32:01,540
Where pair-up is very simple.

273
00:32:01,540 --> 00:32:09,720
Pair-up is nothing more than if I have a list of variables and a list of values, well, if I run out of variables and if I run out of values, everything's OK.

274
00:32:09,720 --> 00:32:12,990
Otherwise, I've given too many arguments.

275
00:32:12,990 --> 00:32:18,560
If I've not run out of variables, but I've run out of values, that I have too few arguments.

276
00:32:18,560 --> 00:32:42,950
And in the general case, where I don't have any errors, and I'm not done, then I really am just adding a new pair of the first variable with the first argument, the first value, onto a list resulting from pairing-up the rest of the variables with the rest of the values.

277
00:32:42,950 --> 00:32:46,620
Lookup is of course equally simple.

278
00:32:46,620 --> 00:32:54,650
If I have to look up a symbol in an environment, well, if the environment is empty, then I've got an unbound variable.

279
00:32:54,650 --> 00:33:05,930
Otherwise, what I'm going to do is use a special pair list lookup procedure, which we'll have very shortly, of the symbol in the first frame of the environment.

280
00:33:05,930 --> 00:33:09,200
Since I know the environment is not empty, it must have a first frame.

281
00:33:09,200 --> 00:33:11,140
So I lookup the symbol in the first frame.

282
00:33:11,140 --> 00:33:15,150
That becomes the value cell here.

283
00:33:15,150 --> 00:33:23,720
And then, if the value cell is empty, if there is no such value cell, then I have to continue and look at the rest of the frames.

284
00:33:23,720 --> 00:33:25,990
It means there was nothing found there.

285
00:33:25,990 --> 00:33:32,010
So that's a property of ASSQ is it returns emptiness if it doesn't find something.

286
00:33:32,010 --> 00:33:41,050
but if it did find something, then I'm going to use the CDR of the value cell here, which is the thing that was the pair consisting of the variable and the value.

287
00:33:41,050 --> 00:33:45,000
So the CDR of it is the value part.

288
00:33:45,000 --> 00:33:47,970
Finally, ASSQ is something you've probably seen already.

289
00:33:47,970 --> 00:33:53,760
ASSQ takes a symbol and a list of pairs, and if the list is empty, it's empty.

290
00:33:53,760 --> 00:33:59,820
If the symbol is the first thing in the list-- That's an error.

291
00:33:59,820 --> 00:34:04,160
That should be CAAR, C-A-A-R. Everybody note that.

292
00:34:07,730 --> 00:34:08,980
Right there, OK?

293
00:34:13,121 --> 00:34:35,190
And in any case, if the symbol is the CAAR of the A list, then I want the first, the first pair, in the A list. So, in other words, if this is the key matching the right entry, otherwise, I want to look up that symbol in the rest. Sorry for producing a bug, bugs appear.

294
00:34:35,190 --> 00:34:39,639
Well, in any case, you're pretty much seeing the whole thing now.

295
00:34:41,880 --> 00:34:49,600
It's a very beautiful thing, even though it's written in an ugly style, being the kernel of every language.

296
00:34:49,600 --> 00:34:51,460
I suggest that we just-- let's look at it for a while.

297
00:34:56,749 --> 00:35:49,750
[MUSIC PLAYING]

298
00:35:49,750 --> 00:35:51,000
Are there any questions?

299
00:36:01,180 --> 00:36:04,044
Alright, I suppose it's time to take a small break then.

300
00:36:04,044 --> 00:36:56,780
[MUSIC PLAYING]

301
00:36:56,780 --> 00:37:03,470
OK, now we're just going to do a little bit of practice understanding what it is we've just shown you.

302
00:37:03,470 --> 00:37:11,500
What we're going to do is go through, in detail, an evaluation by informally substituting through the interpreter.

303
00:37:11,500 --> 00:37:25,330
And since we have no assignments or definitions in this interpreter, we have no possible side effects, and so the we can do substitution with impunity and not worry about results.

304
00:37:25,330 --> 00:37:30,690
So the particular problem I'd like to look at is it an interesting one.

305
00:37:30,690 --> 00:37:59,890
It's the evaluation of quote, open, open, open, lambda of x, lambda of y plus x y, lambda, lambda, applied to three, applied to four, in some global environment which I'll call e0.

306
00:38:04,930 --> 00:38:14,300
So what we have here is a procedure of one argument x, which produces as its value a procedure of one argument y, which adds x to y.

307
00:38:14,300 --> 00:38:17,960
We are applying the procedure of one argument x to three.

308
00:38:17,960 --> 00:38:21,400
So x should become three.

309
00:38:21,400 --> 00:38:26,167
And the result of that should be procedure of one argument y, which will then apply to 4.

310
00:38:28,910 --> 00:38:34,790
And there is a very simple case, they will then add those results.

311
00:38:34,790 --> 00:38:37,660
And now in order to do that, I want to make a very simple environment model.

312
00:38:37,660 --> 00:38:44,460
And at this point, you should already have in your mind the environments that this produces.

313
00:38:44,460 --> 00:38:56,740
But we're going to start out with a global environment, which I'll call e0, which is that.

314
00:38:56,740 --> 00:39:31,270
And it's going to have in it things, definitions for plus, and times, and-- using Greek letters, isn't that interesting, for the objects-- and minus, and quotient, and CAR, and CDR, and CONS, and EQ, and everything else you might imagine in a global environment.

315
00:39:31,270 --> 00:39:39,220
It's got something there for each of those things, something the machine is born with, that's e0.

316
00:39:39,220 --> 00:39:42,940
Now what does it mean to do this evaluation?

317
00:39:42,940 --> 00:39:48,670
Well, we go through the set of special forms. First of all, this is not a number.

318
00:39:48,670 --> 00:39:50,380
This is not a symbol.

319
00:39:53,210 --> 00:39:56,520
Gee, it's not a quoted expression.

320
00:39:56,520 --> 00:40:00,600
This is a quoted expression, but that's not what I interested in.

321
00:40:00,600 --> 00:40:05,890
The question is, whether or not the thing which is quoted is quoted expression?

322
00:40:05,890 --> 00:40:07,960
I'm evaluating an expression.

323
00:40:07,960 --> 00:40:11,410
This just says it's this particular expression.

324
00:40:11,410 --> 00:40:12,660
This is not a quoted expression.

325
00:40:15,230 --> 00:40:19,120
It's not a thing that begins with lambda.

326
00:40:19,120 --> 00:40:22,030
It's not a thing that begins with COND.

327
00:40:22,030 --> 00:40:26,310
Therefore, it's an application of its of an operated operands.

328
00:40:26,310 --> 00:40:28,570
It's a combination.

329
00:40:28,570 --> 00:40:36,480
The combination thus has this as the operator and this is the operands.

330
00:40:40,130 --> 00:41:24,450
Well, that means that what I'm going to do is transform this into apply of eval, of quote, open, open lambda of x, lambda of y-- I'm evaluating the operator-- plus x y, in the environment, also e0, with the operands that I'm going to apply this to, the arguments being the result of EVLIST, the list containing four, fin e0.

331
00:41:29,010 --> 00:41:36,840
I'm using this funny notation here for e0 because this should be that environment.

332
00:41:36,840 --> 00:41:39,890
I haven't a name for it, because I have no environment to name it in.

333
00:41:41,960 --> 00:41:47,730
So this is just a representation of what would be a quoted expression, if you will.

334
00:41:47,730 --> 00:41:53,040
The data structure, which is the environment, goes there.

335
00:41:53,040 --> 00:41:55,850
Well, that's what we're seeing here.

336
00:41:55,850 --> 00:41:59,610
Well in order to do this, I have to do this, and I have to do that.

337
00:41:59,610 --> 00:42:03,770
Well this one's easy, so why don't we do that one first.

338
00:42:03,770 --> 00:42:09,520
This turns into apply of eval-- just copying something now.

339
00:42:09,520 --> 00:42:11,000
Most of the substitution rule is copying.

340
00:42:18,530 --> 00:42:23,350
So I'm going to not say the words when I copy, because it's faster.

341
00:42:26,100 --> 00:42:48,910
And then the EVLIST is going to turn into a cons, of eval, of four, in e0--  because it was not an empty list-- onto the result of EVLISTing, on the empty list, in e0.

342
00:42:52,580 --> 00:42:55,800
And I'm going to start leaving out steps soon, because it's going to get boring.

343
00:42:59,870 --> 00:43:20,240
But this is basically the same thing as apply, of eval--  I'm going to keep doing this-- the lambda of x, the lambda of y, plus xy, 3, close, e0.

344
00:43:20,240 --> 00:43:21,490
I'm a pretty good machine.

345
00:43:24,690 --> 00:43:28,790
Well, eval of four, that's meets the question, is it a number.

346
00:43:28,790 --> 00:43:35,280
So that's cons, cons of 4.

347
00:43:35,280 --> 00:43:39,240
And EVLIST of the empty list is the empty list, so that's this.

348
00:43:43,270 --> 00:43:48,710
And that's very simple to understand, because that means the list containing four itself.

349
00:43:48,710 --> 00:44:13,940
So this is nothing more than apply of eval, quote, open, open, lambda of x, lambda of y, plus x y, three applied to, e0, applied to the list four-- bang.

350
00:44:13,940 --> 00:44:15,190
So that's that step.

351
00:44:18,100 --> 00:44:20,360
Now let's look at the next, more interesting thing.

352
00:44:20,360 --> 00:44:23,070
What do I do to evaluate that?

353
00:44:23,070 --> 00:44:29,460
Evaluating this means I have to evaluate-- Well, it's not.

354
00:44:29,460 --> 00:44:31,680
It's nothing but an application.

355
00:44:31,680 --> 00:44:33,570
It's not one of the special things.

356
00:44:33,570 --> 00:44:46,570
If the application of this operator, which we see here-- here's the operator-- applied to this operands, that combination.

357
00:44:46,570 --> 00:44:52,370
But we know how to do that, because that's the last case of the conditional.

358
00:44:52,370 --> 00:45:01,160
So substituting in for this evaluation, it's apply of eval of the operator in the EVLIST of the operands.

359
00:45:01,160 --> 00:45:25,350
Well, it's apply, of apply, of eval, of quote, open, lambda of x, lambda of y, plus x y, lambda, lambda, in environment e0.

360
00:45:30,520 --> 00:45:35,230
I'm going to short circuit the evaluation of the operands , because they're the same as they were before.

361
00:45:35,230 --> 00:45:39,330
I got a list containing three, apply that, and apply that to four.

362
00:45:42,780 --> 00:45:44,410
Well let's see.

363
00:45:44,410 --> 00:45:49,450
Eval of a lambda expression produces a procedure object.

364
00:45:52,030 --> 00:46:12,130
So this is apply, of apply, of the procedure object closure, which contains the body of the procedure, x, which is lambda-- which binds x [UNINTELLIGIBLE]

365
00:46:12,130 --> 00:46:20,630
the internals of the body, it returns the procedure of one argument y, which adds x to y.

366
00:46:23,210 --> 00:46:30,340
Environment e0 is now captured in it, because this was evaluated with respect to e0.

367
00:46:30,340 --> 00:46:33,040
e0 is part now of the closure object.

368
00:46:33,040 --> 00:46:41,300
Apply that to open, three, close, apply, to open, 4, close, apply.

369
00:46:47,390 --> 00:46:57,150
So going from this step to this step meant that I made up a procedure object which captured in it e0 as part of the procedure object.

370
00:46:57,150 --> 00:46:58,620
Now, we're going to pass those to apply.

371
00:46:58,620 --> 00:47:02,710
We have to apply this procedure to that set of arguments.

372
00:47:02,710 --> 00:47:07,380
Well, but that procedure is not primitive.

373
00:47:07,380 --> 00:47:13,710
It's, in fact, a thing which has got the tag closure, and, therefore, what we have to do is do a bind.

374
00:47:13,710 --> 00:47:15,830
We have to bind.

375
00:47:15,830 --> 00:47:28,230
A new environment is made at this point, which has as its parent environment the one over here, e0, that environment.

376
00:47:30,320 --> 00:47:31,570
And we'll call this one, e1.

377
00:47:34,620 --> 00:47:36,040
Now what's bound in there?

378
00:47:36,040 --> 00:47:38,620
x is bound to three.

379
00:47:38,620 --> 00:47:41,480
So I have x equal three.

380
00:47:41,480 --> 00:47:42,730
That's what's in there.

381
00:47:44,940 --> 00:47:46,240
And we'll call that e1.

382
00:47:46,240 --> 00:48:00,290
So what this transforms into is an eval of the body of this, which is this, the body of that procedure, in the environment that you just saw.

383
00:48:00,290 --> 00:48:16,520
So that's an apply, of eval, quote, open, lambda of y, plus x y-- the body--  in e1.

384
00:48:20,660 --> 00:48:28,680
And apply the result of that to four, open, close, 4-- list of arguments.

385
00:48:28,680 --> 00:48:33,110
Well, that's sensible enough because evaluating a lambda, I know what to do.

386
00:48:33,110 --> 00:48:52,150
That means I apply, the procedure which is closure, binds one argument y, adds x to y, with e1 captured in it.

387
00:48:55,790 --> 00:48:57,800
And you should really see this.

388
00:48:57,800 --> 00:49:00,140
I somehow manufactured a closure.

389
00:49:00,140 --> 00:49:01,790
I should've put this here.

390
00:49:01,790 --> 00:49:03,040
There was one over here too.

391
00:49:06,230 --> 00:49:08,080
Well, there's one here now.

392
00:49:08,080 --> 00:49:17,880
I've captured e1, and this is the procedure of one argument y, whatever this is.

393
00:49:17,880 --> 00:49:20,435
That's what that is there, that closure.

394
00:49:23,040 --> 00:49:26,230
I'm going to apply that to four.

395
00:49:30,690 --> 00:49:31,940
Well, that's easy enough.

396
00:49:36,830 --> 00:49:49,540
That means I have to make a new environment by copying this pointer, which was the pointer of the procedure, which binds y equal 4 with that environment.

397
00:49:49,540 --> 00:49:52,460
And here's my new environment, which I'll call e2.

398
00:49:55,870 --> 00:50:01,910
And, of course, this application then is evaluate the body in e2.

399
00:50:01,910 --> 00:50:13,710
So this is eval, the body, which is plus x y, in the environment e2.

400
00:50:13,710 --> 00:50:37,340
But this is an application, so this is the apply, of eval, plus in e2, an EVLIST, quote, open, x y, in e2.

401
00:50:44,880 --> 00:50:45,590
Well, but let's see.

402
00:50:45,590 --> 00:50:54,190
That is apply, the object which is a result of that and plus.

403
00:50:54,190 --> 00:51:01,780
So here we are in e2, plus is not here, it's not here, oh, yes, but's here as some primitive operator.

404
00:51:01,780 --> 00:51:04,745
So it's the primitive operator for addition.

405
00:51:08,490 --> 00:51:14,370
Apply that to the result of evaluating x and y in e2.

406
00:51:14,370 --> 00:51:18,340
But we can see that x is three and y is four.

407
00:51:18,340 --> 00:51:23,936
So that's a three and four, here.

408
00:51:23,936 --> 00:51:26,280
And that magically produces for me a seven.

409
00:51:30,520 --> 00:51:40,470
I wanted to go through this so you would see, essentially, one important ingredient, which is what's being passed around, and who owns what, and what his job is.

410
00:51:40,470 --> 00:51:41,700
So what do we have here?

411
00:51:41,700 --> 00:51:46,520
We have eval, and we have apply, the two main players.

412
00:51:49,370 --> 00:51:52,320
And there is a big loop the goes around like this.

413
00:51:52,320 --> 00:52:06,270
Which is eval produces a procedure and arguments for apply.

414
00:52:06,270 --> 00:52:09,710
Now some things eval could do by itself.

415
00:52:09,710 --> 00:52:10,860
Those are little self things here.

416
00:52:10,860 --> 00:52:12,700
They're not interesting.

417
00:52:12,700 --> 00:52:16,240
Also eval evaluates all of the arguments, one after another.

418
00:52:16,240 --> 00:52:17,650
That's not very interesting.

419
00:52:17,650 --> 00:52:22,300
Apply can apply some procedures like plus, not very interesting.

420
00:52:22,300 --> 00:52:32,880
However, if apply can't apply a procedure like plus, it produces an expression and environment for eval.

421
00:52:35,470 --> 00:52:43,740
The procedural arguments wrap up essentially the state of a computation and, certainly, the expression of environment.

422
00:52:43,740 --> 00:52:48,820
And so what we're actually going to do next is not the complete state, because it doesn't say who wants the answers.

423
00:52:51,280 --> 00:52:58,970
But what we're going to do-- it's always got something like an expression of environment or procedure and arguments as the main loop that we're going around.

424
00:52:58,970 --> 00:53:12,280
There are minor little sub loops like eval through EVLIST, or eval through evcond, or apply through a primitive apply.

425
00:53:16,140 --> 00:53:18,500
But they're not the essential things.

426
00:53:18,500 --> 00:53:21,860
So that's what I wanted you to see.

427
00:53:21,860 --> 00:53:23,110
Are there any questions?

428
00:53:25,930 --> 00:53:28,690
Yes.

429
00:53:28,690 --> 00:53:37,070
AUDIENCE: I'm trying to understand how x got down to three instead of four.

430
00:53:37,070 --> 00:53:41,310
At the early part of the-- PROFESSOR: Here.

431
00:53:41,310 --> 00:53:43,310
You want to know how x got down to three?

432
00:53:43,310 --> 00:53:51,040
AUDIENCE: Because x is the outer procedure, and x and y are the inner procedure.

433
00:53:51,040 --> 00:53:52,570
PROFESSOR: Fine.

434
00:53:52,570 --> 00:53:55,280
Well, I was very careful and mechanical.

435
00:53:55,280 --> 00:54:00,610
First of all, I should write those procedures again for you, pretty printed.

436
00:54:00,610 --> 00:54:03,830
First order of business, because you're probably not reading them well.

437
00:54:03,830 --> 00:54:26,140
So I have here that procedure of-- was it x over there-- which is-- value of that procedure of y, which adds x to y, lambda, lambda, applied that to three, takes the result of that, and applied that to four.

438
00:54:26,140 --> 00:54:28,810
Is that not what I wrote?

439
00:54:28,810 --> 00:54:40,735
Now, you should immediately see that here is an application-- let me get a white piece of chalk-- here is an application, a combination.

440
00:54:44,300 --> 00:54:51,040
That combination has this as the operator and this as the operand.

441
00:54:51,040 --> 00:54:54,900
The three is going in for the x here.

442
00:54:54,900 --> 00:55:01,530
The result of this is a procedure of one argument y, which gets applied to four.

443
00:55:01,530 --> 00:55:04,190
So you just weren't reading the expression right.

444
00:55:04,190 --> 00:55:13,340
The way you see that over here is that here I have the actual procedure object, x.

445
00:55:13,340 --> 00:55:18,980
It's getting applied to three, the list containing three.

446
00:55:18,980 --> 00:55:24,080
What I'm left over with is something which gets applied to four.

447
00:55:24,080 --> 00:55:25,330
Are there any other questions?

448
00:55:28,600 --> 00:55:30,900
Time for our next small break then.

449
00:55:30,900 --> 00:55:33,735
Thank you.

450
00:55:33,735 --> 00:56:08,410
[MUSIC PLAYING]

451
00:56:08,410 --> 00:56:17,960
Let's see, at this point, you should be getting the feeling, what's this nonsense this Sussman character is feeding me?

452
00:56:20,740 --> 00:56:24,800
There's an awful lot of strange nonsense here.

453
00:56:24,800 --> 00:56:30,892
After all, he purported to explain to me Lisp, and he wrote me a Lisp program on the blackboard.

454
00:56:30,892 --> 00:56:38,370
The Lisp program was intended to be interpreted for Lisp, but you need a Lisp interpreter in order to understand that program.

455
00:56:38,370 --> 00:56:44,150
How could that program have told me anything there is to be known about Lisp?

456
00:56:44,150 --> 00:56:45,795
How is that not completely vacuous?

457
00:56:48,490 --> 00:56:50,990
It's a very strange thing.

458
00:56:50,990 --> 00:56:52,430
Does it tell me anything at all?

459
00:56:56,070 --> 00:57:03,105
Well, you see, the whole thing is sort of like these Escher's hands that we see on this slide.

460
00:57:06,180 --> 00:57:17,110
Yes, eval and apply each sort of draw each other and construct the real thing, which can sit out and draw itself.

461
00:57:17,110 --> 00:57:20,550
Escher was a very brilliant man, he just didn't know the names of these spirits.

462
00:57:23,910 --> 00:57:36,090
Well, I'm going to do now, is I'm going to try to convince you that both this mean something, and, as a aside, I'm going to show you why you don't need definitions.

463
00:57:36,090 --> 00:57:44,890
Just turns out that that sort of falls out, why definitions are not essential in a mathematical sense for doing all the things we need to do for computing.

464
00:57:49,070 --> 00:57:50,690
Well, let's see here.

465
00:57:50,690 --> 00:57:54,870
Consider the following small program, what does it mean?

466
00:57:54,870 --> 00:57:57,035
This is a program for computing exponentials.

467
00:58:07,270 --> 00:58:22,070
The exponential of x to the nth power is if--  and is zero, then the result is one.

468
00:58:22,070 --> 00:58:33,930
Otherwise, I want the product of x and the result of exponentiating x to the n minus one power.

469
00:58:42,858 --> 00:58:46,630
I think I got it right.

470
00:58:46,630 --> 00:58:49,470
Now this is a recursive definition.

471
00:58:49,470 --> 00:58:56,410
It's a definition of the exponentiation procedure in terms of itself.

472
00:58:56,410 --> 00:59:05,650
And, as it has been mentioned before, your high school geometry teacher probably gave you a hard time about things like that.

473
00:59:05,650 --> 00:59:07,910
Was that justified?

474
00:59:07,910 --> 00:59:13,430
Why does this self referential definition make any sense?

475
00:59:13,430 --> 00:59:17,600
Well, first of all, I'm going to convince you that your high school geometry teacher was I telling you nonsense.

476
00:59:20,370 --> 00:59:24,490
Consider the following set of definitions here.

477
00:59:24,490 --> 00:59:33,070
x plus y equals three, and x minus y equal one.

478
00:59:33,070 --> 00:59:37,490
Well, gee, this tells you x in terms of y, and this one tells you y in terms of x, presumably.

479
00:59:40,150 --> 00:59:42,950
And yet this happens to have a unique solution in x and y.

480
00:59:55,910 --> 01:00:06,600
However, I could also write two x plus two y is six.

481
01:00:06,600 --> 01:00:09,610
These two equations have an infinite number solutions.

482
01:00:15,730 --> 01:00:24,070
And I could write you, for example, x minus y equal 2, and these two equations have no solutions.

483
01:00:29,820 --> 01:00:39,510
Well, I have here three sets of simultaneous linear equations, this set, this set, and this set.

484
01:00:39,510 --> 01:00:42,900
But they have different numbers of solutions.

485
01:00:42,900 --> 01:00:45,760
The number of solutions is not in the form of the equations.

486
01:00:45,760 --> 01:00:48,350
They all three sets have the same form.

487
01:00:48,350 --> 01:00:50,205
The number of solutions is in the content.

488
01:00:53,000 --> 01:00:59,660
I can't tell by looking at the form of a definition whether it makes sense, only by its detailed content.

489
01:00:59,660 --> 01:01:05,100
What are the coefficients, for example, in the case of linear equations?

490
01:01:05,100 --> 01:01:16,030
So I shouldn't expect to be able to tell looking at something like this, from some simple things like, oh yes, EXPT is the solution of this recursion equation.

491
01:01:16,030 --> 01:01:26,040
Expt is the procedure which if substituted in here, gives me EXPT back.

492
01:01:26,040 --> 01:01:37,200
I can't tell, looking at this form, whether or not there's a single, unique solution for EXPT, an infinite number of solutions, or no solutions.

493
01:01:37,200 --> 01:01:40,490
It's got to be how it counts and things like that, the details.

494
01:01:40,490 --> 01:01:42,900
And it's harder in programming than linear algebra.

495
01:01:42,900 --> 01:01:45,210
There aren't too many theorems about it in programming.

496
01:01:48,450 --> 01:01:53,970
Well, I want to rewrite these equations a little bit, these over here.

497
01:01:53,970 --> 01:01:56,770
Because what we're investigating is equations like this.

498
01:01:56,770 --> 01:02:04,730
But I want to play a little with equations like this that we understand, just so we get some insight into this kind of question.

499
01:02:04,730 --> 01:02:19,380
We could rewrite our equations here, say these two, the ones that are interesting, as x equals three minus y, and y equals x minus one.

500
01:02:22,010 --> 01:02:24,050
What do we call this transformation?

501
01:02:24,050 --> 01:02:26,095
This is a linear transformation, t.

502
01:02:29,430 --> 01:02:37,370
Then what we're getting here is an equation x y equals t of x y.

503
01:02:42,990 --> 01:02:44,560
What am I looking for?

504
01:02:44,560 --> 01:02:47,040
I'm looking for a fixed point of t.

505
01:02:47,040 --> 01:02:59,350
The solution is a fixed point of t.

506
01:03:01,910 --> 01:03:10,880
So the methods we should have for looking for solutions to equations, if I can do it by fixed points, might be applicable.

507
01:03:10,880 --> 01:03:22,410
If I have a means of finding a solution to an equations by fixed points-- just, might not work-- but it might be applicable to investigating solutions of equations like this.

508
01:03:27,240 --> 01:03:30,260
But what I want you to feel is that this is an equation.

509
01:03:30,260 --> 01:03:45,010
It's an expression with several instances of various names which puts a constraint on the name, saying what that name could have as its value, rather than some sort of mechanical process of substitution right now.

510
01:03:47,740 --> 01:03:51,220
This is an equation which I'm going to try to solve.

511
01:03:51,220 --> 01:03:53,960
Well, let's play around and solve it.

512
01:03:53,960 --> 01:04:00,320
First of all, I want to write down the function which corresponds to t.

513
01:04:00,320 --> 01:04:06,960
First I want to write down the function which corresponds to t whose fixed point is the answer to this question.

514
01:04:11,950 --> 01:04:14,240
Well, let's consider the following procedure f.

515
01:04:16,870 --> 01:04:19,340
I claim it computes that function.

516
01:04:19,340 --> 01:04:33,430
f is that procedure of one argument g, which is that procedure of two arguments x and n.

517
01:04:33,430 --> 01:05:00,690
Which have the property that if n is zero, then the result is one, otherwise, the result is the product of x and g, applied to x, and minus n1.

518
01:05:03,370 --> 01:05:30,930
g, times, else, COND, lambda, lambda--  Here f is a procedure, which if I had a solution to that equation, if I had a good exponentiation procedure, and I applied f to that procedure, then the result would be a good exponentiation procedure.

519
01:05:37,460 --> 01:05:39,420
Because, what does it do?

520
01:05:39,420 --> 01:05:54,670
Well, all it is is exposing g were a good exponentiation procedure, well then this would produce, as its value, a procedure to arguments x and n, such that if n were 0, the result would be one, which is certainly true of exponentiation.

521
01:05:54,670 --> 01:06:03,470
Otherwise, it will be the result of multiplying x by the exponentiation procedure given to me with x and n minus one as arguments.

522
01:06:03,470 --> 01:06:14,620
So if this computed the correct exponentiation for n minus one, then this would be the correct exponentiation for exponent n, so this would have been the right exponentiation procedure.

523
01:06:17,500 --> 01:06:32,320
So what I really want to say here is E-X-P-T is a fixed point of f.

524
01:06:37,550 --> 01:06:40,060
Now our problem is there might be more than one fixed point.

525
01:06:40,060 --> 01:06:43,270
There might be no fixed points.

526
01:06:43,270 --> 01:06:44,810
I have to go hunting for the fixed points.

527
01:06:48,290 --> 01:06:49,540
Got to solve this equation.

528
01:06:52,160 --> 01:06:55,580
Well there are various ways to hunt for fixed points.

529
01:06:55,580 --> 01:07:00,815
Of course, the one we played with at the beginning of this term worked for cosine.

530
01:07:06,080 --> 01:07:16,090
Go into radians mode on your calculator and push cosine, and just keep doing it, and you get to some number which is about 0.73 or 0.74.

531
01:07:16,090 --> 01:07:17,340
I can't remember which.

532
01:07:22,900 --> 01:07:33,770
By iterating a function, whose fixed point I'm searching for, it is sometimes the case that that function will converge in producing the fixed point.

533
01:07:33,770 --> 01:07:39,910
I think we luck out in this case, so let's look for it.

534
01:07:39,910 --> 01:07:48,030
Let's look at this slide.

535
01:07:48,030 --> 01:07:51,390
Consider the following sequence of procedures.

536
01:07:56,400 --> 01:08:02,940
e0 over here is the procedure which does nothing at all.

537
01:08:02,940 --> 01:08:07,780
It's the procedure which produces an error for any arguments you give it.

538
01:08:07,780 --> 01:08:09,030
It's basically useless.

539
01:08:14,480 --> 01:08:20,080
Well, however, I can make an approximation.

540
01:08:20,080 --> 01:08:26,990
Let's consider it the worst possible approximation to exponentiation, because it does nothing.

541
01:08:26,990 --> 01:08:37,380
Well, supposing I substituted e0 for g by calling f, as you see over here on e0.

542
01:08:37,380 --> 01:08:40,729
So you see over here, have e0 there.

543
01:08:40,729 --> 01:08:43,859
Then gee, what's e1?

544
01:08:43,859 --> 01:08:49,325
e1 is a procedure which exponentiate things to the 0th power, with no trouble.

545
01:08:49,325 --> 01:08:54,250
It gets the right answer, anything to the zero is one, and it makes an error on anything else.

546
01:08:57,390 --> 01:09:07,310
Well, now what if I take e1 and I substitute if for g by calling f on e1?

547
01:09:10,500 --> 01:09:15,670
Oh gosh, I have here a procedure of two arguments.

548
01:09:15,670 --> 01:09:24,200
Now remember e1 was appropriate for taking exponentiations of 0, for raising to the 0 exponent.

549
01:09:24,200 --> 01:09:29,520
So here, is n is 0, the result is one, so this guy is good for that too.

550
01:09:29,520 --> 01:09:35,979
However, I can use something for raising to the 0th power to multiply it by x to raise something to the first power.

551
01:09:35,979 --> 01:09:39,670
So e2 is good for both power 0 and one.

552
01:09:43,800 --> 01:09:47,899
And e3 is constructed from e2 in the same way.

553
01:09:47,899 --> 01:09:55,120
And e3, of course, by the same argument is good for powers 0, one, and two.

554
01:09:55,120 --> 01:10:02,520
And so I will assert for you, without proof, because the proof is horribly difficult.

555
01:10:02,520 --> 01:10:07,710
And that's the sort of thing that people called denotational semanticists do.

556
01:10:07,710 --> 01:10:10,265
This great idea was invented by Scott and Strachey.

557
01:10:14,240 --> 01:10:24,240
They're very famous mathematician types who invented the interpretation for these programs that we have that I'm talking to you about right now.

558
01:10:24,240 --> 01:10:32,220
And they proved, by topology that there is such a fixed point in the cases that we want.

559
01:10:32,220 --> 01:10:43,680
But the assertion is E-X-P-T is limit as n goes to infinity of em.

560
01:10:43,680 --> 01:10:47,900
and And that we've constructed this by the following way.

561
01:10:50,520 --> 01:11:01,120
--is Well, it's f of, f of, f of, f of, f of-- f applied to anything at all.

562
01:11:01,120 --> 01:11:05,320
It didn't matter what that was, because, in fact, this always produces an error.

563
01:11:07,540 --> 01:11:16,380
Applied to this--  That's by infinite nesting of f's.

564
01:11:16,380 --> 01:11:19,760
So now my problem is to make some infinite things.

565
01:11:22,590 --> 01:11:24,920
We need some infinite things.

566
01:11:24,920 --> 01:11:28,980
How am I going to nest up an f an infinite number of times?

567
01:11:28,980 --> 01:11:32,380
I'd better construct this.

568
01:11:32,380 --> 01:11:32,930
Well, I don't know.

569
01:11:32,930 --> 01:11:34,810
How would I make an infinite loop at all?

570
01:11:34,810 --> 01:11:38,340
Let's take a very simple infinite loop, the simplest infinite loop imaginable.

571
01:11:43,550 --> 01:12:07,440
If I were to take that procedure of one argument x which applies x to x and apply that to the procedure of one argument x which applies x to x, then this is an infinite loop.

572
01:12:07,440 --> 01:12:09,980
The reason why this is an infinite loop is as follows.

573
01:12:09,980 --> 01:12:18,850
The way I understand this is I substitute the argument for the formal parameter in the body.

574
01:12:18,850 --> 01:12:29,660
But if I do that, I take for each of these x's, I substitute one of these, making a copy of the original expression I just started with, the simplest infinite loop.

575
01:12:35,440 --> 01:12:43,090
Now I want to tell you about a particular operator which is constructed by a perturbation from this infinite loop.

576
01:12:47,040 --> 01:12:48,290
I'll call it y.

577
01:12:52,290 --> 01:13:04,480
This is called Curry's Paradoxical Combinator of y after a fellow by the name of Curry, who was a logician of the 1930s also.

578
01:13:04,480 --> 01:13:09,330
And if I have a procedure of one argument f, what's it going to have in it?

579
01:13:09,330 --> 01:13:27,899
It's going to have a kind of infinite loop in it, which is that procedure of one argument x which applies f to x of x, applied to that procedure of one argument x, which applies f to f of x.

580
01:13:32,300 --> 01:13:34,590
Now what's this do?

581
01:13:34,590 --> 01:13:42,950
Suppose we apply y to F. Well, that's easy enough.

582
01:13:42,950 --> 01:13:46,910
That's this capital F over here.

583
01:13:46,910 --> 01:13:49,920
Well, the easiest thing to say there is, I substitute F for here.

584
01:13:55,320 --> 01:14:02,800
So that's going to give me, basically-- because then I'm going to substitute this for x in here.

585
01:14:08,970 --> 01:14:11,730
Let me actually do it in steps, so you can see it completely.

586
01:14:11,730 --> 01:14:15,020
I'm going to be very careful.

587
01:14:15,020 --> 01:14:37,910
This is open, open, lambda of x , capital F, x, x, applied to itself, F of x of x.

588
01:14:37,910 --> 01:15:11,510
Substituting this for this in here, this is F applied to-- what is it-- substituting this in here, open, open, lambda of x, F, of x and x, applied to lambda of x, F of x of x, F, lambda, pair, F.

589
01:15:11,510 --> 01:15:13,420
Oh, but what is this?

590
01:15:13,420 --> 01:15:20,030
This thing over here that I just computed, is this thing over here.

591
01:15:20,030 --> 01:15:23,370
But I just wrapped another F around it.

592
01:15:23,370 --> 01:15:27,850
So by applying y to F, I make an infinite series of F's.

593
01:15:27,850 --> 01:15:33,170
If I just let this run forever, I'll just keep making more and more F's outside.

594
01:15:33,170 --> 01:15:36,855
I ran an infinite loop which is useless, but it doesn't matter that the inside is useless.

595
01:15:40,220 --> 01:16:04,450
So y of F is F applied to y of F. So y is a magical thing which, when applied to some function, produces the object which is the fixed point of that function, if it exists, and if this all works.

596
01:16:07,910 --> 01:16:11,630
Because, indeed, if I take y of F and put it into F, I get y of F out.

597
01:16:16,240 --> 01:16:23,860
Now I want you to think this in terms of the eval-apply interpreter for a bit.

598
01:16:23,860 --> 01:16:28,540
I wrote down a whole bunch of recursion equations out there.

599
01:16:28,540 --> 01:16:31,470
They're simultaneous in the same way these are simultaneous equations.

600
01:16:31,470 --> 01:16:33,310
Exponentiation was not a simultaneous equation.

601
01:16:33,310 --> 01:16:38,150
It was only one variable I was looking for a meaning for.

602
01:16:38,150 --> 01:16:58,220
But what Lisp is is the fixed point of the process which says, if I knew what Lisp was and substituted it in for eval, and apply, and so on, on the right hand sides of all those recursion equations, then if it was a real good Lisp, is a real one, then the left hand side would also be Lisp.

603
01:16:58,220 --> 01:16:59,565
So I made sense of that definition.

604
01:17:02,420 --> 01:17:05,410
Now whether or not there's an answer isn't so obvious.

605
01:17:05,410 --> 01:17:07,740
I can't attack that.

606
01:17:07,740 --> 01:17:10,660
Now these arguments that I'm giving you now are quite dangerous.

607
01:17:10,660 --> 01:17:13,570
Let's look over here.

608
01:17:13,570 --> 01:17:14,610
These are limit arguments.

609
01:17:14,610 --> 01:17:21,255
We're talking about limits, and it's really calculus, or topology, or something like that, a kind of analysis.

610
01:17:21,255 --> 01:17:23,380
Now here's an argument that you all believe.

611
01:17:23,380 --> 01:17:29,660
And I want to make sure you realize that I could be bullshitting you.

612
01:17:29,660 --> 01:17:30,910
What is this?

613
01:17:34,250 --> 01:17:42,820
u is the sum of 1/2, 1/4, and 1/8, and so on, the sum of a geometric series.

614
01:17:42,820 --> 01:17:44,820
And, of course, I could play a game here.

615
01:17:44,820 --> 01:17:47,570
u minus one is 1/2, plus 1/4, plus 1/8, and so on.

616
01:17:53,590 --> 01:17:56,680
What I could do here-- oops.

617
01:17:56,680 --> 01:17:58,920
There is a parentheses error here.

618
01:17:58,920 --> 01:18:03,990
But I can put here two times u minus one is one plus 1/2, plus 1/4, plus 1/8.

619
01:18:07,570 --> 01:18:08,820
Can I fix that?

620
01:18:14,010 --> 01:18:16,125
Yes, well.

621
01:18:19,520 --> 01:18:30,300
But that gives me back two times u minus one is u, therefore, we conclude that u is two.

622
01:18:30,300 --> 01:18:31,830
And this actually is true.

623
01:18:31,830 --> 01:18:33,910
There's no problem like that.

624
01:18:33,910 --> 01:18:38,540
But supposing I did something different.

625
01:18:38,540 --> 01:18:41,470
Supposing I start up with something which manifestly has no sum.

626
01:18:41,470 --> 01:18:47,390
v is one, plus two, plus four, plus 8, plus dot, dot, dot.

627
01:18:47,390 --> 01:18:52,010
Well, v minus one is surely two, plus four, plus eight, plus dot, dot, dot.

628
01:18:52,010 --> 01:18:57,410
v minus one over two, gee, that looks like v again.

629
01:18:57,410 --> 01:19:03,070
From that I should be able to conclude that-- that's also wrong, apparently.

630
01:19:03,070 --> 01:19:04,510
v equals minus one.

631
01:19:12,455 --> 01:19:15,280
That should be a minus one.

632
01:19:15,280 --> 01:19:16,735
And that's certainly a false conclusion.

633
01:19:22,000 --> 01:19:30,750
So when you play with limits, arguments that may work in one case they may not work in some other case.

634
01:19:30,750 --> 01:19:32,240
You have to be very careful.

635
01:19:32,240 --> 01:19:35,752
The arguments have to be well formed.

636
01:19:35,752 --> 01:19:43,270
And I don't know, in general, what the story is about arguments like this.

637
01:19:43,270 --> 01:19:46,060
We can read a pile of topology and find out.

638
01:19:46,060 --> 01:19:53,260
But, surely, at least you understand now, why it might be some meaning to the things we've been writing on the blackboard.

639
01:19:53,260 --> 01:19:56,480
And you understand what that might mean.

640
01:19:56,480 --> 01:20:09,320
So, I suppose, it's almost about time for you to merit being made a member of the grand recursive order of lambda calculus hackers.

641
01:20:09,320 --> 01:20:10,820
This is the badge.

642
01:20:10,820 --> 01:20:21,890
Because you now understand, for example, what it says at the very top, y F equals F y F. Thank you.

643
01:20:21,890 --> 01:20:24,710
Are there any questions?

644
01:20:24,710 --> 01:20:25,150
Yes, Lev.

645
01:20:25,150 --> 01:20:34,090
AUDIENCE: With this, it seems that then there's no need to define, as you imply, to just remember a value, to apply it later.

646
01:20:34,090 --> 01:20:36,490
Defines were kind of a side-effect it seemed in the language.

647
01:20:36,490 --> 01:20:37,075
[INTERPOSING]

648
01:20:37,075 --> 01:20:39,300
are order dependent.

649
01:20:39,300 --> 01:20:43,150
Does this eliminate the side-effect from the [INTERPOSING]

650
01:20:43,150 --> 01:20:49,180
PROFESSOR: The answer is, this is not the way these things were implemented.

651
01:20:49,180 --> 01:21:03,690
Define, indeed is implemented as an operation that actually modifies an environment structure, changes the frame that the define is executed in.

652
01:21:03,690 --> 01:21:11,340
And there are many reasons for that, but a lot of this has to do with making an interactive system.

653
01:21:11,340 --> 01:21:24,090
What this is saying is that if you've made a system, and you know you're not going to do any debugging or anything like that, and you know everything there is all at once, and you want to say, what is the meaning of a final set of equations?

654
01:21:24,090 --> 01:21:25,790
This gives you a meaning for it.

655
01:21:25,790 --> 01:21:35,000
But in order to make an interactive system, where you can change the meaning of one thing without changing everything else, incrementally, you can't do that by implementing it this way.

656
01:21:40,990 --> 01:21:41,860
Yes.

657
01:21:41,860 --> 01:21:44,650
AUDIENCE: Another question on your danger slide.

658
01:21:44,650 --> 01:21:50,300
It seemed that the two examples that you gave had to do with convergence and non-convergence?

659
01:21:50,300 --> 01:22:05,430
And that may or may not have something to do with function theory in a way which would lead you to think of it in terms of linear systems, or non-linear systems. How does this convergence relate to being able to see a priori what properties of that might be violated?

660
01:22:05,430 --> 01:22:07,680
PROFESSOR: I don't know.

661
01:22:07,680 --> 01:22:10,610
The answer is, I don't know under what circumstances.

662
01:22:10,610 --> 01:22:16,910
I don't know how to translate that into less than an hour of talk more.

663
01:22:16,910 --> 01:22:22,720
What are the conditions under which, for which we know that these things converge?

664
01:22:22,720 --> 01:22:32,810
And v, all that was telling you that arguments that are based on convergence are flaky if you don't know the convergence beforehand.

665
01:22:32,810 --> 01:22:34,440
You can make wrong arguments.

666
01:22:34,440 --> 01:22:40,690
You can make deductions, as if you know the answer, and not be stopped somewhere by some obvious contradiction.

667
01:22:40,690 --> 01:23:03,020
AUDIENCE: So can we say then that if F is a convergent mathematical expression, then the recursion property can be-- PROFESSOR: Well, I think there's a technical kind of F, there is a technical description of those F's that have the property that when you iteratively apply them like this, you converge.

668
01:23:03,020 --> 01:23:09,370
Things that are monotonic, and continuous, and I forgot what else.

669
01:23:09,370 --> 01:23:13,430
There is a whole bunch of little conditions like that which have this property.

670
01:23:13,430 --> 01:23:22,010
Now the real problem is deducing from looking at the F, its definition here, whether not it has those properties, and that's very hard.

671
01:23:22,010 --> 01:23:23,280
The properties are easy.

672
01:23:23,280 --> 01:23:24,580
You can write them down.

673
01:23:24,580 --> 01:23:26,930
You can look in a book by Joe Stoy.

674
01:23:26,930 --> 01:23:29,910
It's a great book-- Stoy.

675
01:23:31,780 --> 01:23:41,800
It's called, The Scott-Strachey Method of Denotational Semantics, and it's by Joe Stoy, MIT Press.

676
01:23:47,960 --> 01:23:51,880
And he works out all this in great detail, enough to horrify you.

677
01:23:55,080 --> 01:23:56,330
But it really is readable.

678
01:24:09,150 --> 01:24:11,490
OK, well, thank you.

679
01:24:11,490 --> 01:24:13,780
Time for the bigger break, I suppose.

