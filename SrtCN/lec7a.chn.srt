1
00:00:15,314 --> 00:00:18,410
今天我们学习一些非同一般的东西

2
00:00:18,410 --> 00:00:26,800
我们借助一些程序来理解更为深刻的理论

3
00:00:26,800 --> 00:00:32,729
到目前为止，我们一直把程序看作可描述的机器

4
00:00:32,729 --> 00:00:42,800
举个例子，这个幻灯片上有一个计算阶乘的程序

5
00:00:42,800 --> 00:00:52,230
它不过就是一连串字符串描述的东西，如果想的话，你也可以用可能无限递归的机器的布线图来表示

6
00:00:52,230 --> 00:00:55,130
我们只消看一点就明白程序是怎么回事

7
00:00:55,130 --> 00:01:00,170
这种记法很简洁，这句描述的是，如果n是0，结果就是1

8
00:01:00,170 --> 00:01:09,340
这里n输入机器，如果是0，就控制这个开关转到输出为1的方向

9
00:01:09,340 --> 00:01:12,970
否则，开关就转到输出为 n乘以n-1的阶乘 的方向

10
00:01:12,970 --> 00:01:21,900
下面计算的是n乘以n-1的阶乘，当n不是0的时候，开关就转到这个方向，输出这部分的计算

11
00:01:21,900 --> 00:01:31,070
当然，这个机器可能是有无数个部件，因为factorial内部又调用了factorial，因此我们也不知道递归的深度是多少

12
00:01:31,070 --> 00:01:38,310
这就是程序的记法所告诉我们的

13
00:01:38,310 --> 00:01:44,900
字符串可以描述程序，如果你想，用布线图表示也是可以的

14
00:01:44,900 --> 00:01:49,490
事实上，很多人都对我说过，说编程语言和这种图形很相似

15
00:01:49,490 --> 00:01:51,500
不过我不认为用图形表示会有很多优势

16
00:01:51,500 --> 00:02:01,090
一个缺点就是表示出来需要占用很大的平面空间，所以就很难一次性表示很大的程序，而且编辑修改起来也不方便

17
00:02:01,090 --> 00:02:10,450
但是不管怎样，有一个叫做“通用机”的机器还是很值得我们注意的

18
00:02:10,450 --> 00:02:21,260
我们再来看第二张幻灯片，这个特殊的机器名为eval

19
00:02:21,260 --> 00:02:25,720
这个eval也就是今天要讲的

20
00:02:25,720 --> 00:02:27,780
它非常简单

21
00:02:27,780 --> 00:02:30,490
甚至在黑板这么小的空间里都能把它写出来

22
00:02:33,350 --> 00:02:40,450
要注意的是，eval的输入比较特殊，它以对其它机器的描述作为输入

23
00:02:40,450 --> 00:02:46,490
这里它以一个计算阶乘的机器的布线图描述作为输入

24
00:02:46,490 --> 00:02:58,910
这样一来，eval变成了计算阶乘机器的模拟器，对eval输入6，得到阶乘结果720

25
00:02:58,910 --> 00:03:02,130
这种机器非同一般

26
00:03:02,130 --> 00:03:05,590
最让人吃惊的是只消在黑板这么小的空间内就可以描述完它

27
00:03:05,590 --> 00:03:28,050
我们可以类比着来看，假设在现实里的模拟电路中，有这样一种通用的机器，它以电路设计图纸为输入，像是低通滤波器、 单极点低通滤波器之类的

28
00:03:28,050 --> 00:03:49,890
你可以这样想像，用这个机器进行扫描输出 -- 扫描线应该可以描述出通用机在模拟的这个机器 -- 使用响应特定频率的滤波电路图的通用机模拟的效果应该和真实的滤波器达到的效果一样

29
00:03:49,890 --> 00:03:55,670
这种机器很难制造出来，我肯定也不能只在黑板这么大的空间就具体的表述出它

30
00:03:55,670 --> 00:03:58,430
所以说，今天是我们见证奇迹的时刻

31
00:03:58,430 --> 00:04:02,790
我们将会见证，在黑板上，我就可以“制造”出通用机

32
00:04:02,790 --> 00:04:06,780
除了部分事情以外，它其实非常简单

33
00:04:06,780 --> 00:04:11,280
我们也逐渐触碰到活在计算机中真正的神灵

34
00:04:11,280 --> 00:04:20,470
这里务必要保持足够的尊敬，所以我特地穿上西服外套，你们应该从没见我穿过

35
00:04:20,470 --> 00:04:26,980
我想我还得戴上一顶合适的帽子

36
00:04:28,780 --> 00:04:40,370
开讲前再给大家提个醒 -- 40岁以下以及还没有几个孩子的人要小心了

37
00:04:40,370 --> 00:04:51,820
如果你真的受不了，可以选择离开 因为一会儿要发生的事情非常神秘，可能使你的思想异常混乱

38
00:04:51,820 --> 00:05:02,510
好了，无论如何，我还是要向你们写一下Lisp的求值程序

39
00:05:02,510 --> 00:05:05,020
求值程序并不复杂

40
00:05:05,020 --> 00:05:08,240
很像我们以前见到过的程序

41
00:05:08,240 --> 00:05:10,860
这也是它令人吃惊的地方

42
00:05:10,860 --> 00:05:16,620
现在我开始写这个程序，叫做eval

43
00:05:22,900 --> 00:05:30,030
它是一个接受两个参数的过程，exp是表达式，env是表达式执行的环境

44
00:05:31,860 --> 00:05:34,940
和很多有趣的过程一样，过程内部按情况分析

45
00:05:40,460 --> 00:05:44,210
但是在我开始之前，我还想告诉你们一些其它的

46
00:05:44,210 --> 00:05:54,210
这里的这个程序非常丑陋、混乱、令人作呕，并不是一种专业的写法

47
00:05:54,210 --> 00:06:02,550
它用具体的语法写就，也就是说我们用很多CAR CDR之类，我之前告诉过你们这样写并不好

48
00:06:02,550 --> 00:06:12,420
在这里是故意这样来写的，因为我想使其娇小，简洁，达到可以写在黑板上的规模

49
00:06:12,420 --> 00:06:15,800
我就不像平时那样使用很多很长的命名了

50
00:06:15,800 --> 00:06:19,580
就用CAR CDR，很简洁

51
00:06:19,580 --> 00:06:20,950
这算是一种权衡

52
00:06:20,950 --> 00:06:23,570
我不希望你们这样来写程序

53
00:06:23,570 --> 00:06:26,090
这里单纯地想达到一种简洁的效果

54
00:06:26,090 --> 00:06:31,270
因此你们读起来可能有些费力，我尽量写的清楚

55
00:06:31,270 --> 00:06:51,670
这个求值器比较完整，但是并不完全，我就不写define和assignment的部分了，不是它们不重要，而是出于一些数学上的原因，再说黑板地方也不大

56
00:06:51,670 --> 00:06:54,170
但是，我们怎么做呢？

57
00:06:54,170 --> 00:07:02,030
这里需要做一个分配，把表达式分类

58
00:07:02,030 --> 00:07:03,525
这就是现在要做的

59
00:07:03,525 --> 00:07:05,150
这里的表达式应该是什么？

60
00:07:05,150 --> 00:07:06,810
我们先来看几种表达式

61
00:07:06,810 --> 00:07:10,420
表达式数字3

62
00:07:10,420 --> 00:07:12,720
要怎么做？

63
00:07:12,720 --> 00:07:17,050
我有很多选择，但是我马上想到，它就应该是数字3

64
00:07:17,050 --> 00:07:18,860
这就是我要的

65
00:07:18,860 --> 00:07:19,800
这个足够简单

66
00:07:19,800 --> 00:07:31,970
那就意味着，如果表达式是数字，表达式本身就应该是求值结果

67
00:07:35,420 --> 00:07:39,390
表达式还可能是符号

68
00:07:39,390 --> 00:07:47,614
比如x n eval number之类

69
00:07:47,614 --> 00:07:49,630
它们意味着什么？

70
00:07:49,630 --> 00:07:51,690
它们是一类代表其它事物的事物

71
00:07:51,690 --> 00:07:54,770
也就是我们语言中所谓的变量

72
00:07:54,770 --> 00:08:02,930
因此，假如这有一个x，求值结果应该是它代表的那个值，我随便写一个3

73
00:08:02,930 --> 00:08:07,920
又假如符号是car

74
00:08:07,920 --> 00:08:23,100
这时候来求值，结果应该是一个过程，具体内部可能是机器码或是别的，不过这里我们并不需要关心

75
00:08:23,100 --> 00:08:24,430
到这是还是相对简单的

76
00:08:24,430 --> 00:08:27,890
我还是想把符号求值的具体部分交给别人来写

77
00:08:27,890 --> 00:08:40,159
假如表达式是符号，就执行(lookup exp env)，得到表达式在当前环境的结果

78
00:08:46,480 --> 00:08:54,060
这里的环境就相当于一本字典，根据符号名字就可以查找到相应的值

79
00:08:54,060 --> 00:08:56,280
就这么简单

80
00:08:56,280 --> 00:08:57,530
env在这里到底是什么？

81
00:08:57,530 --> 00:08:59,760
稍后我们再谈这个

82
00:08:59,760 --> 00:09:01,670
其实并不难

83
00:09:01,670 --> 00:09:04,670
就是一个融合了多种排序的表结构

84
00:09:04,670 --> 00:09:10,040
可以简单理解为它就是一个表，lookup过程可以查找这个表

85
00:09:10,040 --> 00:09:17,430
好的，接下来，下一种可能 -- 表达式可能是一些不是数字的常数，比如'foo

86
00:09:20,170 --> 00:09:31,520
这里方便起见，我把它转化为语法上等同的形式(quote foo)

87
00:09:35,140 --> 00:09:48,780
求值器并不处理引号，一个被引的表达式，无论它是什么，都是一个缩写，像是(quote foo)这种形式的缩写

88
00:09:48,780 --> 00:09:55,615
这样我就可以依据表达式的car来判断表达式的类型了

89
00:09:58,460 --> 00:10:01,650
因此这一部分也不难写

90
00:10:01,650 --> 00:10:05,540
It's happening somewhere earlier in the reader or something.

91
00:10:05,540 --> 00:10:25,140
如果表达式被引，求值结果是，这里(quote foo)的求值结果应该是foo自身

92
00:10:25,140 --> 00:10:27,530
一个常量

93
00:10:27,530 --> 00:10:30,645
也就是说求值结果是它自身

94
00:10:33,150 --> 00:10:33,660
该怎么来写呢？

95
00:10:33,660 --> 00:10:51,290
也就是列表的第二个部分了，应该是列表的CADR，所以这里我就写CADR

96
00:10:51,290 --> 00:10:52,510
表达式还可能是什么类型呢？

97
00:10:52,510 --> 00:11:04,160
还有lambda表达式，比如，(lambda (x) (+ x y))

98
00:11:04,160 --> 00:11:09,600
这样的话，我就必须得有方法来表示过程，也就是lambda求值的结果

99
00:11:09,600 --> 00:11:13,030
过程并不是lambda (x)表达式

100
00:11:13,030 --> 00:11:16,170
表达式只是对过程的文字描述

101
00:11:16,170 --> 00:11:27,360
相对地，我更希望执行过程的时候还要考虑环境的因素

102
00:11:27,360 --> 00:11:30,790
所以这里我们需要一些类型标志

103
00:11:30,790 --> 00:11:39,060
因为之后我们要凭借标志来区分哪些是过程，即lambda和一些原子元素求值的结果

104
00:11:39,060 --> 00:11:44,935
这里考虑历史因素，我就用closure作为类型标志

105
00:11:47,760 --> 00:11:49,920
现在来看看，哪些部分必不可少

106
00:11:49,920 --> 00:11:54,220
我需要形参列表和过程体

107
00:11:54,220 --> 00:12:03,795
也就是lambda的CDR，最后还有执行环境env

108
00:12:08,170 --> 00:12:18,520
单纯的语言使用者肯定没见过像这样的，它只是内部对过程对象的一种表示方法吧

109
00:12:18,520 --> 00:12:26,340
它包含了形参列表，过程体，执行环境，和表示自身为过程类型的标志

110
00:12:26,340 --> 00:12:28,080
接下来写代码

111
00:12:28,080 --> 00:13:10,250
如果表达式的CAR是'lambda，求值结果就是(list 'closure (cdr exp) env)

112
00:13:10,250 --> 00:13:15,190
这样就实现了环境模型中的那些规则

113
00:13:15,190 --> 00:13:19,210
对于从lambda构建一个过程是必不可少的

114
00:13:19,210 --> 00:13:32,240
而且closure里的这个环境就是过程真正执行的时候查找自由变量的地方

115
00:13:34,720 --> 00:13:35,920
所以这里应该有环境env

116
00:13:35,920 --> 00:13:39,210
必须把环境作为过程对象的一部分

117
00:13:39,210 --> 00:13:41,750
之后我们再来细看环境在其中的作用

118
00:13:41,750 --> 00:13:54,520
下一种情况，条件表达式，(cond (p1 e1) (p2 e2) ...)

119
00:13:54,520 --> 00:14:03,480
p是谓词，谓词求值结果非真即假，e是表达式，只有在谓词为真的时候才被求值

120
00:14:03,480 --> 00:14:06,790
如果不介意，我暂时称其为一组子句

121
00:14:06,790 --> 00:14:09,360
具体的求值过程写在别的地方

122
00:14:09,360 --> 00:14:12,420
让别人来考虑具体求值的部分

123
00:14:12,420 --> 00:14:32,050
这里继续写，如果(car exp)是'cond，然后就求值(cdr exp)

124
00:14:34,080 --> 00:14:38,380
记得带上环境

125
00:14:41,430 --> 00:14:56,590
好的，还有一种情况，比如(+ x 3)，一个操作符应用于操作数，它并不特殊

126
00:14:56,590 --> 00:14:59,850
就是说，它不属于这里的特殊形式

127
00:14:59,850 --> 00:15:09,650
上面写的这些都是特殊形式

128
00:15:09,650 --> 00:15:14,370
还是再提一下，如果这里用数据导向的方式来写，会更加的专业

129
00:15:14,370 --> 00:15:22,360
那样的话这里就不会是一系列的条件判断，数据导向会把这种按条件分配的过程表示的更为优雅

130
00:15:22,360 --> 00:15:26,710
并且，我还可以在不改动代码的情况下添加新的条件判断

131
00:15:26,710 --> 00:15:31,280
也可能那样会执行的更快，虽然有很多优势，这里我并不考虑那样来写

132
00:15:31,280 --> 00:15:34,890
现在的目的是把握eval过程的全局

133
00:15:34,890 --> 00:15:37,360
好吧，接着写

134
00:15:37,360 --> 00:15:38,560
要怎么做呢？

135
00:15:38,560 --> 00:15:40,965
这个(+ x 3)的例子里，我得做加法

136
00:15:44,350 --> 00:15:46,565
那样的话我就得清楚 + 到底是什么

137
00:15:46,565 --> 00:15:50,550
接着弄清楚 x 和 3 是什么

138
00:15:50,550 --> 00:15:58,020
然后再把 + 的结果应用于 x 与 3 的结果

139
00:15:58,020 --> 00:15:59,830
具体来写一下

140
00:15:59,830 --> 00:16:20,480
(apply (eval (car exp) env)，(car exp)就是操作符的部分

141
00:16:20,480 --> 00:16:24,050
执行(eval (car exp) env)就得到操作符的结果

142
00:16:24,050 --> 00:16:27,290
我还得求值操作数来得到具体参数

143
00:16:27,290 --> 00:16:38,835
执行evlist来求值操作数

144
00:16:41,940 --> 00:16:48,070
(evlist (cdr exp) env)，这个evlist稍后细讲

145
00:16:50,900 --> 00:16:56,590
你现在看到的就是一个完整的求值器

146
00:16:56,590 --> 00:17:07,470
它针对表达式的类型分情况处理，表达式可以是一个完整的程序或者简单表达式的组合

147
00:17:17,520 --> 00:17:20,089
不过我们还有些过程没有被定义

148
00:17:20,089 --> 00:17:21,780
接下来就看这些未定义的部分

149
00:17:21,780 --> 00:17:25,480
evcond稍后再说

150
00:17:25,480 --> 00:17:27,579
我得定义apply

151
00:17:27,579 --> 00:17:31,790
还有evlist，lookup

152
00:17:31,790 --> 00:17:33,430
我看看，没别的了吧？

153
00:17:33,430 --> 00:17:38,570
剩下的就是一些简单基本的东西了

154
00:17:38,570 --> 00:17:44,450
当然，这里可以写很多特殊形式，但是对于一个语言来说无疑很糟糕

155
00:17:44,450 --> 00:17:47,690
那会让语言变得很复杂

156
00:17:47,690 --> 00:17:54,010
保留字就不该比你能记住几个手指脚指的数目还多

157
00:17:54,010 --> 00:17:59,410
看到有些语言的保留字有上百个，我都不知道该说什么

158
00:17:59,410 --> 00:18:00,710
特殊形式也就是所谓定义保留字的地方

159
00:18:04,750 --> 00:18:09,640
好的，接下来，我们来看第二个核心的部分，apply

160
00:18:09,640 --> 00:18:11,590
它还做些什么呢？

161
00:18:11,590 --> 00:18:26,610
apply主要是将过程应用于实际参数，这里所说的是过程和参数的符号求值的结果，而不是过程和参数的符号

162
00:18:33,270 --> 00:18:43,280
所以我们定义apply过程，接受两个参数分别代表将应用的过程和这个过程的参数列表

163
00:18:47,110 --> 00:18:48,080
具体怎么来写呢？

164
00:18:48,080 --> 00:18:49,720
其实并不复杂

165
00:18:49,720 --> 00:18:50,970
分两种情况就够了

166
00:18:53,580 --> 00:19:06,930
如果这个过程是基本过程 -- 我不知道这个谓词具体是根据什么来判断的

167
00:19:06,930 --> 00:19:18,550
可能原理就像我们用'closure标志来表示组合结构的类型一样，我想可能是这样

168
00:19:18,550 --> 00:19:27,350
但是深究这个谓词并不必要，事实上你可能已经知道或是演绎过，我们并不需要任何基本过程

169
00:19:27,350 --> 00:19:33,190
我们没有基本过程只用lambda也照样可以正常计算

170
00:19:33,190 --> 00:19:34,750
但是有它们总归方便点儿

171
00:19:34,750 --> 00:19:38,060
接下来就是精彩的部分了，我先不细讲

172
00:19:38,060 --> 00:19:42,860
转到机器语言，执行apply-primop

173
00:19:42,860 --> 00:19:44,850
加法就是这样运算的

174
00:19:44,850 --> 00:19:46,100
执行加法指令

175
00:19:50,360 --> 00:19:54,940
然而一门语言有趣的部分在于谓词是如何组合在一起的

176
00:19:54,940 --> 00:19:56,910
我们接着往下看

177
00:19:56,910 --> 00:20:07,620
另一种可能就是这是一个求值lambda得到的过程，一个复合过程

178
00:20:07,620 --> 00:20:10,110
我们检测它的类型标志

179
00:20:10,110 --> 00:20:24,500
如果是'closure，我就得求值这个过程体

180
00:20:24,500 --> 00:20:44,260
这里我要将过程应用于其参数，也就是 将形参与实参绑定，添加入过程的运行环境，然后在此环境下对过程求值

181
00:20:47,030 --> 00:20:48,280
这句话很长

182
00:20:51,130 --> 00:20:52,822
但是描述的内容足够简单

183
00:20:52,822 --> 00:20:56,214
一会儿可能会出现许多CAR CDR CADR ...

184
00:20:56,214 --> 00:20:59,400
现在我先要得到过程体

185
00:20:59,400 --> 00:21:02,960
过程体如何取出呢？

186
00:21:02,960 --> 00:21:06,130
这一部分是CAR，剩下的是CDR部分

187
00:21:06,130 --> 00:21:13,200
然后这里就是CADR，我看看，过程体就在整个过程第二部分的第二部分

188
00:21:13,200 --> 00:21:19,170
也就是CADR的CADR，或者简写为CADADR

189
00:21:19,170 --> 00:21:27,495
这里取整个过程的CADADR

190
00:21:30,260 --> 00:21:43,500
为了在参数绑定后的新环境之中执行这个过程，我还得取到过程的形式参数，形参怎么取呢？

191
00:21:43,500 --> 00:21:48,780
就是CDR的CAR，很混乱不是吗？

192
00:21:52,440 --> 00:21:55,440
过程的CADR

193
00:21:55,440 --> 00:22:04,540
绑定形参实参添加进环境中，环境也是随着过程被传递进来

194
00:22:04,540 --> 00:22:16,315
也就是CDR的CDR的CAR，过程的CADDR

195
00:22:20,290 --> 00:22:39,000
(bind (caadr proc) args (caddr proc)) 如果我有点强迫症，这里就会非常谨慎，我会在后面多加一个判断来处理错误情况，比如你对参数应用的是一个过程吗？

196
00:22:39,000 --> 00:22:42,570
如果不是，这里就是未定义的过程类型

197
00:22:42,570 --> 00:22:45,500
这里保持原样

198
00:22:45,500 --> 00:22:57,610
下面加上else，如果出现错误情况

199
00:22:57,610 --> 00:23:10,750
插个话，目前很多专业用途的系统中，内部的结构也与这类似，主要是分条件判断，分配处理不同情况

200
00:23:10,750 --> 00:23:16,220
回到这里，我可能还会添加新的条件判断，比如这是编译过的代码吗？

201
00:23:16,220 --> 00:23:17,020
这很重要

202
00:23:17,020 --> 00:23:25,880
这样的话我就可以区分一段代码是我通过解释代码对lambda求值得到的结果还是通过编译器编译代码得到的结果

203
00:23:25,880 --> 00:23:27,230
之后再讨论这个话题

204
00:23:27,230 --> 00:23:30,510
又或许是我必须要执行的一段Frotran代码

205
00:23:30,510 --> 00:23:32,920
如果这种可能发生了，记住，就在这里把情况加进去

206
00:23:32,920 --> 00:23:44,360
事实上，我在写这个求值器的时候，有一个内在的假定即这是一种Lisp语言的实现方式，因为我大量使用了CAR CDR之类

207
00:23:44,360 --> 00:23:46,750
CAR意味着操作符，CDR意味着操作数

208
00:23:46,750 --> 00:23:56,160
在这种情形下，就可以想像已经存在了一个抽象的语法解析器，通过它我们就可以取到操作符操作数等等

209
00:23:56,160 --> 00:24:01,570
在清楚了这个假定之后，你完全可以用ALGOL再来实现这个求值器

210
00:24:03,760 --> 00:24:08,660
写完apply之后，发现又引入了一些未定义的过程

211
00:24:10,810 --> 00:24:15,050
我先不操心这两个，下面这个BIND还是挺有意思的

212
00:24:17,930 --> 00:24:20,550
现在我们来快速过一遍，结束这一部分

213
00:24:20,550 --> 00:24:23,060
只剩下两块黑板了，因此它们加起来代码并不多

214
00:24:27,056 --> 00:24:30,070
不过代码还得精心剪裁一番才可以全部放的进黑板

215
00:24:30,070 --> 00:24:30,980
嗯，还剩下点什么？

216
00:24:30,980 --> 00:24:33,730
我们得定义那边的evlist

217
00:24:33,730 --> 00:24:44,240
evlist不过是遍历一串操作数生成实际参数

218
00:24:44,240 --> 00:24:45,820
但是还是写出来看看

219
00:24:45,820 --> 00:24:53,610
还要把它写出来是为了一个神秘的原因，就是我想要求值器简单到可以求值自身

220
00:24:56,450 --> 00:25:00,230
这一点还是有点重要的

221
00:25:00,230 --> 00:25:02,850
现在我就把它完全写在这里

222
00:25:02,850 --> 00:25:06,080
看，我完全不用操心是否传递入的参数是一个过程

223
00:25:06,080 --> 00:25:08,980
求值器并不会真正使用到它们

224
00:25:08,980 --> 00:25:10,880
求值器也不会生成一个是过程的值

225
00:25:10,880 --> 00:25:24,070
因此，如果有一个不同的，和scheme非常相似的语言，它也可以像scheme一样求值比如使用过程参数，返回过程为值，允许过程作为数据

226
00:25:24,070 --> 00:25:31,580
值得注意的是，如果我对ALGOL语言求值，也可以使用这个求值器，尽管ALGOL并不允许过程作为返回值

227
00:25:31,580 --> 00:25:34,050
因为这个解释器并没有对这些事情做过什么假定

228
00:25:34,050 --> 00:25:40,640
事实上，如果被求值的语言真的被限定了不能做这做那，没关系，只能算它们没有使用到这些高级功能

229
00:25:40,640 --> 00:25:44,070
这也是为什么我可以将求值器组织的如此简单

230
00:25:44,070 --> 00:25:47,810
这几乎是所有现存语言求值器的核心

231
00:25:47,810 --> 00:25:49,420
回到这个定义上来

232
00:25:49,420 --> 00:25:53,820
evlise，它是什么呢？

233
00:25:53,820 --> 00:26:33,260
这个过程也有两个参数，l和env，l是所有参数的列表，如果l为空，就返回一个空列表，否则就先在环境中求值第一个参数

234
00:26:33,260 --> 00:26:50,130
求值第一个参数之后，我想要在当前环境递归evlist求值CDR部分，和第一个求值结果连接为列表

235
00:26:53,350 --> 00:27:03,620
闭合括号evlist cons else cond lambda define，还有一个过程我也想写在这里

236
00:27:03,620 --> 00:27:05,470
它是整件事的关键部分

237
00:27:05,470 --> 00:27:08,130
还要深入一个层次

238
00:27:14,540 --> 00:27:18,880
条件式 -- 在剩下的过程中，条件式是唯一一个非常重要的过程

239
00:27:18,880 --> 00:27:25,530
除了这个，我们还有lookup bind的过程要讨论

240
00:27:25,530 --> 00:27:31,600
但是在这个讨论事情相对具体的层次上，下一个重要的事就是你如何处理条件式

241
00:27:31,600 --> 00:27:33,330
这里，条件式具体要怎么写？

242
00:27:37,670 --> 00:27:44,720
它是一个过程，参数是一串子句和环境

243
00:27:47,340 --> 00:27:49,820
它做些什么呢？

244
00:27:49,820 --> 00:28:04,520
如果这里没有子句，我得有一个返回值

245
00:28:04,520 --> 00:28:06,540
可能是一个错误

246
00:28:06,540 --> 00:28:10,060
假设它遍历完了所有条件，都没有符合的，接下来发生什么还真不好说

247
00:28:10,060 --> 00:28:13,650
这完全取决于我，作为一个程序员可以选择应该怎么处理

248
00:28:13,650 --> 00:28:20,100
对我来说实在太方便了，现在我写一个空列表作为返回值，完全无碍

249
00:28:20,100 --> 00:28:23,110
如是有些人倾向于错误检测，他们可以在这里写点别的

250
00:28:23,110 --> 00:28:25,570
下面的更有意思

251
00:28:25,570 --> 00:28:40,265
这里有一系列的子句，每个子句都是一个列表，假如我遇到一个else子句，子句的谓词部分应该是子句的CAAR

252
00:28:43,560 --> 00:28:51,090
所有子句中第一个子句的第一个部分

253
00:28:51,090 --> 00:28:59,800
如果是else，就意味着整个条件式的结果就是执行这个else子句中表达式的结果

254
00:28:59,800 --> 00:29:22,195
所以接着对CADAR部分在当前环境下求值，就是第一个子句的第二个部分

255
00:29:26,620 --> 00:29:29,630
下一种可能性更有意思

256
00:29:29,630 --> 00:29:44,360
如果不是else子句，而且子句的谓词结果是false -- 我们接着写

257
00:29:44,360 --> 00:30:04,180
在当前环境下求值子句的谓词部分，如果是false，这就意味着还得接着判断下面的子句

258
00:30:04,180 --> 00:30:05,990
第一个就扔掉不管了

259
00:30:05,990 --> 00:30:16,700
我们还得在当前环境下，继续递归evcond循环子句的CDR部分

260
00:30:21,240 --> 00:30:41,960
又或者，我遇到了一个真子句，即求值子句的谓词部分结果为真

261
00:30:48,200 --> 00:30:51,210
条件式就要到尾声了

262
00:30:51,210 --> 00:30:53,730
非常近了

263
00:30:53,730 --> 00:30:56,210
把这一部分结束

264
00:30:56,210 --> 00:31:01,220
回到全局再看一遍求值器，你已经对它有一个完整的把握了

265
00:31:01,220 --> 00:31:04,040
接着来看一张幻灯片

266
00:31:08,980 --> 00:31:11,980
bind的定义

267
00:31:11,980 --> 00:31:15,460
bind在环境中添加新的绑定

268
00:31:15,460 --> 00:31:22,800
我们这里先依照环境的数据结构构造一个frame

269
00:31:22,800 --> 00:31:28,080
环境就是由一系列的frame组成的

270
00:31:28,080 --> 00:31:49,690
所以对于环境来说，我把一个新的frame和环境连接在一起就构成了新的环境，新的frame是由pair-up对形参与实参进行绑定得到的结果

271
00:31:49,690 --> 00:31:58,391
环境也就是一个列表而已，构造一个新frame元素，添加入列表就构成了新环境

272
00:31:58,391 --> 00:32:01,540
其实pair-up非常简单

273
00:32:01,540 --> 00:32:09,720
对于一个变量的列表和一个值的列表，两个列表中元素个数应该相同

274
00:32:09,720 --> 00:32:12,990
如果不同，就是实参的数目不对了

275
00:32:12,990 --> 00:32:18,560
假如值遍历完了，还剩下有变量，说明实参给少了

276
00:32:18,560 --> 00:32:42,950
如果没有遇到错误，即变量和值是可以对上号的，就应该用第一个变量和第一个值构造一个序对，和pair-up对两列表CDR的求值结果相连接

277
00:32:42,950 --> 00:32:46,620
lookup也简单

278
00:32:46,620 --> 00:32:54,650
假使我要在环境中查找一个变量，环境是空的，这个变量就是未绑定的

279
00:32:54,650 --> 00:33:05,930
否则，就调用一个新的过程来从环境的第一个frame开始查找变量

280
00:33:05,930 --> 00:33:09,200
因为环境不是空的，所以一定有第一个frame

281
00:33:09,200 --> 00:33:11,140
所以我就在第一个frame中查找

282
00:33:11,140 --> 00:33:15,150
找到的序对也就是这里的vcell

283
00:33:15,150 --> 00:33:23,720
如果vcell为空，我就需要在环境中剩下的frame中查找

284
00:33:23,720 --> 00:33:25,990
vcell为空意味着当前frame没有找到变量

285
00:33:25,990 --> 00:33:32,010
如果没有找到，assq就会返回空值

286
00:33:32,010 --> 00:33:41,050
如果找到了，值就应该是vcell的CDR部分，因为vcell是一个变量和值的序对

287
00:33:41,050 --> 00:33:45,000
因此CDR就取到了值

288
00:33:45,000 --> 00:33:47,970
assq这个过程你们之前见过

289
00:33:47,970 --> 00:33:53,760
assq取一个符号和一系列序对的列表，如果列表为空，变返回'()

290
00:33:53,760 --> 00:33:59,820
如果符号等于列表中第一个 -- 这里写错了

291
00:33:59,820 --> 00:34:04,160
应该是CAAR，大家注意了

292
00:34:07,730 --> 00:34:08,980
就是这里，看见了吗？

293
00:34:13,121 --> 00:34:35,190
如果符号等于列表的CAAR，然后就取列表的第一个序对元素作为返回值，这就是我们要找的绑定；如果符号与之不相同，就在剩下的列表中继续查找。很抱歉刚才幻灯片上面写错了

294
00:34:35,190 --> 00:34:39,639
到现在为止，你们也已看到了全貌

295
00:34:41,880 --> 00:34:49,600
虽然用很难看的编程方式书写出来，但是仍然不能掩盖它的美丽与优雅，这正是语言的核心所在

296
00:34:49,600 --> 00:34:51,460
这样优美的程序，我们可以多看一会儿[骗人啊，说好的只写一黑板呢，又刷出N张幻灯片啊]

297
00:34:56,749 --> 00:35:49,750
[MUSIC PLAYING]

298
00:35:49,750 --> 00:35:51,000
大家有什么问题吗？

299
00:36:01,180 --> 00:36:04,044
没有的话就休息一会儿吧

300
00:36:04,044 --> 00:36:56,780
[MUSIC PLAYING]

301
00:36:56,780 --> 00:37:03,470
这一节我们用一个实例来理解一下求值器的运作过程

302
00:37:03,470 --> 00:37:11,500
我们根据求值器的工作过程，手写出解释器中的代换过程

303
00:37:11,500 --> 00:37:25,330
因为这个求值器的并没有赋值与定义的实现，所以我们只管放心的代换，不用担心任何副作用

304
00:37:25,330 --> 00:37:30,690
我举一个特别点儿的例子吧

305
00:37:30,690 --> 00:37:59,890
(eval '(((lambda(x) (lambda(y) (+ x y))) 3) 4) <e0>)

306
00:38:04,930 --> 00:38:14,300
一个参数为x的过程，生成一个参数为y的过程，其中运算x + y

307
00:38:14,300 --> 00:38:17,960
外层的这个过程应用于数字3

308
00:38:17,960 --> 00:38:21,400
所以x应该是3

309
00:38:21,400 --> 00:38:26,167
生成的结果应该是一个参数为y的过程，应用于数字4

310
00:38:28,910 --> 00:38:34,790
然后要做的也很简单，得到x与y的和

311
00:38:34,790 --> 00:38:37,660
具体做之前，先来构造环境

312
00:38:37,660 --> 00:38:44,460
我相信你们对于环境已经了然于胸

313
00:38:44,460 --> 00:38:56,740
我们从全局环境开始，称之为e0

314
00:38:56,740 --> 00:39:31,270
里面应该有+、*的过程定义 -- 我这里用希腊字母来表示过程对象，有没有很好玩儿 -- 还有 - / CAR CDR CONS EQ?等等，所有你能想到的基本过程都在这里

315
00:39:31,270 --> 00:39:39,220
每个符号都有一个过程对象，由机器底层实现的，这就是环境e0

316
00:39:39,220 --> 00:39:42,940
这对求值意味着什么呢？

317
00:39:42,940 --> 00:39:48,670
现在我们开始求值这个例子，从特殊形式开始查找，第一，这不是一个数字

318
00:39:48,670 --> 00:39:50,380
也不是符号

319
00:39:53,210 --> 00:39:56,520
这不是一个引用表达式

320
00:39:56,520 --> 00:40:00,600
这其实是一个被引用的表达式，但不是我们所关注的那种 引用表达式

321
00:40:00,600 --> 00:40:05,890
问题在于，是否被引的就一定是引用表达式？

322
00:40:05,890 --> 00:40:07,960
现在求值这个表达式

323
00:40:07,960 --> 00:40:11,410
可以理解为 ' 说明这是一个特殊的表达式

324
00:40:11,410 --> 00:40:12,660
并非是引用表达式

325
00:40:15,230 --> 00:40:19,120
继续我们对特殊形式的判断中来，表达式也不以lambda开头

326
00:40:19,120 --> 00:40:22,030
也不以cond开头

327
00:40:22,030 --> 00:40:26,310
因此它不在特殊形式之列，它属于操作符应用于操作数之类

328
00:40:26,310 --> 00:40:28,570
这是一个组合式

329
00:40:28,570 --> 00:40:36,480
这一部分是它的操作符，这里是操作数

330
00:40:40,130 --> 00:41:24,450
根据eval的规则，变换成为(apply (eval '((lambda(x) (lambda(y) (+ x y))) 3) <e0>) (evlist '(4) <e0>)

331
00:41:29,010 --> 00:41:36,840
我把e0写的很特别是来强调它是环境的身份

332
00:41:36,840 --> 00:41:39,890
我无法为它命名，因为命名需要其它环境

333
00:41:41,960 --> 00:41:47,730
So this is just a representation of what would be a quoted expression, if you will.

334
00:41:47,730 --> 00:41:53,040
The data structure, which is the environment, goes there.

335
00:41:53,040 --> 00:41:55,850
好的，经过变换就成了这样

336
00:41:55,850 --> 00:41:59,610
为了执行apply，我得先执行eval和evlist

337
00:41:59,610 --> 00:42:03,770
evlist简单点，我们先计算这个吧

338
00:42:03,770 --> 00:42:09,520
上面的一行复制下来

339
00:42:09,520 --> 00:42:11,000
代换的过程中我们得重复不少笔墨

340
00:42:18,530 --> 00:42:23,350
抄写的时候我就不说什么了，这样快一点儿

341
00:42:26,100 --> 00:42:48,910
下面evlist的部分就代换成为 (cons (eval '4 <e0>) (evlist '() <e0>))

342
00:42:52,580 --> 00:42:55,800
步骤开始有点乏味，我开始想略过一点了

343
00:42:59,870 --> 00:43:20,240
上面的再抄下来

344
00:43:20,240 --> 00:43:21,490
一字不差吧

345
00:43:24,690 --> 00:43:28,790
到下面的eval，4是一个数字

346
00:43:28,790 --> 00:43:35,280
4求值出来还是4

347
00:43:35,280 --> 00:43:39,240
evlist这里参数是空列表，结果相应也是空列表

348
00:43:43,270 --> 00:43:48,710
一起代换过来，就是(cons 4 '())

349
00:43:48,710 --> 00:44:13,940
上面的再抄下来，下面的(cons 4 '())就是'(4)

350
00:44:13,940 --> 00:44:15,190
变换结果就是这样

351
00:44:18,100 --> 00:44:20,360
我们来看下一个有趣的部分

352
00:44:20,360 --> 00:44:23,070
这一行怎么来变换？

353
00:44:23,070 --> 00:44:29,460
变换这一行之前我得先变换eval这部分

354
00:44:29,460 --> 00:44:31,680
这一部分的表达式也属于操作符应用操作数的类型

355
00:44:31,680 --> 00:44:33,570
也不属于特殊形式

356
00:44:33,570 --> 00:44:46,570
操作符是这一大部分，应用于操作数，整体是一个组合式

357
00:44:46,570 --> 00:44:52,370
我们很清楚变换的规则，它就在eval内部条件式的最后

358
00:44:52,370 --> 00:45:01,160
变换这一部分，就大概像(apply (eval operator) (evlist operands))这样

359
00:45:01,160 --> 00:45:25,350
我们接着写，(apply (apply (eval '(lambda(x) (lambda(y) (+ x y))) <e0>)

360
00:45:30,520 --> 00:45:35,230
操作数这里的变换我就直接写结果了，因为和前面是一样的

361
00:45:35,230 --> 00:45:39,330
过程应用于列表'(3)，再应用于'(4)

362
00:45:42,780 --> 00:45:44,410
我们接着看

363
00:45:44,410 --> 00:45:49,450
求值lambda表达式生成一个过程对象

364
00:45:52,030 --> 00:46:12,130
继续变换，(apply (apply '(closure ((x) (lambda(y) (+ x y))))

365
00:46:12,130 --> 00:46:20,630
这个过程内部返回一个形参为y的过程，对x和y求和

366
00:46:23,210 --> 00:46:30,340
还要记得环境e0，因为在环境下求值才有意义

367
00:46:30,340 --> 00:46:33,040
e0现在也是closure对象的一部分了

368
00:46:33,040 --> 00:46:41,300
应用予'(3)，再应用于'(4)

369
00:46:47,390 --> 00:46:57,150
这样一步步的变换过来，现在构造了一个过程对象，并且包含了环境e0

370
00:46:57,150 --> 00:46:58,620
现在是过程应用参数求值的时候了

371
00:46:58,620 --> 00:47:02,710
我们得把过程应用于实际参数

372
00:47:02,710 --> 00:47:07,380
这里的过程并不是基本过程

373
00:47:07,380 --> 00:47:13,710
事实上看到标志'closure就已经知道这不是基本过程了，而且这里我们还需要进行参数绑定

374
00:47:13,710 --> 00:47:15,830
必须要绑定

375
00:47:15,830 --> 00:47:28,230
这里构造一个新环境，父环境是e0

376
00:47:30,320 --> 00:47:31,570
命名这个环境为e1

377
00:47:34,620 --> 00:47:36,040
这里要绑定些什么呢？

378
00:47:36,040 --> 00:47:38,620
变量x绑定为值3

379
00:47:38,620 --> 00:47:41,480
这里写x=3

380
00:47:41,480 --> 00:47:42,730
这样就行

381
00:47:44,940 --> 00:47:46,240
新环境叫e1

382
00:47:46,240 --> 00:48:00,290
这样的话，里面的过程，即(lambda(y) (+ x y))就应该在e1的环境下来求值了

383
00:48:00,290 --> 00:48:16,520
即 (apply (eval '(lambda(y) (+ x y)) <e1>)

384
00:48:20,660 --> 00:48:28,680
应用于参数列表'(4)

385
00:48:28,680 --> 00:48:33,110
到了这里，变换过程就变得很清晰了，我知道该做什么

386
00:48:33,110 --> 00:48:52,150
这和上面的很类似，继续变换(apply '(closure ((y) (+ x y)) <e1>)

387
00:48:55,790 --> 00:48:57,800
你应该已经知道了

388
00:48:57,800 --> 00:49:00,140
我构造了一个closure对象

389
00:49:00,140 --> 00:49:01,790
放在这里

390
00:49:01,790 --> 00:49:03,040
这里也有一个，是前面lambda (x)的那个

391
00:49:06,230 --> 00:49:08,080
这是现在的这个

392
00:49:08,080 --> 00:49:17,880
closure内部是有参数为y的过程体和环境e1

393
00:49:17,880 --> 00:49:20,435
这就是这里的closure

394
00:49:23,040 --> 00:49:26,230
将这个过程应用于'(4)

395
00:49:30,690 --> 00:49:31,940
很简单

396
00:49:36,830 --> 00:49:49,540
这就意味着我还得构造一个新环境，绑定变量y为数字4

397
00:49:49,540 --> 00:49:52,460
这个是新环境，称为e2

398
00:49:55,870 --> 00:50:01,910
接着就是在环境e2中求值过程体(+ x y)

399
00:50:01,910 --> 00:50:13,710
然后变换为，(eval '(+ x y) <e2>)

400
00:50:13,710 --> 00:50:37,340
继续变换，(apply (eval '+ <e2>) (evlist '(x y) <e2>))

401
00:50:44,880 --> 00:50:45,590
我们来看

402
00:50:45,590 --> 00:50:54,190
接着写，(apply ，eval这部分在环境中寻找符号'+

403
00:50:54,190 --> 00:51:01,780
所以我们从e2开始找，它不在这里，也不在e1，哦，它是一个基本操作符

404
00:51:01,780 --> 00:51:04,745
用于做加法

405
00:51:08,490 --> 00:51:14,370
把它应用于x y在e2中解析到的结果

406
00:51:14,370 --> 00:51:18,340
我们知道x是3 y是4

407
00:51:18,340 --> 00:51:23,936
所以这里写'(3 4)

408
00:51:23,936 --> 00:51:26,280
然后就神奇的得到结果7

409
00:51:30,520 --> 00:51:40,470
我把这个例子具体的演示一遍是想让你们清楚的看到，求值过程中实际传递的是什么，每一部分的职能又是什么

410
00:51:40,470 --> 00:51:41,700
所以这里是一些什么呢？

411
00:51:41,700 --> 00:51:46,520
一个eval，一个apply，两个主角

412
00:51:49,370 --> 00:51:52,320
在它们之间是一个大循环

413
00:51:52,320 --> 00:52:06,270
eval将过程与参数传递予apply

414
00:52:06,270 --> 00:52:09,710
也有些事情eval可以自己做

415
00:52:09,710 --> 00:52:10,860
一些内部的事情吧

416
00:52:10,860 --> 00:52:12,700
没多大意思

417
00:52:12,700 --> 00:52:16,240
eval也逐个解析每个形参

418
00:52:16,240 --> 00:52:17,650
也没什么意思

419
00:52:17,650 --> 00:52:22,300
apply实际执行一些过程比如+

420
00:52:22,300 --> 00:52:32,880
然而如果不是基本过程不能直接执行，它就再度将表达式与环境传递予eval

421
00:52:35,470 --> 00:52:43,740
参数和过程记录了计算的状态和环境下的表达式

422
00:52:43,740 --> 00:52:48,820
And so what we're actually going to do next is not the complete state, because it doesn't say who wants the answers.

423
00:52:51,280 --> 00:52:58,970
But what we're going to do-- it's always got something like an expression of environment or procedure and arguments as the main loop that we're going around.

424
00:52:58,970 --> 00:53:12,280
这里也有一些副循环比如eval中的evlist、evcond和apply中的apply

425
00:53:16,140 --> 00:53:18,500
但是它们并不是最主要的

426
00:53:18,500 --> 00:53:21,860
这整个就是我想让你们看到的

427
00:53:21,860 --> 00:53:23,110
有什么问题吗？

428
00:53:25,930 --> 00:53:28,690
你说

429
00:53:28,690 --> 00:53:37,070
我不明白为什么x是3而不是4

430
00:53:37,070 --> 00:53:41,310
在那个部分 教授：这里

431
00:53:41,310 --> 00:53:43,310
x为什么是3？

432
00:53:43,310 --> 00:53:51,040
x是外层过程的参数，y是内层过程的参数

433
00:53:51,040 --> 00:53:52,570
哦，明白了

434
00:53:52,570 --> 00:53:55,280
变换的过程中我已经非常注意了

435
00:53:55,280 --> 00:54:00,610
现在我把这个示例的过程按照美观的排版方式给你再写一遍

436
00:54:00,610 --> 00:54:03,830
这样做的原因是因为你可以读错了这个程序

437
00:54:03,830 --> 00:54:26,140
所以我本着美观打印的原则把这个例子再写一遍

438
00:54:26,140 --> 00:54:28,810
这个和刚才写的那个是一样的

439
00:54:28,810 --> 00:54:40,735
然后你会发现最外层是一个过程调用 -- 我换根白粉笔 -- 这一部分是一个过程调用

440
00:54:44,300 --> 00:54:51,040
这一部分是操作符，下面的3是操作数

441
00:54:51,040 --> 00:54:54,900
所以x应该是3

442
00:54:54,900 --> 00:55:01,530
这个过程执行后的结果是一个参数为y的过程，再应用于4

443
00:55:01,530 --> 00:55:04,190
所以你可能刚刚看错了

444
00:55:04,190 --> 00:55:13,340
刚才你所指的那里，过程对象和x

445
00:55:13,340 --> 00:55:18,980
这个过程应用于下面的列表 '(3)

446
00:55:18,980 --> 00:55:24,080
应用后得到的结果再应用于'(4)

447
00:55:24,080 --> 00:55:25,330
还有疑问吗？

448
00:55:28,600 --> 00:55:30,900
那就休息一下吧

449
00:55:30,900 --> 00:55:33,735
嗯

450
00:55:33,735 --> 00:56:08,410
[MUSIC PLAYING]

451
00:56:08,410 --> 00:56:17,960
现在大家可能开始嘀咕了，GJS说了这么多没用的有什么意义？

452
00:56:20,740 --> 00:56:24,800
很多话没多大意义，而且还不好理解

453
00:56:24,800 --> 00:56:30,892
毕竟他还是给我详细解释了Lisp，并且还在黑板上写了程序

454
00:56:30,892 --> 00:56:38,370
这个程序是用Lisp所写的Lisp的解释器，但是要运行它你必须得先有一个Lisp解释器啊

455
00:56:38,370 --> 00:56:44,150
理解了这个程序就算是完全了解Lisp了吗？

456
00:56:44,150 --> 00:56:45,795
这不是很空洞吗？

457
00:56:48,490 --> 00:56:50,990
而且非常诡异

458
00:56:50,990 --> 00:56:52,430
它是不是还隐藏了什么？

459
00:56:56,070 --> 00:57:03,105
我们想想看，这整件事是否很像幻灯片上这幅埃舍尔所画的手

460
00:57:06,180 --> 00:57:17,110
eval和apply彼此画出彼此，组成了整个程序，它完全是自己画出了自己

461
00:57:17,110 --> 00:57:20,550
埃舍尔聪明绝顶，他看透了其中的玄机不过却没有为其命名

462
00:57:23,910 --> 00:57:36,090
我现在要做的就是，使你们相信，这一切都是有意义的，顺便地提到，我们甚至连定义都不需要

463
00:57:36,090 --> 00:57:44,890
这可能有点打破常规了，我们要做实际计算却不需要定义，这有点违反数学直觉

464
00:57:49,070 --> 00:57:50,690
我们来实际的看一下

465
00:57:50,690 --> 00:57:54,870
考虑下面的这一小段程序，它有什么作用？

466
00:57:54,870 --> 00:57:57,035
一个计算指数的程序

467
00:58:07,270 --> 00:58:22,070
(define expt (lambda (x n) (cond ((= n 0) 1) 

468
00:58:22,070 --> 00:58:33,930
(else (* x (expt x (- n 1))))

469
00:58:42,858 --> 00:58:46,630
应该没错

470
00:58:46,630 --> 00:58:49,470
一个递归定义

471
00:58:49,470 --> 00:58:56,410
用expt自身来定义expt

472
00:58:56,410 --> 00:59:05,650
之前提到过，你的高中几何老师教这里的时候一定费了不少功夫

473
00:59:05,650 --> 00:59:07,910
这样定义合理吗？

474
00:59:07,910 --> 00:59:13,430
为什么这种自己定义自己的无赖方式会说得过去呢？

475
00:59:13,430 --> 00:59:17,600
首先我要说的是，高中老师教的那一套确实说不过去

476
00:59:20,370 --> 00:59:24,490
比如来看几组方程

477
00:59:24,490 --> 00:59:33,070
x + y = 3    x - y = 1

478
00:59:33,070 --> 00:59:37,490
看，这个用y来告诉你x是什么，下面这个用x来告诉你y是什么

479
00:59:40,150 --> 00:59:42,950
碰巧这组方程有唯一的解

480
00:59:55,910 --> 01:00:06,600
然而，如果我写 2x + 2y = 6

481
01:00:06,600 --> 01:00:09,610
上面这两个联立，就有无穷个解了

482
01:00:15,730 --> 01:00:24,070
我再写 x - y = 2，下面的这两个联立完全没有解

483
01:00:29,820 --> 01:00:39,510
这里三组方程式，这组，这组和这组

484
01:00:39,510 --> 01:00:42,900
它们的解的数目完全不同

485
01:00:42,900 --> 01:00:45,760
解的数目通过方程的形式是看不出来的

486
01:00:45,760 --> 01:00:48,350
三组方程看起来形式一样

487
01:00:48,350 --> 01:00:50,205
判断解的数目需要具体的来看方程的内容

488
01:00:53,000 --> 01:00:59,660
我不能看一眼方程的外貌就判断出解的数目来，必须要仔细辨别方程的内容

489
01:00:59,660 --> 01:01:05,100
比如，这个线性方程，我们具体看方程的系数是什么？

490
01:01:05,100 --> 01:01:16,030
所以我不能仅仅依照方程形式就来判断解是什么样子，就比如这个，你说，expt是这个递归方程的解

491
01:01:16,030 --> 01:01:26,040
你还说，expt这个过程，你在这里调用，它就真的计算返回相应的指数

492
01:01:26,040 --> 01:01:37,200
我也不清楚，简单看看这个方程的形式，我也不知道expt是有一个解，无限个解还是根本没有解

493
01:01:37,200 --> 01:01:40,490
要做具体的判断必须明白 它是如何计算的 类似的具体的细节

494
01:01:40,490 --> 01:01:42,900
在编程中弄清楚可不像在线性代数中那么简单了

495
01:01:42,900 --> 01:01:45,210
在编程中定理并不多

496
01:01:48,450 --> 01:01:53,970
现在我先把这些个方程重写一遍

497
01:01:53,970 --> 01:01:56,770
因为我们要讨论的是这种形式的方程

498
01:01:56,770 --> 01:02:04,730
我只是想在这几个方程上做一些变换，以便于我们理解那边的方程

499
01:02:04,730 --> 01:02:19,380
我们把中间这个方程组重写为 x = 3 - y   y = x - 1 

500
01:02:22,010 --> 01:02:24,050
这种变换叫什么来着？

501
01:02:24,050 --> 01:02:26,095
一个线性变换，记为t

502
01:02:29,430 --> 01:02:37,370
所以这组方程也可以写作 <x y> = T<x y>

503
01:02:42,990 --> 01:02:44,560
我在找什么？

504
01:02:44,560 --> 01:02:47,040
我在找T的不动点

505
01:02:47,040 --> 01:02:59,350
不动点也就是方程的解

506
01:03:01,910 --> 01:03:10,880
所以我们已知的求不动点的方法也可以用在这里

507
01:03:10,880 --> 01:03:22,410
假如我有一个根据不动点来求得方程不动点的方法 -- 可能不管用 -- 可能也适用于这种情况的方程

508
01:03:27,240 --> 01:03:30,260
我们来把这个想像为方程，感受一下

509
01:03:30,260 --> 01:03:45,010
这个表达式，其中有一些名字，上面对应着值的约束，不仅仅只用机械的代换来看它

510
01:03:47,740 --> 01:03:51,220
这个方程就是我要求解的方程

511
01:03:51,220 --> 01:03:53,960
我们来试试看

512
01:03:53,960 --> 01:04:00,320
首先，类比T的形式我先写一个函数

513
01:04:00,320 --> 01:04:06,960
这个函数的不动点就是我们想要的答案

514
01:04:11,950 --> 01:04:14,240
来看这个过程  F

515
01:04:16,870 --> 01:04:19,340
用F来计算函数

516
01:04:19,340 --> 01:04:33,430
F有一个参数g，g是一个过程，有两个参数x和n

517
01:04:33,430 --> 01:05:00,690
g的过程体是 (cond ((= n 0) 1) (else (* x (g (x (- n 1))))))

518
01:05:03,370 --> 01:05:30,930
f是一个过程，如果这个方程有解，如果我有一个计算指数的过程，我用f来调用这个过程，结果也应该是一个计算指数的过程

519
01:05:37,460 --> 01:05:39,420
它是怎么做的呢？

520
01:05:39,420 --> 01:05:54,670
假设g是一个指数计算过程，代入这里，生成一个有两个参数x和n的过程，其中如果n=0，结果就是1，这一点符合指数的定义

521
01:05:54,670 --> 01:06:03,470
否则，就返回指数过程g计算得到的x^n-1与x的乘积

522
01:06:03,470 --> 01:06:14,620
如果对x^n-1的计算没有问题，那么返回的这个过程计算x^n也一定没有问题，这就是正确的指数计算过程

523
01:06:17,500 --> 01:06:32,320
所以，expt是F方程的不动点

524
01:06:37,550 --> 01:06:40,060
现在我们的问题在于，万一不止一个不动点

525
01:06:40,060 --> 01:06:43,270
万一根本没有不动点

526
01:06:43,270 --> 01:06:44,810
所以我们必须求出不动点

527
01:06:48,290 --> 01:06:49,540
解出方程

528
01:06:52,160 --> 01:06:55,580
求不动点有很多种方式

529
01:06:55,580 --> 01:07:00,815
我们一开始的时候举过cos的例子

530
01:07:06,080 --> 01:07:16,090
计算器调成弧度制，然后一直按cosine，最后数字会稳定在0.73 0.74左右

531
01:07:16,090 --> 01:07:17,340
记不清是哪个了

532
01:07:22,900 --> 01:07:33,770
类似的，不断进行迭代，说不定就可以找出方程的不动点

533
01:07:33,770 --> 01:07:39,910
碰碰运气，来试试这种方法 

534
01:07:39,910 --> 01:07:48,030
来看这张幻灯片

535
01:07:48,030 --> 01:07:51,390
这有一连串的过程

536
01:07:56,400 --> 01:08:02,940
e0什么也不做

537
01:08:02,940 --> 01:08:07,780
如果将它应用于参数肯定会报错

538
01:08:07,780 --> 01:08:09,030
没什么用

539
01:08:14,480 --> 01:08:20,080
然而，我可以应用F逐渐逼近

540
01:08:20,080 --> 01:08:26,990
e0应该是最差的近似了，因为它什么也做不了

541
01:08:26,990 --> 01:08:37,380
假设我用调用过程F应用于e0

542
01:08:37,380 --> 01:08:40,729
e0代换了g，就在这里

543
01:08:40,729 --> 01:08:43,859
我们来看看，e1是什么？

544
01:08:43,859 --> 01:08:49,325
e1是一个可以计算x的0次方的过程，没什么问题

545
01:08:49,325 --> 01:08:54,250
如果n=0值就是1，n!=0的话就会报错

546
01:08:57,390 --> 01:09:07,310
如果我对e1再次调用F会发生什么？

547
01:09:10,500 --> 01:09:15,670
哦，还是得到了一个有两个参数的过程

548
01:09:15,670 --> 01:09:24,200
记住，e1是F应用e0得到的近似，原本什么都做不了，现在可以计算0次方

549
01:09:24,200 --> 01:09:29,520
来看e2，如果n=0，结果就是1，也是符合指数计算原则的

550
01:09:29,520 --> 01:09:35,979
然而，这里的乘法使得原本只能计算0次方的过程现在可以计算1次方

551
01:09:35,979 --> 01:09:39,670
所以e2可以计算0和1次方

552
01:09:43,800 --> 01:09:47,899
e3的推导过程和e2是类似的

553
01:09:47,899 --> 01:09:55,120
即E3可以用来计算0、1、2次方

554
01:09:55,120 --> 01:10:02,520
因此我就不加证明的断言，不动点就是一个指数计算过程，这个证明十分的困难

555
01:10:02,520 --> 01:10:07,710
这也就是人们所谓的指称语义学家所做的事

556
01:10:07,710 --> 01:10:10,265
这个伟大的想法最先是从Scott和Strachey开始的

557
01:10:14,240 --> 01:10:24,240
他们是非常出色的数学家，也就是他们发明了那些程序的解释方式，就是我刚才讲的

558
01:10:24,240 --> 01:10:32,220
他们用拓扑学的知识证明了，刚才我们的那个例子是存在固定点的

559
01:10:32,220 --> 01:10:43,680
但是结论是，expt是 n趋于无穷时Em的极限值

560
01:10:43,680 --> 01:10:47,900
我们也可以这样写

561
01:10:50,520 --> 01:11:01,120
expt = (f (f (f (f .... (f 丄)....)

562
01:11:01,120 --> 01:11:05,320
不用管丄是什么，因为它总会生成一个错误

563
01:11:07,540 --> 01:11:16,380
无穷的调用F

564
01:11:16,380 --> 01:11:19,760
现在我们的问题又变成了如何构造出无穷调用

565
01:11:22,590 --> 01:11:24,920
我们需要这些

566
01:11:24,920 --> 01:11:28,980
我怎么来无穷次的执行F呢？

567
01:11:28,980 --> 01:11:32,380
我得把它构造出来

568
01:11:32,380 --> 01:11:32,930
好吧我不知道

569
01:11:32,930 --> 01:11:34,810
到底怎么样构建一个无穷循环呢？

570
01:11:34,810 --> 01:11:38,340
我们先来看一个非常简单的无穷循环，我能想到的最简单的

571
01:11:43,550 --> 01:12:07,440
比如这样  ((lambda(x) (x x)) (lambda(x) (x x)))，这样就是一个无限的循环了

572
01:12:07,440 --> 01:12:09,980
现在来解释它是无限循环的原因

573
01:12:09,980 --> 01:12:18,850
只需要参数代换入过程体即可

574
01:12:18,850 --> 01:12:29,660
其中的每个x都要代换为(lambda(x) (x x))，这也就又回到了这个表达式上来，我们就从这里开始，一个最简单的循环

575
01:12:35,440 --> 01:12:43,090
我想要讲的是一个特别的操作符，只需对这个无穷循环做一点点小的改动

576
01:12:47,040 --> 01:12:48,290
我称其为Y

577
01:12:52,290 --> 01:13:04,480
这被称为Curry Y不动点组合子，是由20世纪30年代的逻辑学家Curry发明的

578
01:13:04,480 --> 01:13:09,330
Y是一个接受一个参数的过程，具体怎么写呢？

579
01:13:09,330 --> 01:13:27,899
内部需要构建出无限循环，((lambda(x) (f (x x))) (lambda(x) (f (x x))))

580
01:13:32,300 --> 01:13:34,590
这个是怎么运作的？

581
01:13:34,590 --> 01:13:42,950
假设执行(Y F)

582
01:13:42,950 --> 01:13:46,910
就是那边那个大写的F

583
01:13:46,910 --> 01:13:49,920
很简单，把F代换进来

584
01:13:55,320 --> 01:14:02,800
里面的lambda代换进去

585
01:14:08,970 --> 01:14:11,730
我逐步的代换一次，你就可以明白是怎么回事了

586
01:14:11,730 --> 01:14:15,020
我会非常谨慎

587
01:14:15,020 --> 01:14:37,910
也就是 ((lambda(x) (F (x x))) (lambda(x) (F (x x))))

588
01:14:37,910 --> 01:15:11,510
lambda代换进来，也就是 (F (lambda(x) (F (x x))) (lambda(x) (F (x x))))

589
01:15:11,510 --> 01:15:13,420
哇，这一部分是什么？

590
01:15:13,420 --> 01:15:20,030
也就是我们上面要计算的这部分

591
01:15:20,030 --> 01:15:23,370
不同的是在外层应用了过程F

592
01:15:23,370 --> 01:15:27,850
以此类推，就构造出了无穷个F迭代应用的过程

593
01:15:27,850 --> 01:15:33,170
我们一直这样代换下去，就会在外层得到越来越多的F

594
01:15:33,170 --> 01:15:36,855
运行一个无穷循环看似无用，但是我们还要注意到循环过程中内部的变化

595
01:15:40,220 --> 01:16:04,450
(Y F) => (F (Y F))，Y这个过程很神奇，应用于一个过程，就可以求出这个过程的不动点，当然是在不动点存在的前提下

596
01:16:07,910 --> 01:16:11,630
因为，这里把(Y F)作为一个整体，F应用于(Y F)结果还是(Y F)

597
01:16:16,240 --> 01:16:23,860
Now I want you to think this in terms of the eval-apply interpreter for a bit.

598
01:16:23,860 --> 01:16:28,540
I wrote down a whole bunch of recursion equations out there.

599
01:16:28,540 --> 01:16:31,470
They're simultaneous in the same way these are simultaneous equations.

600
01:16:31,470 --> 01:16:33,310
Exponentiation was not a simultaneous equation.

601
01:16:33,310 --> 01:16:38,150
It was only one variable I was looking for a meaning for.

602
01:16:38,150 --> 01:16:58,220
But what Lisp is is the fixed point of the process which says, if I knew what Lisp was and substituted it in for eval, and apply, and so on, on the right hand sides of all those recursion equations, then if it was a real good Lisp, is a real one, then the left hand side would also be Lisp.

603
01:16:58,220 --> 01:16:59,565
So I made sense of that definition.

604
01:17:02,420 --> 01:17:05,410
Now whether or not there's an answer isn't so obvious.

605
01:17:05,410 --> 01:17:07,740
I can't attack that.

606
01:17:07,740 --> 01:17:10,660
Now these arguments that I'm giving you now are quite dangerous.

607
01:17:10,660 --> 01:17:13,570
Let's look over here.

608
01:17:13,570 --> 01:17:14,610
These are limit arguments.

609
01:17:14,610 --> 01:17:21,255
We're talking about limits, and it's really calculus, or topology, or something like that, a kind of analysis.

610
01:17:21,255 --> 01:17:23,380
Now here's an argument that you all believe.

611
01:17:23,380 --> 01:17:29,660
And I want to make sure you realize that I could be bullshitting you.

612
01:17:29,660 --> 01:17:30,910
What is this?

613
01:17:34,250 --> 01:17:42,820
u is the sum of 1/2, 1/4, and 1/8, and so on, the sum of a geometric series.

614
01:17:42,820 --> 01:17:44,820
And, of course, I could play a game here.

615
01:17:44,820 --> 01:17:47,570
u minus one is 1/2, plus 1/4, plus 1/8, and so on.

616
01:17:53,590 --> 01:17:56,680
What I could do here-- oops.

617
01:17:56,680 --> 01:17:58,920
There is a parentheses error here.

618
01:17:58,920 --> 01:18:03,990
But I can put here two times u minus one is one plus 1/2, plus 1/4, plus 1/8.

619
01:18:07,570 --> 01:18:08,820
Can I fix that?

620
01:18:14,010 --> 01:18:16,125
Yes, well.

621
01:18:19,520 --> 01:18:30,300
But that gives me back two times u minus one is u, therefore, we conclude that u is two.

622
01:18:30,300 --> 01:18:31,830
And this actually is true.

623
01:18:31,830 --> 01:18:33,910
There's no problem like that.

624
01:18:33,910 --> 01:18:38,540
But supposing I did something different.

625
01:18:38,540 --> 01:18:41,470
Supposing I start up with something which manifestly has no sum.

626
01:18:41,470 --> 01:18:47,390
v is one, plus two, plus four, plus 8, plus dot, dot, dot.

627
01:18:47,390 --> 01:18:52,010
Well, v minus one is surely two, plus four, plus eight, plus dot, dot, dot.

628
01:18:52,010 --> 01:18:57,410
v minus one over two, gee, that looks like v again.

629
01:18:57,410 --> 01:19:03,070
From that I should be able to conclude that-- that's also wrong, apparently.

630
01:19:03,070 --> 01:19:04,510
v equals minus one.

631
01:19:12,455 --> 01:19:15,280
That should be a minus one.

632
01:19:15,280 --> 01:19:16,735
And that's certainly a false conclusion.

633
01:19:22,000 --> 01:19:30,750
So when you play with limits, arguments that may work in one case they may not work in some other case.

634
01:19:30,750 --> 01:19:32,240
You have to be very careful.

635
01:19:32,240 --> 01:19:35,752
The arguments have to be well formed.

636
01:19:35,752 --> 01:19:43,270
And I don't know, in general, what the story is about arguments like this.

637
01:19:43,270 --> 01:19:46,060
We can read a pile of topology and find out.

638
01:19:46,060 --> 01:19:53,260
But, surely, at least you understand now, why it might be some meaning to the things we've been writing on the blackboard.

639
01:19:53,260 --> 01:19:56,480
And you understand what that might mean.

640
01:19:56,480 --> 01:20:09,320
So, I suppose, it's almost about time for you to merit being made a member of the grand recursive order of lambda calculus hackers.

641
01:20:09,320 --> 01:20:10,820
This is the badge.

642
01:20:10,820 --> 01:20:21,890
Because you now understand, for example, what it says at the very top, y F equals F y F. Thank you.

643
01:20:21,890 --> 01:20:24,710
Are there any questions?

644
01:20:24,710 --> 01:20:25,150
Yes, Lev.

645
01:20:25,150 --> 01:20:34,090
AUDIENCE: With this, it seems that then there's no need to define, as you imply, to just remember a value, to apply it later.

646
01:20:34,090 --> 01:20:36,490
Defines were kind of a side-effect it seemed in the language.

647
01:20:36,490 --> 01:20:39,300
[INTERPOSING] are order dependent.

648
01:20:39,300 --> 01:20:43,150
Does this eliminate the side-effect from the. Well

649
01:20:43,150 --> 01:20:49,180
PROFESSOR: The answer is, this is not the way these things were implemented.

650
01:20:49,180 --> 01:21:03,690
Define, indeed is implemented as an operation that actually modifies an environment structure, changes the frame that the define is executed in.

651
01:21:03,690 --> 01:21:11,340
And there are many reasons for that, but a lot of this has to do with making an interactive system.

652
01:21:11,340 --> 01:21:24,090
What this is saying is that if you've made a system, and you know you're not going to do any debugging or anything like that, and you know everything there is all at once, and you want to say, what is the meaning of a final set of equations?

653
01:21:24,090 --> 01:21:25,790
This gives you a meaning for it.

654
01:21:25,790 --> 01:21:35,000
But in order to make an interactive system, where you can change the meaning of one thing without changing everything else, incrementally, you can't do that by implementing it this way.

655
01:21:40,990 --> 01:21:41,860
Yes.

656
01:21:41,860 --> 01:21:44,650
AUDIENCE: Another question on your danger slide.

657
01:21:44,650 --> 01:21:50,300
It seemed that the two examples that you gave had to do with convergence and non-convergence?

658
01:21:50,300 --> 01:22:05,430
And that may or may not have something to do with function theory in a way which would lead you to think of it in terms of linear systems, or non-linear systems. How does this convergence relate to being able to see a priori what properties of that might be violated?

659
01:22:05,430 --> 01:22:07,680
PROFESSOR: I don't know.

660
01:22:07,680 --> 01:22:10,610
The answer is, I don't know under what circumstances.

661
01:22:10,610 --> 01:22:16,910
I don't know how to translate that into less than an hour of talk more.

662
01:22:16,910 --> 01:22:22,720
What are the conditions under which, for which we know that these things converge?

663
01:22:22,720 --> 01:22:32,810
And v, all that was telling you that arguments that are based on convergence are flaky if you don't know the convergence beforehand.

664
01:22:32,810 --> 01:22:34,440
You can make wrong arguments.

665
01:22:34,440 --> 01:22:40,690
You can make deductions, as if you know the answer, and not be stopped somewhere by some obvious contradiction.

666
01:22:40,690 --> 01:23:03,020
AUDIENCE: So can we say then that if F is a convergent mathematical expression, then the recursion property can be-- PROFESSOR: Well, I think there's a technical kind of F, there is a technical description of those F's that have the property that when you iteratively apply them like this, you converge.

667
01:23:03,020 --> 01:23:09,370
Things that are monotonic, and continuous, and I forgot what else.

668
01:23:09,370 --> 01:23:13,430
There is a whole bunch of little conditions like that which have this property.

669
01:23:13,430 --> 01:23:22,010
Now the real problem is deducing from looking at the F, its definition here, whether not it has those properties, and that's very hard.

670
01:23:22,010 --> 01:23:23,280
The properties are easy.

671
01:23:23,280 --> 01:23:24,580
You can write them down.

672
01:23:24,580 --> 01:23:26,930
You can look in a book by Joe Stoy.

673
01:23:26,930 --> 01:23:29,910
It's a great book-- Stoy.

674
01:23:31,780 --> 01:23:41,800
It's called, The Scott-Strachey Method of Denotational Semantics, and it's by Joe Stoy, MIT Press.

675
01:23:47,960 --> 01:23:51,880
And he works out all this in great detail, enough to horrify you.

676
01:23:55,080 --> 01:23:56,330
But it really is readable.

677
01:24:09,150 --> 01:24:11,490
OK, well, thank you.

678
01:24:11,490 --> 01:24:13,780
Time for the bigger break, I suppose.

