1
00:00:21,170 --> 00:00:36,630
现在，我们已经拥有了通过改变局部状态进行对象建模的力量，我想我们应该找点复杂的东西来演示一下这种力量是多么强大

2
00:00:40,430 --> 00:00:52,060
假设，我们处在这样一个物理系统中，系统中的事物驱动彼此，全部的这些事物组成了世界

3
00:00:52,060 --> 00:00:58,830
每一个事物都有其独立的局部状态

4
00:00:58,830 --> 00:01:01,280
这决定了它属于一个事物

5
00:01:01,280 --> 00:01:10,940
这个模型存在于我们的大脑里，当然它也可以存在于计算机中

6
00:01:10,940 --> 00:01:28,570
我要做的是，把真实世界中事物，相应地在计算机中建立对象，真实世界中事物的联系，相应地在计算机建立对象间的关系，对象与关系与现实世界的事物与联系一一对应

7
00:01:30,840 --> 00:01:34,740
这也就指引了我们如何去模块化

8
00:01:34,740 --> 00:01:50,450
如果我们真的把世界想象成这样，由许多小的事物组成，我们就可以一一对其建模，这样就把世界的模块性传递到了我们的程序这中

9
00:01:50,450 --> 00:01:55,420
这就是面向对象编程的原理所在

10
00:01:55,420 --> 00:01:58,890
我所见过的最完美的对象

11
00:01:58,890 --> 00:02:14,220
非常非常完美，那就是电气系统。电气系统真的是物理学家构造的非常非常好的一种对象

12
00:02:14,220 --> 00:02:16,760
这里我有一些机器零件

13
00:02:16,760 --> 00:02:20,040
确实是机器零件

14
00:02:20,040 --> 00:02:27,190
有一个电线连接起了零件的两个部分

15
00:02:27,190 --> 00:02:38,310
电气世界中有一个非常棒的特性，就是我可以说这是一个对象，这是一个对象，这两个对象连接起来，所有关系一目了然

16
00:02:38,310 --> 00:02:44,740
而且，如果我没有用电线连接，它们便没有关系

17
00:02:44,740 --> 00:02:51,370
比如我有一个灯泡，一个已经接在插座上的电源

18
00:02:51,370 --> 00:02:53,620
关系非常明了

19
00:02:53,620 --> 00:02:56,220
没有另外的关系表现形式

20
00:02:56,220 --> 00:03:04,040
就算我把电线打个结，灯仍然是亮着的

21
00:03:04,040 --> 00:03:05,290
没什么影响

22
00:03:08,300 --> 00:03:15,270
在物理上，这种连接可以被抽象出来，至少在低频状态下是可以的

23
00:03:17,840 --> 00:03:22,350
而且这就是全部的连接方式了

24
00:03:22,350 --> 00:03:30,951
当然，我们来进一步讨论一种在电气系统中最为广泛的抽象，数字电路

25
00:03:30,951 --> 00:03:34,610
这有一些对象元件

26
00:03:34,610 --> 00:03:41,092
例如，在数字电路里我们有像非门这样的东西

27
00:03:41,092 --> 00:03:43,990
还有与门

28
00:03:43,990 --> 00:03:47,210
或门

29
00:03:47,210 --> 00:03:55,610
我们用电线把它们连接起来，电线就是对01信号的抽象

30
00:03:55,610 --> 00:04:05,160
我们不关心具体的物理因素，像电压啊，电流啊，元件怎么组合啊 等等

31
00:04:05,160 --> 00:04:09,420
这些因素统一抽象为信号

32
00:04:09,420 --> 00:04:14,070
我们用电路连接元件，构建系统

33
00:04:14,070 --> 00:04:32,700
一会儿我要向你们介绍一种新的语言，像之前讲过的图形语言一样，都嵌入在LISP中，不是昨天那种模式匹配替换的语言

34
00:04:32,700 --> 00:04:38,160
模式匹配替换的语言还需要用LISP编写另外的程序来解释

35
00:04:38,160 --> 00:04:45,480
但是之前那种绘图语言我们可以随意使用，不管构造过程还是组合数据

36
00:04:45,480 --> 00:04:53,026
举例来说，首先我要有一些原子对象，比如这个，这个

37
00:04:53,026 --> 00:04:55,810
然后用电线去组合它们

38
00:04:55,810 --> 00:04:59,870
(make-wire)构造一个电线

39
00:04:59,870 --> 00:05:01,740
a就代表了一根电线

40
00:05:01,740 --> 00:05:02,690
b也是

41
00:05:02,690 --> 00:05:03,460
c也是

42
00:05:03,460 --> 00:05:04,230
d也是

43
00:05:04,230 --> 00:05:04,830
还有e

44
00:05:04,830 --> 00:05:06,880
还有s

45
00:05:06,880 --> 00:05:17,940
再来看元件，或门有两个输入a和b，一个输出d，就像这样

46
00:05:17,940 --> 00:05:24,820
与门，a和b两个输入，一个输出c

47
00:05:24,820 --> 00:05:32,750
就像这样来声明，我可以组合出任意的电路

48
00:05:32,750 --> 00:05:43,690
我已经说明了原子元素，组合方法，然后就轮到抽象方法了

49
00:05:43,690 --> 00:05:52,240
举例来说，这是一个半加器

50
00:05:52,240 --> 00:05:56,930
如果你学过电路设计肯定知道这个东西

51
00:05:56,930 --> 00:06:03,956
输入两个数a和b，输出“和”和进位

52
00:06:03,956 --> 00:06:07,450
事实上，完全可以用我刚刚说的来组合电路

53
00:06:07,450 --> 00:06:14,790
把半加器看成一个盒子，盒子的边界，抽象出的永远都是一个盒子

54
00:06:14,790 --> 00:06:19,700
从盒子里引出A B S C四根线

55
00:06:19,700 --> 00:06:28,270
这些是已经声明了的变量，我们就用它们来定义半加器

56
00:06:31,400 --> 00:06:48,790
为了连接半加器里面的线路，我构造了电线D和E，E是这个，D是这个，内部连接的线路并没有引出盒子之外，就像这样连起来

57
00:06:48,790 --> 00:06:53,890
你可以看的出来，这个语言非常有层次性

58
00:06:53,890 --> 00:07:06,300
如果一个语言没有层次性，如果你不能把一个复合对象当成原子对象来使用，这个语言肯定是有问题的 -- 至少我这样觉得

59
00:07:06,300 --> 00:07:23,350
之前我们都是从计算一些数字上的函数开始的，现在我们不那样做，我们从一些电路对象开始，构建更多的电路对象

60
00:07:23,350 --> 00:07:30,500
用LISP里的lambda将其粘合起来

61
00:07:30,500 --> 00:07:32,930
lambda是很有用的粘合剂

62
00:07:32,930 --> 00:08:05,900
当然，两个半加器可以组成结构更为复杂的全加器，就像这里这个，把线路连在一起，还需要另外的电线如S，C1和C2，还有一个或门。全加器输入两个数，一个进位值，输出“和”和一个进位值

63
00:08:05,900 --> 00:08:12,990
除此之外，还可以把全加器链起来组成更大的加法器

64
00:08:12,990 --> 00:08:22,270
现在我们的语言有了原子元素，组合方法和抽象方法，才算完整

65
00:08:22,270 --> 00:08:25,000
现在问题来了，如何实现这套语言？

66
00:08:25,000 --> 00:08:27,070
其实并不难

67
00:08:27,070 --> 00:08:28,610
首先来看原子元素

68
00:08:28,610 --> 00:08:31,160
实现原子元素也是整个问题的根本所在

69
00:08:31,160 --> 00:08:43,417
至于组合方法与抽象方法完全不用亲自实现，因为语言嵌入在LISP中可以直接使用LISP中的这种机制

70
00:08:43,417 --> 00:08:45,860
好的，我们先来看一个原子元素

71
00:08:45,860 --> 00:08:47,400
非门吧

72
00:08:51,540 --> 00:08:54,900
非门有两个引脚，一个输入，一个输出

73
00:08:57,440 --> 00:09:04,300
有信号输入的时候它要做点什么

74
00:09:04,300 --> 00:09:20,120
它和输入的电线说 -- 我们开始讨论一些关于对象的东西，细节之处以后再谈 -- 它需要对作为输入的电线的说 “当你的值变的时候，告诉我一声”

75
00:09:20,120 --> 00:09:26,870
所以非门可能会这样和这个输入对象交流， “Hi，我是George”

76
00:09:26,870 --> 00:09:31,720
“我的工作就是，当你变化的时候对结果做一点修改”

77
00:09:31,720 --> 00:09:34,730
“所以当你变化的时候，告诉我一声”

78
00:09:34,730 --> 00:09:37,010
“因为我需要这个去做点别的”

79
00:09:37,010 --> 00:09:56,130
我们在这里为in添加一个动作invert-in，它在这里定义，是一个无参数的过程，对线路上的信号取反

80
00:09:56,130 --> 00:10:07,140
在一段延时之后，就是inverter-delay -- 每个电路对象都有延时 -- 我们再把输出设置为新的值

81
00:10:10,160 --> 00:10:12,400
非常简单

82
00:10:12,400 --> 00:10:23,840
你可以这样理解，这个作为输出的电线很有灵性，当信号改变的时候，它就奔走相告

83
00:10:23,840 --> 00:10:26,050
“我的值已经改变啦”

84
00:10:26,050 --> 00:10:36,810
所以当你把非门和与门或者其它的什么连在一起的时候，其中会有很多类似“奔走相告”的过程，确保信号以正确的方式传递

85
00:10:36,810 --> 00:10:38,620
到了这里反而很平常

86
00:10:38,620 --> 00:10:46,240
logical-not只是把0，1换成1，0罢了

87
00:10:46,240 --> 00:10:49,780
与门就相对复杂一些

88
00:10:49,780 --> 00:10:56,950
与门有两个输入A1，A2，输出是output

89
00:10:56,950 --> 00:11:00,860
但是其结构和非门没有什么大的不同

90
00:11:00,860 --> 00:11:10,910
当输入信号改变的时候，就执行过程and-action

91
00:11:10,910 --> 00:11:15,900
它所做的只是根据信号逻辑与运算出输出信号而已

92
00:11:15,900 --> 00:11:25,470
在and-gate-delay的延时之后，更新输出信号值

93
00:11:25,470 --> 00:11:28,350
我完全是按愿望思考来完成的这一切

94
00:11:28,350 --> 00:11:32,020
你看，这里有一个赋值操作

95
00:11:32,020 --> 00:11:34,570
并不是set!

96
00:11:34,570 --> 00:11:46,340
之前我们模仿过CAR，CDR构建新过程，这里也是同理，按照惯例，它的具体实现留作最后的惊喜

97
00:11:46,340 --> 00:12:03,350
这个过程add-action!，提醒线路A1，当它改变的时候记得执行过程add-action-procedure，A2也是一样

98
00:12:06,310 --> 00:12:09,510
非常简单

99
00:12:09,510 --> 00:12:18,310
现在我们再来聊聊各个部分之间信息是如何传递的吧

100
00:12:18,310 --> 00:12:47,360
假设，有一个非常简单的电路，一个与门，输入a，b，输出端c又作为输入接在非门上，非门的输出是d

101
00:12:47,360 --> 00:12:49,860
一个对实际电路的抽象

102
00:12:49,860 --> 00:12:54,880
要不了几分钱就可以从Radio Shack买到这些元件

103
00:12:54,880 --> 00:13:01,530
那些元件的作用和画在这里的差不多，不同的是元件上面都标有很多小数字像“LS04”之类的

104
00:13:01,530 --> 00:13:09,010
现在来看其中的计算模型

105
00:13:09,010 --> 00:13:15,850
它联系起我们头脑里的现实和在计算机中虚拟的现实，这种联系到底是什么

106
00:13:15,850 --> 00:13:25,750
真实世界的对象或关系改变了，我就去改变“虚拟”世界中相对应的对象或关系

107
00:13:25,750 --> 00:13:28,560
这是我们的目标

108
00:13:28,560 --> 00:13:30,900
让我们来看看怎么做

109
00:13:30,900 --> 00:13:35,401
这一团东西代表信号A

110
00:13:35,401 --> 00:13:37,940
A，一个信号

111
00:13:37,940 --> 00:13:39,900
画的像一团云

112
00:13:39,900 --> 00:13:49,140
再画另一个信号，B

113
00:13:49,140 --> 00:14:00,320
这两个信号将要一起连入一个盒子，一个与门，一个动作过程

114
00:14:00,320 --> 00:14:02,040
这就是与门的动作过程

115
00:14:07,660 --> 00:14:30,195
它又联系起另一个信号C，后面的非门连接起来和前面差不多

116
00:14:32,860 --> 00:14:42,970
最后一个信号/电线，D

117
00:14:42,970 --> 00:14:45,770
整体布局就是这样

118
00:14:45,770 --> 00:14:51,500
现在必须来研究它们内部的实际机制了，它们的实际运行过程

119
00:14:51,500 --> 00:14:57,340
每一个电线都必须知道自己的信号是什么

120
00:14:57,340 --> 00:15:00,680
所以内部一定有些变量来表示信号

121
00:15:02,670 --> 00:15:05,840
a有一个变量，signal

122
00:15:05,840 --> 00:15:08,656
也不要忘了它所关联的环境

123
00:15:08,656 --> 00:15:11,800
剩下的每一个都和a一样

124
00:15:15,400 --> 00:15:16,880
这里也有一个signal变量

125
00:15:19,400 --> 00:15:24,170
可以猜出来，signal的值不是0就是1

126
00:15:28,000 --> 00:15:34,390
还需要一个列表，记录一些“联系人”，当信号实际改变的时候要去通知”他们“

127
00:15:36,660 --> 00:15:39,300
我们得通知这个与门

128
00:15:39,300 --> 00:15:44,500
这个列表我们叫它AP(Action Procedures，动作过程)

129
00:15:44,500 --> 00:15:50,500
假定它真的用列表实现，在这里，列表里第一个肯定是这个与门

130
00:15:50,500 --> 00:15:54,810
b和a一样

131
00:15:54,810 --> 00:15:59,020
也可能有一些其它“人”在时刻等待着A来叫“他们”

132
00:15:59,020 --> 00:16:03,630
所以这里可能有其它“人”，具体不知道是谁

133
00:16:03,630 --> 00:16:07,200
我画在这里

134
00:16:07,200 --> 00:16:13,070
在b内部的AP列表里，肯定也要有这个与门

135
00:16:13,070 --> 00:16:18,530
相类似的，这里这样来连接

136
00:16:18,530 --> 00:16:21,770
这是c要通知的“人”

137
00:16:21,770 --> 00:16:24,280
d也一样

138
00:16:24,280 --> 00:16:27,190
但是我不知道它要通知谁，因为“他们”没有在我的图中出现

139
00:16:27,190 --> 00:16:30,320
可能是和D连接起来的其它门吧

140
00:16:30,320 --> 00:16:52,790
假如与门被“人”通知了 -- 因为"其它人"信号值的变化 -- 与门就得回头去检测自己的输入电路的新值是多少，才能做“与”操作，生成新的输出信号

141
00:16:57,090 --> 00:17:06,400
这也即与门的输入，A1是这个a，A2就是b

142
00:17:08,930 --> 00:17:16,170
不只这样，还有点别的

143
00:17:16,170 --> 00:17:21,160
还有一个输出

144
00:17:25,800 --> 00:17:43,520
同样地，非门也有一个输入，它也不时地在关注着信号的变化，当有“人”来通知它“我已经改变了”

145
00:17:43,520 --> 00:17:46,900
它就反过来查询这个新的信号值

146
00:17:46,900 --> 00:17:55,860
取到值之后，然后计算输出，改变输出的信号值

147
00:18:00,600 --> 00:18:02,481
等等等等，就像是这样

148
00:18:02,481 --> 00:18:06,240
因此我也必须有这么多的连接

149
00:18:06,240 --> 00:18:10,260
现在我们回头观察一下，这个与门

150
00:18:10,260 --> 00:18:13,670
这张幻灯片

151
00:18:13,670 --> 00:18:16,040
这几个部分的内容

152
00:18:16,040 --> 00:18:21,030
对每个与门，都有A1，A2两个输入，一个输出output

153
00:18:21,030 --> 00:18:46,240
当and-gate运行的时候，A1 A2 output构成了其运行“环境”，它们有各自的信号值

154
00:18:46,240 --> 00:18:54,590
在这个环境下，我构建一个新的过程

155
00:18:54,590 --> 00:18:57,780
and-action-procedure

156
00:18:57,780 --> 00:19:01,620
过程定义了并没有实际运行

157
00:19:01,620 --> 00:19:07,620
当它运行的时候，根据环境模型

158
00:19:07,620 --> 00:19:11,700
找到它的局部环境

159
00:19:11,700 --> 00:19:17,310
and-action-procedure就取到了这里的A1 A2 output的值

160
00:19:17,310 --> 00:19:19,645
A1 A2 output

161
00:19:22,360 --> 00:19:26,030
我们还没有深入探索“电线”的内部结构

162
00:19:26,030 --> 00:19:29,030
我们来看看

163
00:19:29,030 --> 00:19:30,280
来看看“电线”

164
00:19:33,520 --> 00:19:36,160
非常棒的结构

165
00:19:39,500 --> 00:19:43,090
“电线”是有那么一点复杂

166
00:19:43,090 --> 00:19:46,840
哦，说错了

167
00:19:46,840 --> 00:19:49,780
是非常复杂

168
00:19:49,780 --> 00:19:54,720
但是还是来看一下，到底是什么

169
00:19:54,720 --> 00:19:57,760
“电线”是这上面画的云一样的东西 

170
00:19:57,760 --> 00:20:05,010
有两个主要部分，都是它的状态

171
00:20:05,010 --> 00:20:07,390
其中一个是信号值

172
00:20:07,390 --> 00:20:19,270
换句话说，当我们执行make-wire，首先要做的是新建两个局部变量signal和action-procs

173
00:20:22,042 --> 00:20:27,840
在这个上下文中，我们定义了一系列的过程

174
00:20:27,840 --> 00:20:32,850
先看(set-my-signal! new)

175
00:20:32,850 --> 00:20:37,930
它所做的只是，取一个新值new

176
00:20:37,930 --> 00:20:40,360
如果new和signal一样，信号没有变化，就没必要做什么了

177
00:20:40,360 --> 00:20:54,630
否则，把signal的值赋值为new，再执行action-procs里的所有过程，即通知所有“相关的人”

178
00:20:54,630 --> 00:21:01,530
当作为and-gate的参数的时候，它就是我的“联系人”了，得去通知它

179
00:21:04,130 --> 00:21:07,410
添加“联系人”的这个过程在最下面

180
00:21:07,410 --> 00:21:27,780
然后，我还得定义一个接受动作过程的过程，就在这里，使用con把新的过程与原来的过程列表连接在一起，再赋值予action-pros，最后还要再运行一次这个过程proc

181
00:21:27,780 --> 00:21:36,950
这是一种事件驱动的模拟模型，我还不打算细讲，因为那还需要思考更多的内容

182
00:21:36,950 --> 00:21:53,820
最后定义一个过程dispatcher，用来解读传递给线路的信息，执行不同的操作，比如这里，当前的信号值是多少？

183
00:21:53,820 --> 00:21:57,180
设置新信号值的方法是什么？

184
00:21:57,180 --> 00:22:00,100
我想要这个方法

185
00:22:00,100 --> 00:22:02,600
我怎么样去添加另外的动作过程呢？

186
00:22:05,510 --> 00:22:09,940
最后，返回过程dispatch

187
00:22:09,940 --> 00:22:19,790
因此整个电线的被构建成了一个可接受不同信息的对象，比如 ‘add-action!来询问添加动作过程的方法是什么？

188
00:22:19,790 --> 00:22:29,010
因此实际上，它返回了一个过程，这个过程接收一个动作过程作为参数，将其实际添加入电线的action-procs的列表中

189
00:22:31,620 --> 00:22:32,820
这是一种权限

190
00:22:32,820 --> 00:22:37,450
给予你了一种去改变自身动作过程列表的权限

191
00:22:37,450 --> 00:22:41,710
再来看看这里

192
00:22:41,710 --> 00:22:43,278
下一张幻灯片

193
00:22:43,278 --> 00:22:44,528
噢

194
00:22:47,760 --> 00:22:49,120
没什么有意思的

195
00:22:49,120 --> 00:22:54,990
(call-each procedures)只是对列表中过程顺序地执行调用，没什么好说的

196
00:22:54,990 --> 00:22:57,560
我们早就知道了

197
00:22:57,560 --> 00:23:03,090
然而，如果我想知道线路上的信号值是多少，就得这样来询问wire

198
00:23:03,090 --> 00:23:05,860
wire只是一个dispatch过程而已

199
00:23:05,860 --> 00:23:06,830
只是一个过程

200
00:23:06,830 --> 00:23:12,590
这是是‘get-signal作为参数来执行这个过程

201
00:23:12,590 --> 00:23:16,900
实际得到的只是取得线路信号值的方法

202
00:23:16,900 --> 00:23:19,220
进一步的就可以得到信号值

203
00:23:19,220 --> 00:23:38,700
如果我想要对线路设置一个新的信号值，这里传递wire和new-value两个参数，(wire 'set-signal!)取得改变线路信号的权限，实际是一个过程，应用于new-value

204
00:23:38,700 --> 00:24:13,010
我们继续追溯这个过程，调用(wire 'set-signal)之后，我们返回这个过程，定义在线路里面，名为set-my-signal，我们回头看幻灯片，返回的过程有一个实际的调用，以new-value为参数，去改变线路内部signal变量的值，最后再去依次通知“联系人”

205
00:24:16,340 --> 00:24:19,400
非常简单

206
00:24:19,400 --> 00:24:30,100
再来看看幻灯片，还有最后一点，add-action!，我想你们很轻易地就理解了

207
00:24:30,100 --> 00:24:36,470
wire action-proc两个参数

208
00:24:36,470 --> 00:24:40,050
然后请求添加动作过程的权限

209
00:24:40,050 --> 00:24:45,020
得到权限去添加新的动作过程

210
00:24:45,020 --> 00:24:48,570
这就是整个“电线”对象

211
00:24:48,570 --> 00:24:52,460
还有些细节

212
00:24:52,460 --> 00:24:58,390
比如，我怎么来控制它？

213
00:24:58,390 --> 00:25:01,290
这些延时怎么实现？

214
00:25:01,290 --> 00:25:02,540
我们来快速过一遍

215
00:25:05,275 --> 00:25:08,360
下一张

216
00:25:08,360 --> 00:25:09,570
我们来看看

217
00:25:09,570 --> 00:25:18,770
我们细看与门或者或门定义，会发现里面还有“延时”这样的东西

218
00:25:18,770 --> 00:25:23,310
一段延时之后才开始执行过程，改变输出

219
00:25:26,040 --> 00:25:28,120
这个要如何实现？

220
00:25:28,120 --> 00:25:34,720
这里引入一种新技巧，非常复杂，我们得非常细心地来看

221
00:25:34,720 --> 00:25:37,390
在“delay”的延时之后，执行过程action

222
00:25:37,390 --> 00:25:40,590
"delay"是一个数字，"action“是一个过程

223
00:25:40,590 --> 00:25:49,510
这里有一个特殊的数据结构the-agenda，用于组织时间与动作过程

224
00:25:49,510 --> 00:25:50,880
一会儿再来细看它

225
00:25:50,880 --> 00:25:53,070
先把这里说完

226
00:25:53,070 --> 00:25:59,130
the-agenda记录下来一个动作过程未来执行的时间

227
00:25:59,130 --> 00:26:08,460
在current-time + delay段的时间之后，将会执行那个过程

228
00:26:08,460 --> 00:26:13,090
这个过程随着计算好的这个时刻，添加入the-agenda中

229
00:26:15,280 --> 00:26:18,660
要使这个”计时钟表“运行起来并不困难

230
00:26:18,660 --> 00:26:22,710
下面这个过程progagate，就是来做这件事的

231
00:26:22,710 --> 00:26:27,440
如果the-agenda是空的，就没有要做的

232
00:26:27,440 --> 00:26:34,200
否则，我们就取出the-agenda的第一个元素，它是一个没有参数的过程

233
00:26:34,200 --> 00:26:36,030
这里有两层括号

234
00:26:36,030 --> 00:26:39,190
里面的一层返回一个过程，外面的一层括号执行了这个过程

235
00:26:39,190 --> 00:26:42,200
就是之前存储入the-agenda的动作

236
00:26:42,200 --> 00:26:48,395
然后这个过程就可以从the-agenda删掉了，最后执行propagate，进行无限循环

237
00:26:48,395 --> 00:26:50,750
这就是整体的结构

238
00:26:53,380 --> 00:26:57,430
还有点其它的

239
00:26:57,430 --> 00:27:00,410
一会儿再来看the-agenda

240
00:27:00,410 --> 00:27:02,800
现在整体上来看

241
00:27:02,800 --> 00:27:07,410
Well, in order to set this thing going, I just want to show you some behavior out of this simulator.

242
00:27:07,410 --> 00:27:12,370
By the way, you may think this simulator is very simple, and probably too simple to be useful.

243
00:27:12,370 --> 00:27:18,680
The fact of the matter is that this simulator has been used to manufacture a fairly large computer.

244
00:27:18,680 --> 00:27:22,360
So this is a real live example.

245
00:27:22,360 --> 00:27:25,560
Actually, not exactly this simulator, because I'll tell you the difference.

246
00:27:25,560 --> 00:27:29,820
The difference is that there were many more different kinds of primitives.

247
00:27:29,820 --> 00:27:33,200
There's not just the word inverter or and-gate.

248
00:27:33,200 --> 00:27:45,170
There were things like edge-triggered, flip-flops, and latches, transparent latches, and adders, and things like that.

249
00:27:45,170 --> 00:27:54,690
And the difficulty with that is that there's pages and pages of the definitions of all these primitives with numbers like LS04.

250
00:27:54,690 --> 00:27:56,740
And then there's many more parameters for them.

251
00:27:56,740 --> 00:27:58,480
It's not just one delay.

252
00:27:58,480 --> 00:28:01,220
There's things like set up times and hold times and all that.

253
00:28:01,220 --> 00:28:15,110
But with the exception of that part of the complexity, the structure of the simulator that we use for building a real computer, that works is exactly what you're seeing here.

254
00:28:15,110 --> 00:28:19,270
Well in any case, what we have here is a few simple things.

255
00:28:19,270 --> 00:28:23,030
Like, there's inverter delays being set up and making a new agenda.

256
00:28:23,030 --> 00:28:26,470
And then we can make some inputs.

257
00:28:26,470 --> 00:28:29,460
There's input-1, input-2, a sum and a carry, which are wires.

258
00:28:29,460 --> 00:28:37,810
I'm going to put a special kind of object called a probe onto, onto some of the wires, onto sum and onto carry.

259
00:28:37,810 --> 00:28:46,120
A probe is a, can object that has the property that when you change a wire it's attached to, it types out a message.

260
00:28:46,120 --> 00:28:47,970
It's an easy thing to do.

261
00:28:47,970 --> 00:28:59,400
And then once we have that, of course, the way you put the probe on, the first thing it does, it says, the current value of the sum at time 0 is 0 because I just noticed it.

262
00:28:59,400 --> 00:29:05,556
And the value of the carry at time 0, this is the time, is 0.

263
00:29:05,556 --> 00:29:09,620
And then we go off and we build some structure.

264
00:29:09,620 --> 00:29:18,420
Like, we can build a structure here that says you have a half-adder on input-1, input-2, sum, and carry.

265
00:29:18,420 --> 00:29:20,420
And we're going to set the signal on input-1 to 1.

266
00:29:20,420 --> 00:29:21,880
We do some propagation.

267
00:29:21,880 --> 00:29:29,520
At time 8, which you could see going through this thing if you wanted to, the new value of sum became 1.

268
00:29:29,520 --> 00:29:31,150
And the thing says I'm done.

269
00:29:31,150 --> 00:29:32,630
That wasn't very interesting.

270
00:29:32,630 --> 00:29:34,150
But we can send it some more signals.

271
00:29:34,150 --> 00:29:36,590
Like, we set-signal on input-2 to be one.

272
00:29:36,590 --> 00:29:45,040
And at that time if we propagate, then it carried at 11, the carry becomes 1, and at 16, the sum's new value becomes 0.

273
00:29:45,040 --> 00:29:48,990
And you might want to work out that, if you like, about the digital circuitry.

274
00:29:48,990 --> 00:29:50,620
It's true, and it works.

275
00:29:50,620 --> 00:29:51,535
And it's not very interesting.

276
00:29:51,535 --> 00:29:54,580
But that's the kind of behavior we get out of this thing.

277
00:30:01,830 --> 00:30:12,952
So what I've shown you right now is a large-scale picture, how you, at a bigger, big scale, you implement an event-driven simulation of some sort.

278
00:30:12,952 --> 00:30:21,225
And how you might organize it to have nice hierarchical structure allowing you to build abstract boxes that you can instantiate.

279
00:30:21,225 --> 00:30:25,780
But I haven't told you any of the details about how this agenda and things like that work.

280
00:30:25,780 --> 00:30:28,630
That we'll do next.

281
00:30:28,630 --> 00:30:34,310
And that's going to involve change and mutation of data and things like that.

282
00:30:34,310 --> 00:30:35,860
Are there any questions now, before I go on?

283
00:30:47,160 --> 00:30:47,550
Thank you.

284
00:30:47,550 --> 00:30:48,800
Let's take a break.

285
00:31:28,940 --> 00:31:35,060
Well, we've been making a simulation.

286
00:31:35,060 --> 00:31:43,920
And the simulation is an event-driven simulation where the objects in the world are the objects in the computer.

287
00:31:43,920 --> 00:32:04,420
And the changes of state that are happening in the world in time are organized to be time in the computer, so that if something happens after something else in the world, then we have it happen after, after the corresponding events happen in the same order in the computer.

288
00:32:04,420 --> 00:32:08,220
That's where we have assignments, when we make that alignment.

289
00:32:08,220 --> 00:32:16,040
Right now I want to show you a way of organizing time, which is an agenda or priority queue, it's sometimes called.

290
00:32:16,040 --> 00:32:21,230
We'll do some--we'll do a little bit of just understanding what are the things we need to be able to do to make agendas.

291
00:32:28,330 --> 00:32:35,960
And so we're going to have--and so right now over here, I'm going to write down a bunch of primitive operations for manipulating agendas.

292
00:32:35,960 --> 00:32:43,680
I'm not going to show you the code for them because they're all very simple, and you've got listings of all that anyway.

293
00:32:43,680 --> 00:32:44,380
So what do we have?

294
00:32:44,380 --> 00:32:54,130
We have things like make-agenda which produces a new agenda.

295
00:32:59,860 --> 00:33:12,625
We can ask--we get the current-time of an agenda, which gives me a number, a time.

296
00:33:16,990 --> 00:33:21,900
We can get--we can ask whether an agenda is empty, empty-agenda.

297
00:33:30,200 --> 00:33:32,570
And that produces either a true or a false.

298
00:33:42,590 --> 00:33:44,720
We can add an object to an agenda.

299
00:33:52,710 --> 00:33:56,910
Actually, what we add to an agenda is an operation--an action to be done.

300
00:33:56,910 --> 00:34:04,810
And that takes a time, the action itself, and the agenda I want to add it to.

301
00:34:07,850 --> 00:34:10,719
That inserts it in the appropriate place in the agenda.

302
00:34:10,719 --> 00:34:23,259
I can get the first item off an agenda, the first thing I have to do, which is going to give me an action.

303
00:34:26,085 --> 00:34:29,540
And I can remove the first item from an agenda.

304
00:34:29,540 --> 00:34:31,409
That's what I have to be able to do with agendas.

305
00:34:31,409 --> 00:34:33,020
That is a big complicated mess.

306
00:34:42,530 --> 00:34:43,780
From an agenda.

307
00:34:45,530 --> 00:34:52,528
Well, let's see how we can organize this thing as a data structure a bit.

308
00:34:52,528 --> 00:35:01,570
Well, an agenda is going to be some kind of list. And it's going to be a list that I'm going to have to be able to modify.

309
00:35:01,570 --> 00:35:11,070
So we have to talk about modifying of lists, because I'm going to add things to it, and delete things from it, and things like that.

310
00:35:11,070 --> 00:35:13,820
It's organized by time.

311
00:35:13,820 --> 00:35:15,570
It's probably good to keep it in sorted order.

312
00:35:18,330 --> 00:35:23,420
But sometimes there are lots of things that happen at the same time--approximate same time.

313
00:35:23,420 --> 00:35:29,040
What I have to do is say, group things by the time at which they're supposed to happen.

314
00:35:29,040 --> 00:35:32,780
So I'm going to make an agenda as a list of segments.

315
00:35:32,780 --> 00:35:39,620
And so I'm going to draw you a data structure for an agenda, a perfectly reasonable one.

316
00:35:39,620 --> 00:35:41,110
Here's an agenda.

317
00:35:41,110 --> 00:35:42,870
It's a thing that begins with a name.

318
00:35:47,630 --> 00:35:49,940
I'm going to do it right now out of list structure.

319
00:35:52,620 --> 00:35:53,980
It's got a header.

320
00:35:53,980 --> 00:35:55,840
There's a reason for the header.

321
00:35:55,840 --> 00:35:57,630
We're going to see the reason soon.

322
00:36:00,680 --> 00:36:03,750
And it will have a segment.

323
00:36:03,750 --> 00:36:05,620
It will have--it will be a list of segments.

324
00:36:08,310 --> 00:36:33,320
Supposing this agenda has two segments, they're the car's-- successive car's of this list. Each segment is going to have a time--  say for example, 10-- that says that the things that happen in this segment are at time 10.

325
00:36:33,320 --> 00:36:42,240
And what I'm going to have in here is another data structure which I'm not going to describe, which is a queue of things to do at time 10.

326
00:36:42,240 --> 00:36:43,330
It's a queue.

327
00:36:43,330 --> 00:36:45,130
And we'll talk about that in a second.

328
00:36:45,130 --> 00:36:50,200
But abstractly, the queue is just a list of things to do at a particular time.

329
00:36:50,200 --> 00:36:53,100
And I can add things to a queue.

330
00:36:53,100 --> 00:36:56,140
This is a queue.

331
00:36:56,140 --> 00:36:59,115
There's a time, there's a segment.

332
00:37:02,889 --> 00:37:06,035
Now, I may have another segment in this agenda.

333
00:37:08,940 --> 00:37:13,410
Supposing this is stuff that happens at time 30.

334
00:37:13,410 --> 00:37:23,210
It has, of course, another queue of things that are queued up to be done at time 30.

335
00:37:23,210 --> 00:37:27,090
Well, there are various things I have to be able to do to an agenda.

336
00:37:27,090 --> 00:37:33,030
Supposing I want to add to an agenda another thing to be done at time 10.

337
00:37:33,030 --> 00:37:34,700
Well, that's not very hard.

338
00:37:34,700 --> 00:37:39,730
I'm going to walk down here, looking for the segment of time 10.

339
00:37:39,730 --> 00:37:42,930
It is possible that there is no segment of time 10.

340
00:37:42,930 --> 00:37:45,420
We'll cover that case in a second.

341
00:37:45,420 --> 00:37:56,290
But if I find a segment of time 10, then if I want to add another thing to be done at time 10, I just increase that queue-- "just increase" isn't such an obvious idea.

342
00:37:56,290 --> 00:38:01,430
But I increase the things to be done at that time.

343
00:38:01,430 --> 00:38:05,140
Now, supposing I want to add something to be done at time 20.

344
00:38:05,140 --> 00:38:08,680
There is no segment for time 20.

345
00:38:08,680 --> 00:38:11,340
I'm going to have to create a new segment.

346
00:38:11,340 --> 00:38:17,610
I want my time 20 segment to exist between time 10 and time 30.

347
00:38:17,610 --> 00:38:20,170
Well, that takes a little work.

348
00:38:20,170 --> 00:38:21,525
I'm going to have to do a CONS.

349
00:38:24,260 --> 00:38:29,940
I'm going to have to make a new element of the agenda list--list of segments.

350
00:38:33,600 --> 00:38:35,400
I'm going to have to change.

351
00:38:35,400 --> 00:38:37,540
Here's change.

352
00:38:37,540 --> 00:38:56,657
I'm going to have to change the CDR of the CDR of the agenda to point that a new CONS of the new segment and the CDR of the CDR of the CDR of the agenda, the CD-D-D-DR.

353
00:38:56,657 --> 00:39:06,290
And this is going to have a new segment now of time 20 with its own queue, which now has one element in it.

354
00:39:10,730 --> 00:39:20,770
If I wanted to add something at the end, I'm going to have to replace the CDR of this, of this list with something.

355
00:39:20,770 --> 00:39:24,040
We're going to have to change that piece of data structure.

356
00:39:24,040 --> 00:39:27,210
So I'm going to need new primitives for doing this.

357
00:39:27,210 --> 00:39:29,550
But I'm just showing you why I need them.

358
00:39:29,550 --> 00:39:49,400
And finally, if I wanted to add a thing to be done at time 5, I'm going to have to change this one, because I'm going to have to add it in over here, which is why I planned ahead and had a header cell, which has a place.

359
00:39:49,400 --> 00:39:53,420
If I'm going to change things, I have to have places for the change.

360
00:39:53,420 --> 00:39:58,600
I have to have a place to make the change.

361
00:39:58,600 --> 00:40:02,540
If I remove things from the agenda, that's not so hard.

362
00:40:02,540 --> 00:40:11,220
Removing them from the beginning is pretty easy, which is the only case I have. I can go looking for the first, the first segment.

363
00:40:11,220 --> 00:40:14,510
I see if it has a non-empty queue.

364
00:40:14,510 --> 00:40:20,100
If it has a non-empty queue, well, I'm going to delete one element from the queue, like that.

365
00:40:20,100 --> 00:40:24,220
If the queue ever becomes empty, then I have to delete the whole segment.

366
00:40:24,220 --> 00:40:28,220
And then this, this changes to point to here.

367
00:40:28,220 --> 00:40:36,440
So it's quite a complicated data structure manipulation going on, the details of which are not really very exciting.

368
00:40:36,440 --> 00:40:38,920
Now, let's talk about queues.

369
00:40:38,920 --> 00:40:41,160
They're similar.

370
00:40:41,160 --> 00:40:44,340
Because each of these agendas has a queue in it.

371
00:40:44,340 --> 00:40:45,590
What's a queue?

372
00:40:49,079 --> 00:40:52,350
A queue is going to have the following primitive operations.

373
00:40:52,350 --> 00:41:02,170
To make a queue, this gives me a new queue.

374
00:41:07,274 --> 00:41:16,850
I'm going to have to be able to insert into a queue a new item.

375
00:41:24,510 --> 00:41:28,740
I'm going to have to be able to delete from a queue the first item in the queue.

376
00:41:39,988 --> 00:41:52,890
And I want to be able to get the first thing in the queue from some queue.

377
00:41:52,890 --> 00:41:55,140
I also have to be able to test whether a queue is empty.

378
00:42:07,110 --> 00:42:15,120
And when you invent things like this, I want you to be very careful to use the kinds of conventions I use for naming things.

379
00:42:15,120 --> 00:42:19,870
Notice that I'm careful to say these change something and that tests it.

380
00:42:19,870 --> 00:42:24,335
And presumably, I did the same thing over here.

381
00:42:24,335 --> 00:42:29,240
OK, and there should be an empty test over here.

382
00:42:29,240 --> 00:42:31,720
OK, well, how would I make a queue?

383
00:42:31,720 --> 00:42:37,840
A queue wants to be something I can add to at the end of, and pick up the thing at the beginning of.

384
00:42:37,840 --> 00:42:41,230
I should be able to delete from the beginning and add to the end.

385
00:42:41,230 --> 00:42:43,740
Well, I'm going to show you a very simple structure for that.

386
00:42:43,740 --> 00:42:47,080
We can make this out of CONSes as well.

387
00:42:47,080 --> 00:42:49,910
Here's a queue.

388
00:42:49,910 --> 00:42:59,610
It has--it has a queue header, which contains two parts-- a front pointer and a rear pointer.

389
00:43:02,930 --> 00:43:09,000
And here I have a queue with two items in it.

390
00:43:09,000 --> 00:43:12,095
The first item, I don't know, it's perhaps a 1.

391
00:43:12,095 --> 00:43:16,530
And the second item, I don't know, let's give it a 2.

392
00:43:21,160 --> 00:43:31,850
The reason why I want two pointers in here, a front pointer and a rear pointer, is so I can add to the end without having to chase down from the beginning.

393
00:43:31,850 --> 00:43:47,530
So for example, if I wanted to add one more item to this queue, if I want to add on another item to be worried about later, all I have to do is make a CONS, which contains that item, say a 3.

394
00:43:47,530 --> 00:43:51,340
That's for inserting 3 into the queue.

395
00:43:51,340 --> 00:44:00,100
Then I have to change this pointer here to here.

396
00:44:00,100 --> 00:44:04,320
And I have to change this one to point to the new rear.

397
00:44:09,120 --> 00:44:18,890
If I wish to take the first element of the queue, the first item, I just go chasing down the front pointer until I find the first one and pick it up.

398
00:44:18,890 --> 00:44:27,450
If I wish to delete the first item from the queue, delete-queue, all I do is move the front pointer along this way.

399
00:44:27,450 --> 00:44:31,700
The new front of the queue is now this.

400
00:44:31,700 --> 00:44:34,390
So queues are very simple too.

401
00:44:34,390 --> 00:44:41,350
So what you see now is that I need a certain number of new primitive operations.

402
00:44:41,350 --> 00:44:42,560
And I'm going to give them some names.

403
00:44:42,560 --> 00:44:47,350
And then we're going to look into how they work, and how they're used.

404
00:44:47,350 --> 00:44:58,940
We have set the CAR of some pair, or a thing produced by CONSing, to a new value.

405
00:45:02,370 --> 00:45:09,920
And set the CDR of a pair to a new value.

406
00:45:12,680 --> 00:45:16,030
And then we're going to look into how they work.

407
00:45:16,030 --> 00:45:20,960
I needed setting CAR over here to delete the first element of the queue.

408
00:45:20,960 --> 00:45:23,470
This is the CAR, and I had to set it.

409
00:45:23,470 --> 00:45:30,160
I had to be able to set the CDR to be able to move the rear pointer, or to be able to increment the queue here.

410
00:45:30,160 --> 00:45:35,515
All of the operations I did were made out of those that I just showed you on the, on the last blackboard.

411
00:45:38,230 --> 00:45:38,430
Good.

412
00:45:38,430 --> 00:45:40,357
Let's pause the time, and take a little break then.

413
00:46:38,346 --> 00:47:21,850
When we originally introduced pairs made out of CONS, made by CONS, we only said a few axioms about them, which were of the form-- what were they-- for all X and Y, the CAR of the CONS of X and Y is X and the CDR of the CONS of X and Y is Y. Now, these say nothing about whether a CONS has an identity like a person.

414
00:47:21,850 --> 00:47:29,740
In fact, all they say is something sort of abstract, that a CONS is the parts it's made out of.

415
00:47:29,740 --> 00:47:37,390
And of course, two things are made out of the same parts, they're the same, at least from the point of view of these axioms.

416
00:47:37,390 --> 00:47:49,830
But by introducing assignment-- in fact, mutable data is a kind of assignment, we have a set CAR and a set CDR-- by introducing those, these axioms no longer tell the whole story.

417
00:47:49,830 --> 00:47:53,250
And they're still true if written exactly like this.

418
00:47:53,250 --> 00:47:56,070
But they don't tell the whole story.

419
00:47:56,070 --> 00:48:10,090
Because if I'm going to set a particular CAR in a particular CONS, the questions are, well, is that setting all CARs and all CONSes of the same two things or not?

420
00:48:10,090 --> 00:48:21,570
If I--if we use CONSes to make up things like rational numbers, or things like 3 over 4, supposing I had two three-fourths.

421
00:48:21,570 --> 00:48:25,340
Are they the same one-- or are they different?

422
00:48:25,340 --> 00:48:27,860
Well, in the case of numbers, it doesn't matter.

423
00:48:27,860 --> 00:48:33,020
Because there's no meaning to changing the denominator of a number.

424
00:48:33,020 --> 00:48:36,840
What you could do is make a number which has a different denominator.

425
00:48:36,840 --> 00:48:44,770
But the concept of changing a number which has to have a different denominator is sort of a very weird, and sort of not supported by what you think of as mathematics.

426
00:48:44,770 --> 00:48:53,690
However, when these CONSes represent things in the physical world, then changing something like the CAR is like removing a piece of the fingernail.

427
00:48:53,690 --> 00:48:57,770
And so CONSes have an identity.

428
00:48:57,770 --> 00:49:01,280
Let me show you what I mean about identity, first of all.

429
00:49:01,280 --> 00:49:04,320
Let's do some little example here.

430
00:49:04,320 --> 00:49:15,200
Supposing I define A to the CONS of 1 and 2.

431
00:49:18,040 --> 00:49:38,120
Well, what that means, first of all, is that somewhere in some environment I've made a symbol A to have a value which is a pair consisting of pointers to a 1 and a pointer to a 2, just like that.

432
00:49:38,120 --> 00:50:03,970
Now, supposing I also say define B to be the CONS--  it doesn't matter, but I like it better, it's prettier-- of A and A.

433
00:50:03,970 --> 00:50:07,840
Well, first of all, I'm using the name A twice.

434
00:50:07,840 --> 00:50:11,300
At this moment, I'm going to think of CONSes as having identity.

435
00:50:11,300 --> 00:50:13,690
This is the same one.

436
00:50:13,690 --> 00:50:33,260
And so what that means is I make another pair, which I'm going to call B. And it contains two pointers to A. At this point, I have three names for this object.

437
00:50:33,260 --> 00:50:34,790
A is its name.

438
00:50:34,790 --> 00:50:37,230
The CAR of B is its name.

439
00:50:37,230 --> 00:50:39,360
And the CDR of B is its name.

440
00:50:39,360 --> 00:50:41,150
It has several aliases, they're called.

441
00:50:44,230 --> 00:51:07,880
Now, supposing I do something like set-the-CAR, the CAR of the CAR of B to 3.

442
00:51:12,750 --> 00:51:17,830
What that means is I find the CAR of B, that's this.

443
00:51:17,830 --> 00:51:20,935
I set the CAR of that to be 3, changing this.

444
00:51:24,760 --> 00:51:35,340
I've changed A. If I were to ask what's the CAR of A--of A now?

445
00:51:35,340 --> 00:51:45,290
I would get out 3, even though here we see that A was the CONS of 1 and 2.

446
00:51:45,290 --> 00:51:48,400
I caused A to change by changing B.

447
00:51:48,400 --> 00:51:52,010
There is sharing here.

448
00:51:52,010 --> 00:51:54,240
That's sometimes what we want.

449
00:51:54,240 --> 00:52:04,350
Surely in the queues and things like that, that's exactly what we defined our--organized our data structures to facilitate-- sharing.

450
00:52:04,350 --> 00:52:25,190
But inadvertent sharing, unanticipated interactions between objects, is the source of most of the bugs that occur in complicated programs. So by introducing this possibility of things having identity and sharing and having multiple names for the same thing, we get a lot of power.

451
00:52:25,190 --> 00:52:28,640
But we're going to pay for it with lots of complexity and bugs.

452
00:52:32,190 --> 00:52:46,560
So also, for example, if I just looked at this just to drive that home, the CADR of B, which has nothing to do with even the CAR of B, apparently.

453
00:52:46,560 --> 00:52:49,350
The CADR of B, what's that?

454
00:52:49,350 --> 00:52:53,560
Take that CDR of B and now take the CAR of that.

455
00:52:53,560 --> 00:52:56,480
Oh, that's 3 also.

456
00:52:56,480 --> 00:53:01,120
So I can have non-local interactions by sharing.

457
00:53:01,120 --> 00:53:02,480
And I have to be very careful of that.

458
00:53:06,640 --> 00:53:22,820
Well, so far, of course, it seems I've introduced several different assignment operators-- set, set CAR, set CDR. Well, maybe I should just get rid of set CAR and set CDR. Maybe they're not worthwhile.

459
00:53:22,820 --> 00:53:27,170
Well, the answer is that once you let the camel's nose into the tent, the rest of him follows.

460
00:53:30,160 --> 00:53:35,850
All I have to have is set, and I can make all of the--all of the bad things that can happen.

461
00:53:38,550 --> 00:53:40,690
Let's play with that a little bit.

462
00:53:40,690 --> 00:53:52,480
A couple of days ago, when we introduced compound data, you saw Hal show you a definition of CONS in terms of a message acceptor.

463
00:53:52,480 --> 00:54:04,440
I'm going to show you even a more horrible thing, a definition of CONS in terms of nothing but air, hot air.

464
00:54:04,440 --> 00:54:14,580
What is the definition of CONS, of the old functional kind, in terms of purely lambdic expressions, procedures?

465
00:54:17,190 --> 00:54:28,580
Because I'm going to then modify this definition to get assignment to be only one kind of assignment, to get rid of the set CAR and set CDR in terms of set.

466
00:54:28,580 --> 00:54:46,320
So what if I define CONS of X and Y to be a procedure of one argument called a message M, which calls that message on X and Y?

467
00:54:51,120 --> 00:54:57,870
This [? idea ?] was invented by Alonzo Church, who was the greatest programmer of the 20th century, although he never saw a computer.

468
00:54:57,870 --> 00:54:59,130
It was done in the 1930s.

469
00:54:59,130 --> 00:55:02,220
He was a logician, I suppose at Princeton at the time.

470
00:55:08,660 --> 00:55:46,670
Define CAR of X to be the result of applying X to that procedure of two arguments, A and D, which selects A. I will define CDR of X to be that procedure, to be the result of applying X to that procedure of A and D, which selects D.

471
00:55:46,670 --> 00:55:50,510
Now, you may not recognize this as CAR, CDR, and CONS.

472
00:55:50,510 --> 00:55:55,210
But I'm going to demonstrate to you that it satisfies the original axioms, just once.

473
00:55:55,210 --> 00:55:58,290
And then we're going to do some playing of games.

474
00:55:58,290 --> 00:56:09,695
Consider the problem CAR of CONS of, say, 35 and 47.

475
00:56:09,695 --> 00:56:11,120
Well, what is that?

476
00:56:11,120 --> 00:56:19,710
It is the result of taking car of the result of substituting 35 and 47 for X and Y in the body of this.

477
00:56:19,710 --> 00:56:20,690
Well, that's easy enough.

478
00:56:20,690 --> 00:56:35,750
That's CAR of the result of substituting into lambda of M, M of 35 and 47.

479
00:56:35,750 --> 00:56:42,830
Well, what this is, is the result of substituting this object for X in the body of that.

480
00:56:42,830 --> 00:57:15,840
So that's just lambda of M-- that's substituted, because this object is being substituted for X, which is the beginning of a list, lambda of M-- M of 35 and 47, applied to that procedure of A and D, which gives me A. Well, that's the result of substituting this for M here.

481
00:57:15,840 --> 00:57:26,026
So that's the same thing as lambda of A, D, A, applied to 35 and 47.

482
00:57:26,026 --> 00:57:27,560
Oh, well that's 35.

483
00:57:27,560 --> 00:57:40,720
That's substituting 35 for A and for 47 for D in A. So I don't need any data at all, not even numbers.

484
00:57:40,720 --> 00:57:42,640
This is Alonso Church's hack.

485
00:57:52,420 --> 00:57:56,760
Well, now we're going to do something nasty to him.

486
00:57:56,760 --> 00:57:58,860
Being a logician, he wouldn't like this.

487
00:57:58,860 --> 00:58:03,260
But as programmers, let's look at the overhead.

488
00:58:03,260 --> 00:58:05,390
And here we go.

489
00:58:05,390 --> 00:58:09,570
I'm going to change the definition of CONS.

490
00:58:09,570 --> 00:58:14,520
It's almost the same as Alonzo Church's, but not quite.

491
00:58:14,520 --> 00:58:16,070
What do we have here?

492
00:58:16,070 --> 00:58:40,940
The CONS of two arguments, X and Y, is going to be that procedure of one argument M, which supplies M to X and Y as before, but also to two permissions, the permission to set X to N and the permission to set Y to N, given that I have an N.

493
00:58:40,940 --> 00:59:03,365
So besides the things that I had here in Church's definition, what I have is that the thing that CONS returns will apply its argument to not just the values of the X and Y that the CONS is made of, but also permissions to set X and Y to new values.

494
00:59:06,540 --> 00:59:11,690
Now, of course, just as before, CAR is exactly the same.

495
00:59:11,690 --> 00:59:22,550
The CAR of X is nothing more than applying X, as in Church's definition, to a procedure, in this case, of four arguments, which selects out the first one.

496
00:59:22,550 --> 00:59:37,920
And just as we did before, that will be the value of X that was contained in the procedure which is the result of evaluating this lambda expression in the environment where X and Y are defined over here.

497
00:59:41,940 --> 00:59:45,640
That's the value of CONS.

498
00:59:45,640 --> 00:59:47,730
Now, however, the exciting part.

499
00:59:47,730 --> 00:59:48,960
CDR, of course, is the same.

500
00:59:48,960 --> 00:59:55,800
The exciting part, set CAR and set CDR. Well, they're nothing very complicated anymore.

501
00:59:55,800 --> 01:00:26,150
Set CAR of a CONS X to a new value Y is nothing more than applying that CONS, which is the procedure of four--the procedure of one argument which applies its argument to four things, to a procedure which is of four arguments-- the value of X, the value of Y, permission to set X, the permission to set Y-- and using it--using that permission to set X to the new value.

502
01:00:31,650 --> 01:00:33,540
And similarly, set-cdr is the same thing.

503
01:00:36,120 --> 01:00:40,470
So what you've just seen is that I didn't introduce any new primitives at all.

504
01:00:40,470 --> 01:00:45,340
Whether or not I want to implement it this way is a matter of engineering.

505
01:00:45,340 --> 01:00:51,680
And the answer is of course I don't implement it this way for reasons that have to do with engineering.

506
01:00:51,680 --> 01:00:58,765
However in principle, logically, once I introduced one assignment operator, I've assigned--I've introduced them all.

507
01:01:05,420 --> 01:01:06,670
Are there any questions?

508
01:01:09,200 --> 01:01:12,040
Yes, David.

509
01:01:12,040 --> 01:01:15,740
AUDIENCE: I can follow you up until you get--I can follow all of that.

510
01:01:15,740 --> 01:01:24,210
But when we bring in the permissions, defining CONS in terms of the lambda N, I don't follow where N gets passed.

511
01:01:24,210 --> 01:01:25,100
PROFESSOR: Oh, I'm sorry.

512
01:01:25,100 --> 01:01:26,340
I'll show you.

513
01:01:26,340 --> 01:01:27,360
Let's follow it.

514
01:01:27,360 --> 01:01:29,180
Of course, we could do it on the blackboard.

515
01:01:29,180 --> 01:01:30,170
It's not so hard.

516
01:01:30,170 --> 01:01:32,450
But it's also easy here.

517
01:01:32,450 --> 01:01:38,520
Supposing I wish to set-cdr of X to Y. See that right there.

518
01:01:38,520 --> 01:01:46,890
set-cdr of X to Y. X is presumably a CONS, a thing resulting from evaluating CONS.

519
01:01:46,890 --> 01:01:58,110
Therefore X comes from a place over here, that that X is of the result of evaluating this lambda expression.

520
01:01:58,110 --> 01:01:59,380
Right?

521
01:01:59,380 --> 01:02:08,950
That when I evaluated that lambda expression, I evaluated it in an environment where the arguments to CONS were defined.

522
01:02:11,750 --> 01:02:29,250
That means that as free variables in this lambda expression, there is the--there are in the frame, which is the parent frame of this lambda expression, the procedure resulting from this lambda expression, X and Y have places.

523
01:02:29,250 --> 01:02:31,910
And it's possible to set them.

524
01:02:31,910 --> 01:02:37,010
I set them to an N, which is the argument of the permission.

525
01:02:37,010 --> 01:02:47,940
The permission is a procedure which is passed to M, which is the argument that the CONS object gets passed.

526
01:02:47,940 --> 01:02:57,480
Now, let's go back here in the set-cdr The CONS object, which is the first argument of set-cdr gets passed an argument.

527
01:03:00,260 --> 01:03:07,920
That--there's a procedure of four things, indeed, because that's the same thing as this M over here, which is applied to four objects.

528
01:03:07,920 --> 01:03:12,970
The object over here, SD, is, in fact, this permission.

529
01:03:15,470 --> 01:03:19,930
When I use SD, I apply it to Y, right there.

530
01:03:22,910 --> 01:03:25,740
So that comes from this.

531
01:03:25,740 --> 01:03:34,160
AUDIENCE: So what do you-- PROFESSOR: So to finish that, the N that was here is the Y which is here.

532
01:03:34,160 --> 01:03:34,810
How's that?

533
01:03:34,810 --> 01:03:35,750
AUDIENCE: Right, OK.

534
01:03:35,750 --> 01:03:41,970
Now, when you do a set-cdr, X is the value the CDR is going to become.

535
01:03:41,970 --> 01:03:44,742
PROFESSOR: The X over here.

536
01:03:44,742 --> 01:03:46,200
I'm sorry, that's not true.

537
01:03:46,200 --> 01:03:56,150
The X is--set-cdr has two arguments-- The CONS I'm changing and the value I'm changing it to.

538
01:03:56,150 --> 01:03:58,320
So you have them backwards, that's all.

539
01:04:01,750 --> 01:04:03,000
Are there any other questions?

540
01:04:07,880 --> 01:04:08,640
Well, thank you.

541
01:04:08,640 --> 01:04:09,890
It's time for lunch.

