0
00:00:00,000 --> 00:00:03,936


1
00:00:03,936 --> 00:00:04,279
[音乐]
[MUSIC-- "JESU, JOY OF
MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

2
00:00:04,279 --> 00:00:05,529
[音乐]
[MUSIC-- "JESU, JOY OF
MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

3
00:00:05,529 --> 00:00:20,180


4
00:00:20,180 --> 00:00:21,840
教授：到目前为止 我们的课程
PROFESSOR: So far in this course we've been talking

5
00:00:21,840 --> 00:00:23,780
关于数据抽象 已经进行了很多的讨论
a lot about data abstraction.

6
00:00:23,780 --> 00:00:28,230
记住它的想法就是在构造系统的时候
And remember the idea is that we build systems that have

7
00:00:28,230 --> 00:00:32,750
在其中加入水平的抽象屏障 这些抽象屏障
these horizontal barriers in them, these abstraction barriers

8
00:00:32,750 --> 00:00:38,490
把使用 你使用一个数据对象的方式
that separate use,the way you might use some

9
00:00:38,490 --> 00:00:41,180
和你表示它的方式区分开来
data object, from the way you might represent it.

10
00:00:41,180 --> 00:00:48,985


11
00:00:48,985 --> 00:00:51,760
或者可以这样理解它 在上层有一个老板
Or another way to think of that is up here you have the boss

12
00:00:51,760 --> 00:00:57,110
想要调用某种数据对象
who's going to be using some sort of data object.

13
00:00:57,110 --> 00:01:02,310
而在下层 一个叫George的人做了它们的具体实现
And down here is George who's implemented it.

14
00:01:02,310 --> 00:01:05,760
这种把使用与表示分离
Now this notion of separating use from representation so you

15
00:01:05,760 --> 00:01:10,600
让你把这两个问题分开考虑的想法
can think about these two problems separately 

16
00:01:10,600 --> 00:01:15,930
是一种非常强大的编程的方法论 那就是数据抽象
is a very,very powerful programming methodology, data abstraction.

17
00:01:15,930 --> 00:01:21,040
但是与此同时，数据抽象在那些真正复杂的系统上
On the other hand, it's not really sufficient for really

18
00:01:21,040 --> 00:01:28,640
并不是很有效 这个问题就出在George这里
complex systems. And the problem with this is George.

19
00:01:28,640 --> 00:01:32,090
或者，实际上，问题就在于
Or actually, the problem is that

20
00:01:32,090 --> 00:01:34,630
现在有太多的George
there are a lot of Georges.

21
00:01:34,630 --> 00:01:35,390
让我们说得具体一点
Let's be concrete.

22
00:01:35,390 --> 00:01:41,192
假设现在有George和Martha两个人
Let's suppose there is George,and there's also Martha.

23
00:01:41,192 --> 00:01:46,040
他们都是这个系统的开发人员
OK, now George and Martha are both working on this system,

24
00:01:46,040 --> 00:01:49,230
都在设计数据的表示方法
both designing representations,


25
00:01:49,230 --> 00:01:51,750
而且他们完全合不来
and absolutely are incompatible.

26
00:01:51,750 --> 00:01:53,620
他们不会合作开发同一种表示方法
They wouldn't cooperate on a representation 

27
00:01:53,620 --> 00:01:57,250
永远也不会
under any circumstances.

28
00:01:57,250 --> 00:02:00,060
现在的问题是 假设你想要这样一个系统
And the problem is you would like to have some system where

29
00:02:00,060 --> 00:02:05,380
在里面George和Martha都为它设计了数据表示方法
both George and Martha are designing representations, and

30
00:02:05,380 --> 00:02:09,756
但是如果你在高于这个抽象屏障的层面思考
yet, if you're above this abstraction barrier you don't

31
00:02:09,756 --> 00:02:12,360
你就不想去操心这些事情，不想去考虑
want to have to worry about that, whether something is

32
00:02:12,360 --> 00:02:14,180
一个东西是George做的还是Martha做的
done by George or by Martha.

33
00:02:14,180 --> 00:02:15,430
同时你也不想让George和Martha
And you don't want George and Martha to

34
00:02:15,430 --> 00:02:16,630
妨碍彼此的工作
interfere with each other.

35
00:02:16,630 --> 00:02:20,310
你在设计系统的时候，你不仅仅需要这些
Somehow in designing a system,you not only want these

36
00:02:20,310 --> 00:02:26,300
水平的抽象屏障，同时也想设置一道
horizontal barriers, but you also want some kind of

37
00:02:26,300 --> 00:02:32,980
垂直的屏障来把George和Martha分离开
vertical barrier to keep George and Martha separate.

38
00:02:32,980 --> 00:02:36,560
我们来说得再具体一点
Let me be a little bit more concrete.

39
00:02:36,560 --> 00:02:42,650
想象一个很大的公司的人事记录
Imagine that you're thinking about personnel records for a

40
00:02:42,650 --> 00:02:48,180
这个公司里有很多相互没什么联系的部门
large company with a lot of loosely linked divisions that

41
00:02:48,180 --> 00:02:50,430
并且部门之间合作得也不太好
don't cooperate very well either.

42
00:02:50,430 --> 00:02:57,040
甚至还可以想象这个大公司就是由
And imagine even that this company is formed by merging a

43
00:02:57,040 --> 00:02:59,450
很多公司组成的，每个公司
whole bunch of companies that already have their personnel

44
00:02:59,450 --> 00:03:00,700
都有自己的一套人事记录
record system set up.

45
00:03:00,700 --> 00:03:03,250


46
00:03:03,250 --> 00:03:06,570
想象一下突然有一天 这些部门
And imagine that once these divisions are all linked in

47
00:03:06,570 --> 00:03:08,530
被一种神奇的卫星网络连接起来
some kind of very sophisticated satellite

48
00:03:08,530 --> 00:03:12,240
它们各自的数据库都被放到了一起
network, and all these databases are put together.

49
00:03:12,240 --> 00:03:17,260
现在你想要做到 在公司的任何地方
And what you'd like to do is,from any place in the company,

50
00:03:17,260 --> 00:03:23,130
都能够知道，哦，某一条人事记录里的
to be able to say things like,oh, what's the name in a

51
00:03:23,130 --> 00:03:26,400
“姓名”是什么
personnel record?

52
00:03:26,400 --> 00:03:30,540
或者一条记录里的“工作”是什么
Or, what's the job description in a personnel record?

53
00:03:30,540 --> 00:03:34,840
同时又不需要担心每一个部门
And not have to worry about the fact that each division

54
00:03:34,840 --> 00:03:36,760
对于怎么进行人事记录
obviously is going to have completely separate

55
00:03:36,760 --> 00:03:41,580
有着完全不同的习惯
conventions for how you might implement these records.

56
00:03:41,580 --> 00:03:44,960
从你的视角上你不想去了解这些东西
From this point you don't want to know about that.

57
00:03:44,960 --> 00:03:48,430
那么怎么才能做到呢
Well how could you possibly do that?

58
00:03:48,430 --> 00:03:52,640
当然有一种方法是下发一个告示
One way, of course, is to send down an edict from somewhere

59
00:03:52,640 --> 00:03:56,290
来通知所有人把他们自己的记录格式
that everybody has to change their format to some fixed

60
00:03:56,290 --> 00:03:58,070
都改成某种标准的格式
compatible thing.

61
00:03:58,070 --> 00:04:01,820
这是人们经常做的事情 而且当然这从来都没有用
That's what people often try,and of course it never works.

62
00:04:01,820 --> 00:04:07,340
你可能想到了另一个办法 设法把这些记录重新安排
Another thing that you might want to do is somehow arrange

63
00:04:07,340 --> 00:04:11,250
让它们中间有这种垂直的抽象屏障
it so you can have these vertical barriers.

64
00:04:11,250 --> 00:04:14,430
当你询问一份人事档案里的姓名是什么的时候
So that when you ask for the name of a personnel record,

65
00:04:14,430 --> 00:04:17,970
不管它是什么格式，name这个过程就能设法
somehow, whatever format it happens to be, name will

66
00:04:17,970 --> 00:04:20,470
搞清楚怎么正确地完成这件事
figure out how to do the right thing.

67
00:04:20,470 --> 00:04:22,730


68
00:04:22,730 --> 00:04:26,260
我们把name叫做一个 所谓的 通用操作符
We want name to be, so-called, a generic operator.

69
00:04:26,260 --> 00:04:30,060
通用操作符意味着它会根据数据的种类
Generic operator means what it sort of precisely does depends

70
00:04:30,060 --> 00:04:33,650
准确地做出对应的操作
on the kind of data that it's looking at.

71
00:04:33,650 --> 00:04:37,100
更进一步讲，你想让这个系统在
More than that, you'd like to design the system so that the

72
00:04:37,100 --> 00:04:43,250
下次公司里多了一个新的人员划分的时候
next time a new division comes into the company they don't

73
00:04:43,250 --> 00:04:45,640
人们连接系统的方法不会有很大的变化
have to make any big changes in what they're already doing

74
00:04:45,640 --> 00:04:50,110
并且公司里剩下的部门
to link into this system, and the rest of the company

75
00:04:50,110 --> 00:04:53,500
要把它们的人员记录添加到这个系统 也不需要
doesn't have to make any big changes to admit their stuff

76
00:04:53,500 --> 00:04:55,520
做什么大的修改
to the system.

77
00:04:55,520 --> 00:04:58,700
那么这就是你应该考虑的问题
So that's the problem you should be thinking about.

78
00:04:58,700 --> 00:05:00,770
或者这就是你的工作
Like it's sort of just your work.

79
00:05:00,770 --> 00:05:02,390
你想让这个系统可以用最少的改动
You want to be able to include new things by

80
00:05:02,390 --> 00:05:03,640
添加新的东西
making minimal changes.

81
00:05:03,640 --> 00:05:05,980


82
00:05:05,980 --> 00:05:07,340
好的，那么这就是
OK, well that's the problem that we'll be

83
00:05:07,340 --> 00:05:09,440
今天我们要讨论的问题
talking about today.

84
00:05:09,440 --> 00:05:13,140
你们应该把这个分布式的人事档案系统
And you should have this sort of distributed personnel

85
00:05:13,140 --> 00:05:14,240
记在脑子里
record system in your mind.

86
00:05:14,240 --> 00:05:16,620
但是实际上我今天要讨论的是一个
But actually the one I'll be talking about is a problem

87
00:05:16,620 --> 00:05:18,900
比那要更加自成体系的问题#TBD
that's a little bit more self-contained than that.

88
00:05:18,900 --> 00:05:21,870
我觉得用它可以把事情说得更清楚一点
that'll bring up the issues, I think, more clearly.

89
00:05:21,870 --> 00:05:25,300
我们要讨论的是一个在复数上
That's the problem of doing a system that does arithmetic on

90
00:05:25,300 --> 00:05:27,770
做算术的系统
complex numbers.

91
00:05:27,770 --> 00:05:30,690
我们来看看这个系统
So let's take a look here.

92
00:05:30,690 --> 00:05:32,460
做一个小小的复习
Just as a little review,there are things

93
00:05:32,460 --> 00:05:35,250
复数这种东西
called complex numbers.

94
00:05:35,250 --> 00:05:36,960
你可以把它看作是平面上的一个点
Complex number you can think of as a point in

95
00:05:36,960 --> 00:05:39,370
我把它叫做z
the plane, or z.

96
00:05:39,370 --> 00:05:46,230
我们可以用复数的实数部分和虚数部分
And you can represent a point either by its real-part and

97
00:05:46,230 --> 00:05:47,190
来表示这个点的坐标
its imaginary-part.

98
00:05:47,190 --> 00:05:51,690
所以如果这个是z 它的实部是这么多
So if this is z and its real-part is this much, and

99
00:05:51,690 --> 00:05:54,880
它的虚部是这么多 然后你写下
its imaginary-part is that much, and you write z

100
00:05:54,880 --> 00:05:56,130
z=x+iy
equals x plus iy.

101
00:05:56,130 --> 00:05:59,110


102
00:05:59,110 --> 00:06:03,210
或者还有一种方法来表示一个复数 我们看
Or another way to represent a complex number is by saying,

103
00:06:03,210 --> 00:06:10,900
这个点与原点的距离是多少 在原点的什么角度上
what's the distance from the origin, and what's the angle?

104
00:06:10,900 --> 00:06:13,940
像这样用一个距离乘以一个角
So that represents a complex number as its radius

105
00:06:13,940 --> 00:06:16,670
也可以表示一个复数
times an angle.

106
00:06:16,670 --> 00:06:19,520


107
00:06:19,520 --> 00:06:20,820
这种表示方法就叫做——之前那一种叫做
This one's called-- the original one's called

108
00:06:20,820 --> 00:06:24,990
直角坐标表示 用实数部分和虚数部分表示复数 
rectangular form, rectangular representation, real- and imaginary-part

109
00:06:24,990 --> 00:06:28,640
这一种叫做极坐标表示
or polar representation

110
00:06:28,640 --> 00:06:30,040
用模（即长度）和辐角（即角度）表示复数
magnitude and angle--

111
00:06:30,040 --> 00:06:32,260
并且如果你知道了一个复数的实部和虚部
and if you know the real- and imaginary-part, you can figure

112
00:06:32,260 --> 00:06:33,720
你就能计算出它的模和辐角
out the magnitude and angle.

113
00:06:33,720 --> 00:06:37,190
如果知道了x和y 就能用这个式子算出r
If you know x and y, you can get r by this formula.

114
00:06:37,190 --> 00:06:39,480
等于两个数平方和的平方根 然后就可以
Square root of sum of the squares, and you can get the

115
00:06:39,480 --> 00:06:41,420
用反三角函数算出辐角的值
angle as an arctangent.

116
00:06:41,420 --> 00:06:44,420
或者反过来 如果你知道了r和A
Or conversely, if you knew r and A you could

117
00:06:44,420 --> 00:06:45,800
你也能计算出x和y
figure out x and y.

118
00:06:45,800 --> 00:06:49,435
x是cosA的r倍 y是sinA的r倍
x is r times the cosine of A,and y is r times the sine of A. 

119
00:06:49,435 --> 00:06:52,490
好，有这样两种表示方法
All right, so there's these two.

120
00:06:52,490 --> 00:06:54,130
对于复数
They're complex numbers.

121
00:06:54,130 --> 00:06:55,810
你在脑子里可以用极坐标表示它们
You can think of them either in polar form

122
00:06:55,810 --> 00:06:57,150
也可以用直角坐标
or rectangular form.

123
00:06:57,150 --> 00:06:59,830
我们要做的事情是设计一个能对复数
What we would like to do is make a system that does

124
00:06:59,830 --> 00:07:03,850
做算术运算的系统
arithmetic on complex numbers.

125
00:07:03,850 --> 00:07:05,580
换句话讲 我们要做的事情是
In other words, what we'd like--

126
00:07:05,580 --> 00:07:07,380
就像之前课上有理数运算的例子一样
just like the rational number example--

127
00:07:07,380 --> 00:07:11,120
是构造一个叫做+c的操作，它接收
is to have some operations plus c, which is going to take

128
00:07:11,120 --> 00:07:14,640
两个复数然后把它们相加，相减
two complex numbers and add them, subtract them, and

129
00:07:14,640 --> 00:07:16,910
相乘或者相除
multiply them, and divide them.

130
00:07:16,910 --> 00:07:20,730


131
00:07:20,730 --> 00:07:25,280
那么我们要用到一点点数学
OK, well there's little bit of mathematics behind it.

132
00:07:25,280 --> 00:07:29,800
对它们进行操作的具体的算式是什么
What are the actual formulas for manipulating such things?

133
00:07:29,800 --> 00:07:34,270
它们是怎么得出来的 并不重要
And it's sort of not important where they come from, but just

134
00:07:34,270 --> 00:07:36,120
我们只是用它们实现运算 我们来看看
as an implementer let's see--

135
00:07:36,120 --> 00:07:40,030
如果想要把两个复数相加 那么很容易就能知道
if you want to add two complex numbers it's pretty easy to

136
00:07:40,030 --> 00:07:42,660
结果的实数部分和虚数部分
get its real-part and its imaginary-part.

137
00:07:42,660 --> 00:07:47,810
两个复数的和的实部
The real-part of the sum of two complex numbers, the

138
00:07:47,810 --> 00:07:53,720
z1+z2的实部就是z1的实部
real-part of the z1 plus z2 is the real-part of z1 plus the

139
00:07:53,720 --> 00:07:54,970
加上z2的实部
real-part of z2.

140
00:07:54,970 --> 00:07:57,820


141
00:07:57,820 --> 00:08:02,770
然后z1+z2的虚部也就是
And the imaginary-part of z1 plus z2 is the imaginary part

142
00:08:02,770 --> 00:08:07,410
z1的虚部加上z2的虚部
of z1 plus the imaginary part of z2.

143
00:08:07,410 --> 00:08:09,480
所以复数相加是非常简单的事情
So it's pretty easy to add complex numbers.

144
00:08:09,480 --> 00:08:12,320
你只要把各个部分分别加起来 然后用各部分的结果
You just add the corresponding parts and make a new complex

145
00:08:12,320 --> 00:08:13,600
再构造一个新的复数
number with those parts.

146
00:08:13,600 --> 00:08:17,180
如果你想要把它们相乘 用极坐标表示它们
If you want to multiply them,it's kind of nice to do it in

147
00:08:17,180 --> 00:08:17,840
要好得多
polar form.

148
00:08:17,840 --> 00:08:21,810
因为对于两个复数 
Because if you have two complex numbers, the magnitude

149
00:08:21,810 --> 00:08:26,285
它们的积的模值 就是它们各自的模的乘积
of their product is here, the product of the magnitudes.

150
00:08:26,285 --> 00:08:28,850


151
00:08:28,850 --> 00:08:35,809
它们的积的辐角就是两个辐角的和
And the angle of the product is the sum of the angles.

152
00:08:35,809 --> 00:08:39,179
那么以上就是对复数做算术运算
So that's sort of mathematics that allows you to do

153
00:08:39,179 --> 00:08:40,549
要用到的一点数学知识
arithmetic on complex numbers.

154
00:08:40,549 --> 00:08:43,720
我们来想一想具体的实现
Let's actually think about the implementation.

155
00:08:43,720 --> 00:08:49,330
我们就像之前运算有理数那样做
Well we do it just like rational numbers.

156
00:08:49,330 --> 00:08:52,200
下降到底层#TBD 假设我们有几个
We come down, we assume we have some

157
00:08:52,200 --> 00:08:53,840
构造函数和选择函数
constructors and selectors.

158
00:08:53,840 --> 00:08:55,330
它们应该是什么样子呢
What would we like?

159
00:08:55,330 --> 00:08:58,890
那么假设我们制造了一层数据对象的云
Well let's assume that we make a data object cloud, which is

160
00:08:58,890 --> 00:09:02,510
它表示一个由一些组件组成的复数 并且
a complex number that has some stuff in it, and that we can

161
00:09:02,510 --> 00:09:05,870
我们能从这个复数中得到它的
get out from a complex number the real-part, or the

162
00:09:05,870 --> 00:09:12,150
实部 虚部 模 或者辐角
imaginary-part, or the magnitude, or the angle.

163
00:09:12,150 --> 00:09:14,320
然后我们需要一种方法来构造复数
We want some ways of making complex numbers-- not only

164
00:09:14,320 --> 00:09:16,800
不仅要有选择函数 还要有构造函数
selectors, but constructors.

165
00:09:16,800 --> 00:09:20,160
那么假设我们有一个叫做make-rectangular的过程
So we'll assume we have a thing called make-rectangular.

166
00:09:20,160 --> 00:09:24,510
这个过程的功能是接受一个实部
What make-rectangular is going to do is take a real-part and

167
00:09:24,510 --> 00:09:28,610
和一个虚部 然后把这两个部分
an imaginary-part and construct a complex number

168
00:09:28,610 --> 00:09:31,920
组合成一个复数
with those parts.

169
00:09:31,920 --> 00:09:35,010
同样我们也可以构造一个make-polar过程
Similarly, we can have make-polar which will take a

170
00:09:35,010 --> 00:09:42,550
它接受一个模和一个辐角 然后用这两个值
magnitude and an angle, and construct a complex number

171
00:09:42,550 --> 00:09:44,680
组成一个复数
which has that magnitude and angle.

172
00:09:44,680 --> 00:09:45,460
那么这个系统
So here's a system.

173
00:09:45,460 --> 00:09:48,910
里面会有两个构造函数和四个选择函数
We'll have two constructors and four selectors.

174
00:09:48,910 --> 00:09:55,150
而现在 就像之前那样 我们基于这个抽象的数据结构
And now, just like before, in terms of that abstract data

175
00:09:55,150 --> 00:09:59,220
继续实现我们的各种复数操作
we'll go ahead and implement our complex number operations.

176
00:09:59,220 --> 00:10:03,280
在这里你可以看到刚才我写下的式子
And here you can see translated into Lisp code just

177
00:10:03,280 --> 00:10:08,330
被翻译成Lisp代码之后的样子
the arithmetic formulas I put down before.

178
00:10:08,330 --> 00:10:13,450
如果我想把两个复数相加 
If I want to add two complex numbers I will make a complex

179
00:10:13,450 --> 00:10:16,630
我就要用一个实部和一个虚部构造一个复数
number out of its real- and imaginary-parts.

180
00:10:16,630 --> 00:10:19,680
这个新的复数的实部是
The real part of the complex number I'm going to make is

181
00:10:19,680 --> 00:10:23,310
两个复数的实部的和
the sum of the real-parts.

182
00:10:23,310 --> 00:10:25,250
它的虚数部分是
The imaginary part of the complex number I'm going to

183
00:10:25,250 --> 00:10:28,005
两个复数的虚部的和
make is the sum of the imaginary-parts.

184
00:10:28,005 --> 00:10:30,310


185
00:10:30,310 --> 00:10:31,990
我把它们放到一起，构造出一个复数
I put those together, make a complex number.

186
00:10:31,990 --> 00:10:35,780
这就是实现复数加法的方法
That's how I implement complex number addition.

187
00:10:35,780 --> 00:10:39,650
减法实际上是一样的
Subtraction is essentially the same.

188
00:10:39,650 --> 00:10:45,140
只需要把各个部分相加变成把它们相减
All I do is subtract the parts rather than add them.

189
00:10:45,140 --> 00:10:47,980
要把两个复数相乘
To multiply two complex numbers, I

190
00:10:47,980 --> 00:10:49,270
我们用另外一个式子
use the other formula.

191
00:10:49,270 --> 00:10:55,350
我会用一个模和一个辐角来构造一个复数
I'll make a complex number out of a magnitude and angle.

192
00:10:55,350 --> 00:10:58,740
这个模就是我要相乘的两个复数的
The magnitude is going to be the product of the magnitudes

193
00:10:58,740 --> 00:11:01,465
模的乘积
of the two complex numbers I'm multiplying.

194
00:11:01,465 --> 00:11:03,710


195
00:11:03,710 --> 00:11:06,980
而这个辐角是我要相乘的
And the angle is going to be the sum of the angles of the

196
00:11:06,980 --> 00:11:09,620
两个复数的辐角的和
two complex numbers I'm multiplying.

197
00:11:09,620 --> 00:11:11,230
那么这就是乘法的实现
So there's multiplication.

198
00:11:11,230 --> 00:11:17,370
然后是除法 除法和乘法几乎是一样的
And then division, division is almost the same.

199
00:11:17,370 --> 00:11:20,660
我只要把两个模相除 把辐角相减就可以了
Here I divide the magnitudes and subtract the angles.

200
00:11:20,660 --> 00:11:28,640


201
00:11:28,640 --> 00:11:31,870
现在我已经实现了具体操作
Now I've implemented the operations.

202
00:11:31,870 --> 00:11:33,640
然后我们做什么
And what do we do?

203
00:11:33,640 --> 00:11:36,060
我们把George叫来
We call on George.

204
00:11:36,060 --> 00:11:38,799
我们完成了“使用”的部分，现在应该考虑“表示”了
We've done the use, let's worry about the representation.

205
00:11:38,799 --> 00:11:38,800


206
00:11:38,800 --> 00:11:42,200
我们叫来George然后对他说 
We'll call on George and say to George, go ahead and build

207
00:11:42,200 --> 00:11:45,250
给我们设计一个表示复数的方法
us a complex number representation.

208
00:11:45,250 --> 00:11:47,770
很好
Well that's fine.

209
00:11:47,770 --> 00:11:52,660
George可能会说 我们把一个复数
George can say, we'll implement a complex number

210
00:11:52,660 --> 00:11:57,000
用一个由实部和虚部组成的序对来实现
simply as a pair that has the real-part and the imaginary-part.

211
00:11:57,000 --> 00:11:57,200



212
00:11:57,200 --> 00:12:01,020
那么如果我想用一个确定的
So if I want to make a complex number with a certain

213
00:12:01,020 --> 00:12:03,860
实部和一个虚部来构造一个复数
real-part and an imaginary-part,I'll just use

214
00:12:03,860 --> 00:12:06,640
我只需要用cons来构造一个序对 然后就可以——
cons to form a pair, and that will-- that's George's

215
00:12:06,640 --> 00:12:09,780
这就是George表示复数的方法
representation of a complex number.

216
00:12:09,780 --> 00:12:12,420
那么如果我想获得它的实部 我只需要
So if I want to get out the real-part of something, I just

217
00:12:12,420 --> 00:12:14,350
提取出序对的car，它的第一部分
extract the car,the first part.

218
00:12:14,350 --> 00:12:17,300
如果我想要得到虚部 我就提取出它的cdr
If I want to get the imaginary-part, I extract the

219
00:12:17,300 --> 00:12:22,220
那对于模和辐角我怎么处理呢
cdr. How do I deal with the magnitude and angle?

220
00:12:22,220 --> 00:12:25,750
如果我拿出一个复数 想要得到它的模
Well if I want to extract the magnitude of one of these things

221
00:12:25,750 --> 00:12:29,000
我只要计算它的car与cdr的平方的和
I get the square root of the sum of the square of the car

222
00:12:29,000 --> 00:12:34,310
的平方根就好了 如果我想得到
 plus the square of the cdr. If I want to get the

223
00:12:34,310 --> 00:12:39,520
辐角 我就计算它的cdr与car比值的反正切
angle, I compute the arctangent of the cdr in the car.

224
00:12:39,520 --> 00:12:39,530



225
00:12:39,530 --> 00:12:43,300
这个是计算反正切的lisp过程
This is a lisp procedure for computing arctangent.

226
00:12:43,300 --> 00:12:44,970


227
00:12:44,970 --> 00:12:49,150
要是有人给我一个模和一个辐角 然后说
And if somebody hands me a magnitude and an angle and

228
00:12:49,150 --> 00:12:51,670
给我构造一个复数 那么我只要
says, make me a complex number,well I compute the

229
00:12:51,670 --> 00:12:55,280
用它们计算出实部和虚部 或者说a的余弦值
real-part and the imaginary-part, or our cosine of a

230
00:12:55,280 --> 00:12:58,120
和正弦值 然后把它们
and our sine of a, and stick them

231
00:12:58,120 --> 00:13:01,460
连接成一个序对就行了
together into a pair.

232
00:13:01,460 --> 00:13:02,260
完成了
OK so we're done.

233
00:13:02,260 --> 00:13:07,830
实际上我做的事情 在概念上讲 
In fact, what I just did,conceptually, is absolutely no

234
00:13:07,830 --> 00:13:11,710
和我们之前提过的有理数的表示
different from the rational number representation that we

235
00:13:11,710 --> 00:13:12,750
是完全没有区别的
looked at last time.

236
00:13:12,750 --> 00:13:13,910
它们的思想相同
It's the same sort of idea.

237
00:13:13,910 --> 00:13:18,070
写好操作过程 选择一种表示方法
You implement the operators,you pick a representation.

238
00:13:18,070 --> 00:13:20,070
没有什么不同
Nothing different.

239
00:13:20,070 --> 00:13:23,210
现在我们来关心一下Martha
Now let's worry about Martha.

240
00:13:23,210 --> 00:13:26,670
看，Martha的想法不太一样
See, Martha has a different idea.

241
00:13:26,670 --> 00:13:29,490
她不想把复数表示成
She doesn't want to represent a complex number as a pair of

242
00:13:29,490 --> 00:13:30,900
由实部和虚部组成的一个序对
a real-part and an imaginary-part.

243
00:13:30,900 --> 00:13:34,170
她比较喜欢把它们表示成
What she would like to do is represent a complex number as

244
00:13:34,170 --> 00:13:39,550
由模和辐角组成的序对
a pair of a magnitude and an angle.

245
00:13:39,550 --> 00:13:42,130
那么如果我们没有让George而是让Martha
So if instead of calling up George we ask Martha to design

246
00:13:42,130 --> 00:13:44,570
来设计复数的表示方法 我们就会得到这样的东西
our representation, we get something like this.

247
00:13:44,570 --> 00:13:47,160
有一个make-polar过程
We get make-polar.

248
00:13:47,160 --> 00:13:50,220
当然了 有了一个模和一个辐角之后
Sure, if I give you a magnitude and an angle we're

249
00:13:50,220 --> 00:13:55,430
我们只要把它们组合成一个序对就行了
just going to form a pair that has magnitude and angle.

250
00:13:55,430 --> 00:13:57,680
你要是想得到一个复数的模 那很简单
If you want to extract the magnitude, that's easy.

251
00:13:57,680 --> 00:13:59,780
你只要把序对的car拿出来就行了
You just pull out the car or the pair.

252
00:13:59,780 --> 00:14:02,670
想得到一个复数的辐角 那也很简单
If you want to extract the angle, sure, that's easy.

253
00:14:02,670 --> 00:14:05,480
只要把cdr拿出来 
You just pull out the cdr.

254
00:14:05,480 --> 00:14:07,660
但是如果你想要获得实部和虚部
If you want to look for real-parts and imaginary-parts,

255
00:14:07,660 --> 00:14:08,590
那就得费点力气
well then you have to do some work.

256
00:14:08,590 --> 00:14:14,580
想得到实部 你就得计算r*cos a
If you want the real-part, you have to get r cosine a.

257
00:14:14,580 --> 00:14:19,990
换句话讲 用序对的car去乘以
In other words, r, the car of the pair, times the cosine of

258
00:14:19,990 --> 00:14:20,950
cdr的余弦值
the cdr of the pair.

259
00:14:20,950 --> 00:14:26,230
然后你就算出了r*cos a
So this is r times the cosine of a,

260
00:14:26,230 --> 00:14:28,330
这就是这个复数的实部
and that's the real-part.

261
00:14:28,330 --> 00:14:30,810
要是想算出它的虚部
If you want to get the imaginary-part, it's r times

262
00:14:30,810 --> 00:14:32,660
用r乘以sin a就可以了
the sine of a.

263
00:14:32,660 --> 00:14:37,930
现在如果我给你一个实部和一个虚部然后说
And if I hand you a real-part and an imaginary-part and say,

264
00:14:37,930 --> 00:14:42,030
用它们给我构造一个复数
make me a complex number with that real-part and

265
00:14:42,030 --> 00:14:44,170
那就要先算出
imaginary-part, well I figure out what the magnitude and

266
00:14:44,170 --> 00:14:45,540
模和辐角是多少
angle should be.

267
00:14:45,540 --> 00:14:48,090
模是实部和虚部的平方和再开平方
The magnitude's the square root of the sum of the squares

268
00:14:48,090 --> 00:14:49,230
辐角是这个反正切
and the angle's the arctangent.

269
00:14:49,230 --> 00:14:52,090
我用这两个数构造一个序对
I put those together to make a pair.

270
00:14:52,090 --> 00:14:54,170
以上就是Martha的想法
So there's Martha's idea.

271
00:14:54,170 --> 00:14:56,690


272
00:14:56,690 --> 00:14:59,680
那么哪种表示方法比较好呢
Well which is better?

273
00:14:59,680 --> 00:15:02,850
如果你需要做很多加法 那么George的
Well if you're doing a lot of additions, probably George's

274
00:15:02,850 --> 00:15:04,810
比较好 因为你总是要用到复数的实部
is better, because you're doing a lot of real-parts and

275
00:15:04,810 --> 00:15:05,850
和虚部
imaginary-parts.

276
00:15:05,850 --> 00:15:07,920
如果你大多数时间都是在做乘法
If mostly you're going to be doing multiplications and

277
00:15:07,920 --> 00:15:11,140
和除法 那可能Martha的办法就要好一些
divisions, then maybe Martha's idea is better.

278
00:15:11,140 --> 00:15:16,590
又或者——这就是问题所在了——你决定不了
Or maybe, and this is the real point, you can't decide.

279
00:15:16,590 --> 00:15:21,170
或者你想让它们同时存在#TBD 出于某些
Or maybe you just have to let them both hang around, for

280
00:15:21,170 --> 00:15:23,480
个人原因
personality reasons.

281
00:15:23,480 --> 00:15:25,870
也可能你是真的
Maybe you just really can't ever decide

282
00:15:25,870 --> 00:15:28,560
不知道你想要什么
what you would like.

283
00:15:28,560 --> 00:15:31,520
又回到这个话题 我们真正想要的
And again, what we would really like is a system that

284
00:15:31,520 --> 00:15:32,320
是这样一个系统
looks like this.

285
00:15:32,320 --> 00:15:37,090
这里面既有George 他实现了
That somehow there's George over here, who has built

286
00:15:37,090 --> 00:15:41,470
复数的直角坐标表示
rectangular complex numbers.

287
00:15:41,470 --> 00:15:46,120
又有Martha 她实现了复数的极坐标表示
And Martha, who has polar complex numbers.

288
00:15:46,120 --> 00:15:54,200
然后我们有各种操作 用来对复数进行加减
And somehow we have operations that can add, and subtract,

289
00:15:54,200 --> 00:15:59,710
或者乘除，那么这些操作
and multiply, and divide, and it shouldn't matter that there

290
00:15:59,710 --> 00:16:02,790
不应该受到系统中同时存在的这两种
are two incompatible representations of complex

291
00:16:02,790 --> 00:16:04,410
互不兼容的复数表示方法的影响
numbers floating around this system.

292
00:16:04,410 --> 00:16:09,640
或者说 我们不光有这样一个抽象屏障：
In other words, not only like an abstraction barrier here

293
00:16:09,640 --> 00:16:15,770
它里面有real-part
that has things in it like a real-part, and an

294
00:16:15,770 --> 00:16:23,830
imaginary-part 有magnitude和angle这几个过程
imaginary-part, and magnitude,and angle.

295
00:16:23,830 --> 00:16:26,850
不光有一层抽象屏障
So not only is there an abstraction barrier that hides

296
00:16:26,850 --> 00:16:30,310
把实际的数据表示隐藏起来
the actual representation from us, but also there's some kind

297
00:16:30,310 --> 00:16:33,620
还有一层垂直的屏障
of vertical barrier here that allows both of these

298
00:16:33,620 --> 00:16:36,270
容许不同的表示方法彼此共存
representations to exist without

299
00:16:36,270 --> 00:16:38,570
而不互相干预
interfering with each other.

300
00:16:38,570 --> 00:16:41,900
我们的想法是把这些东西
The idea is that the things in here--

301
00:16:41,900 --> 00:16:44,120
real-part, imaginary-part,magnitude,angle这些过程
real-part, imaginary-part,magnitude, and angle--

302
00:16:44,120 --> 00:16:47,310
设计成通用操作符
will be generic operators.

303
00:16:47,310 --> 00:16:50,190
如果你调用real-part过程 它就会判断
If you ask for the real-part,it will worry about what

304
00:16:50,190 --> 00:16:53,880
要在哪一种表示方法中寻找它
representation it's looking at.

305
00:16:53,880 --> 00:16:56,840
那么我们怎么做到这一点呢
OK, well how can we do that?

306
00:16:56,840 --> 00:17:00,290
实际上有一个很容易想到的办法 如果你习惯了
There's actually a really obvious idea, if you're used

307
00:17:00,290 --> 00:17:02,770
思考复数的事情
to thinking about complex numbers.

308
00:17:02,770 --> 00:17:06,390
如果你已经习惯了复合数据的思想
If you're used to thinking about compound data.

309
00:17:06,390 --> 00:17:10,990
假设你只要观察一个复数
See, suppose you could just tell by looking at a complex number

310
00:17:10,990 --> 00:17:13,190
就能看出它是被George还是Martha
whether it was constructed

311
00:17:13,190 --> 00:17:15,790
构造出来的
by George or Martha.

312
00:17:15,790 --> 00:17:18,900
换句话说 在你眼前漂浮的这些东西#TBD
In other words, so it's not that what's floating around

313
00:17:18,900 --> 00:17:20,910
不是普通的复数 对吗
here are ordinary, just complex numbers, right?

314
00:17:20,910 --> 00:17:24,390
它们是被某个设计者构想出来的的复数
They're fancy, designer complex numbers.

315
00:17:24,390 --> 00:17:27,260
那么你不把一个复数
So you look at a complex numbers as it's not just a

316
00:17:27,260 --> 00:17:29,190
只看作一个复数 它上面有一个标签
complex number, it's got a label on it that says, this

317
00:17:29,190 --> 00:17:31,450
写着这个是由Martha制造的
one is by Martha.

318
00:17:31,450 --> 00:17:34,480
或者这个是由George制造的
Or this is a complex number by George.

319
00:17:34,480 --> 00:17:34,481


320
00:17:34,481 --> 00:17:36,860
好吗 它们被签了名字
Right?They're signed.

321
00:17:36,860 --> 00:17:40,155
在这之后 无论何时我们看见一个复数
See, and then whenever we looked at a complex number we

322
00:17:40,155 --> 00:17:45,800
我们只要看它的标签  然后我们就能知道
could just read the label, and then we'd know how you expect

323
00:17:45,800 --> 00:17:48,030
应该怎么对它进行操作
to operate on that.

324
00:17:48,030 --> 00:17:49,850
或者说 我们想要的不只是
In other words, what we want is not just

325
00:17:49,850 --> 00:17:51,190
普通的数据对象
ordinary data objects.

326
00:17:51,190 --> 00:17:53,120
我们引入一个概念
We want to introduce the notion of what's

327
00:17:53,120 --> 00:17:54,370
叫做类型数据
called typed data.

328
00:17:54,370 --> 00:17:59,760


329
00:17:59,760 --> 00:18:03,940
类型数据就意味着 这里有一朵“云”
Typed data means, again, there's some sort of cloud.

330
00:18:03,940 --> 00:18:08,930
它里面有我们之前所说的那种
And what it's got in it is an ordinary data object like

331
00:18:08,930 --> 00:18:10,180
普通的数据对象
we've been thinking about.

332
00:18:10,180 --> 00:18:13,180


333
00:18:13,180 --> 00:18:16,540
这是它的内容 就是实际的数据
Pulled out the contents, sort of the actual data.

334
00:18:16,540 --> 00:18:19,320


335
00:18:19,320 --> 00:18:24,220
它里面还有一个叫做类型的东西
But also a thing called a type, but it's signed by

336
00:18:24,220 --> 00:18:25,999
被George或者Martha签了名
either George or Martha.

337
00:18:25,999 --> 00:18:29,340
那么我们现在就要从无类型的数据进入类型数据的领域
So we're going to go from regular data to type data.

338
00:18:29,340 --> 00:18:31,950


339
00:18:31,950 --> 00:18:32,710
我们怎么构造它
How do we build that?

340
00:18:32,710 --> 00:18:33,990
那很简单
Well that's easy.

341
00:18:33,990 --> 00:18:35,200
我们知道怎么构造“云”
We know how to build clouds.

342
00:18:35,200 --> 00:18:37,920
我们用序对来组成它们
We can build them out of pairs.

343
00:18:37,920 --> 00:18:41,050
那么我们就有了一种表示方法
So here's a little representation that supports

344
00:18:41,050 --> 00:18:43,510
来表示类型数据
typed data.

345
00:18:43,510 --> 00:18:49,020
这种方法叫做 把一种类型附加到
There's a thing called take a type and attach it to a piece

346
00:18:49,020 --> 00:18:51,530
一块内容上 用cons就可以做到
of contents, and we just use cons.

347
00:18:51,530 --> 00:18:54,370
然后面对一个类型数据 我们就可以知道它的类型
And if we have a piece of typed data, we can look at the type

348
00:18:54,370 --> 00:18:56,290
那就是序对的car
which is the car.

349
00:18:56,290 --> 00:19:00,460
我们也可以知道它的具体内容 就是它的cdr
We can look at the contents,which is the cdr. Now along

350
00:19:00,460 --> 00:19:05,420
我们用这种方法使用类型数据
with that, the way we use our type data will test, when

351
00:19:05,420 --> 00:19:07,520
面对一段类型数据就能知道它是什么类型
we're given a piece of data,what type it is.

352
00:19:07,520 --> 00:19:10,510
那么我们现在有了几种类型谓词
So we have some type predicates with us.

353
00:19:10,510 --> 00:19:13,730
举例来讲 想要知道一个复数
For example, to see whether a complex number is one of

354
00:19:13,730 --> 00:19:16,860
是不是George构造的 是不是直角坐标表示的 我们只需要看
George's, whether it's rectangular, we just check to

355
00:19:16,860 --> 00:19:23,850
它的“类型”是不是rectangular这个标志 对吧
see if the type of that is the symbol rectangular, right?

356
00:19:23,850 --> 00:19:25,100
rectangular标志
The symbol rectangular.

357
00:19:25,100 --> 00:19:27,200


358
00:19:27,200 --> 00:19:30,650
同理 想要知道一个复数是不是Martha构造的
And to check whether a complex number is one of Martha's, we

359
00:19:30,650 --> 00:19:34,430
我们就看它的“类型”是不是polar这个标志
check to see whether the type is the symbol polar.

360
00:19:34,430 --> 00:19:36,460


361
00:19:36,460 --> 00:19:38,710
那么这就是一种识别数字的类型
So that's a way to test what kind of number

362
00:19:38,710 --> 00:19:40,350
的方法
we're looking at.

363
00:19:40,350 --> 00:19:42,070
现在来想想怎么用这种方法
Now let's think about how we can use that

364
00:19:42,070 --> 00:19:43,870
来构建我们的系统
to build the system.

365
00:19:43,870 --> 00:19:46,170
我们假设George和Martha分别在做
So let's suppose that George and Martha were off working 

366
00:19:46,170 --> 00:19:50,710
自己的工作 每一个人都设计了他们的
separately, and each of them had designed their complex

367
00:19:50,710 --> 00:19:52,640
复数表示程序包
number representation packages.

368
00:19:52,640 --> 00:19:58,980
他们怎么让自己的东西成为系统的一部分
What do they have to do to become part of the system, to

369
00:19:58,980 --> 00:20:00,140
和对方友好共存呢
exist compatibly?

370
00:20:00,140 --> 00:20:02,860
那其实非常简单
Well it's really pretty easy.

371
00:20:02,860 --> 00:20:05,970
回忆一下，George做了这个程序包
Remember, George had this package.

372
00:20:05,970 --> 00:20:08,980
这就是George的程序包 或者说它的一部分
Here's George's original package, or half of it.

373
00:20:08,980 --> 00:20:12,090
然后红色下划线标出的部分是他需要做的修改
And underlined in red are the changes he has to make.

374
00:20:12,090 --> 00:20:17,000
之前，当George用x和y构建了一个复数的时候
So before, when George made a complex number out of an x and y

375
00:20:17,000 --> 00:20:20,930
他只是把它们组合成一个序对
he just put them together to make a pair.

376
00:20:20,930 --> 00:20:24,090
现在唯一不同的地方是他给它们打了标签
And the only difference is that now he signs them.

377
00:20:24,090 --> 00:20:26,920
他把类型 也就是rectangular标志
He attaches the type,which is the symbol

378
00:20:26,920 --> 00:20:30,600
附加到这个序对上面
rectangular to that pair.

379
00:20:30,600 --> 00:20:33,920
剩下的事情都和之前一样 除了一点
Everything else George does is the same, except that--

380
00:20:33,920 --> 00:20:35,970
看 George和Martha的程序都有叫做
see, George and Martha both have procedures named

381
00:20:35,970 --> 00:20:38,700
real-part和imaginary-part的过程
real-part and imaginary-part.

382
00:20:38,700 --> 00:20:44,220
为了这些过程存在于在同一个Lisp环境中
So to allow them both to exist in the same Lisp environment,

383
00:20:44,220 --> 00:20:45,920
George就要修改他的过程名字
George had changed the names of his procedures.

384
00:20:45,920 --> 00:20:49,145
那么我们说 这是George的real-part过程
So we'll say, this is George's real-part procedure.

385
00:20:49,145 --> 00:20:52,710
叫做real-part-rectangular过程
It's the real-part rectangular procedure, the imaginary-part

386
00:20:52,710 --> 00:20:55,170
这是imaginary-part-rectangular过程
rectangular procedure.

387
00:20:55,170 --> 00:20:59,130
那么这里是George的程序包剩下的部分
And then here's the rest of George's package.

388
00:20:59,130 --> 00:21:02,060
他已经有了magnitude和angle过程 只要把它们改名
He'd had magnitude and angle,just renames them magnitude

389
00:21:02,060 --> 00:21:05,702
叫magnitude-rectangular和angle-rectangular就好了
rectangular and angle rectangular.

390
00:21:05,702 --> 00:21:09,860
Martha要做的事情基本相同
And Martha has to do basically the same thing.

391
00:21:09,860 --> 00:21:15,200
在这之前，当她用模和辐角
Martha previously, when she made a complex number out of a

392
00:21:15,200 --> 00:21:19,270
构造复数的时候 她只是把这两个东西cons起来
magnitude and angle,she just cons them.

393
00:21:19,270 --> 00:21:25,330
现在她把polar类型附加到她的数据上 然后修改
Now she attaches the type polar,and she changes the

394
00:21:25,330 --> 00:21:28,100
她的过程的名字来保证她的real-part过程
name so her real-part procedure won't conflict in

395
00:21:28,100 --> 00:21:30,710
不会和George的产生冲突
name with George's.

396
00:21:30,710 --> 00:21:34,540
那就是real-part-polar,imaginary-part-polar
It's a real-part-polar,imaginary-part-polar,

397
00:21:34,540 --> 00:21:38,060
magnitude-polar和angle-polar这四个过程
magnitude polar, and angle polar.

398
00:21:38,060 --> 00:21:45,000


399
00:21:45,000 --> 00:21:46,130
现在我们的系统
Now we have the system.

400
00:21:46,130 --> 00:21:49,160
在它里面既有George又有Martha
Right there's George and Martha.

401
00:21:49,160 --> 00:21:51,050
然后现在我们需要一个经理来
And now we've got to get some kind of manager to look at

402
00:21:51,050 --> 00:21:52,300
对类型进行判断
these types.

403
00:21:52,300 --> 00:21:55,050


404
00:21:55,050 --> 00:21:57,530
那么在George和Martha给我们提供了类型数据之后
How are these things actually going to work now that George

405
00:21:57,530 --> 00:22:00,530
这个系统现在怎么工作呢
and Martha have supplied us with typed data?

406
00:22:00,530 --> 00:22:05,260
我们手里有的 是一堆选择函数
Well what we have are a bunch of generic selectors.

407
00:22:05,260 --> 00:22:07,800
用于复数的选择函数
Generic selectors for complex numbers

408
00:22:07,800 --> 00:22:10,630
real-part,imaginary-part, magnitude, and angle.

409
00:22:10,630 --> 00:22:14,140


410
00:22:14,140 --> 00:22:16,410
让我们更进一步观察它们
Let's look at them more closely.

411
00:22:16,410 --> 00:22:17,930


412
00:22:17,930 --> 00:22:19,310
real-part过程应该做什么
What does a real-part do?

413
00:22:19,310 --> 00:22:24,070
如果我想得到一个复数的实部
If I ask for the real part of a complex number,

414
00:22:24,070 --> 00:22:25,800
那么我先要观察它
well I look at it.

415
00:22:25,800 --> 00:22:26,690
我观察它的类型
I look at its type.

416
00:22:26,690 --> 00:22:28,940
我说，它是用直角坐标表示的吗
I say, is it rectangular?

417
00:22:28,940 --> 00:22:31,020


418
00:22:31,020 --> 00:22:36,970
如果是的话，我就对这个复数的"内容"部分
If so, I apply George's real part procedure to the contents

419
00:22:36,970 --> 00:22:40,220
调用George的real-part过程
of that complex number.

420
00:22:40,220 --> 00:22:41,230


421
00:22:41,230 --> 00:22:43,720
这是一个带有类型的数字
This is a number that has a type on it.

422
00:22:43,720 --> 00:22:46,340
我用contents过程剥掉类型
I strip off the type using contents and

423
00:22:46,340 --> 00:22:49,590
并且对它应用George的过程
apply George's procedure.

424
00:22:49,590 --> 00:22:50,700


425
00:22:50,700 --> 00:22:53,950
或者说这是一个用极坐标表示的复数
Or is this a polar complex number?

426
00:22:53,950 --> 00:22:57,190
如果我想要得到它的实部 我就把Martha的real-part过程
If I want the real part, I apply Martha's real-part procedure

427
00:22:57,190 --> 00:22:59,850
应用在这个数的内容上
to the contents of that number.

428
00:22:59,850 --> 00:23:02,260
这就是real-part工作的方式
So that's how real part works.

429
00:23:02,260 --> 00:23:04,670
还有类似的imaginary-part过程
And then similarly there's imaginary-part, which is

430
00:23:04,670 --> 00:23:06,770
几乎是一样的
almost the same.

431
00:23:06,770 --> 00:23:09,600
它先观察这个数字 它是直角坐标表示的
It looks at the number and if it's rectangular, uses

432
00:23:09,600 --> 00:23:11,130
就调用George的imaginary-part过程
George's imaginary-part procedure.

433
00:23:11,130 --> 00:23:13,380
是极坐标表示的 就用Martha的过程
If it's polar, uses Martha's.

434
00:23:13,380 --> 00:23:18,240
同理也可以构造出magnitude和angle两个过程
And then there's a magnitude and an angle.

435
00:23:18,240 --> 00:23:19,880


436
00:23:19,880 --> 00:23:21,130
现在我们的系统是这个样子
So there's a system.

437
00:23:21,130 --> 00:23:23,000


438
00:23:23,000 --> 00:23:24,260
它里面有三个部分
Has three parts.

439
00:23:24,260 --> 00:23:26,760
有George，Martha和一个经理
There's sort of George, and Martha, and the manager.

440
00:23:26,760 --> 00:23:28,970
这就是实现通用操作符的方法
And that's how you get generic operators implemented.

441
00:23:28,970 --> 00:23:33,500
为了把它说清楚 我们举一个简单的实例
Let's look at just a simple example, just to pin it down.

442
00:23:33,500 --> 00:23:40,240
但是准确描述了它工作的方式 假设你现在
But exactly how this is going to work, suppose you're going

443
00:23:40,240 --> 00:23:44,460
面对一个实部是1
to be looking at the complex number who's real-part is one,

444
00:23:44,460 --> 00:23:46,090
虚部是2的复数
and who's imaginary-part is two.

445
00:23:46,090 --> 00:23:50,310
也就是说1+2i
So that would be one plus 2i.

446
00:23:50,310 --> 00:23:56,350
现在在这里 在操作所处的
What would happen is up here,up here above where the

447
00:23:56,350 --> 00:23:58,530
顶层 那个数会被
operations have to happen,that number would be

448
00:23:58,530 --> 00:24:10,320
表示成一个由1和2组成的序对加上类型数据
represented as a pair of 1 and 2 together with type data.

449
00:24:10,320 --> 00:24:11,870
（1和2）是内容
That would be the contents.

450
00:24:11,870 --> 00:24:16,300
整个的数据就是在那之上加上一个
And the whole data would be that thing with the symbol

451
00:24:16,300 --> 00:24:17,960
rectangular的记号
rectangular added onto that.

452
00:24:17,960 --> 00:24:20,980
这就是复数在这个系统里
And that's the way that complex number would exist in

453
00:24:20,980 --> 00:24:22,330
存在的形式
the system.

454
00:24:22,330 --> 00:24:26,560
你要调取real-part的时候 经理就会
When you went to take the real-part, the manager would

455
00:24:26,560 --> 00:24:30,270
看看这个数然后说，这是George的那种数字
look at this and say, oh it's one of George's.

456
00:24:30,270 --> 00:24:34,440
他会把类型拿掉 然后把
He'll strip off the type and hand down to

457
00:24:34,440 --> 00:24:37,532
(1,2)这个序对传递给George
George the pair 1, 2.

458
00:24:37,532 --> 00:24:41,420
这是George的系统
And that's the kind of data that George developed his

459
00:24:41,420 --> 00:24:43,670
可以直接处理的数据
system to use.

460
00:24:43,670 --> 00:24:44,950


461
00:24:44,950 --> 00:24:46,680
那么它被拆了出来
So it gets stripped down.

462
00:24:46,680 --> 00:24:51,240
之后 如果你让George构造一个复数
Later on, if you ask George to construct a complex number,

463
00:24:51,240 --> 00:24:55,370
George就会把它构造成序对
George would construct some complex number as a pair, and

464
00:24:55,370 --> 00:24:59,630
在数据被传递到上层之前 经理会
before he passes it back up through the manager would

465
00:24:59,630 --> 00:25:00,880
给它再加上rectangular类型
attach the type rectangular.

466
00:25:00,880 --> 00:25:03,920


467
00:25:03,920 --> 00:25:04,650
看这个过程
So you see what happens.

468
00:25:04,650 --> 00:25:05,850
这个系统不会发生混乱
There's no confusion in this system.

469
00:25:05,850 --> 00:25:13,780
就算在Martha的世界里序对(1 2)的含义完全不同
It doesn't matter in the least that the pair 1, 2 means

470
00:25:13,780 --> 00:25:15,750
也并没有什么影响
something completely different in Martha's world.

471
00:25:15,750 --> 00:25:18,440
在Martha的世界里这个序对代表了
In Martha's world this pair means the complex number whose

472
00:25:18,440 --> 00:25:21,190
一个模为1，辐角为2的复数
magnitude is 1 and whose angle is 2.

473
00:25:21,190 --> 00:25:23,930
但是这并不会造成混乱
And there's no confusion,because by the time any pair

474
00:25:23,930 --> 00:25:27,250
因为每当有一个这样的序对经由经理之手
like this gets handed back through the manager to the

475
00:25:27,250 --> 00:25:31,210
被交给主系统的时候 它都会被附加上polar的类型标志
main system it's going to have the type polar attached.

476
00:25:31,210 --> 00:25:33,670
而这个就会被贴上rectangular类型的标签
Whereas this one would have the type rectangular attached.

477
00:25:33,670 --> 00:25:36,930


478
00:25:36,930 --> 00:25:38,180
好 我们休息一下
OK, let's take a break.

479
00:25:38,180 --> 00:25:40,770


480
00:25:40,770 --> 00:25:41,057
[音乐]
[MUSIC-- "JESU, JOY OF
MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

481
00:25:41,057 --> 00:25:42,307
[音乐]
[MUSIC-- "JESU, JOY OF
MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

482
00:25:42,307 --> 00:26:20,210


483
00:26:20,210 --> 00:26:22,080
我们刚刚提出了一种
We just looked at a strategy for

484
00:26:22,080 --> 00:26:24,150
实现通用操作符的策略
implementing generic operators.

485
00:26:24,150 --> 00:26:31,400
这种策略有一个名字 叫做基于类型的分派
That strategy has a name: it's called dispatch on type.

486
00:26:31,400 --> 00:26:34,310


487
00:26:34,310 --> 00:26:38,480
它的想法就是你要把你的系统
And the idea is that you break your system

488
00:26:38,480 --> 00:26:39,360
分成很多小块
into a bunch of pieces.

489
00:26:39,360 --> 00:26:43,250
里面有George和Martha在设计表示方法
There's George and Martha, who are making representations,

490
00:26:43,250 --> 00:26:46,320
还有一个经理
and then there's the manager.

491
00:26:46,320 --> 00:26:49,880
负责去看数据上的类型是什么 然后把它们
Looks at the types on the data and then dispatches them to

492
00:26:49,880 --> 00:26:51,990
分派给正确的人去处理
the right person.

493
00:26:51,990 --> 00:26:55,320
我们对于这种组织系统的方法
Well what criticisms can we make of that as a system

494
00:26:55,320 --> 00:26:57,570
能提出什么批评意见呢？
organization?

495
00:26:57,570 --> 00:26:58,150


496
00:26:58,150 --> 00:27:00,400
首先是这个小小的烦人的问题
Well first of all there was this little, annoying problem

497
00:27:00,400 --> 00:27:04,210
George和Martha需要修改他们的过程的名字
that George and Martha had to change the names of their procedures

498
00:27:04,210 --> 00:27:04,220


499
00:27:04,220 --> 00:27:06,160
George一开始写了一个real-part过程
George originally had a real-part procedure, and he

500
00:27:06,160 --> 00:27:09,110
现在他必须把它的名字改成real-part-rectangular
had to go name it real-part rectangular so it wouldn't

501
00:27:09,110 --> 00:27:11,170
才能让它不与Martha的real-part过程相互冲突
interfere with Martha's real-part procedure, which is

502
00:27:11,170 --> 00:27:14,410
而Martha的过程现在改叫real-part-polar
now named real-part-polar, so it wouldn't interfere with the

503
00:27:14,410 --> 00:27:17,310
为了不和经理的那个叫做real-part的过程发生冲突
manager's real-part procedure, who's now named real-part.

504
00:27:17,310 --> 00:27:19,460
这确实是很烦人的事情
That's kind of an annoying problem.

505
00:27:19,460 --> 00:27:21,270
但是我现在暂时不讨论这个问题
But I'm not going to talk about that one now.

506
00:27:21,270 --> 00:27:24,450
我们在之后讨论到Lisp名称与环境
We'll see later on when we think about the structure of

507
00:27:24,450 --> 00:27:27,480
的结构的时候就会知道 我们有办法
Lisp names and environments that there really are ways to

508
00:27:27,480 --> 00:27:30,390
把这些所谓的命名空间分开来封装
package all those so-called name spaces separately so they

509
00:27:30,390 --> 00:27:32,500
然后它们就不会互相影响了
don't interfere with each other.

510
00:27:32,500 --> 00:27:35,720
现在我们暂时不去考虑这个问题
Not going to think about that problem now.

511
00:27:35,720 --> 00:27:38,740
我现在想关注的问题是
The problem that I actually want to focus on is what

512
00:27:38,740 --> 00:27:44,510
你把一个新人招纳进系统之中会发生什么
happens when you bring somebody new into the system.

513
00:27:44,510 --> 00:27:45,320
会发生什么
What has to happen?

514
00:27:45,320 --> 00:27:47,690
George和Martha并不关心
Well George and Martha don't care.

515
00:27:47,690 --> 00:27:52,830
George坐在他的直角坐标世界里
George is sitting there in his rectangular world, has his

516
00:27:52,830 --> 00:27:54,090
坐拥着他的过程和数据类型们
procedures and his types.

517
00:27:54,090 --> 00:27:56,260
而Martha待在她的极坐标世界中
Martha sits in her polar world.

518
00:27:56,260 --> 00:27:59,380
也不关心外面发生了什么
She doesn't care.

519
00:27:59,380 --> 00:28:01,540
但是我们来看看我们的经理
But let's look at the manager.

520
00:28:01,540 --> 00:28:03,180
经理需要做什么
What's the manager have to do?

521
00:28:03,180 --> 00:28:07,360
现在经理来了 带着他的操作符
The manager comes through and had these operations.

522
00:28:07,360 --> 00:28:09,040
有直角坐标的判断
There was a test for rectangular

523
00:28:09,040 --> 00:28:10,140
和极坐标的判断过程
and a test for polar.

524
00:28:10,140 --> 00:28:17,210
如果Harry进入这个系统 他带着某种新型的复数表示方法
If Harry comes in with some new kind of complex number,

525
00:28:17,210 --> 00:28:20,430
同时带来了一个新的类型 Harry型复数
and Harry has a new type, Harry type complex number, the

526
00:28:20,430 --> 00:28:25,240
经理就需要修改他所有的过程
manager has to go in and change all those procedures.

527
00:28:25,240 --> 00:28:28,940
所以这个系统的不灵活之处
So the inflexibility in the system, the place where work

528
00:28:28,940 --> 00:28:34,890
需要大量工作才能适应变化的地方 就在这个经理身上
has to happen to accommodate change, is in the manager.

529
00:28:34,890 --> 00:28:35,990
那是非常恼人的事情
That's pretty annoying.

530
00:28:35,990 --> 00:28:40,300
更恼人的是你意识到这个经理实际上
It's even more annoying when you realize the manager's not

531
00:28:40,300 --> 00:28:42,590
什么也不做
doing anything.

532
00:28:42,590 --> 00:28:46,690
他只会坐在办公室摆弄公文
The manager is just being a paper pusher.

533
00:28:46,690 --> 00:28:51,760
我们再来看看这些程序 它们在做什么
Let's look again at these programs. What are they doing?

534
00:28:51,760 --> 00:28:52,880
real-part过程在做什么
What does real-part do?

535
00:28:52,880 --> 00:28:56,170
这个过程说 哦 这个复数是
Real-part says, oh, is it the kind of complex number that

536
00:28:56,170 --> 00:28:57,000
George会处理的那一种吗
George can handle?

537
00:28:57,000 --> 00:28:59,410
如果是的话 好 把它交给George处理
If so, send it off to George.

538
00:28:59,410 --> 00:29:01,910
它是Martha能操作的那一种吗
Is it the kind of complex number that Martha can handle?

539
00:29:01,910 --> 00:29:05,040
是的话 把它交给Martha处理
If so, send it off to Martha.

540
00:29:05,040 --> 00:29:08,720
所以非常恼人的一件事就是这个系统的瓶颈
So it's really annoying that the bottleneck in this system,

541
00:29:08,720 --> 00:29:13,040
降低灵活性 阻碍变化的那个东西
the thing that's preventing flexibility and change, is

542
00:29:13,040 --> 00:29:15,000
完全是一个没用的官僚
completely in the bureaucracy.

543
00:29:15,000 --> 00:29:19,700
而不是任何做实事的人
It's not in anybody who's doing any of the work.

544
00:29:19,700 --> 00:29:23,300
很可惜这种情况经常发生
Not an uncommon situation,unfortunately.

545
00:29:23,300 --> 00:29:24,570
实际上发生的事情是
See, what's really going on--

546
00:29:24,570 --> 00:29:28,100
在系统中，有一张抽象的表格
abstractly in the system,there's a table.

547
00:29:28,100 --> 00:29:31,150
实际发生的事情是有这样一张表格
So what's really happening is somewhere there's a table.

548
00:29:31,150 --> 00:29:32,780


549
00:29:32,780 --> 00:29:34,400
这里是各种类型
There're types.

550
00:29:34,400 --> 00:29:38,565
有polar和rectangular
There's polar and rectangular.

551
00:29:38,565 --> 00:29:41,550


552
00:29:41,550 --> 00:29:44,380
可能Harry也在这里
And Harry's may be over here.

553
00:29:44,380 --> 00:29:48,050
然后这里是各种操作
And there are operators.

554
00:29:48,050 --> 00:29:51,340
各种操作 像real-part
There's an operator like real-part.

555
00:29:51,340 --> 00:29:55,600


556
00:29:55,600 --> 00:30:00,010
和imaginary-part
Or imaginary-part.

557
00:30:00,010 --> 00:30:05,830
还有magnitude angle这些操作符
Or a magnitude and angle.

558
00:30:05,830 --> 00:30:19,280
然后表格里面是(对这种类型做这种操作)应该使用的过程
And sitting in this table are the right procedures.

559
00:30:19,280 --> 00:30:21,990
那么填在这里负责polar类型的real-part操作的是
So sitting here for the type polar and real-part is

560
00:30:21,990 --> 00:30:24,730
Martha的real-part-polar过程
Martha's procedure real-part-polar.

561
00:30:24,730 --> 00:30:30,570


562
00:30:30,570 --> 00:30:33,740
然后在这里是George的
And over here in the table is George's procedure

563
00:30:33,740 --> 00:30:36,990
real-part-rectangular过程
real-part-rectangular.

564
00:30:36,990 --> 00:30:37,740


565
00:30:37,740 --> 00:30:40,680
然后这里是Martha的
And over here would be, say,Martha's procedure

566
00:30:40,680 --> 00:30:46,780
magnitude-polar过程 和George的
magnitude-polar, and George's procedure

567
00:30:46,780 --> 00:30:49,760
magnitude-rectangular过程 等等等等
magnitude-rectangular,right, and so on.

568
00:30:49,760 --> 00:30:52,390
表格里剩下的空格也像这样填好
The rest of this table's filled in.

569
00:30:52,390 --> 00:30:54,260
这就是实际上发生的事情
And that's really what's going on.

570
00:30:54,260 --> 00:30:57,630


571
00:30:57,630 --> 00:31:03,380
从某种意义上讲 经理做的事情就是
So in some sense, all the manager is doing is acting as

572
00:31:03,380 --> 00:31:05,630
去扮演这张表格
this table.

573
00:31:05,630 --> 00:31:06,860


574
00:31:06,860 --> 00:31:09,610
那我们怎么去改进这个系统呢
Well how do we fix our system?

575
00:31:09,610 --> 00:31:12,110


576
00:31:12,110 --> 00:31:13,770
怎么去消灭这种官僚主义
How do you fix bureaucracies a lot of the time?

577
00:31:13,770 --> 00:31:16,240
你要做的就是让这个经理走人
What you do is you get rid of the manager.

578
00:31:16,240 --> 00:31:20,170
我们把他赶走 用一台计算机来代替他
We just take the manager and replace him by a computer.

579
00:31:20,170 --> 00:31:23,320
我们要让自动操作抹掉他存在的意义
We're going to automate him out of existence.

580
00:31:23,320 --> 00:31:25,970
也就是说 我们不用这个经理去查阅
Namely, instead of having the manager who basically consults

581
00:31:25,970 --> 00:31:31,020
这个表格 而是让我们的系统直接去查阅它
this table, we'll have our system use the table directly.

582
00:31:31,020 --> 00:31:32,110
我的意思是什么呢
What do I mean by that?

583
00:31:32,110 --> 00:31:38,730
我们来假设 还是用数据抽象的观点 我们有
Let's assume, again using data abstraction, that we have some

584
00:31:38,730 --> 00:31:40,880
这样一种表格数据结构
kind of data structure that's a table.

585
00:31:40,880 --> 00:31:43,080
而且我们还有把东西填进去
And we have ways of sticking things in and ways of getting

586
00:31:43,080 --> 00:31:44,356
和从中删除的方法
things out.

587
00:31:44,356 --> 00:31:47,000
为了把话说清楚 我们可以假设
And to be explicit, let me assume that there's an

588
00:31:47,000 --> 00:31:52,710
我们现在有一个叫put的方法 这个方法需要两个
operation called "put." And put is going to take, in this

589
00:31:52,710 --> 00:32:00,130
我们把它叫做key(关键字)的东西 key1和key2
case two things I'll call "keys." Key1 and key2.

590
00:32:00,130 --> 00:32:01,380
还有一个值
And a value.

591
00:32:01,380 --> 00:32:06,200


592
00:32:06,200 --> 00:32:11,490
这个过程把这个值存放在表格中key1和key2对应的格子里
And that stores the value in the table under key1 and key2.

593
00:32:11,490 --> 00:32:15,530
然后我们假设有另一个过程叫get
And then we'll assume there's a thing called "get," such

594
00:32:15,530 --> 00:32:19,680
它是这样的一个东西 如果我说把表格里
that if later on I say, get me what's in the table stored

595
00:32:19,680 --> 00:32:25,010
key1和key2对应的格子中的数据给我 它就会返回给我
under key1 and key2, it'll retrieve whatever value was

596
00:32:25,010 --> 00:32:26,730
那里的东西
stored there.

597
00:32:26,730 --> 00:32:30,000
我们先不要担心这个表格怎么实现
And let's not worry about how tables are implemented.

598
00:32:30,000 --> 00:32:33,060
那又是另一个数据抽象了，是George需要考虑的问题
That's yet another data abstraction, George's problem.

599
00:32:33,060 --> 00:32:34,700
也许以后我们还会看到
And maybe we'll see later--

600
00:32:34,700 --> 00:32:36,970
我们还会讨论怎么用lisp建立这个表格
talk about how you might actually build tables in Lisp.

601
00:32:36,970 --> 00:32:40,710


602
00:32:40,710 --> 00:32:44,850
我们有了这个组织结构 George和Martha
Well given this organization,what did George and Martha

603
00:32:44,850 --> 00:32:47,380
需要做什么呢
have to do?

604
00:32:47,380 --> 00:32:50,010
当他们构建自己的系统的时候
Well when they build their system, they each have the

605
00:32:50,010 --> 00:32:52,750
他们两个都要负责在表格里
responsibility to set up their appropriate

606
00:32:52,750 --> 00:32:55,210
正确地添加上自己的那一列
column in the table.

607
00:32:55,210 --> 00:33:00,920
那么George，比如说，当他定义他的过程的时候
So what George does, for example, when he defines his procedures

608
00:33:00,920 --> 00:33:04,020
他需要做的就是把它们放进
all he has to do is go off and put into the

609
00:33:04,020 --> 00:33:07,990
表格中的rectangular类型的那一列下面
table under the type-rectangular.

610
00:33:07,990 --> 00:33:09,820


611
00:33:09,820 --> 00:33:14,100
然后操作的名字是real-part
And the name of the operation is real-part, his procedure

612
00:33:14,100 --> 00:33:16,250
他放入他的real-part-rectangular过程
real-part-rectangular.

613
00:33:16,250 --> 00:33:17,780
注意有什么被放到了表格里
So notice what's going into this table.

614
00:33:17,780 --> 00:33:22,100
这里的两个key是rectangular和real-part这两个记号
The two keys here are symbols,rectangular and real-part.

615
00:33:22,100 --> 00:33:24,400
加上引号表示它是一个符号数据
That's the quote.

616
00:33:24,400 --> 00:33:27,410
要被填到表里的东西是他编写的
And what's going into the table is the actual procedure

617
00:33:27,410 --> 00:33:28,870
real-part-rectangular过程
that he wrote, real-part rectangular.

618
00:33:28,870 --> 00:33:32,040


619
00:33:32,040 --> 00:33:35,000
然后把这个获取虚部的过程也放进表里
And then puts an imaginary part into the table, filed

620
00:33:35,000 --> 00:33:39,370
分类到rectangular和imaginary-part两个关键字之下
under the keys rectangular and imaginary-part, and

621
00:33:39,370 --> 00:33:44,020
获取模值的过程放到rectangular和magnitude下面
magnitude under the keys rectangular magnitude, angle

622
00:33:44,020 --> 00:33:46,270
获取辐角的过程放到rectangular和angle下面
under rectangular-angle.

623
00:33:46,270 --> 00:33:47,350


624
00:33:47,350 --> 00:33:50,840
George要成为系统的一部分，就要做以上这些事情
So that's what George has to do to be part of this system.

625
00:33:50,840 --> 00:33:54,420


626
00:33:54,420 --> 00:33:57,740
Martha用同样的方法填好表格中
Martha similarly sets up the column and

627
00:33:57,740 --> 00:33:59,430
polar的这一列
the table under polar.

628
00:33:59,430 --> 00:34:02,160
在polar和real-part对应的这一栏
Polar and real-part.

629
00:34:02,160 --> 00:34:04,340
应该填的过程是real-part-polar 是吧
Is the procedure real-part-polar?

630
00:34:04,340 --> 00:34:09,030
然后是imaginary-part,magnitude和angle
And imaginary-part, and magnitude, and angle.

631
00:34:09,030 --> 00:34:11,409
Martha想要加入系统当中就要做这些事情
So this is what Martha has to do to be part of the system.

632
00:34:11,409 --> 00:34:13,550
每个设计了数据表示的人
Everyone who makes a representation has the

633
00:34:13,550 --> 00:34:17,840
都必须在表格里设置自己的一列
responsibility for setting up a column in the table.

634
00:34:17,840 --> 00:34:19,900
那么Harry带着他的绝妙的复数实现方法
And what does Harry do when Harry comes in with his

635
00:34:19,900 --> 00:34:21,800
过来的时候 他需要做什么呢
brilliant idea for implementing complex numbers?

636
00:34:21,800 --> 00:34:25,170
他把他的过程写好
Well he makes whatever procedure he wants and builds

637
00:34:25,170 --> 00:34:28,550
然后在表格里再建立一列
a new column in this table.

638
00:34:28,550 --> 00:34:31,330
那么现在经理怎么样了呢
OK, well what happened to the manager?

639
00:34:31,330 --> 00:34:34,610
经理的存在被自动操作所取代
The manager has been automated out of existence and is

640
00:34:34,610 --> 00:34:37,110
被一个叫做operate的过程代替
replaced by a procedure called operate.

641
00:34:37,110 --> 00:34:40,380
这是这个系统最关键的一个过程
And this is the key procedure in the whole system.

642
00:34:40,380 --> 00:34:45,920
我们写下 define operate
Let's say define operate.

643
00:34:45,920 --> 00:34:51,060


644
00:34:51,060 --> 00:34:57,750
Operate过程接收你想要做的操作
Operate is going to take an operation that you want to do,

645
00:34:57,750 --> 00:35:01,840
应该说是这个操作的名字，和你想要把操作
the name of an operation, and an object that you would like

646
00:35:01,840 --> 00:35:04,210
应用于其上的那个对象
to apply that operation to.

647
00:35:04,210 --> 00:35:07,400
那么举例来说 对一个复数调用real-part
So for example, the real-part of some particular complex

648
00:35:07,400 --> 00:35:09,890
operate会做什么呢
number, what does it do?

649
00:35:09,890 --> 00:35:12,650
它要做的第一件事就是去查表
Well the first thing it does,it looks in the table.

650
00:35:12,650 --> 00:35:20,710
它翻阅这个表格，试图去找到写在表格里
Goes into the table and tries to find a procedure that's

651
00:35:20,710 --> 00:35:23,320
的一个过程
stored in the table.

652
00:35:23,320 --> 00:35:29,830
所以它要对表格调用get过程 用对象的类型
So it gets from the table, using as keys the type of the

653
00:35:29,830 --> 00:35:40,450
和操作的名称作为关键字 这样就可以
object and the operator, but looks on the table and sees

654
00:35:40,450 --> 00:35:42,300
知道在表格中 与数据的类型和要进行的操作
what's stored under the type of the object and the

655
00:35:42,300 --> 00:35:44,440
对应的这一格里填了什么东西
operator, sees if anything's stored.

656
00:35:44,440 --> 00:35:45,930
我们假设get过程已经被实现好了
Let's assume that get is implemented.

657
00:35:45,930 --> 00:35:52,560
所以如果在那一格什么也没有 它就会返回一个空表
So if nothing is stored there,it'll return the empty list.

658
00:35:52,560 --> 00:35:55,130
如果那里确实有什么东西
So it says, if there's actually something stored

659
00:35:55,130 --> 00:36:04,920
如果有这样的一个过程 那么它就会
there, if the procedure here is not no, then it'll take the

660
00:36:04,920 --> 00:36:11,240
把它在表里找到的这个过程应用到
procedure that it found in the table and apply it to the

661
00:36:11,240 --> 00:36:15,120
对象的具体内容上去
contents of the object.

662
00:36:15,120 --> 00:36:18,042


663
00:36:18,042 --> 00:36:21,445
如果那里没有东西的话 它就会
And otherwise if there was nothing stored there, it'll--

664
00:36:21,445 --> 00:36:22,435
我们可以决定
well we can decide.

665
00:36:22,435 --> 00:36:25,920
我们让它输出一个错误消息
In this case let's have it put out an error message saying,

666
00:36:25,920 --> 00:36:28,650
未定义的操作符
undefined operator.

667
00:36:28,650 --> 00:36:30,230
没有支持这种类型的操作
No operator for this type.

668
00:36:30,230 --> 00:36:32,770


669
00:36:32,770 --> 00:36:35,285
或者其它合适的错误信息
Or some appropriate error message.

670
00:36:35,285 --> 00:36:39,150


671
00:36:38,750 --> 00:36:39,300
跟上了吗
OK?

672
00:36:39,300 --> 00:36:41,890
那么我们用这个东西替换了经理
And that replaces the manager.

673
00:36:41,890 --> 00:36:43,960
我们怎么去使用它呢
How do we really use it?

674
00:36:43,960 --> 00:36:48,580
我们的想法是operate过程
Well what we say is we'll go off and define our generic

675
00:36:48,580 --> 00:36:50,040
来定义我们的通用选择函数
selectors using operate.

676
00:36:50,040 --> 00:36:57,140
我们可以说一个对象的real-part
We'll say that the real-part of an object is found by

677
00:36:57,140 --> 00:37:05,010
是这个对象被operate应用了叫做real-part的操作后
operating on the object with the name of the operation

678
00:37:05,010 --> 00:37:06,260
得到的结果
being real-part.

679
00:37:06,260 --> 00:37:08,070


680
00:37:08,070 --> 00:37:10,870
那么类似地，imaginary-part是operate对其应用
And then similarly,imaginary-part is operate

681
00:37:10,870 --> 00:37:16,080
imaginary-part操作后得到的结果 magnitude和angle同理
using the name imaginary-part and magnitude and angle.

682
00:37:16,080 --> 00:37:17,430
这就是我们的实现方法
That's our implementation.

683
00:37:17,430 --> 00:37:21,330
由它们加上类型再加上operate过程组成
That plus the type plus the operate procedure.

684
00:37:21,330 --> 00:37:23,100
那么这个表格现在就有效地完成了
And the table effectively replaces what the

685
00:37:23,100 --> 00:37:24,150
之前由经理完成的工作
manager used to do.

686
00:37:24,150 --> 00:37:27,040
我们来梳理一下在这个过程中
Let's just go through that slowly to show you

687
00:37:27,040 --> 00:37:27,900
发生的事情
what's going on.

688
00:37:27,900 --> 00:37:33,000
假设我有一个由Martha构造的复数
Suppose I have one of Martha's complex numbers.

689
00:37:33,000 --> 00:37:35,520


690
00:37:35,520 --> 00:37:39,100
它的模值是1，辐角是2
It's got magnitude 1 and angle 2.

691
00:37:39,100 --> 00:37:40,220
它是由Martha构造的
And it's one of Martha's.

692
00:37:40,220 --> 00:37:47,120
所以它被贴上了polar的标签
So it's labeled here, polar.

693
00:37:47,120 --> 00:37:48,000
我们叫它z
Let's call that z.

694
00:37:48,000 --> 00:37:49,250
假设这就是z
Suppose that's z.

695
00:37:49,250 --> 00:37:51,770


696
00:37:51,770 --> 00:37:54,320
然后假设在这种实现方法下
And suppose with this implementation someone comes

697
00:37:54,320 --> 00:37:58,110
有人想要对z应用real-part操作
up and asks for the real-part of z.

698
00:37:58,110 --> 00:38:04,870


699
00:38:04,870 --> 00:38:08,920
那么real-part现在是用operate来定义的
Well real-part now is defined in terms of operate.

700
00:38:08,920 --> 00:38:18,470
这就等同于说对它调用operate 
So that's equivalent to saying operate with the name of the

701
00:38:18,470 --> 00:38:27,060
real-part作为操作符 应用到z上
operator being real-part, the symbol real-part on z.

702
00:38:27,060 --> 00:38:28,090
然后operate过程
And now operate comes.

703
00:38:28,090 --> 00:38:31,720
就会去查询表格 然后试图去
It's going to look in the table,and it's going to try

704
00:38:31,720 --> 00:38:35,005
寻找在表格里存放的
and find something stored under--

705
00:38:35,005 --> 00:38:38,830

706
00:38:38,830 --> 00:38:42,160
查询表格中哪一栏和
the operation is going to apply by looking in the table

707
00:38:42,160 --> 00:38:46,225
这个对象的类型相对应
under the type of the object.

708
00:38:46,225 --> 00:38:48,790
那么z的类型是polar
And the type of z is polar.

709
00:38:48,790 --> 00:38:52,990
所以它就要说 我用polar作为关键字查表
So it's going to look and say,can I get using polar?

710
00:38:52,990 --> 00:38:59,250
然后操作的名称 是real-part
And the operation name,which was real-part.

711
00:38:59,250 --> 00:39:05,960


712
00:39:05,960 --> 00:39:09,490
它查询对应的过程
It's going to look in there and apply that to

713
00:39:09,490 --> 00:39:14,930
然后应用到z的内容上去
the contents of z.

714
00:39:14,930 --> 00:39:15,650


715
00:39:15,650 --> 00:39:20,350
如果所有东西都安排妥当的话
If everything was set up correctly, this thing is the

716
00:39:20,350 --> 00:39:21,700
它找到的过程就是Martha放在那里的过程
procedure that Martha put there.

717
00:39:21,700 --> 00:39:22,950
就是real-part-polar.
This is real-part-polar.

718
00:39:22,950 --> 00:39:30,790


719
00:39:30,790 --> 00:39:35,130
然后这就是z去掉类型之后的东西
And this is z without its type.

720
00:39:35,130 --> 00:39:37,860
是Martha最初设计过程
The thing that Martha originally designed those

721
00:39:37,860 --> 00:39:41,340
用来处理的那种东西 在这里是序对(1 2)
procedures to work on,which is 1, 2.

722
00:39:41,340 --> 00:39:43,790


723
00:39:43,790 --> 00:39:47,210
所以说在整个系统中operate过程
And so operate sort of does uniformly what the manager

724
00:39:47,210 --> 00:39:49,450
和之前的经理做的事情没什么区别
used to do sort of all over the system.

725
00:39:49,450 --> 00:39:52,170
它找到正确的东西 查询表格
It finds the right thing, looks in the table, strips off

726
00:39:52,170 --> 00:39:56,600
剥掉类型的外衣 然后把它传递给
the type, and passes it down into the

727
00:39:56,600 --> 00:39:59,160
能够处理它的人
person who handles it.

728
00:39:59,160 --> 00:40:04,980
这是另一种 你会发现在大多数情况下
This is another, and, you can see, more flexible for most

729
00:40:04,980 --> 00:40:07,990
更灵活的实现通用操作符的方法
purposes, way of implementing generic operators.

730
00:40:07,990 --> 00:40:16,505
我们把它叫做数据驱动编程
And it's called data-directed programming.

731
00:40:16,505 --> 00:40:20,350


732
00:40:20,350 --> 00:40:24,920
它的想法是 在某种意义上这些数据对象
And the idea of that is in some sense the data objects

733
00:40:24,920 --> 00:40:27,260
本身 这些在系统里漂浮的
themselves, those little complex numbers that are

734
00:40:27,260 --> 00:40:30,340
小小的复数 它们自身就携带关于
floating around the system,are carrying with them the

735
00:40:30,340 --> 00:40:35,390
应该怎么去操作它们 这样的信息
information about how you should operate on them.

736
00:40:35,390 --> 00:40:37,640
我们暂停一下 大家可以提问
Let's break for questions.

737
00:40:37,640 --> 00:40:41,000


738
00:40:41,000 --> 00:40:41,240
好
Yes.

739
00:40:41,240 --> 00:40:43,390
学生：你在那个数据对象里存储的是什么呢
AUDIENCE: What do you have stored in that data object?

740
00:40:43,390 --> 00:40:47,850
这里面有这个数据本身 还有它的类型
You have the data itself, you have its type, and you have

741
00:40:47,850 --> 00:40:49,690
还有对那个类型的操作过程
the operations for that type?

742
00:40:49,690 --> 00:40:53,600
或者说这些操作 被放在哪里呢
Or where are the operations that you found?

743
00:40:53,600 --> 00:40:54,980
教授：好，让我——
PROFESSOR: OK, let me--

744
00:40:54,980 --> 00:40:56,500
啊 那是一个好问题
yeah, that's a good question.

745
00:40:56,500 --> 00:40:59,700
通过它可以想到实现我们目标的
Because it raises other possibilities of how

746
00:40:59,700 --> 00:41:00,750
其它可能的方法
you might do it.

747
00:41:00,750 --> 00:41:04,200
当然可能的方法有很多
And of course there are a lot of possibilities.

748
00:41:04,200 --> 00:41:06,820
在我们的这种实现当中 
In this particular implementation, what's sitting

749
00:41:06,820 --> 00:41:11,630
在这个数据对象里放着的 是数据本身
in this data object, for example, is the data itself--

750
00:41:11,630 --> 00:41:14,980
在这个例子就是1和2组成的序对
which in this case is a pair of 1 and 2--

751
00:41:14,980 --> 00:41:16,550
和一个标志
and also a symbol.

752
00:41:16,550 --> 00:41:21,140
这就是那个标志 单词P-O-L-A-R
This is the symbol, the word P-O-L-A-R, and that's what's

753
00:41:21,140 --> 00:41:23,390
这些就是这个数据对象里面的东西
sitting in this data object.

754
00:41:23,390 --> 00:41:24,870


755
00:41:24,870 --> 00:41:26,690
这些操作本身在哪里呢
Where are the operations themselves?

756
00:41:26,690 --> 00:41:29,850
这些操作在表格里
The operations are sitting in the table.

757
00:41:29,850 --> 00:41:35,450
在这个表格里 所有行和列的名字
So in this table, the rows and columns of the table are

758
00:41:35,450 --> 00:41:38,230
都是前面说的标志
labeled by symbols.

759
00:41:38,230 --> 00:41:40,810
所以当我往里面存什么东西的时候 关键字可以是
So when I store something in this table, the key might be

760
00:41:40,810 --> 00:41:48,240
polar标志与magnitude标志这样的东西
the symbol polar and the symbol magnitude.

761
00:41:48,240 --> 00:41:51,310
我这样写下它可能让你们感到困惑了
And I think by writing it this way I've been very confusing.

762
00:41:51,310 --> 00:41:53,160
因为在这里面放的并不是
Because what's really sitting here isn't--

763
00:41:53,160 --> 00:41:58,360
当我写下magnitude-polar的时候 我想要表达的是那个
when I wrote magnitude polar, what I mean is the procedure

764
00:41:58,360 --> 00:41:59,850
叫magnitude-polar的过程
magnitude polar.

765
00:41:59,850 --> 00:42:02,580
大概我本来应该在这里写上
And probably what I really should have written--

766
00:42:02,580 --> 00:42:04,200
但是这里空间太小了
except it's too small for me to write

767
00:42:04,200 --> 00:42:05,580
我写不下
in this little space--

768
00:42:05,580 --> 00:42:11,250
应该写成lambda(z)什么什么 这样的东西
is something like lambda of z, the thing that

769
00:42:11,250 --> 00:42:14,710
或者说Martha实现的过程本身
Martha wrote to implement.

770
00:42:14,710 --> 00:42:16,620
从这里你可以看出来 我已经暗示了
And then you can see from that,there's another way that

771
00:42:16,620 --> 00:42:20,250
解决这个名字冲突问题的另一个方法
I alluded to of solving this name conflict problem, which

772
00:42:20,250 --> 00:42:22,380
那就是George和Martha根本不用给他们的
is that George and Martha never have to name their

773
00:42:22,380 --> 00:42:23,150
过程起名字
procedures at all.

774
00:42:23,150 --> 00:42:26,710
他们可以直接把由lambda标识的
They can just stick the anonymous things generated by

775
00:42:26,710 --> 00:42:28,660
匿名函数放进表格里
lambda directly into the table.

776
00:42:28,660 --> 00:42:32,540
你的问题还引出了另一种可能性
There's also another thing that your question raises, is

777
00:42:32,540 --> 00:42:36,045
就是也许我想存储在
the possibility that maybe what I would like somehow is

778
00:42:36,045 --> 00:42:40,120
这个数据对象里的 不是POLAR这个标志
to store in this data object not the symbol P-O-L-A-R but

779
00:42:40,120 --> 00:42:43,520
而是所有这些操作本身
maybe actually all the operations themselves.

780
00:42:43,520 --> 00:42:45,860
那就是组织这个系统的另一个方法
And that's another way to organize the system, called

781
00:42:45,860 --> 00:42:48,650
叫做消息传递
message passing.

782
00:42:48,650 --> 00:42:50,970
所以说有很多方法来实现我们的目标
So there are a lot of ways you can do it.

783
00:42:50,970 --> 00:42:54,640


784
00:42:54,640 --> 00:42:58,040
学生：所以说如果Martha和George
AUDIENCE: Therefore if Martha and George had used the same

785
00:42:58,040 --> 00:43:01,230
用了相同的过程名字也没什么问题
procedure names, it would be OK because it wouldn't look

786
00:43:01,230 --> 00:43:02,560
因为它不会看起来
it wouldn't look 

787
00:43:02,560 --> 00:43:04,889
教授：对 对
PROFESSOR: That's right.That's right.

788
00:43:04,889 --> 00:43:04,890

789
00:43:04,890 --> 00:43:07,060
看 他们甚至根本不需要
See, they wouldn't even have to name their

790
00:43:07,060 --> 00:43:09,470
给他们的过程起名字
procedures at all.

791
00:43:09,470 --> 00:43:12,440
George放在表格里
What George could have written instead of saying put in the

792
00:43:12,440 --> 00:43:16,890
rectangular和real-part对应的格子里的东西
table under rectangular- and real-part, the procedure

793
00:43:16,890 --> 00:43:19,660
可以不是real-part-rectangular这个过程
real-part rectangular, George could have written put under

794
00:43:19,660 --> 00:43:23,080
他也可以在这个格子里放一个lambda(z)然后什么什么
rectangular real-part, lambda of z, such and such,

795
00:43:23,080 --> 00:43:24,540
这样一个匿名函数
and such and such.

796
00:43:24,540 --> 00:43:27,330
整个系统会以完全相同的方式工作
And the system would work completely the same.

797
00:43:27,330 --> 00:43:32,000
学生：我的问题是 就算Martha在key1和key2对应的格子里
AUDIENCE: My question is, Martha could have put key1 key2

798
00:43:32,000 --> 00:43:37,120
放了real-part过程 George也在key1和key2下
real-part, and George could have put key1 key2

799
00:43:37,120 --> 00:43:40,060
放了一个real-part 只要他们对这个过程的定义不一样
real-part, and as long as they defined them differently they

800
00:43:40,060 --> 00:43:41,290
就不会发生任何冲突 对吗
wouldn't have had any conflicts, right?

801
00:43:41,290 --> 00:43:45,130
教授：对的 这完全没有问题
PROFESSOR: Yes, that would all be OK except for the fact that

802
00:43:45,130 --> 00:43:47,130
除非你说的是George和Martha在同一个终端上工作
if you imagine George and Martha typing at the same

803
00:43:47,130 --> 00:43:50,090
并且他们两个人起的所有名字的含义全部相同
console with the same meanings for all their names, and it

804
00:43:50,090 --> 00:43:51,720
那么同样的real-part就会造成困扰
would get confused by real-part,but there are ways

805
00:43:51,720 --> 00:43:52,800
但是就算是这种情况也有办法解决
to arrange that, too.

806
00:43:52,800 --> 00:43:54,980
从原则上讲你说的完全正确
And in principle you're absolutely right.

807
00:43:54,980 --> 00:43:56,290
如果他们的名字不互相冲突的话
If their names didn't conflict--

808
00:43:56,290 --> 00:43:58,190
被填到表里的是对象本身 而不是它们的名字
it's the objects that go in the table, not the names.

809
00:43:58,190 --> 00:44:08,200


810
00:44:08,200 --> 00:44:09,450
好 我们休息一下
OK, let's take a break.

811
00:44:09,450 --> 00:44:12,493


812
00:44:12,493 --> 00:44:12,836
[音乐]
[MUSIC-- "JESU, JOY OF
MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

813
00:44:12,836 --> 00:44:25,086
[音乐]
[MUSIC-- "JESU, JOY OF
MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

814
00:44:25,086 --> 00:44:56,880
（黑屏至44:57）

815
00:45:12,880 --> 00:45:17,680
好的 我们刚刚讲了一个数据驱动编程的例子
All right, well we just looked at data-directed programming

816
00:45:17,680 --> 00:45:21,590
它是一个对复数做算术运算的系统
as a way of implementing a system that does arithmetic on

817
00:45:21,590 --> 00:45:22,840
它是一个对复数做算术运算的系统
complex numbers.

818
00:45:22,840 --> 00:45:27,420


819
00:45:27,420 --> 00:45:32,880
我已经在里面实现了这些操作 +c -c
So I had these operations in it called plus C and minus C,

820
00:45:32,880 --> 00:45:38,230
乘法 除法 还有其它的一些过程
and multiply, and divide,and maybe some others.

821
00:45:38,230 --> 00:45:46,030
这些过程存在于上层 这就是问题的关键
And that sat on top of-- and this is the key point-- sat on

822
00:45:46,030 --> 00:45:50,340
存在于两种不同表示方式的上层
top of two different representations.

823
00:45:50,340 --> 00:45:56,110
这是一个直角坐标程序包 这里一个极坐标程序包
A rectangular package here,and a polar package.

824
00:45:56,110 --> 00:45:58,240


825
00:45:58,240 --> 00:45:59,150
可能还有其它的东西
And maybe some more.

826
00:45:59,150 --> 00:46:01,640
我们已经看到通过我们的想法
And we saw that the whole idea is that maybe some more are

827
00:46:01,640 --> 00:46:04,670
那些“其它的东西”可以很容易地添加上去
now very easy to add.

828
00:46:04,670 --> 00:46:08,900
但是那并没有真正体现出这种方法的威力
But that doesn't really show the power of this methodology.

829
00:46:08,900 --> 00:46:10,150
我们看看发生了什么
Shows you what's going on.

830
00:46:10,150 --> 00:46:13,260
这个方法的威力 你在更复杂的系统中
The power of the methodology only becomes apparent when you

831
00:46:13,260 --> 00:46:17,080
应用它的时候 才会体现出来
start embedding this in some more complex system.

832
00:46:17,080 --> 00:46:19,180
现在我就要把它应用在一个
What I'm going to do now is embed this in some more

833
00:46:19,180 --> 00:46:20,250
更复杂的系统里面
complex system.

834
00:46:20,250 --> 00:46:23,960
我们假设我们编写的是一个
Let's assume that what we really have is a general kind

835
00:46:23,960 --> 00:46:25,280
适用于各种数的算术系统
of arithmetic system.

836
00:46:25,280 --> 00:46:27,240
所谓的通用算术系统
So called generic arithmetic system.

837
00:46:27,240 --> 00:46:32,060
然后在系统的最顶层 可以命令它
And at the top level here,somebody can say add two

838
00:46:32,060 --> 00:46:38,450
把两个东西相加 或者相减
things, or subtract two things,or multiply two

839
00:46:38,450 --> 00:46:41,180
或者相乘、相除
things, or divide two things.

840
00:46:41,180 --> 00:46:44,140


841
00:46:44,140 --> 00:46:47,930
然后在它们下面是一个抽象屏障
And underneath that there's an abstraction barrier.

842
00:46:47,930 --> 00:46:50,510
在这个抽象屏障的下层是 我们说
And underneath this barrier,is, say, a

843
00:46:50,510 --> 00:46:52,850
是一个复数运算程序包
complex arithmetic package.

844
00:46:52,850 --> 00:46:55,110
然后你可以让它把两个复数相加
And you can say, add two complex numbers.

845
00:46:55,110 --> 00:46:57,540
或者你还可以 还记得我们的有理数
Or you might also have--remember we did a rational

846
00:46:57,540 --> 00:47:00,190
程序包吗 可以把它也放在这里面
number package-- you might have that sitting there.

847
00:47:00,190 --> 00:47:03,950
可以放进去有理数
And there might be a rational thing.

848
00:47:03,950 --> 00:47:07,760
然后有理数程序包里面
And the rational number package,well, has the things

849
00:47:07,760 --> 00:47:08,320
有我们实现的
we implemented.

850
00:47:08,320 --> 00:47:15,490
+rat,*rat等等的这些过程
Plus rat, and times rat, and so on.

851
00:47:15,490 --> 00:47:17,010
或者你还可以加上普通的lisp数字
Or you might have ordinary Lisp numbers.

852
00:47:17,010 --> 00:47:19,310
你可以让它把3和4加起来
You might say add three and four.

853
00:47:19,310 --> 00:47:29,030
那么我们在这个系统里加入普通数字的运算
So we might have ordinary numbers, in which case we have

854
00:47:29,030 --> 00:47:36,670
我们用Lisp自带的加减乘除过程来实现
the Lisp supplied plus, and minus, and times, and slash.

855
00:47:36,670 --> 00:47:39,840
总而言之 在下一个阶段 我们想象这个复数运算系统
OK, so we might imagine this complex number system sitting

856
00:47:39,840 --> 00:47:43,660
存在于一个更加复杂的
in a more complicated generic operator structure at

857
00:47:43,660 --> 00:47:44,910
通用运算系统里面
the next level up.

858
00:47:44,910 --> 00:47:47,730


859
00:47:47,730 --> 00:47:49,050
我们怎么才能做到呢
Well how can we make that?

860
00:47:49,050 --> 00:47:50,240
我们已经有了想法
We already have the idea, we're just

861
00:47:50,240 --> 00:47:52,780
现在只要再一次应用它就可以了
going to do it again.

862
00:47:52,780 --> 00:47:54,720
我们之前实现了一个有理数程序包
We've implemented a rational number package.

863
00:47:54,720 --> 00:47:57,650
那么我们来看看应该怎么修改它
Let's look at how it has to be changed.

864
00:47:57,650 --> 00:48:01,590


865
00:48:01,590 --> 00:48:02,660
实际上 在这个层面
In fact, at this level it doesn't have to

866
00:48:02,660 --> 00:48:03,730
它根本就不需要修改
be changed at all.

867
00:48:03,730 --> 00:48:07,180
这完全就是我们上次写的那些代码
This is exactly the code that we wrote last time.

868
00:48:07,180 --> 00:48:10,140
要把两个有理数相加
To add two rational numbers, remember

869
00:48:10,140 --> 00:48:11,140
回忆一下我们要用到这个公式
there was this formula.

870
00:48:11,140 --> 00:48:14,980
构造一个有理数 它的分子是
You make a rational number whose numerator--

871
00:48:14,980 --> 00:48:17,330
第一个数的分子乘以第二个数的分母
the numerator of the first times the denominator of the

872
00:48:17,330 --> 00:48:20,486
加上第一个数的分母乘以
second, plus the denominator of the first times the

873
00:48:20,486 --> 00:48:21,520
第二个数的分子
numerator of the second.

874
00:48:21,520 --> 00:48:25,760
而结果的分母是两个分母的乘积
And who's denominator is the product of the denominators.

875
00:48:25,760 --> 00:48:30,580
然后是-rat,*rat,/rat这些过程
And minus rat, and star rat, and slash rat.

876
00:48:30,580 --> 00:48:34,420
这就是我们之前写的那个
And this is exactly the rational number package that

877
00:48:34,420 --> 00:48:36,310
有理数运算程序包
we made before.

878
00:48:36,310 --> 00:48:38,390
我们忽略了最大公约数的问题
We're ignoring the GCD problem,but let's not worry

879
00:48:38,390 --> 00:48:40,240
我们先不去考虑那个
about that.

880
00:48:40,240 --> 00:48:42,980
作为这个有理数包的具体实现
As implementers of this rational number package, how

881
00:48:42,980 --> 00:48:45,570
我们怎么把它安装到我们的通用运算系统中呢
do we install it in the generic arithmetic system?

882
00:48:45,570 --> 00:48:46,820
那很简单
Well that's easy.

883
00:48:46,820 --> 00:48:48,980


884
00:48:48,980 --> 00:48:51,840
我们要做的事只有一件和之前不同
There's only one thing we have to do differently.

885
00:48:51,840 --> 00:48:56,270
在之前我们说构造一个有理数
Whereas previously we said that to make a rational number

886
00:48:56,270 --> 00:49:00,960
就是构造一个由分子分母组成的序对
you built a pair of the numerator and denominator,

887
00:49:00,960 --> 00:49:03,300
现在我们不光构造这个序对 还要给它贴上标签
here we'll not only build the pair, but we'll sign it.

888
00:49:03,300 --> 00:49:06,120
把rational的类型标志附加上去
We'll attach the type rational.

889
00:49:06,120 --> 00:49:08,940
这就是唯一和之前不一样的地方
That's the only thing we have to do different, make it a

890
00:49:08,940 --> 00:49:12,380
把有理数变成类型数据
typed data object.

891
00:49:12,380 --> 00:49:14,500
现在我们要把我们的操作放进表格里
And now we'll stick our operations in the table.

892
00:49:14,500 --> 00:49:18,920
我们在rational标志和add操作对应的格子里
We'll put under the symbol rational and the operation add

893
00:49:18,920 --> 00:49:21,820
放进我们的+rat过程
our procedure, plus rat.

894
00:49:21,820 --> 00:49:23,580
并且再一次注意 这是一个标志
And, again, note this is a symbol.

895
00:49:23,580 --> 00:49:23,930
对吧
Right?

896
00:49:23,930 --> 00:49:26,830
加上引号 加上引号 但是实际上放进表里的
Quote, and quote, but the actual thing we're putting in the table 

897
00:49:26,830 --> 00:49:30,060
是过程本身
is the procedure.

898
00:49:30,060 --> 00:49:33,700
然后怎么做减法
And for how to subtract,well you subtract

899
00:49:33,700 --> 00:49:38,270
我们用-rat过程做减法
rationals with minus rat.

900
00:49:38,270 --> 00:49:41,090
然后是乘法和除法
And multiply, and divide.

901
00:49:41,090 --> 00:49:43,640
以上就是让我们的有理数包
And that is exactly and precisely what we have to do

902
00:49:43,640 --> 00:49:48,510
兼容这个通用算术系统的准确严谨的步骤
to fit inside this generic arithmetic system.

903
00:49:48,510 --> 00:49:51,560
那么整个系统怎么工作呢
Well how does the whole thing work?

904
00:49:51,560 --> 00:50:00,170
看 我们想要的是通用操作符
See, what we want to do is have some generic operators.

905
00:50:00,170 --> 00:50:01,720
让add,sub mul和div
Have add and sub and mul and div

906
00:50:01,720 --> 00:50:03,990
变成通用操作符
be generic operators.

907
00:50:03,990 --> 00:50:18,930
所以我们要定义add过程 对x和y调用add
So we're going to define add and say, to add x and y, that

908
00:50:18,930 --> 00:50:22,840
就是operate
will be operate--

909
00:50:22,840 --> 00:50:26,080


910
00:50:26,080 --> 00:50:27,490
我们把这个叫做operate-2
we were going to call it operate-2.

911
00:50:27,490 --> 00:50:30,350
这是我们的操作过程 但是要接收两个参数
This is our operator procedure,but set up for two

912
00:50:30,350 --> 00:50:37,261
对它们应用add 把它们加起来
arguments using add on x and y.

913
00:50:37,261 --> 00:50:40,420
这是和operate类似的一个东西
And so this is the analog to operate.

914
00:50:40,420 --> 00:50:41,680
我们再看看这个代码
Let's look at the code for second.

915
00:50:41,680 --> 00:50:42,930
它和operate很相似
It's almost like operate.

916
00:50:42,930 --> 00:50:46,040


917
00:50:46,040 --> 00:50:51,550
为了使用这个操作符对这两个参数
To operate with some operator on an argument 1 and an

918
00:50:51,550 --> 00:50:56,370
进行操作 我们首先要做的是
argument 2, well the first thing we're going to do is

919
00:50:56,370 --> 00:51:01,900
检查这两个参数的类型是不是相同
check and see if the two arguments have the same type.

920
00:51:01,900 --> 00:51:06,610
所以我们要问 第一个参数的类型
So we'll say, is the type of the first argument the same as

921
00:51:06,610 --> 00:51:08,860
和第二个的类型一样吗
the type of the second argument?

922
00:51:08,860 --> 00:51:10,350


923
00:51:10,350 --> 00:51:15,070
如果不一样 我们就停止运行 然后抱怨
And if they're not, we'll go off and complain, and say,

924
00:51:15,070 --> 00:51:15,670
发生了一个错误
that's an error.

925
00:51:15,670 --> 00:51:19,140
我们不知道怎么对它们进行操作
We don't know how to do that.

926
00:51:19,140 --> 00:51:20,920
如果它们的类型确实是相同的
If they do have the same type, we'll do

927
00:51:20,920 --> 00:51:22,080
我们就和之前做一样的事
exactly what we did before.

928
00:51:22,080 --> 00:51:26,460
我们会查询在参数的类型对应的
We'll go look and filed under the type of the argument--

929
00:51:26,460 --> 00:51:30,420
参数1和参数2是同样的类型 知道一个就可以
arg 1 and arg 2 have the same type, so it doesn't matter.

930
00:51:30,420 --> 00:51:33,640
我们到表格里去查找对应的过程
So we'll look in the table,find the procedure.

931
00:51:33,640 --> 00:51:38,870
如果那里有一个过程 我们就把它应用到
If there is a procedure there,then we'll apply it to the

932
00:51:38,870 --> 00:51:43,030
参数1和参数2的内容上去
contents of the argument 1 and the contents of arg 2.

933
00:51:43,030 --> 00:51:44,760
如果是其他情况呢 就报错
And otherwise we'll say, error.

934
00:51:44,760 --> 00:51:46,890
未定义操作符
Undefined operator.

935
00:51:46,890 --> 00:51:49,140
这就是operate-2过程
And so there's operate-2.

936
00:51:49,140 --> 00:51:51,326


937
00:51:51,326 --> 00:51:55,160
这就是我们要做的全部事情
And that's all we have to do.

938
00:51:55,160 --> 00:51:57,640
我们刚刚才写好了一个复数运算包
We just built the complex number package before.

939
00:51:57,640 --> 00:52:00,140
那么怎么把它放进
How do we embed that complex number package in

940
00:52:00,140 --> 00:52:02,140
这个通用系统里面呢
this generic system?

941
00:52:02,140 --> 00:52:03,390
方法几乎是一样的
Almost the same.

942
00:52:03,390 --> 00:52:06,410


943
00:52:06,410 --> 00:52:11,060
我们构造一个过程叫做make-complex
We make a procedure called make-complex that takes

944
00:52:11,060 --> 00:52:14,100
它把任何George和Martha给我们的东西
whatever George and Martha hand to us and add the

945
00:52:14,100 --> 00:52:16,350
贴上complex的类型标志
type-complex.

946
00:52:16,350 --> 00:52:18,170


947
00:52:18,170 --> 00:52:25,840
然后我们说 要把复数相加 这个+complex过程
And then we say, to add complex numbers, plus complex,

948
00:52:25,840 --> 00:52:32,240
我们用我们的内部过程 +c 把结果加上类型
we use our internal procedure,plus c, and attach a type,

949
00:52:32,240 --> 00:52:34,490
让它变成复数类型
make that a complex number.

950
00:52:34,490 --> 00:52:37,560


951
00:52:37,560 --> 00:52:42,840
那么我们的包里原来有+c和*c这两个过程
So our original package had names plus c and minus c that

952
00:52:42,840 --> 00:52:45,250
用来和George和Martha通信
we're using to communicate with George and Martha.

953
00:52:45,250 --> 00:52:47,730
然后为了与外部通信
And then to communicate with the outside world, we have a

954
00:52:47,730 --> 00:52:53,380
我们还有+complex和-complex
thing called plus-complex and minus-complex.

955
00:52:53,380 --> 00:52:55,920


956
00:52:55,920 --> 00:52:56,530
等等等等
And so on.

957
00:52:56,530 --> 00:52:59,000
它们唯一的不同就在于
And the only difference is that these return

958
00:52:59,000 --> 00:53:01,120
它们的返回值是被包装好的#TBD
values that are tight.

959
00:53:01,120 --> 00:53:02,850
我们可以在这里看到它们
So they can be looked at up here.

960
00:53:02,850 --> 00:53:05,690
而这些是内部过程
And these are internal operations.

961
00:53:05,690 --> 00:53:09,250


962
00:53:09,250 --> 00:53:10,680
我们再来看那个幻灯片
Let's go look at that slide again.

963
00:53:10,680 --> 00:53:13,740
我们还有一件事要做
There's one more thing we do.

964
00:53:13,740 --> 00:53:19,280
在定义了+complex之后 我们把这个过程
After defining plus-complex, we put under the type complex

965
00:53:19,280 --> 00:53:23,200
放在表格中complex类型和add记号的格子里 
and the symbol add, that procedure plus complex.

966
00:53:23,200 --> 00:53:27,130
然后类似地 对于减法
And then similarly for subtracting complex numbers,

967
00:53:27,130 --> 00:53:29,130
乘法和除法也做同样的事情
and multiplying them,and dividing them.

968
00:53:29,130 --> 00:53:31,700


969
00:53:31,700 --> 00:53:35,250
那我们怎么安装普通的数字呢
OK, how do we install ordinary numbers?

970
00:53:35,250 --> 00:53:38,160
方法还是一样的
Exactly the same way.

971
00:53:38,160 --> 00:53:41,750
我们会写一个叫做make-number的过程
Come off and say, well we'll make a thing called make-number

972
00:53:41,750 --> 00:53:41,760


973
00:53:41,760 --> 00:53:44,340


974
00:53:44,340 --> 00:53:48,500
Make-number接收一个数 然后给它加上类型
Make-number takes a number and attaches a type, which is the

975
00:53:48,500 --> 00:53:50,260
number类型标志
symbol number.

976
00:53:50,260 --> 00:53:55,300
我们构造一个过程叫做+number 它单纯地
We build a procedure called plus-number, which is simply,

977
00:53:55,300 --> 00:53:59,220
用lisp自带的加法把两个数加起来
add the two things using the ordinary addition, because in

978
00:53:59,220 --> 00:54:01,850
因为现在说的是普通的数字 然后
this case we're talking about ordinary numbers, and attach a

979
00:54:01,850 --> 00:54:04,510
给它附加类型 让它变成number类型
type to it and make that a number.

980
00:54:04,510 --> 00:54:08,700
然后我们把+number过程放到
And then we put into the table under the symbol number and

981
00:54:08,700 --> 00:54:12,550
表格里number和add对应的的格子中
the operation add, this procedure plus-number, and

982
00:54:12,550 --> 00:54:15,360
再用相同的方法把减法 乘法
then the same thing for subtracting, and multiplying,

983
00:54:15,360 --> 00:54:16,610
除法也放进去
and dividing.

984
00:54:16,610 --> 00:54:22,750


985
00:54:22,750 --> 00:54:26,060
我们举一个例子 就看得清楚一点
Let's look at an example,just to make it clear.

986
00:54:26,060 --> 00:54:32,600
假设 比如说
Suppose, for instance,I'm going

987
00:54:32,600 --> 00:54:34,150
我要执行这个操作
to perform the operation.

988
00:54:34,150 --> 00:54:38,220
好，现在我要执行一个操作
So I sit up here and I'm going to perform the operation,

989
00:54:38,220 --> 00:54:40,930
比如说我把两个复数乘起来
which looks like multiplying two complex numbers.

990
00:54:40,930 --> 00:54:49,786
把3+4i和2+6i 乘起来
So I would multiply, say,3 plus 4i and 2 plus 6i.

991
00:54:49,786 --> 00:54:51,740
这就是我调用mul过程
And that's something that I might want to take

992
00:54:51,740 --> 00:54:52,840
要传入的参数
hand that to mul.

993
00:54:52,840 --> 00:54:57,170
这里就代表通用操作符mul
I'll write mul as my generic operator here.

994
00:54:57,170 --> 00:54:58,280
那么它怎么工作呢
How's that going to work?

995
00:54:58,280 --> 00:55:05,020
我们讲3+4i 在整个系统里
Well 3 plus 4i, say, sits in the system at this level as

996
00:55:05,020 --> 00:55:06,250
处于这样的一个位置
something that looks like this.

997
00:55:06,250 --> 00:55:08,280
它是George的那种复数
Let's say it was one of George's.

998
00:55:08,280 --> 00:55:14,695
所以它的内部有一个3和一个4
So it would have a 3 and a 4.

999
00:55:14,695 --> 00:55:18,490


1000
00:55:18,490 --> 00:55:25,330
这上面还贴着George的类型标志
And attached to that would be George's type, which would say

1001
00:55:25,330 --> 00:55:29,510
是他构造的rectangular类型
rectangular, it came from George.

1002
00:55:29,510 --> 00:55:31,230
又附加在那上面的
And attached to that--

1003
00:55:31,230 --> 00:55:35,630
从更上一层的视角来看这一段数据
and this itself would be the data view from the next level up

1004
00:55:35,630 --> 00:55:37,700
它又是一个
which it is--

1005
00:55:37,700 --> 00:55:41,030
整个这个东西又是一个complex类型的数据
so that itself would be a type-data object which would

1006
00:55:41,030 --> 00:55:42,280
整个这个东西又是一个complex类型的数据
say complex.

1007
00:55:42,280 --> 00:55:44,820


1008
00:55:44,820 --> 00:55:49,240
那么这就是这个对象
So that's what this object would look like up here at the

1009
00:55:49,240 --> 00:55:52,300
在最高层视角中的样子 在那些通用操作
very highest level, where the really super-generic

1010
00:55:52,300 --> 00:55:55,560
视角上的样子
operations are looking at it.

1011
00:55:55,560 --> 00:55:58,720
现在 mul过程会过来问
Now what happens, mul eventually's going to come along 

1012
00:55:58,720 --> 00:56:00,400
哦 它的类型是什么
and say, oh,what's it's type?

1013
00:56:00,400 --> 00:56:01,650
它的类型是complex
It's type is complex.

1014
00:56:01,650 --> 00:56:04,270


1015
00:56:04,270 --> 00:56:08,460
然后运行到operate-2 然后说
Go through to operate-2 and say, oh, what I want to do is

1016
00:56:08,460 --> 00:56:10,440
啊 我想要把表格里的过程
apply what's in the table,which is going to be the

1017
00:56:10,440 --> 00:56:17,150
*complex这个过程 应用到它的
procedure star complex, on this thing with the type

1018
00:56:17,150 --> 00:56:17,950
类型剥下来之后的东西上面
stripped off.

1019
00:56:17,950 --> 00:56:22,400
所以它会把类型剥下来
So it's going to strip off the type, take that much, and send

1020
00:56:22,400 --> 00:56:26,288
把剩下的东西传递给复数的世界
that down into the complex world.

1021
00:56:26,288 --> 00:56:28,950
复数的世界看了看它有的操作然后说
The complex world looks at its operations and says, oh, I

1022
00:56:28,950 --> 00:56:31,280
我得调用*c这个过程
have to apply star c.

1023
00:56:31,280 --> 00:56:34,490
然后*c过程说 我要看看这个东西里面
Star c might say, oh, at some point I want to look at the

1024
00:56:34,490 --> 00:56:39,420
保存的模 这个数据是多少
magnitude of this object that it's in, that it's got.

1025
00:56:39,420 --> 00:56:40,160
然后它们会说 啊
And they'll say, oh, it's

1026
00:56:40,160 --> 00:56:41,870
它是直角坐标表示的 是George的东西
rectangular, it's one of George's.

1027
00:56:41,870 --> 00:56:47,340
所以它们又剥掉了一个类型
So it'll then strip off the next version of type, and hand

1028
00:56:47,340 --> 00:56:52,160
然后把内容交给George 让他提取出它的模值
that down to George to take the magnitude of.

1029
00:56:52,160 --> 00:56:55,290
那么我们看到这其中
So you see what's going on is that there are

1030
00:56:55,290 --> 00:56:59,320
有一个类型的链条
these chains of types.

1031
00:56:59,320 --> 00:57:01,530
这个链条的长度就是你要
And the length of the chain is sort of the number of levels

1032
00:57:01,530 --> 00:57:05,090
在这个表格里上升的层数
that you're going to be going up in this table.

1033
00:57:05,090 --> 00:57:09,590
类型的作用是 每次我们
And what a type tells you, every time you have a vertical

1034
00:57:09,590 --> 00:57:12,350
在这个表格里加一道垂直的抽象屏障
barrier in this table, where there's some ambiguity about

1035
00:57:12,350 --> 00:57:15,010
你不知道要去下一层的哪个位置的时候
where you should go down to the next level, the type is

1036
00:57:15,010 --> 00:57:17,440
类型就会给你指路
telling you where to go.

1037
00:57:17,440 --> 00:57:19,950
然后最底层的过程 它们构造数据结构
And then everybody at the bottom, as they construct data

1038
00:57:19,950 --> 00:57:22,810
对数据进行筛选之后 再把类型贴回去
and filter it up, they stick their type back on.

1039
00:57:22,810 --> 00:57:25,350


1040
00:57:25,350 --> 00:57:30,750
这就是整个系统的总体结构
So that's the general structure of the system.

1041
00:57:30,750 --> 00:57:33,410


1042
00:57:33,410 --> 00:57:34,820
好
OK.

1043
00:57:34,820 --> 00:57:38,660
明白了这个之后 我们再让这个系统
Now that we've got this, let's go and make this thing even

1044
00:57:38,660 --> 00:57:39,910
变得更加复杂
more complex.

1045
00:57:39,910 --> 00:57:41,890


1046
00:57:41,890 --> 00:57:46,150
我们这次不光要在系统里
Let's talk about adding to the system not only these kinds of

1047
00:57:46,150 --> 00:57:49,680
添加新的类型的数字 我们讨论一下
numbers, but it's also meaningful to start talking

1048
00:57:49,680 --> 00:57:51,510
怎么把多项式也加进去
about adding polynomials.

1049
00:57:51,510 --> 00:57:53,360
让它能对多项式做运算
Might do arithmetic on polynomials.

1050
00:57:53,360 --> 00:57:57,570
比如我们可以计算
Like we could have x to the fifteenth plus 2x to the

1051
00:57:57,570 --> 00:58:04,480
x^15+2x^7+5
seventh plus 5.

1052
00:58:04,480 --> 00:58:06,380
像这样的多项式
That might be some polynomial.

1053
00:58:06,380 --> 00:58:08,720
如果有两个这样的东西 我们最后可以把它们
And if we have two such gadgets we can add them or

1054
00:58:08,720 --> 00:58:10,530
相加或者相乘
multiply them.

1055
00:58:10,530 --> 00:58:12,140
我们先不要担心相除的问题
Let's not worry about dividing them.

1056
00:58:12,140 --> 00:58:15,870
只考虑相加相乘和相减
Just add them, multiply them,then we'll subtract them.

1057
00:58:15,870 --> 00:58:17,160
我们需要做什么
What do we have to do? Well

1058
00:58:17,160 --> 00:58:21,830
我们先来想想怎么表示一个多项式
let's think about how we might represent a polynomial.

1059
00:58:21,830 --> 00:58:24,950
它也是一种带类型的数据
It's going to be some typed data object.

1060
00:58:24,950 --> 00:58:29,690
这个系统里的一个多项式应该是一个
So let's say a polynomial to this system might look like a

1061
00:58:29,690 --> 00:58:32,000
polynomial类型的对象
thing that starts with the type polynomial.

1062
00:58:32,000 --> 00:58:33,710
接下来它可能要问这个多项式的
And then maybe it says the next thing is what

1063
00:58:33,710 --> 00:58:34,550
变量是哪个
variable its in.

1064
00:58:34,550 --> 00:58:38,960
我说我是一个以x为变量的多项式
So I might say I'm a polynomial in the variable x.

1065
00:58:38,960 --> 00:58:40,500
然后它里面要有这个多项式的
And then it'll have some information about

1066
00:58:40,500 --> 00:58:42,250
各个项的信息
what the terms are.

1067
00:58:42,250 --> 00:58:45,620
有很多种方法
And there're just tons of ways to do this, but one way is to

1068
00:58:45,620 --> 00:58:51,520
我们采用的方法是构造一个项表
say we're going to have a thing called a term-list. And

1069
00:58:51,520 --> 00:58:53,700
一个项表
a term-list--

1070
00:58:53,700 --> 00:58:54,830
在这个例子里我们用的是
well, in our case we'll use something

1071
00:58:54,830 --> 00:58:56,360
类似这样的东西
that looks like this.

1072
00:58:56,360 --> 00:58:59,680
我们把它写成一系列按系数排列的序对
We'll make it a bunch of pairs which have an order in a coefficient

1073
00:58:59,680 --> 00:58:59,690

1074
00:58:59,690 --> 00:59:09,070
那么这个项表就能表示这个多项式了
So this polynomial would be represented by this term-list.

1075
00:59:09,070 --> 00:59:12,910
它的意义是这个多项式
And what that means is that this polynomial starts off

1076
00:59:12,910 --> 00:59:19,710
第一项的次数是15，系数是1
with a term of order 15 and coefficient 1.

1077
00:59:19,710 --> 00:59:23,820


1078
00:59:23,820 --> 00:59:26,780
然后下一项的次数是7
And the next thing in it is a term of order 7 and

1079
00:59:26,780 --> 00:59:29,680
系数是2 再下一项是一个常数 次数是0
coefficient 2, a term of order 0, which is constant in

1080
00:59:29,680 --> 00:59:31,450
系数是5
coefficient 5.

1081
00:59:31,450 --> 00:59:35,600
实际上有很多很多种方法
And there are lots and lots of ways, and lots and lots of

1082
00:59:35,600 --> 00:59:37,890
期间又需要无数次的权衡#TBD 来构造这个代数操作
trade-offs when you really think about making algebraic

1083
00:59:37,890 --> 00:59:40,570
程序包或者准确地说 
manipulation packages about exactly how you should

1084
00:59:40,570 --> 00:59:41,730
来设计数据的表示方法
represent these things.

1085
00:59:41,730 --> 00:59:44,180
但是我们这种是比较标准的一种
But this is a fairly standard one.

1086
00:59:44,180 --> 00:59:47,770
它适用于很多情况
It's useful in a lot of contexts.

1087
00:59:47,770 --> 00:59:51,815
好 那么我们怎么实现我们的多项式算术呢
OK, well how do we implement our polynomial arithmetic?

1088
00:59:51,815 --> 00:59:54,270


1089
00:59:54,270 --> 00:59:55,520
现在开始着手做这个事情
Let's start out.

1090
00:59:55,520 --> 00:59:57,950


1091
00:59:57,950 --> 01:00:00,760
构造一个多项式 首先要
What we'll do to make a polynomial--

1092
01:00:00,760 --> 01:00:05,690
首先我们得找一个办法来构造多项式
we'll first have a way to make polynomials.

1093
01:00:05,690 --> 01:00:08,560
我们可以用一个变量 比如x
We're going to make a polynomial out of variable

1094
01:00:08,560 --> 01:00:13,180
和一个项表来构造它们 然后我们要用某种方法
like x and term-list. And all that does is we'll package

1095
01:00:13,180 --> 01:00:14,990
把它们包装起来
them together someway.We'll

1096
01:00:14,990 --> 01:00:18,740
我们要把变量和项表组合起来
put the variable together with the term list

1097
01:00:18,740 --> 01:00:22,380
我们可以用cons，然后把这个序对加上polynomial的类型标志
using cons, and then attached to that the type polynomial.

1098
01:00:22,380 --> 01:00:26,270


1099
01:00:26,270 --> 01:00:29,280
那我们怎么把两个多项式相加呢
OK, how do we add two polynomials?

1100
01:00:29,280 --> 01:00:33,330
要相加两个多项式 p1和p2
To add a polynomial, p1 and p2, and then just for

1101
01:00:33,330 --> 01:00:36,060
为了简化问题假设我们只相加
simplicity let's say we will only add

1102
01:00:36,060 --> 01:00:37,380
变量相同的两个式子
things in the same variable.

1103
01:00:37,380 --> 01:00:40,740
那么如果它们的变量相同
So if they have the same variable, and same variable

1104
01:00:40,740 --> 01:00:43,160
是否相同交给这个选择函数判断
here is going to be some selector we write, whose

1105
01:00:43,160 --> 01:00:45,150
我们不必在意它的细节
details we don't care about.

1106
01:00:45,150 --> 01:00:48,280
如果两个多项式的变量相同
If the two polynomials have the same variable, then we'll

1107
01:00:48,280 --> 01:00:48,810
我们就继续运算
do something.

1108
01:00:48,810 --> 01:00:52,350
如果它们的变量不相同 我们返回一个错误
If they don't have the same variable, we'll give an error,

1109
01:00:52,350 --> 01:00:55,480
两个多项式的变量不相同
polynomials not in the same variable.

1110
01:00:55,480 --> 01:00:58,120
如果它们的变量确实是相同的呢
And if they do have the same variable, what we'll do is

1111
01:00:58,120 --> 01:01:01,130
我们要做的是构造一个新的多项式
we'll make a polynomial whose variable is whatever that

1112
01:01:01,130 --> 01:01:05,570
它的变量是原来两个式子的变量 它的项表
variable is, and whose term-list is something we'll

1113
01:01:05,570 --> 01:01:10,170
我们用这个+terms过程 +terms会把两个项表加起来
call sum-terms. Plus terms will add the two term lists.

1114
01:01:10,170 --> 01:01:13,500
所以我们要把两个多项式的项表加起来
So we'll add the two term lists to the polynomial.

1115
01:01:13,500 --> 01:01:16,755
得到一个新的项表 我们把它们加起来
That'll give us a term-list.We'll add on, we'll say it's a

1116
01:01:16,755 --> 01:01:19,500
我们说这是一个关于这个变量的
polynomial in the variable with that

1117
01:01:19,500 --> 01:01:22,550
有这么一个项表的多项式 这就是+poly过程
term-list. That's plus poly.

1118
01:01:22,550 --> 01:01:26,360
然后我们要把这个过程放进表格中polynomial
And then we're going to put in our table under the type

1119
01:01:26,360 --> 01:01:30,520
那一栏的下面 用+poly实现add操作
polynomial, add them using plus poly.

1120
01:01:30,520 --> 01:01:31,750
当然实际上没做多少事情
And of course we really haven't done much.

1121
01:01:31,750 --> 01:01:34,360
我们只是把所有的工作压到
What we've really done is pushed all the work onto this

1122
01:01:34,360 --> 01:01:38,480
+terms的头上 它会负责把项表相加起来
thing, plus-terms, which is supposed to add term-lists.

1123
01:01:38,480 --> 01:01:40,920
我们看看这个过程
Let's look at that.

1124
01:01:40,920 --> 01:01:48,900
这是我们把两个项表相加的大概过程
Here's an overview of how we might add two term-lists.

1125
01:01:48,900 --> 01:01:51,860
L1和L2是两个项表
So L1 and L2 were going to be two term-lists.

1126
01:01:51,860 --> 01:01:55,700
然后每个项表都是一系列序对 按次数排序
And a term-list is a bunch of pairs, coefficient in order.

1127
01:01:55,700 --> 01:01:56,950
这里有一个大的条件判断
And it's a big case analysis.

1128
01:01:56,950 --> 01:01:59,860


1129
01:01:59,860 --> 01:02:03,470
我们要做的第一件事是看看项表里
And the first thing we'll check for and see if there are

1130
01:02:03,470 --> 01:02:07,020
有没有至少一个项 我们在项表里递归下降
any terms. We're going to recursively work down these

1131
01:02:07,020 --> 01:02:09,980
最终下降到一个状态就是L1
term-lists, so eventually we'll get to a place where

1132
01:02:09,980 --> 01:02:12,270
或者L2 有一个是空的
either L1 or L2 might be empty.

1133
01:02:12,270 --> 01:02:15,160
如果其中一个是空的呢 我们的答案就是
And if either one is empty,our answer will

1134
01:02:15,160 --> 01:02:15,850
剩下的另一个
be the other one.

1135
01:02:15,850 --> 01:02:20,720
就是说如果L1是空表 我们就返回L2
So if L1 is empty we'll return L2, and if L2 is empty

1136
01:02:20,720 --> 01:02:23,470
L2是空表的话就返回L1
we'll return L1.

1137
01:02:23,470 --> 01:02:27,220
除此之外还有三种情况
Otherwise there are sort of three interesting cases.

1138
01:02:27,220 --> 01:02:30,560
我们先拿到每一个项表里的
What we're going to do is grab the first term in each of

1139
01:02:30,560 --> 01:02:37,660
第一项 我们把它们分别叫做t1和t2
those lists, called t1 and t2.

1140
01:02:37,660 --> 01:02:43,090
我们看t1的次数是高于
And we're going to look at three cases, depending on

1141
01:02:43,090 --> 01:02:47,230
还是低于t2的次数 还是相等 我们看属于
whether the order of t1 is greater than the order of t2,

1142
01:02:47,230 --> 01:02:51,470
这三种情况中的哪一种
or less than t2, or the same.

1143
01:02:51,470 --> 01:02:53,290


1144
01:02:53,290 --> 01:02:54,910
这就是我们要判断的三种情况
Those are the three cases we're going to look at.

1145
01:02:54,910 --> 01:02:57,160
先看看这一种
Let's look at this case.

1146
01:02:57,160 --> 01:02:58,640


1147
01:02:58,640 --> 01:03:03,550
如果t1的次数比t2的次数要高
If the order of t1 is greater than the order of t2, then

1148
01:03:03,550 --> 01:03:08,280
就意味着我们的答案的第一项的次数
what that means is that our answer is going to start with

1149
01:03:08,280 --> 01:03:11,480
就是t1的次数
this term of the order of t1.

1150
01:03:11,480 --> 01:03:14,455
因为高次项不会和任何次数低的项相加
Because it won't combine with any lower order terms. So what

1151
01:03:14,455 --> 01:03:19,720
那么我们只需要把低次的项加起来 我们递归地
we do is add the lower order terms. We recursively add

1152
01:03:19,720 --> 01:03:21,900
把L1和L2两个项表里
together all the terms in the rest of the

1153
01:03:21,900 --> 01:03:26,880
剩下的项相加
term-list in L1 and L2.

1154
01:03:26,880 --> 01:03:30,120
作为我们的答案中低次的项
That's going to be the lower order terms of the answer.

1155
01:03:30,120 --> 01:03:31,490
然后我们把它们
And then we're going to adjoin to that the

1156
01:03:31,490 --> 01:03:33,180
和最高次的项连接起来
highest order term.

1157
01:03:33,180 --> 01:03:35,120
这里我用了一系列
And I'm using here a whole bunch of procedures I haven't

1158
01:03:35,120 --> 01:03:39,360
我还没有定义过的过程 比如adjoin-term rest-terms
defined, like a adjoin-term, and rest-terms, and selectors

1159
01:03:39,360 --> 01:03:41,410
还有获取次数的选择函数
that get order.

1160
01:03:41,410 --> 01:03:44,730
但是你可以想象它们是什么样子的
But you can imagine what those are.

1161
01:03:44,730 --> 01:03:48,550
那么如果第一个项表的次数比第二个要高
So if the first term-list has a higher order than the

1162
01:03:48,550 --> 01:03:51,830
我们就递归地把所有的低次的项相加
second, we recursively add all the lower terms and then stick

1163
01:03:51,830 --> 01:03:55,540
再和最高次项连接起来
on that last term.

1164
01:03:55,540 --> 01:03:56,890
对于其他情况也是一样的
The other case, the same way.

1165
01:03:56,890 --> 01:04:02,400
如果第一个多项式次数比较低
If the first term has a smaller order, well then we add

1166
01:04:02,400 --> 01:04:07,740
我们就把整个第一个多项式 和第二个多项式低次的项
we add the first term-list and the rest of the terms in the

1167
01:04:07,740 --> 01:04:12,430
相加 然后把结果再和最高次项连起来
second one, and adjoin on this highest order term.

1168
01:04:12,430 --> 01:04:14,570


1169
01:04:14,570 --> 01:04:16,660
到现在没发生多少复杂的事情 我们只是一次次
So so far nothing's much happened, we've just sort of

1170
01:04:16,660 --> 01:04:19,700
把问题变成 让低次数的项相加
pushed this thing off into adding lower order terms. The

1171
01:04:19,700 --> 01:04:22,870
还有最后一种情况是 两个多项式的次数一样
last case where you actually get to a coefficients that you

1172
01:04:22,870 --> 01:04:24,240
你必须要把它们的系数加起来
have to add, this will be the case where

1173
01:04:24,240 --> 01:04:27,240
你必须要把它们的系数加起来
the orders are equal.

1174
01:04:27,240 --> 01:04:30,340
我们的应对方法是 仍然是递归地
What we do is, well again recursively add the lower

1175
01:04:30,340 --> 01:04:33,460
把低次的项相加 但是现在必须要实实在在地相加两个东西了
order terms. But now we have to really combine something.

1176
01:04:33,460 --> 01:04:38,960
我们构造一个项 让它的次数等于
What we do is we make a term whose order is the order of

1177
01:04:38,960 --> 01:04:40,820
我们正在处理的那一项的次数
the term we're looking at.

1178
01:04:40,820 --> 01:04:44,320
因为现在t1和t2的次数是相同的
By now t1 and t2 have the same order.

1179
01:04:44,320 --> 01:04:45,090
这就是它们的次数
That's its order.

1180
01:04:45,090 --> 01:04:50,400
它的系数呢 通过把t1和t2
And its coefficient is gotten by adding the coefficient of

1181
01:04:50,400 --> 01:04:53,230
的系数相加来获取
t1 and the coefficient of t2.

1182
01:04:53,230 --> 01:04:56,360


1183
01:04:56,360 --> 01:04:59,800
这是一个庞大的递归过程
This is a big recursive working down of terms, but

1184
01:04:59,800 --> 01:05:03,070
但是实际上整个过程中只有一个符号是
really there's only one interesting symbol in this

1185
01:05:03,070 --> 01:05:05,900
最有意思的 只有一个有趣的想法
procedure, only one interesting idea.

1186
01:05:05,900 --> 01:05:08,500
那就是这个add
The interesting idea is this add.

1187
01:05:08,500 --> 01:05:12,390


1188
01:05:12,390 --> 01:05:15,330
说它有趣是因为
And the reason that's interesting is because

1189
01:05:15,330 --> 01:05:18,220
刚才有一件好事发生
something completely wonderful just happened.

1190
01:05:18,220 --> 01:05:25,440
我们把多项式加法 没有归为plus过程的一种
We reduced adding polynomials,not to sort of plus, but to

1191
01:05:25,440 --> 01:05:28,820
却把它放在通用操作符add之下
the generic add.

1192
01:05:28,820 --> 01:05:33,270
换句话说 用这种方法实现它之后
In other words, by implementing it that way, not

1193
01:05:33,270 --> 01:05:37,530
我们的系统就不光有
only do we have our system where we can have rational

1194
01:05:37,530 --> 01:05:42,090
有理数，复数和普通数字的运算这些功能
numbers, or complex numbers,or ordinary numbers, we've

1195
01:05:42,090 --> 01:05:44,340
我们同时也让它支持多项式运算了
just added on polynomials.

1196
01:05:44,340 --> 01:05:48,520


1197
01:05:48,520 --> 01:05:51,820
但是这个多项式的系数可以是
But the coefficients of the polynomials can be anything

1198
01:05:51,820 --> 01:05:53,590
这个系统能够相加的任何东西
that the system can add.

1199
01:05:53,590 --> 01:05:57,450
也就是说 多项式的系数可以是
So these could be polynomials whose coefficients are

1200
01:05:57,450 --> 01:06:04,110
有理数或者复数 复数可以是
rational numbers or complex numbers, which in turn could

1201
01:06:04,110 --> 01:06:11,250
直角坐标或者极坐标表示 或者就是普通的数值
be either rectangular, or polar, or ordinary numbers.

1202
01:06:11,250 --> 01:06:19,860


1203
01:06:19,860 --> 01:06:23,460
我想说的是 我们的系统现在可以
So what I mean precisely is our system right now

1204
01:06:23,460 --> 01:06:30,200
自动处理多项式相加这样的事情
automatically can handle things like adding together

1205
01:06:30,200 --> 01:06:35,830
比如2/3x^2+5/17x+11/4这样的式子
polynomials that have this one:2/3 of x squared plus

1206
01:06:35,830 --> 01:06:40,940
比如2/3x^2+5/17x+11/4这样的式子
5/17 x plus 11/4.

1207
01:06:40,940 --> 01:06:44,210
也可以自动处理像是
Or automatically handle polynomials that look like 3

1208
01:06:44,210 --> 01:06:54,160
(3+2i)x^5+4+7i这样的式子
plus 2i times x to the fifth plus 4 plus 7i, or something.

1209
01:06:54,160 --> 01:06:56,210
系统可以自动处理这些运算
You can automatically handle those things.

1210
01:06:56,210 --> 01:06:57,820
为什么
Why is that?

1211
01:06:57,820 --> 01:07:03,280
仅仅是因为 或者说深层次的原因是
That's merely because, or profoundly because we reduced

1212
01:07:03,280 --> 01:07:06,790
我们把多项式相加归约成了把它们的系数相加
adding polynomials to adding their coefficients.

1213
01:07:06,790 --> 01:07:09,670
而系数的相加是由add通用操作符
And adding coefficients was done by the generic add

1214
01:07:09,670 --> 01:07:12,770
来完成的 它说我不管你的数据类型是什么
operator, which said, I don't care what your types are

1215
01:07:12,770 --> 01:07:15,170
只要我能够处理就行
as long as I know how to add you.

1216
01:07:15,170 --> 01:07:17,800
于是我们就免费获得了
So automatically for free we get the

1217
01:07:17,800 --> 01:07:20,880
处理这些东西的功能
ability to handle that.

1218
01:07:20,880 --> 01:07:24,920
更神奇的事情是 还记得吧
What's even better than that,because remember one of the

1219
01:07:24,920 --> 01:07:29,870
我们把多项式加法 +poly过程
things we did is we put into the table that the way you add

1220
01:07:29,870 --> 01:07:34,660
放进了表格里
polynomials is using plus poly.

1221
01:07:34,660 --> 01:07:37,480
这意味着多项式本身也已经是
That means that polynomials themselves are

1222
01:07:37,480 --> 01:07:39,370
通用操作add可以操作的东西了
things that can be added.

1223
01:07:39,370 --> 01:07:42,110
比如说 我写一个例子
So for instance let me write one here.

1224
01:07:42,110 --> 01:07:45,260


1225
01:07:45,260 --> 01:07:46,510
这是一个多项式
Here's a polynomial.

1226
01:07:46,510 --> 01:07:50,560


1227
01:07:50,560 --> 01:07:55,080
我正在写的这个东西
So this gadget here I'm writing up, this is a

1228
01:07:55,080 --> 01:08:02,710
它是一个以y作为变量的多项式 而它的系数是
polynomial in y whose coefficients are

1229
01:08:02,710 --> 01:08:04,690
以x作为变量的多项式
polynomials in x.

1230
01:08:04,690 --> 01:08:08,610


1231
01:08:08,610 --> 01:08:13,110
那么你看到 “多项式能被add过程相加”
So you see, simply by saying, polynomials are themselves

1232
01:08:13,110 --> 01:08:15,590
只要这一事实成立 我们就可以说
things that can be added, we can go off and say, well not

1233
01:08:15,590 --> 01:08:19,560
我们的系统现在不光能运算有理数 复数
only can we deal with rationals,or complex, or

1234
01:08:19,560 --> 01:08:22,330
普通的数字 如果一个多项式它的系数
ordinary numbers, but we can deal with polynomials whose

1235
01:08:22,330 --> 01:08:25,420
是有理数，复数，普通数字
coefficients are rationals, or complex, or ordinary numbers,

1236
01:08:25,420 --> 01:08:31,979
或者这个系数是一个多项式 它的系数是有理数
or polynomials whose coefficients are rationals, or

1237
01:08:31,979 --> 01:08:37,569
各种复数 普通数字
complex, rectangular, polar,or ordinary numbers, or

1238
01:08:37,569 --> 01:08:42,609
或者又一个多项式 系数是有理数，
polynomials whose coefficients are rationals, complex, or

1239
01:08:42,609 --> 01:08:43,670
复数，普通数字
ordinary numbers.

1240
01:08:43,670 --> 01:08:45,950
以此类推
And so on, and so on, and so on.

1241
01:08:45,950 --> 01:08:50,830
我们构造出了一座无限延伸的 递归的
So this is sort of an infinite or maybe a recursive tower of

1242
01:08:50,830 --> 01:08:53,880
类型的高塔
types that we've built up.

1243
01:08:53,880 --> 01:08:56,920
这一切都来源于那个小小的记号 ADD
And it's all exactly from that one little symbol, A-D-D.

1244
01:08:56,920 --> 01:08:59,615
来源于在多项式程序里
Writing "add" instead of "plus" in

1245
01:08:59,615 --> 01:09:02,270
用"add"来代替"+"
the polynomial thing.

1246
01:09:02,270 --> 01:09:04,620
换一种方式来理解它就是
Slightly different way to think about it is that

1247
01:09:04,620 --> 01:09:08,740
多项式是构造类型的函数
polynomials are a constructor for types.

1248
01:09:08,740 --> 01:09:12,149
也就是说你传递给它一个类型 比如整数类型
Namely you give it a type, like integer, and it returns

1249
01:09:12,149 --> 01:09:16,279
然后它就返回一个以整数作为系数的多项式
for you polynomials in x whose coefficients are integers.

1250
01:09:16,279 --> 01:09:20,010
过程中很重要的一点是对多项式的操作
And the important thing about that is that the operations on

1251
01:09:20,010 --> 01:09:22,729
被归约成了对系数的操作
polynomials reduce to the operations on the

1252
01:09:22,729 --> 01:09:23,500
被归约成了对系数的操作
coefficients.

1253
01:09:23,500 --> 01:09:25,840
有很多地方都用到了这种思想#TBD
And there are a lot of things like that.

1254
01:09:25,840 --> 01:09:28,870
作为一个例子 我们再回头看看有理数
So for example, let's go back and rational numbers.

1255
01:09:28,870 --> 01:09:32,410
之前我们把有理数看成 上面有一个整数
We thought about rational numbers as an integer over an

1256
01:09:32,410 --> 01:09:34,229
下面有一个整数 这样的东西 但是
integer, but there's the general notion

1257
01:09:34,229 --> 01:09:36,240
所有有理对象都可以这样来表示
of a rational object.

1258
01:09:36,240 --> 01:09:43,010
比如我们也可以把3x+7放在上面 x^2+1放在下面
Like we might think about 3x plus 7 over x squared plus 1.

1259
01:09:43,010 --> 01:09:47,430
这是一个分子分母都是多项式的
That's general rational object whose numerator and

1260
01:09:47,430 --> 01:09:50,310
广义上的有理式
denominator are polynomials.

1261
01:09:50,310 --> 01:09:52,990
有理式相加 和有理数相加一样
And to add two of them we use the same formula, numerator

1262
01:09:52,990 --> 01:09:55,720
左边分子乘右边分母加上右边分子乘左边分母 写在上面
times denominator plus denominator times numerator

1263
01:09:55,720 --> 01:09:57,290
两个分母的乘积写在下面
over product of denominators.

1264
01:09:57,290 --> 01:09:59,530
怎么把它放到我们的系统中
How could we install that in our system?

1265
01:09:59,530 --> 01:10:01,820
这是我们原来的
Well here's our original rational

1266
01:10:01,820 --> 01:10:04,250
有理数算术程序包
number arithmetic package.

1267
01:10:04,250 --> 01:10:08,660
为了让这个系统能够
And all we have to do in order to make the entire system

1268
01:10:08,660 --> 01:10:12,530
支持有理式的运算 我们把这些
continue working with general rational objects, is replace

1269
01:10:12,530 --> 01:10:16,480
特定的加法和乘法过程 都改成通用操作符
these particular pluses and stars by the generic operator.

1270
01:10:16,480 --> 01:10:19,870
所以如果我们把原来那个过程变成这个过程
So if we simply change that procedure to this one, here

1271
01:10:19,870 --> 01:10:23,100
把+和*换成add和mul 
we've changed plus and star to add a mul, those are

1272
01:10:23,100 --> 01:10:28,170
是唯一的改动 然后霎时间我们的整个系统
absolutely the only change,then suddenly our entire

1273
01:10:28,170 --> 01:10:34,000
都知道怎么运算这样的东西了
system can start talking about objects that look like this.

1274
01:10:34,000 --> 01:10:40,350
比如说 这里的这个有理式
So for example, here is a rational object whose

1275
01:10:40,350 --> 01:10:44,030
它的分子是一个关于x的 系数是有理数的多项式
numerator is a polynomial in x whose coefficients are

1276
01:10:44,030 --> 01:10:47,350
它的分子是一个关于x的 系数是有理数的多项式
rational numbers.

1277
01:10:47,350 --> 01:10:54,000
或者有一个有理式 它的分子是关于x的多项式
Or here is a rational object whose numerator is polynomials in x

1278
01:10:54,000 --> 01:11:00,480
多项式的系数又是有理式
 whose coefficients are rational objects constructed

1279
01:11:00,480 --> 01:11:03,390
有理式又由复数组成
out of complex numbers.

1280
01:11:03,390 --> 01:11:04,850
或者别的像这样的东西
And then there are a lot of other things like that.

1281
01:11:04,850 --> 01:11:07,500
看，只要操作能够归约成
See, whenever you have a thing where the operations reduce to

1282
01:11:07,500 --> 01:11:10,450
更小的操作 另一个例子是比如有一个
operations on the pieces,another example would be two

1283
01:11:10,450 --> 01:11:12,310
2*2的矩阵
by two matrices.

1284
01:11:12,310 --> 01:11:17,030
假如有这样一个矩阵形式的东西
I have the idea, there might be a matrix here of general

1285
01:11:17,030 --> 01:11:18,650
不管它里面是什么
things that I don't care about.

1286
01:11:18,650 --> 01:11:25,180
但是如果我对两个这种东西调用add 答案就是
But if I add two of them, the answer over here is gotten by

1287
01:11:25,180 --> 01:11:29,030
把一个和另一个相加的结果 不管它们是怎么相加的
adding this one and that one,however they like to add.

1288
01:11:29,030 --> 01:11:31,110
那么我可以用同样的方法实现
So I can implement that the same way.

1289
01:11:31,110 --> 01:11:33,520
如果我这么做了 又一次 霎时间我的整个系统
And if I do that, then again suddenly my system can start

1290
01:11:33,520 --> 01:11:35,480
就可以处理像这样的东西了
handling things like this.

1291
01:11:35,480 --> 01:11:39,460
比如说一个矩阵 它的元素都是
So here's a matrix whose elements happen to be--

1292
01:11:39,460 --> 01:11:43,330
它的元素是一个有理式
we'll say this element here is a rational object whose

1293
01:11:43,330 --> 01:11:47,230
这个有理式的分子分母都是多项式
numerator and denominators are polynomials.

1294
01:11:47,230 --> 01:11:50,510
我们免费获得了这样的功能
And all that comes for free.

1295
01:11:50,510 --> 01:11:52,580


1296
01:11:52,580 --> 01:11:53,920
整个过程中发生了什么
What's really going on here?

1297
01:11:53,920 --> 01:11:58,910
就是摆脱了这个坐在这里
What's really going on is getting rid of this manager

1298
01:11:58,910 --> 01:12:02,060
想要对别人的所有事情都插一手的
who's sitting there poking his nose into who everybody's

1299
01:12:02,060 --> 01:12:03,120
这个经理
business is.

1300
01:12:03,120 --> 01:12:06,900
我们构造了一个 控制去中心化 的系统
We built a system that has decentralized control.

1301
01:12:06,900 --> 01:12:14,350


1302
01:12:14,350 --> 01:12:18,340
你进入这个系统的时候 不会有人一边闲逛一边说#TBD
So when you come into and no one's poking around saying,

1303
01:12:18,340 --> 01:12:21,080
我看看官方的相加对象列表里面
gee, are you in the official list of

1304
01:12:21,080 --> 01:12:22,440
有没有你
people who can be added?

1305
01:12:22,440 --> 01:12:24,850
你直接就可以用正确的方法
Rather you say, well go off and add yourself how your

1306
01:12:24,850 --> 01:12:27,810
把你和别的东西加起来
parts like to be added.

1307
01:12:27,810 --> 01:12:31,030
这么做的好处就是 就连这种非常非常
And the result of that is you can get this very, very, very

1308
01:12:31,030 --> 01:12:33,870
复杂的分层对象也可以被分解后#TBD
complex hierarchy where a lot of things just get done and

1309
01:12:33,870 --> 01:12:36,482
自动放到正确的地方去处理
rooted to the right place automatically.

1310
01:12:36,482 --> 01:12:38,732
讲课就讲到这里 下面大家提问
Let's stop for questions.

1311
01:12:38,732 --> 01:12:40,380


1312
01:12:40,380 --> 01:12:43,020
你说你免费获得了这些功能
AUDIENCE: You say you get this for free.

1313
01:12:43,020 --> 01:12:46,920
但是我在意的是你现在丢掉了一种
One thing that strikes me is that now you've lost kind of

1314
01:12:46,920 --> 01:12:50,150
什么在上层、什么在下层的
the cleanness of the break between what's on top and

1315
01:12:50,150 --> 01:12:50,910
清楚的界限
what's underneath.

1316
01:12:50,910 --> 01:12:52,770
或者说 现在你是在用
In other words, now you're defining some of the

1317
01:12:52,770 --> 01:12:54,850
上层的东西来定义
lower-level procedures in terms of things

1318
01:12:54,850 --> 01:12:56,610
下层的过程
above their own line.

1319
01:12:56,610 --> 01:13:00,350
这不是很危险吗
Isn't that dangerous?

1320
01:13:00,350 --> 01:13:05,440
或者说 我能想到的还有 结构会变得混乱
Or, if nothing more, a little less structured?

1321
01:13:05,440 --> 01:13:06,125
教授：不 我——
PROFESSOR: No, I--

1322
01:13:06,125 --> 01:13:07,770
你问它的结构混不混乱
the question is whether that's less structured.

1323
01:13:07,770 --> 01:13:08,690
这要看你说的“结构”是指什么
Depends on what you mean by structure.

1324
01:13:08,690 --> 01:13:11,050
整个过程里我们都在做递归
All this is doing is recursion.

1325
01:13:11,050 --> 01:13:15,780
看 就是说要把这些东西相加
See, it's saying that the way you add these

1326
01:13:15,780 --> 01:13:18,840
就要用到这个过程
guys is to use that.

1327
01:13:18,840 --> 01:13:20,520
这不是结构混乱
And that's not less structured,it's just a

1328
01:13:20,520 --> 01:13:22,610
递归的结构就是这样的
recursive structure.

1329
01:13:22,610 --> 01:13:24,990
所以我不认为它不清楚
So I don't think it's particularly any less clean.

1330
01:13:24,990 --> 01:13:27,250
学生：那么你想对乘法或者加法操作
AUDIENCE: Now when you want to change the multiplier or the

1331
01:13:27,250 --> 01:13:31,380
做出修改的时候 可能会导致
add operator, suddenly you've got tremendous consequences

1332
01:13:31,380 --> 01:13:34,480
程度无法预测的灾难性后果 #TBD
underneath that you're not even sure the extent of.

1333
01:13:34,480 --> 01:13:37,080
教授：你说得对 但是那要看你的意思是什么
PROFESSOR: That's right, but it depends what you mean.

1334
01:13:37,080 --> 01:13:38,470
从两个角度来讨论#TBD
See, this goes both ways.

1335
01:13:38,470 --> 01:13:41,790


1336
01:13:41,790 --> 01:13:44,690
举个什么例子好呢
What would be a good example?

1337
01:13:44,690 --> 01:13:47,500
比如说 之前我忽略了通用除法操作
I ignored greatest common divisor, for instance.

1338
01:13:47,500 --> 01:13:50,280
我忽略了这个问题 是为了简化我们的例子
I ignored that problem just to keep the example simple.

1339
01:13:50,280 --> 01:13:59,820
但是如果突然我觉得 有理数加法应该对结果
But if I suddenly decided that plus rat here should do a GCD

1340
01:13:59,820 --> 01:14:04,750
求最大公约数 并且把这个功能安装到程序里 那么这个功能
computation and install that,then that immediately becomes

1341
01:14:04,750 --> 01:14:08,280
一旦安装 就立刻可以被所有过程调用
available to all of these, to that guy, and that guy, and

1342
01:14:08,280 --> 01:14:11,560
被这个或者那个 所有的这些
that guy, and all the way down.

1343
01:14:11,560 --> 01:14:13,890
所以这个取决于你为什么要提高耦合性
So it depends what you mean by the coherence of your system.

1344
01:14:13,890 --> 01:14:17,030
确实你可能想设计一个
It's certainly true that you might want to have a special

1345
01:14:17,030 --> 01:14:18,950
不这样递归下降的程序
different one that didn't filter down through the

1346
01:14:18,950 --> 01:14:21,400
但是我举这个例子的好处
coefficients, but the nice thing about this particular

1347
01:14:21,400 --> 01:14:25,440
就在于我们通常都是这么做的
example is that mostly you do.

1348
01:14:25,440 --> 01:14:27,630
学生：是不是有一个问题 我想
AUDIENCE: Isn't that the problem, I think, that you're

1349
01:14:27,630 --> 01:14:32,950
就是你会被这个结构捆绑起来
getting to tied in with the fact that the structuring, the

1350
01:14:32,950 --> 01:14:36,330
这个递归的结构是实际上被执行了的 
recursiveness of that structuring there is actually

1351
01:14:36,330 --> 01:14:40,340
而不是仅仅是为了定义类型的需要
in execution as opposed to just definition of the actual

1352
01:14:40,340 --> 01:14:41,590
被这个事实所束缚
types themselves?

1353
01:14:41,590 --> 01:14:44,680


1354
01:14:44,680 --> 01:14:46,120
教授：我想我明白你的意思
PROFESSOR: I think I understand the question.

1355
01:14:46,120 --> 01:14:48,650
你是想说在这个系统投入运行之后
The point is that these types evolve and get more and more

1356
01:14:48,650 --> 01:14:50,400
这些类型还会变得越来越复杂
complex as the thing's actually running.

1357
01:14:50,400 --> 01:14:50,730
你是不是想……
Is that what--

1358
01:14:50,730 --> 01:14:50,990
学生：对
AUDIENCE: Yes.
你是不是想……
Is that what--

1359
01:14:50,990 --> 01:14:51,790
在它投入运行之后
As it's running.

1360
01:14:51,790 --> 01:14:51,956
教授：……说这个？
PROFESSOR: --what you're saying?

1361
01:14:51,956 --> 01:14:52,090
对 重点就在于……
Yes, the point is--

1362
01:14:52,090 --> 01:14:54,180
学生：而不是作为基本的定义
AUDIENCE: As opposed to the basic definitions.
对 重点就在于……
Yes, the point is--

1363
01:14:54,180 --> 01:14:54,830
教授：对
PROFESSOR: Right.

1364
01:14:54,830 --> 01:14:57,210
我们的类型结构可以说就是递归的
The type structure is sort of recursive.

1365
01:14:57,210 --> 01:15:02,770
它并不是一个 可以在系统投入运行之前
It's not that you can make this finite list of the actual

1366
01:15:02,770 --> 01:15:04,850
就能把要用到的东西全部包括的列表
things they might look like before the system runs.

1367
01:15:04,850 --> 01:15:06,780
它是一个会发展变化的东西
It's something that evolves.

1368
01:15:06,780 --> 01:15:09,610
所以如果你想要定制这个系统#TBD
So if you want to specify that system, you have to do in some

1369
01:15:09,610 --> 01:15:12,275
你就不能通过修改这个列表 而是要通过其它的方式
other way than by this finite list. You have to do it by a

1370
01:15:12,275 --> 01:15:13,670
你需要用一个递归结构实现它
recursive structure.

1371
01:15:13,670 --> 01:15:16,960
学生：因为类型的基本结构
AUDIENCE: Because the basic structure of the types is

1372
01:15:16,960 --> 01:15:17,900
是非常简单的
pretty clean and simple.

1373
01:15:17,900 --> 01:15:20,125
教授：对
PROFESSOR: Right.

1374
01:15:20,125 --> 01:15:21,460
嗯？
Yes?

1375
01:15:21,460 --> 01:15:22,870
学生：我有一个问题
AUDIENCE: I have a question.

1376
01:15:22,870 --> 01:15:25,980
我明白一旦你的数据结构被设计好之后
I understand once you have your data structure set up,

1377
01:15:25,980 --> 01:15:29,230
它是怎么把complex标志拿掉 把它传递给下层
how it pulls off complex and passes that down, and then

1378
01:15:29,230 --> 01:15:30,640
然后把rect标志拿掉 再传递给下层
pulls off rect, passes that down.

1379
01:15:30,640 --> 01:15:32,790
但是如果你只是一个用户 对这些
But if you're just a user and you don't know anything about

1380
01:15:32,790 --> 01:15:35,610
rect或者polar这些类型完全不懂 你怎么知道去
rect or polar or whatever, how do you initially set up that

1381
01:15:35,610 --> 01:15:37,330
设置这个数据结构
data structure so that everything goes

1382
01:15:37,330 --> 01:15:38,390
让所有东西正常运转呢
to the right spot?

1383
01:15:38,390 --> 01:15:41,210
如果我只知道左边的这个算式
If I just have the equation over there on the left and I

1384
01:15:41,210 --> 01:15:42,500
我只是想把复数加起来或者乘起来
just want to add, multiply complex numbers--

1385
01:15:42,500 --> 01:15:43,640
教授：这就是它神奇的地方
PROFESSOR: Well that's the wonderful thing.

1386
01:15:43,640 --> 01:15:47,730
如果你是一个用户 直接调用mul就可以了
If you're just a user you say "mul."

1387
01:15:47,730 --> 01:15:50,280
学生：然后它就能明白我要计算的是复数？
AUDIENCE: And it figures out that I mean complex numbers?

1388
01:15:50,280 --> 01:15:51,420
或者我怎么告诉它我想——
Or how do I tell it that I want--

1389
01:15:51,420 --> 01:15:51,950
教授：然后你就会得到一个复数
PROFESSOR: Well you're going to have in your

1390
01:15:51,950 --> 01:15:53,050
教授：然后你就会得到一个复数
hands complex numbers.

1391
01:15:53,050 --> 01:15:56,490
看看这个系统 在用户这一级别上还有什么东西
See what you would have at some level, as a real user, is

1392
01:15:56,490 --> 01:15:58,370
我们有一个复数的构造函数
a constructor for complex numbers.

1393
01:15:58,370 --> 01:15:59,470
学生：那么我需要自己构造复数了？
AUDIENCE: So then I have to make complex numbers?

1394
01:15:59,470 --> 01:16:00,350
教授：那么你需要自己构造它们
PROFESSOR: So you have to make them.

1395
01:16:00,350 --> 01:16:03,180
作为用户你拥有的 可能是输入界面
What you would probably have as a user is some little thing

1396
01:16:03,180 --> 01:16:07,390
内置的小功能 它会提供给你输入复数的方法
in the reader loop, which would give you some plausible

1397
01:16:07,390 --> 01:16:09,850
内置的小功能 它会提供给你输入复数的方法
way to type in a complex number, in

1398
01:16:09,850 --> 01:16:11,590
让你用你喜欢的格式输入
whatever format you like.

1399
01:16:11,590 --> 01:16:14,360
也可能你根本就不用输入它们
Or it might be that you're never typing them in.

1400
01:16:14,360 --> 01:16:16,170
只是别人给你一个复数让你计算
Someone's just handing you a complex number.

1401
01:16:16,170 --> 01:16:19,500
学生：好 那么如果我有一个复数
AUDIENCE: OK, so if I had a complex number that had a

1402
01:16:19,500 --> 01:16:21,505
它里面有一个多项式 我就要先构造这个多项式
polynomial in it, I'd have to make my polynomial and then

1403
01:16:21,505 --> 01:16:21,960
然后再构造我的复数
make my complex number.

1404
01:16:21,960 --> 01:16:24,220
如果你是从零开始构造它的话 是这样的
PROFESSOR: Right if you wanted it constructed from scratch.

1405
01:16:24,220 --> 01:16:25,710
可以说你是在从零开始构造
At some point you construct them from scratch.

1406
01:16:25,710 --> 01:16:27,880
但是你不需要知道（计算的原理） 你有了要计算的东西
But what you don't have to know of that is when you have

1407
01:16:27,880 --> 01:16:32,345
可以直接调用mul操作 然后它们就会被乘起来
the object you can just say "mul." And it'll multiply.

1408
01:16:32,345 --> 01:16:33,279
说吧
Yeah?

1409
01:16:33,279 --> 01:16:36,450
学生：我想提一个问题 就是……
AUDIENCE: I think the question that was being posed here is,

1410
01:16:36,450 --> 01:16:40,220
比如说我想修改我的复数表示方法
say if I want to change my presentation of complexes, or

1411
01:16:40,220 --> 01:16:46,330
或者对复数的某些操作 我需要实际上去面对
some operation of complex, how much real code I will have to

1412
01:16:46,330 --> 01:16:49,860
或者修改的代码有多少
gets around with, or change to change it in

1413
01:16:49,860 --> 01:16:52,270
在我修改一个操作的过程当中
one specific operation?

1414
01:16:52,270 --> 01:16:53,490
教授：看你想要修改的是什么
PROFESSOR: [UNINTELLIGIBLE] what you have to change.

1415
01:16:53,490 --> 01:16:54,990
重点在于你只需要改
And the point is that you only have to change

1416
01:16:54,990 --> 01:16:56,070
你想改的那一部分
what you're changing.

1417
01:16:56,070 --> 01:17:00,320
想象一下如果Martha决定她
See if Martha decides that she would rather--

1418
01:17:00,320 --> 01:17:01,440
举个简单的例子
let's see something silly--

1419
01:17:01,440 --> 01:17:04,040
比如把序对中两个数的顺序调换
like change the order in the pair.

1420
01:17:04,040 --> 01:17:09,700
把模和辐角的顺序反过来
Like angle and magnitude in the other order, she just

1421
01:17:09,700 --> 01:17:10,970
只是这样修改了她自己的程序
makes that change locally.

1422
01:17:10,970 --> 01:17:12,750
那么这个改动会准确无误地
And the whole thing will propagate through the system

1423
01:17:12,750 --> 01:17:14,790
扩散到整个系统里
in the right way.

1424
01:17:14,790 --> 01:17:18,040
或者突然你说 我有另一种方法
Or if suddenly you said, gee, I have another representation

1425
01:17:18,040 --> 01:17:19,700
来表示有理数
for rationals.

1426
01:17:19,700 --> 01:17:22,740
我要通过在表格里添加操作
And I'm going to stick it here, by filing those

1427
01:17:22,740 --> 01:17:24,820
把这种方法放到系统里面
operations in the table.

1428
01:17:24,820 --> 01:17:27,220
那么突然之间所有的多项式
Then suddenly all of these polynomials whose coefficients

1429
01:17:27,220 --> 01:17:29,240
它们的系数和系数的系数 或者什么东西
are coefficients of coefficients, or whatever,

1430
01:17:29,240 --> 01:17:32,970
都自动支持用这种表示方法来表示了
also can automatically have available that representation.

1431
01:17:32,970 --> 01:17:35,952
这就是我们这种设计的威力
That's the power of this particular one.

1432
01:17:35,952 --> 01:17:37,625
学生：我不知道我能不能提一个
AUDIENCE: I'm not sure if I can even pose an intelligent

1433
01:17:37,625 --> 01:17:38,700
聪明一点的问题
sounding question.

1434
01:17:38,700 --> 01:17:42,920
整个这个系统看起来
But somehow this whole thing went really nicely to this

1435
01:17:42,920 --> 01:17:44,910
非常完美 所有的东西都
beautiful finish where all the things seemed

1436
01:17:44,910 --> 01:17:47,280
各就各位
to fall into place.

1437
01:17:47,280 --> 01:17:49,530
完美得有点不自然
Sort of seemed a little contrived.

1438
01:17:49,530 --> 01:17:50,930


1439
01:17:50,930 --> 01:17:52,670
我相信 这都是为了教学方便
That's all for the sake,I'm sure, of teaching.

1440
01:17:52,670 --> 01:17:55,100
我怀疑的是首先发明了这种做法的人
I doubt that the guys who first did this--

1441
01:17:55,100 --> 01:17:56,510
我可能说得不对
and I could be wrong--

1442
01:17:56,510 --> 01:17:59,200
难道一下子就搞清楚了所有这些东西
figured it all out so that when they just all put it all

1443
01:17:59,200 --> 01:18:02,410
只要把这些放在一起 你就突然可以什么什么
together, you could all of the sudden, blam, do any kind of

1444
01:18:02,410 --> 01:18:04,860
对各种对象做各种运算
arithmetic on any kind of object.

1445
01:18:04,860 --> 01:18:07,930
我觉得他们应该研究了很长时间
It seems like maybe they had to play with it for a while

1446
01:18:07,930 --> 01:18:11,800
不断地推倒重来
and had to bash it and rework it.

1447
01:18:11,800 --> 01:18:14,120
然后我觉得 当我们设计一个非常复杂的系统
And it seems like that's the kind of problem we're really

1448
01:18:14,120 --> 01:18:16,940
我们也要面对这样的问题
faced with we start trying to design a really complex system

1449
01:18:16,940 --> 01:18:19,390
就是有太多各种各样的部件 
is having lots of different kinds of parts and

1450
01:18:19,390 --> 01:18:22,730
我们甚至不知道要对这些部件
not even knowing what kinds of operations we're going to want

1451
01:18:22,730 --> 01:18:24,620
做什么样的操作
to do on those parts.

1452
01:18:24,620 --> 01:18:27,580
在这种时候我怎么用这种科学的方法组织操作
How to organize the operations in this nice way so that no

1453
01:18:27,580 --> 01:18:29,630
才能获得这种 不管怎样只要把它们放在一起 
matter what you do, when you start putting them together

1454
01:18:29,630 --> 01:18:31,700
所有事情就正常运转 这样的效果呢
everything starts falling out for free.

1455
01:18:31,700 --> 01:18:33,090
教授：很好，这确实是一个
PROFESSOR: OK, well that's certainly a

1456
01:18:33,090 --> 01:18:34,340
非常聪明的问题
very intelligent question.

1457
01:18:34,340 --> 01:18:37,020


1458
01:18:37,020 --> 01:18:40,560
要说的一点是我们这种方法论
One part is this is a very good methodology that people

1459
01:18:40,560 --> 01:18:44,590
受到了符号代数的很多启发
have discovered a lot coming from symbolic algebra.

1460
01:18:44,590 --> 01:18:47,590
因为在那里面有很多复杂的理论#TBD
Because there are a lot of complications.

1461
01:18:47,590 --> 01:18:50,710
允许你在决定各种操作是什么样子之前
To allow you to implement these things before you decide

1462
01:18:50,710 --> 01:18:52,130
来实现这个系统
what you want all the operations to

1463
01:18:52,130 --> 01:18:53,310
来实现这个系统
be, and all of that.

1464
01:18:53,310 --> 01:18:55,580
所以从某种意义上讲 这是人们
So in some sense it's an answer that people have

1465
01:18:55,580 --> 01:18:58,560
在这方面长期探索之后得出的答案
discovered by wading through this stuff.

1466
01:18:58,560 --> 01:19:02,160
从另一个角度来说 这确实是一个人为设计的例子
In another sense, it is a very contrived example.

1467
01:19:02,160 --> 01:19:06,240
学生：看上去想要设计出这样的系统
AUDIENCE: It seems like to be able to do this you do have to

1468
01:19:06,240 --> 01:19:08,320
一开始先要研究一段时间
wade through it for a certain amount of time before you can

1469
01:19:08,320 --> 01:19:09,010
然后才能变熟练
become good at it.

1470
01:19:09,010 --> 01:19:12,220
教授：我给你看看这个东西是多么的勉强
PROFESSOR: Let me show you how terribly contrived this is.

1471
01:19:12,220 --> 01:19:14,130
你现在可以写下所有的这些程序
So you can write all these wonderful things.

1472
01:19:14,130 --> 01:19:17,600
但是我写在这里的这个系统 如果我们
But the system that I wrote here, and if we had another

1473
01:19:17,600 --> 01:19:19,820
再有半个小时的上课的时间我就能
half an hour to give this lecture I would have given

1474
01:19:19,820 --> 01:19:23,470
把它讲给大家 注意如果我让它做一个错误操作
this part of it, which says,notice that it breaks down if

1475
01:19:23,470 --> 01:19:30,880
比如一个愚蠢的命令 用3加上7/2 它就会崩溃
I tell it to do something as foolish as add 3 plus 7/2.

1476
01:19:30,880 --> 01:19:33,980
因为程序首先会调用operate-2这个过程
Because what will happen is you'll get to operate-2, and

1477
01:19:33,980 --> 01:19:36,180
然后operate-2会说 这个是数字类型
operate-2 will say, oh this is type number,

1478
01:19:36,180 --> 01:19:37,560
那个是有理数类型
and that's type rational.

1479
01:19:37,560 --> 01:19:38,810
我不知道怎么把它们加起来
I don't know how to add them.

1480
01:19:38,810 --> 01:19:41,530


1481
01:19:41,530 --> 01:19:43,600
那么你想让这个系统至少能够
So you'd like the system at least to be able to say

1482
01:19:43,600 --> 01:19:48,660
比如说 在做这个操作之前
something like, gee,before you do that

1483
01:19:48,660 --> 01:19:50,480
把3变成3/1
change that to 3/1.

1484
01:19:50,480 --> 01:19:52,250
把它变成一个有理数 然后
Turn it into a rational number,hand that to the

1485
01:19:52,250 --> 01:19:53,500
交给有理数程序包来处理
rational package.

1486
01:19:53,500 --> 01:19:55,510


1487
01:19:55,510 --> 01:19:58,860
这是我讲课时没有讲到的一个东西
That's the thing I didn't talk about in this lecture.

1488
01:19:58,860 --> 01:20:00,880
书里面讨论了这个问题 
It's a little bit in the book,which talks about the problem

1489
01:20:00,880 --> 01:20:03,390
叫做强制转换
of what's called coercion.

1490
01:20:03,390 --> 01:20:05,310
你想要的是
Where you wanted--

1491
01:20:05,310 --> 01:20:08,280
看 我们小心翼翼地设计了这些类型
see, having so carefully set up all of these types as

1492
01:20:08,280 --> 01:20:11,720
来把对象进行分类 但是有时你也想让它
distinct objects, a lot of times you want to also put in

1493
01:20:11,720 --> 01:20:16,650
知道怎么把一个普通的数字
knowledge about how to view an ordinary number

1494
01:20:16,650 --> 01:20:19,110
当成有理数
as a kind of rational.

1495
01:20:19,110 --> 01:20:21,620
或者把普通的数字当成复数
Or view an ordinary number as a kind of complex.

1496
01:20:21,620 --> 01:20:24,580
到那个时候系统就开始
That's where the complexity in the system really starts

1497
01:20:24,580 --> 01:20:27,110
变得复杂了 就是你去思考 我应该把这些知识
happening, where you talk about, see where

1498
01:20:27,110 --> 01:20:28,420
放在哪里的时候
do I put that knowledge?

1499
01:20:28,420 --> 01:20:30,810
让它知道一个普通数字可以变成组合对象
Is it rational to know that ordinary numbers might be

1500
01:20:30,810 --> 01:20:33,130
真的是一件好事吗
pieces of cons of them?

1501
01:20:33,130 --> 01:20:38,790
或者我们举一个更加糟糕的例子
Or they're terrible, terrible examples, like if I might want

1502
01:20:38,790 --> 01:20:48,510
比如说我想要把一个复数加到有理数上去
to add a complex number to a rational number.

1503
01:20:48,510 --> 01:20:50,080


1504
01:20:50,080 --> 01:20:50,760
这个不好
Bad example.

1505
01:20:50,760 --> 01:20:52,010
5/7.

1506
01:20:52,010 --> 01:20:53,860


1507
01:20:53,860 --> 01:20:57,300
然后整个系统里必须有人知道 他需要把这个东西
Then somebody's got to know that I have to convert these

1508
01:20:57,300 --> 01:20:59,790
变成另一种类型 一个复数 
to another type, which is complex numbers whose parts

1509
01:20:59,790 --> 01:21:01,540
它的一部分是有理数
might be rationals.

1510
01:21:01,540 --> 01:21:02,680
那么谁应该去操心这个事情呢
And who worries about that?

1511
01:21:02,680 --> 01:21:03,950
是complex过程吗
Does complex worry about that?

1512
01:21:03,950 --> 01:21:05,030
是rational过程吗
Does rational worry about that?

1513
01:21:05,030 --> 01:21:06,900
plus过程要考虑这个问题吗
Does plus worry about that?

1514
01:21:06,900 --> 01:21:08,520
这就是体现复杂性的地方
That's where the real complexity comes in.

1515
01:21:08,520 --> 01:21:11,380
也是这个问题的特别之处#TBD
And that's where it's pretty well sorted out.

1516
01:21:11,380 --> 01:21:14,810
同时很多的 实际上是所有的这样的消息传递的想法
And a lot of, in fact, all of this message passing stuff was

1517
01:21:14,810 --> 01:21:18,460
都是被这样的问题启发的
motivated by problems like this.

1518
01:21:18,460 --> 01:21:21,630
当你真正深入进去#TBD 人们
And when you really push it,people are-- somehow the

1519
01:21:21,630 --> 01:21:25,330
代数操作的问题是如此复杂
algebraic manipulation problem seems to be so complex that

1520
01:21:25,330 --> 01:21:27,410
那些一直围绕它们工作的人们 确实就处在
the people who are always at the edge of it are exactly in

1521
01:21:27,410 --> 01:21:28,050
你说的那种状态
the state you said.

1522
01:21:28,050 --> 01:21:29,940
他们在这些问题里艰难跋涉 时不时陷进泥里
They're wading through this thing, mucking around, seeing

1523
01:21:29,940 --> 01:21:33,470
寻找好用的工具 并试着提炼一个通用的方法
what they use, trying to distill stuff.

1524
01:21:33,470 --> 01:21:36,030
学生：我想再一次回到这个
AUDIENCE: I just want to come back to this issue of

1525
01:21:36,030 --> 01:21:39,250
复杂度的问题上来
complexity once more.

1526
01:21:39,250 --> 01:21:44,550
在修改底层过程的时候 这个系统
It certainly seems to be true that you have a great deal of

1527
01:21:44,550 --> 01:21:49,580
毫无疑问 体现了非常大的灵活性
flexibility in altering the lower level kinds of things.

1528
01:21:49,580 --> 01:21:54,320
但是确实 在某种意义上讲 你封死了
But it is true that you are,in a sense, freezing higher

1529
01:21:54,320 --> 01:21:55,450
对高层操作的修改
level operations.

1530
01:21:55,450 --> 01:21:58,510
或者至少如果你修改它们 你不知道
Or at least if you change them you don't know where all of

1531
01:21:58,510 --> 01:22:02,060
改动会体现在哪里 会怎么体现出来
the changes are going to show up, or how they are.

1532
01:22:02,060 --> 01:22:04,840
教授：这个问题真是不能再好了
PROFESSOR: OK, that's an extremely good question.

1533
01:22:04,840 --> 01:22:10,130
我要做的事情就是 如果我决定添加一个
What I have to do is, if I decide there's a new general

1534
01:22:10,130 --> 01:22:16,300
新的通用操作叫做equality-test 然后所有这些过程
operation called equality test,then all of these people

1535
01:22:16,300 --> 01:22:19,835
就要查表格 来看他们需不需要
have to decide whether or not they would like to have an

1536
01:22:19,835 --> 01:22:24,650
测试两个数是否相等
equality test by looking in the table.

1537
01:22:24,650 --> 01:22:27,870
我们可以让它变得更加去中心化
There're ways to decentralize it even more.

1538
01:22:27,870 --> 01:22:31,430
这就是之前我提示了很多次的事情
That's what I sort of hinted at last time, where I said you

1539
01:22:31,430 --> 01:22:34,240
我说你可以不仅把类型标志放在对象里
could not only have this type as a symbol, but you actually

1540
01:22:34,240 --> 01:22:37,850
而是把每一类对象接受的操作
might store in each object the operations

1541
01:22:37,850 --> 01:22:40,450
也保存在里面
that it knows of that.

1542
01:22:40,450 --> 01:22:44,670
那么你可以添加一个 比如说最大公约数过程
So you might have things like greatest common divisor, which

1543
01:22:44,670 --> 01:22:47,540
它只能计算整数
is a thing here which is defined only for integers, and

1544
01:22:47,540 --> 01:22:51,030
而不是对所有有理数都通用
not in general for rational numbers.

1545
01:22:51,030 --> 01:22:53,110
所以这个系统可能是非常非常碎片化的
So it might be a very, very fragmented system.

1546
01:22:53,110 --> 01:22:56,570
取决于你想让哪一部分比较灵活
And then depending on where you want your flexibility,

1547
01:22:56,570 --> 01:22:58,190
有一系列的地方让你
there's a whole spectrum of places that you

1548
01:22:58,190 --> 01:22:59,960
把这个东西放进去
can build that in.

1549
01:22:59,960 --> 01:23:02,320
但是你也指出了这种设计的弱点
But you're pointing at the place where this starts being

1550
01:23:02,320 --> 01:23:04,990
就是在顶层对于这些通用操作符
weak, that there has to be some agreement on top here

1551
01:23:04,990 --> 01:23:06,370
必须有一些约定
about these general operations.

1552
01:23:06,370 --> 01:23:08,390
或者至少人们要考虑这件事情
Or at least people have to think about them.

1553
01:23:08,390 --> 01:23:10,340
或者你可以决定 把这个表格设计得
Or you might decide, you might have a table that's very

1554
01:23:10,340 --> 01:23:14,010
很稀疏 里面只放很少的一点东西
sparse, that only has a few things in it.

1555
01:23:14,010 --> 01:23:15,490
这个游戏有很多种玩法
But there are lot of ways to play that game.

1556
01:23:15,490 --> 01:23:19,780


1557
01:23:19,780 --> 01:23:21,030
谢谢大家
OK, thank you.

1558
01:23:21,030 --> 01:23:23,534


1559
01:23:23,534 --> 01:23:23,849
[音乐]
[MUSIC: "JESU, JOY OF
MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

1560
01:23:23,849 --> 01:23:25,099
[音乐]
[MUSIC: "JESU, JOY OF
MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

1561
01:23:25,099 --> 01:23:36,682
