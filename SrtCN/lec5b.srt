1
00:00:21,170 --> 00:00:27,408
我们已经学了如何用独立的局部状态来建模对象
PROFESSOR: Well, now that we've given you some power to make independent local state and to model objects,

2
00:00:28,336 --> 00:00:32,672
我想我们应该找点复杂的东西
I thought we'd do a bit of programming of a very complicated kind,

3
00:00:34,032 --> 00:00:36,368
来实践一下我们学过的这些知识
just to illustrate what you can do with this sort of thing.

4
00:00:40,430 --> 00:00:43,488
假设，我们处在这样一个物理系统中，系统中的事物驱动彼此，全部的这些事物组成了世界
I suppose, as I said, we were motivated by physical systems

5
00:00:44,112 --> 00:00:46,256
假设，我们处在这样一个物理系统中，系统中的事物驱动彼此，全部的这些事物组成了世界
the ways we like to think about physical systems,

6
00:00:46,992 --> 00:00:51,088
假设，我们处在这样一个物理系统中，系统中的事物驱动彼此，全部的这些事物组成了世界
which is that there are these things that the world is made out of.

7
00:00:52,060 --> 00:00:55,984
每一个事物都有其独立的局部状态
And each of these things has particular independent local state,

8
00:00:57,248 --> 00:00:59,872
每一个事物都有其独立的局部状态
and therefore it is a thing. That's what makes it a thing.

9
00:01:01,280 --> 00:01:04,272
我们说 我们有一个真实的世界
And then we're going to say that in the model in the world

10
00:01:04,288 --> 00:01:09,900
我们在大脑中和计算机中对那个真实世界建模
we have a world and a model in our minds and in the computer of that world.

11
00:01:10,940 --> 00:01:15,184
我想要把真实世界的对象和计算机中的对象联系对应起来
And what I want to make is a correspondence between the objects in the world and the objects in the computer,

12
00:01:15,872 --> 00:01:21,728
把真实世界中对象间的关系 与模型中对象间的关系 对应起来
the relationships between the objects in the world and the relationships between those same obj...--the model objects in the computer,

13
00:01:23,184 --> 00:01:28,112
真实世界中关联对象的函数 与模型中的函数 对应起来
and the functions that relate things in the world to the functions that relate things in the computer.

14
00:01:30,840 --> 00:01:33,824
这也就指引了我们如何去模块化 #TBD
This buys us modularity.

15
00:01:34,740 --> 00:01:36,752
如果我们认为真实世界是像那样的
If we really believe the world is like that,

16
00:01:37,360 --> 00:01:38,720
也就是由许多小的事物构成的
that it's made out of these little pieces,

17
00:01:39,200 --> 00:01:41,472
当然 我们可以把世界安排成那样
and of course we could arrange our world to be like that,

18
00:01:42,032 --> 00:01:43,952
我们只能对像那样的事物建模
we could only model those things that are like that,

19
00:01:45,456 --> 00:01:49,024
这样 我们的程序就可以从现实世界中继承模块化
then we can inherit the modularity in the world into our programming.

20
00:01:50,450 --> 00:01:53,584
这就是发明面向对象编程的初衷
That's why we would invent some of this object-oriented programming.

21
00:01:55,420 --> 00:01:58,192
我所见过的最完美的对象（系统）
Well, let's take the best kind of objects I know.

22
00:01:58,890 --> 00:02:04,176
电气系统 就是非常非常完美的对象系统
They're completely--they're completely wonderful: electrical systems.

23
00:02:06,400 --> 00:02:12,992
电气系统真的是物理学家构造的非常非常好的一种对象
Electrical systems really are the physicist's best, best objects.

24
00:02:14,220 --> 00:02:16,760
这里 我有一些机器零件
You see over here I have some piece of machinery.

25
00:02:16,760 --> 00:02:20,040
确实是机器零件
Right here's a piece of machinery.

26
00:02:20,040 --> 00:02:27,190
有一个电线连接起了零件的两个部分
And it's got an electrical wire connecting one part of the machinery with another part of the machinery.

27
00:02:27,190 --> 00:02:38,310
电气世界中有一个非常棒的特性，就是我可以说这是一个对象，这是一个对象，这两个对象连接起来，所有关系一目了然
And one of the wonderful properties of the electrical world is that I can say this is an object, and this is an object, and they're-- the connection between them is clear.

28
00:02:38,310 --> 00:02:44,740
而且，如果我没有用电线连接，它们便没有关系
In principle, there is no connection that I didn't describe with these wires.

29
00:02:44,740 --> 00:02:51,370
比如我有一个灯泡，一个已经接在插座上的电源
Let's say if I have light bulbs, a light bulb and a power supply that's plugged into the outlet.

30
00:02:51,370 --> 00:02:53,620
关系非常明了
Then the connection is perfectly clear.

31
00:02:53,620 --> 00:02:56,220
没有另外的关系表现形式
There's no other connections that we know of.

32
00:02:56,220 --> 00:03:04,040
就算我把电线打个结，灯仍然是亮着的
If I were to tie a knot in the wire that connects the light bulb to the power supply, the light remains lit up.

33
00:03:04,040 --> 00:03:05,290
没什么影响
It doesn't care.

34
00:03:08,300 --> 00:03:15,270
在物理上，这种连接可以被抽象出来，至少在低频状态下是可以的
That the way the physics is arranged is such that the connection can be made abstract, at least for low frequencies and things like that.

35
00:03:17,840 --> 00:03:22,350
而且这就是全部的连接方式了
So in fact, we have captured all of the connections there really are.

36
00:03:22,350 --> 00:03:30,951
当然，我们来进一步讨论一种在电气系统中最为广泛的抽象，数字电路
Well, as you can go one step further and talk about the most abstract types of electrical systems we have, digital to dual circuits.

37
00:03:30,951 --> 00:03:34,610
这有一些对象元件
And here there are certain kinds of objects.

38
00:03:34,610 --> 00:03:41,092
例如，在数字电路里我们有像非门这样的东西
For example, in digital circuits we have things like inverters.

39
00:03:41,092 --> 00:03:43,990
还有与门
We have things like and-gates.

40
00:03:43,990 --> 00:03:47,210
或门
We have things like or-gates.

41
00:03:47,210 --> 00:03:55,610
我们用电线把它们连接起来，电线就是对01信号的抽象
We connect them together by sort-of wires which represent abstract signals.

42
00:03:55,610 --> 00:04:05,160
我们不关心具体的物理因素，像电压啊，电流啊，元件怎么组合啊 等等
We don't really care as physical variables whether these are voltages or currents or some combination or anything like that, or water, water pressure.

43
00:04:05,160 --> 00:04:09,420
这些因素统一抽象为信号
These abstract variables represent certain signals.

44
00:04:09,420 --> 00:04:14,070
我们用电路连接元件，构建系统
And we build systems by wiring these things together with wires.

45
00:04:14,070 --> 00:04:32,700
一会儿我要向你们介绍一种新的语言，像之前讲过的图形语言一样，都嵌入在LISP中，不是昨天那种模式匹配替换的语言
So today what I'm going to show you, right now, we're going to build up an invented language in Lisp, embedded in the same sense that Henderson's picture language was embedded, which is not the same sense as the language of pattern match and substitution was done yesterday.

46
00:04:32,700 --> 00:04:38,160
模式匹配替换的语言还需要用LISP编写另外的程序来解释
The pattern match/substitution language was interpreted by a Lisp program.

47
00:04:38,160 --> 00:04:45,480
但是之前那种绘图语言我们可以随意使用，不管构造过程还是组合数据
But the embedding of Henderson's program is that we just build up more and more procedures that encapsulate the structure we want.

48
00:04:45,480 --> 00:04:53,026
举例来说，首先我要有一些原子对象，比如这个，这个
So for example here, I'm going to have some various primitive kinds of objects, as you see, that one and that one.

49
00:04:53,026 --> 00:04:55,810
然后用电线去组合它们
I'm going to use wires to combine them.

50
00:04:55,810 --> 00:04:59,870
(make-wire)构造一个电线
The way I represent attaching-- I can make wires.

51
00:04:59,870 --> 00:05:01,740
a就代表了一根电线
So let's say A is a wire.

52
00:05:01,740 --> 00:05:02,690
b也是
And B is a wire.

53
00:05:02,690 --> 00:05:03,460
c也是
And C is a wire.

54
00:05:03,460 --> 00:05:04,230
d也是
And D is a wire.

55
00:05:04,230 --> 00:05:04,830
还有e
And E is wire.

56
00:05:04,830 --> 00:05:06,880
还有s
And S is a wire.

57
00:05:06,880 --> 00:05:17,940
再来看元件，或门有两个输入a和b，一个输出d，就像这样
Well, an or-gate that has both inputs, the inputs being A and B, and the output being Y or D, you notate like this.

58
00:05:17,940 --> 00:05:24,820
与门，a和b两个输入，一个输出c
An and-gate, which has inputs A and B and output C, we notate like that.

59
00:05:24,820 --> 00:05:32,750
就像这样来声明，我可以组合出任意的电路
By making such a sequence of declarations, like this, I can wire together an arbitrary circuit.

60
00:05:32,750 --> 00:05:43,690
我已经说明了原子元素，组合方法，然后就轮到抽象方法了
So I've just told you a set of primitives and means of combination for building digital circuits, when I need more in a real language than abstraction.

61
00:05:43,690 --> 00:05:52,240
举例来说，这是一个半加器
And so for example, here I have--here I have a half adder.

62
00:05:52,240 --> 00:05:56,930
如果你学过电路设计肯定知道这个东西
It's something you all know if you've done any digital design.

63
00:05:56,930 --> 00:06:03,956
输入两个数a和b，输出“和”和进位
It's used for adding numbers together on A and B and putting out a sum and a carry.

64
00:06:03,956 --> 00:06:07,450
事实上，完全可以用我刚刚说的来组合电路
And in fact, the wiring diagram is exactly what I told you.

65
00:06:07,450 --> 00:06:14,790
把半加器看成一个盒子，盒子的边界，抽象出的永远都是一个盒子
A half adder with things that come out of the box-- you see the box, the boundary, the abstraction is always a box.

66
00:06:14,790 --> 00:06:19,700
从盒子里引出A B S C四根线
And there are things that come out of it, A, B, S, and C.

67
00:06:19,700 --> 00:06:28,270
这些是已经声明了的变量，我们就用它们来定义半加器
Those are the declared variables--declared variables of a lambda expression, which is the one that defines half adder.

68
00:06:31,400 --> 00:06:48,790
为了连接半加器里面的线路，我构造了电线D和E，E是这个，D是这个，内部连接的线路并没有引出盒子之外，就像这样连起来
And internal to that, I make up some more wires, D and E, which I'm going to use for the interconnect-- here E is this one and D is this wire, the interconnect that doesn't come through the walls of the box-- and wire things together as you just saw.

69
00:06:48,790 --> 00:06:53,890
你可以看的出来，这个语言非常有层次性
And the nice thing about this that I've just shown you is this language is hierarchical in the right way.

70
00:06:53,890 --> 00:07:06,300
如果一个语言没有层次性，如果你不能把一个复合对象当成原子对象来使用，这个语言肯定是有问题的 -- 至少我这样觉得
If a language isn't hierarchical in the right way, if it turns out that a compound object doesn't look like a primitive, there's something wrong with the language-- at least the way I feel about that.

71
00:07:06,300 --> 00:07:23,350
之前我们都是从计算一些数字上的函数开始的，现在我们不那样做，我们从一些电路对象开始，构建更多的电路对象
So here we have--here, instead of starting with mathematical functions, or things that compute mathematical functions, which is what we've been doing up until now, instead of starting with things that look like mathematical functions, or compute such things, we are starting with things that are electrical objects and we build up more electrical objects.

72
00:07:23,350 --> 00:07:30,500
用LISP里的lambda将其粘合起来
And the glue we're using is basically the Lisp structure: lambdas.

73
00:07:30,500 --> 00:07:32,930
lambda是很有用的粘合剂
Lambda is the ultimate glue, if you will.

74
00:07:32,930 --> 00:08:05,900
当然，两个半加器可以组成结构更为复杂的全加器，就像这里这个，把线路连在一起，还需要另外的电线如S，C1和C2，还有一个或门。全加器输入两个数，一个进位值，输出“和”和一个进位值
And of course, half adder itself can be used in a more complicated abstraction called a full adder, which in fact involves two half adders, as you see here, hooked together with some extra wires, that you see here, S, C1, and C2, and an or-gate, to manufacture a full adder, which takes a input number, another input number, a carry in, and produces output, a sum and a carry out.

75
00:08:05,900 --> 00:08:12,990
除此之外，还可以把全加器链起来组成更大的加法器
And out of full adders, you can make real adder chains and big adders.

76
00:08:12,990 --> 00:08:22,270
现在我们的语言有了原子元素，组合方法和抽象方法，才算完整
So we have here a language so far that has primitives, means of combination, and means of abstraction to real language.

77
00:08:22,270 --> 00:08:25,000
现在问题来了，如何实现这套语言？
Now, how are we going to implement this?

78
00:08:25,000 --> 00:08:27,070
其实并不难
Well, let's do it easily.

79
00:08:27,070 --> 00:08:28,610
首先来看原子元素
Let's look at the primitives.

80
00:08:28,610 --> 00:08:31,160
实现原子元素也是整个问题的根本所在
The only problem is we have to implement the primitives.

81
00:08:31,160 --> 00:08:43,417
至于组合方法与抽象方法完全不用亲自实现，因为语言嵌入在LISP中可以直接使用LISP中的这种机制
Nothing else has to be implemented, because we're picking up the means of combination and abstraction from Lisp, inheriting them in the embedding.

82
00:08:43,417 --> 00:08:45,860
好的，我们先来看一个原子元素
OK, so let's look at a particular primitive.

83
00:08:45,860 --> 00:08:47,400
非门吧
An inverter is a nice one.

84
00:08:51,540 --> 00:08:54,900
非门有两个引脚，一个输入，一个输出
Now, inverter has two wires coming in, an in and an out.

85
00:08:57,440 --> 00:09:04,300
有信号输入的时候它要做点什么
And somehow, it's going to have to know what to do when a signal comes in.

86
00:09:04,300 --> 00:09:20,120
它和输入的电线说 -- 我们开始讨论一些关于对象的东西，细节之处以后再谈 -- 它需要对作为输入的电线的说 “当你的值变的时候，告诉我一声”
So somehow it's going to have to tell its input wire-- and now we're going to talk about objects and we're going to see this in a little more detail soon-- but it's going to have to tell its input wire that when you change, tell me.

87
00:09:20,120 --> 00:09:26,870
所以非门可能会这样和这个输入对象交流， “Hi，我是George”
So this object, the object which is the inverter has to tell the object which is the input wire, hi, my name is George.

88
00:09:26,870 --> 00:09:31,720
“我的工作就是，当你变化的时候对结果做一点修改”
And my, my job is to do something with results when you change.

89
00:09:31,720 --> 00:09:34,730
“所以当你变化的时候，告诉我一声”
So when you change, you get a change, tell me about it.

90
00:09:34,730 --> 00:09:37,010
“因为我需要这个去做点别的”
Because I've got to do something with that.

91
00:09:37,010 --> 00:09:56,130
我们在这里为in添加一个动作invert-in，它在这里定义，是一个无参数的过程，对线路上的信号取反
Well, that's done down here by adding an action on the input wire called invert-in, where invert-in is defined over here to be a procedure of no arguments, which gets the logical not of the signal on the input wire.

92
00:09:56,130 --> 00:10:07,140
在一段延时之后，就是inverter-delay -- 每个电路对象都有延时 -- 我们再把输出设置为新的值
And after some delay, which is the inverter delay, all these electrical objects have delays, we'll do the following thing-- set the signal on the output wire to the new value.

93
00:10:10,160 --> 00:10:12,400
非常简单
A very simple program.

94
00:10:12,400 --> 00:10:23,840
你可以这样理解，这个作为输出的电线很有灵性，当信号改变的时候，它就奔走相告
Now, you have to imagine that the output wire has to be sensitive and know that when its signal changes, it may have to tell other guys, hey, wake up.

95
00:10:23,840 --> 00:10:26,050
“我的值已经改变啦”
My value has changed.

96
00:10:26,050 --> 00:10:36,810
所以当你把非门和与门或者其它的什么连在一起的时候，其中会有很多类似“奔走相告”的过程，确保信号以正确的方式传递
So when you hook together inverter with an and-gate or something like that, there has to be a lot of communication going on in order to make sure that the signal propagates right.

97
00:10:36,810 --> 00:10:38,620
到了这里反而很平常
And down here is nothing very exciting.

98
00:10:38,620 --> 00:10:46,240
logical-not只是把0，1换成1，0罢了
This is just the definition of logical not for some particular representations of the logical values-- 1, 0 in this case.

99
00:10:46,240 --> 00:10:49,780
与门就相对复杂一些
And we can look at things more complicated like and-gates.

100
00:10:49,780 --> 00:10:56,950
与门有两个输入A1，A2，输出是output
And-gates take two inputs, A1 and A2, we'll call them, and produce an output.

101
00:10:56,950 --> 00:11:00,860
但是其结构和非门没有什么大的不同
But the structure of the and-gate is identical to the one we just saw.

102
00:11:00,860 --> 00:11:10,910
当输入信号改变的时候，就执行过程and-action
There's one called an and-action procedure that's defined, which is the thing that gets called when an input is changed.

103
00:11:10,910 --> 00:11:15,900
它所做的只是根据信号逻辑与运算出输出信号而已
And what it does, of course, is nothing more than compute the logical and of the signals on the inputs.

104
00:11:15,900 --> 00:11:25,470
在and-gate-delay的延时之后，更新输出信号值
And after some delay, called the and-gate-delay, calls this procedure, which sets a signal on the output to a new value.

105
00:11:25,470 --> 00:11:28,350
我完全是按愿望思考来完成的这一切
Now, how I implement these things is all wishful thinking.

106
00:11:28,350 --> 00:11:32,020
你看，这里有一个赋值操作
As you see here, I have an assignment operation.

107
00:11:32,020 --> 00:11:34,570
并不是set!
It's not set.

108
00:11:34,570 --> 00:11:46,340
之前我们模仿过CAR，CDR构建新过程，这里也是同理，按照惯例，它的具体实现留作最后的惊喜
It's a derived assignment operation in the same way we had functions that were derived from CAR and CDR. So I, by convention, label that with an exclamation point.

109
00:11:46,340 --> 00:12:03,350
这个过程add-action!，提醒线路A1，当它改变的时候记得执行过程add-action-procedure，A2也是一样
And over here, you see there's an action, which is to inform the wire, called A1 locally in this and-gate, to call the and-action procedure when it gets changed, and the wire A2 to call the and-action procedure when it gets changed.

110
00:12:06,310 --> 00:12:09,510
非常简单
All very simple.

111
00:12:09,510 --> 00:12:18,310
现在我们再来聊聊各个部分之间信息是如何传递的吧
Well, let's talk a little bit about this communication that must occur between these various parts.

112
00:12:18,310 --> 00:12:47,360
假设，有一个非常简单的电路，一个与门，输入a，b，输出端c又作为输入接在非门上，非门的输出是d
Suppose, for example, I have a very simple circuit which contains an and-gate with wires A and B. And that connects through a wire called C to an inverter which has a wire output called D. What are the comput...--here's the physical world.

113
00:12:47,360 --> 00:12:49,860
一个对实际电路的抽象
It's an abstraction of the physical world.

114
00:12:49,860 --> 00:12:54,880
要不了几分钱就可以从Radio Shack买到这些元件
Now I can buy these out of little pieces that you get at Radio Shack for a few cents.

115
00:12:54,880 --> 00:13:01,530
那些元件的作用和画在这里的差不多，不同的是元件上面都标有很多小数字像“LS04”之类的
And there are boxes that act like this, which have little numbers on them like LS04 or something.

116
00:13:01,530 --> 00:13:09,010
现在来看其中的计算模型
Now supposing I were to try to say what's the computational model.

117
00:13:09,010 --> 00:13:15,850
它联系起我们头脑里的现实和在计算机中虚拟的现实，这种联系到底是什么
What is the thing that corresponds to that, that part of reality in the mind of us and in the computer?

118
00:13:15,850 --> 00:13:25,750
真实世界的对象或关系改变了，我就去改变“虚拟”世界中相对应的对象或关系
Well, I have to assign for every object in the world an object in the computer, and for every relationship in the world between them a relationship in the computer.

119
00:13:25,750 --> 00:13:28,560
这是我们的目标
That's my goal.

120
00:13:28,560 --> 00:13:30,900
让我们来看看怎么做
So let's do that.

121
00:13:30,900 --> 00:13:35,401
这一团东西代表信号A
Well, I have some sort of thing called the signal, A.

122
00:13:35,401 --> 00:13:37,940
A，一个信号
This is A. It's a signal.

123
00:13:37,940 --> 00:13:39,900
画的像一团云
It's a cloudy thing like that.

124
00:13:39,900 --> 00:13:49,140
再画另一个信号，B
And I have another one down here which I'm going to call B. It's another signal.

125
00:13:49,140 --> 00:14:00,320
这两个信号将要一起连入一个盒子，一个与门，一个动作过程
Now this signal--these two signals are somehow going to have to hook together into a box, let's call it this, which is the and-gate, action procedure.

126
00:14:00,320 --> 00:14:02,040
这就是与门的动作过程
That's the and-gate's action procedure.

127
00:14:07,660 --> 00:14:30,195
它又联系起另一个信号C，后面的非门连接起来和前面差不多
And it's going to produce--well, it's going to interact with a signal object, which we call C--a wire object, excuse me, we call C. And then the-- this is going to put out again, or connect to, another action procedure which is one associated with the inverter in the world, not.

128
00:14:32,860 --> 00:14:42,970
最后一个信号/电线，D
And I'm going to have another--another wire, which we'll call D.

129
00:14:42,970 --> 00:14:45,770
整体布局就是这样
So here's my layout of stuff.

130
00:14:45,770 --> 00:14:51,500
现在必须来研究它们内部的实际机制了，它们的实际运行过程
Now we have to say what's inside them and what they have to know to compute.

131
00:14:51,500 --> 00:14:57,340
每一个电线都必须知道自己的信号是什么
Well, every--every one of these wires has to know what the value of the signal that's on that wire is.

132
00:14:57,340 --> 00:15:00,680
所以内部一定有些变量来表示信号
So there's going to be some variable inside here, we'll call it signal.

133
00:15:02,670 --> 00:15:05,840
a有一个变量，signal
And he owns a value.

134
00:15:05,840 --> 00:15:08,656
也不要忘了它所关联的环境
So there must be some environment associated with this.

135
00:15:08,656 --> 00:15:11,800
剩下的每一个都和a一样
And for each one of these, there must be an environment that binds signal.

136
00:15:15,400 --> 00:15:16,880
这里也有一个signal变量
And there must be a signal here, therefore.

137
00:15:19,400 --> 00:15:24,170
可以猜出来，signal的值不是0就是1
And presumably, signal's a value that's either 1 or 0, and signal.

138
00:15:28,000 --> 00:15:34,390
还需要一个列表，记录一些“联系人”，当信号实际改变的时候要去通知”他们“
Now, we also have to have some list of people to inform if the signal here changes.

139
00:15:36,660 --> 00:15:39,300
我们得通知这个与门
We're going to have to inform this.

140
00:15:39,300 --> 00:15:44,500
这个列表我们叫它AP(Action Procedures，动作过程)
So I've got that list. We'll call it the Action Procedures, AP.

141
00:15:44,500 --> 00:15:50,500
假定它真的用列表实现，在这里，列表里第一个肯定是这个与门
And it's presumably a list. But the first thing on the list, in this case, is this guy.

142
00:15:50,500 --> 00:15:54,810
b和a一样
And the action procedures of this one happens to have some list of stuff.

143
00:15:54,810 --> 00:15:59,020
也可能有一些其它“人”在时刻等待着A来叫“他们”
There might be other people who are sharing A, who are looking at it.

144
00:15:59,020 --> 00:16:03,630
所以这里可能有其它“人”，具体不知道是谁
So there might be other guys on this list, like somebody over there that we don't know about.

145
00:16:03,630 --> 00:16:07,200
我画在这里
It's the other guy attached to A.

146
00:16:07,200 --> 00:16:13,070
在b内部的AP列表里，肯定也要有这个与门
And the action procedure here also has to point to that, the list of action procedures.

147
00:16:13,070 --> 00:16:18,530
相类似的，这里这样来连接
And of course, that means this one, its action procedures has to point up to here.

148
00:16:18,530 --> 00:16:21,770
这是c要通知的“人”
This is the things-- the people it has to inform.

149
00:16:21,770 --> 00:16:24,280
d也一样
And this guy has some too.

150
00:16:24,280 --> 00:16:27,190
但是我不知道它要通知谁，因为“他们”没有在我的图中出现
But I don't know what they are because I didn't draw it in my diagram.

151
00:16:27,190 --> 00:16:30,320
可能是和D连接起来的其它门吧
It's the things connected to D.

152
00:16:30,320 --> 00:16:52,790
假如与门被“人”通知了 -- 因为"其它人"信号值的变化 -- 与门就得回头去检测自己的输入电路的新值是多少，才能做“与”操作，生成新的输出信号
Now, it's also the case that when the and-action procedure is awakened, saying one of the people who know that you've told--one of the people you've told to wake you up if their signal changes, you have to go look and ask them what's their signal so you can do the and, and produce a signal for this one.

153
00:16:57,090 --> 00:17:06,400
这也即与门的输入，A1是这个a，A2就是b
So there has to be, for example, information here saying A1, my A1 is this guy, and my A2 is this guy.

154
00:17:08,930 --> 00:17:16,170
不只这样，还有点别的
And not only that, when I do my and, I'm going to have to tell this guy something.

155
00:17:16,170 --> 00:17:21,160
还有一个输出
So I need an output--  being this guy.

156
00:17:25,800 --> 00:17:43,520
同样地，非门也有一个输入，它也不时地在关注着信号的变化，当有“人”来通知它“我已经改变了”
And similarly, this guy's going to have a thing called the input that he interrogates to find out what the value of the signal on the input is, when the signal wakes up and says, I've changed, and sends a message this way saying, I've changed.

157
00:17:43,520 --> 00:17:46,900
它就反过来查询这个新的信号值
This guy says, OK, what's your value now?

158
00:17:46,900 --> 00:17:55,860
取到值之后，然后计算输出，改变输出的信号值
When he gets that value, then he's going to have to say, OK, output changes this guy, changes this guy.

159
00:18:00,600 --> 00:18:02,481
等等等等，就像是这样
And so on.

160
00:18:02,481 --> 00:18:06,240
因此我也必须有这么多的连接
And so I have to have at least that much connected-ness.

161
00:18:06,240 --> 00:18:10,260
现在我们回头观察一下，这个与门
Now, let's go back and look, for example, at the and-gate.

162
00:18:10,260 --> 00:18:13,670
这张幻灯片
Here we are back on this slide.

163
00:18:13,670 --> 00:18:16,040
这几个部分的内容
And we can see some of these parts.

164
00:18:16,040 --> 00:18:21,030
对每个与门，都有A1，A2两个输入，一个输出output
For any particular and-gate, there is an A1, there is an A2, and the output.

165
00:18:21,030 --> 00:18:46,240
当and-gate运行的时候，A1 A2 output构成了其运行“环境”，它们有各自的信号值
And those are, those are an environment that was created at the--those produce a frame at the time and-gate was called, a frame where A1, A2, and output are--have as their values, they're bound to the wires which, they are--which were passed in.

166
00:18:46,240 --> 00:18:54,590
在这个环境下，我构建一个新的过程
In that environment, I constructed a procedure-- this one right there.

167
00:18:54,590 --> 00:18:57,780
and-action-procedure
And-action-procedure was constructed in that environment.

168
00:18:57,780 --> 00:19:01,620
过程定义了并没有实际运行
That was the result of evaluating a lambda expression.

169
00:19:01,620 --> 00:19:07,620
当它运行的时候，根据环境模型
So it hangs onto the frame where these were defined.

170
00:19:07,620 --> 00:19:11,700
找到它的局部环境
Local--part of its local state is that.

171
00:19:11,700 --> 00:19:17,310
and-action-procedure就取到了这里的A1 A2 output的值
The and-action-procedure, therefore, has access to A1, A2, and output as we see here.

172
00:19:17,310 --> 00:19:19,645
A1 A2 output
A1, A2, and output.

173
00:19:22,360 --> 00:19:26,030
我们还没有深入探索“电线”的内部结构
Now, we haven't looked inside of a wire yet.

174
00:19:26,030 --> 00:19:29,030
我们来看看
That's all that remains.

175
00:19:29,030 --> 00:19:30,280
来看看“电线”
Let's look at a wire.

176
00:19:33,520 --> 00:19:36,160
非常棒的结构
Like the overhead, very good.

177
00:19:39,500 --> 00:19:43,090
“电线”是有那么一点复杂
Well, the wire, again, is a, is a somewhat complicated mess.

178
00:19:43,090 --> 00:19:46,840
哦，说错了
Ooh, wrong one.

179
00:19:46,840 --> 00:19:49,780
是非常复杂
It's a big complicated mess, like that.

180
00:19:49,780 --> 00:19:54,720
但是还是来看一下，到底是什么
But let's look at it in detail and see what's going on.

181
00:19:54,720 --> 00:19:57,760
“电线”是这上面画的云一样的东西
Well, the wire is one of these.

182
00:19:57,760 --> 00:20:05,010
有两个主要部分，都是它的状态
And it has to have two things that are part of it, that it's state.

183
00:20:05,010 --> 00:20:07,390
其中一个是信号值
One of them is the signal we see here.

184
00:20:07,390 --> 00:20:19,270
换句话说，当我们执行make-wire，首先要做的是新建两个局部变量signal和action-procs
In other words, when we call make-wire to make a wire, then the first thing we do is we create some variables which are the signal and the action procedures for this wire.

185
00:20:22,042 --> 00:20:27,840
在这个上下文中，我们定义了一系列的过程
And in that context, we define various functions--or procedures, excuse me, procedures.

186
00:20:27,840 --> 00:20:32,850
先看(set-my-signal! new)
One of them is called set-my-signal to a new value.

187
00:20:32,850 --> 00:20:37,930
它所做的只是，取一个新值new
And what that does is takes a new value in.

188
00:20:37,930 --> 00:20:40,360
如果new和signal一样，信号没有变化，就没必要做什么了
If that's equal to my current value of my signal, I'm done.

189
00:20:40,360 --> 00:20:54,630
否则，把signal的值赋值为new，再执行action-procs里的所有过程，即通知所有“相关的人”
Otherwise, I set the signal to the new value and call each of the action procedures that I've been, that I've been--what's the right word?--  introduced to.

190
00:20:54,630 --> 00:21:01,530
当作为and-gate的参数的时候，它就是我的“联系人”了，得去通知它
I get introduced when the and-gate was applied to me.

191
00:21:04,130 --> 00:21:07,410
添加“联系人”的这个过程在最下面
I add action procedure at the bottom.

192
00:21:07,410 --> 00:21:27,780
然后，我还得定义一个接受动作过程的过程，就在这里，使用con把新的过程与原来的过程列表连接在一起，再赋值予action-pros，最后还要再运行一次这个过程proc
Also, I have to define a way of accepting an action procedure-- which is what you see here--- which increments my action procedures using set to the result of CONSing up a new process--a procedure, which is passed to me, on to my actions procedures list. And for technical reasons, I have to call that procedure one.

193
00:21:27,780 --> 00:21:36,950
这是一种事件驱动的模拟模型，我还不打算细讲，因为那还需要思考更多的内容
So I'm not going to tell you anything about that, that has to do with event-driven simulations and getting them started, which takes a little bit of thinking.

194
00:21:36,950 --> 00:21:53,820
最后定义一个过程dispatcher，用来解读传递给线路的信息，执行不同的操作，比如这里，当前的信号值是多少？
And finally, I'm going to define a thing called the dispatcher, which is a way of passing a message to a wire, which is going to be used to extract from it various information, like what is the current signal value?

195
00:21:53,820 --> 00:21:57,180
设置新信号值的方法是什么？
What is the method of setting your signal?

196
00:21:57,180 --> 00:22:00,100
我想要这个方法
I want to get that out of it.

197
00:22:00,100 --> 00:22:02,600
我怎么样去添加另外的动作过程呢？
How do I--how do I add another action procedure?

198
00:22:05,510 --> 00:22:09,940
最后，返回过程dispatch
And I'm going to return that dispatch, that procedure as a value.

199
00:22:09,940 --> 00:22:19,790
因此整个电线的被构建成了一个可接受不同信息的对象，比如 ‘add-action!来询问添加动作过程的方法是什么？
So the wire that I've constructed is a message accepting object which accepts a message like, like what's your method of adding action procedures?

200
00:22:19,790 --> 00:22:29,010
因此实际上，它返回了一个过程，这个过程接收一个动作过程作为参数，将其实际添加入电线的action-procs的列表中
In fact, it'll give me a procedure, which is the add action procedure, which I can then apply to an action procedure to create another action procedure in the wire.

201
00:22:31,620 --> 00:22:32,820
这是一种权限
So that's a permission.

202
00:22:32,820 --> 00:22:37,450
给予你了一种去改变自身动作过程列表的权限
So it's given me permission to change your action procedures.

203
00:22:37,450 --> 00:22:41,710
再来看看这里
And in fact, you can see that over here.

204
00:22:41,710 --> 00:22:43,278
下一张幻灯片
Next slide.

205
00:22:43,278 --> 00:22:44,528
噢
Ah.

206
00:22:47,760 --> 00:22:49,120
没什么有意思的
This is nothing very interesting.

207
00:22:49,120 --> 00:22:54,990
(call-each procedures)只是对列表中过程顺序地执行调用，没什么好说的
The call each of the action procedures is just a CDRing down a list. And I'm not going to even talk about that anymore.

208
00:22:54,990 --> 00:22:57,560
我们早就知道了
We're too advanced for that.

209
00:22:57,560 --> 00:23:03,090
然而，如果我想知道线路上的信号值是多少，就得这样来询问wire
However, if I want to get a signal from a wire, I ask the wire-- which is, what is the wire?

210
00:23:03,090 --> 00:23:05,860
wire只是一个dispatch过程而已
The wire is the dispatch returned by creating the wire.

211
00:23:05,860 --> 00:23:06,830
只是一个过程
It's a procedure.

212
00:23:06,830 --> 00:23:12,590
这是是‘get-signal作为参数来执行这个过程
I call that dispatch on the message get-signal.

213
00:23:12,590 --> 00:23:16,900
实际得到的只是取得线路信号值的方法
And what I should expect to get is a method of getting a signal.

214
00:23:16,900 --> 00:23:19,220
进一步的就可以得到信号值
Or actually, I get the signal.

215
00:23:19,220 --> 00:23:38,700
如果我想要对线路设置一个新的信号值，这里传递wire和new-value两个参数，(wire 'set-signal!)取得改变线路信号的权限，实际是一个过程，应用于new-value
If I want to set a signal, I want to change a signal, then what I'm going to do is take a wire as an argument and a new value for the signal, I'm going to ask the wire for permission to set its signal and use that permission, which is a procedure, on the new value.

216
00:23:38,700 --> 00:24:13,010
我们继续追溯这个过程，调用(wire 'set-signal)之后，我们返回这个过程，定义在线路里面，名为set-my-signal，我们回头看幻灯片，返回的过程有一个实际的调用，以new-value为参数，去改变线路内部signal变量的值，最后再去依次通知“联系人”
And if we go back to the overhead here, thank you, if we go back to the overhead here, we see that the method-- if I ask for the method of setting the signal, that's over here, it's set-my-signal, a procedure that's defined inside the wire, which if we look over here is the thing that says set my internal value called the signal, my internal variable, which is the signal, to the new value, which is passed to me as an argument, and then call each of the action procedures waking them up.

217
00:24:16,340 --> 00:24:19,400
非常简单
Very simple.

218
00:24:19,400 --> 00:24:30,100
再来看看幻灯片，还有最后一点，add-action!，我想你们很轻易地就理解了
Going back to that slide, we also have the one last thing-- which I suppose now you can easily work out for yourself-- is the way you add an action.

219
00:24:30,100 --> 00:24:36,470
wire action-proc两个参数
You take a wire--a wire and an action procedure.

220
00:24:36,470 --> 00:24:40,050
然后请求添加动作过程的权限
And I ask the wire for permission to add an action.

221
00:24:40,050 --> 00:24:45,020
得到权限去添加新的动作过程
Getting that permission, I use that permission to give it an action procedure.

222
00:24:45,020 --> 00:24:48,570
这就是整个“电线”对象
So that's a real object.

223
00:24:48,570 --> 00:24:52,460
还有些细节
There's a few more details about this.

224
00:24:52,460 --> 00:24:58,390
比如，我怎么来控制它？
For example, how am I going to control this thing?

225
00:24:58,390 --> 00:25:01,290
这些延时怎么实现？
How do I do these delays?

226
00:25:01,290 --> 00:25:02,540
我们来快速过一遍
Let's look at that for a second.

227
00:25:05,275 --> 00:25:08,360
下一张
The next one here.

228
00:25:08,360 --> 00:25:09,570
我们来看看
Let's see.

229
00:25:09,570 --> 00:25:18,770
我们细看与门或者或门定义，会发现里面还有“延时”这样的东西
We know when we looked at the and-gate or the not-gate that when a signal changed on the input, there was a delay.

230
00:25:18,770 --> 00:25:23,310
一段延时之后才开始执行过程，改变输出
And then it was going to call the procedure, which was going to change the output.

231
00:25:26,040 --> 00:25:28,120
这个要如何实现？
Well, how are we going to do this?

232
00:25:28,120 --> 00:25:34,720
这里引入一种新技巧，非常复杂，我们得非常细心地来看
We're going to make up some mechanism, a fairly complicated mechanism at that, which we're going to have to be very careful about.

233
00:25:34,720 --> 00:25:37,390
在“delay”的延时之后，执行过程action
But after a delay, we're going to do an action.

234
00:25:37,390 --> 00:25:40,590
"delay"是一个数字，"action“是一个过程
A delay is a number, and an action is a procedure.

235
00:25:40,590 --> 00:25:49,510
这里有一个特殊的数据结构the-agenda，用于组织时间与动作过程
What that's going to be is they're going to have a special structure called an agenda, which is a thing that organizes time and actions.

236
00:25:49,510 --> 00:25:50,880
一会儿再来细看它
And we're going to see that in a while.

237
00:25:50,880 --> 00:25:53,070
先把这里说完
I don't want to get into that right now.

238
00:25:53,070 --> 00:25:59,130
the-agenda记录下来一个动作过程未来执行的时间
But the agenda has a moment at which--at which something happens.

239
00:25:59,130 --> 00:26:08,460
在current-time + delay段的时间之后，将会执行那个过程
We're setting up for later at some moment, which is the sum of the time, which is the delay time plus the current time, which the agenda thinks is now.

240
00:26:08,460 --> 00:26:13,090
这个过程随着计算好的这个时刻，添加入the-agenda中
We're going to set up to do this action, and add that to the agenda.

241
00:26:15,280 --> 00:26:18,660
要使这个”计时钟表“运行起来并不困难
And the way this machine will now run is very simple.

242
00:26:18,660 --> 00:26:22,710
下面这个过程progagate，就是来做这件事的
We have a thing called propagate, which is the way things run.

243
00:26:22,710 --> 00:26:27,440
如果the-agenda是空的，就没有要做的
If the agenda is empty, we're done--if there's nothing more to be done.

244
00:26:27,440 --> 00:26:34,200
否则，我们就取出the-agenda的第一个元素，它是一个没有参数的过程
Otherwise, we're going to take the first item off the agenda, and that's a procedure of no arguments.

245
00:26:34,200 --> 00:26:36,030
这里有两层括号
So that we're going to see extra parentheses here.

246
00:26:36,030 --> 00:26:39,190
里面的一层返回一个过程，外面的一层括号执行了这个过程
We call that on no arguments.

247
00:26:39,190 --> 00:26:42,200
就是之前存储入the-agenda的动作
That takes the action.

248
00:26:42,200 --> 00:26:48,395
然后这个过程就可以从the-agenda删掉了，最后执行propagate，进行无限循环
Then we remove that first item from the agenda, and we go around the propagation loop.

249
00:26:48,395 --> 00:26:50,750
这就是整体的结构
So that's the overall structure of this thing.

250
00:26:53,380 --> 00:26:57,430
还有点其它的
Now, there's a, a few other things we can look at.

251
00:26:57,430 --> 00:27:00,410
一会儿再来看the-agenda
And then we're going to look into the agenda a little while from now.

252
00:27:00,410 --> 00:27:02,800
现在整体上来看
Now the overhead again.

253
00:27:02,800 --> 00:27:07,410
说点题外话
Well, in order to set this thing going, I just want to show you some behavior out of this simulator.

254
00:27:07,410 --> 00:27:12,370
这个模拟器其实是非常简单，简单到你认为它根本没什么用
By the way, you may think this simulator is very simple, and probably too simple to be useful.

255
00:27:12,370 --> 00:27:18,680
事实上这样的模拟器曾用来操纵大型机
The fact of the matter is that this simulator has been used to manufacture a fairly large computer.

256
00:27:18,680 --> 00:27:22,360
那是一个真实的案例
So this is a real live example.

257
00:27:22,360 --> 00:27:25,560
实际上这两个模拟器有点不同
Actually, not exactly this simulator, because I'll tell you the difference.

258
00:27:25,560 --> 00:27:29,820
不同之处在于操纵大型机的模拟器有更多的原子结构
The difference is that there were many more different kinds of primitives.

259
00:27:29,820 --> 00:27:33,200
不只是有非门，与门之类的
There's not just the word inverter or and-gate.

260
00:27:33,200 --> 00:27:45,170
还有边缘触发器，触发电路，锁存器，电平触发器，加法器等等之类的
There were things like edge-triggered, flip-flops, and latches, transparent latches, and adders, and things like that.

261
00:27:45,170 --> 00:27:54,690
困难之处在于需要很多页的文档来描述这些原子结构
And the difficulty with that is that there's pages and pages of the definitions of all these primitives with numbers like LS04.

262
00:27:54,690 --> 00:27:56,740
同时它们还有很多的参数
And then there's many more parameters for them.

263
00:27:56,740 --> 00:27:58,480
不是只有一个延时这么简单
It's not just one delay.

264
00:27:58,480 --> 00:28:01,220
还有建立时间，维持时间之类的
There's things like set up times and hold times and all that.

265
00:28:01,220 --> 00:28:15,110
真实计算机的结构确实复杂，但是那么所谓模拟器的部分却和这里我们要讲的很相似
But with the exception of that part of the complexity, the structure of the simulator that we use for building a real computer, that works is exactly what you're seeing here.

266
00:28:15,110 --> 00:28:19,270
回到正题，这些东西都很简单
Well in any case, what we have here is a few simple things.

267
00:28:19,270 --> 00:28:23,030
像这个，设置非门的延时时间，构建一个the-agenda
Like, there's inverter delays being set up and making a new agenda.

268
00:28:23,030 --> 00:28:26,470
这里我们可以用(make-wire)构建更多线路
And then we can make some inputs.

269
00:28:26,470 --> 00:28:29,460
这里只有4个，input-1 input-2 sum carry
There's input-1, input-2, a sum and a carry, which are wires.

270
00:28:29,460 --> 00:28:37,810
过程probe在sum carry对象上放置了一种称为探测器的特殊对象
I'm going to put a special kind of object called a probe onto, onto some of the wires, onto sum and onto carry.

271
00:28:37,810 --> 00:28:46,120
探测器可以在被监测的对象信号改变的时候，输出一条消息
A probe is a, can object that has the property that when you change a wire it's attached to, it types out a message.

272
00:28:46,120 --> 00:28:47,970
这很容易实现
It's an easy thing to do.

273
00:28:47,970 --> 00:28:59,400
这里，我们第一次执行(probe 'sum sum)，它打印出消息说，当前sum在时刻0的信号值是0
And then once we have that, of course, the way you put the probe on, the first thing it does, it says, the current value of the sum at time 0 is 0 because I just noticed it.

274
00:28:59,400 --> 00:29:05,556
carry与sum相同
And the value of the carry at time 0, this is the time, is 0.

275
00:29:05,556 --> 00:29:09,620
我们继续来构建更多结构
And then we go off and we build some structure.

276
00:29:09,620 --> 00:29:18,420
比如这里构建一个半加器
Like, we can build a structure here that says you have a half-adder on input-1, input-2, sum, and carry.

277
00:29:18,420 --> 00:29:20,420
现在把input-1上的信号变为1
And we're going to set the signal on input-1 to 1.

278
00:29:20,420 --> 00:29:21,880
然后开始模拟
We do some propagation.

279
00:29:21,880 --> 00:29:29,520
在时刻8的时候，sum的信号变为1
At time 8, which you could see going through this thing if you wanted to, the new value of sum became 1.

280
00:29:29,520 --> 00:29:31,150
然后没有然后了
And the thing says I'm done.

281
00:29:31,150 --> 00:29:32,630
好像没什么意思
That wasn't very interesting.

282
00:29:32,630 --> 00:29:34,150
我们继续
But we can send it some more signals.

283
00:29:34,150 --> 00:29:36,590
把input-2也变为1
Like, we set-signal on input-2 to be one.

284
00:29:36,590 --> 00:29:45,040
如果再模拟，在时刻11，carry变为1，时刻16，sum变为0
And at that time if we propagate, then it carried at 11, the carry becomes 1, and at 16, the sum's new value becomes 0.

285
00:29:45,040 --> 00:29:48,990
如果你想，你可以实现一个电子电路
And you might want to work out that, if you like, about the digital circuitry.

286
00:29:48,990 --> 00:29:50,620
真的，确实可以
It's true, and it works.

287
00:29:50,620 --> 00:29:51,535
把input-2变为1，整个过程看起来也没什么特别的
And it's not very interesting.

288
00:29:51,535 --> 00:29:54,580
但是却清楚地表明了这一些都是如何运作的
But that's the kind of behavior we get out of this thing.

289
00:30:01,830 --> 00:30:12,952
现在我给你们呈现的是一种宏观的图景，如何去实现事件驱动的模拟
So what I've shown you right now is a large-scale picture, how you, at a bigger, big scale, you implement an event-driven simulation of some sort.

290
00:30:12,952 --> 00:30:21,225
你如何组织出有层次性的结构，构建抽象的盒子
And how you might organize it to have nice hierarchical structure allowing you to build abstract boxes that you can instantiate.

291
00:30:21,225 --> 00:30:25,780
the-agenda忘记说了
But I haven't told you any of the details about how this agenda and things like that work.

292
00:30:25,780 --> 00:30:28,630
下一小节再说
That we'll do next.

293
00:30:28,630 --> 00:30:34,310
这将涉及到一些关于数据变化之类的事情
And that's going to involve change and mutation of data and things like that.

294
00:30:34,310 --> 00:30:35,860
在我继续之前，有什么问题吗？
Are there any questions now, before I go on?

295
00:30:47,160 --> 00:30:47,550
没有的话
Thank you.

296
00:30:47,550 --> 00:30:48,800
休息时间
Let's take a break.

297
00:31:28,940 --> 00:31:35,060
我们已经做了一个模拟器
Well, we've been making a simulation.

298
00:31:35,060 --> 00:31:43,920
这种模拟是事件驱动的，计算机中的对象与现实中的对象一一对应
And the simulation is an event-driven simulation where the objects in the world are the objects in the computer.

299
00:31:43,920 --> 00:32:04,420
现实世界中的时间相对的也由计算机中的时间代替，假如现实中这件事发生在那件事之后，在计算机中也应该是这样，同样的顺序
And the changes of state that are happening in the world in time are organized to be time in the computer, so that if something happens after something else in the world, then we have it happen after, after the corresponding events happen in the same order in the computer.

300
00:32:04,420 --> 00:32:08,220
那也是我们引入赋值的开始
That's where we have assignments, when we make that alignment.

301
00:32:08,220 --> 00:32:16,040
现在我要介绍一种方法来组织时间，用agenda和优先队列来实现
Right now I want to show you a way of organizing time, which is an agenda or priority queue, it's sometimes called.

302
00:32:16,040 --> 00:32:21,230
这样做之前，先来了解点别的
We'll do some--we'll do a little bit of just understanding what are the things we need to be able to do to make agendas.

303
00:32:28,330 --> 00:32:35,960
这里我们先写一些对于agenda的基础操作
And so we're going to have--and so right now over here, I'm going to write down a bunch of primitive operations for manipulating agendas.

304
00:32:35,960 --> 00:32:43,680
具体实现我就不细说了，非常简单而且你们手上也有
I'm not going to show you the code for them because they're all very simple, and you've got listings of all that anyway.

305
00:32:43,680 --> 00:32:44,380
有什么操作呢？
So what do we have?

306
00:32:44,380 --> 00:32:54,130
make-agenda构造一个agenda
We have things like make-agenda which produces a new agenda.

307
00:32:59,860 --> 00:33:12,625
current-time，取得当前的时间，是一个数字
We can ask--we get the current-time of an agenda, which gives me a number, a time.

308
00:33:16,990 --> 00:33:21,900
empty-agenda，判断agenda是否为空
We can get--we can ask whether an agenda is empty, empty-agenda.

309
00:33:30,200 --> 00:33:32,570
返回true或false
And that produces either a true or a false.

310
00:33:42,590 --> 00:33:44,720
也要向agenda添加对象
We can add an object to an agenda.

311
00:33:52,710 --> 00:33:56,910
现实上这里添加的对象是一个过程，一个动作过程
Actually, what we add to an agenda is an operation--an action to be done.

312
00:33:56,910 --> 00:34:04,810
一共3个参数，时间time，动作过程action，要添加入的agenda
And that takes a time, the action itself, and the agenda I want to add it to.

313
00:34:07,850 --> 00:34:10,719
把action放入agenda合适的地方
That inserts it in the appropriate place in the agenda.

314
00:34:10,719 --> 00:34:23,259
(FIRST-ITEM agenda)用于取出agenda中第一个item
I can get the first item off an agenda, the first thing I have to do, which is going to give me an action.

315
00:34:26,085 --> 00:34:29,540
还可以把第一个item从中删除
And I can remove the first item from an agenda.

316
00:34:29,540 --> 00:34:31,409
这些就是对agenda的全部基础操作
That's what I have to be able to do with agendas.

317
00:34:31,409 --> 00:34:33,020
杂乱不甚
That is a big complicated mess.

318
00:34:42,530 --> 00:34:43,780
从agenda删除
From an agenda.

319
00:34:45,530 --> 00:34:52,528
现在我们来看如何具体组织数据结构
Well, let's see how we can organize this thing as a data structure a bit.

320
00:34:52,528 --> 00:35:01,570
agenda应该是一个列表，一个可修改的列表
Well, an agenda is going to be some kind of list. And it's going to be a list that I'm going to have to be able to modify.

321
00:35:01,570 --> 00:35:11,070
因为我们要向其中添加，删除，所以列表必定是可被修改的
So we have to talk about modifying of lists, because I'm going to add things to it, and delete things from it, and things like that.

322
00:35:11,070 --> 00:35:13,820
它依时间来组织
It's organized by time.

323
00:35:13,820 --> 00:35:15,570
以某种顺序排序起来也是有益的
It's probably good to keep it in sorted order.

324
00:35:18,330 --> 00:35:23,420
但是也有可能同一时间会发生很多事，需要执行很多过程
But sometimes there are lots of things that happen at the same time--approximate same time.

325
00:35:23,420 --> 00:35:29,040
我们把将要发生的事，要执行的过程按时间顺序来组织
What I have to do is say, group things by the time at which they're supposed to happen.

326
00:35:29,040 --> 00:35:32,780
所以agenda看起来就像是很多segment组成的列表
So I'm going to make an agenda as a list of segments.

327
00:35:32,780 --> 00:35:39,620
我来画一下这个结构，好让人理解
And so I'm going to draw you a data structure for an agenda, a perfectly reasonable one.

328
00:35:39,620 --> 00:35:41,110
这是一个agenda
Here's an agenda.

329
00:35:41,110 --> 00:35:42,870
以一个名字开始
It's a thing that begins with a name.

330
00:35:47,630 --> 00:35:49,940
在画具体的表结构之前先画它
I'm going to do it right now out of list structure.

331
00:35:52,620 --> 00:35:53,980
作为一个头部
It's got a header.

332
00:35:53,980 --> 00:35:55,840
这个头部的存在也是很必要的
There's a reason for the header.

333
00:35:55,840 --> 00:35:57,630
待会你就会知道
We're going to see the reason soon.

334
00:36:00,680 --> 00:36:03,750
再画一个segment
And it will have a segment.

335
00:36:03,750 --> 00:36:05,620
这将是许多segment组成的列表
It will have--it will be a list of segments.

336
00:36:08,310 --> 00:36:33,320
假设现在有两个segment，这样连接在一起-- 连接使用CAR就可访问到 -- 每个segment都要有一个时间，代表动作过程要执行的时间，比如这个就是10
Supposing this agenda has two segments, they're the car's-- successive car's of this list. Each segment is going to have a time--  say for example, 10-- that says that the things that happen in this segment are at time 10.

337
00:36:33,320 --> 00:36:42,240
这里还要有另一个数据结构，先不具体描述，代表在时刻10将要做的事
And what I'm going to have in here is another data structure which I'm not going to describe, which is a queue of things to do at time 10.

338
00:36:42,240 --> 00:36:43,330
一个队列
It's a queue.

339
00:36:43,330 --> 00:36:45,130
一会儿再细说
And we'll talk about that in a second.

340
00:36:45,130 --> 00:36:50,200
抽象来看，队列就是一系列在一个固定时间要做的事情的集合
But abstractly, the queue is just a list of things to do at a particular time.

341
00:36:50,200 --> 00:36:53,100
我可以向其中添加其它要做的事
And I can add things to a queue.

342
00:36:53,100 --> 00:36:56,140
一个队列
This is a queue.

343
00:36:56,140 --> 00:36:59,115
一个时刻，两者就是segment的主要元素
There's a time, there's a segment.

344
00:37:02,889 --> 00:37:06,035
这里还有一个segment
Now, I may have another segment in this agenda.

345
00:37:08,940 --> 00:37:13,410
假设其时刻是30
Supposing this is stuff that happens at time 30.

346
00:37:13,410 --> 00:37:23,210
类似的，这里也要有一个队列，记录这一时刻将发生的事
It has, of course, another queue of things that are queued up to be done at time 30.

347
00:37:23,210 --> 00:37:27,090
现在我们来看看，对agenda的一系列操作
Well, there are various things I have to be able to do to an agenda.

348
00:37:27,090 --> 00:37:33,030
假设我想在时刻10，想做新的事情
Supposing I want to add to an agenda another thing to be done at time 10.

349
00:37:33,030 --> 00:37:34,700
这并不难
Well, that's not very hard.

350
00:37:34,700 --> 00:37:39,730
我只需要沿着这下来，找到时刻是10的segment
I'm going to walk down here, looking for the segment of time 10.

351
00:37:39,730 --> 00:37:42,930
也可能这样的一个segment并不存在
It is possible that there is no segment of time 10.

352
00:37:42,930 --> 00:37:45,420
一会儿再谈这种情况
We'll cover that case in a second.

353
00:37:45,420 --> 00:37:56,290
如果我找到了这样一个segment，就把这件事放入队列中 -- 尽管要怎样加入队列并不明显
But if I find a segment of time 10, then if I want to add another thing to be done at time 10, I just increase that queue-- "just increase" isn't such an obvious idea.

354
00:37:56,290 --> 00:38:01,430
但是那时我就得这样做
But I increase the things to be done at that time.

355
00:38:01,430 --> 00:38:05,140
现在，假设我想在时刻20做点什么
Now, supposing I want to add something to be done at time 20.

356
00:38:05,140 --> 00:38:08,680
然而并没有时刻是20的segment
There is no segment for time 20.

357
00:38:08,680 --> 00:38:11,340
我不得不构造一个segment
I'm going to have to create a new segment.

358
00:38:11,340 --> 00:38:17,610
我想把这个segment放在10与30之间
I want my time 20 segment to exist between time 10 and time 30.

359
00:38:17,610 --> 00:38:20,170
这着实要花点功夫
Well, that takes a little work.

360
00:38:20,170 --> 00:38:21,525
先用CONS
I'm going to have to do a CONS.

361
00:38:24,260 --> 00:38:29,940
构建一个新的segment
I'm going to have to make a new element of the agenda list--list of segments.

362
00:38:33,600 --> 00:38:35,400
这里的连接必须要变
I'm going to have to change.

363
00:38:35,400 --> 00:38:37,540
就像这样
Here's change.

364
00:38:37,540 --> 00:38:56,657
把segment 10的CDR指向新的segment 20，新的segment 20的CDR指向segment 30
I'm going to have to change the CDR of the CDR of the agenda to point that a new CONS of the new segment and the CDR of the CDR of the CDR of the agenda, the CD-D-D-DR.

365
00:38:56,657 --> 00:39:06,290
这个segment的时刻为20，队列只有一件事要做
And this is going to have a new segment now of time 20 with its own queue, which now has one element in it.

366
00:39:10,730 --> 00:39:20,770
如果我想在后面添加点什么，就更改这个CDR指向要添加的东西
If I wanted to add something at the end, I'm going to have to replace the CDR of this, of this list with something.

367
00:39:20,770 --> 00:39:24,040
必须对数据结构进行修改
We're going to have to change that piece of data structure.

368
00:39:24,040 --> 00:39:27,210
因此我需要新的基础操作
So I'm going to need new primitives for doing this.

369
00:39:27,210 --> 00:39:29,550
因为原有的基础操作达不到这一点
But I'm just showing you why I need them.

370
00:39:29,550 --> 00:39:49,400
如果我想在时刻5做点什么事，按时间顺序来看，就得改变这里的CDR，这也就是我留了一个“头”的原因，可以方便的进行在队列头插入的操作
And finally, if I wanted to add a thing to be done at time 5, I'm going to have to change this one, because I'm going to have to add it in over here, which is why I planned ahead and had a header cell, which has a place.

371
00:39:49,400 --> 00:39:53,420
如果我想做些改变
If I'm going to change things, I have to have places for the change.

372
00:39:53,420 --> 00:39:58,600
就必须找准哪些地方需要修改
I have to have a place to make the change.

373
00:39:58,600 --> 00:40:02,540
从agenda中删除东西并不困难
If I remove things from the agenda, that's not so hard.

374
00:40:02,540 --> 00:40:11,220
删除操作非常简单，我只讲一种情况，先找到第一个segment
Removing them from the beginning is pretty easy, which is the only case I have. I can go looking for the first, the first segment.

375
00:40:11,220 --> 00:40:14,510
判断队列是否为空
I see if it has a non-empty queue.

376
00:40:14,510 --> 00:40:20,100
如果队列不是空的，就把要移除的事情从队列中删掉
If it has a non-empty queue, well, I'm going to delete one element from the queue, like that.

377
00:40:20,100 --> 00:40:24,220
如果这时队列变为空的，就还要继续把segment删掉
If the queue ever becomes empty, then I have to delete the whole segment.

378
00:40:24,220 --> 00:40:28,220
这里，把“头”的CDR指向这里
And then this, this changes to point to here.

379
00:40:28,220 --> 00:40:36,440
这个数据结构操作起来很复杂，很无趣
So it's quite a complicated data structure manipulation going on, the details of which are not really very exciting.

380
00:40:36,440 --> 00:40:38,920
现在我们来聊聊队列
Now, let's talk about queues.

381
00:40:38,920 --> 00:40:41,160
它们很相似
They're similar.

382
00:40:41,160 --> 00:40:44,340
每一个segment都有一个队列
Because each of these agendas has a queue in it.

383
00:40:44,340 --> 00:40:45,590
队列是什么？
What's a queue?

384
00:40:49,079 --> 00:40:52,350
一个队列有这些基础操作
A queue is going to have the following primitive operations.

385
00:40:52,350 --> 00:41:02,170
MAKE-QUEUE 构建一个新队列
To make a queue, this gives me a new queue.

386
00:41:07,274 --> 00:41:16,850
INSERT-QUEUE！ 向队列中插入新元素
I'm going to have to be able to insert into a queue a new item.

387
00:41:24,510 --> 00:41:28,740
DELETE-QUEUE！ 从队列中删除元素
I'm going to have to be able to delete from a queue the first item in the queue.

388
00:41:39,988 --> 00:41:52,890
FRONT-QUEUE 查看队列中第一个元素
And I want to be able to get the first thing in the queue from some queue.

389
00:41:52,890 --> 00:41:55,140
还需要检测队列是否为空
I also have to be able to test whether a queue is empty.

390
00:42:07,110 --> 00:42:15,120
如果你以后要发明些类似的基础操作，我希望你要注意下命名约定
And when you invent things like this, I want you to be very careful to use the kinds of conventions I use for naming things.

391
00:42:15,120 --> 00:42:19,870
有改动的操作加上！，判断的谓词用？
Notice that I'm careful to say these change something and that tests it.

392
00:42:19,870 --> 00:42:24,335
看起来，和这边的好像差不多
And presumably, I did the same thing over here.

393
00:42:24,335 --> 00:42:29,240
嗯，这里也需要一个是否为空的检测
OK, and there should be an empty test over here.

394
00:42:29,240 --> 00:42:31,720
好的，我要如何构建一个队列呢？
OK, well, how would I make a queue?

395
00:42:31,720 --> 00:42:37,840
队列是一个后进先出的结构
A queue wants to be something I can add to at the end of, and pick up the thing at the beginning of.

396
00:42:37,840 --> 00:42:41,230
从队列头删除元素，向队列尾添加元素
I should be able to delete from the beginning and add to the end.

397
00:42:41,230 --> 00:42:43,740
我可以用一种很简单的结构来实现
Well, I'm going to show you a very simple structure for that.

398
00:42:43,740 --> 00:42:47,080
先有一个序对
We can make this out of CONSes as well.

399
00:42:47,080 --> 00:42:49,910
整个队列的开始
Here's a queue.

400
00:42:49,910 --> 00:42:59,610
这是一个队列“头”，包含一个头指针和一个尾指针
It has--it has a queue header, which contains two parts-- a front pointer and a rear pointer.

401
00:43:02,930 --> 00:43:09,000
假如队列一共两个元素
And here I have a queue with two items in it.

402
00:43:09,000 --> 00:43:12,095
第一个，值假定是1
The first item, I don't know, it's perhaps a 1.

403
00:43:12,095 --> 00:43:16,530
第二个假定是2吧
And the second item, I don't know, let's give it a 2.

404
00:43:21,160 --> 00:43:31,850
需要两个指针的原因在于，向尾部添加元素的时候，就不用一直CDR找到结尾这样费力
The reason why I want two pointers in here, a front pointer and a rear pointer, is so I can add to the end without having to chase down from the beginning.

405
00:43:31,850 --> 00:43:47,530
例如，我想要向队列添加入一个新元素，只需要先用CONS构建一个序对，假如值是3
So for example, if I wanted to add one more item to this queue, if I want to add on another item to be worried about later, all I have to do is make a CONS, which contains that item, say a 3.

406
00:43:47,530 --> 00:43:51,340
再添加到队列里
That's for inserting 3 into the queue.

407
00:43:51,340 --> 00:44:00,100
这里就需要把item 2的CDR指向item 3
Then I have to change this pointer here to here.

408
00:44:00,100 --> 00:44:04,320
尾指针也指到最后
And I have to change this one to point to the new rear.

409
00:44:09,120 --> 00:44:18,890
如果我想查看第一个元素，由头指针就可以轻易找到
If I wish to take the first element of the queue, the first item, I just go chasing down the front pointer until I find the first one and pick it up.

410
00:44:18,890 --> 00:44:27,450
如果想删除元素，只需要把头指针向后移到就行
If I wish to delete the first item from the queue, delete-queue, all I do is move the front pointer along this way.

411
00:44:27,450 --> 00:44:31,700
新的头指针指向这里
The new front of the queue is now this.

412
00:44:31,700 --> 00:44:34,390
所以队列比较简单
So queues are very simple too.

413
00:44:34,390 --> 00:44:41,350
我们需要一些另外的基础操作来支持这种修改操作
So what you see now is that I need a certain number of new primitive operations.

414
00:44:41,350 --> 00:44:42,560
我先列出它们的名字
And I'm going to give them some names.

415
00:44:42,560 --> 00:44:47,350
然后我们再来看它们是如何使用的
And then we're going to look into how they work, and how they're used.

416
00:44:47,350 --> 00:44:58,940
SET-CAR！ 改变一个序对的CAR为一个新值
We have set the CAR of some pair, or a thing produced by CONSing, to a new value.

417
00:45:02,370 --> 00:45:09,920
SET-CDR！和它类似
And set the CDR of a pair to a new value.

418
00:45:12,680 --> 00:45:16,030
现在来看看它们到底做了什么
And then we're going to look into how they work.

419
00:45:16,030 --> 00:45:20,960
我用SET-CAR！修改头指针的指向，删除第一个元素
I needed setting CAR over here to delete the first element of the queue.

420
00:45:20,960 --> 00:45:23,470
这是CAR，我把它SET为另的值
This is the CAR, and I had to set it.

421
00:45:23,470 --> 00:45:30,160
同理SET-CDR！修改尾指针的指向来添加元素
I had to be able to set the CDR to be able to move the rear pointer, or to be able to increment the queue here.

422
00:45:30,160 --> 00:45:35,515
全部的修改工作都是由SET-CAR！ SET-CDR！完成的
All of the operations I did were made out of those that I just showed you on the, on the last blackboard.

423
00:45:38,230 --> 00:45:38,430
非常完美
Good.

424
00:45:38,430 --> 00:45:40,357
先讲到这里，大家休息一下
Let's pause the time, and take a little break then.

425
00:46:38,346 --> 00:47:21,850
当我们讲到CONS的时候，我们提到了CONS的原则，(car (cons x y)) => x，(cdr (cons x y )) => y
When we originally introduced pairs made out of CONS, made by CONS, we only said a few axioms about them, which were of the form-- what were they-- for all X and Y, the CAR of the CONS of X and Y is X and the CDR of the CONS of X and Y is Y. Now, these say nothing about whether a CONS has an identity like a person.

426
00:47:21,850 --> 00:47:29,740
这个描述的有点抽象，CONS是由它组成的部分所组成的
In fact, all they say is something sort of abstract, that a CONS is the parts it's made out of.

427
00:47:29,740 --> 00:47:37,390
要是这样来看，如果两个CONS，它们两个的组成部分是相同的，从原则来看，这两个CONS就应该相同
And of course, two things are made out of the same parts, they're the same, at least from the point of view of these axioms.

428
00:47:37,390 --> 00:47:49,830
但是引入了赋值以后，数据变成了变量，值可以通过赋值来改变，比如用SET-CAR！ SET-CDR！，这样来看，这些原则好像没有把CONS描述清楚
But by introducing assignment-- in fact, mutable data is a kind of assignment, we have a set CAR and a set CDR-- by introducing those, these axioms no longer tell the whole story.

429
00:47:49,830 --> 00:47:53,250
但是这里写的也是对的
And they're still true if written exactly like this.

430
00:47:53,250 --> 00:47:56,070
只不过描述的不再完整
But they don't tell the whole story.

431
00:47:56,070 --> 00:48:10,090
如果我用SET-CAR！ SET-CDR！改变两个CONS，使它们的CAR和CDR都相同，这两个CONS是否是完全相同的？
Because if I'm going to set a particular CAR in a particular CONS, the questions are, well, is that setting all CARs and all CONSes of the same two things or not?

432
00:48:10,090 --> 00:48:21,570
假如我用CONS构建两个有理数，两个3/4
If I--if we use CONSes to make up things like rational numbers, or things like 3 over 4, supposing I had two three-fourths.

433
00:48:21,570 --> 00:48:25,340
这两个一样吗？还是不一样？
Are they the same one-- or are they different?

434
00:48:25,340 --> 00:48:27,860
当然，对于数字来说，这并不重要
Well, in the case of numbers, it doesn't matter.

435
00:48:27,860 --> 00:48:33,020
因为这两个有理数表示的大小是一样的，都是3/4
Because there's no meaning to changing the denominator of a number.

436
00:48:33,020 --> 00:48:36,840
你可以改变一个有理数的分母来使它们变的不一样
What you could do is make a number which has a different denominator.

437
00:48:36,840 --> 00:48:44,770
但是这看来很怪异，强制的改变分母使其两个有理数有区别，这也和数学上认知不符合
But the concept of changing a number which has to have a different denominator is sort of a very weird, and sort of not supported by what you think of as mathematics.

438
00:48:44,770 --> 00:48:53,690
但是，如果CONS表示的是现实世界中的物体，修改CAR就像剪掉你的指甲一样，是切实存在的
However, when these CONSes represent things in the physical world, then changing something like the CAR is like removing a piece of the fingernail.

439
00:48:53,690 --> 00:48:57,770
所以，每一个CONS都是不同的，它们有自己的身份
And so CONSes have an identity.

440
00:48:57,770 --> 00:49:01,280
我来先说明“身份”是什么意思
Let me show you what I mean about identity, first of all.

441
00:49:01,280 --> 00:49:04,320
来看些例子
Let's do some little example here.

442
00:49:04,320 --> 00:49:15,200
假如(define a (cons 1 2))
Supposing I define A to the CONS of 1 and 2.

443
00:49:18,040 --> 00:49:38,120
这是什么意思呢？在环境中的某处有一个符号a，它代表了一个序对，CAR指向1，CDR指向2
Well, what that means, first of all, is that somewhere in some environment I've made a symbol A to have a value which is a pair consisting of pointers to a 1 and a pointer to a 2, just like that.

444
00:49:38,120 --> 00:50:03,970
假设再定义一个b，(define b (cons a a))
Now, supposing I also say define B to be the CONS--  it doesn't matter, but I like it better, it's prettier-- of A and A.

445
00:50:03,970 --> 00:50:07,840
这里用了两次a
Well, first of all, I'm using the name A twice.

446
00:50:07,840 --> 00:50:11,300
现在就要考虑序对的身份问题了
At this moment, I'm going to think of CONSes as having identity.

447
00:50:11,300 --> 00:50:13,690
这两个a是一样的，是同一个东西
This is the same one.

448
00:50:13,690 --> 00:50:33,260
所以b是这样的一个序对，CAR与CDR都指向a，对于a来说，有三个别名都代表着它
And so what that means is I make another pair, which I'm going to call B. And it contains two pointers to A. At this point, I have three names for this object.

449
00:50:33,260 --> 00:50:34,790
a是一个
A is its name.

450
00:50:34,790 --> 00:50:37,230
(car b)是一个
The CAR of B is its name.

451
00:50:37,230 --> 00:50:39,360
(cdr b)也是一个
And the CDR of B is its name.

452
00:50:39,360 --> 00:50:41,150
都是这个序对的别名
It has several aliases, they're called.

453
00:50:44,230 --> 00:51:07,880
假设现在执行 (SET-CAR! (CAR B) 3)
Now, supposing I do something like set-the-CAR, the CAR of the CAR of B to 3.

454
00:51:12,750 --> 00:51:17,830
找到b的CAR
What that means is I find the CAR of B, that's this.

455
00:51:17,830 --> 00:51:20,935
把它的CAR设置为3
I set the CAR of that to be 3, changing this.

456
00:51:24,760 --> 00:51:35,340
这样我也就修改了a，现在调用(CAR A)来看一下结果
I've changed A. If I were to ask what's the CAR of A--of A now?

457
00:51:35,340 --> 00:51:45,290
结果是3，尽管上面定义a是(cons 1 2)
I would get out 3, even though here we see that A was the CONS of 1 and 2.

458
00:51:45,290 --> 00:51:48,400
我通过改变b而改变了a
I caused A to change by changing B.

459
00:51:48,400 --> 00:51:52,010
它们共享着一处数据
There is sharing here.

460
00:51:52,010 --> 00:51:54,240
有时候我们需要这样的结构
That's sometimes what we want.

461
00:51:54,240 --> 00:52:04,350
我们之前的队列，就是这样来组织的
Surely in the queues and things like that, that's exactly what we defined our--organized our data structures to facilitate-- sharing.

462
00:52:04,350 --> 00:52:25,190
但是对象之间不合理的共享与操作，是很多复杂系统中bug的来源。所以我们虽然使对象具有身份，可以用很多别名来共享，得到了不少的好处
But inadvertent sharing, unanticipated interactions between objects, is the source of most of the bugs that occur in complicated programs. So by introducing this possibility of things having identity and sharing and having multiple names for the same thing, we get a lot of power.

463
00:52:25,190 --> 00:52:28,640
但是同时也为此引出的bug而付出代价
But we're going to pay for it with lots of complexity and bugs.

464
00:52:32,190 --> 00:52:46,560
还看这里的这个例子，(CADR B)，看起来和(CAR B)没有一点关系
So also, for example, if I just looked at this just to drive that home, the CADR of B, which has nothing to do with even the CAR of B, apparently.

465
00:52:46,560 --> 00:52:49,350
但是它的值是什么？
The CADR of B, what's that?

466
00:52:49,350 --> 00:52:53,560
来找一下
Take that CDR of B and now take the CAR of that.

467
00:52:53,560 --> 00:52:56,480
哦，还是3
Oh, that's 3 also.

468
00:52:56,480 --> 00:53:01,120
有了共享这样的机制，局部的含义也不是那么清楚了
So I can have non-local interactions by sharing.

469
00:53:01,120 --> 00:53:02,480
所以我们要非常小心的操作
And I have to be very careful of that.

470
00:53:06,640 --> 00:53:22,820
目前为止，我已经介绍了SET！ SET-CAR！ SET-CDR！这些赋值操作，或许我应该不用SET-CAR！ SET-CDR！，它们引入太多问题了
Well, so far, of course, it seems I've introduced several different assignment operators-- set, set CAR, set CDR. Well, maybe I should just get rid of set CAR and set CDR. Maybe they're not worthwhile.

471
00:53:22,820 --> 00:53:27,170
不幸的是，一旦你让骆驼的鼻子进了帐篷，相当于你把它放进了帐篷
Well, the answer is that once you let the camel's nose into the tent, the rest of him follows.

472
00:53:30,160 --> 00:53:35,850
我想说的是，只要有set！，这一切不幸的都可能会发生
All I have to have is set, and I can make all of the--all of the bad things that can happen.

473
00:53:38,550 --> 00:53:40,690
我们来分析一下
Let's play with that a little bit.

474
00:53:40,690 --> 00:53:52,480
前些日子讲到复合数据的时候，哈罗德教授向你们展示了用消息接收的方式来定义CONS
A couple of days ago, when we introduced compound data, you saw Hal show you a definition of CONS in terms of a message acceptor.

475
00:53:52,480 --> 00:54:04,440
现在我要用一种更为恐怖的方式来定义CONS
I'm going to show you even a more horrible thing, a definition of CONS in terms of nothing but air, hot air.

476
00:54:04,440 --> 00:54:14,580
过去的那个CONS是怎么定义的来着？一个lambda表达式，一个过程？
What is the definition of CONS, of the old functional kind, in terms of purely lambdic expressions, procedures?

477
00:54:17,190 --> 00:54:28,580
我们这里对CONS的修改是要达到这样的效果，用SET！来代替SET-CAR！ SET-CDR！
Because I'm going to then modify this definition to get assignment to be only one kind of assignment, to get rid of the set CAR and set CDR in terms of set.

478
00:54:28,580 --> 00:54:46,320
这里我定义CONS为一个接受一个参数M的过程，M作用于X与Y
So what if I define CONS of X and Y to be a procedure of one argument called a message M, which calls that message on X and Y?

479
00:54:51,120 --> 00:54:57,870
这是阿隆佐·丘奇发明的方法，他是20世纪最伟大的程序员之一，尽管当时电脑还没有被发明
This [? idea ?] was invented by Alonzo Church, who was the greatest programmer of the 20th century, although he never saw a computer.

480
00:54:57,870 --> 00:54:59,130
那时20世纪30年代的事了
It was done in the 1930s.

481
00:54:59,130 --> 00:55:02,220
他是一个逻辑学家，当时应该是在普林斯顿
He was a logician, I suppose at Princeton at the time.

482
00:55:08,660 --> 00:55:46,670
(DEFINE (CAR X) (X (lambda(A D) A))) (DEFINE (CDR X) (X (lambda(A D) D)))
Define CAR of X to be the result of applying X to that procedure of two arguments, A and D, which selects A. I will define CDR of X to be that procedure, to be the result of applying X to that procedure of A and D, which selects D.

483
00:55:46,670 --> 00:55:50,510
这就是CONS CAR CDR
Now, you may not recognize this as CAR, CDR, and CONS.

484
00:55:50,510 --> 00:55:55,210
我来举例看一下，它是否符合之前所说的CONS的原则
But I'm going to demonstrate to you that it satisfies the original axioms, just once.

485
00:55:55,210 --> 00:55:58,290
简单来看
And then we're going to do some playing of games.

486
00:55:58,290 --> 00:56:09,695
(CAR (CONS 35 47))
Consider the problem CAR of CONS of, say, 35 and 47.

487
00:56:09,695 --> 00:56:11,120
这是什么呢？
Well, what is that?

488
00:56:11,120 --> 00:56:19,710
用代换模型，把CONS换成这边定义的
It is the result of taking car of the result of substituting 35 and 47 for X and Y in the body of this.

489
00:56:19,710 --> 00:56:20,690
非常容易
Well, that's easy enough.

490
00:56:20,690 --> 00:56:35,750
就是(CAR (lambda (M) (M 35 47)))
That's CAR of the result of substituting into lambda of M, M of 35 and 47.

491
00:56:35,750 --> 00:56:42,830
再来代换CAR
Well, what this is, is the result of substituting this object for X in the body of that.

492
00:56:42,830 --> 00:57:15,840
((lambda (M) (M 35 47)) (lambda (A D) A))
So that's just lambda of M-- that's substituted, because this object is being substituted for X, which is the beginning of a list, lambda of M-- M of 35 and 47, applied to that procedure of A and D, which gives me A. Well, that's the result of substituting this for M here.

493
00:57:15,840 --> 00:57:26,026
继续代换，((lambda (A D) A) 35 47)
So that's the same thing as lambda of A, D, A, applied to 35 and 47.

494
00:57:26,026 --> 00:57:27,560
结果就是35
Oh, well that's 35.

495
00:57:27,560 --> 00:57:40,720
35对应A，47对应的是D。在这种定义里，我什么数据都不需要，甚至连数字都没有
That's substituting 35 for A and for 47 for D in A. So I don't need any data at all, not even numbers.

496
00:57:40,720 --> 00:57:42,640
太佩服丘奇了
This is Alonso Church's hack.

497
00:57:52,420 --> 00:57:56,760
现在呢我们来对这个定义做点修改
Well, now we're going to do something nasty to him.

498
00:57:56,760 --> 00:57:58,860
作为逻辑学家，他可能会不太开心
Being a logician, he wouldn't like this.

499
00:57:58,860 --> 00:58:03,260
但是作为程序员，应该没什么
But as programmers, let's look at the overhead.

500
00:58:03,260 --> 00:58:05,390
我们来看看
And here we go.

501
00:58:05,390 --> 00:58:09,570
修改CONS的定义
I'm going to change the definition of CONS.

502
00:58:09,570 --> 00:58:14,520
和丘奇的定义很相似，但是不完全相同
It's almost the same as Alonzo Church's, but not quite.

503
00:58:14,520 --> 00:58:16,070
具体到底是什么？
What do we have here?

504
00:58:16,070 --> 00:58:40,940
CONS定义为一个过程，这个过程需要一个参数M，但是M作用于4个参数，X，Y 和两个lambda过程
The CONS of two arguments, X and Y, is going to be that procedure of one argument M, which supplies M to X and Y as before, but also to two permissions, the permission to set X to N and the permission to set Y to N, given that I have an N.

505
00:58:40,940 --> 00:59:03,365
所以这里的不同之处在于，M除了应用于x y之外，还应用于两个过程，分别用于修改x与y的值
So besides the things that I had here in Church's definition, what I have is that the thing that CONS returns will apply its argument to not just the values of the X and Y that the CONS is made of, but also permissions to set X and Y to new values.

506
00:59:06,540 --> 00:59:11,690
类似之前，CAR看起来也很相似
Now, of course, just as before, CAR is exactly the same.

507
00:59:11,690 --> 00:59:22,550
(CAR X)也就只是从4个参数里挑出第一个而已
The CAR of X is nothing more than applying X, as in Church's definition, to a procedure, in this case, of four arguments, which selects out the first one.

508
00:59:22,550 --> 00:59:37,920
和之前一样，返回的将会是这个过程中的x
And just as we did before, that will be the value of X that was contained in the procedure which is the result of evaluating this lambda expression in the environment where X and Y are defined over here.

509
00:59:41,940 --> 00:59:45,640
这个过程的整体就是CONS
That's the value of CONS.

510
00:59:45,640 --> 00:59:47,730
接着，最为精彩的一段
Now, however, the exciting part.

511
00:59:47,730 --> 00:59:48,960
CDR，和CAR一样的
CDR, of course, is the same.

512
00:59:48,960 --> 00:59:55,800
SET-CAR！ SET-CDR！的实现着实让人眼前一亮，其实它们也并不复杂
The exciting part, set CAR and set CDR. Well, they're nothing very complicated anymore.

513
00:59:55,800 --> 01:00:26,150
(SET-CAR! X Y)无非就是用一个取到4个参数中第3个参数的过程，去代换实际定义的CONS，取得修改其中X的权限，把其修改为新的值Y
Set CAR of a CONS X to a new value Y is nothing more than applying that CONS, which is the procedure of four--the procedure of one argument which applies its argument to four things, to a procedure which is of four arguments-- the value of X, the value of Y, permission to set X, the permission to set Y-- and using it--using that permission to set X to the new value.

514
01:00:31,650 --> 01:00:33,540
SET-CDR！和它是类似的
And similarly, set-cdr is the same thing.

515
01:00:36,120 --> 01:00:40,470
你也看到了，这里并没有引入新的其它基础操作
So what you've just seen is that I didn't introduce any new primitives at all.

516
01:00:40,470 --> 01:00:45,340
具体要不要这样来实现是一个工程性问题
Whether or not I want to implement it this way is a matter of engineering.

517
01:00:45,340 --> 01:00:51,680
实际上出于一些原因，工程上并不这样来实现
And the answer is of course I don't implement it this way for reasons that have to do with engineering.

518
01:00:51,680 --> 01:00:58,765
原理上逻辑上就是这样，一旦引入了赋值，便可以修改任意的东西
However in principle, logically, once I introduced one assignment operator, I've assigned--I've introduced them all.

519
01:01:05,420 --> 01:01:06,670
有什么问题吗？
Are there any questions?

520
01:01:09,200 --> 01:01:12,040
好的，David
Yes, David.

521
01:01:12,040 --> 01:01:15,740
我可以跟的上你的思路，直到
AUDIENCE: I can follow you up until you get--I can follow all of that.

522
01:01:15,740 --> 01:01:24,210
直到那个lambda (n)那里，我不知道这个参数是什么时候传进来的
But when we bring in the permissions, defining CONS in terms of the lambda N, I don't follow where N gets passed.

523
01:01:24,210 --> 01:01:25,100
哦，抱歉
PROFESSOR: Oh, I'm sorry.

524
01:01:25,100 --> 01:01:26,340
我没讲清楚
I'll show you.

525
01:01:26,340 --> 01:01:27,360
我们来仔细看看
Let's follow it.

526
01:01:27,360 --> 01:01:29,180
当然，我们也可以在黑板上演示
Of course, we could do it on the blackboard.

527
01:01:29,180 --> 01:01:30,170
并不难懂
It's not so hard.

528
01:01:30,170 --> 01:01:32,450
非常简单
But it's also easy here.

529
01:01:32,450 --> 01:01:38,520
来看(set-cdr! x y)
Supposing I wish to set-cdr of X to Y. See that right there.

530
01:01:38,520 --> 01:01:46,890
x是一个CONS
set-cdr of X to Y. X is presumably a CONS, a thing resulting from evaluating CONS.

531
01:01:46,890 --> 01:01:58,110
x可以代换为这一部分，一个lambda表达式
Therefore X comes from a place over here, that that X is of the result of evaluating this lambda expression.

532
01:01:58,110 --> 01:01:59,380
对吧
Right?

533
01:01:59,380 --> 01:02:08,950
这个lambda，是在定义CONS的环境下执行的
That when I evaluated that lambda expression, I evaluated it in an environment where the arguments to CONS were defined.

534
01:02:11,750 --> 01:02:29,250
这意味着，x y都是自由变量，x y所在的frame在这个lambda的上层，因此在这个过程中可以访问到x和y
That means that as free variables in this lambda expression, there is the--there are in the frame, which is the parent frame of this lambda expression, the procedure resulting from this lambda expression, X and Y have places.

535
01:02:29,250 --> 01:02:31,910
也可以对它们赋值
And it's possible to set them.

536
01:02:31,910 --> 01:02:37,010
这里赋值为n，是一个传过来的参数
I set them to an N, which is the argument of the permission.

537
01:02:37,010 --> 01:02:47,940
这个可以进行修改的过程是M的参数，而M又是CONS对象的参数
The permission is a procedure which is passed to M, which is the argument that the CONS object gets passed.

538
01:02:47,940 --> 01:02:57,480
现在再来看看SET-CDR！，第一个参数是一个CONS对象
Now, let's go back here in the set-cdr The CONS object, which is the first argument of set-cdr gets passed an argument.

539
01:03:00,260 --> 01:03:07,920
这是一个有4个参数的过程，作为实参，对应这里的形参M
That--there's a procedure of four things, indeed, because that's the same thing as this M over here, which is applied to four objects.

540
01:03:07,920 --> 01:03:12,970
这边的这个sd，就对应于这个过程
The object over here, SD, is, in fact, this permission.

541
01:03:15,470 --> 01:03:19,930
当我执行sd，应用于Y
When I use SD, I apply it to Y, right there.

542
01:03:22,910 --> 01:03:25,740
y是这里传过来的参数
So that comes from this.

543
01:03:25,740 --> 01:03:34,160
David：那-- 教授：对应起来，这里的y就对应于这里的n
AUDIENCE: So what do you-- PROFESSOR: So to finish that, the N that was here is the Y which is here.

544
01:03:34,160 --> 01:03:34,810
明白了吧
How's that?

545
01:03:34,810 --> 01:03:35,750
了解了
AUDIENCE: Right, OK.

546
01:03:35,750 --> 01:03:41,970
当你执行SET-CDR！的时候，x是CDR要变成的值
Now, when you do a set-cdr, X is the value the CDR is going to become.

547
01:03:41,970 --> 01:03:44,742
这里的x
PROFESSOR: The X over here.

548
01:03:44,742 --> 01:03:46,200
并不全对
I'm sorry, that's not true.

549
01:03:46,200 --> 01:03:56,150
SET-CAR！有两个参数，这个x是我们要改变的CONS对象
The X is--set-cdr has two arguments-- The CONS I'm changing and the value I'm changing it to.

550
01:03:56,150 --> 01:03:58,320
你可以代换回去看看，就很清楚了
So you have them backwards, that's all.

551
01:04:01,750 --> 01:04:03,000
还有什么问题吗？
Are there any other questions?

552
01:04:07,880 --> 01:04:08,640
好的
Well, thank you.

553
01:04:08,640 --> 01:04:09,890
这节课就到这里
It's time for lunch.

