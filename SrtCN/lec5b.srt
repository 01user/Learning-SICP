1
00:00:21,170 --> 00:00:24,128
现在我们已经学习了
PROFESSOR: Well, now that we've given you some power

2
00:00:24,432 --> 00:00:27,400
如何创建局部状态和如何建模对象
to make independent local state and to model objects,

3
00:00:28,336 --> 00:00:32,672
我想我们应该找点复杂的东西
I thought we'd do a bit of programming of a very complicated kind,

4
00:00:34,032 --> 00:00:36,368
来实践一下我们学过的这些知识
just to illustrate what you can do with this sort of thing.

5
00:00:40,430 --> 00:00:43,488
假设 我们处在一个物理系统中
I suppose, as I said, we were motivated by physical systems

6
00:00:44,112 --> 00:00:46,256
假设，我们处在这样一个物理系统中，系统中的事物驱动彼此，全部的这些事物组成了世界
the ways we like to think about physical systems,

7
00:00:46,992 --> 00:00:51,088
假设，我们处在这样一个物理系统中，系统中的事物驱动彼此，全部的这些事物组成了世界
which is that there are these things that the world is made out of.

8
00:00:52,060 --> 00:00:55,984
每一个事物都有其独立的局部状态
And each of these things has particular independent local state,

9
00:00:57,248 --> 00:00:59,872
每一个事物都有其独立的局部状态
and therefore it is a thing. That's what makes it a thing.

10
00:01:01,280 --> 00:01:04,272
我们说 我们有一个真实的世界
And then we're going to say that in the model in the world

11
00:01:04,288 --> 00:01:09,900
我们在大脑中和计算机中对那个真实世界建模
we have a world and a model in our minds and in the computer of that world.

12
00:01:10,940 --> 00:01:12,544
我想要把真实世界和计算机中的对象
And what I want to make is a correspondence

13
00:01:12,784 --> 00:01:15,216
联系对应起来
between the objects in the world and the objects in the computer,

14
00:01:15,872 --> 00:01:21,728
把真实世界中对象间的关系 与模型中对象间的关系 对应起来
the relationships between the objects in the world and the relationships between those same obj...--the model objects in the computer,

15
00:01:23,184 --> 00:01:28,112
真实世界中关联对象的函数 与模型中的函数 对应起来
and the functions that relate things in the world to the functions that relate things in the computer.

16
00:01:30,840 --> 00:01:33,824
这就为我们赢得了模块性
This buys us modularity.

17
00:01:34,740 --> 00:01:36,752
如果我们认为真实世界是像那样的
If we really believe the world is like that,

18
00:01:37,360 --> 00:01:38,720
也就是由许多小的事物构成的
that it's made out of these little pieces,

19
00:01:39,200 --> 00:01:41,472
当然 我们可以把世界安排成那样
and of course we could arrange our world to be like that,

20
00:01:42,032 --> 00:01:43,952
我们只能对像那样的事物建模
we could only model those things that are like that,

21
00:01:45,456 --> 00:01:49,024
这样 我们的程序就可以从现实世界中继承模块化
then we can inherit the modularity in the world into our programming.

22
00:01:50,450 --> 00:01:53,584
这就是发明面向对象编程的初衷
That's why we would invent some of this object-oriented programming.

23
00:01:55,420 --> 00:01:58,192
我所见过的最完美的对象（系统）
Well, let's take the best kind of objects I know.

24
00:01:58,890 --> 00:02:04,176
电气系统 就是非常非常完美的对象系统
They're completely--they're completely wonderful: electrical systems.

25
00:02:06,400 --> 00:02:12,992
电气系统真的是物理学家构造的非常非常好的一种对象
Electrical systems really are the physicist's best, best objects.

26
00:02:14,220 --> 00:02:16,760
这里 我有一些机器零件
You see over here I have some piece of machinery.

27
00:02:17,120 --> 00:02:18,288
就是这些零件
Right here's a piece of machinery.

28
00:02:20,040 --> 00:02:22,880
有一个电线连接起了
And it's got an electrical wire connecting

29
00:02:23,664 --> 00:02:26,400
零件的两个部分
one part of the machinery with another part of the machinery.

30
00:02:27,568 --> 00:02:30,864
电气世界中 有一个非常棒的特性
And one of the wonderful properties of the electrical world

31
00:02:31,648 --> 00:02:33,120
就是我可以说这是一个对象
is that I can say this is an object,

32
00:02:34,016 --> 00:02:34,976
这又是一个对象
and this is an object,

33
00:02:35,712 --> 00:02:37,536
它们间的关联一目了然
and they're-- the connection between them is clear.

34
00:02:38,240 --> 00:02:43,328
而且 如果我没有用电线连接 它们便没有关联
In principle, there is no connection that I didn't describe with these wires.

35
00:02:44,740 --> 00:02:46,128
比如我有一个灯泡
Let's say if I have light bulbs,

36
00:02:46,528 --> 00:02:50,320
一个灯泡和一个已经接在插座上的电源
Let's say if I have light bulbs, a light bulb and a power supply that's plugged into the outlet.

37
00:02:51,632 --> 00:02:53,536
关联非常明了
Then the connection is perfectly clear.

38
00:02:53,620 --> 00:02:55,424
这就是已知所有的连接方式了
There's no other connections that we know of.

39
00:02:56,220 --> 00:03:02,336
就算我把连接电灯和电源的电线打个结
If I were to tie a knot in the wire that connects the light bulb to the power supply,

40
00:03:02,688 --> 00:03:03,648
灯仍然是亮的
the light remains lit up.

41
00:03:04,040 --> 00:03:04,768
没什么影响
It doesn't care.

42
00:03:07,440 --> 00:03:12,400
物理学上这样安排 可以使连接变成抽象的
That the way the physics is arranged is such that the connection can be made abstract,

43
00:03:13,088 --> 00:03:15,270
至少在低频状态下是可以的
at least for low frequencies and things like that.

44
00:03:17,840 --> 00:03:20,880
而且这就是全部的关联方式了
So in fact, we have captured all of the connections there really are.

45
00:03:22,350 --> 00:03:23,872
当然 我们来进一步
Well, as you can go one step further

46
00:03:23,904 --> 00:03:27,310
讨论一种在电气系统中最为广泛的抽象
and talk about the most abstract types of electrical systems we have,

47
00:03:27,856 --> 00:03:29,420
数字电路
digital to dual circuits.

48
00:03:31,696 --> 00:03:33,664
这里有一些对象
And here there are certain kinds of objects.

49
00:03:34,640 --> 00:03:40,128
例如 在数字电路里中 我们有非门
For example, in digital circuits we have things like inverters.

50
00:03:41,392 --> 00:03:42,784
有与门
We have things like and-gates.

51
00:03:43,990 --> 00:03:45,408
还有或门
We have things like or-gates.

52
00:03:47,210 --> 00:03:50,128
我们用一种特殊的“电线” 把它们连接起来
We connect them together by sort-of wires

53
00:03:52,000 --> 00:03:54,944
这些“电线”代表抽象信号
which represent abstract signals.

54
00:03:55,610 --> 00:03:57,184
我们不关心具体的物理因素
We don't really care as physical variables

55
00:03:57,210 --> 00:03:59,728
像电压、电流或者组合因素等
whether these are voltages or currents or some combination

56
00:04:00,016 --> 00:04:03,440
又或者是水压 等等
or water, water pressure.

57
00:04:05,200 --> 00:04:07,328
这些抽象变量代表某类信号
These abstract variables represent certain signals.

58
00:04:09,420 --> 00:04:12,896
我们用电路连接元件 构建系统
And we build systems by wiring these things together with wires.

59
00:04:14,070 --> 00:04:16,224
现在 我要向你们介绍一门新的语言
So today what I'm going to show you, right now,

60
00:04:17,632 --> 00:04:20,176
我们要构建一门内嵌于Lisp中的语言
we're going to build up an invented language in Lisp,

61
00:04:22,144 --> 00:04:25,088
这是一种内部DSL 是类似于之前讲过的图形语言那种
embedded in the same sense that Henderson's picture language was embedded,

62
00:04:26,160 --> 00:04:27,328
而不是昨天那种
which is not the same sense

63
00:04:27,888 --> 00:04:31,610
那种模式匹配语言 -- 那是外部DSL
as the language of pattern match and substitution was done yesterday.

64
00:04:32,800 --> 00:04:36,300
模式匹配语言是由Lisp程序所解释的
The pattern match substitution language was interpreted by a Lisp program.

65
00:04:38,160 --> 00:04:40,528
而之前那种图形语言
But the embedding of Henderson's program

66
00:04:40,560 --> 00:04:44,270
是在Lisp中构造我们想要的过程 来封装图形结构
is that we just build up more and more procedures that encapsulate the structure we want.

67
00:04:45,480 --> 00:04:46,752
举例来说
So for example here,

68
00:04:47,728 --> 00:04:50,640
首先我要有一些基本对象
I'm going to have some various primitive kinds of objects, as you see,

69
00:04:51,056 --> 00:04:52,128
比如这个和这个
that one and that one.

70
00:04:53,504 --> 00:04:55,184
然后用电线去组合它们
I'm going to use wires to combine them.

71
00:04:55,984 --> 00:04:59,376
我用 (MAKE-WIRE) 来构造一个电线
The way I represent attaching-- I can make wires.

72
00:04:59,870 --> 00:05:01,248
A就代表了一根电线
So let's say A is a wire.

73
00:05:01,740 --> 00:05:02,690
B也是
And B is a wire.

74
00:05:02,690 --> 00:05:03,460
C也是
And C is a wire.

75
00:05:03,460 --> 00:05:04,230
D也是
And D is a wire.

76
00:05:04,230 --> 00:05:04,830
还有E
And E is wire.

77
00:05:04,830 --> 00:05:05,648
S也是
And S is a wire.

78
00:05:06,880 --> 00:05:12,752
而或门有两个输入 分别是A和B
Well, an or-gate that has both inputs, the inputs being A and B,

79
00:05:13,168 --> 00:05:14,752
它的输出是D
and the output being wire D,

80
00:05:15,072 --> 00:05:16,128
我们用这样的记号来表示
you notate like this.

81
00:05:18,140 --> 00:05:22,144
与门 输入是A和B 输出是C
An and-gate, which has inputs A and B and output C,

82
00:05:22,224 --> 00:05:23,240
我们这样表示
we notate like that.

83
00:05:24,820 --> 00:05:28,464
通过一系列像这样的声明
By making such a sequence of declarations,

84
00:05:29,296 --> 00:05:31,648
我可以组合出任意的电路
I can wire together an arbitrary circuit.

85
00:05:32,750 --> 00:05:38,512
我已经说明了基本对象和构建数字电路的组合方法
So I've just told you a set of primitives and means of combination for building digital circuits,

86
00:05:40,096 --> 00:05:43,040
然后就该说抽象的方法了
when I need more in a real language than abstraction.

87
00:05:43,690 --> 00:05:52,240
举例来说 这是一个半加器
And so for example, here I have--here I have a half adder.

88
00:05:52,672 --> 00:05:55,552
如果你学过电路设计肯定知道这个东西
It's something you all know if you've done any digital design.

89
00:05:56,930 --> 00:06:00,448
输入两个数A和B
It's used for adding numbers together on A and B

90
00:06:00,624 --> 00:06:02,120
输出两者之和以及进位
and putting out a sum and a carry.

91
00:06:04,352 --> 00:06:06,800
事实上 完全可以用我刚刚说的来组合电路#TBD
And in fact, the wiring diagram is exactly what I told you.

92
00:06:07,450 --> 00:06:10,992
盒子外面 有半加器的另外一些东西 #TBD
A half adder with things that come out of the box--

93
00:06:11,136 --> 00:06:14,112
这些盒子的边界 我们总是抽象成盒子
you see the box, the boundary, the abstraction is always a box.

94
00:06:14,790 --> 00:06:19,700
从盒子里引出A B S C四根线
And there are things that come out of it, A, B, S, and C.

95
00:06:19,700 --> 00:06:21,792
这些是已经声明了的变量
Those are the declared variables--

96
00:06:23,390 --> 00:06:26,256
由LAMBDA表达式声明的几个变量
declared variables of a lambda expression,

97
00:06:26,288 --> 00:06:28,010
定义了这个半加器
which is the one that defines half adder.

98
00:06:31,400 --> 00:06:35,968
在盒子的内部 我构造了电线D和E
And internal to that, I make up some more wires, D and E,

99
00:06:36,000 --> 00:06:37,440
这是为了连接内部结构
which I'm going to use for the interconnect--

100
00:06:37,744 --> 00:06:40,400
这条是E 这条是D
here E is this one and D is this wire,

101
00:06:41,328 --> 00:06:43,504
内部连接的线路并没有引出盒子之外
the interconnect that doesn't come through the walls of the box--

102
00:06:45,056 --> 00:06:46,832
就像电路图那样连起来
and wire things together as you just saw.

103
00:06:48,790 --> 00:06:50,896
大家可以看得出来
And the nice thing about this that I've just shown you

104
00:06:51,056 --> 00:06:53,024
这个语言非常有层次性
this language is hierarchical in the right way.

105
00:06:53,856 --> 00:06:55,712
如果一门语言没有层次性
If a language isn't hierarchical in the right way,

106
00:06:55,952 --> 00:06:59,968
如果你不能把一个复合对象当成基本对象来使用
if it turns out that a compound object doesn't look like a primitive,

107
00:07:00,384 --> 00:07:01,536
这门语言肯定是有问题的
there's something wrong with the language--

108
00:07:02,592 --> 00:07:04,224
至少我是这么认为的
at least the way I feel about that.

109
00:07:06,410 --> 00:07:09,584
之前 我们都是在研究数学函数
So here we have--here, instead of starting with mathematical functions,

110
00:07:09,600 --> 00:07:11,120
或者是计算数学函数的东西
or things that compute mathematical functions,

111
00:07:11,152 --> 00:07:12,650
这些都是我们之前研究的东西
which is what we've been doing up until now,

112
00:07:13,850 --> 00:07:16,656
而我们现在
instead of starting with things that look like mathematical functions,

113
00:07:16,672 --> 00:07:17,630
不这么做了
or compute such things,

114
00:07:17,850 --> 00:07:20,880
我们从一些电气对象开始
we are starting with things that are electrical objects

115
00:07:21,040 --> 00:07:22,640
构建更多的对象
and we build up more electrical objects.

116
00:07:23,350 --> 00:07:28,832
我们用Lisp里的LAMBDA将其粘合起来
And the glue we're using is basically the Lisp structure: lambdas.

117
00:07:30,500 --> 00:07:32,930
“LAMBDA: 终极之粘合剂”
Lambda is the ultimate glue, if you will.

118
00:07:33,320 --> 00:07:36,352
当然 半加器可以用于
And of course, half adder itself can be used

119
00:07:37,648 --> 00:07:41,040
构造一种更复杂的抽象结构 -- 全加器
in a more complicated abstraction called a full adder,

120
00:07:41,600 --> 00:07:45,056
如这里所示 全加器由两个半加器构成
which in fact involves two half adders, as you see here,

121
00:07:45,470 --> 00:07:47,872
用一些额外的电线连接起来
hooked together with some extra wires,

122
00:07:48,080 --> 00:07:51,290
就像这里所示的S、C1、C2以及一个或门
that you see here, S, C1, and C2, and an or-gate,

123
00:07:52,190 --> 00:07:53,600
而对于一个全加器
to manufacture a full adder,

124
00:07:53,872 --> 00:08:00,780
它的输入有：两个待加的数 一个进位值
which takes a input number, another input number, a carry in,

125
00:08:01,360 --> 00:08:04,176
输出是：两数之和以及进位
and produces output, a sum and a carry out.

126
00:08:05,900 --> 00:08:10,704
构建好全加器以后 还可以把它们链起来组成更大的加法器
And out of full adders, you can make real adder chains and big adders.

127
00:08:12,990 --> 00:08:14,832
现在我们有了一门完整的语言
So we have here a language so far

128
00:08:16,064 --> 00:08:21,760
它有基本元素、组合方法以及抽象方法
That has primitives, means of combination, and means of abstraction to real language.

129
00:08:22,270 --> 00:08:23,360
现在 我们怎样实现这门语言？
Now, how are we going to implement this?

130
00:08:25,000 --> 00:08:26,848
其实并不难
Well, let's do it easily.

131
00:08:27,070 --> 00:08:27,968
首先来看基本元素
Let's look at the primitives.

132
00:08:28,128 --> 00:08:30,112
实现原子元素也是整个问题的根本所在
The only problem is we have to implement the primitives.

133
00:08:31,160 --> 00:08:32,560
不需要再做其它事情了
Nothing else has to be implemented,

134
00:08:33,744 --> 00:08:38,000
因为我们直接借用了Lisp中的组合方法以及抽象方法
because we're picking up the means of combination and abstraction from Lisp,

135
00:08:39,968 --> 00:08:41,888
我们的语言 继承自Lisp并内嵌于其中
inheriting them in the embedding.

136
00:08:43,776 --> 00:08:45,440
好 我们先来看一个基本元素
OK, so let's look at a particular primitive.

137
00:08:45,860 --> 00:08:47,400
就拿非门来说吧
An inverter is a nice one.

138
00:08:51,540 --> 00:08:54,672
非门有两个引脚 分别是输入和输出
Now, inverter has two wires coming in, an in and an out.

139
00:08:57,312 --> 00:09:02,624
它要对输入信号做出响应
And somehow, it's going to have to know what to do when a signal comes in.

140
00:09:04,300 --> 00:09:07,008
它需要对输入电线说 --
So somehow it's going to have to tell its input wire--

141
00:09:07,640 --> 00:09:10,144
我们现在把它们视作对象
and now we're going to talk about objects

142
00:09:10,448 --> 00:09:12,416
其具体细节我们稍后讨论
and we're going to see this in a little more detail soon--

143
00:09:13,230 --> 00:09:14,848
它对其输入电线的说
but it's going to have to tell its input wire

144
00:09:15,824 --> 00:09:18,480
“当你的值变发生改变时 告诉我一声”
that when you change, tell me.

145
00:09:20,120 --> 00:09:22,112
所以非门这个对象
So this object, the object which is the inverter

146
00:09:22,416 --> 00:09:24,384
会对输入电线这个对象说 --
has to tell the object which is the input wire,

147
00:09:25,136 --> 00:09:26,400
“Hi，我是George”
hi, my name is George.

148
00:09:26,870 --> 00:09:31,024
“我的工作就是 对你的变化做出响应”
And my, my job is to do something with results when you change.

149
00:09:31,720 --> 00:09:34,192
“所以当你变化的时候 告诉我一声”
So when you change, you get a change, tell me about it.

150
00:09:34,730 --> 00:09:35,728
“因为这样我才能进行进一步的处理”
Because I've got to do something with that.

151
00:09:36,880 --> 00:09:40,304
这是通过这里在输入电线上
Well, that's done down here by adding an action on the input wire called invert-in,

152
00:09:41,408 --> 00:09:44,640
添加一个叫做INVERT-IN的动作来实现的
Well, that's done down here by adding an action on the input wire called invert-in,

153
00:09:45,070 --> 00:09:46,944
INVERT-IN在这里定义
where invert-in is defined over here

154
00:09:47,056 --> 00:09:48,760
它是一个无参过程
to be a procedure of no arguments,

155
00:09:49,984 --> 00:09:54,592
它将线路上的信号逻辑取反
which gets the logical not of the signal on the input wire.

156
00:09:56,130 --> 00:09:58,528
经过一段时长为INVERTER-DELAT的延时以后 --
And after some delay, which is the inverter delay,

157
00:09:59,344 --> 00:10:01,136
每个电路对象都有延时 --
all these electrical objects have delays,

158
00:10:02,880 --> 00:10:04,460
然后我们会 --
we'll do the following thing--

159
00:10:04,672 --> 00:10:07,140
我们再把输出设置为新的值
set the signal on the output wire to the new value.

160
00:10:10,160 --> 00:10:11,360
非常简单
A very simple program.

161
00:10:12,400 --> 00:10:15,280
你可以想象输出电线也同样是信号敏感的
Now, you have to imagine that the output wire has to be sensitive

162
00:10:15,770 --> 00:10:18,272
当信号改变的时候
and know that when its signal changes,

163
00:10:19,280 --> 00:10:21,150
它会“告知”其它对象
it may have to tell other guys,

164
00:10:21,792 --> 00:10:24,784
“快醒醒！我的值已经改变啦”
Hi, wake up. My value has changed.

165
00:10:26,050 --> 00:10:30,144
所以当你把非门和与门或者元件连在一起的时候
So when you hook together inverter with an and-gate or something like that,

166
00:10:30,464 --> 00:10:32,208
它们之间将会有大量的通信
there has to be a lot of communication going on

167
00:10:32,864 --> 00:10:35,072
以确保信号正确地传播
to make sure that the signal propagates right.

168
00:10:36,810 --> 00:10:38,620
到目前为止 没什么新奇的东西
And down here is nothing very exciting.

169
00:10:38,620 --> 00:10:40,720
我们只是针对某个特定的表示法
This is just the definition of logical not

170
00:10:40,720 --> 00:10:45,240
也就是这个例子中的 1 0 -- 实现了LOGICAL-NOT而已
for some particular representations of the logical values-- 1, 0 in this case.

171
00:10:46,736 --> 00:10:49,168
与门就相对复杂一些
And we can look at things more complicated like and-gates.

172
00:10:49,780 --> 00:10:55,808
与门有两个输入A1和A2 输出是OUTPUT
And-gates take two inputs, A1 and A2, we'll call them, and produce an output.

173
00:10:56,736 --> 00:11:00,640
但是其结构和非门没有什么大的不同
But the structure of the and-gate is identical to the one we just saw.

174
00:11:00,860 --> 00:11:03,440
只不过是 当输入信号改变的时候
There's one called an and-action procedure that's defined,

175
00:11:04,528 --> 00:11:09,070
与门调用的是AND-ACTION过程罢了
which is the thing that gets called when an input is changed.

176
00:11:10,910 --> 00:11:12,880
当然 它所做的只是
And what it does, of course, is nothing more than

177
00:11:12,912 --> 00:11:15,370
对输入信号进行逻辑“与”运算
compute the logical and of the signals on the inputs.

178
00:11:16,192 --> 00:11:18,768
在经过AND-GATE-DELAY的延时之后
And after some delay, called the and-gate-delay,

179
00:11:20,464 --> 00:11:24,368
调用这个过程 更新输出信号值
calls this procedure, which sets a signal on the output to a new value.

180
00:11:25,470 --> 00:11:28,350
那么 我们如何用“按愿望思维”来构造这一切呢？
Now, how I implement these things is all wishful thinking.

181
00:11:28,350 --> 00:11:31,088
如大家所见 这里有一个赋值运算
As you see here, I have an assignment operation.

182
00:11:32,020 --> 00:11:32,784
但并不是SET!
It's not set.

183
00:11:34,570 --> 00:11:36,784
这是一个派生出来的运算
It's a derived assignment operation in the same way

184
00:11:36,784 --> 00:11:38,730
就像可以从CAR和CDR派生出其它函数一样
we had functions that were derived from CAR and CDR.

185
00:11:40,800 --> 00:11:44,816
因此 按照约定 我加上“!”（表示这个过程有副作用）
So I, by convention, label that with an exclamation point.

186
00:11:46,340 --> 00:11:49,184
这里有个过程ADD-ACTION!
And over here, you see there's an add-action!,

187
00:11:52,176 --> 00:11:54,624
它用来提醒与门中的局部线路A1
which is to inform the wire, called A1 locally in this and-gate,

188
00:11:55,632 --> 00:11:58,688
当它改变的时候记得执行过程ADD-ACTION-PROCEDURE
to call the and-action-procedure when it gets changed,

189
00:11:59,584 --> 00:12:02,912
A2也是一样
and the wire A2 to call the and-action procedure when it gets changed.

190
00:12:06,310 --> 00:12:07,232
非常简单
All very simple.

191
00:12:09,960 --> 00:12:12,096
现在我们再来看看
Well, let's talk a little bit about this communication

192
00:12:12,704 --> 00:12:16,120
各部分间是如何通信的
that must occur between these various parts.

193
00:12:18,544 --> 00:12:19,664
例如
Suppose, for example,

194
00:12:23,120 --> 00:12:24,272
有一个非常简单的电路
I have a very simple circuit

195
00:12:24,272 --> 00:12:30,460
它有一个带有两个输入A、B的与门
which contains and-gate with wires a and b.

196
00:12:31,920 --> 00:12:38,000
与门通过电线C跟非门相连
And that connects through a wire called c to an inverter

197
00:12:39,728 --> 00:12:41,536
非门的输出是D
which has a wire output called d.

198
00:12:44,208 --> 00:12:47,344
这就是物理世界
What are the comput...--here's the physical world.

199
00:12:47,360 --> 00:12:49,024
一个对物理世界的抽象
It's an abstraction of the physical world.

200
00:12:49,860 --> 00:12:53,408
要不了几分钱就可以从Radio Shack买到这些元件
Now I can buy these out of little pieces that you get at Radio Shack for a few cents.

201
00:12:54,880 --> 00:12:56,320
那些元件的作用和画在这里的差不多
And there are boxes that act like this,

202
00:12:57,168 --> 00:13:00,220
元件上都标有类似于LS04的标签
which have little numbers on them like LS04 or something.

203
00:13:01,530 --> 00:13:08,160
现在来看其中的计算模型
Now supposing I were to try to say what's the computational model.

204
00:13:09,010 --> 00:13:10,944
它又对应着什么
What is the thing that corresponds to that,

205
00:13:11,136 --> 00:13:14,096
#TBD
that part of reality in the mind of us and in the computer?

206
00:13:15,850 --> 00:13:19,136
#TBD
Well, I have to assign for every object in the world an object in the computer,

207
00:13:19,792 --> 00:13:24,272
#TBD
and for every relationship in the world between them a relationship in the computer.

208
00:13:26,064 --> 00:13:26,800
这是我们的目标
That's my goal.

209
00:13:28,560 --> 00:13:29,456
让我们来看看怎么做
So let's do that.

210
00:13:30,900 --> 00:13:34,208
这一团东西代表信号A
Well, I have some sort of thing called the signal, A.

211
00:13:35,712 --> 00:13:36,944
这是信号A
This is A. It's a signal.

212
00:13:37,940 --> 00:13:39,328
画得像一团云
It's a cloudy thing like that.

213
00:13:39,900 --> 00:13:42,800
再画另一个信号 -- B
And I have another one down here which I'm going to call B.

214
00:13:46,688 --> 00:13:47,470
它是另一个信号
It's another signal.

215
00:13:49,140 --> 00:13:50,912
这两个信号
Now this signal--these two signals

216
00:13:51,104 --> 00:13:52,816
要通过某种方式连在一起
are somehow going to have to hook together

217
00:13:53,728 --> 00:13:58,752
连在这个盒子上 -- 我们这么来画
into a box, let's call it this, which is the and-gate, action procedure.

218
00:14:00,320 --> 00:14:02,040
这就是与门的动作过程
That's the and-gate's action procedure.

219
00:14:07,660 --> 00:14:08,592
它将产生
And it's going to produce

220
00:14:09,152 --> 00:14:13,296
它将与另外一个称作C的信号对象交互
well, it's going to interact with a signal object, which we call C--

221
00:14:16,224 --> 00:14:18,880
哦 说错了 是一条电线C
a wire object, excuse me, we call C.

222
00:14:20,592 --> 00:14:23,888
这跟电线 又将连在
this is going to put out again, or connect to,

223
00:14:24,784 --> 00:14:30,336
一个非门上#TBD
nother action procedure which is one associated with the inverter in the world, not.

224
00:14:32,860 --> 00:14:40,656
我还有另外一根电线 -- D
And I'm going to have another--another wire, which we'll call D.

225
00:14:42,970 --> 00:14:45,296
整体布局就是这样
So here's my layout of stuff.

226
00:14:46,000 --> 00:14:49,440
现在必须来研究它们 有关计算的内部机制了
Now we have to say what's inside them and what they have to know to compute.

227
00:14:51,500 --> 00:14:53,696
每一跟电线都必须知道
Well, every--every one of these wires has to know

228
00:14:53,696 --> 00:14:56,360
自己承载的信号是什么
what the value of the signal that's on that wire is.

229
00:14:57,340 --> 00:15:00,000
我们用变量SIGNAL来表示
So there's going to be some variable inside here, we'll call it signal.

230
00:15:02,976 --> 00:15:04,048
SIGNAL的值就是信号
And he owns a value.

231
00:15:05,680 --> 00:15:07,744
也不要忘了它所关联的环境
So there must be some environment associated with this.

232
00:15:08,896 --> 00:15:11,344
对于每个元件来说 一定有一个环境绑定了信号
And for each one of these, there must be an environment that binds signal.

233
00:15:15,400 --> 00:15:16,880
因此 这里也有一个SIGNAL变量
And there must be a signal here, therefore.

234
00:15:19,400 --> 00:15:21,920
SIGNAL的值不是0就是1
And presumably, signal's a value that's either 1 or 0,

235
00:15:22,816 --> 00:15:23,488
这儿也有个SIGNAL
and signal.

236
00:15:28,000 --> 00:15:30,560
现在 一旦这里的信号改变
Now, we also have to have some

237
00:15:31,264 --> 00:15:34,112
我们需要通知一系列的对象
list of people to inform if the signal here changes.

238
00:15:36,660 --> 00:15:37,664
我们得通知这个与门
We're going to have to inform this.

239
00:15:39,300 --> 00:15:43,968
这里有个表 我们把它叫做AP
So I've got that list. We'll call it the Action Procedures, AP.

240
00:15:44,500 --> 00:15:45,600
它可能是一个表
And it's presumably a list.

241
00:15:46,448 --> 00:15:49,008
在本例中 表里面的第一项条目是这个东西
But the first thing on the list, in this case, is this guy.

242
00:15:50,500 --> 00:15:54,810
这个元件也有一个称为AP的表
And the action procedures of this one happens to have some list of stuff.

243
00:15:54,810 --> 00:15:58,176
也可能有一些其它对象 时刻等待着A来通知“它们”
There might be other people who are sharing A, who are looking at it.

244
00:15:59,020 --> 00:16:01,312
所以这里可能有其它对象 比如
So there might be other guys on this list, like

245
00:16:01,728 --> 00:16:03,230
一些其它我们不知道的对象
like somebody over there that we don't know about.

246
00:16:03,630 --> 00:16:04,880
我画在这里#TBD
It's the other guy attached to A.

247
00:16:07,200 --> 00:16:09,648
这里的AP表
And the action procedure here also has to point to that,

248
00:16:11,120 --> 00:16:12,400
也指向这个与门
the list of action procedures.

249
00:16:13,070 --> 00:16:16,352
相类似的 这里的AP表
And of course, that means this one, its action procedures

250
00:16:16,784 --> 00:16:18,530
也要指向这里
has to point up to here.

251
00:16:18,530 --> 00:16:20,896
这里是C要通知的元件
This is the things-- the people it has to inform.

252
00:16:21,770 --> 00:16:23,184
D也一样
And this guy has some too.

253
00:16:24,280 --> 00:16:25,248
但是我不知道它要通知谁
But I don't know what they are

254
00:16:25,264 --> 00:16:26,650
因为我的图中没有画出来
because I didn't draw it in my diagram.

255
00:16:27,190 --> 00:16:28,368
可能是和D连接起来的其它门吧#TBD
It's the things connected to D.

256
00:16:30,320 --> 00:16:32,624
同样的
Now, it's also the case

257
00:16:33,800 --> 00:16:36,960
当AND-ACTION过程被唤醒时
that when the and-action procedure is awakened,

258
00:16:37,020 --> 00:16:41,312
#TBD
saying one of the people who know that you've told

259
00:16:41,450 --> 00:16:44,848
#TBD
one of the people you've told to wake you up if their signal changes,

260
00:16:46,970 --> 00:16:48,816
你得去检查它的信号是什么
you have to go look and ask them what's their signal

261
00:16:49,328 --> 00:16:52,256
这样你就可以计算逻辑与 输出信号给下一个元件
so you can do the and, and produce a signal for this one.

262
00:16:57,090 --> 00:16:58,752
所里 这里就必须要有
So there has to be, for example,

263
00:16:58,848 --> 00:17:03,000
有信息说 A1是这个元件
information here saying A1, my A1 is this guy,

264
00:17:03,900 --> 00:17:06,480
A2就是这个元件
my A1 is this guy, and my A2 is this guy.

265
00:17:08,930 --> 00:17:09,984
不只是这样
And not only that,

266
00:17:11,790 --> 00:17:15,200
当我在计算逻辑与时 我还得告诉这个元件一些信息
when I do my and, I'm going to have to tell this guy something.

267
00:17:16,304 --> 00:17:21,056
还有一个输出 输出给这个元件
So I need an output--  being this guy.

268
00:17:25,800 --> 00:17:30,032
同样地 非门也有一个输入
And similarly, this guy's going to have a thing called the input

269
00:17:32,380 --> 00:17:34,928
当信号被唤醒并告知它信号被修改时
that he interrogates to find out

270
00:17:36,752 --> 00:17:38,640
非门会询问该信号
what the value of the signal on the input is,

271
00:17:38,640 --> 00:17:40,090
你的值是什么
when the signal wakes up and says, I've changed,

272
00:17:41,050 --> 00:17:43,472
信号通过像这样发消息 告知“信号已改变”
and sends a message this way saying, I've changed.

273
00:17:43,520 --> 00:17:45,536
它就反过来查询这个新的信号值
This guy says, OK, what's your value now?

274
00:17:46,900 --> 00:17:50,128
取到值之后 它将会
When he gets that value, then he's going to have to say,

275
00:17:50,144 --> 00:17:55,860
计算输出 并改变这个信号的值
OK, output changes this guy, changes this guy.

276
00:18:00,600 --> 00:18:01,248
以此类推
And so on.

277
00:18:02,848 --> 00:18:04,560
因此我也必须有这么多的连接
And so I have to have at least that much connected-ness.

278
00:18:06,240 --> 00:18:09,232
现在我们回头观察一下 这个与门
Now, let's go back and look, for example, at the and-gate.

279
00:18:10,260 --> 00:18:12,096
回到这张幻灯片
Here we are back on this slide.

280
00:18:13,670 --> 00:18:15,040
这几个部分的内容
And we can see some of these parts.

281
00:18:16,040 --> 00:18:19,328
对每个与门 都有A1、A2两个输入 一个OUTPUT输出
For any particular and-gate, there is an A1, there is an A2, and the output.

282
00:18:21,030 --> 00:18:23,536
这些都是
And those are, those are an

283
00:18:25,088 --> 00:18:28,160
在AND-GATE被调用时
an environment that was created at the--those produce a frame

284
00:18:28,416 --> 00:18:31,248
所创建出的环境
at the time and-gate was called,

285
00:18:33,310 --> 00:18:35,904
#TBD
A frame where A1, A2, and output are--

286
00:18:36,672 --> 00:18:39,200
#TBD
have as their values, they're bound to

287
00:18:39,600 --> 00:18:44,256
#TBD
the wires which, they are--which were passed in.

288
00:18:46,240 --> 00:18:47,312
在这个环境下
In that environment,

289
00:18:47,744 --> 00:18:49,856
我构建一个过程
I constructed a procedure

290
00:18:50,976 --> 00:18:53,680
就在这里
this one right there.

291
00:18:54,590 --> 00:18:57,312
在该环境下定义的AND-ACTION-PROCEDURE
And-action-procedure was constructed in that environment.

292
00:18:58,352 --> 00:19:00,704
这个实际上是对一个LAMBDA表达式求值
That was the result of evaluating a lambda expression.

293
00:19:01,620 --> 00:19:05,488
它跟求值该LAMBDA表达式时的环境相绑定
So it hangs onto the frame where these were defined.

294
00:19:07,168 --> 00:19:09,344
找到它的局部环境
Local--part of its local state is that.

295
00:19:11,700 --> 00:19:13,472
因此 AND-ACTION-PROCEDURE 过程能够
The and-action-procedure, therefore, has

296
00:19:13,648 --> 00:19:16,940
存取这里看到的 A1 A2 和 OUTPUT
access to A1, A2, and output as we see here.

297
00:19:17,310 --> 00:19:19,645
A1 A2 OUTPUT
A1, A2, and output.

298
00:19:22,360 --> 00:19:23,952
我们还没有深入探索“电线”的内部结构
Now, we haven't looked inside of a wire yet.

299
00:19:26,030 --> 00:19:26,992
那是仅剩的部分
That's all that remains.

300
00:19:29,030 --> 00:19:29,920
来看看“电线”
Let's look at a wire.

301
00:19:33,520 --> 00:19:36,256
麻烦请开一下投影仪
Like the overhead, very good.

302
00:19:39,500 --> 00:19:42,560
“电线”是有那么一点复杂
Well, the wire, again, is a, is a somewhat complicated mess.

303
00:19:43,090 --> 00:19:44,640
哦 说错了
Ooh, wrong one.

304
00:19:47,056 --> 00:19:48,752
是非常复杂 像这样
It's a big complicated mess, like that.

305
00:19:50,064 --> 00:19:53,104
但是还是来看一下 到底是什么
But let's look at it in detail and see what's going on.

306
00:19:54,720 --> 00:19:56,672
“电线”是这样的一种东西
Well, the wire is one of these.

307
00:19:57,760 --> 00:20:03,520
有两个主要部分 都是它的状态
And it has to have two things that are part of it, that it's state.

308
00:20:05,010 --> 00:20:07,390
我们这里看到的 一个是信号值
One of them is the signal we see here.

309
00:20:07,456 --> 00:20:10,064
这里 当我们调用 MAKE-WIRE 创建一条电线时
Heres, when we call make-wire to make a wire,

310
00:20:10,464 --> 00:20:13,024
我们首先要创建一些变量
then the first thing we do is we create some variables

311
00:20:14,944 --> 00:20:16,080
分别是这条电线的
which are the signal

312
00:20:17,104 --> 00:20:19,296
SIGNAL 和 ACTION-PROCS
and the action procedures for this wire.

313
00:20:22,320 --> 00:20:23,440
在这个上下文中
And in that context,

314
00:20:23,760 --> 00:20:27,040
我们定义了一系列的过程
we define various functions--or procedures, excuse me, procedures.

315
00:20:27,840 --> 00:20:31,152
其中一个是 (SET-MY-SIGNAL! NEW)
One of them is called set-my-signal to a new value.

316
00:20:32,850 --> 00:20:37,424
它所做的只是 取一个新值NEW
And what that does is takes a new value in.

317
00:20:37,930 --> 00:20:40,360
如果NEW和SIGNAL一样 信号没有变化 就没必要做什么了
If that's equal to my current value of my signal, I'm done.

318
00:20:40,360 --> 00:20:42,624
否则 把 SIGNAL 的值赋值为 NEW
Otherwise, I set the signal to the new value

319
00:20:42,752 --> 00:20:44,608
再调用 ACTION-PROCS 里的所有过程
and call each of the action procedures

320
00:20:46,528 --> 00:20:52,512
那些我之前引入的过程
that I've been, that I've been--what's the right word? --  introduced to.

321
00:20:54,630 --> 00:21:01,530
#TBD
I get introduced when the and-gate was applied to me.

322
00:21:04,130 --> 00:21:05,600
是在代码最后调用 ADD-ACTION-PROCEDURE 实现的
By add action procedure at the bottom.

323
00:21:07,410 --> 00:21:10,800
然后 我还得定义一个过程 用来接受动作
Also, I have to define a way of accepting an action procedure--

324
00:21:10,816 --> 00:21:11,820
也就是这段代码
which is what you see here---

325
00:21:12,800 --> 00:21:15,136
它增加了AP表
which increments my action procedures

326
00:21:15,568 --> 00:21:21,630
这是通过使用 SET! 将 PROC 与旧的 AP 表 CONS 起来实现的
using set to the result of CONSing up a new process--a procedure,

327
00:21:21,792 --> 00:21:24,256
而这个 PROC 是作为参数传递进来的
which is passed to me, on to my actions procedures list.

328
00:21:25,408 --> 00:21:27,584
由于技术原因 最后还要再运行一次PROC
And for technical reasons, I have to call that procedure one.

329
00:21:27,780 --> 00:21:29,200
我不会再对此展开#TBD
So I'm not going to tell you anything about that,

330
00:21:29,392 --> 00:21:33,152
这是一种事件驱动的模拟
that has to do with event-driven simulations and getting them started,

331
00:21:34,592 --> 00:21:36,000
#TBD
which takes a little bit of thinking.

332
00:21:36,950 --> 00:21:39,408
最后 我还要定义一个“分派器”
And finally, I'm going to define a thing called the dispatcher,

333
00:21:39,968 --> 00:21:43,584
这是一种将消息分派给电线的方法
which is a way of passing a message to a wire,

334
00:21:45,376 --> 00:21:48,656
它将用于从中抽取出不同的信息
which is going to be used to extract from it various information,

335
00:21:49,072 --> 00:21:51,488
比如这里 当前的信号值是多少？
like what is the current signal value?

336
00:21:53,820 --> 00:21:55,664
设置新信号值的方法是什么？
What is the method of setting your signal?

337
00:21:57,180 --> 00:21:58,288
我想要这个方法
I want to get that out of it.

338
00:22:00,100 --> 00:22:02,600
我怎么样去添加另外的动作过程呢？
How do I--how do I add another action procedure?

339
00:22:05,510 --> 00:22:09,360
最后 以 DISPATCH 过程为返回值 返回
And I'm going to return that dispatch, that procedure as a value.

340
00:22:09,940 --> 00:22:11,872
因此 我所构造的电线
So the wire that I've constructed

341
00:22:12,000 --> 00:22:13,552
是一种可以接收消息的对象
is a message accepting object

342
00:22:14,256 --> 00:22:16,016
它接收的消息类似于
which accepts a message like, like

343
00:22:16,448 --> 00:22:18,368
“你的哪个方法可以用来添加动作过程？”
what's your method of adding action procedures?

344
00:22:19,920 --> 00:22:21,008
它返回一个过程
That it'll give me a procedure,

345
00:22:21,640 --> 00:22:23,056
它返回 ADD-ACTION-PROCUDURE
which is the add action procedure,

346
00:22:23,072 --> 00:22:26,540
我可以将其应用在一个动作过程上
which I can then apply to an action procedure

347
00:22:27,056 --> 00:22:29,010
从而实现将一个动作过程加入电线的 AP 表中
to create another action procedure in the wire.

348
00:22:31,620 --> 00:22:32,820
这是一种权限
So that's a permission.

349
00:22:33,200 --> 00:22:36,080
给予你了一种去改变自身 AP 表的权限
So it's given me permission to change your action procedures.

350
00:22:37,824 --> 00:22:40,160
实际上 你可以在这里看到
And in fact, you can see that over here.

351
00:22:41,710 --> 00:22:42,320
下一张幻灯片
Next slide.

352
00:22:43,536 --> 00:22:43,824
噢
Ah.

353
00:22:47,760 --> 00:22:49,120
没什么有意思的
This is nothing very interesting.

354
00:22:49,120 --> 00:22:50,656
CALL-EACH 调用每个动作过程
The call each of the action procedures

355
00:22:50,896 --> 00:22:52,576
这只是对一个表不断做 CDR
is just a CDRing down a list.

356
00:22:52,736 --> 00:22:54,608
没什么好说的
And I'm not going to even talk about that anymore.

357
00:22:54,990 --> 00:22:56,256
我们早就知道了
We're too advanced for that.

358
00:22:57,560 --> 00:23:00,672
然而 如果我想知道线路上的信号值
However, if I want to get a signal from a wire,

359
00:23:01,024 --> 00:23:02,544
我询问该线路：你的 --
I ask the wire-- which is,

360
00:23:02,544 --> 00:23:03,090
回想一下 什么是线路？
what is the wire?

361
00:23:03,090 --> 00:23:05,408
线路对象只是在创建它时所返回的分派过程而已
The wire is the dispatch returned by creating the wire.

362
00:23:05,860 --> 00:23:06,480
只是一个过程
It's a procedure.

363
00:23:06,830 --> 00:23:12,272
我向该分派器发送一个消息 'GET-SIGNAL
I call that dispatch on the message get-signal.

364
00:23:12,912 --> 00:23:15,408
实际得到的是一个方法 用于取得线路信号值
And what I should expect to get is a method of getting a signal.

365
00:23:16,900 --> 00:23:17,968
进一步 我就可以得到信号值
Or actually, I get the signal.

366
00:23:19,220 --> 00:23:20,528
如果我想要设置一个信号值
If I want to set a signal,

367
00:23:22,656 --> 00:23:23,968
我想要改变一个信号值
I want to change a signal,

368
00:23:24,512 --> 00:23:26,768
我要做的是
then what I'm going to do

369
00:23:26,928 --> 00:23:29,696
以一个线路和信号的新值作为参数
is take a wire as an argument and a new value for the signal,

370
00:23:30,016 --> 00:23:32,432
我向线路请求权限 来设置它的信号值
I would ask the wire for permission to set the signal

371
00:23:32,848 --> 00:23:37,616
我会用该权限 -- 也就是一个过程 -- 应用在一个新值上
and use that permission, which is a procedure, on the new value.

372
00:23:38,700 --> 00:23:40,512
我们再过来看投影
And if we go back to the overhead here,

373
00:23:41,648 --> 00:23:43,248
好的 谢谢
Okay, thank you,

374
00:23:44,208 --> 00:23:45,632
我们看这里的投影
we go back to the overhead here,

375
00:23:45,920 --> 00:23:48,752
我们看到 如果我请求设置信号的方法
we see that the method-- if I ask for the method of setting the signal,

376
00:23:49,344 --> 00:23:50,448
也就是这段代码
that's over here,

377
00:23:52,256 --> 00:23:55,696
返回的是一个定义在线路内部的 SET-MY-SIGNAL! 方法
it's set-my-signal, a procedure that's defined inside the wire,

378
00:23:56,256 --> 00:23:57,696
回过头来看它的定义
which if we look over here

379
00:23:58,720 --> 00:23:59,744
它的定义是
is the thing that says

380
00:24:00,432 --> 00:24:02,688
将我的一个内部变量 SIGNAL 的值设为
set my internal value called the signal,

381
00:24:02,736 --> 00:24:05,504
这个内部变量 用于存储信号值
my internal variable, which is the signal,

382
00:24:07,616 --> 00:24:10,030
将其值设为通过参数传递的 NEW
to the new value, which is passed to me as an argument,

383
00:24:10,784 --> 00:24:13,010
然后调用 AP 表中的过程 来唤醒它们
and then call each of the action procedures waking them up.

384
00:24:16,340 --> 00:24:16,992
非常简单
Very simple.

385
00:24:19,248 --> 00:24:20,768
回头来看刚才的幻灯片
Ok, Going back to that slide,

386
00:24:22,480 --> 00:24:24,320
还有最后一点
we also have the one last thing--

387
00:24:24,368 --> 00:24:27,310
我想你们现在应该很轻易地就能理解了
which I suppose now you can easily work out for yourself--

388
00:24:27,776 --> 00:24:29,152
关于我们如何添加新的动作过程
is the way you add an action.

389
00:24:30,100 --> 00:24:35,184
我们需要 WIRE 和 ACTION-PROC两个参数
You take a wire--a wire and an action procedure.

390
00:24:36,470 --> 00:24:39,312
然后请求添加动作过程的权限
And I ask the wire for permission to add an action.

391
00:24:40,050 --> 00:24:44,224
得到权限后 用该权限去添加新的动作过程
Getting that permission, I use that permission to give it an action procedure.

392
00:24:45,840 --> 00:24:47,088
这就是整个“电线”对象 #TBD
So that's a real object.

393
00:24:48,570 --> 00:24:50,320
还有些细节
There's a few more details about this.

394
00:24:52,460 --> 00:24:58,390
比如 我怎么来控制它？
For example, how am I going to control this thing?

395
00:24:58,390 --> 00:24:59,696
这些延时怎么实现？
How do I do these delays?

396
00:25:00,992 --> 00:25:02,540
我们来快速过一遍
Okay? Let's look at that for a second.

397
00:25:05,504 --> 00:25:07,984
下一张
The next one here.

398
00:25:08,360 --> 00:25:08,880
我们来看看
Let's see.

399
00:25:09,570 --> 00:25:14,176
我们细看与门、或门的定义
We know when we looked at the and-gate or the not-gate

400
00:25:15,312 --> 00:25:17,008
会发现当输入信号改变时
that when a signal changed on the input,

401
00:25:17,248 --> 00:25:18,192
会有“延时”
there was a delay.

402
00:25:18,770 --> 00:25:21,248
然后它将调用过程
And then it was going to call the procedure,

403
00:25:21,632 --> 00:25:23,008
来改变输出
which was going to change the output.

404
00:25:26,040 --> 00:25:27,920
这个要如何实现？
Well, how are we going to do this?

405
00:25:28,120 --> 00:25:29,920
我们将要建立一种机制
We're going to make up some mechanism,

406
00:25:30,304 --> 00:25:32,000
一种相当复杂的机制
a fairly complicated mechanism at that,

407
00:25:32,336 --> 00:25:33,760
我们得非常细心地来看
which we're going to have to be very careful about.

408
00:25:34,720 --> 00:25:37,232
一段延时之后 我们将执行一个动作
But after a delay, we're going to do an action.

409
00:25:37,390 --> 00:25:38,128
DELAY 是一个数
A delay is a number,

410
00:25:38,160 --> 00:25:39,230
而 ACTION 是一个过程
and an action is a procedure.

411
00:25:40,590 --> 00:25:43,728
我们引入一种称为 THE-AGENDA 的特殊数据结构
What that's going to be is they're going to have a special structure called an agenda,

412
00:25:45,504 --> 00:25:48,800
用于组织时间与动作
which is a thing that organizes time and actions.

413
00:25:49,510 --> 00:25:50,880
一会儿再来自习研究
And we're going to see that in a while.

414
00:25:50,880 --> 00:25:52,544
先把这里说完
I don't want to get into that right now.

415
00:25:53,070 --> 00:25:58,288
THE-AGENDA 记录下来动作在未来执行的时刻
But the agenda has a moment at which--at which something happens.

416
00:25:59,130 --> 00:26:02,464
我们把它设定在未来的某个时刻
We're setting up for later at some moment,

417
00:26:02,510 --> 00:26:05,680
也就是在 CURRENT-TIME + DELAT 的时间之后
which is the sum of the time, which is the delay time plus the current time,

418
00:26:05,696 --> 00:26:07,130
触发关联的动作
which the agenda thinks is now.

419
00:26:09,024 --> 00:26:10,560
我们把准备好要执行的动作
We're going to set up to do this action,

420
00:26:11,024 --> 00:26:12,400
添加入 THE-AGENDA 中
and add that to the agenda.

421
00:26:15,280 --> 00:26:18,032
要使这个“机器”运行起来并不困难
And the way this machine will now run is very simple.

422
00:26:18,660 --> 00:26:21,488
我们利用这个 PROPAGATE 过程来完成这件事
We have a thing called propagate, which is the way things run.

423
00:26:22,710 --> 00:26:25,952
如果 THE-AGENDA 为空 就没有要做的
If the agenda is empty, we're done--if there's nothing more to be done.

424
00:26:27,440 --> 00:26:28,160
否则
Otherwise,

425
00:26:29,760 --> 00:26:31,536
我们就取出THE-AGENDA的第一个元素
we're going to take the first item off the agenda,

426
00:26:31,712 --> 00:26:33,340
它是一个无参过程
and that's a procedure of no arguments.

427
00:26:34,200 --> 00:26:36,030
所以这里有额外的括号
So that we're going to see extra parentheses here.

428
00:26:36,030 --> 00:26:37,856
我们对其进行无参调用
We call that on no arguments.

429
00:26:39,190 --> 00:26:40,176
这就执行了之前存入的动作
That takes the action.

430
00:26:42,200 --> 00:26:44,176
然后我们从 THE-AGENDA 中删除第一个元素
Then we remove that first item from the agenda,

431
00:26:44,592 --> 00:26:46,144
然后再进入传播循环
and we go around the propagation loop.

432
00:26:48,912 --> 00:26:50,750
这就是整体的结构
So that's the overall structure of this thing.

433
00:26:53,380 --> 00:26:55,936
还有点其它的
Now, there's a, a few other things we can look at.

434
00:26:57,430 --> 00:27:00,016
现在 我们来看看 THE-AGENDA 的内部结构
And then we're going to look into the agenda a little while from now.

435
00:27:00,576 --> 00:27:01,552
请看投影仪
Now the overhead again.

436
00:27:02,800 --> 00:27:04,672
#TBD
Well, in order to set this thing going,

437
00:27:04,672 --> 00:27:07,410
#TBD
I just want to show you some behavior out of this simulator.

438
00:27:07,856 --> 00:27:09,936
你们可能觉得这个模拟器太简陋了
By the way, you may think this simulator is very simple,

439
00:27:10,400 --> 00:27:12,016
甚至你们认为它根本没什么用
and probably too simple to be useful.

440
00:27:12,576 --> 00:27:13,760
而实际上是
The fact of the matter is

441
00:27:13,984 --> 00:27:15,392
这样的模拟器曾被用于
that this simulator has been used

442
00:27:15,728 --> 00:27:17,440
操纵相当大型的计算机
to manufacture a fairly large computer.

443
00:27:18,680 --> 00:27:20,640
那是一个真实的事例
So this is a real live example.

444
00:27:22,360 --> 00:27:24,064
当然 并不完全是这里的这个模拟器
Actually, not exactly this simulator，

445
00:27:24,064 --> 00:27:25,392
我会告诉你它们的区别
because I'll tell you the difference.

446
00:27:25,840 --> 00:27:28,704
区别就是 操纵大型机的模拟器有更多的基本元素
The difference is that there were many more different kinds of primitives.

447
00:27:29,820 --> 00:27:32,224
不只是有非门 与门之类的
There's not just the word inverter or and-gate.

448
00:27:33,200 --> 00:27:35,728
还有边缘触发器
There were things like edge-triggered,

449
00:27:36,256 --> 00:27:39,888
翻转触发器 锁存器
There were things like edge-triggered, flip-flops,

450
00:27:40,704 --> 00:27:44,520
电平触发器 加法器等等之类的
transparent latches, and adders, and things like that.

451
00:27:45,170 --> 00:27:47,312
困难之处在于
And the difficulty with that

452
00:27:47,456 --> 00:27:50,864
困难之处在于需要很多页的文档
is there's pages and pages of the definitions of all these primitives

453
00:27:51,200 --> 00:27:52,896
来描述这些基本元素
with numbers like LS04.

454
00:27:54,690 --> 00:27:56,740
同时它们还有很多的参数
And then there's many more parameters for them.

455
00:27:56,740 --> 00:27:57,984
不是只有一个延时这么简单
It's not just one delay.

456
00:27:58,480 --> 00:28:00,816
还有建立时间 维持时间之类的 #TBD
There's things like set up times and hold times and all that.

457
00:28:01,220 --> 00:28:03,408
但是 如果不算上那部分的复杂度
But with the exception of that part of the complexity,

458
00:28:03,820 --> 00:28:08,208
我们用来构建真实计算机的模拟器的结构
the structure of the simulator that we use for building a real computer,

459
00:28:09,088 --> 00:28:12,896
跟你们在这里看到的的是一致的
that works is exactly what you're seeing here.

460
00:28:15,110 --> 00:28:19,270
无论如何 这里都是一些简单的东西
Well in any case, what we have here is a few simple things.

461
00:28:19,270 --> 00:28:22,592
像这个 设置非门的延时时间 构建一个 AGENDA
Like, there's inverter delays being set up and making a new agenda.

462
00:28:23,030 --> 00:28:25,520
我们可以构建一些输入（线路）
And then we can make some inputs.

463
00:28:26,032 --> 00:28:29,184
这里的四条线路分别是：INPUT-1 INPUT-2 SUM CARRY
Ok? There's input-1, input-2, a sum and a carry, which are wires.

464
00:28:29,460 --> 00:28:31,888
我将要放置一种被称为“探针”的特殊对象
I'm going to put a special kind of object called a probe

465
00:28:32,512 --> 00:28:34,640
放在一些线路上
onto, onto some of the wires,

466
00:28:34,976 --> 00:28:36,240
放在 SUM 和 CARRY 上
onto sum and onto carry.

467
00:28:37,230 --> 00:28:40,560
探针是一种对象 它可以--
A probe is a, can object that has the property

468
00:28:40,704 --> 00:28:43,600
当你改变它所附着线路的信号时
that when you change a wire it's attached to,

469
00:28:43,728 --> 00:28:44,832
它会输出一条消息
it types out a message.

470
00:28:46,120 --> 00:28:46,928
这很容易实现
It's an easy thing to do.

471
00:28:48,448 --> 00:28:49,520
一旦我们设置好它们
And then once we have that,

472
00:28:49,552 --> 00:28:51,456
当你在放置探针的时候
of course, then when you put the probe on,

473
00:28:51,450 --> 00:28:52,416
它首先会输出
the first thing it does, it says,

474
00:28:52,672 --> 00:28:56,016
SUM 在 0 时刻的值为 0
the current value of the sum at time 0 is 0

475
00:28:57,296 --> 00:28:58,432
这个我已经注意到了
And because I just noticed it.

476
00:28:59,400 --> 00:29:04,752
CARRY 在 0 时刻的值也是 0
And the value of the carry at time 0, this is the time, is 0.

477
00:29:06,048 --> 00:29:09,280
我们继续来构建更多结构
And then we go off and we build some structure.

478
00:29:09,620 --> 00:29:12,288
比如 可以像这里一样构建一种结构
Like, we can build a structure here that says

479
00:29:14,064 --> 00:29:18,208
用 INPUT-1 INPUT-2 SUM 和 CARRY 组成一个半加器
you have a half-adder on input-1, input-2, sum, and carry.

480
00:29:18,420 --> 00:29:20,420
然后我们把 INPUT-1 上的信号变为1
And we're going to set the signal on input-1 to 1.

481
00:29:20,624 --> 00:29:21,728
然后开始传播
We do some propagation.

482
00:29:21,880 --> 00:29:22,848
在时刻 8 的时候
At time 8,

483
00:29:23,904 --> 00:29:26,128
如果你想的话 也可以单步跟踪传播过程
which you could see going through this thing if you wanted to,

484
00:29:26,528 --> 00:29:29,200
SUM的值变为 1
the new value of sum became 1.

485
00:29:29,520 --> 00:29:30,448
然后就结束了
And the thing says I'm done.

486
00:29:31,168 --> 00:29:32,256
好像没什么意思
That wasn't very interesting.

487
00:29:32,630 --> 00:29:33,904
我们还可以设置信号
But we can send it some more signals.

488
00:29:34,064 --> 00:29:36,736
把 INPUT-2 也变为 1
Like, we set-signal on input-2 to be one.

489
00:29:36,890 --> 00:29:38,096
如果再进行传播
And at that time if we propagate,

490
00:29:38,368 --> 00:29:39,952
在时刻 11
then it carried at 11,

491
00:29:40,128 --> 00:29:41,424
CARRY 变为 1
the carry becomes 1,

492
00:29:41,552 --> 00:29:44,192
在时刻16 SUM 变为 0
and at 16, the sum's new value becomes 0.

493
00:29:45,392 --> 00:29:48,990
#TBD
And you might want to work out that, if you like, about the digital circuitry.

494
00:29:48,990 --> 00:29:50,128
它确实是这个结果
It's true, and it works.

495
00:29:50,620 --> 00:29:51,535
也并没有什么特别的
And it's not very interesting.

496
00:29:51,530 --> 00:29:54,128
但是却清楚地表明了这一些都是如何运作的
But that's the kind of behavior we get out of this thing.

497
00:30:01,830 --> 00:30:03,296
我现在给你们展示的是
So what I've shown you right now

498
00:30:03,488 --> 00:30:05,520
一种宏观的图景
is a large-scale picture,

499
00:30:06,600 --> 00:30:08,560
你如何在一个很大的规模中
how you, at a bigger, big scale,

500
00:30:08,720 --> 00:30:12,040
你何去实现事件驱动的模拟
you implement an event-driven simulation of some sort.

501
00:30:13,296 --> 00:30:14,560
你应该如何去组织
And how you might organize it

502
00:30:14,880 --> 00:30:16,704
来获得良好的层次性结构
to have nice hierarchical structure

503
00:30:16,992 --> 00:30:21,008
使得你可以构建可具体化的抽象盒子
allowing you to build abstract boxes that you can instantiate.

504
00:30:21,568 --> 00:30:24,960
但我还没有告诉你 AGENDA 是如何运作的
But I haven't told you any of the details about how this agenda and things like that work.

505
00:30:25,780 --> 00:30:26,544
下一小节再说
That we'll do next.

506
00:30:28,630 --> 00:30:32,944
这将涉及到一些关于数据变化之类的事情
And that's going to involve change and mutation of data and things like that.

507
00:30:34,310 --> 00:30:35,860
在我继续之前 有什么问题吗？
Are there any questions now, before I go on?

508
00:30:47,160 --> 00:30:47,550
没有的话
Thank you.

509
00:30:47,550 --> 00:30:48,288
休息一下
Let's take a break.

510
00:31:28,940 --> 00:31:35,060
我们已经做了一个模拟器
Well, we've been making a simulation.

511
00:31:35,392 --> 00:31:37,776
这是一种事件驱动的模拟
And the simulation is an event-driven simulation

512
00:31:38,176 --> 00:31:42,752
其中 计算机中的对象与现实中的对象一一对应
where the objects in the world are the objects in the computer.

513
00:31:43,920 --> 00:31:47,280
现实世界中按时发生的状态改变
And the changes of state that are happening in the world in time

514
00:31:47,984 --> 00:31:50,832
#TBD
are organized to be time in the computer,

515
00:31:52,992 --> 00:31:56,048
如果现实中某件事后于另一件事发生
so that if something happens after something else in the world,

516
00:31:56,460 --> 00:31:57,968
#TBD
then we have it happen after,

517
00:31:58,896 --> 00:32:02,256
#TBD
after the corresponding events happen in the same order in the computer.

518
00:32:04,420 --> 00:32:07,168
排列这些时间 就是我们要用到赋值的地方
That's where we have assignments, when we make that alignment.

519
00:32:08,220 --> 00:32:11,216
现在我要介绍一种方法来组织时间
Right now I want to show you a way of organizing time,

520
00:32:11,808 --> 00:32:14,864
AGENDA -- 或者有时候所谓的“优先队列”
which is an agenda or priority queue, it's sometimes called.

521
00:32:16,040 --> 00:32:21,230
这样做之前 先来了解点别的 #TBD
We'll do some--we'll do a little bit of just understanding what are the things we need to be able to do to make agendas.

522
00:32:28,330 --> 00:32:31,280
首先我要在这里写下一些
And so we're going to have--and so right now over here, I'm going to write down a bunch

523
00:32:31,392 --> 00:32:33,888
用于操作AGENDA的基本运算
of primitive operations for manipulating agendas.

524
00:32:35,960 --> 00:32:37,952
我不会给出具体代码
I'm not going to show you the code for them

525
00:32:38,144 --> 00:32:39,584
因为它们都非常简单
because they're all very simple,

526
00:32:40,320 --> 00:32:42,608
而且你们手上也有
Iand you've got listings of all that anyway.

527
00:32:43,680 --> 00:32:44,380
有哪些运算呢？
So what do we have?

528
00:32:44,380 --> 00:32:53,504
MAKE-AGENDA 可以新建一个 AGENDA
We have things like make-agenda which produces a new agenda.

529
00:32:59,860 --> 00:33:01,776
CURRENT-TIME 可以获得一个 AGENDA 的当前时间
We can ask--we get the current-time of an agenda,

530
00:33:07,472 --> 00:33:12,800
返回一个数 -- 也就是当前时间
of an agenda, which gives me a number, a time.

531
00:33:16,990 --> 00:33:21,376
EMPTY-AGENDA? 可用于判断一个 AGENDA 是否为空
We can get--we can ask whether an agenda is empty, empty-agenda.

532
00:33:30,200 --> 00:33:32,570
返回 TRUE 或 FALSE
And that produces either a true or a false.

533
00:33:42,720 --> 00:33:44,720
我们也可以向 AGENDA 中添加对象
We can add an object to an agenda.

534
00:33:52,710 --> 00:33:56,064
实际上 向 AGENDA 中添加的是一个运算 -- 或者说是需要完成的操作
Actually, what we add to an agenda is an operation--an action to be done.

535
00:33:56,910 --> 00:33:58,144
它需要时间 TIME
And that takes a time,

536
00:33:59,632 --> 00:34:00,560
待添加的动作 ACTION
the action itself,

537
00:34:02,864 --> 00:34:04,640
以及 AGENDA 本身
and the agenda I want to add it to.

538
00:34:07,584 --> 00:34:10,256
它把 ACTION 放入 AGENDA 中合适的地方
OK? That inserts it in the appropriate place in the agenda.

539
00:34:10,710 --> 00:34:12,736
FIRST-ITEM 用于从 AGENDA 取出第一个事项
I can get the first item off an agenda,

540
00:34:14,240 --> 00:34:15,392
那是我首先需要做的事情
the first thing I have to do,

541
00:34:21,840 --> 00:34:23,840
该事项是一个动作
which is going to give me an action.

542
00:34:26,464 --> 00:34:28,736
我还可以把第一个事项从 AGENDA 中移除
And I can remove the first item from an agenda.

543
00:34:29,540 --> 00:34:31,168
这是操作 AGENDA 的一个必要运算
That's what I have to be able to do with agendas.

544
00:34:31,409 --> 00:34:33,020
这个运算实现起来非常繁杂
That is a big complicated mess.

545
00:34:42,530 --> 00:34:43,360
从 AGENDA 中移除
From an agenda.

546
00:34:45,984 --> 00:34:49,856
现在我们来看如何具体组织数据结构
Well, let's see how we can organize this thing as a data structure a bit.

547
00:34:52,960 --> 00:34:56,048
AGENDA 应该是一种表
Well, an agenda is going to be some kind of list.

548
00:34:58,432 --> 00:35:01,200
一种可修改的表
And it's going to be a list that I'm going to have to be able to modify.

549
00:35:01,570 --> 00:35:04,032
因为我们要向其中添加元素
So we have to talk about modifying of lists,

550
00:35:05,808 --> 00:35:06,896
删除元素等等
because I'm going to add things to it,

551
00:35:07,776 --> 00:35:10,272
所以我们需要一种可修改的表
and delete things from it, and things like that.

552
00:35:11,070 --> 00:35:12,512
它通过时间组织起来
It's organized by time.

553
00:35:13,820 --> 00:35:15,570
让它有序 也许会有益处
It's probably good to keep it in sorted order.

554
00:35:18,330 --> 00:35:20,880
但是也有可能同一时间会发生很多事
But sometimes there are lots of things that happen at the same time

555
00:35:22,048 --> 00:35:23,420
或者说几乎同时
approximate same time.

556
00:35:23,808 --> 00:35:27,520
因此我们要按发生时间为事件分组
What I have to do is say, group things by the time at which they're supposed to happen.

557
00:35:29,040 --> 00:35:31,616
所以我要把 AGENDA 组织成由 SEGMENT 构成的表
So I'm going to make an agenda as a list of segments.

558
00:35:32,780 --> 00:35:35,696
我来画一下这个结构
And so I'm going to draw you a data structure for an agenda,

559
00:35:36,688 --> 00:35:37,936
方便理解
a perfectly reasonable one.

560
00:35:39,620 --> 00:35:40,496
这是一个 AGENDA
Here's an agenda.

561
00:35:41,110 --> 00:35:42,870
以一个名字开始
It's a thing that begins with a name.

562
00:35:47,856 --> 00:35:50,192
在画具体的表结构之前先画它 #TBD
I'm going to do it right now out of list structure.

563
00:35:52,608 --> 00:35:53,392
这是它的头部
It's got a header.

564
00:35:54,144 --> 00:35:55,440
这个头部的存在也是很必要的
There's a reason for the header.

565
00:35:55,840 --> 00:35:57,630
待会你就会知道
We're going to see the reason soon.

566
00:36:00,680 --> 00:36:03,408
再画一个 SEGMENT
And it will have a segment. We will have--

567
00:36:03,968 --> 00:36:05,620
这是一个由 SEGMENT 构成的表
It will have--it will be a list of segments.

568
00:36:08,310 --> 00:36:10,544
假设这个 AGENDA 有两个 SEGMENT
Supposing this agenda has two segments,

569
00:36:11,584 --> 00:36:15,072
不断对这个表取 CAR 即可得到
OK, they're the car's-- successive car's of this list.

570
00:36:16,416 --> 00:36:20,576
每个 SEGMENT 都有一个时间
Each segment is going to have a time--

571
00:36:24,208 --> 00:36:26,640
比如说这里是10
say for example, 10--

572
00:36:26,832 --> 00:36:30,512
也就是说 这个 SEGMENT 里的事件发生在10时刻
that says that the things that happen in this segment are at time 10.

573
00:36:33,160 --> 00:36:36,528
这里是另外一种数据结构
And what I'm going to have in here is another data structure

574
00:36:36,560 --> 00:36:38,010
我先不具体描述
which I'm not going to describe,

575
00:36:38,496 --> 00:36:41,088
它是一个队列 表示在10时刻要做的事
which is a queue of things to do at time 10.

576
00:36:42,240 --> 00:36:43,330
它是一个队列
It's a queue.

577
00:36:43,330 --> 00:36:44,704
一会儿再细说
And we'll talk about that in a second.

578
00:36:45,200 --> 00:36:50,352
不过抽象地看 队列就是一个由在固定时间要做的事 所构成的表
But abstractly, the queue is just a list of things to do at a particular time.

579
00:36:50,400 --> 00:36:52,048
我可以向其中添加其它要做的事
And I can add things to a queue.

580
00:36:53,100 --> 00:36:53,808
这是一个队列
This is a queue.

581
00:36:56,140 --> 00:36:59,115
这个是时间 这个是 SEGMENT
There's a time, there's a segment.

582
00:37:03,232 --> 00:37:06,368
在这个 AGENDA 中 还有另一个 SEGMENT
Now, I may have another segment in this agenda.

583
00:37:08,940 --> 00:37:11,200
假设它在30时刻发生
Supposing this is stuff that happens at time 30.

584
00:37:13,500 --> 00:37:15,920
类似地 它也有一个队列
It has, of course, another queue

585
00:37:16,928 --> 00:37:20,240
里面是在30时刻要去做的事
of things that are queued up to be done at time 30.

586
00:37:23,210 --> 00:37:25,664
当然 我们的 AGENDA 还需要支持其它操作
Well, there are various things I have to be able to do to an agenda.

587
00:37:27,090 --> 00:37:29,200
假设我想将一个在10时刻发生的事
Supposing I want to add to an agenda

588
00:37:29,472 --> 00:37:31,616
添加到 AGENDA 中
another thing to be done at time 10.

589
00:37:33,030 --> 00:37:34,160
这并不难
Well, that's not very hard.

590
00:37:34,700 --> 00:37:38,656
我遍历到这里 找到时刻是10的 SEGMENT
I'm going to walk down here, looking for the segment of time 10.

591
00:37:39,730 --> 00:37:42,144
这样的 SEGMENT 也可能不存在
It is possible that there is no segment of time 10.

592
00:37:42,930 --> 00:37:44,560
一会儿再考虑这种情况
We'll cover that case in a second.

593
00:37:45,420 --> 00:37:47,568
如果我找到了时刻为10的 SEGMENT
But if I find a segment of time 10,

594
00:37:47,872 --> 00:37:50,432
如果我想要把一个事情放入其中
then if I want to add another thing to be done at time 10,

595
00:37:50,560 --> 00:37:52,160
我只要增加该队列即可
I just increase that queue--

596
00:37:53,856 --> 00:37:56,224
尽管要怎样加入队列并不明显 #TBD
"just increase" isn't such an obvious idea.

597
00:37:56,576 --> 00:37:59,264
我在这里添加需要在那时做的事
But I increase the things to be done at that time.

598
00:38:01,430 --> 00:38:04,256
现在 假设我想在时刻20做点什么
Now, supposing I want to add something to be done at time 20.

599
00:38:05,312 --> 00:38:07,904
然而并没有时刻是20的segment
There is no segment for time 20.

600
00:38:08,992 --> 00:38:10,640
我不得不构造一个新的 SEGMENT
I'm going to have to create a new segment.

601
00:38:11,340 --> 00:38:15,648
我想把这个segment放在10与30之间
I want my time 20 segment to exist between time 10 and time 30.

602
00:38:17,610 --> 00:38:20,170
这着实要花点功夫
Well, that takes a little work.

603
00:38:20,170 --> 00:38:21,525
先用CONS
I'm going to have to do a CONS.

604
00:38:24,260 --> 00:38:29,940
构建一个新的segment
I'm going to have to make a new element of the agenda list--list of segments.

605
00:38:33,600 --> 00:38:35,400
这里的连接必须要变
I'm going to have to change.

606
00:38:35,400 --> 00:38:37,540
就像这样
Here's change.

607
00:38:37,540 --> 00:38:56,657
把segment 10的CDR指向新的segment 20，新的segment 20的CDR指向segment 30
I'm going to have to change the CDR of the CDR of the agenda to point that a new CONS of the new segment and the CDR of the CDR of the CDR of the agenda, the CD-D-D-DR.

608
00:38:56,657 --> 00:39:06,290
这个segment的时刻为20，队列只有一件事要做
And this is going to have a new segment now of time 20 with its own queue, which now has one element in it.

609
00:39:10,730 --> 00:39:20,770
如果我想在后面添加点什么，就更改这个CDR指向要添加的东西
If I wanted to add something at the end, I'm going to have to replace the CDR of this, of this list with something.

610
00:39:20,770 --> 00:39:24,040
必须对数据结构进行修改
We're going to have to change that piece of data structure.

611
00:39:24,040 --> 00:39:27,210
因此我需要新的基础操作
So I'm going to need new primitives for doing this.

612
00:39:27,210 --> 00:39:29,550
因为原有的基础操作达不到这一点
But I'm just showing you why I need them.

613
00:39:29,550 --> 00:39:49,400
如果我想在时刻5做点什么事，按时间顺序来看，就得改变这里的CDR，这也就是我留了一个“头”的原因，可以方便的进行在队列头插入的操作
And finally, if I wanted to add a thing to be done at time 5, I'm going to have to change this one, because I'm going to have to add it in over here, which is why I planned ahead and had a header cell, which has a place.

614
00:39:49,400 --> 00:39:53,420
如果我想做些改变
If I'm going to change things, I have to have places for the change.

615
00:39:53,420 --> 00:39:58,600
就必须找准哪些地方需要修改
I have to have a place to make the change.

616
00:39:58,600 --> 00:40:02,540
从agenda中删除东西并不困难
If I remove things from the agenda, that's not so hard.

617
00:40:02,540 --> 00:40:11,220
删除操作非常简单，我只讲一种情况，先找到第一个segment
Removing them from the beginning is pretty easy, which is the only case I have. I can go looking for the first, the first segment.

618
00:40:11,220 --> 00:40:14,510
判断队列是否为空
I see if it has a non-empty queue.

619
00:40:14,510 --> 00:40:20,100
如果队列不是空的，就把要移除的事情从队列中删掉
If it has a non-empty queue, well, I'm going to delete one element from the queue, like that.

620
00:40:20,100 --> 00:40:24,220
如果这时队列变为空的，就还要继续把segment删掉
If the queue ever becomes empty, then I have to delete the whole segment.

621
00:40:24,220 --> 00:40:28,220
这里，把“头”的CDR指向这里
And then this, this changes to point to here.

622
00:40:28,220 --> 00:40:36,440
这个数据结构操作起来很复杂，很无趣
So it's quite a complicated data structure manipulation going on, the details of which are not really very exciting.

623
00:40:36,440 --> 00:40:38,920
现在我们来聊聊队列
Now, let's talk about queues.

624
00:40:38,920 --> 00:40:41,160
它们很相似
They're similar.

625
00:40:41,160 --> 00:40:44,340
每一个segment都有一个队列
Because each of these agendas has a queue in it.

626
00:40:44,340 --> 00:40:45,590
队列是什么？
What's a queue?

627
00:40:49,079 --> 00:40:52,350
一个队列有这些基础操作
A queue is going to have the following primitive operations.

628
00:40:52,350 --> 00:41:02,170
MAKE-QUEUE 构建一个新队列
To make a queue, this gives me a new queue.

629
00:41:07,274 --> 00:41:16,850
INSERT-QUEUE！ 向队列中插入新元素
I'm going to have to be able to insert into a queue a new item.

630
00:41:24,510 --> 00:41:28,740
DELETE-QUEUE！ 从队列中删除元素
I'm going to have to be able to delete from a queue the first item in the queue.

631
00:41:39,988 --> 00:41:52,890
FRONT-QUEUE 查看队列中第一个元素
And I want to be able to get the first thing in the queue from some queue.

632
00:41:52,890 --> 00:41:55,140
还需要检测队列是否为空
I also have to be able to test whether a queue is empty.

633
00:42:07,110 --> 00:42:15,120
如果你以后要发明些类似的基础操作，我希望你要注意下命名约定
And when you invent things like this, I want you to be very careful to use the kinds of conventions I use for naming things.

634
00:42:15,120 --> 00:42:19,870
有改动的操作加上！，判断的谓词用？
Notice that I'm careful to say these change something and that tests it.

635
00:42:19,870 --> 00:42:24,335
看起来，和这边的好像差不多
And presumably, I did the same thing over here.

636
00:42:24,335 --> 00:42:29,240
嗯，这里也需要一个是否为空的检测
OK, and there should be an empty test over here.

637
00:42:29,240 --> 00:42:31,720
好的，我要如何构建一个队列呢？
OK, well, how would I make a queue?

638
00:42:31,720 --> 00:42:37,840
队列是一个后进先出的结构
A queue wants to be something I can add to at the end of, and pick up the thing at the beginning of.

639
00:42:37,840 --> 00:42:41,230
从队列头删除元素，向队列尾添加元素
I should be able to delete from the beginning and add to the end.

640
00:42:41,230 --> 00:42:43,740
我可以用一种很简单的结构来实现
Well, I'm going to show you a very simple structure for that.

641
00:42:43,740 --> 00:42:47,080
先有一个序对
We can make this out of CONSes as well.

642
00:42:47,080 --> 00:42:49,910
整个队列的开始
Here's a queue.

643
00:42:49,910 --> 00:42:59,610
这是一个队列“头”，包含一个头指针和一个尾指针
It has--it has a queue header, which contains two parts-- a front pointer and a rear pointer.

644
00:43:02,930 --> 00:43:09,000
假如队列一共两个元素
And here I have a queue with two items in it.

645
00:43:09,000 --> 00:43:12,095
第一个，值假定是1
The first item, I don't know, it's perhaps a 1.

646
00:43:12,095 --> 00:43:16,530
第二个假定是2吧
And the second item, I don't know, let's give it a 2.

647
00:43:21,160 --> 00:43:31,850
需要两个指针的原因在于，向尾部添加元素的时候，就不用一直CDR找到结尾这样费力
The reason why I want two pointers in here, a front pointer and a rear pointer, is so I can add to the end without having to chase down from the beginning.

648
00:43:31,850 --> 00:43:47,530
例如，我想要向队列添加入一个新元素，只需要先用CONS构建一个序对，假如值是3
So for example, if I wanted to add one more item to this queue, if I want to add on another item to be worried about later, all I have to do is make a CONS, which contains that item, say a 3.

649
00:43:47,530 --> 00:43:51,340
再添加到队列里
That's for inserting 3 into the queue.

650
00:43:51,340 --> 00:44:00,100
这里就需要把item 2的CDR指向item 3
Then I have to change this pointer here to here.

651
00:44:00,100 --> 00:44:04,320
尾指针也指到最后
And I have to change this one to point to the new rear.

652
00:44:09,120 --> 00:44:18,890
如果我想查看第一个元素，由头指针就可以轻易找到
If I wish to take the first element of the queue, the first item, I just go chasing down the front pointer until I find the first one and pick it up.

653
00:44:18,890 --> 00:44:27,450
如果想删除元素，只需要把头指针向后移到就行
If I wish to delete the first item from the queue, delete-queue, all I do is move the front pointer along this way.

654
00:44:27,450 --> 00:44:31,700
新的头指针指向这里
The new front of the queue is now this.

655
00:44:31,700 --> 00:44:34,390
所以队列比较简单
So queues are very simple too.

656
00:44:34,390 --> 00:44:41,350
我们需要一些另外的基础操作来支持这种修改操作
So what you see now is that I need a certain number of new primitive operations.

657
00:44:41,350 --> 00:44:42,560
我先列出它们的名字
And I'm going to give them some names.

658
00:44:42,560 --> 00:44:47,350
然后我们再来看它们是如何使用的
And then we're going to look into how they work, and how they're used.

659
00:44:47,350 --> 00:44:58,940
SET-CAR！ 改变一个序对的CAR为一个新值
We have set the CAR of some pair, or a thing produced by CONSing, to a new value.

660
00:45:02,370 --> 00:45:09,920
SET-CDR！和它类似
And set the CDR of a pair to a new value.

661
00:45:12,680 --> 00:45:16,030
现在来看看它们到底做了什么
And then we're going to look into how they work.

662
00:45:16,030 --> 00:45:20,960
我用SET-CAR！修改头指针的指向，删除第一个元素
I needed setting CAR over here to delete the first element of the queue.

663
00:45:20,960 --> 00:45:23,470
这是CAR，我把它SET为另的值
This is the CAR, and I had to set it.

664
00:45:23,470 --> 00:45:30,160
同理SET-CDR！修改尾指针的指向来添加元素
I had to be able to set the CDR to be able to move the rear pointer, or to be able to increment the queue here.

665
00:45:30,160 --> 00:45:35,515
全部的修改工作都是由SET-CAR！ SET-CDR！完成的
All of the operations I did were made out of those that I just showed you on the, on the last blackboard.

666
00:45:38,230 --> 00:45:38,430
非常完美
Good.

667
00:45:38,430 --> 00:45:40,357
先讲到这里，大家休息一下
Let's pause the time, and take a little break then.

668
00:46:38,346 --> 00:47:21,850
当我们讲到CONS的时候，我们提到了CONS的原则，(car (cons x y)) => x，(cdr (cons x y )) => y
When we originally introduced pairs made out of CONS, made by CONS, we only said a few axioms about them, which were of the form-- what were they-- for all X and Y, the CAR of the CONS of X and Y is X and the CDR of the CONS of X and Y is Y. Now, these say nothing about whether a CONS has an identity like a person.

669
00:47:21,850 --> 00:47:29,740
这个描述的有点抽象，CONS是由它组成的部分所组成的
In fact, all they say is something sort of abstract, that a CONS is the parts it's made out of.

670
00:47:29,740 --> 00:47:37,390
要是这样来看，如果两个CONS，它们两个的组成部分是相同的，从原则来看，这两个CONS就应该相同
And of course, two things are made out of the same parts, they're the same, at least from the point of view of these axioms.

671
00:47:37,390 --> 00:47:49,830
但是引入了赋值以后，数据变成了变量，值可以通过赋值来改变，比如用SET-CAR！ SET-CDR！，这样来看，这些原则好像没有把CONS描述清楚
But by introducing assignment-- in fact, mutable data is a kind of assignment, we have a set CAR and a set CDR-- by introducing those, these axioms no longer tell the whole story.

672
00:47:49,830 --> 00:47:53,250
但是这里写的也是对的
And they're still true if written exactly like this.

673
00:47:53,250 --> 00:47:56,070
只不过描述的不再完整
But they don't tell the whole story.

674
00:47:56,070 --> 00:48:10,090
如果我用SET-CAR！ SET-CDR！改变两个CONS，使它们的CAR和CDR都相同，这两个CONS是否是完全相同的？
Because if I'm going to set a particular CAR in a particular CONS, the questions are, well, is that setting all CARs and all CONSes of the same two things or not?

675
00:48:10,090 --> 00:48:21,570
假如我用CONS构建两个有理数，两个3/4
If I--if we use CONSes to make up things like rational numbers, or things like 3 over 4, supposing I had two three-fourths.

676
00:48:21,570 --> 00:48:25,340
这两个一样吗？还是不一样？
Are they the same one-- or are they different?

677
00:48:25,340 --> 00:48:27,860
当然，对于数字来说，这并不重要
Well, in the case of numbers, it doesn't matter.

678
00:48:27,860 --> 00:48:33,020
因为这两个有理数表示的大小是一样的，都是3/4
Because there's no meaning to changing the denominator of a number.

679
00:48:33,020 --> 00:48:36,840
你可以改变一个有理数的分母来使它们变的不一样
What you could do is make a number which has a different denominator.

680
00:48:36,840 --> 00:48:44,770
但是这看来很怪异，强制的改变分母使其两个有理数有区别，这也和数学上认知不符合
But the concept of changing a number which has to have a different denominator is sort of a very weird, and sort of not supported by what you think of as mathematics.

681
00:48:44,770 --> 00:48:53,690
但是，如果CONS表示的是现实世界中的物体，修改CAR就像剪掉你的指甲一样，是切实存在的
However, when these CONSes represent things in the physical world, then changing something like the CAR is like removing a piece of the fingernail.

682
00:48:53,690 --> 00:48:57,770
所以，每一个CONS都是不同的，它们有自己的身份
And so CONSes have an identity.

683
00:48:57,770 --> 00:49:01,280
我来先说明“身份”是什么意思
Let me show you what I mean about identity, first of all.

684
00:49:01,280 --> 00:49:04,320
来看些例子
Let's do some little example here.

685
00:49:04,320 --> 00:49:15,200
假如(define a (cons 1 2))
Supposing I define A to the CONS of 1 and 2.

686
00:49:18,040 --> 00:49:38,120
这是什么意思呢？在环境中的某处有一个符号a，它代表了一个序对，CAR指向1，CDR指向2
Well, what that means, first of all, is that somewhere in some environment I've made a symbol A to have a value which is a pair consisting of pointers to a 1 and a pointer to a 2, just like that.

687
00:49:38,120 --> 00:50:03,970
假设再定义一个b，(define b (cons a a))
Now, supposing I also say define B to be the CONS--  it doesn't matter, but I like it better, it's prettier-- of A and A.

688
00:50:03,970 --> 00:50:07,840
这里用了两次a
Well, first of all, I'm using the name A twice.

689
00:50:07,840 --> 00:50:11,300
现在就要考虑序对的身份问题了
At this moment, I'm going to think of CONSes as having identity.

690
00:50:11,300 --> 00:50:13,690
这两个a是一样的，是同一个东西
This is the same one.

691
00:50:13,690 --> 00:50:33,260
所以b是这样的一个序对，CAR与CDR都指向a，对于a来说，有三个别名都代表着它
And so what that means is I make another pair, which I'm going to call B. And it contains two pointers to A. At this point, I have three names for this object.

692
00:50:33,260 --> 00:50:34,790
a是一个
A is its name.

693
00:50:34,790 --> 00:50:37,230
(car b)是一个
The CAR of B is its name.

694
00:50:37,230 --> 00:50:39,360
(cdr b)也是一个
And the CDR of B is its name.

695
00:50:39,360 --> 00:50:41,150
都是这个序对的别名
It has several aliases, they're called.

696
00:50:44,230 --> 00:51:07,880
假设现在执行 (SET-CAR! (CAR B) 3)
Now, supposing I do something like set-the-CAR, the CAR of the CAR of B to 3.

697
00:51:12,750 --> 00:51:17,830
找到b的CAR
What that means is I find the CAR of B, that's this.

698
00:51:17,830 --> 00:51:20,935
把它的CAR设置为3
I set the CAR of that to be 3, changing this.

699
00:51:24,760 --> 00:51:35,340
这样我也就修改了a，现在调用(CAR A)来看一下结果
I've changed A. If I were to ask what's the CAR of A--of A now?

700
00:51:35,340 --> 00:51:45,290
结果是3，尽管上面定义a是(cons 1 2)
I would get out 3, even though here we see that A was the CONS of 1 and 2.

701
00:51:45,290 --> 00:51:48,400
我通过改变b而改变了a
I caused A to change by changing B.

702
00:51:48,400 --> 00:51:52,010
它们共享着一处数据
There is sharing here.

703
00:51:52,010 --> 00:51:54,240
有时候我们需要这样的结构
That's sometimes what we want.

704
00:51:54,240 --> 00:52:04,350
我们之前的队列，就是这样来组织的
Surely in the queues and things like that, that's exactly what we defined our--organized our data structures to facilitate-- sharing.

705
00:52:04,350 --> 00:52:25,190
但是对象之间不合理的共享与操作，是很多复杂系统中bug的来源。所以我们虽然使对象具有身份，可以用很多别名来共享，得到了不少的好处
But inadvertent sharing, unanticipated interactions between objects, is the source of most of the bugs that occur in complicated programs. So by introducing this possibility of things having identity and sharing and having multiple names for the same thing, we get a lot of power.

706
00:52:25,190 --> 00:52:28,640
但是同时也为此引出的bug而付出代价
But we're going to pay for it with lots of complexity and bugs.

707
00:52:32,190 --> 00:52:46,560
还看这里的这个例子，(CADR B)，看起来和(CAR B)没有一点关系
So also, for example, if I just looked at this just to drive that home, the CADR of B, which has nothing to do with even the CAR of B, apparently.

708
00:52:46,560 --> 00:52:49,350
但是它的值是什么？
The CADR of B, what's that?

709
00:52:49,350 --> 00:52:53,560
来找一下
Take that CDR of B and now take the CAR of that.

710
00:52:53,560 --> 00:52:56,480
哦，还是3
Oh, that's 3 also.

711
00:52:56,480 --> 00:53:01,120
有了共享这样的机制，局部的含义也不是那么清楚了
So I can have non-local interactions by sharing.

712
00:53:01,120 --> 00:53:02,480
所以我们要非常小心的操作
And I have to be very careful of that.

713
00:53:06,640 --> 00:53:22,820
目前为止，我已经介绍了SET！ SET-CAR！ SET-CDR！这些赋值操作，或许我应该不用SET-CAR！ SET-CDR！，它们引入太多问题了
Well, so far, of course, it seems I've introduced several different assignment operators-- set, set CAR, set CDR. Well, maybe I should just get rid of set CAR and set CDR. Maybe they're not worthwhile.

714
00:53:22,820 --> 00:53:27,170
不幸的是，一旦你让骆驼的鼻子进了帐篷，相当于你把它放进了帐篷
Well, the answer is that once you let the camel's nose into the tent, the rest of him follows.

715
00:53:30,160 --> 00:53:35,850
我想说的是，只要有set！，这一切不幸的都可能会发生
All I have to have is set, and I can make all of the--all of the bad things that can happen.

716
00:53:38,550 --> 00:53:40,690
我们来分析一下
Let's play with that a little bit.

717
00:53:40,690 --> 00:53:52,480
前些日子讲到复合数据的时候，哈罗德教授向你们展示了用消息接收的方式来定义CONS
A couple of days ago, when we introduced compound data, you saw Hal show you a definition of CONS in terms of a message acceptor.

718
00:53:52,480 --> 00:54:04,440
现在我要用一种更为恐怖的方式来定义CONS
I'm going to show you even a more horrible thing, a definition of CONS in terms of nothing but air, hot air.

719
00:54:04,440 --> 00:54:14,580
过去的那个CONS是怎么定义的来着？一个lambda表达式，一个过程？
What is the definition of CONS, of the old functional kind, in terms of purely lambdic expressions, procedures?

720
00:54:17,190 --> 00:54:28,580
我们这里对CONS的修改是要达到这样的效果，用SET！来代替SET-CAR！ SET-CDR！
Because I'm going to then modify this definition to get assignment to be only one kind of assignment, to get rid of the set CAR and set CDR in terms of set.

721
00:54:28,580 --> 00:54:46,320
这里我定义CONS为一个接受一个参数M的过程，M作用于X与Y
So what if I define CONS of X and Y to be a procedure of one argument called a message M, which calls that message on X and Y?

722
00:54:51,120 --> 00:54:57,870
这是阿隆佐·丘奇发明的方法，他是20世纪最伟大的程序员之一，尽管当时电脑还没有被发明
This [? idea ?] was invented by Alonzo Church, who was the greatest programmer of the 20th century, although he never saw a computer.

723
00:54:57,870 --> 00:54:59,130
那时20世纪30年代的事了
It was done in the 1930s.

724
00:54:59,130 --> 00:55:02,220
他是一个逻辑学家，当时应该是在普林斯顿
He was a logician, I suppose at Princeton at the time.

725
00:55:08,660 --> 00:55:46,670
(DEFINE (CAR X) (X (lambda(A D) A))) (DEFINE (CDR X) (X (lambda(A D) D)))
Define CAR of X to be the result of applying X to that procedure of two arguments, A and D, which selects A. I will define CDR of X to be that procedure, to be the result of applying X to that procedure of A and D, which selects D.

726
00:55:46,670 --> 00:55:50,510
这就是CONS CAR CDR
Now, you may not recognize this as CAR, CDR, and CONS.

727
00:55:50,510 --> 00:55:55,210
我来举例看一下，它是否符合之前所说的CONS的原则
But I'm going to demonstrate to you that it satisfies the original axioms, just once.

728
00:55:55,210 --> 00:55:58,290
简单来看
And then we're going to do some playing of games.

729
00:55:58,290 --> 00:56:09,695
(CAR (CONS 35 47))
Consider the problem CAR of CONS of, say, 35 and 47.

730
00:56:09,695 --> 00:56:11,120
这是什么呢？
Well, what is that?

731
00:56:11,120 --> 00:56:19,710
用代换模型，把CONS换成这边定义的
It is the result of taking car of the result of substituting 35 and 47 for X and Y in the body of this.

732
00:56:19,710 --> 00:56:20,690
非常容易
Well, that's easy enough.

733
00:56:20,690 --> 00:56:35,750
就是(CAR (lambda (M) (M 35 47)))
That's CAR of the result of substituting into lambda of M, M of 35 and 47.

734
00:56:35,750 --> 00:56:42,830
再来代换CAR
Well, what this is, is the result of substituting this object for X in the body of that.

735
00:56:42,830 --> 00:57:15,840
((lambda (M) (M 35 47)) (lambda (A D) A))
So that's just lambda of M-- that's substituted, because this object is being substituted for X, which is the beginning of a list, lambda of M-- M of 35 and 47, applied to that procedure of A and D, which gives me A. Well, that's the result of substituting this for M here.

736
00:57:15,840 --> 00:57:26,026
继续代换，((lambda (A D) A) 35 47)
So that's the same thing as lambda of A, D, A, applied to 35 and 47.

737
00:57:26,026 --> 00:57:27,560
结果就是35
Oh, well that's 35.

738
00:57:27,560 --> 00:57:40,720
35对应A，47对应的是D。在这种定义里，我什么数据都不需要，甚至连数字都没有
That's substituting 35 for A and for 47 for D in A. So I don't need any data at all, not even numbers.

739
00:57:40,720 --> 00:57:42,640
太佩服丘奇了
This is Alonso Church's hack.

740
00:57:52,420 --> 00:57:56,760
现在呢我们来对这个定义做点修改
Well, now we're going to do something nasty to him.

741
00:57:56,760 --> 00:57:58,860
作为逻辑学家，他可能会不太开心
Being a logician, he wouldn't like this.

742
00:57:58,860 --> 00:58:03,260
但是作为程序员，应该没什么
But as programmers, let's look at the overhead.

743
00:58:03,260 --> 00:58:05,390
我们来看看
And here we go.

744
00:58:05,390 --> 00:58:09,570
修改CONS的定义
I'm going to change the definition of CONS.

745
00:58:09,570 --> 00:58:14,520
和丘奇的定义很相似，但是不完全相同
It's almost the same as Alonzo Church's, but not quite.

746
00:58:14,520 --> 00:58:16,070
具体到底是什么？
What do we have here?

747
00:58:16,070 --> 00:58:40,940
CONS定义为一个过程，这个过程需要一个参数M，但是M作用于4个参数，X，Y 和两个lambda过程
The CONS of two arguments, X and Y, is going to be that procedure of one argument M, which supplies M to X and Y as before, but also to two permissions, the permission to set X to N and the permission to set Y to N, given that I have an N.

748
00:58:40,940 --> 00:59:03,365
所以这里的不同之处在于，M除了应用于x y之外，还应用于两个过程，分别用于修改x与y的值
So besides the things that I had here in Church's definition, what I have is that the thing that CONS returns will apply its argument to not just the values of the X and Y that the CONS is made of, but also permissions to set X and Y to new values.

749
00:59:06,540 --> 00:59:11,690
类似之前，CAR看起来也很相似
Now, of course, just as before, CAR is exactly the same.

750
00:59:11,690 --> 00:59:22,550
(CAR X)也就只是从4个参数里挑出第一个而已
The CAR of X is nothing more than applying X, as in Church's definition, to a procedure, in this case, of four arguments, which selects out the first one.

751
00:59:22,550 --> 00:59:37,920
和之前一样，返回的将会是这个过程中的x
And just as we did before, that will be the value of X that was contained in the procedure which is the result of evaluating this lambda expression in the environment where X and Y are defined over here.

752
00:59:41,940 --> 00:59:45,640
这个过程的整体就是CONS
That's the value of CONS.

753
00:59:45,640 --> 00:59:47,730
接着，最为精彩的一段
Now, however, the exciting part.

754
00:59:47,730 --> 00:59:48,960
CDR，和CAR一样的
CDR, of course, is the same.

755
00:59:48,960 --> 00:59:55,800
SET-CAR！ SET-CDR！的实现着实让人眼前一亮，其实它们也并不复杂
The exciting part, set CAR and set CDR. Well, they're nothing very complicated anymore.

756
00:59:55,800 --> 01:00:26,150
(SET-CAR! X Y)无非就是用一个取到4个参数中第3个参数的过程，去代换实际定义的CONS，取得修改其中X的权限，把其修改为新的值Y
Set CAR of a CONS X to a new value Y is nothing more than applying that CONS, which is the procedure of four--the procedure of one argument which applies its argument to four things, to a procedure which is of four arguments-- the value of X, the value of Y, permission to set X, the permission to set Y-- and using it--using that permission to set X to the new value.

757
01:00:31,650 --> 01:00:33,540
SET-CDR！和它是类似的
And similarly, set-cdr is the same thing.

758
01:00:36,120 --> 01:00:40,470
你也看到了，这里并没有引入新的其它基础操作
So what you've just seen is that I didn't introduce any new primitives at all.

759
01:00:40,470 --> 01:00:45,340
具体要不要这样来实现是一个工程性问题
Whether or not I want to implement it this way is a matter of engineering.

760
01:00:45,340 --> 01:00:51,680
实际上出于一些原因，工程上并不这样来实现
And the answer is of course I don't implement it this way for reasons that have to do with engineering.

761
01:00:51,680 --> 01:00:58,765
原理上逻辑上就是这样，一旦引入了赋值，便可以修改任意的东西
However in principle, logically, once I introduced one assignment operator, I've assigned--I've introduced them all.

762
01:01:05,420 --> 01:01:06,670
有什么问题吗？
Are there any questions?

763
01:01:09,200 --> 01:01:12,040
好的，David
Yes, David.

764
01:01:12,040 --> 01:01:15,740
我可以跟的上你的思路，直到
AUDIENCE: I can follow you up until you get--I can follow all of that.

765
01:01:15,740 --> 01:01:24,210
直到那个lambda (n)那里，我不知道这个参数是什么时候传进来的
But when we bring in the permissions, defining CONS in terms of the lambda N, I don't follow where N gets passed.

766
01:01:24,210 --> 01:01:25,100
哦，抱歉
PROFESSOR: Oh, I'm sorry.

767
01:01:25,100 --> 01:01:26,340
我没讲清楚
I'll show you.

768
01:01:26,340 --> 01:01:27,360
我们来仔细看看
Let's follow it.

769
01:01:27,360 --> 01:01:29,180
当然，我们也可以在黑板上演示
Of course, we could do it on the blackboard.

770
01:01:29,180 --> 01:01:30,170
并不难懂
It's not so hard.

771
01:01:30,170 --> 01:01:32,450
非常简单
But it's also easy here.

772
01:01:32,450 --> 01:01:38,520
来看(set-cdr! x y)
Supposing I wish to set-cdr of X to Y. See that right there.

773
01:01:38,520 --> 01:01:46,890
x是一个CONS
set-cdr of X to Y. X is presumably a CONS, a thing resulting from evaluating CONS.

774
01:01:46,890 --> 01:01:58,110
x可以代换为这一部分，一个lambda表达式
Therefore X comes from a place over here, that that X is of the result of evaluating this lambda expression.

775
01:01:58,110 --> 01:01:59,380
对吧
Right?

776
01:01:59,380 --> 01:02:08,950
这个lambda，是在定义CONS的环境下执行的
That when I evaluated that lambda expression, I evaluated it in an environment where the arguments to CONS were defined.

777
01:02:11,750 --> 01:02:29,250
这意味着，x y都是自由变量，x y所在的frame在这个lambda的上层，因此在这个过程中可以访问到x和y
That means that as free variables in this lambda expression, there is the--there are in the frame, which is the parent frame of this lambda expression, the procedure resulting from this lambda expression, X and Y have places.

778
01:02:29,250 --> 01:02:31,910
也可以对它们赋值
And it's possible to set them.

779
01:02:31,910 --> 01:02:37,010
这里赋值为n，是一个传过来的参数
I set them to an N, which is the argument of the permission.

780
01:02:37,010 --> 01:02:47,940
这个可以进行修改的过程是M的参数，而M又是CONS对象的参数
The permission is a procedure which is passed to M, which is the argument that the CONS object gets passed.

781
01:02:47,940 --> 01:02:57,480
现在再来看看SET-CDR！，第一个参数是一个CONS对象
Now, let's go back here in the set-cdr The CONS object, which is the first argument of set-cdr gets passed an argument.

782
01:03:00,260 --> 01:03:07,920
这是一个有4个参数的过程，作为实参，对应这里的形参M
That--there's a procedure of four things, indeed, because that's the same thing as this M over here, which is applied to four objects.

783
01:03:07,920 --> 01:03:12,970
这边的这个sd，就对应于这个过程
The object over here, SD, is, in fact, this permission.

784
01:03:15,470 --> 01:03:19,930
当我执行sd，应用于Y
When I use SD, I apply it to Y, right there.

785
01:03:22,910 --> 01:03:25,740
y是这里传过来的参数
So that comes from this.

786
01:03:25,740 --> 01:03:34,160
David：那-- 教授：对应起来，这里的y就对应于这里的n
AUDIENCE: So what do you-- PROFESSOR: So to finish that, the N that was here is the Y which is here.

787
01:03:34,160 --> 01:03:34,810
明白了吧
How's that?

788
01:03:34,810 --> 01:03:35,750
了解了
AUDIENCE: Right, OK.

789
01:03:35,750 --> 01:03:41,970
当你执行SET-CDR！的时候，x是CDR要变成的值
Now, when you do a set-cdr, X is the value the CDR is going to become.

790
01:03:41,970 --> 01:03:44,742
这里的x
PROFESSOR: The X over here.

791
01:03:44,742 --> 01:03:46,200
并不全对
I'm sorry, that's not true.

792
01:03:46,200 --> 01:03:56,150
SET-CAR！有两个参数，这个x是我们要改变的CONS对象
The X is--set-cdr has two arguments-- The CONS I'm changing and the value I'm changing it to.

793
01:03:56,150 --> 01:03:58,320
你可以代换回去看看，就很清楚了
So you have them backwards, that's all.

794
01:04:01,750 --> 01:04:03,000
还有什么问题吗？
Are there any other questions?

795
01:04:07,880 --> 01:04:08,640
好的
Well, thank you.

796
01:04:08,640 --> 01:04:09,890
这节课就到这里
It's time for lunch.

