1
00:00:21,170 --> 00:00:24,128
现在我们已经学习了
PROFESSOR: Well, now that we've given you some power

2
00:00:24,432 --> 00:00:27,400
如何创建局部状态和如何建模对象
to make independent local state and to model objects,

3
00:00:28,336 --> 00:00:32,672
我想我们应该找点复杂的东西
I thought we'd do a bit of programming of a very complicated kind,

4
00:00:34,032 --> 00:00:36,368
来实践一下我们学过的这些知识
just to illustrate what you can do with this sort of thing.

5
00:00:40,430 --> 00:00:43,488
假设 我们处在一个物理系统中
I suppose, as I said, we were motivated by physical systems

6
00:00:44,112 --> 00:00:46,256
假设，我们处在这样一个物理系统中，系统中的事物驱动彼此，全部的这些事物组成了世界
the ways we like to think about physical systems,

7
00:00:46,992 --> 00:00:51,088
假设，我们处在这样一个物理系统中，系统中的事物驱动彼此，全部的这些事物组成了世界
which is that there are these things that the world is made out of.

8
00:00:52,060 --> 00:00:55,984
每一个事物都有其独立的局部状态
And each of these things has particular independent local state,

9
00:00:57,248 --> 00:00:59,872
每一个事物都有其独立的局部状态
and therefore it is a thing. That's what makes it a thing.

10
00:01:01,280 --> 00:01:04,272
我们说 我们有一个真实的世界
And then we're going to say that in the model in the world

11
00:01:04,288 --> 00:01:09,900
我们在大脑中和计算机中对那个真实世界建模
we have a world and a model in our minds and in the computer of that world.

12
00:01:10,940 --> 00:01:12,544
我想要把真实世界和计算机中的对象
And what I want to make is a correspondence

13
00:01:12,784 --> 00:01:15,216
联系对应起来
between the objects in the world and the objects in the computer,

14
00:01:15,872 --> 00:01:21,728
把真实世界中对象间的关系 与模型中对象间的关系 对应起来
the relationships between the objects in the world and the relationships between those same obj...--the model objects in the computer,

15
00:01:23,184 --> 00:01:28,112
真实世界中关联对象的函数 与模型中的函数 对应起来
and the functions that relate things in the world to the functions that relate things in the computer.

16
00:01:30,840 --> 00:01:33,824
这就为我们赢得了模块性
This buys us modularity.

17
00:01:34,740 --> 00:01:36,752
如果我们认为真实世界是像那样的
If we really believe the world is like that,

18
00:01:37,360 --> 00:01:38,720
也就是由许多小的事物构成的
that it's made out of these little pieces,

19
00:01:39,200 --> 00:01:41,472
当然 我们可以把世界安排成那样
and of course we could arrange our world to be like that,

20
00:01:42,032 --> 00:01:43,952
我们只能对像那样的事物建模
we could only model those things that are like that,

21
00:01:45,456 --> 00:01:49,024
这样 我们的程序就可以从现实世界中继承模块化
then we can inherit the modularity in the world into our programming.

22
00:01:50,450 --> 00:01:53,584
这就是发明面向对象编程的初衷
That's why we would invent some of this object-oriented programming.

23
00:01:55,420 --> 00:01:58,192
我所见过的最完美的对象（系统）
Well, let's take the best kind of objects I know.

24
00:01:58,890 --> 00:02:04,176
电气系统 就是非常非常完美的对象系统
They're completely--they're completely wonderful: electrical systems.

25
00:02:06,400 --> 00:02:12,992
电气系统真的是物理学家构造的非常非常好的一种对象
Electrical systems really are the physicist's best, best objects.

26
00:02:14,220 --> 00:02:16,760
这里 我有一些机器零件
You see over here I have some piece of machinery.

27
00:02:17,120 --> 00:02:18,288
就是这些零件
Right here's a piece of machinery.

28
00:02:20,040 --> 00:02:22,880
有一个电线连接起了
And it's got an electrical wire connecting

29
00:02:23,664 --> 00:02:26,400
零件的两个部分
one part of the machinery with another part of the machinery.

30
00:02:27,568 --> 00:02:30,864
电气世界中 有一个非常棒的特性
And one of the wonderful properties of the electrical world

31
00:02:31,648 --> 00:02:33,120
就是我可以说这是一个对象
is that I can say this is an object,

32
00:02:34,016 --> 00:02:34,976
这又是一个对象
and this is an object,

33
00:02:35,712 --> 00:02:37,536
它们间的关联一目了然
and they're-- the connection between them is clear.

34
00:02:38,240 --> 00:02:43,328
而且 如果我没有用电线连接 它们便没有关联
In principle, there is no connection that I didn't describe with these wires.

35
00:02:44,740 --> 00:02:46,128
比如我有一个灯泡
Let's say if I have light bulbs,

36
00:02:46,528 --> 00:02:50,320
一个灯泡和一个已经接在插座上的电源
Let's say if I have light bulbs, a light bulb and a power supply that's plugged into the outlet.

37
00:02:51,632 --> 00:02:53,536
关联非常明了
Then the connection is perfectly clear.

38
00:02:53,620 --> 00:02:55,424
这就是已知所有的连接方式了
There's no other connections that we know of.

39
00:02:56,220 --> 00:03:02,336
就算我把连接电灯和电源的电线打个结
If I were to tie a knot in the wire that connects the light bulb to the power supply,

40
00:03:02,688 --> 00:03:03,648
灯仍然是亮的
the light remains lit up.

41
00:03:04,040 --> 00:03:04,768
没什么影响
It doesn't care.

42
00:03:07,440 --> 00:03:12,400
物理学上这样安排 可以使连接变成抽象的
That the way the physics is arranged is such that the connection can be made abstract,

43
00:03:13,088 --> 00:03:15,270
至少在低频状态下是可以的
at least for low frequencies and things like that.

44
00:03:17,840 --> 00:03:20,880
而且这就是全部的关联方式了
So in fact, we have captured all of the connections there really are.

45
00:03:22,350 --> 00:03:23,872
当然 我们来进一步
Well, as you can go one step further

46
00:03:23,904 --> 00:03:27,310
讨论一种在电气系统中最为广泛的抽象
and talk about the most abstract types of electrical systems we have,

47
00:03:27,856 --> 00:03:29,420
数字电路
digital to dual circuits.

48
00:03:31,696 --> 00:03:33,664
这里有一些对象
And here there are certain kinds of objects.

49
00:03:34,640 --> 00:03:40,128
例如 在数字电路里中 我们有非门
For example, in digital circuits we have things like inverters.

50
00:03:41,392 --> 00:03:42,784
有与门
We have things like and-gates.

51
00:03:43,990 --> 00:03:45,408
还有或门
We have things like or-gates.

52
00:03:47,210 --> 00:03:50,128
我们用一种特殊的“电线” 把它们连接起来
We connect them together by sort-of wires

53
00:03:52,000 --> 00:03:54,944
这些“电线”代表抽象信号
which represent abstract signals.

54
00:03:55,610 --> 00:03:57,184
我们不关心具体的物理因素
We don't really care as physical variables

55
00:03:57,210 --> 00:03:59,728
像电压、电流或者组合因素等
whether these are voltages or currents or some combination

56
00:04:00,016 --> 00:04:03,440
又或者是水压 等等
or water, water pressure.

57
00:04:05,200 --> 00:04:07,328
这些抽象变量代表某类信号
These abstract variables represent certain signals.

58
00:04:09,420 --> 00:04:12,896
我们用电路连接元件 构建系统
And we build systems by wiring these things together with wires.

59
00:04:14,070 --> 00:04:16,224
现在 我要向你们介绍一门新的语言
So today what I'm going to show you, right now,

60
00:04:17,632 --> 00:04:20,176
我们要构建一门内嵌于Lisp中的语言
we're going to build up an invented language in Lisp,

61
00:04:22,144 --> 00:04:25,088
这是一种内部DSL 是类似于之前讲过的图形语言那种
embedded in the same sense that Henderson's picture language was embedded,

62
00:04:26,160 --> 00:04:27,328
而不是昨天那种
which is not the same sense

63
00:04:27,888 --> 00:04:31,610
那种模式匹配语言 -- 那是外部DSL
as the language of pattern match and substitution was done yesterday.

64
00:04:32,800 --> 00:04:36,300
模式匹配语言是由Lisp程序所解释的
The pattern match substitution language was interpreted by a Lisp program.

65
00:04:38,160 --> 00:04:40,528
而之前那种图形语言
But the embedding of Henderson's program

66
00:04:40,560 --> 00:04:44,270
是在Lisp中构造我们想要的过程 来封装图形结构
is that we just build up more and more procedures that encapsulate the structure we want.

67
00:04:45,480 --> 00:04:46,752
举例来说
So for example here,

68
00:04:47,728 --> 00:04:50,640
首先我要有一些基本对象
I'm going to have some various primitive kinds of objects, as you see,

69
00:04:51,056 --> 00:04:52,128
比如这个和这个
that one and that one.

70
00:04:53,504 --> 00:04:55,184
然后用电线去组合它们
I'm going to use wires to combine them.

71
00:04:55,984 --> 00:04:59,376
我用 (MAKE-WIRE) 来构造一个电线
The way I represent attaching-- I can make wires.

72
00:04:59,870 --> 00:05:01,248
A就代表了一根电线
So let's say A is a wire.

73
00:05:01,740 --> 00:05:02,690
B也是
And B is a wire.

74
00:05:02,690 --> 00:05:03,460
C也是
And C is a wire.

75
00:05:03,460 --> 00:05:04,230
D也是
And D is a wire.

76
00:05:04,230 --> 00:05:04,830
还有E
And E is wire.

77
00:05:04,830 --> 00:05:05,648
S也是
And S is a wire.

78
00:05:06,880 --> 00:05:12,752
而或门有两个输入 分别是A和B
Well, an or-gate that has both inputs, the inputs being A and B,

79
00:05:13,168 --> 00:05:14,752
它的输出是D
and the output being wire D,

80
00:05:15,072 --> 00:05:16,128
我们用这样的记号来表示
you notate like this.

81
00:05:18,140 --> 00:05:22,144
与门 输入是A和B 输出是C
An and-gate, which has inputs A and B and output C,

82
00:05:22,224 --> 00:05:23,240
我们这样表示
we notate like that.

83
00:05:24,820 --> 00:05:28,464
通过一系列像这样的声明
By making such a sequence of declarations,

84
00:05:29,296 --> 00:05:31,648
我可以组合出任意的电路
I can wire together an arbitrary circuit.

85
00:05:32,750 --> 00:05:38,512
我已经说明了基本对象和构建数字电路的组合方法
So I've just told you a set of primitives and means of combination for building digital circuits,

86
00:05:40,096 --> 00:05:43,040
然后就该说抽象的方法了
when I need more in a real language than abstraction.

87
00:05:43,690 --> 00:05:52,240
举例来说 这是一个半加器
And so for example, here I have--here I have a half adder.

88
00:05:52,672 --> 00:05:55,552
如果你学过电路设计肯定知道这个东西
It's something you all know if you've done any digital design.

89
00:05:56,930 --> 00:06:00,448
输入两个数A和B
It's used for adding numbers together on A and B

90
00:06:00,624 --> 00:06:02,120
输出两者之和以及进位
and putting out a sum and a carry.

91
00:06:04,352 --> 00:06:06,800
事实上 完全可以用我刚刚说的来组合电路#TBD
And in fact, the wiring diagram is exactly what I told you.

92
00:06:07,450 --> 00:06:10,992
盒子外面 有半加器的另外一些东西 #TBD
A half adder with things that come out of the box--

93
00:06:11,136 --> 00:06:14,112
这些盒子的边界 我们总是抽象成盒子
you see the box, the boundary, the abstraction is always a box.

94
00:06:14,790 --> 00:06:19,700
从盒子里引出A B S C四根线
And there are things that come out of it, A, B, S, and C.

95
00:06:19,700 --> 00:06:21,792
这些是已经声明了的变量
Those are the declared variables--

96
00:06:23,390 --> 00:06:26,256
由LAMBDA表达式声明的几个变量
declared variables of a lambda expression,

97
00:06:26,288 --> 00:06:28,010
定义了这个半加器
which is the one that defines half adder.

98
00:06:31,400 --> 00:06:35,968
在盒子的内部 我构造了电线D和E
And internal to that, I make up some more wires, D and E,

99
00:06:36,000 --> 00:06:37,440
这是为了连接内部结构
which I'm going to use for the interconnect--

100
00:06:37,744 --> 00:06:40,400
这条是E 这条是D
here E is this one and D is this wire,

101
00:06:41,328 --> 00:06:43,504
内部连接的线路并没有引出盒子之外
the interconnect that doesn't come through the walls of the box--

102
00:06:45,056 --> 00:06:46,832
就像电路图那样连起来
and wire things together as you just saw.

103
00:06:48,790 --> 00:06:50,896
大家可以看得出来
And the nice thing about this that I've just shown you

104
00:06:51,056 --> 00:06:53,024
这个语言非常有层次性
this language is hierarchical in the right way.

105
00:06:53,856 --> 00:06:55,712
如果一门语言没有层次性
If a language isn't hierarchical in the right way,

106
00:06:55,952 --> 00:06:59,968
如果你不能把一个复合对象当成基本对象来使用
if it turns out that a compound object doesn't look like a primitive,

107
00:07:00,384 --> 00:07:01,536
这门语言肯定是有问题的
there's something wrong with the language--

108
00:07:02,592 --> 00:07:04,224
至少我是这么认为的
at least the way I feel about that.

109
00:07:06,410 --> 00:07:09,584
之前 我们都是在研究数学函数
So here we have--here, instead of starting with mathematical functions,

110
00:07:09,600 --> 00:07:11,120
或者是计算数学函数的东西
or things that compute mathematical functions,

111
00:07:11,152 --> 00:07:12,650
这些都是我们之前研究的东西
which is what we've been doing up until now,

112
00:07:13,850 --> 00:07:16,656
而我们现在
instead of starting with things that look like mathematical functions,

113
00:07:16,672 --> 00:07:17,630
不这么做了
or compute such things,

114
00:07:17,850 --> 00:07:20,880
我们从一些电气对象开始
we are starting with things that are electrical objects

115
00:07:21,040 --> 00:07:22,640
构建更多的对象
and we build up more electrical objects.

116
00:07:23,350 --> 00:07:28,832
我们用Lisp里的LAMBDA将其粘合起来
And the glue we're using is basically the Lisp structure: lambdas.

117
00:07:30,500 --> 00:07:32,930
“LAMBDA: 终极之粘合剂”
Lambda is the ultimate glue, if you will.

118
00:07:33,320 --> 00:07:36,352
当然 半加器可以用于
And of course, half adder itself can be used

119
00:07:37,648 --> 00:07:41,040
构造一种更复杂的抽象结构 -- 全加器
in a more complicated abstraction called a full adder,

120
00:07:41,600 --> 00:07:45,056
如这里所示 全加器由两个半加器构成
which in fact involves two half adders, as you see here,

121
00:07:45,470 --> 00:07:47,872
用一些额外的电线连接起来
hooked together with some extra wires,

122
00:07:48,080 --> 00:07:51,290
就像这里所示的S、C1、C2以及一个或门
that you see here, S, C1, and C2, and an or-gate,

123
00:07:52,190 --> 00:07:53,600
而对于一个全加器
to manufacture a full adder,

124
00:07:53,872 --> 00:08:00,780
它的输入有：两个待加的数 一个进位值
which takes a input number, another input number, a carry in,

125
00:08:01,360 --> 00:08:04,176
输出是：两数之和以及进位
and produces output, a sum and a carry out.

126
00:08:05,900 --> 00:08:10,704
构建好全加器以后 还可以把它们链起来组成更大的加法器
And out of full adders, you can make real adder chains and big adders.

127
00:08:12,990 --> 00:08:14,832
现在我们有了一门完整的语言
So we have here a language so far

128
00:08:16,064 --> 00:08:21,760
它有基本元素、组合方法以及抽象方法
That has primitives, means of combination, and means of abstraction to real language.

129
00:08:22,270 --> 00:08:23,360
现在 我们怎样实现这门语言？
Now, how are we going to implement this?

130
00:08:25,000 --> 00:08:26,848
其实并不难
Well, let's do it easily.

131
00:08:27,070 --> 00:08:27,968
首先来看基本元素
Let's look at the primitives.

132
00:08:28,128 --> 00:08:30,112
实现原子元素也是整个问题的根本所在
The only problem is we have to implement the primitives.

133
00:08:31,160 --> 00:08:32,560
不需要再做其它事情了
Nothing else has to be implemented,

134
00:08:33,744 --> 00:08:38,000
因为我们直接借用了Lisp中的组合方法以及抽象方法
because we're picking up the means of combination and abstraction from Lisp,

135
00:08:39,968 --> 00:08:41,888
我们的语言 继承自Lisp并内嵌于其中
inheriting them in the embedding.

136
00:08:43,776 --> 00:08:45,440
好 我们先来看一个基本元素
OK, so let's look at a particular primitive.

137
00:08:45,860 --> 00:08:47,400
就拿非门来说吧
An inverter is a nice one.

138
00:08:51,540 --> 00:08:54,672
非门有两个引脚 分别是输入和输出
Now, inverter has two wires coming in, an in and an out.

139
00:08:57,312 --> 00:09:02,624
它要对输入信号做出响应
And somehow, it's going to have to know what to do when a signal comes in.

140
00:09:04,300 --> 00:09:07,008
它需要对输入电线说 --
So somehow it's going to have to tell its input wire--

141
00:09:07,640 --> 00:09:10,144
我们现在把它们视作对象
and now we're going to talk about objects

142
00:09:10,448 --> 00:09:12,416
其具体细节我们稍后讨论
and we're going to see this in a little more detail soon--

143
00:09:13,230 --> 00:09:14,848
它对其输入电线的说
but it's going to have to tell its input wire

144
00:09:15,824 --> 00:09:18,480
“当你的值变发生改变时 告诉我一声”
that when you change, tell me.

145
00:09:20,120 --> 00:09:22,112
所以非门这个对象
So this object, the object which is the inverter

146
00:09:22,416 --> 00:09:24,384
会对输入电线这个对象说 --
has to tell the object which is the input wire,

147
00:09:25,136 --> 00:09:26,400
“Hi，我是George”
hi, my name is George.

148
00:09:26,870 --> 00:09:31,024
“我的工作就是 对你的变化做出响应”
And my, my job is to do something with results when you change.

149
00:09:31,720 --> 00:09:34,192
“所以当你变化的时候 告诉我一声”
So when you change, you get a change, tell me about it.

150
00:09:34,730 --> 00:09:35,728
“因为这样我才能进行进一步的处理”
Because I've got to do something with that.

151
00:09:36,880 --> 00:09:40,304
这是通过这里在输入电线上
Well, that's done down here by adding an action on the input wire called invert-in,

152
00:09:41,408 --> 00:09:44,640
添加一个叫做INVERT-IN的动作来实现的
Well, that's done down here by adding an action on the input wire called invert-in,

153
00:09:45,070 --> 00:09:46,944
INVERT-IN在这里定义
where invert-in is defined over here

154
00:09:47,056 --> 00:09:48,760
它是一个无参过程
to be a procedure of no arguments,

155
00:09:49,984 --> 00:09:54,592
它将线路上的信号逻辑取反
which gets the logical not of the signal on the input wire.

156
00:09:56,130 --> 00:09:58,528
经过一段时长为INVERTER-DELAT的延时以后 --
And after some delay, which is the inverter delay,

157
00:09:59,344 --> 00:10:01,136
每个电路对象都有延时 --
all these electrical objects have delays,

158
00:10:02,880 --> 00:10:04,460
然后我们会 --
we'll do the following thing--

159
00:10:04,672 --> 00:10:07,140
我们再把输出设置为新的值
set the signal on the output wire to the new value.

160
00:10:10,160 --> 00:10:11,360
非常简单
A very simple program.

161
00:10:12,400 --> 00:10:15,280
你可以想象输出电线也同样是信号敏感的
Now, you have to imagine that the output wire has to be sensitive

162
00:10:15,770 --> 00:10:18,272
当信号改变的时候
and know that when its signal changes,

163
00:10:19,280 --> 00:10:21,150
它会“告知”其它对象
it may have to tell other guys,

164
00:10:21,792 --> 00:10:24,784
“快醒醒！我的值已经改变啦”
Hi, wake up. My value has changed.

165
00:10:26,050 --> 00:10:30,144
所以当你把非门和与门或者元件连在一起的时候
So when you hook together inverter with an and-gate or something like that,

166
00:10:30,464 --> 00:10:32,208
它们之间将会有大量的通信
there has to be a lot of communication going on

167
00:10:32,864 --> 00:10:35,072
以确保信号正确地传播
to make sure that the signal propagates right.

168
00:10:36,810 --> 00:10:38,620
到目前为止 没什么新奇的东西
And down here is nothing very exciting.

169
00:10:38,620 --> 00:10:40,720
我们只是针对某个特定的表示法
This is just the definition of logical not 

170
00:10:40,720 --> 00:10:45,240
也就是这个例子中的 1 0 -- 实现了LOGICAL-NOT而已
for some particular representations of the logical values-- 1, 0 in this case.

171
00:10:46,736 --> 00:10:49,168
与门就相对复杂一些
And we can look at things more complicated like and-gates.

172
00:10:49,780 --> 00:10:55,808
与门有两个输入A1和A2 输出是OUTPUT
And-gates take two inputs, A1 and A2, we'll call them, and produce an output.

173
00:10:56,736 --> 00:11:00,640
但是其结构和非门没有什么大的不同
But the structure of the and-gate is identical to the one we just saw.

174
00:11:00,860 --> 00:11:03,440
只不过是 当输入信号改变的时候
There's one called an and-action procedure that's defined,

175
00:11:04,528 --> 00:11:09,070
与门调用的是AND-ACTION过程罢了
which is the thing that gets called when an input is changed.

176
00:11:10,910 --> 00:11:12,880
当然 它所做的只是
And what it does, of course, is nothing more than 

177
00:11:12,912 --> 00:11:15,370
对输入信号进行逻辑“与”运算
compute the logical and of the signals on the inputs.

178
00:11:16,192 --> 00:11:18,768
在经过AND-GATE-DELAY的延时之后
And after some delay, called the and-gate-delay,

179
00:11:20,464 --> 00:11:24,368
调用这个过程 更新输出信号值
calls this procedure, which sets a signal on the output to a new value.

180
00:11:25,470 --> 00:11:28,350
那么 我们如何用“按愿望思维”来构造这一切呢？
Now, how I implement these things is all wishful thinking.

181
00:11:28,350 --> 00:11:31,088
如大家所见 这里有一个赋值运算
As you see here, I have an assignment operation.

182
00:11:32,020 --> 00:11:32,784
但并不是SET!
It's not set.

183
00:11:34,570 --> 00:11:36,784
这是一个派生出来的运算
It's a derived assignment operation in the same way

184
00:11:36,784 --> 00:11:38,730
就像可以从CAR和CDR派生出其它函数一样
we had functions that were derived from CAR and CDR.

185
00:11:40,800 --> 00:11:44,816
因此 按照约定 我加上“!”（表示这个过程有副作用）
So I, by convention, label that with an exclamation point.

186
00:11:46,340 --> 00:11:49,184
这里有个过程ADD-ACTION!
And over here, you see there's an add-action!,

187
00:11:52,176 --> 00:11:54,624
它用来提醒与门中的局部线路A1
which is to inform the wire, called A1 locally in this and-gate,

188
00:11:55,632 --> 00:11:58,688
当它改变的时候记得执行过程ADD-ACTION-PROCEDURE
to call the and-action-procedure when it gets changed,

189
00:11:59,584 --> 00:12:02,912
A2也是一样
and the wire A2 to call the and-action procedure when it gets changed.

190
00:12:06,310 --> 00:12:07,232
非常简单
All very simple.

191
00:12:09,960 --> 00:12:12,096
现在我们再来看看
Well, let's talk a little bit about this communication

192
00:12:12,704 --> 00:12:16,120
各部分间是如何通信的
that must occur between these various parts.

193
00:12:18,544 --> 00:12:19,664
例如
Suppose, for example,

194
00:12:23,120 --> 00:12:24,272
有一个非常简单的电路
I have a very simple circuit

195
00:12:24,272 --> 00:12:30,460
它有一个带有两个输入A、B的与门
which contains and-gate with wires a and b.

196
00:12:31,920 --> 00:12:38,000
与门通过电线C跟非门相连
And that connects through a wire called c to an inverter

197
00:12:39,728 --> 00:12:41,536
非门的输出是D
which has a wire output called d.

198
00:12:44,208 --> 00:12:47,344
这就是物理世界
What are the comput...--here's the physical world.

199
00:12:47,360 --> 00:12:49,024
一个对物理世界的抽象
It's an abstraction of the physical world.

200
00:12:49,860 --> 00:12:53,408
要不了几分钱就可以从Radio Shack买到这些元件
Now I can buy these out of little pieces that you get at Radio Shack for a few cents.

201
00:12:54,880 --> 00:12:56,320
那些元件的作用和画在这里的差不多
And there are boxes that act like this,

202
00:12:57,168 --> 00:13:00,220
元件上都标有类似于LS04的标签
which have little numbers on them like LS04 or something.

203
00:13:01,530 --> 00:13:08,160
现在来看其中的计算模型
Now supposing I were to try to say what's the computational model.

204
00:13:09,010 --> 00:13:10,944
它又对应着什么
What is the thing that corresponds to that,

205
00:13:11,136 --> 00:13:14,096
#TBD
that part of reality in the mind of us and in the computer?

206
00:13:15,850 --> 00:13:19,136
#TBD
Well, I have to assign for every object in the world an object in the computer,

207
00:13:19,792 --> 00:13:24,272
#TBD
and for every relationship in the world between them a relationship in the computer.

208
00:13:26,064 --> 00:13:26,800
这是我们的目标
That's my goal.

209
00:13:28,560 --> 00:13:29,456
让我们来看看怎么做
So let's do that.

210
00:13:30,900 --> 00:13:34,208
这一团东西代表信号A
Well, I have some sort of thing called the signal, A.

211
00:13:35,712 --> 00:13:36,944
这是信号A
This is A. It's a signal.

212
00:13:37,940 --> 00:13:39,328
画得像一团云
It's a cloudy thing like that.

213
00:13:39,900 --> 00:13:42,800
再画另一个信号 -- B
And I have another one down here which I'm going to call B.

214
00:13:46,688 --> 00:13:47,470
它是另一个信号
It's another signal.

215
00:13:49,140 --> 00:13:50,912
这两个信号
Now this signal--these two signals

216
00:13:51,104 --> 00:13:52,816
要通过某种方式连在一起
are somehow going to have to hook together

217
00:13:53,728 --> 00:13:58,752
连在这个盒子上 -- 我们这么来画
into a box, let's call it this, which is the and-gate, action procedure.

218
00:14:00,320 --> 00:14:02,040
这就是与门的动作过程
That's the and-gate's action procedure.

219
00:14:07,660 --> 00:14:08,592
它将产生
And it's going to produce

220
00:14:09,152 --> 00:14:13,296
它将与另外一个称作C的信号对象交互
well, it's going to interact with a signal object, which we call C--

221
00:14:16,224 --> 00:14:18,880
哦 说错了 是一条电线C
a wire object, excuse me, we call C.

222
00:14:20,592 --> 00:14:23,888
这跟电线 又将连在
this is going to put out again, or connect to,

223
00:14:24,784 --> 00:14:30,336
一个非门上#TBD
nother action procedure which is one associated with the inverter in the world, not.

224
00:14:32,860 --> 00:14:40,656
我还有另外一根电线 -- D
And I'm going to have another--another wire, which we'll call D.

225
00:14:42,970 --> 00:14:45,296
整体布局就是这样
So here's my layout of stuff.

226
00:14:46,000 --> 00:14:49,440
现在必须来研究它们 有关计算的内部机制了
Now we have to say what's inside them and what they have to know to compute.

227
00:14:51,500 --> 00:14:53,696
每一跟电线都必须知道
Well, every--every one of these wires has to know

228
00:14:53,696 --> 00:14:56,360
自己承载的信号是什么
what the value of the signal that's on that wire is.

229
00:14:57,340 --> 00:15:00,000
我们用变量SIGNAL来表示
So there's going to be some variable inside here, we'll call it signal.

230
00:15:02,976 --> 00:15:04,048
SIGNAL的值就是信号
And he owns a value.

231
00:15:05,680 --> 00:15:07,744
也不要忘了它所关联的环境
So there must be some environment associated with this.

232
00:15:08,896 --> 00:15:11,344
对于每个元件来说 一定有一个环境绑定了信号
And for each one of these, there must be an environment that binds signal.

233
00:15:15,400 --> 00:15:16,880
因此 这里也有一个SIGNAL变量
And there must be a signal here, therefore.

234
00:15:19,400 --> 00:15:21,920
SIGNAL的值不是0就是1
And presumably, signal's a value that's either 1 or 0,

235
00:15:22,816 --> 00:15:23,488
这儿也有个SIGNAL
and signal.

236
00:15:28,000 --> 00:15:30,560
现在 一旦这里的信号改变
Now, we also have to have some

237
00:15:31,264 --> 00:15:34,112
我们需要通知一系列的对象
list of people to inform if the signal here changes.

238
00:15:36,660 --> 00:15:37,664
我们得通知这个与门
We're going to have to inform this.

239
00:15:39,300 --> 00:15:43,968
这里有个表 我们把它叫做AP
So I've got that list. We'll call it the Action Procedures, AP.

240
00:15:44,500 --> 00:15:45,600
它可能是一个表
And it's presumably a list.

241
00:15:46,448 --> 00:15:49,008
在本例中 表里面的第一项条目是这个东西
But the first thing on the list, in this case, is this guy.

242
00:15:50,500 --> 00:15:54,810
这个元件也有一个称为AP的表
And the action procedures of this one happens to have some list of stuff.

243
00:15:54,810 --> 00:15:58,176
也可能有一些其它对象 时刻等待着A来通知“它们”
There might be other people who are sharing A, who are looking at it.

244
00:15:59,020 --> 00:16:01,312
所以这里可能有其它对象 比如
So there might be other guys on this list, like

245
00:16:01,728 --> 00:16:03,230
一些其它我们不知道的对象
like somebody over there that we don't know about.

246
00:16:03,630 --> 00:16:04,880
我画在这里#TBD
It's the other guy attached to A.

247
00:16:07,200 --> 00:16:09,648
这里的AP表
And the action procedure here also has to point to that,

248
00:16:11,120 --> 00:16:12,400
也指向这个与门
the list of action procedures.

249
00:16:13,070 --> 00:16:16,352
相类似的 这里的AP表
And of course, that means this one, its action procedures

250
00:16:16,784 --> 00:16:18,530
也要指向这里
has to point up to here.

251
00:16:18,530 --> 00:16:20,896
这里是C要通知的元件
This is the things-- the people it has to inform.

252
00:16:21,770 --> 00:16:23,184
D也一样
And this guy has some too.

253
00:16:24,280 --> 00:16:25,248
但是我不知道它要通知谁
But I don't know what they are

254
00:16:25,264 --> 00:16:26,650
因为我的图中没有画出来
because I didn't draw it in my diagram.

255
00:16:27,190 --> 00:16:28,368
可能是和D连接起来的其它门吧#TBD
It's the things connected to D.

256
00:16:30,320 --> 00:16:32,624
同样的
Now, it's also the case

257
00:16:33,800 --> 00:16:36,960
当AND-ACTION过程被唤醒时
that when the and-action procedure is awakened,

258
00:16:37,020 --> 00:16:41,312
#TBD
saying one of the people who know that you've told

259
00:16:41,450 --> 00:16:44,848
#TBD
one of the people you've told to wake you up if their signal changes,

260
00:16:46,970 --> 00:16:48,816
你得去检查它的信号是什么
you have to go look and ask them what's their signal

261
00:16:49,328 --> 00:16:52,256
这样你就可以计算逻辑与 输出信号给下一个元件
so you can do the and, and produce a signal for this one.

262
00:16:57,090 --> 00:16:58,752
所里 这里就必须要有
So there has to be, for example,

263
00:16:58,848 --> 00:17:03,000
有信息说 A1是这个元件
information here saying A1, my A1 is this guy,

264
00:17:03,900 --> 00:17:06,480
A2就是这个元件
my A1 is this guy, and my A2 is this guy.

265
00:17:08,930 --> 00:17:09,984
不只是这样
And not only that,

266
00:17:11,790 --> 00:17:15,200
当我在计算逻辑与时 我还得告诉这个元件一些信息
when I do my and, I'm going to have to tell this guy something.

267
00:17:16,304 --> 00:17:21,056
还有一个输出 输出给这个元件
So I need an output--  being this guy.

268
00:17:25,800 --> 00:17:30,032
同样地 非门也有一个输入
And similarly, this guy's going to have a thing called the input

269
00:17:32,380 --> 00:17:34,928
当信号被唤醒并告知它信号被修改时
that he interrogates to find out

270
00:17:36,752 --> 00:17:38,640
非门会询问该信号
what the value of the signal on the input is,

271
00:17:38,640 --> 00:17:40,090
你的值是什么
when the signal wakes up and says, I've changed,

272
00:17:41,050 --> 00:17:43,472
信号通过像这样发消息 告知“信号已改变”
and sends a message this way saying, I've changed.

273
00:17:43,520 --> 00:17:45,536
它就反过来查询这个新的信号值
This guy says, OK, what's your value now?

274
00:17:46,900 --> 00:17:50,128
取到值之后 它将会
When he gets that value, then he's going to have to say,

275
00:17:50,144 --> 00:17:55,860
计算输出 并改变这个信号的值
OK, output changes this guy, changes this guy.

276
00:18:00,600 --> 00:18:01,248
以此类推
And so on.

277
00:18:02,848 --> 00:18:04,560
因此我也必须有这么多的连接
And so I have to have at least that much connected-ness.

278
00:18:06,240 --> 00:18:09,232
现在我们回头观察一下 这个与门
Now, let's go back and look, for example, at the and-gate.

279
00:18:10,260 --> 00:18:12,096
回到这张幻灯片
Here we are back on this slide.

280
00:18:13,670 --> 00:18:15,040
这几个部分的内容
And we can see some of these parts.

281
00:18:16,040 --> 00:18:19,328
对每个与门 都有A1、A2两个输入 一个OUTPUT输出
For any particular and-gate, there is an A1, there is an A2, and the output.

282
00:18:21,030 --> 00:18:23,536
这些都是
And those are, those are an

283
00:18:25,088 --> 00:18:28,160
在AND-GATE被调用时
an environment that was created at the--those produce a frame

284
00:18:28,416 --> 00:18:31,248
所创建出的环境
at the time and-gate was called,

285
00:18:33,310 --> 00:18:35,904
#TBD
A frame where A1, A2, and output are--

286
00:18:36,672 --> 00:18:39,200
#TBD
have as their values, they're bound to

287
00:18:39,600 --> 00:18:44,256
#TBD
the wires which, they are--which were passed in.

288
00:18:46,240 --> 00:18:47,312
在这个环境下
In that environment,

289
00:18:47,744 --> 00:18:49,856
我构建一个过程
I constructed a procedure

290
00:18:50,976 --> 00:18:53,680
就在这里
this one right there.

291
00:18:54,590 --> 00:18:57,312
在该环境下定义的AND-ACTION-PROCEDURE
And-action-procedure was constructed in that environment.

292
00:18:58,352 --> 00:19:00,704
这个实际上是对一个LAMBDA表达式求值
That was the result of evaluating a lambda expression.

293
00:19:01,620 --> 00:19:05,488
它跟求值该LAMBDA表达式时的环境相绑定
So it hangs onto the frame where these were defined.

294
00:19:07,168 --> 00:19:09,344
找到它的局部环境
Local--part of its local state is that.

295
00:19:11,700 --> 00:19:13,472
因此 AND-ACTION-PROCEDURE 过程能够
The and-action-procedure, therefore, has

296
00:19:13,648 --> 00:19:16,940
存取这里看到的 A1 A2 和 OUTPUT
access to A1, A2, and output as we see here.

297
00:19:17,310 --> 00:19:19,645
A1 A2 OUTPUT
A1, A2, and output.

298
00:19:22,360 --> 00:19:23,952
我们还没有深入探索“电线”的内部结构
Now, we haven't looked inside of a wire yet.

299
00:19:26,030 --> 00:19:26,992
那是仅剩的部分
That's all that remains.

300
00:19:29,030 --> 00:19:29,920
来看看“电线”
Let's look at a wire.

301
00:19:33,520 --> 00:19:36,160
非常棒的结构
Like the overhead, very good.

302
00:19:39,500 --> 00:19:43,090
“电线”是有那么一点复杂
Well, the wire, again, is a, is a somewhat complicated mess.

303
00:19:43,090 --> 00:19:46,840
哦，说错了
Ooh, wrong one.

304
00:19:46,840 --> 00:19:49,780
是非常复杂
It's a big complicated mess, like that.

305
00:19:49,780 --> 00:19:54,720
但是还是来看一下，到底是什么
But let's look at it in detail and see what's going on.

306
00:19:54,720 --> 00:19:57,760
“电线”是这上面画的云一样的东西
Well, the wire is one of these.

307
00:19:57,760 --> 00:20:05,010
有两个主要部分，都是它的状态
And it has to have two things that are part of it, that it's state.

308
00:20:05,010 --> 00:20:07,390
其中一个是信号值
One of them is the signal we see here.

309
00:20:07,390 --> 00:20:19,270
换句话说，当我们执行make-wire，首先要做的是新建两个局部变量signal和action-procs
In other words, when we call make-wire to make a wire, then the first thing we do is we create some variables which are the signal and the action procedures for this wire.

310
00:20:22,042 --> 00:20:27,840
在这个上下文中，我们定义了一系列的过程
And in that context, we define various functions--or procedures, excuse me, procedures.

311
00:20:27,840 --> 00:20:32,850
先看(set-my-signal! new)
One of them is called set-my-signal to a new value.

312
00:20:32,850 --> 00:20:37,930
它所做的只是，取一个新值new
And what that does is takes a new value in.

313
00:20:37,930 --> 00:20:40,360
如果new和signal一样，信号没有变化，就没必要做什么了
If that's equal to my current value of my signal, I'm done.

314
00:20:40,360 --> 00:20:54,630
否则，把signal的值赋值为new，再执行action-procs里的所有过程，即通知所有“相关的人”
Otherwise, I set the signal to the new value and call each of the action procedures that I've been, that I've been--what's the right word?--  introduced to.

315
00:20:54,630 --> 00:21:01,530
当作为and-gate的参数的时候，它就是我的“联系人”了，得去通知它
I get introduced when the and-gate was applied to me.

316
00:21:04,130 --> 00:21:07,410
添加“联系人”的这个过程在最下面
I add action procedure at the bottom.

317
00:21:07,410 --> 00:21:27,780
然后，我还得定义一个接受动作过程的过程，就在这里，使用con把新的过程与原来的过程列表连接在一起，再赋值予action-pros，最后还要再运行一次这个过程proc
Also, I have to define a way of accepting an action procedure-- which is what you see here--- which increments my action procedures using set to the result of CONSing up a new process--a procedure, which is passed to me, on to my actions procedures list. And for technical reasons, I have to call that procedure one.

318
00:21:27,780 --> 00:21:36,950
这是一种事件驱动的模拟模型，我还不打算细讲，因为那还需要思考更多的内容
So I'm not going to tell you anything about that, that has to do with event-driven simulations and getting them started, which takes a little bit of thinking.

319
00:21:36,950 --> 00:21:53,820
最后定义一个过程dispatcher，用来解读传递给线路的信息，执行不同的操作，比如这里，当前的信号值是多少？
And finally, I'm going to define a thing called the dispatcher, which is a way of passing a message to a wire, which is going to be used to extract from it various information, like what is the current signal value?

320
00:21:53,820 --> 00:21:57,180
设置新信号值的方法是什么？
What is the method of setting your signal?

321
00:21:57,180 --> 00:22:00,100
我想要这个方法
I want to get that out of it.

322
00:22:00,100 --> 00:22:02,600
我怎么样去添加另外的动作过程呢？
How do I--how do I add another action procedure?

323
00:22:05,510 --> 00:22:09,940
最后，返回过程dispatch
And I'm going to return that dispatch, that procedure as a value.

324
00:22:09,940 --> 00:22:19,790
因此整个电线的被构建成了一个可接受不同信息的对象，比如 ‘add-action!来询问添加动作过程的方法是什么？
So the wire that I've constructed is a message accepting object which accepts a message like, like what's your method of adding action procedures?

325
00:22:19,790 --> 00:22:29,010
因此实际上，它返回了一个过程，这个过程接收一个动作过程作为参数，将其实际添加入电线的action-procs的列表中
In fact, it'll give me a procedure, which is the add action procedure, which I can then apply to an action procedure to create another action procedure in the wire.

326
00:22:31,620 --> 00:22:32,820
这是一种权限
So that's a permission.

327
00:22:32,820 --> 00:22:37,450
给予你了一种去改变自身动作过程列表的权限
So it's given me permission to change your action procedures.

328
00:22:37,450 --> 00:22:41,710
再来看看这里
And in fact, you can see that over here.

329
00:22:41,710 --> 00:22:43,278
下一张幻灯片
Next slide.

330
00:22:43,278 --> 00:22:44,528
噢
Ah.

331
00:22:47,760 --> 00:22:49,120
没什么有意思的
This is nothing very interesting.

332
00:22:49,120 --> 00:22:54,990
(call-each procedures)只是对列表中过程顺序地执行调用，没什么好说的
The call each of the action procedures is just a CDRing down a list. And I'm not going to even talk about that anymore.

333
00:22:54,990 --> 00:22:57,560
我们早就知道了
We're too advanced for that.

334
00:22:57,560 --> 00:23:03,090
然而，如果我想知道线路上的信号值是多少，就得这样来询问wire
However, if I want to get a signal from a wire, I ask the wire-- which is, what is the wire?

335
00:23:03,090 --> 00:23:05,860
wire只是一个dispatch过程而已
The wire is the dispatch returned by creating the wire.

336
00:23:05,860 --> 00:23:06,830
只是一个过程
It's a procedure.

337
00:23:06,830 --> 00:23:12,590
这是是‘get-signal作为参数来执行这个过程
I call that dispatch on the message get-signal.

338
00:23:12,590 --> 00:23:16,900
实际得到的只是取得线路信号值的方法
And what I should expect to get is a method of getting a signal.

339
00:23:16,900 --> 00:23:19,220
进一步的就可以得到信号值
Or actually, I get the signal.

340
00:23:19,220 --> 00:23:38,700
如果我想要对线路设置一个新的信号值，这里传递wire和new-value两个参数，(wire 'set-signal!)取得改变线路信号的权限，实际是一个过程，应用于new-value
If I want to set a signal, I want to change a signal, then what I'm going to do is take a wire as an argument and a new value for the signal, I'm going to ask the wire for permission to set its signal and use that permission, which is a procedure, on the new value.

341
00:23:38,700 --> 00:24:13,010
我们继续追溯这个过程，调用(wire 'set-signal)之后，我们返回这个过程，定义在线路里面，名为set-my-signal，我们回头看幻灯片，返回的过程有一个实际的调用，以new-value为参数，去改变线路内部signal变量的值，最后再去依次通知“联系人”
And if we go back to the overhead here, thank you, if we go back to the overhead here, we see that the method-- if I ask for the method of setting the signal, that's over here, it's set-my-signal, a procedure that's defined inside the wire, which if we look over here is the thing that says set my internal value called the signal, my internal variable, which is the signal, to the new value, which is passed to me as an argument, and then call each of the action procedures waking them up.

342
00:24:16,340 --> 00:24:19,400
非常简单
Very simple.

343
00:24:19,400 --> 00:24:30,100
再来看看幻灯片，还有最后一点，add-action!，我想你们很轻易地就理解了
Going back to that slide, we also have the one last thing-- which I suppose now you can easily work out for yourself-- is the way you add an action.

344
00:24:30,100 --> 00:24:36,470
wire action-proc两个参数
You take a wire--a wire and an action procedure.

345
00:24:36,470 --> 00:24:40,050
然后请求添加动作过程的权限
And I ask the wire for permission to add an action.

346
00:24:40,050 --> 00:24:45,020
得到权限去添加新的动作过程
Getting that permission, I use that permission to give it an action procedure.

347
00:24:45,020 --> 00:24:48,570
这就是整个“电线”对象
So that's a real object.

348
00:24:48,570 --> 00:24:52,460
还有些细节
There's a few more details about this.

349
00:24:52,460 --> 00:24:58,390
比如，我怎么来控制它？
For example, how am I going to control this thing?

350
00:24:58,390 --> 00:25:01,290
这些延时怎么实现？
How do I do these delays?

351
00:25:01,290 --> 00:25:02,540
我们来快速过一遍
Let's look at that for a second.

352
00:25:05,275 --> 00:25:08,360
下一张
The next one here.

353
00:25:08,360 --> 00:25:09,570
我们来看看
Let's see.

354
00:25:09,570 --> 00:25:18,770
我们细看与门或者或门定义，会发现里面还有“延时”这样的东西
We know when we looked at the and-gate or the not-gate that when a signal changed on the input, there was a delay.

355
00:25:18,770 --> 00:25:23,310
一段延时之后才开始执行过程，改变输出
And then it was going to call the procedure, which was going to change the output.

356
00:25:26,040 --> 00:25:28,120
这个要如何实现？
Well, how are we going to do this?

357
00:25:28,120 --> 00:25:34,720
这里引入一种新技巧，非常复杂，我们得非常细心地来看
We're going to make up some mechanism, a fairly complicated mechanism at that, which we're going to have to be very careful about.

358
00:25:34,720 --> 00:25:37,390
在“delay”的延时之后，执行过程action
But after a delay, we're going to do an action.

359
00:25:37,390 --> 00:25:40,590
"delay"是一个数字，"action“是一个过程
A delay is a number, and an action is a procedure.

360
00:25:40,590 --> 00:25:49,510
这里有一个特殊的数据结构the-agenda，用于组织时间与动作过程
What that's going to be is they're going to have a special structure called an agenda, which is a thing that organizes time and actions.

361
00:25:49,510 --> 00:25:50,880
一会儿再来细看它
And we're going to see that in a while.

362
00:25:50,880 --> 00:25:53,070
先把这里说完
I don't want to get into that right now.

363
00:25:53,070 --> 00:25:59,130
the-agenda记录下来一个动作过程未来执行的时间
But the agenda has a moment at which--at which something happens.

364
00:25:59,130 --> 00:26:08,460
在current-time + delay段的时间之后，将会执行那个过程
We're setting up for later at some moment, which is the sum of the time, which is the delay time plus the current time, which the agenda thinks is now.

365
00:26:08,460 --> 00:26:13,090
这个过程随着计算好的这个时刻，添加入the-agenda中
We're going to set up to do this action, and add that to the agenda.

366
00:26:15,280 --> 00:26:18,660
要使这个”计时钟表“运行起来并不困难
And the way this machine will now run is very simple.

367
00:26:18,660 --> 00:26:22,710
下面这个过程progagate，就是来做这件事的
We have a thing called propagate, which is the way things run.

368
00:26:22,710 --> 00:26:27,440
如果the-agenda是空的，就没有要做的
If the agenda is empty, we're done--if there's nothing more to be done.

369
00:26:27,440 --> 00:26:34,200
否则，我们就取出the-agenda的第一个元素，它是一个没有参数的过程
Otherwise, we're going to take the first item off the agenda, and that's a procedure of no arguments.

370
00:26:34,200 --> 00:26:36,030
这里有两层括号
So that we're going to see extra parentheses here.

371
00:26:36,030 --> 00:26:39,190
里面的一层返回一个过程，外面的一层括号执行了这个过程
We call that on no arguments.

372
00:26:39,190 --> 00:26:42,200
就是之前存储入the-agenda的动作
That takes the action.

373
00:26:42,200 --> 00:26:48,395
然后这个过程就可以从the-agenda删掉了，最后执行propagate，进行无限循环
Then we remove that first item from the agenda, and we go around the propagation loop.

374
00:26:48,395 --> 00:26:50,750
这就是整体的结构
So that's the overall structure of this thing.

375
00:26:53,380 --> 00:26:57,430
还有点其它的
Now, there's a, a few other things we can look at.

376
00:26:57,430 --> 00:27:00,410
一会儿再来看the-agenda
And then we're going to look into the agenda a little while from now.

377
00:27:00,410 --> 00:27:02,800
现在整体上来看
Now the overhead again.

378
00:27:02,800 --> 00:27:07,410
说点题外话
Well, in order to set this thing going, I just want to show you some behavior out of this simulator.

379
00:27:07,410 --> 00:27:12,370
这个模拟器其实是非常简单，简单到你认为它根本没什么用
By the way, you may think this simulator is very simple, and probably too simple to be useful.

380
00:27:12,370 --> 00:27:18,680
事实上这样的模拟器曾用来操纵大型机
The fact of the matter is that this simulator has been used to manufacture a fairly large computer.

381
00:27:18,680 --> 00:27:22,360
那是一个真实的案例
So this is a real live example.

382
00:27:22,360 --> 00:27:25,560
实际上这两个模拟器有点不同
Actually, not exactly this simulator, because I'll tell you the difference.

383
00:27:25,560 --> 00:27:29,820
不同之处在于操纵大型机的模拟器有更多的原子结构
The difference is that there were many more different kinds of primitives.

384
00:27:29,820 --> 00:27:33,200
不只是有非门，与门之类的
There's not just the word inverter or and-gate.

385
00:27:33,200 --> 00:27:45,170
还有边缘触发器，触发电路，锁存器，电平触发器，加法器等等之类的
There were things like edge-triggered, flip-flops, and latches, transparent latches, and adders, and things like that.

386
00:27:45,170 --> 00:27:54,690
困难之处在于需要很多页的文档来描述这些原子结构
And the difficulty with that is that there's pages and pages of the definitions of all these primitives with numbers like LS04.

387
00:27:54,690 --> 00:27:56,740
同时它们还有很多的参数
And then there's many more parameters for them.

388
00:27:56,740 --> 00:27:58,480
不是只有一个延时这么简单
It's not just one delay.

389
00:27:58,480 --> 00:28:01,220
还有建立时间，维持时间之类的
There's things like set up times and hold times and all that.

390
00:28:01,220 --> 00:28:15,110
真实计算机的结构确实复杂，但是那么所谓模拟器的部分却和这里我们要讲的很相似
But with the exception of that part of the complexity, the structure of the simulator that we use for building a real computer, that works is exactly what you're seeing here.

391
00:28:15,110 --> 00:28:19,270
回到正题，这些东西都很简单
Well in any case, what we have here is a few simple things.

392
00:28:19,270 --> 00:28:23,030
像这个，设置非门的延时时间，构建一个the-agenda
Like, there's inverter delays being set up and making a new agenda.

393
00:28:23,030 --> 00:28:26,470
这里我们可以用(make-wire)构建更多线路
And then we can make some inputs.

394
00:28:26,470 --> 00:28:29,460
这里只有4个，input-1 input-2 sum carry
There's input-1, input-2, a sum and a carry, which are wires.

395
00:28:29,460 --> 00:28:37,810
过程probe在sum carry对象上放置了一种称为探测器的特殊对象
I'm going to put a special kind of object called a probe onto, onto some of the wires, onto sum and onto carry.

396
00:28:37,810 --> 00:28:46,120
探测器可以在被监测的对象信号改变的时候，输出一条消息
A probe is a, can object that has the property that when you change a wire it's attached to, it types out a message.

397
00:28:46,120 --> 00:28:47,970
这很容易实现
It's an easy thing to do.

398
00:28:47,970 --> 00:28:59,400
这里，我们第一次执行(probe 'sum sum)，它打印出消息说，当前sum在时刻0的信号值是0
And then once we have that, of course, the way you put the probe on, the first thing it does, it says, the current value of the sum at time 0 is 0 because I just noticed it.

399
00:28:59,400 --> 00:29:05,556
carry与sum相同
And the value of the carry at time 0, this is the time, is 0.

400
00:29:05,556 --> 00:29:09,620
我们继续来构建更多结构
And then we go off and we build some structure.

401
00:29:09,620 --> 00:29:18,420
比如这里构建一个半加器
Like, we can build a structure here that says you have a half-adder on input-1, input-2, sum, and carry.

402
00:29:18,420 --> 00:29:20,420
现在把input-1上的信号变为1
And we're going to set the signal on input-1 to 1.

403
00:29:20,420 --> 00:29:21,880
然后开始模拟
We do some propagation.

404
00:29:21,880 --> 00:29:29,520
在时刻8的时候，sum的信号变为1
At time 8, which you could see going through this thing if you wanted to, the new value of sum became 1.

405
00:29:29,520 --> 00:29:31,150
然后没有然后了
And the thing says I'm done.

406
00:29:31,150 --> 00:29:32,630
好像没什么意思
That wasn't very interesting.

407
00:29:32,630 --> 00:29:34,150
我们继续
But we can send it some more signals.

408
00:29:34,150 --> 00:29:36,590
把input-2也变为1
Like, we set-signal on input-2 to be one.

409
00:29:36,590 --> 00:29:45,040
如果再模拟，在时刻11，carry变为1，时刻16，sum变为0
And at that time if we propagate, then it carried at 11, the carry becomes 1, and at 16, the sum's new value becomes 0.

410
00:29:45,040 --> 00:29:48,990
如果你想，你可以实现一个电子电路
And you might want to work out that, if you like, about the digital circuitry.

411
00:29:48,990 --> 00:29:50,620
真的，确实可以
It's true, and it works.

412
00:29:50,620 --> 00:29:51,535
把input-2变为1，整个过程看起来也没什么特别的
And it's not very interesting.

413
00:29:51,535 --> 00:29:54,580
但是却清楚地表明了这一些都是如何运作的
But that's the kind of behavior we get out of this thing.

414
00:30:01,830 --> 00:30:12,952
现在我给你们呈现的是一种宏观的图景，如何去实现事件驱动的模拟
So what I've shown you right now is a large-scale picture, how you, at a bigger, big scale, you implement an event-driven simulation of some sort.

415
00:30:12,952 --> 00:30:21,225
你如何组织出有层次性的结构，构建抽象的盒子
And how you might organize it to have nice hierarchical structure allowing you to build abstract boxes that you can instantiate.

416
00:30:21,225 --> 00:30:25,780
the-agenda忘记说了
But I haven't told you any of the details about how this agenda and things like that work.

417
00:30:25,780 --> 00:30:28,630
下一小节再说
That we'll do next.

418
00:30:28,630 --> 00:30:34,310
这将涉及到一些关于数据变化之类的事情
And that's going to involve change and mutation of data and things like that.

419
00:30:34,310 --> 00:30:35,860
在我继续之前，有什么问题吗？
Are there any questions now, before I go on?

420
00:30:47,160 --> 00:30:47,550
没有的话
Thank you.

421
00:30:47,550 --> 00:30:48,800
休息时间
Let's take a break.

422
00:31:28,940 --> 00:31:35,060
我们已经做了一个模拟器
Well, we've been making a simulation.

423
00:31:35,060 --> 00:31:43,920
这种模拟是事件驱动的，计算机中的对象与现实中的对象一一对应
And the simulation is an event-driven simulation where the objects in the world are the objects in the computer.

424
00:31:43,920 --> 00:32:04,420
现实世界中的时间相对的也由计算机中的时间代替，假如现实中这件事发生在那件事之后，在计算机中也应该是这样，同样的顺序
And the changes of state that are happening in the world in time are organized to be time in the computer, so that if something happens after something else in the world, then we have it happen after, after the corresponding events happen in the same order in the computer.

425
00:32:04,420 --> 00:32:08,220
那也是我们引入赋值的开始
That's where we have assignments, when we make that alignment.

426
00:32:08,220 --> 00:32:16,040
现在我要介绍一种方法来组织时间，用agenda和优先队列来实现
Right now I want to show you a way of organizing time, which is an agenda or priority queue, it's sometimes called.

427
00:32:16,040 --> 00:32:21,230
这样做之前，先来了解点别的
We'll do some--we'll do a little bit of just understanding what are the things we need to be able to do to make agendas.

428
00:32:28,330 --> 00:32:35,960
这里我们先写一些对于agenda的基础操作
And so we're going to have--and so right now over here, I'm going to write down a bunch of primitive operations for manipulating agendas.

429
00:32:35,960 --> 00:32:43,680
具体实现我就不细说了，非常简单而且你们手上也有
I'm not going to show you the code for them because they're all very simple, and you've got listings of all that anyway.

430
00:32:43,680 --> 00:32:44,380
有什么操作呢？
So what do we have?

431
00:32:44,380 --> 00:32:54,130
make-agenda构造一个agenda
We have things like make-agenda which produces a new agenda.

432
00:32:59,860 --> 00:33:12,625
current-time，取得当前的时间，是一个数字
We can ask--we get the current-time of an agenda, which gives me a number, a time.

433
00:33:16,990 --> 00:33:21,900
empty-agenda，判断agenda是否为空
We can get--we can ask whether an agenda is empty, empty-agenda.

434
00:33:30,200 --> 00:33:32,570
返回true或false
And that produces either a true or a false.

435
00:33:42,590 --> 00:33:44,720
也要向agenda添加对象
We can add an object to an agenda.

436
00:33:52,710 --> 00:33:56,910
现实上这里添加的对象是一个过程，一个动作过程
Actually, what we add to an agenda is an operation--an action to be done.

437
00:33:56,910 --> 00:34:04,810
一共3个参数，时间time，动作过程action，要添加入的agenda
And that takes a time, the action itself, and the agenda I want to add it to.

438
00:34:07,850 --> 00:34:10,719
把action放入agenda合适的地方
That inserts it in the appropriate place in the agenda.

439
00:34:10,719 --> 00:34:23,259
(FIRST-ITEM agenda)用于取出agenda中第一个item
I can get the first item off an agenda, the first thing I have to do, which is going to give me an action.

440
00:34:26,085 --> 00:34:29,540
还可以把第一个item从中删除
And I can remove the first item from an agenda.

441
00:34:29,540 --> 00:34:31,409
这些就是对agenda的全部基础操作
That's what I have to be able to do with agendas.

442
00:34:31,409 --> 00:34:33,020
杂乱不甚
That is a big complicated mess.

443
00:34:42,530 --> 00:34:43,780
从agenda删除
From an agenda.

444
00:34:45,530 --> 00:34:52,528
现在我们来看如何具体组织数据结构
Well, let's see how we can organize this thing as a data structure a bit.

445
00:34:52,528 --> 00:35:01,570
agenda应该是一个列表，一个可修改的列表
Well, an agenda is going to be some kind of list. And it's going to be a list that I'm going to have to be able to modify.

446
00:35:01,570 --> 00:35:11,070
因为我们要向其中添加，删除，所以列表必定是可被修改的
So we have to talk about modifying of lists, because I'm going to add things to it, and delete things from it, and things like that.

447
00:35:11,070 --> 00:35:13,820
它依时间来组织
It's organized by time.

448
00:35:13,820 --> 00:35:15,570
以某种顺序排序起来也是有益的
It's probably good to keep it in sorted order.

449
00:35:18,330 --> 00:35:23,420
但是也有可能同一时间会发生很多事，需要执行很多过程
But sometimes there are lots of things that happen at the same time--approximate same time.

450
00:35:23,420 --> 00:35:29,040
我们把将要发生的事，要执行的过程按时间顺序来组织
What I have to do is say, group things by the time at which they're supposed to happen.

451
00:35:29,040 --> 00:35:32,780
所以agenda看起来就像是很多segment组成的列表
So I'm going to make an agenda as a list of segments.

452
00:35:32,780 --> 00:35:39,620
我来画一下这个结构，好让人理解
And so I'm going to draw you a data structure for an agenda, a perfectly reasonable one.

453
00:35:39,620 --> 00:35:41,110
这是一个agenda
Here's an agenda.

454
00:35:41,110 --> 00:35:42,870
以一个名字开始
It's a thing that begins with a name.

455
00:35:47,630 --> 00:35:49,940
在画具体的表结构之前先画它
I'm going to do it right now out of list structure.

456
00:35:52,620 --> 00:35:53,980
作为一个头部
It's got a header.

457
00:35:53,980 --> 00:35:55,840
这个头部的存在也是很必要的
There's a reason for the header.

458
00:35:55,840 --> 00:35:57,630
待会你就会知道
We're going to see the reason soon.

459
00:36:00,680 --> 00:36:03,750
再画一个segment
And it will have a segment.

460
00:36:03,750 --> 00:36:05,620
这将是许多segment组成的列表
It will have--it will be a list of segments.

461
00:36:08,310 --> 00:36:33,320
假设现在有两个segment，这样连接在一起-- 连接使用CAR就可访问到 -- 每个segment都要有一个时间，代表动作过程要执行的时间，比如这个就是10
Supposing this agenda has two segments, they're the car's-- successive car's of this list. Each segment is going to have a time--  say for example, 10-- that says that the things that happen in this segment are at time 10.

462
00:36:33,320 --> 00:36:42,240
这里还要有另一个数据结构，先不具体描述，代表在时刻10将要做的事
And what I'm going to have in here is another data structure which I'm not going to describe, which is a queue of things to do at time 10.

463
00:36:42,240 --> 00:36:43,330
一个队列
It's a queue.

464
00:36:43,330 --> 00:36:45,130
一会儿再细说
And we'll talk about that in a second.

465
00:36:45,130 --> 00:36:50,200
抽象来看，队列就是一系列在一个固定时间要做的事情的集合
But abstractly, the queue is just a list of things to do at a particular time.

466
00:36:50,200 --> 00:36:53,100
我可以向其中添加其它要做的事
And I can add things to a queue.

467
00:36:53,100 --> 00:36:56,140
一个队列
This is a queue.

468
00:36:56,140 --> 00:36:59,115
一个时刻，两者就是segment的主要元素
There's a time, there's a segment.

469
00:37:02,889 --> 00:37:06,035
这里还有一个segment
Now, I may have another segment in this agenda.

470
00:37:08,940 --> 00:37:13,410
假设其时刻是30
Supposing this is stuff that happens at time 30.

471
00:37:13,410 --> 00:37:23,210
类似的，这里也要有一个队列，记录这一时刻将发生的事
It has, of course, another queue of things that are queued up to be done at time 30.

472
00:37:23,210 --> 00:37:27,090
现在我们来看看，对agenda的一系列操作
Well, there are various things I have to be able to do to an agenda.

473
00:37:27,090 --> 00:37:33,030
假设我想在时刻10，想做新的事情
Supposing I want to add to an agenda another thing to be done at time 10.

474
00:37:33,030 --> 00:37:34,700
这并不难
Well, that's not very hard.

475
00:37:34,700 --> 00:37:39,730
我只需要沿着这下来，找到时刻是10的segment
I'm going to walk down here, looking for the segment of time 10.

476
00:37:39,730 --> 00:37:42,930
也可能这样的一个segment并不存在
It is possible that there is no segment of time 10.

477
00:37:42,930 --> 00:37:45,420
一会儿再谈这种情况
We'll cover that case in a second.

478
00:37:45,420 --> 00:37:56,290
如果我找到了这样一个segment，就把这件事放入队列中 -- 尽管要怎样加入队列并不明显
But if I find a segment of time 10, then if I want to add another thing to be done at time 10, I just increase that queue-- "just increase" isn't such an obvious idea.

479
00:37:56,290 --> 00:38:01,430
但是那时我就得这样做
But I increase the things to be done at that time.

480
00:38:01,430 --> 00:38:05,140
现在，假设我想在时刻20做点什么
Now, supposing I want to add something to be done at time 20.

481
00:38:05,140 --> 00:38:08,680
然而并没有时刻是20的segment
There is no segment for time 20.

482
00:38:08,680 --> 00:38:11,340
我不得不构造一个segment
I'm going to have to create a new segment.

483
00:38:11,340 --> 00:38:17,610
我想把这个segment放在10与30之间
I want my time 20 segment to exist between time 10 and time 30.

484
00:38:17,610 --> 00:38:20,170
这着实要花点功夫
Well, that takes a little work.

485
00:38:20,170 --> 00:38:21,525
先用CONS
I'm going to have to do a CONS.

486
00:38:24,260 --> 00:38:29,940
构建一个新的segment
I'm going to have to make a new element of the agenda list--list of segments.

487
00:38:33,600 --> 00:38:35,400
这里的连接必须要变
I'm going to have to change.

488
00:38:35,400 --> 00:38:37,540
就像这样
Here's change.

489
00:38:37,540 --> 00:38:56,657
把segment 10的CDR指向新的segment 20，新的segment 20的CDR指向segment 30
I'm going to have to change the CDR of the CDR of the agenda to point that a new CONS of the new segment and the CDR of the CDR of the CDR of the agenda, the CD-D-D-DR.

490
00:38:56,657 --> 00:39:06,290
这个segment的时刻为20，队列只有一件事要做
And this is going to have a new segment now of time 20 with its own queue, which now has one element in it.

491
00:39:10,730 --> 00:39:20,770
如果我想在后面添加点什么，就更改这个CDR指向要添加的东西
If I wanted to add something at the end, I'm going to have to replace the CDR of this, of this list with something.

492
00:39:20,770 --> 00:39:24,040
必须对数据结构进行修改
We're going to have to change that piece of data structure.

493
00:39:24,040 --> 00:39:27,210
因此我需要新的基础操作
So I'm going to need new primitives for doing this.

494
00:39:27,210 --> 00:39:29,550
因为原有的基础操作达不到这一点
But I'm just showing you why I need them.

495
00:39:29,550 --> 00:39:49,400
如果我想在时刻5做点什么事，按时间顺序来看，就得改变这里的CDR，这也就是我留了一个“头”的原因，可以方便的进行在队列头插入的操作
And finally, if I wanted to add a thing to be done at time 5, I'm going to have to change this one, because I'm going to have to add it in over here, which is why I planned ahead and had a header cell, which has a place.

496
00:39:49,400 --> 00:39:53,420
如果我想做些改变
If I'm going to change things, I have to have places for the change.

497
00:39:53,420 --> 00:39:58,600
就必须找准哪些地方需要修改
I have to have a place to make the change.

498
00:39:58,600 --> 00:40:02,540
从agenda中删除东西并不困难
If I remove things from the agenda, that's not so hard.

499
00:40:02,540 --> 00:40:11,220
删除操作非常简单，我只讲一种情况，先找到第一个segment
Removing them from the beginning is pretty easy, which is the only case I have. I can go looking for the first, the first segment.

500
00:40:11,220 --> 00:40:14,510
判断队列是否为空
I see if it has a non-empty queue.

501
00:40:14,510 --> 00:40:20,100
如果队列不是空的，就把要移除的事情从队列中删掉
If it has a non-empty queue, well, I'm going to delete one element from the queue, like that.

502
00:40:20,100 --> 00:40:24,220
如果这时队列变为空的，就还要继续把segment删掉
If the queue ever becomes empty, then I have to delete the whole segment.

503
00:40:24,220 --> 00:40:28,220
这里，把“头”的CDR指向这里
And then this, this changes to point to here.

504
00:40:28,220 --> 00:40:36,440
这个数据结构操作起来很复杂，很无趣
So it's quite a complicated data structure manipulation going on, the details of which are not really very exciting.

505
00:40:36,440 --> 00:40:38,920
现在我们来聊聊队列
Now, let's talk about queues.

506
00:40:38,920 --> 00:40:41,160
它们很相似
They're similar.

507
00:40:41,160 --> 00:40:44,340
每一个segment都有一个队列
Because each of these agendas has a queue in it.

508
00:40:44,340 --> 00:40:45,590
队列是什么？
What's a queue?

509
00:40:49,079 --> 00:40:52,350
一个队列有这些基础操作
A queue is going to have the following primitive operations.

510
00:40:52,350 --> 00:41:02,170
MAKE-QUEUE 构建一个新队列
To make a queue, this gives me a new queue.

511
00:41:07,274 --> 00:41:16,850
INSERT-QUEUE！ 向队列中插入新元素
I'm going to have to be able to insert into a queue a new item.

512
00:41:24,510 --> 00:41:28,740
DELETE-QUEUE！ 从队列中删除元素
I'm going to have to be able to delete from a queue the first item in the queue.

513
00:41:39,988 --> 00:41:52,890
FRONT-QUEUE 查看队列中第一个元素
And I want to be able to get the first thing in the queue from some queue.

514
00:41:52,890 --> 00:41:55,140
还需要检测队列是否为空
I also have to be able to test whether a queue is empty.

515
00:42:07,110 --> 00:42:15,120
如果你以后要发明些类似的基础操作，我希望你要注意下命名约定
And when you invent things like this, I want you to be very careful to use the kinds of conventions I use for naming things.

516
00:42:15,120 --> 00:42:19,870
有改动的操作加上！，判断的谓词用？
Notice that I'm careful to say these change something and that tests it.

517
00:42:19,870 --> 00:42:24,335
看起来，和这边的好像差不多
And presumably, I did the same thing over here.

518
00:42:24,335 --> 00:42:29,240
嗯，这里也需要一个是否为空的检测
OK, and there should be an empty test over here.

519
00:42:29,240 --> 00:42:31,720
好的，我要如何构建一个队列呢？
OK, well, how would I make a queue?

520
00:42:31,720 --> 00:42:37,840
队列是一个后进先出的结构
A queue wants to be something I can add to at the end of, and pick up the thing at the beginning of.

521
00:42:37,840 --> 00:42:41,230
从队列头删除元素，向队列尾添加元素
I should be able to delete from the beginning and add to the end.

522
00:42:41,230 --> 00:42:43,740
我可以用一种很简单的结构来实现
Well, I'm going to show you a very simple structure for that.

523
00:42:43,740 --> 00:42:47,080
先有一个序对
We can make this out of CONSes as well.

524
00:42:47,080 --> 00:42:49,910
整个队列的开始
Here's a queue.

525
00:42:49,910 --> 00:42:59,610
这是一个队列“头”，包含一个头指针和一个尾指针
It has--it has a queue header, which contains two parts-- a front pointer and a rear pointer.

526
00:43:02,930 --> 00:43:09,000
假如队列一共两个元素
And here I have a queue with two items in it.

527
00:43:09,000 --> 00:43:12,095
第一个，值假定是1
The first item, I don't know, it's perhaps a 1.

528
00:43:12,095 --> 00:43:16,530
第二个假定是2吧
And the second item, I don't know, let's give it a 2.

529
00:43:21,160 --> 00:43:31,850
需要两个指针的原因在于，向尾部添加元素的时候，就不用一直CDR找到结尾这样费力
The reason why I want two pointers in here, a front pointer and a rear pointer, is so I can add to the end without having to chase down from the beginning.

530
00:43:31,850 --> 00:43:47,530
例如，我想要向队列添加入一个新元素，只需要先用CONS构建一个序对，假如值是3
So for example, if I wanted to add one more item to this queue, if I want to add on another item to be worried about later, all I have to do is make a CONS, which contains that item, say a 3.

531
00:43:47,530 --> 00:43:51,340
再添加到队列里
That's for inserting 3 into the queue.

532
00:43:51,340 --> 00:44:00,100
这里就需要把item 2的CDR指向item 3
Then I have to change this pointer here to here.

533
00:44:00,100 --> 00:44:04,320
尾指针也指到最后
And I have to change this one to point to the new rear.

534
00:44:09,120 --> 00:44:18,890
如果我想查看第一个元素，由头指针就可以轻易找到
If I wish to take the first element of the queue, the first item, I just go chasing down the front pointer until I find the first one and pick it up.

535
00:44:18,890 --> 00:44:27,450
如果想删除元素，只需要把头指针向后移到就行
If I wish to delete the first item from the queue, delete-queue, all I do is move the front pointer along this way.

536
00:44:27,450 --> 00:44:31,700
新的头指针指向这里
The new front of the queue is now this.

537
00:44:31,700 --> 00:44:34,390
所以队列比较简单
So queues are very simple too.

538
00:44:34,390 --> 00:44:41,350
我们需要一些另外的基础操作来支持这种修改操作
So what you see now is that I need a certain number of new primitive operations.

539
00:44:41,350 --> 00:44:42,560
我先列出它们的名字
And I'm going to give them some names.

540
00:44:42,560 --> 00:44:47,350
然后我们再来看它们是如何使用的
And then we're going to look into how they work, and how they're used.

541
00:44:47,350 --> 00:44:58,940
SET-CAR！ 改变一个序对的CAR为一个新值
We have set the CAR of some pair, or a thing produced by CONSing, to a new value.

542
00:45:02,370 --> 00:45:09,920
SET-CDR！和它类似
And set the CDR of a pair to a new value.

543
00:45:12,680 --> 00:45:16,030
现在来看看它们到底做了什么
And then we're going to look into how they work.

544
00:45:16,030 --> 00:45:20,960
我用SET-CAR！修改头指针的指向，删除第一个元素
I needed setting CAR over here to delete the first element of the queue.

545
00:45:20,960 --> 00:45:23,470
这是CAR，我把它SET为另的值
This is the CAR, and I had to set it.

546
00:45:23,470 --> 00:45:30,160
同理SET-CDR！修改尾指针的指向来添加元素
I had to be able to set the CDR to be able to move the rear pointer, or to be able to increment the queue here.

547
00:45:30,160 --> 00:45:35,515
全部的修改工作都是由SET-CAR！ SET-CDR！完成的
All of the operations I did were made out of those that I just showed you on the, on the last blackboard.

548
00:45:38,230 --> 00:45:38,430
非常完美
Good.

549
00:45:38,430 --> 00:45:40,357
先讲到这里，大家休息一下
Let's pause the time, and take a little break then.

550
00:46:38,346 --> 00:47:21,850
当我们讲到CONS的时候，我们提到了CONS的原则，(car (cons x y)) => x，(cdr (cons x y )) => y
When we originally introduced pairs made out of CONS, made by CONS, we only said a few axioms about them, which were of the form-- what were they-- for all X and Y, the CAR of the CONS of X and Y is X and the CDR of the CONS of X and Y is Y. Now, these say nothing about whether a CONS has an identity like a person.

551
00:47:21,850 --> 00:47:29,740
这个描述的有点抽象，CONS是由它组成的部分所组成的
In fact, all they say is something sort of abstract, that a CONS is the parts it's made out of.

552
00:47:29,740 --> 00:47:37,390
要是这样来看，如果两个CONS，它们两个的组成部分是相同的，从原则来看，这两个CONS就应该相同
And of course, two things are made out of the same parts, they're the same, at least from the point of view of these axioms.

553
00:47:37,390 --> 00:47:49,830
但是引入了赋值以后，数据变成了变量，值可以通过赋值来改变，比如用SET-CAR！ SET-CDR！，这样来看，这些原则好像没有把CONS描述清楚
But by introducing assignment-- in fact, mutable data is a kind of assignment, we have a set CAR and a set CDR-- by introducing those, these axioms no longer tell the whole story.

554
00:47:49,830 --> 00:47:53,250
但是这里写的也是对的
And they're still true if written exactly like this.

555
00:47:53,250 --> 00:47:56,070
只不过描述的不再完整
But they don't tell the whole story.

556
00:47:56,070 --> 00:48:10,090
如果我用SET-CAR！ SET-CDR！改变两个CONS，使它们的CAR和CDR都相同，这两个CONS是否是完全相同的？
Because if I'm going to set a particular CAR in a particular CONS, the questions are, well, is that setting all CARs and all CONSes of the same two things or not?

557
00:48:10,090 --> 00:48:21,570
假如我用CONS构建两个有理数，两个3/4
If I--if we use CONSes to make up things like rational numbers, or things like 3 over 4, supposing I had two three-fourths.

558
00:48:21,570 --> 00:48:25,340
这两个一样吗？还是不一样？
Are they the same one-- or are they different?

559
00:48:25,340 --> 00:48:27,860
当然，对于数字来说，这并不重要
Well, in the case of numbers, it doesn't matter.

560
00:48:27,860 --> 00:48:33,020
因为这两个有理数表示的大小是一样的，都是3/4
Because there's no meaning to changing the denominator of a number.

561
00:48:33,020 --> 00:48:36,840
你可以改变一个有理数的分母来使它们变的不一样
What you could do is make a number which has a different denominator.

562
00:48:36,840 --> 00:48:44,770
但是这看来很怪异，强制的改变分母使其两个有理数有区别，这也和数学上认知不符合
But the concept of changing a number which has to have a different denominator is sort of a very weird, and sort of not supported by what you think of as mathematics.

563
00:48:44,770 --> 00:48:53,690
但是，如果CONS表示的是现实世界中的物体，修改CAR就像剪掉你的指甲一样，是切实存在的
However, when these CONSes represent things in the physical world, then changing something like the CAR is like removing a piece of the fingernail.

564
00:48:53,690 --> 00:48:57,770
所以，每一个CONS都是不同的，它们有自己的身份
And so CONSes have an identity.

565
00:48:57,770 --> 00:49:01,280
我来先说明“身份”是什么意思
Let me show you what I mean about identity, first of all.

566
00:49:01,280 --> 00:49:04,320
来看些例子
Let's do some little example here.

567
00:49:04,320 --> 00:49:15,200
假如(define a (cons 1 2))
Supposing I define A to the CONS of 1 and 2.

568
00:49:18,040 --> 00:49:38,120
这是什么意思呢？在环境中的某处有一个符号a，它代表了一个序对，CAR指向1，CDR指向2
Well, what that means, first of all, is that somewhere in some environment I've made a symbol A to have a value which is a pair consisting of pointers to a 1 and a pointer to a 2, just like that.

569
00:49:38,120 --> 00:50:03,970
假设再定义一个b，(define b (cons a a))
Now, supposing I also say define B to be the CONS--  it doesn't matter, but I like it better, it's prettier-- of A and A.

570
00:50:03,970 --> 00:50:07,840
这里用了两次a
Well, first of all, I'm using the name A twice.

571
00:50:07,840 --> 00:50:11,300
现在就要考虑序对的身份问题了
At this moment, I'm going to think of CONSes as having identity.

572
00:50:11,300 --> 00:50:13,690
这两个a是一样的，是同一个东西
This is the same one.

573
00:50:13,690 --> 00:50:33,260
所以b是这样的一个序对，CAR与CDR都指向a，对于a来说，有三个别名都代表着它
And so what that means is I make another pair, which I'm going to call B. And it contains two pointers to A. At this point, I have three names for this object.

574
00:50:33,260 --> 00:50:34,790
a是一个
A is its name.

575
00:50:34,790 --> 00:50:37,230
(car b)是一个
The CAR of B is its name.

576
00:50:37,230 --> 00:50:39,360
(cdr b)也是一个
And the CDR of B is its name.

577
00:50:39,360 --> 00:50:41,150
都是这个序对的别名
It has several aliases, they're called.

578
00:50:44,230 --> 00:51:07,880
假设现在执行 (SET-CAR! (CAR B) 3)
Now, supposing I do something like set-the-CAR, the CAR of the CAR of B to 3.

579
00:51:12,750 --> 00:51:17,830
找到b的CAR
What that means is I find the CAR of B, that's this.

580
00:51:17,830 --> 00:51:20,935
把它的CAR设置为3
I set the CAR of that to be 3, changing this.

581
00:51:24,760 --> 00:51:35,340
这样我也就修改了a，现在调用(CAR A)来看一下结果
I've changed A. If I were to ask what's the CAR of A--of A now?

582
00:51:35,340 --> 00:51:45,290
结果是3，尽管上面定义a是(cons 1 2)
I would get out 3, even though here we see that A was the CONS of 1 and 2.

583
00:51:45,290 --> 00:51:48,400
我通过改变b而改变了a
I caused A to change by changing B.

584
00:51:48,400 --> 00:51:52,010
它们共享着一处数据
There is sharing here.

585
00:51:52,010 --> 00:51:54,240
有时候我们需要这样的结构
That's sometimes what we want.

586
00:51:54,240 --> 00:52:04,350
我们之前的队列，就是这样来组织的
Surely in the queues and things like that, that's exactly what we defined our--organized our data structures to facilitate-- sharing.

587
00:52:04,350 --> 00:52:25,190
但是对象之间不合理的共享与操作，是很多复杂系统中bug的来源。所以我们虽然使对象具有身份，可以用很多别名来共享，得到了不少的好处
But inadvertent sharing, unanticipated interactions between objects, is the source of most of the bugs that occur in complicated programs. So by introducing this possibility of things having identity and sharing and having multiple names for the same thing, we get a lot of power.

588
00:52:25,190 --> 00:52:28,640
但是同时也为此引出的bug而付出代价
But we're going to pay for it with lots of complexity and bugs.

589
00:52:32,190 --> 00:52:46,560
还看这里的这个例子，(CADR B)，看起来和(CAR B)没有一点关系
So also, for example, if I just looked at this just to drive that home, the CADR of B, which has nothing to do with even the CAR of B, apparently.

590
00:52:46,560 --> 00:52:49,350
但是它的值是什么？
The CADR of B, what's that?

591
00:52:49,350 --> 00:52:53,560
来找一下
Take that CDR of B and now take the CAR of that.

592
00:52:53,560 --> 00:52:56,480
哦，还是3
Oh, that's 3 also.

593
00:52:56,480 --> 00:53:01,120
有了共享这样的机制，局部的含义也不是那么清楚了
So I can have non-local interactions by sharing.

594
00:53:01,120 --> 00:53:02,480
所以我们要非常小心的操作
And I have to be very careful of that.

595
00:53:06,640 --> 00:53:22,820
目前为止，我已经介绍了SET！ SET-CAR！ SET-CDR！这些赋值操作，或许我应该不用SET-CAR！ SET-CDR！，它们引入太多问题了
Well, so far, of course, it seems I've introduced several different assignment operators-- set, set CAR, set CDR. Well, maybe I should just get rid of set CAR and set CDR. Maybe they're not worthwhile.

596
00:53:22,820 --> 00:53:27,170
不幸的是，一旦你让骆驼的鼻子进了帐篷，相当于你把它放进了帐篷
Well, the answer is that once you let the camel's nose into the tent, the rest of him follows.

597
00:53:30,160 --> 00:53:35,850
我想说的是，只要有set！，这一切不幸的都可能会发生
All I have to have is set, and I can make all of the--all of the bad things that can happen.

598
00:53:38,550 --> 00:53:40,690
我们来分析一下
Let's play with that a little bit.

599
00:53:40,690 --> 00:53:52,480
前些日子讲到复合数据的时候，哈罗德教授向你们展示了用消息接收的方式来定义CONS
A couple of days ago, when we introduced compound data, you saw Hal show you a definition of CONS in terms of a message acceptor.

600
00:53:52,480 --> 00:54:04,440
现在我要用一种更为恐怖的方式来定义CONS
I'm going to show you even a more horrible thing, a definition of CONS in terms of nothing but air, hot air.

601
00:54:04,440 --> 00:54:14,580
过去的那个CONS是怎么定义的来着？一个lambda表达式，一个过程？
What is the definition of CONS, of the old functional kind, in terms of purely lambdic expressions, procedures?

602
00:54:17,190 --> 00:54:28,580
我们这里对CONS的修改是要达到这样的效果，用SET！来代替SET-CAR！ SET-CDR！
Because I'm going to then modify this definition to get assignment to be only one kind of assignment, to get rid of the set CAR and set CDR in terms of set.

603
00:54:28,580 --> 00:54:46,320
这里我定义CONS为一个接受一个参数M的过程，M作用于X与Y
So what if I define CONS of X and Y to be a procedure of one argument called a message M, which calls that message on X and Y?

604
00:54:51,120 --> 00:54:57,870
这是阿隆佐·丘奇发明的方法，他是20世纪最伟大的程序员之一，尽管当时电脑还没有被发明
This [? idea ?] was invented by Alonzo Church, who was the greatest programmer of the 20th century, although he never saw a computer.

605
00:54:57,870 --> 00:54:59,130
那时20世纪30年代的事了
It was done in the 1930s.

606
00:54:59,130 --> 00:55:02,220
他是一个逻辑学家，当时应该是在普林斯顿
He was a logician, I suppose at Princeton at the time.

607
00:55:08,660 --> 00:55:46,670
(DEFINE (CAR X) (X (lambda(A D) A))) (DEFINE (CDR X) (X (lambda(A D) D)))
Define CAR of X to be the result of applying X to that procedure of two arguments, A and D, which selects A. I will define CDR of X to be that procedure, to be the result of applying X to that procedure of A and D, which selects D.

608
00:55:46,670 --> 00:55:50,510
这就是CONS CAR CDR
Now, you may not recognize this as CAR, CDR, and CONS.

609
00:55:50,510 --> 00:55:55,210
我来举例看一下，它是否符合之前所说的CONS的原则
But I'm going to demonstrate to you that it satisfies the original axioms, just once.

610
00:55:55,210 --> 00:55:58,290
简单来看
And then we're going to do some playing of games.

611
00:55:58,290 --> 00:56:09,695
(CAR (CONS 35 47))
Consider the problem CAR of CONS of, say, 35 and 47.

612
00:56:09,695 --> 00:56:11,120
这是什么呢？
Well, what is that?

613
00:56:11,120 --> 00:56:19,710
用代换模型，把CONS换成这边定义的
It is the result of taking car of the result of substituting 35 and 47 for X and Y in the body of this.

614
00:56:19,710 --> 00:56:20,690
非常容易
Well, that's easy enough.

615
00:56:20,690 --> 00:56:35,750
就是(CAR (lambda (M) (M 35 47)))
That's CAR of the result of substituting into lambda of M, M of 35 and 47.

616
00:56:35,750 --> 00:56:42,830
再来代换CAR
Well, what this is, is the result of substituting this object for X in the body of that.

617
00:56:42,830 --> 00:57:15,840
((lambda (M) (M 35 47)) (lambda (A D) A))
So that's just lambda of M-- that's substituted, because this object is being substituted for X, which is the beginning of a list, lambda of M-- M of 35 and 47, applied to that procedure of A and D, which gives me A. Well, that's the result of substituting this for M here.

618
00:57:15,840 --> 00:57:26,026
继续代换，((lambda (A D) A) 35 47)
So that's the same thing as lambda of A, D, A, applied to 35 and 47.

619
00:57:26,026 --> 00:57:27,560
结果就是35
Oh, well that's 35.

620
00:57:27,560 --> 00:57:40,720
35对应A，47对应的是D。在这种定义里，我什么数据都不需要，甚至连数字都没有
That's substituting 35 for A and for 47 for D in A. So I don't need any data at all, not even numbers.

621
00:57:40,720 --> 00:57:42,640
太佩服丘奇了
This is Alonso Church's hack.

622
00:57:52,420 --> 00:57:56,760
现在呢我们来对这个定义做点修改
Well, now we're going to do something nasty to him.

623
00:57:56,760 --> 00:57:58,860
作为逻辑学家，他可能会不太开心
Being a logician, he wouldn't like this.

624
00:57:58,860 --> 00:58:03,260
但是作为程序员，应该没什么
But as programmers, let's look at the overhead.

625
00:58:03,260 --> 00:58:05,390
我们来看看
And here we go.

626
00:58:05,390 --> 00:58:09,570
修改CONS的定义
I'm going to change the definition of CONS.

627
00:58:09,570 --> 00:58:14,520
和丘奇的定义很相似，但是不完全相同
It's almost the same as Alonzo Church's, but not quite.

628
00:58:14,520 --> 00:58:16,070
具体到底是什么？
What do we have here?

629
00:58:16,070 --> 00:58:40,940
CONS定义为一个过程，这个过程需要一个参数M，但是M作用于4个参数，X，Y 和两个lambda过程
The CONS of two arguments, X and Y, is going to be that procedure of one argument M, which supplies M to X and Y as before, but also to two permissions, the permission to set X to N and the permission to set Y to N, given that I have an N.

630
00:58:40,940 --> 00:59:03,365
所以这里的不同之处在于，M除了应用于x y之外，还应用于两个过程，分别用于修改x与y的值
So besides the things that I had here in Church's definition, what I have is that the thing that CONS returns will apply its argument to not just the values of the X and Y that the CONS is made of, but also permissions to set X and Y to new values.

631
00:59:06,540 --> 00:59:11,690
类似之前，CAR看起来也很相似
Now, of course, just as before, CAR is exactly the same.

632
00:59:11,690 --> 00:59:22,550
(CAR X)也就只是从4个参数里挑出第一个而已
The CAR of X is nothing more than applying X, as in Church's definition, to a procedure, in this case, of four arguments, which selects out the first one.

633
00:59:22,550 --> 00:59:37,920
和之前一样，返回的将会是这个过程中的x
And just as we did before, that will be the value of X that was contained in the procedure which is the result of evaluating this lambda expression in the environment where X and Y are defined over here.

634
00:59:41,940 --> 00:59:45,640
这个过程的整体就是CONS
That's the value of CONS.

635
00:59:45,640 --> 00:59:47,730
接着，最为精彩的一段
Now, however, the exciting part.

636
00:59:47,730 --> 00:59:48,960
CDR，和CAR一样的
CDR, of course, is the same.

637
00:59:48,960 --> 00:59:55,800
SET-CAR！ SET-CDR！的实现着实让人眼前一亮，其实它们也并不复杂
The exciting part, set CAR and set CDR. Well, they're nothing very complicated anymore.

638
00:59:55,800 --> 01:00:26,150
(SET-CAR! X Y)无非就是用一个取到4个参数中第3个参数的过程，去代换实际定义的CONS，取得修改其中X的权限，把其修改为新的值Y
Set CAR of a CONS X to a new value Y is nothing more than applying that CONS, which is the procedure of four--the procedure of one argument which applies its argument to four things, to a procedure which is of four arguments-- the value of X, the value of Y, permission to set X, the permission to set Y-- and using it--using that permission to set X to the new value.

639
01:00:31,650 --> 01:00:33,540
SET-CDR！和它是类似的
And similarly, set-cdr is the same thing.

640
01:00:36,120 --> 01:00:40,470
你也看到了，这里并没有引入新的其它基础操作
So what you've just seen is that I didn't introduce any new primitives at all.

641
01:00:40,470 --> 01:00:45,340
具体要不要这样来实现是一个工程性问题
Whether or not I want to implement it this way is a matter of engineering.

642
01:00:45,340 --> 01:00:51,680
实际上出于一些原因，工程上并不这样来实现
And the answer is of course I don't implement it this way for reasons that have to do with engineering.

643
01:00:51,680 --> 01:00:58,765
原理上逻辑上就是这样，一旦引入了赋值，便可以修改任意的东西
However in principle, logically, once I introduced one assignment operator, I've assigned--I've introduced them all.

644
01:01:05,420 --> 01:01:06,670
有什么问题吗？
Are there any questions?

645
01:01:09,200 --> 01:01:12,040
好的，David
Yes, David.

646
01:01:12,040 --> 01:01:15,740
我可以跟的上你的思路，直到
AUDIENCE: I can follow you up until you get--I can follow all of that.

647
01:01:15,740 --> 01:01:24,210
直到那个lambda (n)那里，我不知道这个参数是什么时候传进来的
But when we bring in the permissions, defining CONS in terms of the lambda N, I don't follow where N gets passed.

648
01:01:24,210 --> 01:01:25,100
哦，抱歉
PROFESSOR: Oh, I'm sorry.

649
01:01:25,100 --> 01:01:26,340
我没讲清楚
I'll show you.

650
01:01:26,340 --> 01:01:27,360
我们来仔细看看
Let's follow it.

651
01:01:27,360 --> 01:01:29,180
当然，我们也可以在黑板上演示
Of course, we could do it on the blackboard.

652
01:01:29,180 --> 01:01:30,170
并不难懂
It's not so hard.

653
01:01:30,170 --> 01:01:32,450
非常简单
But it's also easy here.

654
01:01:32,450 --> 01:01:38,520
来看(set-cdr! x y)
Supposing I wish to set-cdr of X to Y. See that right there.

655
01:01:38,520 --> 01:01:46,890
x是一个CONS
set-cdr of X to Y. X is presumably a CONS, a thing resulting from evaluating CONS.

656
01:01:46,890 --> 01:01:58,110
x可以代换为这一部分，一个lambda表达式
Therefore X comes from a place over here, that that X is of the result of evaluating this lambda expression.

657
01:01:58,110 --> 01:01:59,380
对吧
Right?

658
01:01:59,380 --> 01:02:08,950
这个lambda，是在定义CONS的环境下执行的
That when I evaluated that lambda expression, I evaluated it in an environment where the arguments to CONS were defined.

659
01:02:11,750 --> 01:02:29,250
这意味着，x y都是自由变量，x y所在的frame在这个lambda的上层，因此在这个过程中可以访问到x和y
That means that as free variables in this lambda expression, there is the--there are in the frame, which is the parent frame of this lambda expression, the procedure resulting from this lambda expression, X and Y have places.

660
01:02:29,250 --> 01:02:31,910
也可以对它们赋值
And it's possible to set them.

661
01:02:31,910 --> 01:02:37,010
这里赋值为n，是一个传过来的参数
I set them to an N, which is the argument of the permission.

662
01:02:37,010 --> 01:02:47,940
这个可以进行修改的过程是M的参数，而M又是CONS对象的参数
The permission is a procedure which is passed to M, which is the argument that the CONS object gets passed.

663
01:02:47,940 --> 01:02:57,480
现在再来看看SET-CDR！，第一个参数是一个CONS对象
Now, let's go back here in the set-cdr The CONS object, which is the first argument of set-cdr gets passed an argument.

664
01:03:00,260 --> 01:03:07,920
这是一个有4个参数的过程，作为实参，对应这里的形参M
That--there's a procedure of four things, indeed, because that's the same thing as this M over here, which is applied to four objects.

665
01:03:07,920 --> 01:03:12,970
这边的这个sd，就对应于这个过程
The object over here, SD, is, in fact, this permission.

666
01:03:15,470 --> 01:03:19,930
当我执行sd，应用于Y
When I use SD, I apply it to Y, right there.

667
01:03:22,910 --> 01:03:25,740
y是这里传过来的参数
So that comes from this.

668
01:03:25,740 --> 01:03:34,160
David：那-- 教授：对应起来，这里的y就对应于这里的n
AUDIENCE: So what do you-- PROFESSOR: So to finish that, the N that was here is the Y which is here.

669
01:03:34,160 --> 01:03:34,810
明白了吧
How's that?

670
01:03:34,810 --> 01:03:35,750
了解了
AUDIENCE: Right, OK.

671
01:03:35,750 --> 01:03:41,970
当你执行SET-CDR！的时候，x是CDR要变成的值
Now, when you do a set-cdr, X is the value the CDR is going to become.

672
01:03:41,970 --> 01:03:44,742
这里的x
PROFESSOR: The X over here.

673
01:03:44,742 --> 01:03:46,200
并不全对
I'm sorry, that's not true.

674
01:03:46,200 --> 01:03:56,150
SET-CAR！有两个参数，这个x是我们要改变的CONS对象
The X is--set-cdr has two arguments-- The CONS I'm changing and the value I'm changing it to.

675
01:03:56,150 --> 01:03:58,320
你可以代换回去看看，就很清楚了
So you have them backwards, that's all.

676
01:04:01,750 --> 01:04:03,000
还有什么问题吗？
Are there any other questions?

677
01:04:07,880 --> 01:04:08,640
好的
Well, thank you.

678
01:04:08,640 --> 01:04:09,890
这节课就到这里
It's time for lunch.

