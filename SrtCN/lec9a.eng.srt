1
00:00:02,190 --> 00:00:03,800
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

2
00:00:17,260 --> 00:00:19,072
教授：我认为 到目前为止
PROFESSOR: Well, up 'til now, I suppose,

3
00:00:19,328 --> 00:00:23,936
我们已经学习了很多关于
we've been learning about a lot of techniques for 

4
00:00:24,096 --> 00:00:28,830
组织程序以及操纵符号的技术
organizing big programs, symbolic manipulation a bit,

5
00:00:30,848 --> 00:00:35,600
用来构建语言的技术
some of the technology that you use for establishing languages,

6
00:00:35,630 --> 00:00:36,784
用一门语言创建另一门语言
one in terms of another,

7
00:00:37,104 --> 00:00:39,920
这在组织大型程序时非常有用
which is used for organizing very large programs.

8
00:00:39,968 --> 00:00:42,304
实际上 我所知的最好的程序
In fact, the nicest programs I know

9
00:00:42,448 --> 00:00:44,432
看起来更像是一堆语言
look more like a pile of languages

10
00:00:44,912 --> 00:00:47,968
而不是将问题分解成若干部分
than like a decomposition of a problem into parts.

11
00:00:49,900 --> 00:00:51,456
我想 此时此刻
Well, I suppose at this point,

12
00:00:52,080 --> 00:00:53,584
关于这类东西的工作方式
there are still, however, a few mysteries

13
00:00:53,616 --> 00:00:55,328
仍然存在一些谜团
about how this sort of stuff works.

14
00:00:56,260 --> 00:00:59,680
因此 我现在就要
And so what we'd like to do now is

15
00:01:00,030 --> 00:01:02,608
偏离原先的计划
diverge from the plan of

16
00:01:02,960 --> 00:01:05,420
不再继续讲解如何组织大型程序
telling you how to organize big programs,

17
00:01:05,450 --> 00:01:08,192
而是告诉你一些关于
and rather tell you something about the mechanisms

18
00:01:08,528 --> 00:01:11,710
使这些事情可以起作用的机制
by which these things can be made to work.

19
00:01:12,190 --> 00:01:14,832
这样做的主要原因就是
The main reason for this is

20
00:01:15,808 --> 00:01:17,870
揭秘
demystification, if you will,

21
00:01:18,768 --> 00:01:20,544
The main reason for this is demystification, if you will, that we have a lot of mysteries left, like exactly how it is the case that a program is controlled, how a computer knows what the next thing to do is, or something like that.

22
00:01:21,088 --> 00:01:22,880
The main reason for this is demystification, if you will, that we have a lot of mysteries left, like exactly how it is the case that a program is controlled, how a computer knows what the next thing to do is, or something like that.

23
00:01:23,184 --> 00:01:25,488
The main reason for this is demystification, if you will, that we have a lot of mysteries left, like exactly how it is the case that a program is controlled, how a computer knows what the next thing to do is, or something like that.

24
00:01:26,080 --> 00:01:30,384
The main reason for this is demystification, if you will, that we have a lot of mysteries left, like exactly how it is the case that a program is controlled, how a computer knows what the next thing to do is, or something like that.

25
00:01:30,528 --> 00:01:31,744
The main reason for this is demystification, if you will, that we have a lot of mysteries left, like exactly how it is the case that a program is controlled, how a computer knows what the next thing to do is, or something like that.

26
00:01:32,430 --> 00:01:33,728
And what I'd like to do now is make that clear to you, that even if you've never played with a physical computer before, the mechanism is really very simple, and that you can understand it completely with no trouble.

27
00:01:33,952 --> 00:01:35,552
And what I'd like to do now is make that clear to you, that even if you've never played with a physical computer before, the mechanism is really very simple, and that you can understand it completely with no trouble.

28
00:01:35,856 --> 00:01:39,104
And what I'd like to do now is make that clear to you, that even if you've never played with a physical computer before, the mechanism is really very simple, and that you can understand it completely with no trouble.

29
00:01:39,568 --> 00:01:43,504
And what I'd like to do now is make that clear to you, that even if you've never played with a physical computer before, the mechanism is really very simple, and that you can understand it completely with no trouble.

30
00:01:44,336 --> 00:01:46,352
And what I'd like to do now is make that clear to you, that even if you've never played with a physical computer before, the mechanism is really very simple, and that you can understand it completely with no trouble.

31
00:01:47,650 --> 00:01:51,248
So I'd like to start by imagining that we-- well, the way we're going to do this, by the way, is we're going to take some very simple Lisp programs, very simple Lisp programs, and transform them into hardware.

32
00:01:51,328 --> 00:01:52,912
So I'd like to start by imagining that we-- well, the way we're going to do this, by the way, is we're going to take some very simple Lisp programs, very simple Lisp programs, and transform them into hardware.

33
00:01:52,960 --> 00:01:55,808
So I'd like to start by imagining that we-- well, the way we're going to do this, by the way, is we're going to take some very simple Lisp programs, very simple Lisp programs, and transform them into hardware.

34
00:01:56,544 --> 00:01:58,128
So I'd like to start by imagining that we-- well, the way we're going to do this, by the way, is we're going to take some very simple Lisp programs, very simple Lisp programs, and transform them into hardware.

35
00:01:59,040 --> 00:02:00,624
So I'd like to start by imagining that we-- well, the way we're going to do this, by the way, is we're going to take some very simple Lisp programs, very simple Lisp programs, and transform them into hardware.

36
00:02:02,160 --> 00:02:04,160
I'm not going to worry about some intermediate step of going through some existing computer machine language and then showing you how that computer works, because that's not as illuminating.

37
00:02:04,704 --> 00:02:09,056
I'm not going to worry about some intermediate step of going through some existing computer machine language and then showing you how that computer works, because that's not as illuminating.

38
00:02:09,824 --> 00:02:12,000
I'm not going to worry about some intermediate step of going through some existing computer machine language and then showing you how that computer works, because that's not as illuminating.

39
00:02:12,750 --> 00:02:14,176
So what I'm really going to show you is how a piece of machinery can be built to do a job that you have written down as a program.

40
00:02:14,512 --> 00:02:17,488
So what I'm really going to show you is how a piece of machinery can be built to do a job that you have written down as a program.

41
00:02:18,032 --> 00:02:22,040
So what I'm really going to show you is how a piece of machinery can be built to do a job that you have written down as a program.

42
00:02:22,040 --> 00:02:24,032
That program is, in fact, a description of a machine.

43
00:02:25,760 --> 00:02:27,696
We're going to start with a very simple program, proceed to show you some simple mechanisms, proceed to a few more complicated programs, and then later show you a not very complicated program, how the evaluator transforms into a piece of hardware.

44
00:02:28,096 --> 00:02:30,816
We're going to start with a very simple program, proceed to show you some simple mechanisms, proceed to a few more complicated programs, and then later show you a not very complicated program, how the evaluator transforms into a piece of hardware.

45
00:02:31,392 --> 00:02:33,680
We're going to start with a very simple program, proceed to show you some simple mechanisms, proceed to a few more complicated programs, and then later show you a not very complicated program, how the evaluator transforms into a piece of hardware.

46
00:02:34,224 --> 00:02:35,424
We're going to start with a very simple program, proceed to show you some simple mechanisms, proceed to a few more complicated programs, and then later show you a not very complicated program, how the evaluator transforms into a piece of hardware.

47
00:02:35,536 --> 00:02:37,424
We're going to start with a very simple program, proceed to show you some simple mechanisms, proceed to a few more complicated programs, and then later show you a not very complicated program, how the evaluator transforms into a piece of hardware.

48
00:02:37,440 --> 00:02:41,230
We're going to start with a very simple program, proceed to show you some simple mechanisms, proceed to a few more complicated programs, and then later show you a not very complicated program, how the evaluator transforms into a piece of hardware.

49
00:02:41,230 --> 00:02:42,064
And of course at that point, you have made the universal transition and can execute any program imaginable with a piece of well-defined hardware.

50
00:02:42,080 --> 00:02:44,080
And of course at that point, you have made the universal transition and can execute any program imaginable with a piece of well-defined hardware.

51
00:02:44,224 --> 00:02:46,880
And of course at that point, you have made the universal transition and can execute any program imaginable with a piece of well-defined hardware.

52
00:02:47,168 --> 00:02:48,800
And of course at that point, you have made the universal transition and can execute any program imaginable with a piece of well-defined hardware.

53
00:02:51,728 --> 00:02:52,912
Well, let's start up now, give you a real concrete feeling for this sort of thing.

54
00:02:53,056 --> 00:02:55,312
Well, let's start up now, give you a real concrete feeling for this sort of thing.

55
00:02:55,440 --> 00:02:57,664
Let's start with a very simple program.

56
00:02:59,600 --> 00:03:00,850
Here's Euclid's algorithm.

57
00:03:03,880 --> 00:03:07,008
It's actually a little bit more modern than Euclid's algorithm.

58
00:03:07,020 --> 00:03:10,096
Euclid's algorithm for computing the greatest common divisor of two numbers was invented 350 BC, I think.

59
00:03:10,416 --> 00:03:13,600
Euclid's algorithm for computing the greatest common divisor of two numbers was invented 350 BC, I think.

60
00:03:14,300 --> 00:03:15,696
It's the oldest known algorithm.

61
00:03:19,320 --> 00:03:23,344
But here we're going to talk about GCD of A and B, the Greatest Common Divisor or two numbers, A and B. And the algorithm is extremely simple.

62
00:03:23,360 --> 00:03:25,616
But here we're going to talk about GCD of A and B, the Greatest Common Divisor or two numbers, A and B. And the algorithm is extremely simple.

63
00:03:26,208 --> 00:03:28,912
But here we're going to talk about GCD of A and B, the Greatest Common Divisor or two numbers, A and B. And the algorithm is extremely simple.

64
00:03:29,500 --> 00:03:31,088
If B is 0, then the result is going to be A. Otherwise, the result is the GCD of B and the remainder when A is divided by B.

65
00:03:34,160 --> 00:03:36,832
If B is 0, then the result is going to be A. Otherwise, the result is the GCD of B and the remainder when A is divided by B.

66
00:03:37,520 --> 00:03:43,616
If B is 0, then the result is going to be A. Otherwise, the result is the GCD of B and the remainder when A is divided by B.

67
00:03:44,496 --> 00:03:53,392
If B is 0, then the result is going to be A. Otherwise, the result is the GCD of B and the remainder when A is divided by B.

68
00:03:58,530 --> 00:04:01,904
So this we have here is a very simple iterative process.

69
00:04:02,030 --> 00:04:04,080
This a simple recursive procedure, recursively defined procedure, recursive definition, which yields an iterative process.

70
00:04:04,384 --> 00:04:06,080
This a simple recursive procedure, recursively defined procedure, recursive definition, which yields an iterative process.

71
00:04:06,336 --> 00:04:07,424
This a simple recursive procedure, recursively defined procedure, recursive definition, which yields an iterative process.

72
00:04:07,712 --> 00:04:09,264
This a simple recursive procedure, recursively defined procedure, recursive definition, which yields an iterative process.

73
00:04:09,990 --> 00:04:10,928
And the way it works is that every step, it determines whether B was zero.

74
00:04:11,360 --> 00:04:12,464
And the way it works is that every step, it determines whether B was zero.

75
00:04:12,800 --> 00:04:15,104
And the way it works is that every step, it determines whether B was zero.

76
00:04:16,240 --> 00:04:18,800
And if B is 0, we got the answer in A. Otherwise, we make another step where A is the old B, and B is the remainder of the old A divided by the old B. Very simple.

77
00:04:19,632 --> 00:04:22,464
And if B is 0, we got the answer in A. Otherwise, we make another step where A is the old B, and B is the remainder of the old A divided by the old B. Very simple.

78
00:04:22,496 --> 00:04:23,872
And if B is 0, we got the answer in A. Otherwise, we make another step where A is the old B, and B is the remainder of the old A divided by the old B. Very simple.

79
00:04:23,888 --> 00:04:27,040
And if B is 0, we got the answer in A. Otherwise, we make another step where A is the old B, and B is the remainder of the old A divided by the old B. Very simple.

80
00:04:28,768 --> 00:04:29,552
And if B is 0, we got the answer in A. Otherwise, we make another step where A is the old B, and B is the remainder of the old A divided by the old B. Very simple.

81
00:04:31,110 --> 00:04:32,720
Now this, I've already told you some of the mechanism by just saying it that way.

82
00:04:32,992 --> 00:04:34,860
Now this, I've already told you some of the mechanism by just saying it that way.

83
00:04:34,860 --> 00:04:35,904
I set it in time.

84
00:04:36,360 --> 00:04:37,728
I said there are certain steps, and that, in fact, one of the things you can see here is that one of the reasons why this is iterative is nothing is needed of the last step to get the answer.

85
00:04:38,144 --> 00:04:39,328
I said there are certain steps, and that, in fact, one of the things you can see here is that one of the reasons why this is iterative is nothing is needed of the last step to get the answer.

86
00:04:39,520 --> 00:04:40,864
I said there are certain steps, and that, in fact, one of the things you can see here is that one of the reasons why this is iterative is nothing is needed of the last step to get the answer.

87
00:04:41,184 --> 00:04:43,696
I said there are certain steps, and that, in fact, one of the things you can see here is that one of the reasons why this is iterative is nothing is needed of the last step to get the answer.

88
00:04:43,950 --> 00:04:47,680
I said there are certain steps, and that, in fact, one of the things you can see here is that one of the reasons why this is iterative is nothing is needed of the last step to get the answer.

89
00:04:49,490 --> 00:04:51,424
All of the information that's needed to run this algorithm is in A and B. It has two well-defined state variables.

90
00:04:51,712 --> 00:04:53,136
All of the information that's needed to run this algorithm is in A and B. It has two well-defined state variables.

91
00:04:54,240 --> 00:04:55,296
All of the information that's needed to run this algorithm is in A and B. It has two well-defined state variables.

92
00:04:55,744 --> 00:04:57,808
All of the information that's needed to run this algorithm is in A and B. It has two well-defined state variables.

93
00:05:00,470 --> 00:05:02,336
So I'm going to define a machine for you that can compute you GCDs.

94
00:05:03,984 --> 00:05:05,552
So I'm going to define a machine for you that can compute you GCDs.

95
00:05:06,560 --> 00:05:07,120
Now let's see.

96
00:05:07,120 --> 00:05:08,832
Every computer that's ever been made that's a single-process computer, as opposed to a multiprocessor of some sort, is made according to the same plan.

97
00:05:09,712 --> 00:05:11,232
Every computer that's ever been made that's a single-process computer, as opposed to a multiprocessor of some sort, is made according to the same plan.

98
00:05:11,800 --> 00:05:14,080
Every computer that's ever been made that's a single-process computer, as opposed to a multiprocessor of some sort, is made according to the same plan.

99
00:05:15,040 --> 00:05:16,592
Every computer that's ever been made that's a single-process computer, as opposed to a multiprocessor of some sort, is made according to the same plan.

100
00:05:17,840 --> 00:05:19,536
The plan is the computer has two parts, a part called the datapaths, and a part called the controller.

101
00:05:20,576 --> 00:05:22,352
The plan is the computer has two parts, a part called the datapaths, and a part called the controller.

102
00:05:23,104 --> 00:05:24,368
The plan is the computer has two parts, a part called the datapaths, and a part called the controller.

103
00:05:25,910 --> 00:05:29,280
The datapaths correspond to a calculator that you might have. It contains certain registers that remember things, and you've all used calculators.

104
00:05:29,712 --> 00:05:31,872
The datapaths correspond to a calculator that you might have. It contains certain registers that remember things, and you've all used calculators.

105
00:05:31,904 --> 00:05:33,136
The datapaths correspond to a calculator that you might have. It contains certain registers that remember things, and you've all used calculators.

106
00:05:33,560 --> 00:05:35,344
It has some buttons on it and some lights.

107
00:05:37,030 --> 00:05:38,496
And so by pushing the various buttons, you can cause operations to happen inside there among the registers, and some of the results to be displayed.

108
00:05:38,528 --> 00:05:41,344
And so by pushing the various buttons, you can cause operations to happen inside there among the registers, and some of the results to be displayed.

109
00:05:41,872 --> 00:05:43,488
And so by pushing the various buttons, you can cause operations to happen inside there among the registers, and some of the results to be displayed.

110
00:05:45,160 --> 00:05:46,250
That's completely mechanical.

111
00:05:46,250 --> 00:05:49,552
You could imagine that box has no intelligence in it.

112
00:05:50,900 --> 00:05:53,280
Now it might be very impressive that it can produce the sine of a number, but that at least is apparently possibly mechanical.

113
00:05:53,536 --> 00:05:58,970
Now it might be very impressive that it can produce the sine of a number, but that at least is apparently possibly mechanical.

114
00:05:58,970 --> 00:06:01,712
At least, I could open that up in the same way I'm about to open GCD.

115
00:06:02,690 --> 00:06:04,368
So this may have a whole computer inside of it, but that's not interesting.

116
00:06:04,688 --> 00:06:05,696
So this may have a whole computer inside of it, but that's not interesting.

117
00:06:05,940 --> 00:06:07,104
Addition is certainly simple.

118
00:06:08,200 --> 00:06:09,840
That can be done without any further mechanism.

119
00:06:10,890 --> 00:06:15,648
Now also, if we were to look at the other half, the controller, that's a part that's dumb, too.

120
00:06:15,936 --> 00:06:17,392
Now also, if we were to look at the other half, the controller, that's a part that's dumb, too.

121
00:06:18,190 --> 00:06:19,168
It pushes the buttons.

122
00:06:20,350 --> 00:06:21,520
It pushes them according to the sequence, which is written down on a piece of paper, and observes the lights.

123
00:06:21,552 --> 00:06:22,848
It pushes them according to the sequence, which is written down on a piece of paper, and observes the lights.

124
00:06:24,272 --> 00:06:25,648
It pushes them according to the sequence, which is written down on a piece of paper, and observes the lights.

125
00:06:26,290 --> 00:06:29,440
And every so often, it comes to a place in a sequence that says, if light A is on, do this sequence.

126
00:06:29,472 --> 00:06:32,370
And every so often, it comes to a place in a sequence that says, if light A is on, do this sequence.

127
00:06:32,370 --> 00:06:33,856
Otherwise, do that sequence.

128
00:06:34,620 --> 00:06:37,456
And thereby, there's no complexity there either.

129
00:06:38,352 --> 00:06:40,576
Well, let's just draw that and see what we feel about that.

130
00:06:42,510 --> 00:06:44,848
So for computing GCDs, what I want you to think about is that there are these registers.

131
00:06:45,888 --> 00:06:49,520
So for computing GCDs, what I want you to think about is that there are these registers.

132
00:06:50,560 --> 00:06:53,024
A register is a place where I store a number, in this case.

133
00:06:53,520 --> 00:06:54,656
And this one's called a.

134
00:06:56,810 --> 00:06:58,700
And then there's another one for storing b.

135
00:07:03,170 --> 00:07:05,456
Now we have to see what things we can do with these registers, and they're not entirely obvious what you can do with them.

136
00:07:05,984 --> 00:07:07,504
Now we have to see what things we can do with these registers, and they're not entirely obvious what you can do with them.

137
00:07:07,664 --> 00:07:08,656
Now we have to see what things we can do with these registers, and they're not entirely obvious what you can do with them.

138
00:07:09,840 --> 00:07:11,728
Well, we have to see what things we need to do with them.

139
00:07:11,824 --> 00:07:13,872
We're looking at the problem we're trying to solve.

140
00:07:14,030 --> 00:07:16,096
One of the important things for designing a computer, which I think most designers don't do, is you study the problem you want to solve and then use what you learn from studying the problem you want to solve to put in the mechanisms needed to solve it in the computer you're building, no more no less.

141
00:07:17,104 --> 00:07:19,584
One of the important things for designing a computer, which I think most designers don't do, is you study the problem you want to solve and then use what you learn from studying the problem you want to solve to put in the mechanisms needed to solve it in the computer you're building, no more no less.

142
00:07:20,208 --> 00:07:21,888
One of the important things for designing a computer, which I think most designers don't do, is you study the problem you want to solve and then use what you learn from studying the problem you want to solve to put in the mechanisms needed to solve it in the computer you're building, no more no less.

143
00:07:22,720 --> 00:07:25,184
One of the important things for designing a computer, which I think most designers don't do, is you study the problem you want to solve and then use what you learn from studying the problem you want to solve to put in the mechanisms needed to solve it in the computer you're building, no more no less.

144
00:07:25,440 --> 00:07:27,280
One of the important things for designing a computer, which I think most designers don't do, is you study the problem you want to solve and then use what you learn from studying the problem you want to solve to put in the mechanisms needed to solve it in the computer you're building, no more no less.

145
00:07:27,530 --> 00:07:28,700
One of the important things for designing a computer, which I think most designers don't do, is you study the problem you want to solve and then use what you learn from studying the problem you want to solve to put in the mechanisms needed to solve it in the computer you're building, no more no less.

146
00:07:28,816 --> 00:07:30,080
One of the important things for designing a computer, which I think most designers don't do, is you study the problem you want to solve and then use what you learn from studying the problem you want to solve to put in the mechanisms needed to solve it in the computer you're building, no more no less.

147
00:07:32,140 --> 00:07:33,968
Now it may be that the problem you're trying to solve is everybody's problem, in which case you have to build in a universal interpreter of some language.

148
00:07:34,240 --> 00:07:35,408
Now it may be that the problem you're trying to solve is everybody's problem, in which case you have to build in a universal interpreter of some language.

149
00:07:36,064 --> 00:07:39,296
Now it may be that the problem you're trying to solve is everybody's problem, in which case you have to build in a universal interpreter of some language.

150
00:07:40,190 --> 00:07:42,320
But you shouldn't put any more in than required to build the universal interpreter of some language.

151
00:07:42,352 --> 00:07:44,256
But you shouldn't put any more in than required to build the universal interpreter of some language.

152
00:07:44,448 --> 00:07:45,856
We'll worry about that in a second.

153
00:07:47,232 --> 00:07:49,930
OK, going back to here, let's see.

154
00:07:49,930 --> 00:07:51,248
What do we have to be able to do?

155
00:07:51,792 --> 00:07:54,144
Well, somehow, we have to be able to get B into A. We have to be able to get the old value of B into the value of A. So we have to have some path by which stuff can flow, whatever this information is, from b to a.

156
00:07:56,080 --> 00:07:59,600
Well, somehow, we have to be able to get B into A. We have to be able to get the old value of B into the value of A. So we have to have some path by which stuff can flow, whatever this information is, from b to a.

157
00:08:00,384 --> 00:08:01,552
Well, somehow, we have to be able to get B into A. We have to be able to get the old value of B into the value of A. So we have to have some path by which stuff can flow, whatever this information is, from b to a.

158
00:08:01,792 --> 00:08:04,768
Well, somehow, we have to be able to get B into A. We have to be able to get the old value of B into the value of A. So we have to have some path by which stuff can flow, whatever this information is, from b to a.

159
00:08:05,376 --> 00:08:06,576
Well, somehow, we have to be able to get B into A. We have to be able to get the old value of B into the value of A. So we have to have some path by which stuff can flow, whatever this information is, from b to a.

160
00:08:07,390 --> 00:08:09,264
I'm going to draw that with by an arrow saying that it is possible to move the contents of b into a, replacing the value of a.

161
00:08:09,520 --> 00:08:12,624
I'm going to draw that with by an arrow saying that it is possible to move the contents of b into a, replacing the value of a.

162
00:08:12,960 --> 00:08:14,576
I'm going to draw that with by an arrow saying that it is possible to move the contents of b into a, replacing the value of a.

163
00:08:15,120 --> 00:08:16,736
And there's a little button here which you push which allows that to happen.

164
00:08:17,488 --> 00:08:18,560
And there's a little button here which you push which allows that to happen.

165
00:08:19,710 --> 00:08:20,784
That's what the little x is here.

166
00:08:23,070 --> 00:08:23,936
Now it's also the case that I have to be able to compute the remainder of a and b.

167
00:08:23,952 --> 00:08:26,288
Now it's also the case that I have to be able to compute the remainder of a and b.

168
00:08:27,000 --> 00:08:28,496
Now that may be a complicated mess.

169
00:08:28,860 --> 00:08:30,864
On the other hand, I'm going to make it a small box.

170
00:08:31,960 --> 00:08:33,920
If we have to, we may open up that box and look inside and see what it is.

171
00:08:34,128 --> 00:08:35,632
If we have to, we may open up that box and look inside and see what it is.

172
00:08:37,776 --> 00:08:40,400
So here, I'm going to have a little box, which I'm going to draw this way, which we'll call the remainder.

173
00:08:43,168 --> 00:08:44,384
So here, I'm going to have a little box, which I'm going to draw this way, which we'll call the remainder.

174
00:08:46,440 --> 00:08:48,608
And it's going to take in a.

175
00:08:50,910 --> 00:08:52,160
That's going to take in b.

176
00:08:54,370 --> 00:08:56,512
And it's going to put out something, the remainder of a divided by b.

177
00:08:58,896 --> 00:09:00,464
And it's going to put out something, the remainder of a divided by b.

178
00:09:02,290 --> 00:09:03,936
Another thing we have to see here is that we have to be able to test whether b is equal to 0.

179
00:09:03,968 --> 00:09:06,064
Another thing we have to see here is that we have to be able to test whether b is equal to 0.

180
00:09:08,000 --> 00:09:09,664
Well, that means somebody's got to be looking at-- a thing that's looking at the value of b.

181
00:09:10,000 --> 00:09:12,304
Well, that means somebody's got to be looking at-- a thing that's looking at the value of b.

182
00:09:13,390 --> 00:09:14,400
I have a light bulb here which lights up if b equals 0.

183
00:09:15,856 --> 00:09:17,390
I have a light bulb here which lights up if b equals 0.

184
00:09:21,110 --> 00:09:22,016
That's its job.

185
00:09:24,030 --> 00:09:26,784
And finally, I suppose, because of the fact that we want the new value of a to be the old value of b, and simultaneously the new value of b to be something I've done with a, and if I plan to make my machine such that everything happens one at a time, one motion at a time, and I can't put two numbers in a register, then I have to have another place to put one while I'm interchanging.

186
00:09:26,960 --> 00:09:30,432
And finally, I suppose, because of the fact that we want the new value of a to be the old value of b, and simultaneously the new value of b to be something I've done with a, and if I plan to make my machine such that everything happens one at a time, one motion at a time, and I can't put two numbers in a register, then I have to have another place to put one while I'm interchanging.

187
00:09:30,464 --> 00:09:34,416
And finally, I suppose, because of the fact that we want the new value of a to be the old value of b, and simultaneously the new value of b to be something I've done with a, and if I plan to make my machine such that everything happens one at a time, one motion at a time, and I can't put two numbers in a register, then I have to have another place to put one while I'm interchanging.

188
00:09:35,280 --> 00:09:37,600
And finally, I suppose, because of the fact that we want the new value of a to be the old value of b, and simultaneously the new value of b to be something I've done with a, and if I plan to make my machine such that everything happens one at a time, one motion at a time, and I can't put two numbers in a register, then I have to have another place to put one while I'm interchanging.

189
00:09:37,808 --> 00:09:39,744
And finally, I suppose, because of the fact that we want the new value of a to be the old value of b, and simultaneously the new value of b to be something I've done with a, and if I plan to make my machine such that everything happens one at a time, one motion at a time, and I can't put two numbers in a register, then I have to have another place to put one while I'm interchanging.

190
00:09:40,208 --> 00:09:41,408
And finally, I suppose, because of the fact that we want the new value of a to be the old value of b, and simultaneously the new value of b to be something I've done with a, and if I plan to make my machine such that everything happens one at a time, one motion at a time, and I can't put two numbers in a register, then I have to have another place to put one while I'm interchanging.

191
00:09:41,616 --> 00:09:43,424
And finally, I suppose, because of the fact that we want the new value of a to be the old value of b, and simultaneously the new value of b to be something I've done with a, and if I plan to make my machine such that everything happens one at a time, one motion at a time, and I can't put two numbers in a register, then I have to have another place to put one while I'm interchanging.

192
00:09:44,032 --> 00:09:46,300
And finally, I suppose, because of the fact that we want the new value of a to be the old value of b, and simultaneously the new value of b to be something I've done with a, and if I plan to make my machine such that everything happens one at a time, one motion at a time, and I can't put two numbers in a register, then I have to have another place to put one while I'm interchanging.

193
00:09:49,296 --> 00:09:49,600
OK?

194
00:09:50,000 --> 00:09:51,856
I can't interchange the two things in my hands, unless I either put two in one hand and then pull it back the other way, or unless I put one down, pick it up, and put the other one, like that, unless I'm a juggler, which I'm not, as you can see, in which case I have a possibility of timing errors.

195
00:09:52,112 --> 00:09:55,136
I can't interchange the two things in my hands, unless I either put two in one hand and then pull it back the other way, or unless I put one down, pick it up, and put the other one, like that, unless I'm a juggler, which I'm not, as you can see, in which case I have a possibility of timing errors.

196
00:09:55,504 --> 00:09:56,912
I can't interchange the two things in my hands, unless I either put two in one hand and then pull it back the other way, or unless I put one down, pick it up, and put the other one, like that, unless I'm a juggler, which I'm not, as you can see, in which case I have a possibility of timing errors.

197
00:09:57,024 --> 00:09:58,688
I can't interchange the two things in my hands, unless I either put two in one hand and then pull it back the other way, or unless I put one down, pick it up, and put the other one, like that, unless I'm a juggler, which I'm not, as you can see, in which case I have a possibility of timing errors.

198
00:09:59,648 --> 00:10:00,944
I can't interchange the two things in my hands, unless I either put two in one hand and then pull it back the other way, or unless I put one down, pick it up, and put the other one, like that, unless I'm a juggler, which I'm not, as you can see, in which case I have a possibility of timing errors.

199
00:10:01,660 --> 00:10:03,500
I can't interchange the two things in my hands, unless I either put two in one hand and then pull it back the other way, or unless I put one down, pick it up, and put the other one, like that, unless I'm a juggler, which I'm not, as you can see, in which case I have a possibility of timing errors.

200
00:10:04,656 --> 00:10:07,360
I can't interchange the two things in my hands, unless I either put two in one hand and then pull it back the other way, or unless I put one down, pick it up, and put the other one, like that, unless I'm a juggler, which I'm not, as you can see, in which case I have a possibility of timing errors.

201
00:10:08,850 --> 00:10:11,040
In fact, much of the type of computer design people do involves timing errors, of some potential timing errors, which I don't much like.

202
00:10:11,072 --> 00:10:12,688
In fact, much of the type of computer design people do involves timing errors, of some potential timing errors, which I don't much like.

203
00:10:13,120 --> 00:10:15,008
In fact, much of the type of computer design people do involves timing errors, of some potential timing errors, which I don't much like.

204
00:10:15,248 --> 00:10:16,432
In fact, much of the type of computer design people do involves timing errors, of some potential timing errors, which I don't much like.

205
00:10:17,340 --> 00:10:21,264
So for that reason, I have to have a place to put the second one of them down.

206
00:10:22,060 --> 00:10:23,296
So for that reason, I have to have a place to put the second one of them down.

207
00:10:23,410 --> 00:10:26,848
So I have a place called t, which is a register just for temporary, t, with a button on it.

208
00:10:28,592 --> 00:10:29,632
So I have a place called t, which is a register just for temporary, t, with a button on it.

209
00:10:30,470 --> 00:10:31,888
And then I'll take the result of that, since I have to take that and put into b, over here, we'll take the result of that and go like this, and a button here.

210
00:10:31,904 --> 00:10:34,144
And then I'll take the result of that, since I have to take that and put into b, over here, we'll take the result of that and go like this, and a button here.

211
00:10:34,688 --> 00:10:36,736
And then I'll take the result of that, since I have to take that and put into b, over here, we'll take the result of that and go like this, and a button here.

212
00:10:38,416 --> 00:10:39,300
And then I'll take the result of that, since I have to take that and put into b, over here, we'll take the result of that and go like this, and a button here.

213
00:10:42,430 --> 00:10:45,840
So that's the datapaths of a GCD machine.

214
00:10:47,600 --> 00:10:48,576
Now what's the controller?

215
00:10:49,740 --> 00:10:51,280
Controller's a very simple thing, too.

216
00:10:52,280 --> 00:10:53,264
The machine has a state.

217
00:10:54,384 --> 00:10:57,728
The way I like to visualize that is that I've got a maze.

218
00:10:59,010 --> 00:11:03,200
And the maze has a bunch of places connected by directed arrows.

219
00:11:04,430 --> 00:11:05,600
And what I have is a marble, which represents the state of the controller.

220
00:11:06,464 --> 00:11:09,072
And what I have is a marble, which represents the state of the controller.

221
00:11:10,740 --> 00:11:12,272
The marble rolls around in the maze.

222
00:11:13,744 --> 00:11:17,150
Of course, this analogy breaks down for energy reasons.

223
00:11:17,150 --> 00:11:19,088
I sometimes have to pump the marble up to the top, because it's going to otherwise be a perpetual motion machine.

224
00:11:19,120 --> 00:11:21,856
I sometimes have to pump the marble up to the top, because it's going to otherwise be a perpetual motion machine.

225
00:11:22,000 --> 00:11:23,328
But not worrying about that, this is not a physical analogy.

226
00:11:23,904 --> 00:11:25,904
But not worrying about that, this is not a physical analogy.

227
00:11:26,080 --> 00:11:27,424
This marble rolls around.

228
00:11:27,680 --> 00:11:29,568
And every time it rolls around certain bumpers, like in a pinball machine, it pushes one of these buttons.

229
00:11:29,680 --> 00:11:32,560
And every time it rolls around certain bumpers, like in a pinball machine, it pushes one of these buttons.

230
00:11:34,830 --> 00:11:37,504
And every so often, it comes to a place, which is a division, where it has to make a choice.

231
00:11:38,624 --> 00:11:39,680
And every so often, it comes to a place, which is a division, where it has to make a choice.

232
00:11:40,250 --> 00:11:42,360
And there's a flap, which is controlled by this.

233
00:11:46,000 --> 00:11:48,820
So that's a really mechanical way of thinking about it.

234
00:11:48,820 --> 00:11:50,192
Of course, controllers these days, are not built that way in real computers.

235
00:11:50,224 --> 00:11:51,840
Of course, controllers these days, are not built that way in real computers.

236
00:11:51,840 --> 00:11:56,016
They're built with a little bit of ROM and a state register.

237
00:11:56,610 --> 00:11:58,736
But there was a time, like the DEC PDP-6, where that's how you built the controller of a machine.

238
00:11:59,296 --> 00:12:01,024
But there was a time, like the DEC PDP-6, where that's how you built the controller of a machine.

239
00:12:01,808 --> 00:12:03,616
There was a bit that ran around the delay line, and it triggered things as it went by.

240
00:12:05,696 --> 00:12:08,144
There was a bit that ran around the delay line, and it triggered things as it went by.

241
00:12:08,580 --> 00:12:10,704
And it would come back to the beginning and get fed round again.

242
00:12:11,990 --> 00:12:13,728
And of course, there were all sorts of great bugs you could have like two bits going around, two marbles.

243
00:12:13,744 --> 00:12:17,670
And of course, there were all sorts of great bugs you could have like two bits going around, two marbles.

244
00:12:17,670 --> 00:12:19,260
And then the machine has lost its marbles.

245
00:12:19,456 --> 00:12:20,208
That happens, too.

246
00:12:20,980 --> 00:12:21,584
Oh, well.

247
00:12:22,272 --> 00:12:24,224
So anyway, for this machine, what I have to do is the following.

248
00:12:24,272 --> 00:12:25,488
So anyway, for this machine, what I have to do is the following.

249
00:12:25,808 --> 00:12:27,744
I'm going to start my maze here.

250
00:12:30,520 --> 00:12:32,736
And the first thing I've got to do, in a notation which many of you are familiar with, is b equal to zero, a test.

251
00:12:33,760 --> 00:12:36,752
And the first thing I've got to do, in a notation which many of you are familiar with, is b equal to zero, a test.

252
00:12:37,072 --> 00:12:39,856
And the first thing I've got to do, in a notation which many of you are familiar with, is b equal to zero, a test.

253
00:12:41,540 --> 00:12:42,576
And there's a possibility, either yes, in which case I'm done.

254
00:12:42,800 --> 00:12:43,792
And there's a possibility, either yes, in which case I'm done.

255
00:12:43,936 --> 00:12:45,584
And there's a possibility, either yes, in which case I'm done.

256
00:12:49,790 --> 00:12:51,264
Otherwise, if no, then I'm going have to roll over some bumpers.

257
00:12:52,704 --> 00:12:54,320
Otherwise, if no, then I'm going have to roll over some bumpers.

258
00:12:55,008 --> 00:12:56,464
I'm going to do it in the following order.

259
00:12:57,420 --> 00:13:03,408
I want to do this interchange game.

260
00:13:04,050 --> 00:13:05,808
Now first, since I need both a and b, but then the first-- and this is not necessary-- I want to collect this.

261
00:13:06,320 --> 00:13:08,576
Now first, since I need both a and b, but then the first-- and this is not necessary-- I want to collect this.

262
00:13:08,656 --> 00:13:09,728
Now first, since I need both a and b, but then the first-- and this is not necessary-- I want to collect this.

263
00:13:11,070 --> 00:13:12,624
This is the thing that's going to go into b.

264
00:13:13,240 --> 00:13:14,032
So I'm going to say, take this, which depends upon both a and b, and put the remainder into here.

265
00:13:14,288 --> 00:13:16,272
So I'm going to say, take this, which depends upon both a and b, and put the remainder into here.

266
00:13:16,368 --> 00:13:18,672
So I'm going to say, take this, which depends upon both a and b, and put the remainder into here.

267
00:13:19,150 --> 00:13:20,336
So I'm going to push this button first. Then, I'm going to transfer b to a, push that button, and then I transfer the temporary into b, push that button.

268
00:13:21,536 --> 00:13:24,432
So I'm going to push this button first. Then, I'm going to transfer b to a, push that button, and then I transfer the temporary into b, push that button.

269
00:13:24,448 --> 00:13:25,600
So I'm going to push this button first. Then, I'm going to transfer b to a, push that button, and then I transfer the temporary into b, push that button.

270
00:13:25,824 --> 00:13:27,632
So I'm going to push this button first. Then, I'm going to transfer b to a, push that button, and then I transfer the temporary into b, push that button.

271
00:13:28,768 --> 00:13:29,424
So I'm going to push this button first. Then, I'm going to transfer b to a, push that button, and then I transfer the temporary into b, push that button.

272
00:13:32,030 --> 00:13:34,970
So a very sequential machine, it's very inefficient.

273
00:13:35,392 --> 00:13:36,528
So a very sequential machine, it's very inefficient.

274
00:13:37,750 --> 00:13:39,056
But that's fine right now.

275
00:13:39,810 --> 00:13:40,970
We're going to name the buttons, t gets remainder.

276
00:13:41,472 --> 00:13:42,720
We're going to name the buttons, t gets remainder.

277
00:13:46,750 --> 00:13:48,736
a gets b.

278
00:13:50,030 --> 00:13:54,816
And b gets t.

279
00:13:55,470 --> 00:13:57,632
And then I'm going to go around here and it's to go back to start.

280
00:13:58,784 --> 00:13:59,888
And then I'm going to go around here and it's to go back to start.

281
00:14:01,620 --> 00:14:03,870
And if you look, what are we seeing here?

282
00:14:03,870 --> 00:14:04,912
We're seeing the various-- what I really have is some sort of mechanical connection, where t gets r controls this thing.

283
00:14:05,056 --> 00:14:07,168
We're seeing the various-- what I really have is some sort of mechanical connection, where t gets r controls this thing.

284
00:14:07,424 --> 00:14:13,632
We're seeing the various-- what I really have is some sort of mechanical connection, where t gets r controls this thing.

285
00:14:16,830 --> 00:14:21,488
And I have here that a gets b controls this fellow over here, and this fellow over here.

286
00:14:26,960 --> 00:14:28,120
And I have here that a gets b controls this fellow over here, and this fellow over here.

287
00:14:28,120 --> 00:14:31,088
Boy, that's absolutely pessimal, the inverse of optimal.

288
00:14:31,488 --> 00:14:32,480
Boy, that's absolutely pessimal, the inverse of optimal.

289
00:14:32,630 --> 00:14:34,590
Every line heads across every other line the way I drew it.

290
00:14:38,540 --> 00:14:41,150
I suppose this goes here, b gets t.

291
00:14:45,690 --> 00:14:48,040
Now I'd like to run this machine.

292
00:14:48,040 --> 00:14:49,344
But before I run the machine, I want to write down a description of this controller, just so you can see that these things, of course, as usual, can be written down in some nice language, so that we don't have to always draw these diagrams. One of the problems with diagrams is that they take up a lot of space.

293
00:14:49,376 --> 00:14:51,408
But before I run the machine, I want to write down a description of this controller, just so you can see that these things, of course, as usual, can be written down in some nice language, so that we don't have to always draw these diagrams. One of the problems with diagrams is that they take up a lot of space.

294
00:14:51,632 --> 00:14:53,696
But before I run the machine, I want to write down a description of this controller, just so you can see that these things, of course, as usual, can be written down in some nice language, so that we don't have to always draw these diagrams. One of the problems with diagrams is that they take up a lot of space.

295
00:14:53,900 --> 00:14:55,630
But before I run the machine, I want to write down a description of this controller, just so you can see that these things, of course, as usual, can be written down in some nice language, so that we don't have to always draw these diagrams. One of the problems with diagrams is that they take up a lot of space.

296
00:14:56,080 --> 00:14:58,080
But before I run the machine, I want to write down a description of this controller, just so you can see that these things, of course, as usual, can be written down in some nice language, so that we don't have to always draw these diagrams. One of the problems with diagrams is that they take up a lot of space.

297
00:14:58,368 --> 00:15:00,688
But before I run the machine, I want to write down a description of this controller, just so you can see that these things, of course, as usual, can be written down in some nice language, so that we don't have to always draw these diagrams. One of the problems with diagrams is that they take up a lot of space.

298
00:15:00,710 --> 00:15:01,984
And for a machine this small, it takes two blackboards.

299
00:15:02,000 --> 00:15:03,056
And for a machine this small, it takes two blackboards.

300
00:15:03,220 --> 00:15:05,248
For a machine that's the evaluator machine, I have trouble putting it into this room, even though it isn't very big.

301
00:15:05,408 --> 00:15:07,104
For a machine that's the evaluator machine, I have trouble putting it into this room, even though it isn't very big.

302
00:15:07,952 --> 00:15:09,168
For a machine that's the evaluator machine, I have trouble putting it into this room, even though it isn't very big.

303
00:15:09,900 --> 00:15:11,280
So I'm going to make a little language for this that's just a description of that, saying define a machine we'll call GCD.

304
00:15:11,296 --> 00:15:12,512
So I'm going to make a little language for this that's just a description of that, saying define a machine we'll call GCD.

305
00:15:13,104 --> 00:15:23,296
So I'm going to make a little language for this that's just a description of that, saying define a machine we'll call GCD.

306
00:15:24,420 --> 00:15:25,664
Of course, once we have something like this, we have a simulator for it.

307
00:15:25,680 --> 00:15:26,832
Of course, once we have something like this, we have a simulator for it.

308
00:15:27,220 --> 00:15:29,424
And the reason why we want to build a language in this form, is because all of a sudden we can manipulate these expressions that I'm writing down.

309
00:15:29,568 --> 00:15:32,944
And the reason why we want to build a language in this form, is because all of a sudden we can manipulate these expressions that I'm writing down.

310
00:15:33,210 --> 00:15:34,912
And then of course I can write things that can algebraically manipulate these things, simulate them, all that sort of things that I might want to do, perhaps transform them as a layout, who knows.

311
00:15:35,296 --> 00:15:36,976
And then of course I can write things that can algebraically manipulate these things, simulate them, all that sort of things that I might want to do, perhaps transform them as a layout, who knows.

312
00:15:37,152 --> 00:15:39,952
And then of course I can write things that can algebraically manipulate these things, simulate them, all that sort of things that I might want to do, perhaps transform them as a layout, who knows.

313
00:15:40,128 --> 00:15:42,592
And then of course I can write things that can algebraically manipulate these things, simulate them, all that sort of things that I might want to do, perhaps transform them as a layout, who knows.

314
00:15:43,630 --> 00:15:48,384
Once I have a nice representation of registers, it has certain registers, which we can call A, B, and T.

315
00:15:48,512 --> 00:15:55,648
Once I have a nice representation of registers, it has certain registers, which we can call A, B, and T.

316
00:15:56,752 --> 00:15:57,808
And there's a controller.

317
00:16:02,190 --> 00:16:04,464
Actually, a better language, which would be more explicit, would be one which named every button also and said what it did.

318
00:16:04,496 --> 00:16:06,976
Actually, a better language, which would be more explicit, would be one which named every button also and said what it did.

319
00:16:08,144 --> 00:16:10,176
Actually, a better language, which would be more explicit, would be one which named every button also and said what it did.

320
00:16:10,420 --> 00:16:14,192
Like, this button causes the contents of T to go to the contents of B. Well I don't want to do that, because it's actually harder to read to do that, and it takes up more space.

321
00:16:15,104 --> 00:16:17,936
Like, this button causes the contents of T to go to the contents of B. Well I don't want to do that, because it's actually harder to read to do that, and it takes up more space.

322
00:16:18,208 --> 00:16:19,344
Like, this button causes the contents of T to go to the contents of B. Well I don't want to do that, because it's actually harder to read to do that, and it takes up more space.

323
00:16:19,510 --> 00:16:22,368
So I'm going to have that in the instructions written in the controller.

324
00:16:23,290 --> 00:16:25,248
It's going to be implicit what the operations are.

325
00:16:26,320 --> 00:16:28,576
They can be deduced by reading these and collecting together all the different things that can be done.

326
00:16:29,168 --> 00:16:31,392
They can be deduced by reading these and collecting together all the different things that can be done.

327
00:16:31,696 --> 00:16:33,500
They can be deduced by reading these and collecting together all the different things that can be done.

328
00:16:33,500 --> 00:16:34,704
Well, let's just look at what these things are.

329
00:16:35,712 --> 00:16:37,296
There's a little loop that we go around which says branch, this is the representation of the little flap that decides which way you go here, if 0 fetch of B, the contents of B, and if the contents of B is 0, then go to a place called done.

330
00:16:38,240 --> 00:16:40,208
There's a little loop that we go around which says branch, this is the representation of the little flap that decides which way you go here, if 0 fetch of B, the contents of B, and if the contents of B is 0, then go to a place called done.

331
00:16:42,640 --> 00:16:46,464
There's a little loop that we go around which says branch, this is the representation of the little flap that decides which way you go here, if 0 fetch of B, the contents of B, and if the contents of B is 0, then go to a place called done.

332
00:16:46,896 --> 00:16:48,496
There's a little loop that we go around which says branch, this is the representation of the little flap that decides which way you go here, if 0 fetch of B, the contents of B, and if the contents of B is 0, then go to a place called done.

333
00:16:49,104 --> 00:16:58,000
There's a little loop that we go around which says branch, this is the representation of the little flap that decides which way you go here, if 0 fetch of B, the contents of B, and if the contents of B is 0, then go to a place called done.

334
00:16:58,656 --> 00:17:01,728
There's a little loop that we go around which says branch, this is the representation of the little flap that decides which way you go here, if 0 fetch of B, the contents of B, and if the contents of B is 0, then go to a place called done.

335
00:17:03,640 --> 00:17:05,120
Now, one thing you're seeing here, this looks very much like a traditional computer language.

336
00:17:05,136 --> 00:17:07,408
Now, one thing you're seeing here, this looks very much like a traditional computer language.

337
00:17:08,170 --> 00:17:09,552
And what you're seeing here is things like labels that represent places in a sequence written down as a sequence.

338
00:17:10,032 --> 00:17:12,000
And what you're seeing here is things like labels that represent places in a sequence written down as a sequence.

339
00:17:12,992 --> 00:17:16,864
And what you're seeing here is things like labels that represent places in a sequence written down as a sequence.

340
00:17:17,600 --> 00:17:18,944
The reason why they're needed is because over here, I've written something with loops.

341
00:17:19,488 --> 00:17:21,152
The reason why they're needed is because over here, I've written something with loops.

342
00:17:21,456 --> 00:17:22,816
The reason why they're needed is because over here, I've written something with loops.

343
00:17:23,320 --> 00:17:26,112
But if I'm writing English text, or something like that, it's hard to refer to a place.

344
00:17:26,448 --> 00:17:28,096
But if I'm writing English text, or something like that, it's hard to refer to a place.

345
00:17:28,580 --> 00:17:29,536
I don't have arrows.

346
00:17:30,800 --> 00:17:34,448
Arrows are represented by giving names to the places where the arrows terminate, and then referring to them by those names.

347
00:17:34,576 --> 00:17:36,288
Arrows are represented by giving names to the places where the arrows terminate, and then referring to them by those names.

348
00:17:37,408 --> 00:17:38,592
Now this is just an encoding.

349
00:17:39,860 --> 00:17:41,888
There's nothing magical about things like that.

350
00:17:43,150 --> 00:17:44,960
Next thing we're going to do is we're going to say, how do we do T gets R?

351
00:17:45,024 --> 00:17:46,840
Next thing we're going to do is we're going to say, how do we do T gets R?

352
00:17:47,450 --> 00:17:49,760
Oh, that's easy enough, assign.

353
00:17:52,192 --> 00:17:55,552
We assign to T the remainder.

354
00:17:56,320 --> 00:17:59,248
Assign is the name of the button.

355
00:18:01,470 --> 00:18:02,640
That's the button-pusher.

356
00:18:03,140 --> 00:18:04,976
Assign to T the remainder, and here's the representation of the operation, when we divide the fetch of A by the fetch of B.

357
00:18:04,992 --> 00:18:06,768
Assign to T the remainder, and here's the representation of the operation, when we divide the fetch of A by the fetch of B.

358
00:18:11,744 --> 00:18:17,536
Assign to T the remainder, and here's the representation of the operation, when we divide the fetch of A by the fetch of B.

359
00:18:23,856 --> 00:18:30,992
And we're also going to assign to A the fetch of B, assign to B the result of getting the contents of T. And now I have to refer to the beginning here.

360
00:18:34,990 --> 00:18:47,888
And we're also going to assign to A the fetch of B, assign to B the result of getting the contents of T. And now I have to refer to the beginning here.

361
00:18:49,616 --> 00:18:51,856
And we're also going to assign to A the fetch of B, assign to B the result of getting the contents of T. And now I have to refer to the beginning here.

362
00:18:53,184 --> 00:18:55,920
I see, why don't I call that loop like I have here?

363
00:19:04,096 --> 00:19:07,040
So that's that reference to that arrow.

364
00:19:07,610 --> 00:19:08,950
And when we're done, we're done.

365
00:19:09,024 --> 00:19:13,072
We go to here, which is the end of the thing.

366
00:19:15,264 --> 00:19:19,200
So here's just a written representation of this fragment of machinery that we've drawn here.

367
00:19:19,968 --> 00:19:20,864
So here's just a written representation of this fragment of machinery that we've drawn here.

368
00:19:21,660 --> 00:19:24,848
Now the next thing I'd like to do is run this.

369
00:19:25,490 --> 00:19:26,656
I want us to feel it running.

370
00:19:27,620 --> 00:19:29,808
Never done this before, you got to do it once.

371
00:19:31,010 --> 00:19:32,624
So let's take a particular problem.

372
00:19:33,100 --> 00:19:34,704
Suppose we want to compute the GCD of a equals 30 and b equals 42.

373
00:19:35,040 --> 00:19:40,680
Suppose we want to compute the GCD of a equals 30 and b equals 42.

374
00:19:42,210 --> 00:19:44,928
I have no idea what that is right now.

375
00:19:45,860 --> 00:19:47,600
But a 30 and b is 42.

376
00:19:50,960 --> 00:19:52,096
So that's how I start this thing up.

377
00:19:52,608 --> 00:19:53,904
Well, what's the first thing I do?

378
00:19:54,240 --> 00:19:56,864
I say is B equal to 0, no.

379
00:19:57,590 --> 00:20:02,112
Then assign to T the remainder of the fetch of A and the fetch of B. Well the remainder of 30 when divided by 42 is itself 30.

380
00:20:02,800 --> 00:20:07,600
Then assign to T the remainder of the fetch of A and the fetch of B. Well the remainder of 30 when divided by 42 is itself 30.

381
00:20:11,130 --> 00:20:12,032
Push that button.

382
00:20:12,920 --> 00:20:15,104
Now the marble has rolled to here.

383
00:20:17,100 --> 00:20:18,064
A gets B. That pushes this button.

384
00:20:19,024 --> 00:20:20,768
A gets B. That pushes this button.

385
00:20:21,220 --> 00:20:22,544
So 42 moves into here.

386
00:20:26,592 --> 00:20:27,600
B gets C. Push that button.

387
00:20:28,368 --> 00:20:29,344
B gets C. Push that button.

388
00:20:29,870 --> 00:20:30,960
The 30 goes here.

389
00:20:32,576 --> 00:20:33,696
Let met just interchange them.

390
00:20:34,660 --> 00:20:38,272
Now let's see, go back to the beginning.

391
00:20:38,640 --> 00:20:39,728
B 0, no.

392
00:20:40,192 --> 00:20:41,504
T gets the remainder.

393
00:20:43,230 --> 00:20:46,304
I suppose the remainder when dividing 42 by 30 is 12.

394
00:20:47,240 --> 00:20:48,304
I push that one.

395
00:20:48,530 --> 00:20:51,408
Next thing I do is allow the 30 to go to here, push this one, allow the 12 to go to here.

396
00:20:53,904 --> 00:20:55,950
Next thing I do is allow the 30 to go to here, push this one, allow the 12 to go to here.

397
00:20:58,416 --> 00:21:00,380
Go around this thing.

398
00:21:00,380 --> 00:21:01,312
Is that done?

399
00:21:01,530 --> 00:21:02,128
No.

400
00:21:02,360 --> 00:21:08,224
How about-- so now I have to find out the remainder of 30 divided by 12.

401
00:21:08,850 --> 00:21:10,672
And I believe that's 6.

402
00:21:12,420 --> 00:21:13,712
So 6 goes here on this button push.

403
00:21:14,112 --> 00:21:15,168
So 6 goes here on this button push.

404
00:21:16,208 --> 00:21:18,256
Then the next thing I push is this one, which the 12 goes into here.

405
00:21:18,304 --> 00:21:19,616
Then the next thing I push is this one, which the 12 goes into here.

406
00:21:23,730 --> 00:21:25,090
Then I push this button.

407
00:21:25,090 --> 00:21:26,000
The 6 gets into here.

408
00:21:29,850 --> 00:21:31,680
Is 6 equal to 0?

409
00:21:31,888 --> 00:21:32,496
No.

410
00:21:33,420 --> 00:21:33,984
OK.

411
00:21:34,380 --> 00:21:36,800
So then at that point, the next thing to do is divide it.

412
00:21:36,890 --> 00:21:38,128
So then at that point, the next thing to do is divide it.

413
00:21:38,144 --> 00:21:39,808
Ooh, this has got a remainder of 0.

414
00:21:40,660 --> 00:21:41,744
Looks like we're almost done.

415
00:21:42,360 --> 00:21:44,360
Move the 6 over here next.

416
00:21:47,008 --> 00:21:48,272
0 over here.

417
00:21:49,090 --> 00:21:50,200
Is the answer 0?

418
00:21:50,200 --> 00:21:50,736
Yes.

419
00:21:51,340 --> 00:21:53,360
B is 0, therefore the answer is in A.

420
00:21:54,288 --> 00:21:55,760
The answer is 6.

421
00:21:56,610 --> 00:21:57,616
And indeed that's right, because if we look at the original problem, what we have is 30 is 2 times 3 times 5, and 42 is 2 times 3 times 7.

422
00:21:57,632 --> 00:21:59,472
And indeed that's right, because if we look at the original problem, what we have is 30 is 2 times 3 times 5, and 42 is 2 times 3 times 7.

423
00:22:00,080 --> 00:22:06,640
And indeed that's right, because if we look at the original problem, what we have is 30 is 2 times 3 times 5, and 42 is 2 times 3 times 7.

424
00:22:07,008 --> 00:22:11,120
And indeed that's right, because if we look at the original problem, what we have is 30 is 2 times 3 times 5, and 42 is 2 times 3 times 7.

425
00:22:11,670 --> 00:22:14,112
So the greatest common divisor is 2 times 3, which is 6.

426
00:22:14,208 --> 00:22:15,088
So the greatest common divisor is 2 times 3, which is 6.

427
00:22:18,380 --> 00:22:20,560
Now normally, we write one other little line here, just to make it a little bit clearer, which is that we leave in a connection saying that this light is the guy that that flap looks at.

428
00:22:20,592 --> 00:22:22,528
Now normally, we write one other little line here, just to make it a little bit clearer, which is that we leave in a connection saying that this light is the guy that that flap looks at.

429
00:22:22,896 --> 00:22:27,712
Now normally, we write one other little line here, just to make it a little bit clearer, which is that we leave in a connection saying that this light is the guy that that flap looks at.

430
00:22:27,856 --> 00:22:31,010
Now normally, we write one other little line here, just to make it a little bit clearer, which is that we leave in a connection saying that this light is the guy that that flap looks at.

431
00:22:34,000 --> 00:22:40,000
Of course, any real machine has a lot more complicated things in it than what I've just shown you.

432
00:22:41,350 --> 00:22:47,168
Let's look for a second at the first still store.

433
00:22:47,980 --> 00:22:48,816
Wow.

434
00:22:50,190 --> 00:22:52,432
Well you see, for example, one thing we might want to do is worry about the operations that are of IO form.

435
00:22:52,656 --> 00:22:55,856
Well you see, for example, one thing we might want to do is worry about the operations that are of IO form.

436
00:22:56,840 --> 00:23:01,424
And we may have to collect something from the outside.

437
00:23:01,980 --> 00:23:03,936
So a state machine that we might have, the controller may have to, for example, get a value from something and put register a to load it up.

438
00:23:04,240 --> 00:23:05,568
So a state machine that we might have, the controller may have to, for example, get a value from something and put register a to load it up.

439
00:23:05,920 --> 00:23:10,592
So a state machine that we might have, the controller may have to, for example, get a value from something and put register a to load it up.

440
00:23:10,784 --> 00:23:12,416
So a state machine that we might have, the controller may have to, for example, get a value from something and put register a to load it up.

441
00:23:13,490 --> 00:23:15,920
I have to master load up register b with another value.

442
00:23:17,070 --> 00:23:18,608
And then later, when I'm done, I might want to print the answer out.

443
00:23:18,992 --> 00:23:20,528
And then later, when I'm done, I might want to print the answer out.

444
00:23:21,200 --> 00:23:25,232
And of course, that might be either simple or complicated.

445
00:23:26,090 --> 00:23:28,032
I'm writing, assuming print is very simple, and read is very simple.

446
00:23:28,096 --> 00:23:29,296
I'm writing, assuming print is very simple, and read is very simple.

447
00:23:29,880 --> 00:23:31,088
But in fact, in the real world, those are very complicated operations, usually much, much larger and more complicated than the thing you're doing as your problem you're trying to solve.

448
00:23:31,120 --> 00:23:32,896
But in fact, in the real world, those are very complicated operations, usually much, much larger and more complicated than the thing you're doing as your problem you're trying to solve.

449
00:23:33,088 --> 00:23:38,330
But in fact, in the real world, those are very complicated operations, usually much, much larger and more complicated than the thing you're doing as your problem you're trying to solve.

450
00:23:41,670 --> 00:23:43,904
On the other hand, I can remember a time when, I remember using IBM 7090 computer of sorts, where things like read and write of a single object, a single number, a number, is a primitive operation of the IO controller.

451
00:23:44,896 --> 00:23:48,784
On the other hand, I can remember a time when, I remember using IBM 7090 computer of sorts, where things like read and write of a single object, a single number, a number, is a primitive operation of the IO controller.

452
00:23:49,056 --> 00:23:53,040
On the other hand, I can remember a time when, I remember using IBM 7090 computer of sorts, where things like read and write of a single object, a single number, a number, is a primitive operation of the IO controller.

453
00:23:53,088 --> 00:23:54,624
On the other hand, I can remember a time when, I remember using IBM 7090 computer of sorts, where things like read and write of a single object, a single number, a number, is a primitive operation of the IO controller.

454
00:23:55,840 --> 00:23:58,544
On the other hand, I can remember a time when, I remember using IBM 7090 computer of sorts, where things like read and write of a single object, a single number, a number, is a primitive operation of the IO controller.

455
00:23:59,632 --> 00:24:02,048
OK? And so we have that kind of thing in there.

456
00:24:02,330 --> 00:24:04,672
And in such a machine, well, what are we really doing?

457
00:24:05,440 --> 00:24:06,896
And in such a machine, well, what are we really doing?

458
00:24:07,120 --> 00:24:11,600
We're just saying that there's a source over here called "read," which is an operation which always has a value.

459
00:24:12,208 --> 00:24:14,464
We're just saying that there's a source over here called "read," which is an operation which always has a value.

460
00:24:14,660 --> 00:24:17,136
We have to think about this as always having a value which can be gated into either register a or b.

461
00:24:17,216 --> 00:24:19,840
We have to think about this as always having a value which can be gated into either register a or b.

462
00:24:21,660 --> 00:24:23,232
And print is some sort of thing which when you gate it appropriately, when you push the button on it, will cause a print of the value that's currently in register a.

463
00:24:23,376 --> 00:24:25,024
And print is some sort of thing which when you gate it appropriately, when you push the button on it, will cause a print of the value that's currently in register a.

464
00:24:25,248 --> 00:24:26,432
And print is some sort of thing which when you gate it appropriately, when you push the button on it, will cause a print of the value that's currently in register a.

465
00:24:26,656 --> 00:24:29,616
And print is some sort of thing which when you gate it appropriately, when you push the button on it, will cause a print of the value that's currently in register a.

466
00:24:31,660 --> 00:24:32,736
Nothing very exciting.

467
00:24:33,328 --> 00:24:35,200
So that's one sort of thing you might want to have. But these are also other things that are a little bit worrisome.

468
00:24:35,888 --> 00:24:38,320
So that's one sort of thing you might want to have. But these are also other things that are a little bit worrisome.

469
00:24:38,320 --> 00:24:40,672
Like I've used here some complicated mechanisms.

470
00:24:41,050 --> 00:24:42,480
What you see here is remainder.

471
00:24:43,850 --> 00:24:44,448
What is that?

472
00:24:44,690 --> 00:24:46,416
That may not be so obvious how to compute.

473
00:24:46,920 --> 00:24:48,928
It may be something which when you open it up, you get a whole machine.

474
00:24:49,488 --> 00:24:50,624
It may be something which when you open it up, you get a whole machine.

475
00:24:51,840 --> 00:24:53,664
OK? In fact, that's true.

476
00:24:54,540 --> 00:24:59,152
For example, if I write down the program for remainder, the simplest program for it is by repeated subtraction.

477
00:24:59,408 --> 00:25:00,768
For example, if I write down the program for remainder, the simplest program for it is by repeated subtraction.

478
00:25:00,896 --> 00:25:02,448
For example, if I write down the program for remainder, the simplest program for it is by repeated subtraction.

479
00:25:04,780 --> 00:25:07,072
Because of course, division can be done by repeated subtraction of numbers, of integers.

480
00:25:07,424 --> 00:25:08,990
Because of course, division can be done by repeated subtraction of numbers, of integers.

481
00:25:09,800 --> 00:25:23,584
So the remainder of N divided by D is nothing more than if N is less than D, then the result is N. Otherwise, it's the remainder when we subtract D from N with respect to D, when divided by D. Gee, this looks just like the GCD program.

482
00:25:24,992 --> 00:25:31,440
So the remainder of N divided by D is nothing more than if N is less than D, then the result is N. Otherwise, it's the remainder when we subtract D from N with respect to D, when divided by D. Gee, this looks just like the GCD program.

483
00:25:32,240 --> 00:25:33,664
So the remainder of N divided by D is nothing more than if N is less than D, then the result is N. Otherwise, it's the remainder when we subtract D from N with respect to D, when divided by D. Gee, this looks just like the GCD program.

484
00:25:34,304 --> 00:25:35,904
So the remainder of N divided by D is nothing more than if N is less than D, then the result is N. Otherwise, it's the remainder when we subtract D from N with respect to D, when divided by D. Gee, this looks just like the GCD program.

485
00:25:41,150 --> 00:25:47,600
So the remainder of N divided by D is nothing more than if N is less than D, then the result is N. Otherwise, it's the remainder when we subtract D from N with respect to D, when divided by D. Gee, this looks just like the GCD program.

486
00:25:48,272 --> 00:25:49,328
So the remainder of N divided by D is nothing more than if N is less than D, then the result is N. Otherwise, it's the remainder when we subtract D from N with respect to D, when divided by D. Gee, this looks just like the GCD program.

487
00:25:51,280 --> 00:25:55,056
So the remainder of N divided by D is nothing more than if N is less than D, then the result is N. Otherwise, it's the remainder when we subtract D from N with respect to D, when divided by D. Gee, this looks just like the GCD program.

488
00:25:56,890 --> 00:25:59,488
Of course, it's not a very nice way to do remainders.

489
00:25:59,750 --> 00:26:00,912
You'd really want to use something like binary notation and shift and things like that in a practical computer.

490
00:26:00,928 --> 00:26:02,992
You'd really want to use something like binary notation and shift and things like that in a practical computer.

491
00:26:03,344 --> 00:26:05,550
You'd really want to use something like binary notation and shift and things like that in a practical computer.

492
00:26:05,550 --> 00:26:06,976
But the point of that is that if I open this thing up, I might find inside of it a computer.

493
00:26:07,136 --> 00:26:08,480
But the point of that is that if I open this thing up, I might find inside of it a computer.

494
00:26:08,928 --> 00:26:10,640
But the point of that is that if I open this thing up, I might find inside of it a computer.

495
00:26:11,880 --> 00:26:12,992
Oh, we know how to do that.

496
00:26:13,510 --> 00:26:14,336
We just made one.

497
00:26:15,640 --> 00:26:17,104
And it could be another thing just like this.

498
00:26:17,400 --> 00:26:18,064
On the other hand, we might want to make a more efficient or better-structured machine, or maybe make use of some of the registers more than once, or some horrible mess like that that hardware designers like to do, and for very good reasons.

499
00:26:18,080 --> 00:26:21,680
On the other hand, we might want to make a more efficient or better-structured machine, or maybe make use of some of the registers more than once, or some horrible mess like that that hardware designers like to do, and for very good reasons.

500
00:26:21,856 --> 00:26:27,056
On the other hand, we might want to make a more efficient or better-structured machine, or maybe make use of some of the registers more than once, or some horrible mess like that that hardware designers like to do, and for very good reasons.

501
00:26:27,312 --> 00:26:28,608
On the other hand, we might want to make a more efficient or better-structured machine, or maybe make use of some of the registers more than once, or some horrible mess like that that hardware designers like to do, and for very good reasons.

502
00:26:29,250 --> 00:26:31,568
So for example, here's a machine that you see, which you're not supposed to be able to read.

503
00:26:32,528 --> 00:26:34,912
So for example, here's a machine that you see, which you're not supposed to be able to read.

504
00:26:35,050 --> 00:26:37,520
It's a little bit complicated. OK?

505
00:26:37,520 --> 00:26:39,872
But what it is is the integration of the remainder into the GCD machine.

506
00:26:40,096 --> 00:26:43,824
But what it is is the integration of the remainder into the GCD machine.

507
00:26:44,464 --> 00:26:46,020
And it takes, in fact, no more registers.

508
00:26:46,020 --> 00:26:48,624
There are three registers in the datapaths.

509
00:26:49,050 --> 00:26:50,640
But now there's a subtractor.

510
00:26:51,550 --> 00:26:52,992
There are two things that are tested.

511
00:26:53,020 --> 00:26:55,072
Is b equal to 0, or is t less than b?

512
00:26:55,232 --> 00:26:56,560
Is b equal to 0, or is t less than b?

513
00:26:57,250 --> 00:26:59,456
And then the controller, which you see over here, is not much more complicated.

514
00:27:00,224 --> 00:27:01,760
And then the controller, which you see over here, is not much more complicated.

515
00:27:01,850 --> 00:27:03,872
But it has two loops in it, one of which is the main one for doing the GCD, and one of which is the subtraction loop for doing the remainder sub-operation.

516
00:27:04,528 --> 00:27:08,336
But it has two loops in it, one of which is the main one for doing the GCD, and one of which is the subtraction loop for doing the remainder sub-operation.

517
00:27:08,400 --> 00:27:10,144
But it has two loops in it, one of which is the main one for doing the GCD, and one of which is the subtraction loop for doing the remainder sub-operation.

518
00:27:10,432 --> 00:27:12,800
But it has two loops in it, one of which is the main one for doing the GCD, and one of which is the subtraction loop for doing the remainder sub-operation.

519
00:27:14,030 --> 00:27:15,808
And there are ways, of course, of, if you think about it, taking the remainder program.

520
00:27:15,968 --> 00:27:18,688
And there are ways, of course, of, if you think about it, taking the remainder program.

521
00:27:19,920 --> 00:27:20,960
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

522
00:27:20,992 --> 00:27:22,832
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

523
00:27:23,568 --> 00:27:27,024
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

524
00:27:28,208 --> 00:27:30,128
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

525
00:27:30,320 --> 00:27:33,664
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

526
00:27:34,464 --> 00:27:35,952
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

527
00:27:36,630 --> 00:27:39,424
And I can get this piece of machinery by basically, a little bit of algebraic simplification on the lambda expressions.

528
00:27:40,736 --> 00:27:42,944
And I can get this piece of machinery by basically, a little bit of algebraic simplification on the lambda expressions.

529
00:27:43,360 --> 00:27:45,216
And I can get this piece of machinery by basically, a little bit of algebraic simplification on the lambda expressions.

530
00:27:48,550 --> 00:27:51,200
So I suppose you've seen your first very simple machines now.

531
00:27:51,952 --> 00:27:53,280
Are there any questions?

532
00:28:02,700 --> 00:28:03,104
Good.

533
00:28:05,360 --> 00:28:06,544
This looks easy, doesn't it?

534
00:28:10,144 --> 00:28:11,328
Thank you. I suppose, take a break.

535
00:28:11,350 --> 00:28:13,010
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

536
00:28:47,936 --> 00:28:48,704
PROFESSOR: Well, let's see.

537
00:28:49,376 --> 00:28:52,464
Now you know how to make an iterative procedure, or a procedure that yields an iterative process, turn into a machine.

538
00:28:52,544 --> 00:28:54,544
Now you know how to make an iterative procedure, or a procedure that yields an iterative process, turn into a machine.

539
00:28:55,184 --> 00:28:56,528
Now you know how to make an iterative procedure, or a procedure that yields an iterative process, turn into a machine.

540
00:28:57,770 --> 00:29:00,048
I suppose the next thing we want to do is worry about things that reveal recursive processes.

541
00:29:00,544 --> 00:29:02,304
I suppose the next thing we want to do is worry about things that reveal recursive processes.

542
00:29:02,816 --> 00:29:05,056
So let's play with a simple factorial procedure.

543
00:29:11,200 --> 00:29:16,944
We define factorial of N to be if n is 1, the result is 1, using 1 right now to decrease the amount of work I have to do to simulate it, else it's times N factorial N minus 1.

544
00:29:19,632 --> 00:29:24,256
We define factorial of N to be if n is 1, the result is 1, using 1 right now to decrease the amount of work I have to do to simulate it, else it's times N factorial N minus 1.

545
00:29:24,624 --> 00:29:27,696
We define factorial of N to be if n is 1, the result is 1, using 1 right now to decrease the amount of work I have to do to simulate it, else it's times N factorial N minus 1.

546
00:29:28,128 --> 00:29:33,940
We define factorial of N to be if n is 1, the result is 1, using 1 right now to decrease the amount of work I have to do to simulate it, else it's times N factorial N minus 1.

547
00:29:42,520 --> 00:29:46,048
And what's different with this program, as you know, is that after I've computed factorial of N minus 1 here, I have to do something to the result.

548
00:29:46,656 --> 00:29:50,368
And what's different with this program, as you know, is that after I've computed factorial of N minus 1 here, I have to do something to the result.

549
00:29:50,672 --> 00:29:52,260
And what's different with this program, as you know, is that after I've computed factorial of N minus 1 here, I have to do something to the result.

550
00:29:52,260 --> 00:29:53,680
I have to multiply it by N.

551
00:29:56,000 --> 00:29:58,880
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

552
00:29:59,136 --> 00:30:00,592
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

553
00:30:01,088 --> 00:30:02,016
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

554
00:30:02,352 --> 00:30:03,184
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

555
00:30:03,360 --> 00:30:04,944
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

556
00:30:05,088 --> 00:30:08,112
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

557
00:30:09,320 --> 00:30:11,168
But this machine, the outer machine, has to exist before and after the factorial machine, which is inside.

558
00:30:11,200 --> 00:30:13,136
But this machine, the outer machine, has to exist before and after the factorial machine, which is inside.

559
00:30:13,904 --> 00:30:15,712
But this machine, the outer machine, has to exist before and after the factorial machine, which is inside.

560
00:30:16,800 --> 00:30:17,904
Whereas in the iterative case, the outer machine doesn't need to exist after the inner machine is running, because you never need to go back to the outer machine to do anything.

561
00:30:18,752 --> 00:30:20,528
Whereas in the iterative case, the outer machine doesn't need to exist after the inner machine is running, because you never need to go back to the outer machine to do anything.

562
00:30:20,912 --> 00:30:24,016
Whereas in the iterative case, the outer machine doesn't need to exist after the inner machine is running, because you never need to go back to the outer machine to do anything.

563
00:30:24,832 --> 00:30:27,536
Whereas in the iterative case, the outer machine doesn't need to exist after the inner machine is running, because you never need to go back to the outer machine to do anything.

564
00:30:28,640 --> 00:30:30,064
So here we have a problem where we have a machine which has the same machine inside of it, an infinitely large machine.

565
00:30:30,272 --> 00:30:32,736
So here we have a problem where we have a machine which has the same machine inside of it, an infinitely large machine.

566
00:30:33,872 --> 00:30:35,520
So here we have a problem where we have a machine which has the same machine inside of it, an infinitely large machine.

567
00:30:40,390 --> 00:30:43,120
And it's got other things inside of it, like a multiplier, which takes some inputs, and there's a minus 1 box, and things like that.

568
00:30:44,768 --> 00:30:46,032
And it's got other things inside of it, like a multiplier, which takes some inputs, and there's a minus 1 box, and things like that.

569
00:30:46,272 --> 00:30:47,776
And it's got other things inside of it, like a multiplier, which takes some inputs, and there's a minus 1 box, and things like that.

570
00:30:48,128 --> 00:30:49,312
And it's got other things inside of it, like a multiplier, which takes some inputs, and there's a minus 1 box, and things like that.

571
00:30:50,690 --> 00:30:53,728
You can imagine that's what it looks like.

572
00:30:54,370 --> 00:30:56,768
But the important thing is that here I have something that happens before and after, in the outer machine, the execution of the inner machine.

573
00:30:57,024 --> 00:30:59,904
But the important thing is that here I have something that happens before and after, in the outer machine, the execution of the inner machine.

574
00:31:00,176 --> 00:31:01,600
But the important thing is that here I have something that happens before and after, in the outer machine, the execution of the inner machine.

575
00:31:02,540 --> 00:31:04,080
So this machine has to have a life.

576
00:31:05,570 --> 00:31:07,568
It has to exist on both times sides of this machine.

577
00:31:08,608 --> 00:31:11,440
It has to exist on both times sides of this machine.

578
00:31:13,490 --> 00:31:15,808
So somehow, I have to have a place to store the things that this thing needs to run.

579
00:31:16,192 --> 00:31:18,192
So somehow, I have to have a place to store the things that this thing needs to run.

580
00:31:20,030 --> 00:31:22,096
Infinite objects don't exist in the real world.

581
00:31:24,140 --> 00:31:25,584
What we have to do is arrange an illusion that we have an infinite object, we have an infinite amount of hardware somewhere.

582
00:31:26,128 --> 00:31:27,488
What we have to do is arrange an illusion that we have an infinite object, we have an infinite amount of hardware somewhere.

583
00:31:27,984 --> 00:31:29,776
What we have to do is arrange an illusion that we have an infinite object, we have an infinite amount of hardware somewhere.

584
00:31:31,830 --> 00:31:35,344
Now of course, illusion's all that really matters.

585
00:31:36,280 --> 00:31:40,320
If we can arrange that every time you look at some infinite object, the part of it that you look at is there, then it's as infinite as you need it to be.

586
00:31:40,976 --> 00:31:46,048
If we can arrange that every time you look at some infinite object, the part of it that you look at is there, then it's as infinite as you need it to be.

587
00:31:47,390 --> 00:31:49,440
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

588
00:31:49,824 --> 00:31:52,496
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

589
00:31:53,008 --> 00:31:54,976
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

590
00:31:56,048 --> 00:31:57,648
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

591
00:31:57,920 --> 00:32:02,352
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

592
00:32:03,184 --> 00:32:04,464
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

593
00:32:04,784 --> 00:32:07,616
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

594
00:32:09,170 --> 00:32:10,448
We have some datapaths, which consist of registers and operators.

595
00:32:10,464 --> 00:32:12,752
We have some datapaths, which consist of registers and operators.

596
00:32:13,080 --> 00:32:15,200
And what I propose to do here is decompose the machine into two parts, such that there is a part which is fundamentally finite, and some part where a certain amount of infinite stuff can be kept.

597
00:32:15,488 --> 00:32:16,960
And what I propose to do here is decompose the machine into two parts, such that there is a part which is fundamentally finite, and some part where a certain amount of infinite stuff can be kept.

598
00:32:17,360 --> 00:32:19,792
And what I propose to do here is decompose the machine into two parts, such that there is a part which is fundamentally finite, and some part where a certain amount of infinite stuff can be kept.

599
00:32:20,784 --> 00:32:23,536
And what I propose to do here is decompose the machine into two parts, such that there is a part which is fundamentally finite, and some part where a certain amount of infinite stuff can be kept.

600
00:32:24,230 --> 00:32:25,904
On the other hand this is very simple and really isn't infinite, but it's just very large.

601
00:32:26,416 --> 00:32:28,720
On the other hand this is very simple and really isn't infinite, but it's just very large.

602
00:32:29,430 --> 00:32:30,400
But it's so simple

603
00:32:30,528 --> 00:32:32,928
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

604
00:32:34,096 --> 00:32:34,928
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

605
00:32:35,952 --> 00:32:39,072
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

606
00:32:39,408 --> 00:32:41,232
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

607
00:32:41,450 --> 00:32:43,632
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

608
00:32:43,648 --> 00:32:46,960
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

609
00:32:48,340 --> 00:32:49,440
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

610
00:32:49,936 --> 00:32:50,416
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

611
00:32:50,560 --> 00:32:52,976
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

612
00:32:54,352 --> 00:32:55,632
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

613
00:32:55,888 --> 00:32:57,600
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

614
00:32:59,184 --> 00:33:01,072
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

615
00:33:03,840 --> 00:33:05,488
So it will remember the important things about the life of the outer machine that will be needed for this computation.

616
00:33:05,632 --> 00:33:07,952
So it will remember the important things about the life of the outer machine that will be needed for this computation.

617
00:33:08,048 --> 00:33:10,304
So it will remember the important things about the life of the outer machine that will be needed for this computation.

618
00:33:11,390 --> 00:33:12,480
Since, of course, these machines are nested in a recursive manner, then in fact the stack will only be accessed in a manner which is the last thing that goes in is the first thing that comes out.

619
00:33:12,752 --> 00:33:16,336
Since, of course, these machines are nested in a recursive manner, then in fact the stack will only be accessed in a manner which is the last thing that goes in is the first thing that comes out.

620
00:33:18,336 --> 00:33:20,912
Since, of course, these machines are nested in a recursive manner, then in fact the stack will only be accessed in a manner which is the last thing that goes in is the first thing that comes out.

621
00:33:21,712 --> 00:33:26,448
Since, of course, these machines are nested in a recursive manner, then in fact the stack will only be accessed in a manner which is the last thing that goes in is the first thing that comes out.

622
00:33:29,330 --> 00:33:30,640
So we'll only need to access some little part of this stack memory.

623
00:33:30,800 --> 00:33:32,528
So we'll only need to access some little part of this stack memory.

624
00:33:34,930 --> 00:33:35,920
OK, well, let's do it.

625
00:33:36,810 --> 00:33:38,416
I'm going to build you a datapath now, and I'm going to write the controller.

626
00:33:38,448 --> 00:33:39,680
I'm going to build you a datapath now, and I'm going to write the controller.

627
00:33:40,370 --> 00:33:42,864
And then we're going to execute this to see how you do it.

628
00:33:43,510 --> 00:33:46,880
So the factorial machine isn't so bad.

629
00:33:47,900 --> 00:33:50,160
It's going to have a register called the value, where the answer is going to be stored, and a registered called N, which is where the number I'm taking factorial will be stored, factorial of.

630
00:33:52,224 --> 00:33:53,888
It's going to have a register called the value, where the answer is going to be stored, and a registered called N, which is where the number I'm taking factorial will be stored, factorial of.

631
00:33:54,896 --> 00:33:56,672
It's going to have a register called the value, where the answer is going to be stored, and a registered called N, which is where the number I'm taking factorial will be stored, factorial of.

632
00:33:59,856 --> 00:34:04,160
It's going to have a register called the value, where the answer is going to be stored, and a registered called N, which is where the number I'm taking factorial will be stored, factorial of.

633
00:34:04,512 --> 00:34:06,624
And it will be necessary in some instances to connect VAL to N.

634
00:34:07,520 --> 00:34:10,544
And it will be necessary in some instances to connect VAL to N.

635
00:34:11,760 --> 00:34:13,632
In fact, one nice case of this is if I just said over here, N, because that would be right for N equal 1N.

636
00:34:13,760 --> 00:34:15,632
In fact, one nice case of this is if I just said over here, N, because that would be right for N equal 1N.

637
00:34:16,380 --> 00:34:19,536
In fact, one nice case of this is if I just said over here, N, because that would be right for N equal 1N.

638
00:34:20,090 --> 00:34:23,264
And I could just move the answer over there if that's important.

639
00:34:23,900 --> 00:34:25,552
I'm not worried about that right now.

640
00:34:26,980 --> 00:34:28,608
And there are things I have to be able to do.

641
00:34:29,060 --> 00:34:31,024
Like I have to be able to, as we see here, multiply N by something in VAL, because VAL is the result of computing factorial.

642
00:34:31,216 --> 00:34:34,672
Like I have to be able to, as we see here, multiply N by something in VAL, because VAL is the result of computing factorial.

643
00:34:34,912 --> 00:34:37,456
Like I have to be able to, as we see here, multiply N by something in VAL, because VAL is the result of computing factorial.

644
00:34:38,688 --> 00:34:40,448
And I have to put the result back into VAL.

645
00:34:41,488 --> 00:34:42,656
So here we can see that the result of computing a factorial is N times the result of computing a factorial.

646
00:34:42,832 --> 00:34:46,432
So here we can see that the result of computing a factorial is N times the result of computing a factorial.

647
00:34:46,576 --> 00:34:49,200
So here we can see that the result of computing a factorial is N times the result of computing a factorial.

648
00:34:50,690 --> 00:34:53,776
VAL will be the representation of the answer of the inner factorial.

649
00:34:55,190 --> 00:35:00,256
And so I'm going to have to have a multiplier here, which is going to sample the value of N and the value of VAL and put the result back into VAL like that.

650
00:35:02,368 --> 00:35:04,608
And so I'm going to have to have a multiplier here, which is going to sample the value of N and the value of VAL and put the result back into VAL like that.

651
00:35:05,744 --> 00:35:07,152
And so I'm going to have to have a multiplier here, which is going to sample the value of N and the value of VAL and put the result back into VAL like that.

652
00:35:08,640 --> 00:35:15,600
And so I'm going to have to have a multiplier here, which is going to sample the value of N and the value of VAL and put the result back into VAL like that.

653
00:35:17,170 --> 00:35:19,392
I'm also going to have to be able to see if N is 1.

654
00:35:21,328 --> 00:35:22,384
So I need a light bulb.

655
00:35:28,200 --> 00:35:30,400
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

656
00:35:31,024 --> 00:35:32,848
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

657
00:35:34,848 --> 00:35:36,096
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

658
00:35:38,368 --> 00:35:39,232
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

659
00:35:39,552 --> 00:35:41,392
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

660
00:35:46,620 --> 00:35:48,400
That's pretty much what I need in my machine.

661
00:35:49,550 --> 00:35:51,648
Now, there's a little bit else I need.

662
00:35:52,304 --> 00:35:53,584
It's a little bit more complicated, because I'm also going to need a way to store, to save away, the things that are going to be needed for resuming the computation of a factorial after I've done a sub-factorial.

663
00:35:55,168 --> 00:35:56,880
It's a little bit more complicated, because I'm also going to need a way to store, to save away, the things that are going to be needed for resuming the computation of a factorial after I've done a sub-factorial.

664
00:35:57,168 --> 00:35:59,696
It's a little bit more complicated, because I'm also going to need a way to store, to save away, the things that are going to be needed for resuming the computation of a factorial after I've done a sub-factorial.

665
00:36:01,024 --> 00:36:04,864
It's a little bit more complicated, because I'm also going to need a way to store, to save away, the things that are going to be needed for resuming the computation of a factorial after I've done a sub-factorial.

666
00:36:06,250 --> 00:36:06,864
What's that?

667
00:36:07,230 --> 00:36:08,736
One thing I need is N.

668
00:36:09,850 --> 00:36:12,048
So I'm going to build here a thing called a stack.

669
00:36:14,700 --> 00:36:15,680
The stack is a bunch of stuff that I'm going to write in sequentially.

670
00:36:17,984 --> 00:36:24,976
The stack is a bunch of stuff that I'm going to write in sequentially.

671
00:36:27,152 --> 00:36:28,592
I don't how long it is.

672
00:36:29,152 --> 00:36:31,488
The longer it is, the better my illusion of infinity.

673
00:36:33,232 --> 00:36:34,448
And I'm going to have to have a way of getting stuff out of N and into the stack and vice versa.

674
00:36:34,544 --> 00:36:37,024
And I'm going to have to have a way of getting stuff out of N and into the stack and vice versa.

675
00:36:38,128 --> 00:36:39,088
And I'm going to have to have a way of getting stuff out of N and into the stack and vice versa.

676
00:36:39,936 --> 00:36:41,744
So I'm going to need a connection like this, which is two-way, whereby I can save the value of N and then restore it some other time through that connection.

677
00:36:44,416 --> 00:36:45,488
So I'm going to need a connection like this, which is two-way, whereby I can save the value of N and then restore it some other time through that connection.

678
00:36:50,448 --> 00:36:52,224
So I'm going to need a connection like this, which is two-way, whereby I can save the value of N and then restore it some other time through that connection.

679
00:36:52,240 --> 00:36:55,504
So I'm going to need a connection like this, which is two-way, whereby I can save the value of N and then restore it some other time through that connection.

680
00:36:56,048 --> 00:36:56,848
This is the stack.

681
00:36:58,100 --> 00:36:59,280
I also need a way of remembering where I was in the computation of factorial in the outer program.

682
00:37:00,352 --> 00:37:03,744
I also need a way of remembering where I was in the computation of factorial in the outer program.

683
00:37:04,432 --> 00:37:07,712
I also need a way of remembering where I was in the computation of factorial in the outer program.

684
00:37:08,530 --> 00:37:10,064
Now in the case of this machine, it isn't very much a problem.

685
00:37:10,768 --> 00:37:13,344
Now in the case of this machine, it isn't very much a problem.

686
00:37:14,176 --> 00:37:16,240
Factorial always returns, has to go back to the place where we multiply by N, except for the last time, when it has to return to whatever needs the factorial or go to done or stop.

687
00:37:16,864 --> 00:37:19,072
Factorial always returns, has to go back to the place where we multiply by N, except for the last time, when it has to return to whatever needs the factorial or go to done or stop.

688
00:37:19,344 --> 00:37:20,720
Factorial always returns, has to go back to the place where we multiply by N, except for the last time, when it has to return to whatever needs the factorial or go to done or stop.

689
00:37:21,152 --> 00:37:24,048
Factorial always returns, has to go back to the place where we multiply by N, except for the last time, when it has to return to whatever needs the factorial or go to done or stop.

690
00:37:25,660 --> 00:37:26,672
However, in general, I'm going to have to remember where I have been, because I might have computed factorial from somewhere else.

691
00:37:27,168 --> 00:37:28,736
However, in general, I'm going to have to remember where I have been, because I might have computed factorial from somewhere else.

692
00:37:29,136 --> 00:37:31,248
However, in general, I'm going to have to remember where I have been, because I might have computed factorial from somewhere else.

693
00:37:32,080 --> 00:37:34,896
I have to go back to that place and continue there.

694
00:37:36,070 --> 00:37:38,000
So I'm going to have to have some way of taking the place where the marble is in the finite state controller, the state of the controller, and storing that in the stack as well.

695
00:37:38,016 --> 00:37:40,864
So I'm going to have to have some way of taking the place where the marble is in the finite state controller, the state of the controller, and storing that in the stack as well.

696
00:37:41,328 --> 00:37:42,640
So I'm going to have to have some way of taking the place where the marble is in the finite state controller, the state of the controller, and storing that in the stack as well.

697
00:37:44,224 --> 00:37:46,352
So I'm going to have to have some way of taking the place where the marble is in the finite state controller, the state of the controller, and storing that in the stack as well.

698
00:37:47,400 --> 00:37:49,104
And I'm going to have to have ways of restoring that back to the state of the-- the marble.

699
00:37:49,456 --> 00:37:51,120
And I'm going to have to have ways of restoring that back to the state of the-- the marble.

700
00:37:52,144 --> 00:37:54,288
So I have to have something that moves the marble to the right place.

701
00:37:54,704 --> 00:37:56,528
Well, we're going to have a place which is the marble now.

702
00:37:57,872 --> 00:37:59,344
And it's called the continue register, called continue, which is the place to put the marble next time I go to continue.

703
00:38:03,616 --> 00:38:04,528
And it's called the continue register, called continue, which is the place to put the marble next time I go to continue.

704
00:38:09,168 --> 00:38:13,056
And it's called the continue register, called continue, which is the place to put the marble next time I go to continue.

705
00:38:14,912 --> 00:38:15,920
That's what that's for.

706
00:38:16,140 --> 00:38:18,480
And so there's got to be some path from that into the controller.

707
00:38:22,910 --> 00:38:27,120
I also have to have some way of saving that on the stack.

708
00:38:29,456 --> 00:38:31,216
And I have to have some way of setting that up to have various constants, a certain fixed number of constants.

709
00:38:31,872 --> 00:38:33,008
And I have to have some way of setting that up to have various constants, a certain fixed number of constants.

710
00:38:34,016 --> 00:38:35,696
And I have to have some way of setting that up to have various constants, a certain fixed number of constants.

711
00:38:36,860 --> 00:38:38,208
And that's very easy to arrange.

712
00:38:38,840 --> 00:38:40,144
So let's have some constants here.

713
00:38:40,180 --> 00:38:41,504
We'll call this one after-fact.

714
00:38:47,328 --> 00:38:48,752
And that's a constant which we'll get into the continue register, and also another one called fact-done.

715
00:38:48,848 --> 00:38:51,504
And that's a constant which we'll get into the continue register, and also another one called fact-done.

716
00:38:52,592 --> 00:38:54,432
And that's a constant which we'll get into the continue register, and also another one called fact-done.

717
00:39:05,210 --> 00:39:07,824
So this is the machine I want to build.

718
00:39:08,130 --> 00:39:09,488
That's its datapaths, at least. And it mixes a little with the controller here, because of the fact that I have to remember where I was and restore myself to that place.

719
00:39:09,920 --> 00:39:11,696
That's its datapaths, at least. And it mixes a little with the controller here, because of the fact that I have to remember where I was and restore myself to that place.

720
00:39:11,856 --> 00:39:14,592
That's its datapaths, at least. And it mixes a little with the controller here, because of the fact that I have to remember where I was and restore myself to that place.

721
00:39:14,704 --> 00:39:16,352
That's its datapaths, at least. And it mixes a little with the controller here, because of the fact that I have to remember where I was and restore myself to that place.

722
00:39:17,300 --> 00:39:19,936
But let's write the program now which represents the controller.

723
00:39:20,390 --> 00:39:22,624
I'm not going to write the define machine thing and the register list, because that's not very interesting.

724
00:39:22,640 --> 00:39:23,456
I'm not going to write the define machine thing and the register list, because that's not very interesting.

725
00:39:23,488 --> 00:39:24,890
I'm not going to write the define machine thing and the register list, because that's not very interesting.

726
00:39:25,136 --> 00:39:29,024
I'm just going to write down the sequence of instructions that constitute the controller.

727
00:39:31,488 --> 00:39:41,856
So we have assign, to set up, continue to done.

728
00:39:45,152 --> 00:39:56,080
We have a loop which says branch if equal 1 fetch N, if N is 1, then go to the base step of the induction, the simple case.

729
00:40:00,944 --> 00:40:04,112
We have a loop which says branch if equal 1 fetch N, if N is 1, then go to the base step of the induction, the simple case.

730
00:40:06,064 --> 00:40:07,200
We have a loop which says branch if equal 1 fetch N, if N is 1, then go to the base step of the induction, the simple case.

731
00:40:08,050 --> 00:40:08,768
Otherwise, I have to remember the things that are necessary to perform a sub-factorial.

732
00:40:08,880 --> 00:40:13,840
Otherwise, I have to remember the things that are necessary to perform a sub-factorial.

733
00:40:14,640 --> 00:40:15,184
I'm going to go over here, and I have to perform a sub-factorial.

734
00:40:15,200 --> 00:40:16,830
I'm going to go over here, and I have to perform a sub-factorial.

735
00:40:17,570 --> 00:40:19,296
So I have to remember what's needed after I will be done with that.

736
00:40:19,712 --> 00:40:22,528
So I have to remember what's needed after I will be done with that.

737
00:40:24,000 --> 00:40:25,510
See, I'm about to do something terrible.

738
00:40:25,728 --> 00:40:27,392
I'm about to change the value of N. But this guy has to know the old value of N. But in order to make the sub-factorial work, I have to change the value of N. So I have to remember the old value.

739
00:40:28,576 --> 00:40:30,400
I'm about to change the value of N. But this guy has to know the old value of N. But in order to make the sub-factorial work, I have to change the value of N. So I have to remember the old value.

740
00:40:32,144 --> 00:40:34,928
I'm about to change the value of N. But this guy has to know the old value of N. But in order to make the sub-factorial work, I have to change the value of N. So I have to remember the old value.

741
00:40:35,600 --> 00:40:37,104
I'm about to change the value of N. But this guy has to know the old value of N. But in order to make the sub-factorial work, I have to change the value of N. So I have to remember the old value.

742
00:40:38,000 --> 00:40:39,600
And I also have to remember where I've been.

743
00:40:40,850 --> 00:40:42,320
So I save up continue.

744
00:40:47,700 --> 00:40:51,296
And this is an instruction that says, put something in the stack.

745
00:40:53,120 --> 00:40:55,536
Save the contents of the continuation register, which in this case is done, because later I'm going to change that, too, because I need to go back to after-fact, as well.

746
00:40:56,512 --> 00:40:58,000
Save the contents of the continuation register, which in this case is done, because later I'm going to change that, too, because I need to go back to after-fact, as well.

747
00:40:58,880 --> 00:41:02,784
Save the contents of the continuation register, which in this case is done, because later I'm going to change that, too, because I need to go back to after-fact, as well.

748
00:41:03,550 --> 00:41:04,192
We'll see that.

749
00:41:05,040 --> 00:41:09,712
We save N, because I'm going to need that for later.

750
00:41:10,380 --> 00:41:20,544
Assign to N the decrement of fetch N. Assign continue, we're going to look at this now, to after, we'll call it.

751
00:41:23,264 --> 00:41:28,976
Assign to N the decrement of fetch N. Assign continue, we're going to look at this now, to after, we'll call it.

752
00:41:32,128 --> 00:41:33,424
Assign to N the decrement of fetch N. Assign continue, we're going to look at this now, to after, we'll call it.

753
00:41:34,064 --> 00:41:35,616
Assign to N the decrement of fetch N. Assign continue, we're going to look at this now, to after, we'll call it.

754
00:41:37,690 --> 00:41:38,704
That's a good name for this, a little bit easier and shorter, and fits in here.

755
00:41:38,736 --> 00:41:40,656
That's a good name for this, a little bit easier and shorter, and fits in here.

756
00:41:53,360 --> 00:41:54,640
Now look what I'm doing here.

757
00:41:55,330 --> 00:41:57,020
I'm saying, if the answer is 1, I'm done.

758
00:41:58,720 --> 00:41:59,664
I'm saying, if the answer is 1, I'm done.

759
00:42:00,464 --> 00:42:01,664
I'm going to have to just get the answer.

760
00:42:02,150 --> 00:42:04,880
Otherwise, I'm going to save the continuation, save N, make N one less than N, remember I'm going to come back to someplace else, and go back and start doing another factorial.

761
00:42:05,776 --> 00:42:07,328
Otherwise, I'm going to save the continuation, save N, make N one less than N, remember I'm going to come back to someplace else, and go back and start doing another factorial.

762
00:42:07,600 --> 00:42:09,632
Otherwise, I'm going to save the continuation, save N, make N one less than N, remember I'm going to come back to someplace else, and go back and start doing another factorial.

763
00:42:09,648 --> 00:42:11,488
Otherwise, I'm going to save the continuation, save N, make N one less than N, remember I'm going to come back to someplace else, and go back and start doing another factorial.

764
00:42:13,504 --> 00:42:15,744
However, I've got a different machine [? in me ?] now.

765
00:42:16,050 --> 00:42:18,380
N is 1, and continue is something else.

766
00:42:22,112 --> 00:42:23,216
N is N minus 1.

767
00:42:23,770 --> 00:42:25,280
Now after I'm done with that, I can go there.

768
00:42:26,944 --> 00:42:27,760
Now after I'm done with that, I can go there.

769
00:42:28,660 --> 00:42:30,464
I will restore the old value of N, which is the opposite of this save over here.

770
00:42:32,688 --> 00:42:36,560
I will restore the old value of N, which is the opposite of this save over here.

771
00:42:38,360 --> 00:42:39,888
I will restore the continuation.

772
00:42:49,660 --> 00:42:52,576
I will then go to here.

773
00:42:54,320 --> 00:43:00,864
I will assign to the VAL register the product of N and fetch VAL.

774
00:43:01,168 --> 00:43:08,130
I will assign to the VAL register the product of N and fetch VAL.

775
00:43:13,440 --> 00:43:18,304
VAL fetch product assign.

776
00:43:19,790 --> 00:43:21,440
And then I will be done.

777
00:43:21,440 --> 00:43:25,680
I will have my answer to the sub-factorial in VAL.

778
00:43:26,570 --> 00:43:27,376
At that point, I'm going to return by going to the place where the continuation is pointing.

779
00:43:27,664 --> 00:43:31,616
At that point, I'm going to return by going to the place where the continuation is pointing.

780
00:43:33,640 --> 00:43:35,776
That says, go to fetch continue.

781
00:43:45,870 --> 00:43:47,408
And then I have finally a base step, which is the immediate answer.

782
00:43:49,312 --> 00:43:50,512
And then I have finally a base step, which is the immediate answer.

783
00:43:50,680 --> 00:43:56,880
Assign to VAL fetch N, and go to fetch continue.

784
00:44:01,360 --> 00:44:02,752
Assign to VAL fetch N, and go to fetch continue.

785
00:44:12,670 --> 00:44:13,552
And then I'm done.

786
00:44:18,640 --> 00:44:21,216
Now let's see how this executes on a very simple case, because then we'll see the use of this stack to do the job we need.

787
00:44:22,512 --> 00:44:23,536
Now let's see how this executes on a very simple case, because then we'll see the use of this stack to do the job we need.

788
00:44:23,664 --> 00:44:26,528
Now let's see how this executes on a very simple case, because then we'll see the use of this stack to do the job we need.

789
00:44:26,890 --> 00:44:29,808
This is statically what it's doing, but we have look dynamically at this.

790
00:44:31,340 --> 00:44:32,096
So let's see.

791
00:44:32,300 --> 00:44:34,560
First thing we do is continue gets done.

792
00:44:36,730 --> 00:44:38,096
The way that happened is I pushed this.

793
00:44:38,300 --> 00:44:39,600
Let's call that done the way I have it.

794
00:44:46,336 --> 00:44:47,030
I push that button.

795
00:44:47,030 --> 00:44:48,112
Done goes into there.

796
00:44:48,950 --> 00:44:53,712
Now I also have to set this thing up to have an initial value.

797
00:44:53,850 --> 00:44:58,080
Let's consider a factorial of three, a simple case.

798
00:44:58,384 --> 00:44:59,248
Let's consider a factorial of three, a simple case.

799
00:45:00,544 --> 00:45:04,048
And we're going to start out with our stack growing over here.

800
00:45:05,900 --> 00:45:07,760
Stacks have their own little internal state saying where they are, where the next place I'm going to write is.

801
00:45:07,792 --> 00:45:09,056
Stacks have their own little internal state saying where they are, where the next place I'm going to write is.

802
00:45:09,808 --> 00:45:11,648
Stacks have their own little internal state saying where they are, where the next place I'm going to write is.

803
00:45:12,770 --> 00:45:14,590
So now we say, is N 1?

804
00:45:14,768 --> 00:45:15,712
The answer is no.

805
00:45:16,110 --> 00:45:18,560
So now I'm going to save continue, bang.

806
00:45:19,152 --> 00:45:20,656
Now that done goes in here.

807
00:45:22,080 --> 00:45:23,552
And this moves to here, the next place I'm going to write.

808
00:45:24,880 --> 00:45:26,144
And this moves to here, the next place I'm going to write.

809
00:45:26,660 --> 00:45:28,784
Save N 3.

810
00:45:29,950 --> 00:45:30,320
OK?

811
00:45:30,672 --> 00:45:33,616
Assign to N the decrement of N. That means I've pushed this button.

812
00:45:33,968 --> 00:45:35,376
Assign to N the decrement of N. That means I've pushed this button.

813
00:45:35,940 --> 00:45:37,320
This becomes 2.

814
00:45:38,736 --> 00:45:42,288
Assign to continue aft.

815
00:45:42,580 --> 00:45:43,610
So I've pushed that button.

816
00:45:43,610 --> 00:45:44,544
Aft goes in here.

817
00:45:49,140 --> 00:45:53,936
OK, now go to loop, bang, so up to here.

818
00:45:54,830 --> 00:45:56,570
Is N 1?

819
00:45:56,570 --> 00:45:57,040
No.

820
00:45:57,780 --> 00:45:59,232
So I have to save continue.

821
00:45:59,490 --> 00:46:00,272
What's continue?

822
00:46:00,600 --> 00:46:01,530
Continue is aft.

823
00:46:01,530 --> 00:46:02,320
Push this button.

824
00:46:02,780 --> 00:46:03,952
So this moves to here.

825
00:46:08,490 --> 00:46:09,744
I have to save N. N is over here.

826
00:46:10,512 --> 00:46:11,460
I have to save N. N is over here.

827
00:46:11,460 --> 00:46:12,144
I got to 2.

828
00:46:12,280 --> 00:46:13,376
Push that button.

829
00:46:13,856 --> 00:46:15,248
So a 2 gets written there.

830
00:46:16,050 --> 00:46:17,648
And then this thing moves down here.

831
00:46:20,060 --> 00:46:22,608
OK, save N. Assign N to the decrement of N.

832
00:46:24,608 --> 00:46:25,460
This becomes a 1.

833
00:46:29,240 --> 00:46:30,544
Assign continue to aft.

834
00:46:31,370 --> 00:46:34,480
A-F-T gets written there again.

835
00:46:34,960 --> 00:46:35,648
Go to loop.

836
00:46:36,520 --> 00:46:37,744
Is N equal to 1?

837
00:46:37,930 --> 00:46:39,520
Oh, yes, the answer is 1.

838
00:46:41,040 --> 00:46:43,264
OK, go to base step.

839
00:46:44,160 --> 00:46:45,776
Assign to VAL fetch of N. Bang, 1 gets put in there.

840
00:46:46,560 --> 00:46:50,720
Assign to VAL fetch of N. Bang, 1 gets put in there.

841
00:46:51,100 --> 00:46:52,200
Go to fetch continue.

842
00:46:52,200 --> 00:46:53,536
So we look in continue.

843
00:46:53,680 --> 00:46:56,064
Basically, I'm pushing a button over here that goes to the controller.

844
00:46:56,670 --> 00:46:58,288
The continue becomes aft, and all of a sudden, the program's running here.

845
00:46:58,320 --> 00:47:00,256
The continue becomes aft, and all of a sudden, the program's running here.

846
00:47:02,640 --> 00:47:05,632
I now have to restore the outer version of factorial.

847
00:47:06,650 --> 00:47:07,550
So we go here.

848
00:47:07,550 --> 00:47:09,488
We say, restore N. So restore N means take the contents that's here.

849
00:47:10,320 --> 00:47:13,040
We say, restore N. So restore N means take the contents that's here.

850
00:47:13,940 --> 00:47:18,176
Push this button, and it goes into here, 2, and the pointer moves up.

851
00:47:18,560 --> 00:47:20,048
Push this button, and it goes into here, 2, and the pointer moves up.

852
00:47:21,136 --> 00:47:24,496
Restore continue, pretty easy.

853
00:47:24,810 --> 00:47:26,496
Go push this button.

854
00:47:27,020 --> 00:47:28,928
And then aft gets written in here again.

855
00:47:31,280 --> 00:47:32,640
That means this thing moves up.

856
00:47:32,640 --> 00:47:35,190
I've gotten rid of something else on my stack.

857
00:47:42,240 --> 00:47:43,472
Right, then I go to here, which says, assign to VAL the product of N an VAL.

858
00:47:43,872 --> 00:47:47,152
Right, then I go to here, which says, assign to VAL the product of N an VAL.

859
00:47:47,850 --> 00:47:50,576
So I push this button over here, bang.

860
00:47:50,970 --> 00:47:52,912
2 times 1 gives me a 2, get written there.

861
00:47:54,016 --> 00:47:54,752
2 times 1 gives me a 2, get written there.

862
00:47:55,760 --> 00:47:57,200
OK? Go to fetch continue.

863
00:47:57,540 --> 00:47:59,856
Continue is aft. I go to aft.

864
00:48:01,150 --> 00:48:03,888
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

865
00:48:04,368 --> 00:48:05,728
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

866
00:48:05,872 --> 00:48:08,448
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

867
00:48:09,248 --> 00:48:10,336
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

868
00:48:10,600 --> 00:48:11,770
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

869
00:48:15,040 --> 00:48:17,296
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

870
00:48:18,016 --> 00:48:19,904
The next thing I do is restore continue.

871
00:48:20,200 --> 00:48:22,208
Continue is now going to become done.

872
00:48:22,830 --> 00:48:26,784
So this moves up here when I push this button.

873
00:48:27,130 --> 00:48:31,552
Done may or may be there anymore, I'm not interested, but it certainly is here.

874
00:48:35,800 --> 00:48:38,120
Next thing I do is assign to VAL the product of the fetch of N and the fetch of VAL.

875
00:48:38,432 --> 00:48:40,768
Next thing I do is assign to VAL the product of the fetch of N and the fetch of VAL.

876
00:48:41,440 --> 00:48:44,300
That's pushing this button over here, bang.

877
00:48:44,300 --> 00:48:45,776
2 times 3 is 6.

878
00:48:46,520 --> 00:48:47,870
So I get a 6 over here.

879
00:48:50,976 --> 00:48:53,408
And go to fetch continue, whoops, I go to done, and I'm done.

880
00:48:53,488 --> 00:48:54,832
And go to fetch continue, whoops, I go to done, and I'm done.

881
00:48:55,020 --> 00:48:56,096
And my answer is 6, as you can see in the VAL register.

882
00:48:56,608 --> 00:48:57,824
And my answer is 6, as you can see in the VAL register.

883
00:48:58,950 --> 00:48:59,824
And in fact, the stack is in the state it originally was in.

884
00:49:00,912 --> 00:49:03,344
And in fact, the stack is in the state it originally was in.

885
00:49:08,208 --> 00:49:10,704
Now there's a bit of discipline in using these things like stacks that we have to be careful of.

886
00:49:11,200 --> 00:49:12,272
Now there's a bit of discipline in using these things like stacks that we have to be careful of.

887
00:49:13,620 --> 00:49:15,520
And we'll see that in the next segment.

888
00:49:16,260 --> 00:49:18,464
But first I want to ask if there are any questions for this.

889
00:49:28,560 --> 00:49:29,648
Are there any questions?

890
00:49:30,170 --> 00:49:30,630
Yes, Ron.

891
00:49:30,630 --> 00:49:33,376
AUDIENCE: What happens when you roll off the end of the stack with-- PROFESSOR: What do you mean, roll off of?

892
00:49:33,392 --> 00:49:34,624
AUDIENCE: What happens when you roll off the end of the stack with-- PROFESSOR: What do you mean, roll off of?

893
00:49:35,030 --> 00:49:37,504
AUDIENCE: Well, the largest number-- a larger starting point of N requires more memory, correct?

894
00:49:37,520 --> 00:49:38,720
AUDIENCE: Well, the largest number-- a larger starting point of N requires more memory, correct?

895
00:49:38,860 --> 00:49:39,440
PROFESSOR: Oh, yes.

896
00:49:39,440 --> 00:49:41,120
Well, I need to have a long enough stack.

897
00:49:41,530 --> 00:49:43,200
You say, what if I violate my illusion?

898
00:49:43,840 --> 00:49:44,128
AUDIENCE: Yes.

899
00:49:44,550 --> 00:49:46,736
PROFESSOR: Well, then the magic doesn't work.

900
00:49:47,968 --> 00:49:51,008
The truth of the matter is that every machine is finite.

901
00:49:51,640 --> 00:49:53,728
And for a procedure like this, there's a limit to the number of sub-factorials I could have.

902
00:49:54,176 --> 00:49:58,864
And for a procedure like this, there's a limit to the number of sub-factorials I could have.

903
00:49:59,950 --> 00:50:02,480
Remember when we were doing the y-operator a while ago, we pointed out that there was a sequence of exponentiation procedures, each of which was a little better than the previous one.

904
00:50:02,800 --> 00:50:06,224
Remember when we were doing the y-operator a while ago, we pointed out that there was a sequence of exponentiation procedures, each of which was a little better than the previous one.

905
00:50:06,256 --> 00:50:08,096
Remember when we were doing the y-operator a while ago, we pointed out that there was a sequence of exponentiation procedures, each of which was a little better than the previous one.

906
00:50:08,720 --> 00:50:11,600
Well, we're now seeing how we implement that mathematical idea.

907
00:50:13,090 --> 00:50:14,192
The limiting process is only so good as as far as you take the limit.

908
00:50:14,352 --> 00:50:16,336
The limiting process is only so good as as far as you take the limit.

909
00:50:17,990 --> 00:50:19,420
If you think about it, what am I using here?

910
00:50:19,420 --> 00:50:22,656
I'm using about two pieces of memory for every recursion of this process.

911
00:50:23,040 --> 00:50:27,072
I'm using about two pieces of memory for every recursion of this process.

912
00:50:29,100 --> 00:50:31,712
If we try to compute factorial of 10,000, that's not a lot of memory.

913
00:50:31,728 --> 00:50:32,816
If we try to compute factorial of 10,000, that's not a lot of memory.

914
00:50:33,180 --> 00:50:34,688
On the other hand, it's an awful big number.

915
00:50:35,952 --> 00:50:38,416
So the question is, is that a valuable thing in this case.

916
00:50:39,180 --> 00:50:42,192
But it really turns out not to be a terrible limit, because memory is el cheapo, and people are pretty expensive.

917
00:50:42,224 --> 00:50:43,536
But it really turns out not to be a terrible limit, because memory is el cheapo, and people are pretty expensive.

918
00:50:44,160 --> 00:50:45,344
But it really turns out not to be a terrible limit, because memory is el cheapo, and people are pretty expensive.

919
00:50:48,130 --> 00:50:50,224
OK, thank you, let's take a break.

920
00:50:51,050 --> 00:50:52,660
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

921
00:51:56,112 --> 00:51:57,040
PROFESSOR: Well, let's see.

922
00:51:58,704 --> 00:52:03,376
What I've shown you now is how to do a simple iterative process and a simple recursive process.

923
00:52:03,696 --> 00:52:05,312
What I've shown you now is how to do a simple iterative process and a simple recursive process.

924
00:52:05,640 --> 00:52:08,688
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

925
00:52:09,632 --> 00:52:11,120
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

926
00:52:11,216 --> 00:52:13,584
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

927
00:52:13,968 --> 00:52:17,136
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

928
00:52:17,232 --> 00:52:19,888
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

929
00:52:20,048 --> 00:52:22,688
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

930
00:52:22,768 --> 00:52:25,040
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

931
00:52:26,400 --> 00:52:27,110
So let's see.

932
00:52:27,110 --> 00:52:28,272
I'm just going to write down, first of all, the program I'm going to translate.

933
00:52:28,304 --> 00:52:29,712
I'm just going to write down, first of all, the program I'm going to translate.

934
00:52:34,150 --> 00:52:36,528
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

935
00:52:39,232 --> 00:52:41,584
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

936
00:52:44,576 --> 00:52:46,464
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

937
00:52:47,312 --> 00:52:48,560
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

938
00:52:49,264 --> 00:52:55,344
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

939
00:52:58,448 --> 00:52:59,856
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

940
00:53:07,056 --> 00:53:09,290
That's the plan I have here.

941
00:53:09,290 --> 00:53:12,560
And we're just going to write down the controller for such a machine.

942
00:53:13,070 --> 00:53:19,152
We're going to assume that there are registers, N, which holds the number we're taking Fibonacci of, VAL, which is where the answer is going to get put, and continue, which is the thing that's linked to the controller, like before.

943
00:53:19,824 --> 00:53:21,808
We're going to assume that there are registers, N, which holds the number we're taking Fibonacci of, VAL, which is where the answer is going to get put, and continue, which is the thing that's linked to the controller, like before.

944
00:53:22,176 --> 00:53:24,976
We're going to assume that there are registers, N, which holds the number we're taking Fibonacci of, VAL, which is where the answer is going to get put, and continue, which is the thing that's linked to the controller, like before.

945
00:53:26,112 --> 00:53:26,810
We're going to assume that there are registers, N, which holds the number we're taking Fibonacci of, VAL, which is where the answer is going to get put, and continue, which is the thing that's linked to the controller, like before.

946
00:53:26,960 --> 00:53:29,216
But I'm not going to draw another physical datapath, because it's pretty much the same as the last one you've seen.

947
00:53:31,536 --> 00:53:34,000
But I'm not going to draw another physical datapath, because it's pretty much the same as the last one you've seen.

948
00:53:34,360 --> 00:53:37,840
And of course, one of the most amazing things about computation is that after a while, you build up a little more features and a few more features, and all of the sudden, you've got everything you need.

949
00:53:38,752 --> 00:53:39,888
And of course, one of the most amazing things about computation is that after a while, you build up a little more features and a few more features, and all of the sudden, you've got everything you need.

950
00:53:40,080 --> 00:53:41,936
And of course, one of the most amazing things about computation is that after a while, you build up a little more features and a few more features, and all of the sudden, you've got everything you need.

951
00:53:41,952 --> 00:53:43,328
And of course, one of the most amazing things about computation is that after a while, you build up a little more features and a few more features, and all of the sudden, you've got everything you need.

952
00:53:44,752 --> 00:53:47,600
So it's remarkable that it just gets there so fast. I don't need much more to make a universal computer.

953
00:53:48,176 --> 00:53:50,848
So it's remarkable that it just gets there so fast. I don't need much more to make a universal computer.

954
00:53:51,810 --> 00:53:54,688
But in any case, let's look at the controller for the Fibonacci thing.

955
00:53:55,060 --> 00:53:57,072
First thing I want to do is start the thing up by assign to continue a place called done, called Fib-done here.

956
00:53:57,328 --> 00:54:02,528
First thing I want to do is start the thing up by assign to continue a place called done, called Fib-done here.

957
00:54:07,136 --> 00:54:10,288
First thing I want to do is start the thing up by assign to continue a place called done, called Fib-done here.

958
00:54:14,144 --> 00:54:15,536
So that means that somewhere over here, I'm going to have a label, Fib-done, which is the place where I go when I want the machine to stop.

959
00:54:15,552 --> 00:54:18,480
So that means that somewhere over here, I'm going to have a label, Fib-done, which is the place where I go when I want the machine to stop.

960
00:54:19,712 --> 00:54:21,104
So that means that somewhere over here, I'm going to have a label, Fib-done, which is the place where I go when I want the machine to stop.

961
00:54:21,232 --> 00:54:22,448
So that means that somewhere over here, I'm going to have a label, Fib-done, which is the place where I go when I want the machine to stop.

962
00:54:24,000 --> 00:54:24,864
That's what that is.

963
00:54:25,920 --> 00:54:26,896
And I'm going to make up a loop.

964
00:54:31,110 --> 00:54:34,256
It's a place I'm going to go to in order to start up computing a Fib.

965
00:54:35,470 --> 00:54:36,864
Whatever is in N at this point, Fibonacci will be computed of, and we will return to the place specified by continue.

966
00:54:37,392 --> 00:54:38,992
Whatever is in N at this point, Fibonacci will be computed of, and we will return to the place specified by continue.

967
00:54:39,136 --> 00:54:42,016
Whatever is in N at this point, Fibonacci will be computed of, and we will return to the place specified by continue.

968
00:54:44,800 --> 00:54:48,400
So what you're going to see here at this place, what I want here is the contract that says, I'm going to write this with a comment syntax, the contract is N contains arg, the argument.

969
00:54:48,448 --> 00:54:50,480
So what you're going to see here at this place, what I want here is the contract that says, I'm going to write this with a comment syntax, the contract is N contains arg, the argument.

970
00:54:50,970 --> 00:54:54,256
So what you're going to see here at this place, what I want here is the contract that says, I'm going to write this with a comment syntax, the contract is N contains arg, the argument.

971
00:54:54,576 --> 00:55:00,992
So what you're going to see here at this place, what I want here is the contract that says, I'm going to write this with a comment syntax, the contract is N contains arg, the argument.

972
00:55:02,100 --> 00:55:09,824
Continue is the recipient.

973
00:55:13,360 --> 00:55:14,290
And that's where it is.

974
00:55:15,710 --> 00:55:18,960
At this point, if I ever go to this place, I'm expecting this to be true, the argument for computing the Fibonacci.

975
00:55:19,248 --> 00:55:21,040
At this point, if I ever go to this place, I'm expecting this to be true, the argument for computing the Fibonacci.

976
00:55:21,520 --> 00:55:23,328
At this point, if I ever go to this place, I'm expecting this to be true, the argument for computing the Fibonacci.

977
00:55:24,820 --> 00:55:26,832
Now the next thing I want to do is to branch.

978
00:55:30,220 --> 00:55:32,224
And if N is less than 2--  by the way, I'm using what looks like Lisp syntax.

979
00:55:35,072 --> 00:55:37,440
And if N is less than 2--  by the way, I'm using what looks like Lisp syntax.

980
00:55:38,730 --> 00:55:39,632
This is not Lisp.

981
00:55:41,310 --> 00:55:42,384
This does not run.

982
00:55:42,750 --> 00:55:45,472
What I'm writing here does not run as a simple Lisp program.

983
00:55:46,120 --> 00:55:49,312
This is a representation of another language.

984
00:55:49,710 --> 00:55:52,256
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

985
00:55:52,400 --> 00:55:54,704
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

986
00:55:55,328 --> 00:55:57,344
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

987
00:55:57,824 --> 00:55:59,184
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

988
00:55:59,296 --> 00:56:00,912
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

989
00:56:03,380 --> 00:56:06,240
I don't want to confuse this to think that this is Lisp code.

990
00:56:06,940 --> 00:56:08,608
It's just I'm using a lot of the pieces of Lisp.

991
00:56:09,510 --> 00:56:10,848
I'm embedding a language in Lisp, using Lisp as pieces to make my process of making my simulator easy.

992
00:56:11,024 --> 00:56:12,448
I'm embedding a language in Lisp, using Lisp as pieces to make my process of making my simulator easy.

993
00:56:12,720 --> 00:56:15,120
I'm embedding a language in Lisp, using Lisp as pieces to make my process of making my simulator easy.

994
00:56:16,620 --> 00:56:18,560
So I'm inheriting from Lisp all of its properties.

995
00:56:19,100 --> 00:56:21,530
Fetch of N 2, I want to go to a place called immediate answer.

996
00:56:21,776 --> 00:56:23,728
Fetch of N 2, I want to go to a place called immediate answer.

997
00:56:26,208 --> 00:56:27,296
It's the base step.

998
00:56:33,150 --> 00:56:34,352
Now, that's somewhere over here, just above done.

999
00:56:35,920 --> 00:56:36,896
Now, that's somewhere over here, just above done.

1000
00:56:37,750 --> 00:56:38,640
And we'll see it later.

1001
00:56:39,424 --> 00:56:40,704
Now, in the general case, which is the part I'm going to write down now, let's just do it.

1002
00:56:40,720 --> 00:56:42,448
Now, in the general case, which is the part I'm going to write down now, let's just do it.

1003
00:56:43,136 --> 00:56:44,192
Now, in the general case, which is the part I'm going to write down now, let's just do it.

1004
00:56:44,860 --> 00:56:45,728
Well, first of all, I'm going to have to call Fibonacci twice.

1005
00:56:45,744 --> 00:56:48,208
Well, first of all, I'm going to have to call Fibonacci twice.

1006
00:56:49,420 --> 00:56:52,544
In each case-- well, in one case at least, I'm going to have to know what to do to come back and do the next one.

1007
00:56:52,784 --> 00:56:55,360
In each case-- well, in one case at least, I'm going to have to know what to do to come back and do the next one.

1008
00:56:56,310 --> 00:56:58,368
I have to remember, have I done the first Fib, or have I done the second one?

1009
00:56:59,200 --> 00:57:01,232
I have to remember, have I done the first Fib, or have I done the second one?

1010
00:57:01,264 --> 00:57:02,544
I have to remember, have I done the first Fib, or have I done the second one?

1011
00:57:04,500 --> 00:57:07,040
Do I have to come back to the place where I do the second Fib, or do I have to come back to the place where I do the add?

1012
00:57:07,072 --> 00:57:09,088
Do I have to come back to the place where I do the second Fib, or do I have to come back to the place where I do the add?

1013
00:57:10,128 --> 00:57:12,112
In the first case, over the first Fibonacci, I'm going to need the value of N for computing for the second one.

1014
00:57:12,140 --> 00:57:14,464
In the first case, over the first Fibonacci, I'm going to need the value of N for computing for the second one.

1015
00:57:14,512 --> 00:57:16,980
In the first case, over the first Fibonacci, I'm going to need the value of N for computing for the second one.

1016
00:57:19,840 --> 00:57:21,584
So I have to store some of these things up.

1017
00:57:23,360 --> 00:57:24,896
So first I'm going to save continue.

1018
00:57:26,192 --> 00:57:27,328
That's who needs the answer.

1019
00:57:31,320 --> 00:57:32,464
And the reason I'm doing that is because I'm about to assign continue to the place which is the place I want to go to after.

1020
00:57:32,480 --> 00:57:34,208
And the reason I'm doing that is because I'm about to assign continue to the place which is the place I want to go to after.

1021
00:57:40,112 --> 00:57:44,320
And the reason I'm doing that is because I'm about to assign continue to the place which is the place I want to go to after.

1022
00:57:46,832 --> 00:57:50,272
Let's call it Fib-N-minus-1, big long name, classic Lisp name.

1023
00:57:51,040 --> 00:57:53,760
Let's call it Fib-N-minus-1, big long name, classic Lisp name.

1024
00:57:57,360 --> 00:58:00,224
Because I'm going to compute the first Fib of N minus 1, and then after that, I want to come back and do something else.

1025
00:58:00,848 --> 00:58:03,296
Because I'm going to compute the first Fib of N minus 1, and then after that, I want to come back and do something else.

1026
00:58:03,960 --> 00:58:06,528
That's the place I want to go to after I've done the first Fibonacci calculation.

1027
00:58:07,552 --> 00:58:09,488
That's the place I want to go to after I've done the first Fibonacci calculation.

1028
00:58:11,520 --> 00:58:13,136
And I want to do a save of N, because I'm going to need it later, after that.

1029
00:58:14,416 --> 00:58:17,264
And I want to do a save of N, because I'm going to need it later, after that.

1030
00:58:19,130 --> 00:58:20,544
Now I'm going to, at this point, get ready to do the Fibonacci of N minus 1.

1031
00:58:20,672 --> 00:58:22,848
Now I'm going to, at this point, get ready to do the Fibonacci of N minus 1.

1032
00:58:23,024 --> 00:58:33,950
So assign to N the difference of the fetch of N and 1.

1033
00:58:38,110 --> 00:58:40,270
Now I'm ready to go back to doing the Fib loop.

1034
00:58:47,184 --> 00:58:49,872
Have I satisfied my contract?

1035
00:58:50,400 --> 00:58:51,504
And the answer is yes.

1036
00:58:51,770 --> 00:58:55,120
N contains N minus 1, which is what I need.

1037
00:58:56,432 --> 00:59:00,096
Continue contains a place I want to go to when I'm done with calculating N minus 1.

1038
00:59:01,280 --> 00:59:03,072
Continue contains a place I want to go to when I'm done with calculating N minus 1.

1039
00:59:04,100 --> 00:59:05,440
So I've satisfied the contract.

1040
00:59:05,440 --> 00:59:09,024
And therefore, I can write down here a label, after-Fib-N-minus-1.

1041
00:59:11,472 --> 00:59:17,568
And therefore, I can write down here a label, after-Fib-N-minus-1.

1042
00:59:20,490 --> 00:59:21,632
Now what am I going to do here?

1043
00:59:22,690 --> 00:59:24,352
Here's a place where I now have to get ready to do Fib of N minus 2.

1044
00:59:24,448 --> 00:59:26,752
Here's a place where I now have to get ready to do Fib of N minus 2.

1045
00:59:29,270 --> 00:59:30,800
But in order to do a Fib of N minus 2, look, I don't know.

1046
00:59:30,832 --> 00:59:31,632
But in order to do a Fib of N minus 2, look, I don't know.

1047
00:59:31,780 --> 00:59:33,408
I've clobbered my N over here.

1048
00:59:33,810 --> 00:59:37,136
And presumably my N is counted down all the way to 1 or 0 or something at this point.

1049
00:59:37,856 --> 00:59:38,800
And presumably my N is counted down all the way to 1 or 0 or something at this point.

1050
00:59:39,780 --> 00:59:42,512
So I don't know what the value of N in the N register is.

1051
00:59:43,030 --> 00:59:44,752
I want the value of N that was on the stack that I saved over here so that could restore it over here.

1052
00:59:44,800 --> 00:59:46,000
I want the value of N that was on the stack that I saved over here so that could restore it over here.

1053
00:59:46,176 --> 00:59:47,888
I want the value of N that was on the stack that I saved over here so that could restore it over here.

1054
00:59:49,520 --> 00:59:51,024
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1055
00:59:51,152 --> 00:59:52,528
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1056
00:59:53,648 --> 00:59:54,496
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1057
00:59:54,896 --> 00:59:57,376
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1058
00:59:57,530 --> 00:59:59,640
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1059
00:59:59,680 --> 01:00:00,864
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1060
01:00:01,810 --> 01:00:02,752
So let's restore that.

1061
01:00:08,830 --> 01:00:09,776
Restore of N.

1062
01:00:11,130 --> 01:00:15,984
Now I'm about to do something which is superstitious, and we will remove it shortly.

1063
01:00:16,000 --> 01:00:17,408
Now I'm about to do something which is superstitious, and we will remove it shortly.

1064
01:00:18,520 --> 01:00:20,480
I am about to finish the sequence of doing the subroutine call, if you will.

1065
01:00:20,592 --> 01:00:23,440
I am about to finish the sequence of doing the subroutine call, if you will.

1066
01:00:24,800 --> 01:00:25,952
I'm going to say, well, I also saved up the continuation, since I'm going to restore it now.

1067
01:00:26,064 --> 01:00:27,904
I'm going to say, well, I also saved up the continuation, since I'm going to restore it now.

1068
01:00:28,480 --> 01:00:30,432
I'm going to say, well, I also saved up the continuation, since I'm going to restore it now.

1069
01:00:31,600 --> 01:00:32,448
But actually, I don't have to, because I'm not going to need it.

1070
01:00:32,480 --> 01:00:33,552
But actually, I don't have to, because I'm not going to need it.

1071
01:00:34,610 --> 01:00:35,728
We'll fix that in a second.

1072
01:00:36,260 --> 01:00:37,952
So we'll do a restore of continue, which is what I would in general need to do.

1073
01:00:46,048 --> 01:00:48,020
So we'll do a restore of continue, which is what I would in general need to do.

1074
01:00:48,020 --> 01:00:49,232
And we're just going to see what you would call in the compiler world a peephole optimization, which says, whoops, you didn't have to do that.

1075
01:00:49,312 --> 01:00:52,144
And we're just going to see what you would call in the compiler world a peephole optimization, which says, whoops, you didn't have to do that.

1076
01:00:52,272 --> 01:00:53,728
And we're just going to see what you would call in the compiler world a peephole optimization, which says, whoops, you didn't have to do that.

1077
01:00:55,420 --> 01:00:57,104
OK, so the next thing I see here is that I have to get ready now to do Fibonacci of N minus 2.

1078
01:00:58,464 --> 01:01:02,288
OK, so the next thing I see here is that I have to get ready now to do Fibonacci of N minus 2.

1079
01:01:02,770 --> 01:01:04,496
But I don't have to save N anymore.

1080
01:01:05,050 --> 01:01:06,720
The reason why I don't have to save N anymore is because I don't need N after I've done Fib of N minus 2, because the next thing I do is add.

1081
01:01:06,800 --> 01:01:09,344
The reason why I don't have to save N anymore is because I don't need N after I've done Fib of N minus 2, because the next thing I do is add.

1082
01:01:09,360 --> 01:01:10,720
The reason why I don't have to save N anymore is because I don't need N after I've done Fib of N minus 2, because the next thing I do is add.

1083
01:01:13,540 --> 01:01:15,856
So I'm just going to set up my N that way.

1084
01:01:16,608 --> 01:01:28,990
Assign N minus difference of fetch N and 2.

1085
01:01:31,850 --> 01:01:34,016
Now I have to finish the setup for calling Fibonacci of N minus 2.

1086
01:01:34,272 --> 01:01:36,730
Now I have to finish the setup for calling Fibonacci of N minus 2.

1087
01:01:36,950 --> 01:01:38,336
Well, I have to save up continue and assign continue, continue, to the place which is after Fib N 2, that place over here somewhere.

1088
01:01:44,224 --> 01:01:49,024
Well, I have to save up continue and assign continue, continue, to the place which is after Fib N 2, that place over here somewhere.

1089
01:01:52,304 --> 01:01:59,952
Well, I have to save up continue and assign continue, continue, to the place which is after Fib N 2, that place over here somewhere.

1090
01:02:02,576 --> 01:02:04,032
Well, I have to save up continue and assign continue, continue, to the place which is after Fib N 2, that place over here somewhere.

1091
01:02:05,320 --> 01:02:07,232
However, I've got to be very careful.

1092
01:02:08,650 --> 01:02:11,424
The old value, the value of Fib of N minus 1, I'm going to need later.

1093
01:02:12,064 --> 01:02:13,120
The old value, the value of Fib of N minus 1, I'm going to need later.

1094
01:02:15,300 --> 01:02:17,376
The value of Fibonacci of N minus 1, I'm going to need.

1095
01:02:17,616 --> 01:02:18,480
The value of Fibonacci of N minus 1, I'm going to need.

1096
01:02:18,784 --> 01:02:19,808
And I can't clobber it, because I'm going to have to add it to the value of Fib of N minus 2.

1097
01:02:21,072 --> 01:02:23,600
And I can't clobber it, because I'm going to have to add it to the value of Fib of N minus 2.

1098
01:02:24,150 --> 01:02:25,888
That's in the value register, so I'm going to save it.

1099
01:02:27,792 --> 01:02:32,608
So I have to save this right now, save up VAL.

1100
01:02:33,780 --> 01:02:39,540
And now I can go off to my subroutine, go to Fib loop.

1101
01:02:44,220 --> 01:02:46,576
Now before I go any further and finish this program, I just want to look at this segment so far and see, oh yes, there's a sequence of instructions here, if you will, that I can do something about.

1102
01:02:46,800 --> 01:02:51,056
Now before I go any further and finish this program, I just want to look at this segment so far and see, oh yes, there's a sequence of instructions here, if you will, that I can do something about.

1103
01:02:51,232 --> 01:02:56,000
Now before I go any further and finish this program, I just want to look at this segment so far and see, oh yes, there's a sequence of instructions here, if you will, that I can do something about.

1104
01:02:57,840 --> 01:02:59,088
Now before I go any further and finish this program, I just want to look at this segment so far and see, oh yes, there's a sequence of instructions here, if you will, that I can do something about.

1105
01:03:01,580 --> 01:03:03,200
Here I have a restore of continue, a save of continue, and then an assign of continue, with no other references to continue in between.

1106
01:03:04,256 --> 01:03:05,488
Here I have a restore of continue, a save of continue, and then an assign of continue, with no other references to continue in between.

1107
01:03:06,016 --> 01:03:07,408
Here I have a restore of continue, a save of continue, and then an assign of continue, with no other references to continue in between.

1108
01:03:08,704 --> 01:03:10,640
Here I have a restore of continue, a save of continue, and then an assign of continue, with no other references to continue in between.

1109
01:03:13,840 --> 01:03:15,488
The restore followed by the save leaves the stack unchanged.

1110
01:03:15,504 --> 01:03:16,670
The restore followed by the save leaves the stack unchanged.

1111
01:03:19,090 --> 01:03:21,728
The only difference is that I set the continue register to a value, which is the value that was on the stack.

1112
01:03:21,968 --> 01:03:23,280
The only difference is that I set the continue register to a value, which is the value that was on the stack.

1113
01:03:24,330 --> 01:03:25,792
Since I now clobber that value, as in it was never referenced, these instructions are unnecessary.

1114
01:03:26,448 --> 01:03:27,936
Since I now clobber that value, as in it was never referenced, these instructions are unnecessary.

1115
01:03:28,592 --> 01:03:30,096
Since I now clobber that value, as in it was never referenced, these instructions are unnecessary.

1116
01:03:31,760 --> 01:03:35,390
So we will remove these.

1117
01:03:38,880 --> 01:03:40,784
But I couldn't have seen that unless I had written them down.

1118
01:03:43,780 --> 01:03:44,720
Was that really true?

1119
01:03:45,776 --> 01:03:46,608
Well, I don't know.

1120
01:03:48,610 --> 01:03:52,912
OK, so we've now gone off to compute Fibonacci of N minus 2.

1121
01:03:53,660 --> 01:03:54,592
So after that, what are we going to do?

1122
01:04:02,960 --> 01:04:03,856
So after that, what are we going to do?

1123
01:04:05,070 --> 01:04:06,768
Well, I suppose the first thing we have to do-- we've got two things.

1124
01:04:06,992 --> 01:04:07,888
Well, I suppose the first thing we have to do-- we've got two things.

1125
01:04:07,960 --> 01:04:10,496
We've got a thing in the value register which is now valuable.

1126
01:04:10,920 --> 01:04:11,984
We also have a thing on the stack that can be restored into the value register.

1127
01:04:12,048 --> 01:04:13,632
We also have a thing on the stack that can be restored into the value register.

1128
01:04:14,810 --> 01:04:16,576
And what I have to be careful with now is I want to shuffle this right so I can do the multiply.

1129
01:04:16,880 --> 01:04:18,992
And what I have to be careful with now is I want to shuffle this right so I can do the multiply.

1130
01:04:19,470 --> 01:04:21,248
Now there are various conventions I might use, but I'm going to be very picky and say, I'm only going to restore into a register I've saved from.

1131
01:04:21,472 --> 01:04:23,520
Now there are various conventions I might use, but I'm going to be very picky and say, I'm only going to restore into a register I've saved from.

1132
01:04:23,552 --> 01:04:25,888
Now there are various conventions I might use, but I'm going to be very picky and say, I'm only going to restore into a register I've saved from.

1133
01:04:26,740 --> 01:04:28,288
If that's the case, I have to do a shuffle here.

1134
01:04:29,248 --> 01:04:31,840
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1135
01:04:32,688 --> 01:04:37,136
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1136
01:04:37,168 --> 01:04:39,376
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1137
01:04:39,920 --> 01:04:41,216
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1138
01:04:45,216 --> 01:04:47,340
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1139
01:04:52,950 --> 01:04:56,352
And I'm going to restore the value register now.

1140
01:05:01,850 --> 01:05:03,920
This restore matches this save. And if you're very careful and examine very carefully what goes on, restores and saves are always matched.

1141
01:05:05,584 --> 01:05:08,832
This restore matches this save. And if you're very careful and examine very carefully what goes on, restores and saves are always matched.

1142
01:05:09,216 --> 01:05:11,968
This restore matches this save. And if you're very careful and examine very carefully what goes on, restores and saves are always matched.

1143
01:05:13,840 --> 01:05:15,152
Now there's an outstanding save, of course, that we have to get rid of soon.
Now there's an outstanding save, of course, that we have to get rid of soon.

1144
01:05:15,152 --> 01:05:15,184
Now there's an outstanding save, of course, that we have to get rid of soon.

1145
01:05:15,184 --> 01:05:16,384
Now there's an outstanding save, of course, that we have to get rid of soon.
Now there's an outstanding save, of course, that we have to get rid of soon.

1146
01:05:16,384 --> 01:05:19,000
Now there's an outstanding save, of course, that we have to get rid of soon.

1147
01:05:19,000 --> 01:05:20,590
And so I restored the value register.

1148
01:05:20,944 --> 01:05:22,576
Now I restore the continue one, which matches this one, dot, dot, dot, dot, dot, dot, dot, down to here, restoring that continuation.

1149
01:05:31,152 --> 01:05:32,400
Now I restore the continue one, which matches this one, dot, dot, dot, dot, dot, dot, dot, down to here, restoring that continuation.

1150
01:05:34,800 --> 01:05:37,856
Now I restore the continue one, which matches this one, dot, dot, dot, dot, dot, dot, dot, down to here, restoring that continuation.

1151
01:05:40,592 --> 01:05:42,464
Now I restore the continue one, which matches this one, dot, dot, dot, dot, dot, dot, dot, down to here, restoring that continuation.

1152
01:05:42,860 --> 01:05:45,712
That continuation is a continuation of Fib of N, which is the problem I was trying to solve, a major problem I'm trying to solve.

1153
01:05:46,464 --> 01:05:49,328
That continuation is a continuation of Fib of N, which is the problem I was trying to solve, a major problem I'm trying to solve.

1154
01:05:49,984 --> 01:05:52,352
So that's the guy I have to go back to who wants Fib of N. I saved them all the way up here when I realized N was not less than 2.

1155
01:05:52,544 --> 01:05:54,032
So that's the guy I have to go back to who wants Fib of N. I saved them all the way up here when I realized N was not less than 2.

1156
01:05:54,160 --> 01:05:56,608
So that's the guy I have to go back to who wants Fib of N. I saved them all the way up here when I realized N was not less than 2.

1157
01:05:57,360 --> 01:05:59,072
And so I had to do a complicated operation.

1158
01:06:00,840 --> 01:06:02,576
Now I've got everything I need to do it.

1159
01:06:03,240 --> 01:06:04,368
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1160
01:06:05,440 --> 01:06:10,000
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1161
01:06:12,288 --> 01:06:18,224
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1162
01:06:19,552 --> 01:06:21,072
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1163
01:06:27,440 --> 01:06:28,608
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1164
01:06:38,260 --> 01:06:44,784
So now I've returned from computing Fibonacci of N, the general case.

1165
01:06:45,392 --> 01:06:46,576
So now I've returned from computing Fibonacci of N, the general case.

1166
01:06:47,110 --> 01:06:50,608
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1167
01:06:50,992 --> 01:06:55,536
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1168
01:07:02,576 --> 01:07:05,088
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1169
01:07:05,776 --> 01:07:07,488
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1170
01:07:08,544 --> 01:07:11,856
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1171
01:07:13,648 --> 01:07:16,896
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1172
01:07:16,990 --> 01:07:18,192
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1173
01:07:19,232 --> 01:07:36,130
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1174
01:07:43,460 --> 01:07:45,640
So that's a fairly complicated program.

1175
01:07:45,640 --> 01:07:47,344
And the reason I wanted you see to that is because I want you to see the particular flavors of stack discipline that I was obeying.

1176
01:07:47,504 --> 01:07:51,216
And the reason I wanted you see to that is because I want you to see the particular flavors of stack discipline that I was obeying.

1177
01:07:51,760 --> 01:07:52,656
And the reason I wanted you see to that is because I want you to see the particular flavors of stack discipline that I was obeying.

1178
01:07:53,328 --> 01:07:55,216
It was first of all, I don't want to take anything that I'm not going to need later.

1179
01:07:56,928 --> 01:07:58,128
It was first of all, I don't want to take anything that I'm not going to need later.

1180
01:08:00,576 --> 01:08:01,850
I was being very careful.

1181
01:08:01,850 --> 01:08:02,912
And it's very important.

1182
01:08:03,940 --> 01:08:06,528
And there are all sorts of other disciplines people make with frames and things like that of some sort, where you save all sorts of junk you're not going to need later and restore it because, in some sense, it's easier to do that.

1183
01:08:07,376 --> 01:08:09,616
And there are all sorts of other disciplines people make with frames and things like that of some sort, where you save all sorts of junk you're not going to need later and restore it because, in some sense, it's easier to do that.

1184
01:08:10,192 --> 01:08:12,624
And there are all sorts of other disciplines people make with frames and things like that of some sort, where you save all sorts of junk you're not going to need later and restore it because, in some sense, it's easier to do that.

1185
01:08:12,640 --> 01:08:15,264
And there are all sorts of other disciplines people make with frames and things like that of some sort, where you save all sorts of junk you're not going to need later and restore it because, in some sense, it's easier to do that.

1186
01:08:15,830 --> 01:08:17,408
That's going to lead to various disasters, which we'll see a little later.

1187
01:08:18,592 --> 01:08:20,256
That's going to lead to various disasters, which we'll see a little later.

1188
01:08:21,440 --> 01:08:24,240
It's crucial to save exactly what you're going to need later.

1189
01:08:26,890 --> 01:08:28,016
It's an important idea.

1190
01:08:29,850 --> 01:08:31,328
And the responsibility of that is whoever saves something is the guy who restores it, because he needs it.

1191
01:08:31,904 --> 01:08:33,360
And the responsibility of that is whoever saves something is the guy who restores it, because he needs it.

1192
01:08:33,760 --> 01:08:35,328
And the responsibility of that is whoever saves something is the guy who restores it, because he needs it.

1193
01:08:36,930 --> 01:08:38,544
And in such discipline, you can see what things are unnecessary, operations that are unimportant.

1194
01:08:38,864 --> 01:08:40,768
And in such discipline, you can see what things are unnecessary, operations that are unimportant.

1195
01:08:43,456 --> 01:08:44,736
And in such discipline, you can see what things are unnecessary, operations that are unimportant.

1196
01:08:47,150 --> 01:08:50,400
Now, one other thing I want to tell you about that's very simple is that, of course, the picture you see is not the whole picture.

1197
01:08:51,664 --> 01:08:54,672
Now, one other thing I want to tell you about that's very simple is that, of course, the picture you see is not the whole picture.

1198
01:08:55,350 --> 01:08:56,688
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1199
01:08:56,800 --> 01:09:01,520
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1200
01:09:03,536 --> 01:09:05,600
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1201
01:09:05,888 --> 01:09:07,328
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1202
01:09:08,304 --> 01:09:09,216
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1203
01:09:10,400 --> 01:09:13,600
Well, at this level of detail, whatever it is, we can conceptualize those as primitive operations in the datapath.

1204
01:09:13,872 --> 01:09:17,856
Well, at this level of detail, whatever it is, we can conceptualize those as primitive operations in the datapath.

1205
01:09:18,752 --> 01:09:21,952
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1206
01:09:22,320 --> 01:09:24,112
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1207
01:09:24,208 --> 01:09:26,464
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1208
01:09:26,640 --> 01:09:29,808
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1209
01:09:29,888 --> 01:09:33,184
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1210
01:09:33,630 --> 01:09:35,296
Well, it's got about the same structure.

1211
01:09:36,544 --> 01:09:37,270
And what do we have?

1212
01:09:37,270 --> 01:09:39,392
We have some sort of things in it which may be registers, x and y, and then x has to somehow move to y sometimes, x has to get the value of y.

1213
01:09:39,760 --> 01:09:42,480
We have some sort of things in it which may be registers, x and y, and then x has to somehow move to y sometimes, x has to get the value of y.

1214
01:09:42,512 --> 01:09:46,752
We have some sort of things in it which may be registers, x and y, and then x has to somehow move to y sometimes, x has to get the value of y.

1215
01:09:46,930 --> 01:09:48,416
And then we may have to be able to do something which is a cons.

1216
01:09:48,544 --> 01:09:50,128
And then we may have to be able to do something which is a cons.

1217
01:09:51,700 --> 01:09:57,936
I don't remember if I need to like this is in this system, but cons is sort of like subtract or add or something.

1218
01:09:57,952 --> 01:10:01,104
I don't remember if I need to like this is in this system, but cons is sort of like subtract or add or something.

1219
01:10:01,420 --> 01:10:02,704
It combines two things, producing a thing which is the cons, which we may then think goes into there.

1220
01:10:02,736 --> 01:10:04,272
It combines two things, producing a thing which is the cons, which we may then think goes into there.

1221
01:10:04,512 --> 01:10:06,496
It combines two things, producing a thing which is the cons, which we may then think goes into there.

1222
01:10:07,600 --> 01:10:09,728
And then maybe a thing called the CAR, which will produce-- I can get the CAR or something.

1223
01:10:12,880 --> 01:10:16,224
And then maybe a thing called the CAR, which will produce-- I can get the CAR or something.

1224
01:10:16,920 --> 01:10:19,552
And maybe I can get the CDR of something, and so on.

1225
01:10:20,150 --> 01:10:22,304
But we shouldn't be too afraid of saying things this way, because the worst that could happen is if we open up cons, what we're going to find is some machine.

1226
01:10:22,928 --> 01:10:24,240
But we shouldn't be too afraid of saying things this way, because the worst that could happen is if we open up cons, what we're going to find is some machine.

1227
01:10:24,944 --> 01:10:26,416
But we shouldn't be too afraid of saying things this way, because the worst that could happen is if we open up cons, what we're going to find is some machine.

1228
01:10:27,312 --> 01:10:29,824
But we shouldn't be too afraid of saying things this way, because the worst that could happen is if we open up cons, what we're going to find is some machine.

1229
01:10:31,888 --> 01:10:34,448
And cons may in fact overlap with CAR and CDR, and it always does, in the same way that plus and minus overlap, and really the same business.

1230
01:10:35,504 --> 01:10:38,128
And cons may in fact overlap with CAR and CDR, and it always does, in the same way that plus and minus overlap, and really the same business.

1231
01:10:38,576 --> 01:10:39,856
And cons may in fact overlap with CAR and CDR, and it always does, in the same way that plus and minus overlap, and really the same business.

1232
01:10:41,210 --> 01:10:42,608
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1233
01:10:42,624 --> 01:10:44,528
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1234
01:10:45,504 --> 01:10:46,544
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1235
01:10:48,032 --> 01:10:49,648
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1236
01:10:50,000 --> 01:10:52,864
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1237
01:10:53,300 --> 01:10:54,416
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1238
01:10:54,432 --> 01:10:56,160
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1239
01:10:56,464 --> 01:10:58,704
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1240
01:10:58,816 --> 01:11:00,656
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1241
01:11:00,960 --> 01:11:02,030
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1242
01:11:06,570 --> 01:11:08,832
And I wouldn't be so horrified if that were the way it works.

1243
01:11:09,330 --> 01:11:11,072
In fact, it does, and we'll talk about that later.

1244
01:11:13,320 --> 01:11:14,570
So are there any questions?

1245
01:11:24,340 --> 01:11:25,808
Gee, what an unquestioning audience.

1246
01:11:28,670 --> 01:11:30,330
Suppose I tell you a horrible pile of lies.

1247
01:11:39,690 --> 01:11:40,384
OK.

1248
01:11:41,990 --> 01:11:42,520
Well, thank you.

1249
01:11:42,520 --> 01:11:43,280
Let's take our break.

1250
01:11:44,230 --> 01:11:48,780
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

