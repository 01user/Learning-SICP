1
00:00:02,190 --> 00:00:03,800
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

2
00:00:17,260 --> 00:00:19,072
教授：我认为 到目前为止
PROFESSOR: Well, up 'til now, I suppose,

3
00:00:19,328 --> 00:00:23,936
我们已经学习了很多关于
we've been learning about a lot of techniques for

4
00:00:24,096 --> 00:00:28,830
组织程序以及操纵符号的技术
organizing big programs, symbolic manipulation a bit,

5
00:00:30,848 --> 00:00:35,600
用来构建语言的技术
some of the technology that you use for establishing languages,

6
00:00:35,630 --> 00:00:36,784
用一门语言创建另一门语言
one in terms of another,

7
00:00:37,104 --> 00:00:39,920
这在组织大型程序时非常有用
which is used for organizing very large programs.

8
00:00:39,968 --> 00:00:42,304
实际上 我所知的最好的程序
In fact, the nicest programs I know

9
00:00:42,448 --> 00:00:44,432
看起来更像是一堆语言
look more like a pile of languages

10
00:00:44,912 --> 00:00:47,968
而不是将问题分解成若干部分
than like a decomposition of a problem into parts.

11
00:00:49,900 --> 00:00:51,456
我想 此时此刻
Well, I suppose at this point,

12
00:00:52,080 --> 00:00:53,584
关于这类东西的工作方式
there are still, however, a few mysteries

13
00:00:53,616 --> 00:00:55,328
仍然存在一些谜团
about how this sort of stuff works.

14
00:00:56,260 --> 00:00:59,680
因此 我现在就要
And so what we'd like to do now is

15
00:01:00,030 --> 00:01:02,608
偏离原先的计划
diverge from the plan of

16
00:01:02,960 --> 00:01:05,420
不再继续讲解如何组织大型程序
telling you how to organize big programs,

17
00:01:05,450 --> 00:01:08,192
而是告诉你一些关于
and rather tell you something about the mechanisms

18
00:01:08,528 --> 00:01:11,710
使这些事情可以起作用的机制
by which these things can be made to work.

19
00:01:12,190 --> 00:01:14,832
这样做的主要原因就是
The main reason for this is

20
00:01:15,808 --> 00:01:17,870
来揭秘
demystification, if you will,

21
00:01:18,656 --> 00:01:20,540
剩下的很多谜团
that we have a lot of mysteries left,

22
00:01:21,080 --> 00:01:25,488
比如说 如何控制程序的运行
like exactly how it is the case that a program is controlled,

23
00:01:26,080 --> 00:01:30,384
计算机如何知晓下一步的动作
how a computer knows what the next thing to do is,

24
00:01:30,528 --> 00:01:31,744
等等等等
or something like that.

25
00:01:32,430 --> 00:01:35,568
我现在就要让你们清楚地知道
And what I'd like to do now is make that clear to you

26
00:01:35,856 --> 00:01:39,104
就算你之前没有使用过计算机
that even if you've never played with a physical computer before,

27
00:01:39,568 --> 00:01:43,504
但这种机制非常简单
the mechanism is really very simple,

28
00:01:44,336 --> 00:01:46,352
你可以毫无问题地理解它
and that you can understand it completely with no trouble.

29
00:01:47,650 --> 00:01:51,248
好吧 我们先来想象一个 --
So I'd like to start by imagining that we--

30
00:01:51,328 --> 00:01:52,912
先说明一下 我们采用的方法是
well, the way we're going to do this, by the way,

31
00:01:52,960 --> 00:01:55,808
把一些非常简单的Lisp程序
is we're going to take some very simple Lisp programs,

32
00:01:56,544 --> 00:01:58,128
真的是非常简单的程序
very simple Lisp programs,

33
00:01:59,040 --> 00:02:00,624
把它们转换成硬件
and transform them into hardware.

34
00:02:02,160 --> 00:02:04,160
我不会考虑一些中间步骤
I'm not going to worry about some intermediate step

35
00:02:04,700 --> 00:02:07,456
比如转换成某种现有的机器语言
of going through some existing computer machine language

36
00:02:07,472 --> 00:02:09,050
然后来解释计算机是如何工作的
and then showing you how that computer works,

37
00:02:09,824 --> 00:02:12,000
因为那不太明显
because that's not as illuminating.

38
00:02:12,750 --> 00:02:14,176
所以我真正要向你展示的是
So what I'm really going to show you

39
00:02:14,512 --> 00:02:17,488
如何构建一台机器来完成
is how a piece of machinery can be built

40
00:02:18,032 --> 00:02:22,040
一项你写成程序的工作
to do a job that you have written down as a program.

41
00:02:22,040 --> 00:02:24,032
而程序呢 实际上就是一个机器的描述
That program is, in fact, a description of a machine.

42
00:02:25,760 --> 00:02:27,696
我们从一个非常简单的程序开始
We're going to start with a very simple program,

43
00:02:28,096 --> 00:02:30,816
然后演示一些简单的机制
proceed to show you some simple mechanisms,

44
00:02:31,392 --> 00:02:33,680
进而用更复杂的程序
proceed to a few more complicated programs,

45
00:02:34,304 --> 00:02:37,420
然后又演示一个不那么复杂的程序
and then later show you a not very complicated program,

46
00:02:37,440 --> 00:02:41,230
来演示求值器是如何变成硬件的
how the evaluator transforms into a piece of hardware.

47
00:02:41,230 --> 00:02:42,064
当然 到那个时候
And of course at that point,

48
00:02:42,080 --> 00:02:44,080
你完成了全面的转换
you have made the universal transition

49
00:02:44,224 --> 00:02:46,880
并且可以用一个定义明确的硬件
and can execute any program imaginable

50
00:02:47,168 --> 00:02:48,800
来执行任何可以想象的程序
with a piece of well-defined hardware.

51
00:02:51,728 --> 00:02:52,912
那么 现在让我们开始
Well, let's start up now,

52
00:02:53,056 --> 00:02:55,312
给你们关于这些东西的具体感觉
give you a real concrete feeling for this sort of thing.

53
00:02:55,440 --> 00:02:57,664
我们先从一个非常简单的程序开始
Let's start with a very simple program.

54
00:02:59,600 --> 00:03:00,850
这是欧几里得算法
Here's Euclid's algorithm.

55
00:03:03,880 --> 00:03:07,008
它实际上比欧几里德算法更现代一些
It's actually a little bit more modern than Euclid's algorithm.

56
00:03:07,020 --> 00:03:10,096
我想 用来计算两数最大公约数的欧几里得算法
Euclid's algorithm for computing the greatest common divisor of two numbers

57
00:03:10,416 --> 00:03:13,600
是在公元前350年发明的
was invented 350 BC, I think.

58
00:03:14,300 --> 00:03:15,696
它是已知最古老的算法
It's the oldest known algorithm.

59
00:03:19,320 --> 00:03:23,344
我们先定义(GCD A B)
But here we're going to talk about GCD of A and B,

60
00:03:23,360 --> 00:03:25,616
也就是用来计算A、B两数的最大公约数
the Greatest Common Divisor or two numbers, A and B.

61
00:03:26,208 --> 00:03:28,912
这个算法相当得简单
And the algorithm is extremely simple.

62
00:03:29,500 --> 00:03:31,088
如果B等于0
If B is 0,

63
00:03:34,160 --> 00:03:36,832
那么结果就是A
then the result is going to be A.

64
00:03:37,520 --> 00:03:43,616
否则结果就是 (GCD B
Otherwise, the result is the GCD of B

65
00:03:44,496 --> 00:03:53,392
(REMAINDER A B))
and the remainder when A is divided by B.

66
00:03:58,530 --> 00:04:01,904
这里 我们定义了一个简单的迭代过程
So this we have here is a very simple iterative process.

67
00:04:02,030 --> 00:04:04,080
这是一个简单的递归过程
This a simple recursive procedure,

68
00:04:04,380 --> 00:04:07,536
也可以说这个过程是递归地定义的
recursively defined procedure, recursive definition,

69
00:04:07,712 --> 00:04:09,264
但它产生的计算过程是迭代的
which yields an iterative process.

70
00:04:09,952 --> 00:04:12,460
它的原理是 在每一步
And the way it works is that every step,

71
00:04:12,800 --> 00:04:15,104
判断B是否为0
it determines whether B was zero.

72
00:04:16,240 --> 00:04:18,800
如果B为0 那么A的值就是我们的答案
And if B is 0, we got the answer in A.

73
00:04:19,632 --> 00:04:22,464
否则就进入下一个步骤
Otherwise, we make another step

74
00:04:22,496 --> 00:04:23,872
日中A就变成旧的B
where A is the old B,

75
00:04:23,888 --> 00:04:27,040
而B的值 是A旧值除B旧值的余数
and B is the remainder of the old A divided by the old B.

76
00:04:28,768 --> 00:04:29,552
非常简单
Very simple.

77
00:04:31,110 --> 00:04:32,720
现在 我已经通过这种方式
Now this, I've already told you

78
00:04:32,992 --> 00:04:34,860
告诉了你一些机制
some of the mechanism by just saying it that way.

79
00:04:34,860 --> 00:04:35,904
#TBD
I set it in time.

80
00:04:36,360 --> 00:04:37,728
我说过 其中有特定的步骤
I said there are certain steps,

81
00:04:38,144 --> 00:04:39,328
并且实际上
and that, in fact,

82
00:04:39,520 --> 00:04:40,864
你可以在这里知道
one of the things you can see here

83
00:04:41,184 --> 00:04:43,696
为什么这个过程是迭代的
is that one of the reasons why this is iterative

84
00:04:43,950 --> 00:04:47,680
是因为最后一步无需额外信息来得到答案
is nothing is needed of the last step to get the answer.

85
00:04:49,440 --> 00:04:55,290
所有运行此算法所需的信息都在A和B中
All of the information that's needed to run this algorithm is in A and B.

86
00:04:55,744 --> 00:04:57,808
它有两个定义明确的状态变量
It has two well-defined state variables.

87
00:05:00,470 --> 00:05:02,336
现在 我就要为你们定义一台机器
So I'm going to define a machine for you

88
00:05:03,984 --> 00:05:05,552
用来计算GCD
can compute you GCDs.

89
00:05:06,560 --> 00:05:07,120
我们来看看
Now let's see.

90
00:05:07,120 --> 00:05:11,280
每台制造的计算机都是单进程计算机
Every computer that's ever been made that's a single-process computer,

91
00:05:11,800 --> 00:05:14,080
而不是某种多处理器
as opposed to a multiprocessor of some sort,

92
00:05:15,040 --> 00:05:16,592
都是按照相同的方案制定的
is made according to the same plan.

93
00:05:17,840 --> 00:05:19,536
这种方案就是：计算机由两部分组成
The plan is the computer has two parts,

94
00:05:20,576 --> 00:05:22,352
一部分叫数据通路
a part called the datapaths,

95
00:05:23,104 --> 00:05:24,368
而另一部分叫控制器
and a part called the controller.

96
00:05:25,910 --> 00:05:29,280
数据通路相当于你可能有的计算器
The datapaths correspond to a calculator that you might have.

97
00:05:29,712 --> 00:05:31,872
它有一些寄存器 能够存储数据
It contains certain registers that remember things,

98
00:05:31,904 --> 00:05:33,136
你们都用过计算器
and you've all used calculators.

99
00:05:33,560 --> 00:05:35,344
它上面有一些按钮和指示灯
It has some buttons on it and some lights.

100
00:05:37,030 --> 00:05:38,496
通过按下不同的按钮
And so by pushing the various buttons,

101
00:05:38,528 --> 00:05:41,344
你可以使操作在寄存器内发生
you can cause operations to happen inside there among the registers,

102
00:05:41,872 --> 00:05:43,488
并显示计算结果
and some of the results to be displayed.

103
00:05:45,160 --> 00:05:46,250
它是完全机械式的
That's completely mechanical.

104
00:05:46,250 --> 00:05:49,552
你可以认为那个盒子没有任何智能
You could imagine that box has no intelligence in it.

105
00:05:50,900 --> 00:05:53,280
它能计算一个数的正弦也许令人吃惊
Now it might be very impressive that it can produce the sine of a number,

106
00:05:53,536 --> 00:05:58,970
但它显然是机械式的
but that at least is apparently possibly mechanical.

107
00:05:58,970 --> 00:06:01,712
至少 我可以像打开GCD机器一样打开它
At least, I could open that up in the same way I'm about to open GCD.

108
00:06:02,690 --> 00:06:04,368
也就是说 它其中可能有一整台计算机
So this may have a whole computer inside of it,

109
00:06:04,688 --> 00:06:05,696
但这并不有趣
but that's not interesting.

110
00:06:05,940 --> 00:06:07,104
加法相当简单
Addition is certainly simple.

111
00:06:08,200 --> 00:06:09,840
不借助额外机制就可以完成
That can be done without any further mechanism.

112
00:06:10,890 --> 00:06:15,648
现在 如果我们来看另外的一部分：控制器
Now also, if we were to look at the other half, the controller,

113
00:06:15,936 --> 00:06:17,392
这一部分也非常简单
that's a part that's dumb, too.

114
00:06:18,190 --> 00:06:19,168
它负责按下按钮
It pushes the buttons.

115
00:06:20,350 --> 00:06:21,520
它根据指令序列来按按钮
It pushes them according to the sequence,

116
00:06:21,552 --> 00:06:22,848
指令是写在纸上的
which is written down on a piece of paper,

117
00:06:24,272 --> 00:06:25,648
控制器还会观察指示灯
and observes the lights.

118
00:06:26,290 --> 00:06:29,440
而且每隔一段 它就会来到指令序列中的一处
And every so often, it comes to a place in a sequence that says,

119
00:06:29,472 --> 00:06:32,370
如果指示灯A亮 则执行某段指令
if light A is on, do this sequence.

120
00:06:32,370 --> 00:06:33,856
否则执行另外的指令
Otherwise, do that sequence.

121
00:06:34,620 --> 00:06:37,456
因此 这其中也没有什么复杂的
And thereby, there's no complexity there either.

122
00:06:38,350 --> 00:06:39,328
那么 让我们来画一下
Well, let's just draw that

123
00:06:39,344 --> 00:06:40,570
然后来感受一下它
and see what we feel about that.

124
00:06:42,510 --> 00:06:44,848
为了计算GCD
So for computing GCDs,

125
00:06:45,888 --> 00:06:49,520
你们要知道：这其中有一些寄存器
what I want you to think about is that there are these registers.

126
00:06:50,560 --> 00:06:53,024
这里 寄存器就是一个存储数值的地方
A register is a place where I store a number, in this case.

127
00:06:53,520 --> 00:06:54,656
这个寄存器存储的是A
And this one's called a.

128
00:06:56,810 --> 00:06:58,700
而另外的这个存储的是B
And then there's another one for storing b.

129
00:07:03,170 --> 00:07:05,456
现在 我们来看看有了这些寄存器后能做什么
Now we have to see what things we can do with these registers,

130
00:07:05,980 --> 00:07:08,736
至于你能利用它做什么 并不是很明显
and they're not entirely obvious what you can do with them.

131
00:07:09,840 --> 00:07:11,728
那么 我们必须看看需要用它们做什么
Well, we have to see what things we need to do with them.

132
00:07:11,824 --> 00:07:13,872
我们来看看尝试求解的问题
We're looking at the problem we're trying to solve.

133
00:07:14,030 --> 00:07:16,096
设计计算机的一件重要的事儿就是
One of the important things for designing a computer,

134
00:07:17,104 --> 00:07:19,584
我想大多数设计师都不会照做
which I think most designers don't do,

135
00:07:20,208 --> 00:07:21,888
也就是专注于待解的问题
is you stay the problem you want to solve

136
00:07:22,624 --> 00:07:25,180
然后使用你研究问题所学到的东西
and then use what you learn from studying the problem you want to solve

137
00:07:25,440 --> 00:07:27,280
把那些求解问题所需要的机制
to put in the mechanisms needed to solve it

138
00:07:27,530 --> 00:07:28,700
融入正在构建的计算机中
in the computer you're building,

139
00:07:28,816 --> 00:07:30,080
不多也不少
no more no less.

140
00:07:32,140 --> 00:07:33,968
现在 可能你所要解决的问题
Now it may be that the problem you're trying to solve

141
00:07:34,240 --> 00:07:35,408
是大家共有的问题
is everybody's problem,

142
00:07:36,060 --> 00:07:37,584
这种情况下你需要构建
in which case you have to build in a universal

143
00:07:37,600 --> 00:07:39,290
某种语言的通用解释器
interpreter of some language.

144
00:07:40,190 --> 00:07:42,320
但是你添加的机制不能比
But you shouldn't put any more in than required

145
00:07:42,352 --> 00:07:44,256
想构建的语言解释器的需求多
to build the universal interpreter of some language.

146
00:07:44,448 --> 00:07:45,856
这一点 我们稍后来讨论
We'll worry about that in a second.

147
00:07:47,232 --> 00:07:49,930
好了 让我们回到这里
OK, going back to here, let's see.

148
00:07:49,930 --> 00:07:51,248
我们必须能够做什么？
What do we have to be able to do?

149
00:07:51,792 --> 00:07:54,144
首先 我们能把B的值赋给A
Well, somehow, we have to be able to get B into A.

150
00:07:56,080 --> 00:07:59,600
我们要能够把B的旧值赋给A
We have to be able to get the old value of B into the value of A.

151
00:08:00,380 --> 00:08:03,328
因此 我们需要某种能够让数据流通的“路径”
So we have to have some path by which stuff can flow

152
00:08:03,344 --> 00:08:04,760
而不管数据具体是什么
whatever this information is,

153
00:08:05,376 --> 00:08:06,576
从B到A的通路
OK? from b to a.

154
00:08:07,390 --> 00:08:09,264
我箭头来指示
I'm going to draw that with by an arrow

155
00:08:09,520 --> 00:08:12,624
我们能够把B的值赋给A
saying that it is possible to move the contents of b into a,

156
00:08:12,960 --> 00:08:14,576
从而替换A的旧值
replacing the value of a.

157
00:08:15,120 --> 00:08:16,736
当你按下这里的按钮后
And there's a little button here which you push

158
00:08:17,488 --> 00:08:18,560
就能够实现这个效果
which allows that to happen.

159
00:08:19,710 --> 00:08:20,784
这个按钮就在这里
That's what the little x is here.

160
00:08:23,070 --> 00:08:23,936
同样的
Now it's also the case

161
00:08:23,952 --> 00:08:26,288
我还需要能够计算A除B的余数
that I have to be able to compute the remainder of a and b.

162
00:08:27,000 --> 00:08:28,496
这可能混乱而又复杂
Now that may be a complicated mess.

163
00:08:28,860 --> 00:08:30,864
但另一方面 我会把它放到一个小盒子中
On the other hand, I'm going to make it a small box.

164
00:08:31,960 --> 00:08:33,920
如果有必要的话 我们可以打开那个盒子
If we have to, we may open up that box

165
00:08:34,128 --> 00:08:35,632
看看其中有些什么
and look inside and see what it is.

166
00:08:37,770 --> 00:08:39,168
这就是那个小盒子
So here, I'm going to have a little box,

167
00:08:39,200 --> 00:08:40,380
我这么来画它
which I'm going to draw this way,

168
00:08:43,168 --> 00:08:44,384
我把它叫做REM
which we'll call the remainder.

169
00:08:46,440 --> 00:08:48,608
它接受A
And it's going to take in a.

170
00:08:50,910 --> 00:08:52,160
同时也要接受B
That's going to take in b.

171
00:08:54,370 --> 00:08:56,512
它有一个输出
And it's going to put out something,

172
00:08:58,896 --> 00:09:00,464
也就是A除以B的余数
the remainder of a divided by b.

173
00:09:02,290 --> 00:09:03,616
在这里 我们同样需要能够
Another thing we have to see here is

174
00:09:03,648 --> 00:09:06,060
判断B是否等于0
that we have to be able to test whether b is equal to 0.

175
00:09:08,000 --> 00:09:09,664
也就是说 总得有个东西
Well, that means somebody's got to be looking at--

176
00:09:10,000 --> 00:09:12,304
去查询B的值
a thing that's looking at the value of b.

177
00:09:13,390 --> 00:09:14,400
这是一个指示灯
I have a light bulb here

178
00:09:15,856 --> 00:09:17,390
当B等于0时 它就会点亮
which lights up if b equals 0.

179
00:09:21,110 --> 00:09:22,016
它就是干这个的
That's its job.

180
00:09:24,030 --> 00:09:26,784
最后 我想 因为我们希望
And finally, I suppose, because of the fact

181
00:09:26,960 --> 00:09:30,432
A的新值是B的旧值
that we want the new value of a to be the old value of b,

182
00:09:30,464 --> 00:09:34,416
同时B的新值是有关于A的
and simultaneously the new value of b to be something I've done with a,

183
00:09:35,280 --> 00:09:37,600
如果我打算让机器
and if I plan to make my machine

184
00:09:37,808 --> 00:09:39,744
一次只发生一件事
such that everything happens one at a time,

185
00:09:40,208 --> 00:09:41,408
一次执行一个动作
one motion at a time,

186
00:09:41,616 --> 00:09:43,424
并且我不能在一个寄存器中放两个数字
and I can't put two numbers in a register,

187
00:09:44,032 --> 00:09:46,300
那么进行互换时 必须有另外的地方放置一个数字
then I have to have another place to put one while I'm interchanging.

188
00:09:49,296 --> 00:09:49,600
对吧？
OK?

189
00:09:50,000 --> 00:09:51,856
我不能同时交换两手的东西
I can't interchange the two things in my hands,

190
00:09:52,110 --> 00:09:53,728
除非我一手拿两个
unless I either put two in one hand

191
00:09:53,728 --> 00:09:55,130
然后从中取另外一个
and then pull it back the other way,

192
00:09:55,504 --> 00:09:56,912
或者我先放下一个
or unless I put one down,

193
00:09:57,024 --> 00:09:58,688
取得另一个后再像这样捡起来
pick it up, and put the other one, like that

194
00:09:59,648 --> 00:10:00,944
除非我是耍杂技的
unless I'm a juggler,

195
00:10:01,660 --> 00:10:03,500
当然正如大家所见 我并不是
which I'm not, as you can see,

196
00:10:04,656 --> 00:10:07,360
这种情况下 我就会遇到时序错误
in which case I have a possibility of timing errors.

197
00:10:08,850 --> 00:10:11,040
事实上 人们所做的许多类型的计算机设计
In fact, much of the type of computer design

198
00:10:11,072 --> 00:10:12,688
都遇到了时序错误
people do involves timing errors,

199
00:10:13,120 --> 00:10:15,008
或者潜在的时序错误
of some potential timing errors,

200
00:10:15,248 --> 00:10:16,432
我不太喜欢这种错误
which I don't much like.

201
00:10:17,340 --> 00:10:18,640
因此 出于这个原因
But. So for that reason,

202
00:10:18,688 --> 00:10:21,216
我需要有一个地方来放置
I have to have a place to put the third thing down

203
00:10:22,060 --> 00:10:23,296
其中的一个元素
the second one of them down.

204
00:10:23,410 --> 00:10:24,720
因此 这里有一个寄存器
So I have a place called t,

205
00:10:24,752 --> 00:10:26,840
用来存放临时值T
which is a register just for temporary, t,

206
00:10:28,592 --> 00:10:29,632
上面有一个按钮
with a button on it.

207
00:10:30,470 --> 00:10:31,888
我会使用它的结果
And then I'll take the result of that,

208
00:10:31,904 --> 00:10:34,144
#TBD
since I have to take that and put into b, over here,

209
00:10:34,688 --> 00:10:36,736
#TBD
we'll take the result of that and go like this,

210
00:10:38,416 --> 00:10:39,300
这里同样有一个按钮
and a button here.

211
00:10:42,430 --> 00:10:45,840
这就是GCD机器的数据通路
So that's the datapaths of a GCD machine.

212
00:10:47,600 --> 00:10:48,576
那么 控制器又是怎样的呢？
Now what's the controller?

213
00:10:49,740 --> 00:10:51,280
控制器同样很简单
Controller's a very simple thing, too.

214
00:10:52,280 --> 00:10:53,264
机器具有状态
The machine has a state.

215
00:10:54,384 --> 00:10:57,728
我喜欢形象地把它们比作迷宫
The way I like to visualize that is that I've got a maze.

216
00:10:59,010 --> 00:11:03,200
这个迷宫的各处是通过直接的箭头连接的
And the maze has a bunch of places connected by directed arrows.

217
00:11:04,430 --> 00:11:05,600
而我有一颗弹珠
And what I have is a marble,

218
00:11:06,464 --> 00:11:09,072
它代表了控制器的状态
which represents the state of the controller.

219
00:11:10,740 --> 00:11:12,272
弹珠在迷宫中四处滚动
The marble rolls around in the maze.

220
00:11:13,744 --> 00:11:17,150
当然 这种类比因能源原因而崩溃#TBD
Of course, this analogy breaks down for energy reasons.

221
00:11:17,150 --> 00:11:19,088
有时我不得不将弹珠泵到顶部
I sometimes have to pump the marble up to the top,

222
00:11:19,120 --> 00:11:21,856
不然它就会成为一台永动机
because it's going to otherwise be a perpetual motion machine.

223
00:11:22,000 --> 00:11:23,328
但不用担心那么多
But not worrying about that,

224
00:11:23,904 --> 00:11:25,904
这并不是一个物理比喻
this is not a physical analogy.

225
00:11:26,080 --> 00:11:27,424
弹珠到处滚动
This marble rolls around.

226
00:11:27,680 --> 00:11:29,568
就像弹球机一样
And every time it rolls around certain bumpers,

227
00:11:29,680 --> 00:11:30,976
每次当它滚动到一些缓冲器时
like in a pinball machine,

228
00:11:31,264 --> 00:11:32,608
它就会按下这些按钮
it pushes one of these buttons.

229
00:11:34,830 --> 00:11:37,504
它也会经常来到一个分支区域
And every so often, it comes to a place, which is a division,

230
00:11:38,624 --> 00:11:39,680
它要在这里做选择
where it has to make a choice.

231
00:11:40,250 --> 00:11:42,360
#TBD
And there's a flap, which is controlled by this.

232
00:11:46,000 --> 00:11:48,820
所以这是一个非常机械化的思考方式
So that's a really mechanical way of thinking about it.

233
00:11:48,820 --> 00:11:51,056
当然 真实计算机中的控制器
Of course, controllers not these days, are not built that way

234
00:11:51,088 --> 00:11:51,840
并不是这样的
in real computers.

235
00:11:51,840 --> 00:11:56,016
而是由一些ROM和状态寄存器构成
They're built with a little bit of ROM and a state register.

236
00:11:56,610 --> 00:11:58,736
但曾几何时 像DEC、PDP-6这些个机器
But there was a time, like the DEC PDP-6,

237
00:11:59,296 --> 00:12:01,024
它们的控制器就是我们说的那样
where that's how you built the controller of a machine.

238
00:12:01,808 --> 00:12:03,616
延迟线上有一些比特信息
There was a bit that ran around the delay line,

239
00:12:05,696 --> 00:12:08,144
它随着时间的推移而触发事件
and it triggered things as it went by.

240
00:12:08,580 --> 00:12:10,704
然后回到开始并再次轮回
And it would come back to the beginning and get fed round again.

241
00:12:11,990 --> 00:12:13,728
当然 还有各种各样的错误
And of course, there were all sorts of great bugs you could have

242
00:12:13,744 --> 00:12:17,670
比如两个比特的信息 -- 对应两个弹珠
like two bits going around, two marbles.

243
00:12:17,670 --> 00:12:19,260
机器也会丢失弹珠
And then the machine has lost its marbles.

244
00:12:19,456 --> 00:12:20,208
这也会发生
That happens, too.

245
00:12:20,980 --> 00:12:21,584
好吧
Oh, well.

246
00:12:22,272 --> 00:12:24,224
无论如何 对于这台机器
So anyway, for this machine,

247
00:12:24,272 --> 00:12:25,488
我想要这么来做
what I have to do is the following.

248
00:12:25,808 --> 00:12:27,744
迷宫从这里开始
I'm going to start my maze here.

249
00:12:30,520 --> 00:12:32,736
我首先要做的是
And the first thing I've got to do,

250
00:12:33,760 --> 00:12:36,752
用一个你们非常熟悉的流程图记号
is in a notation which many of you are familiar with,

251
00:12:37,072 --> 00:12:39,856
这是一个判断：B是否为0
is b equal to zero, a test.

252
00:12:41,504 --> 00:12:43,790
如果判断为是的话
And there's a possibility, either yes,

253
00:12:43,936 --> 00:12:45,584
那我就做完了
in which case I'm done.

254
00:12:49,790 --> 00:12:51,264
否则的话
Otherwise, if no,

255
00:12:52,704 --> 00:12:54,320
我就不得不滚动一些缓冲器
then I'm going have to roll over some bumpers.

256
00:12:55,008 --> 00:12:56,464
按照下列顺序执行
I'm going to do it in the following order.

257
00:12:57,420 --> 00:13:03,408
我想向这样来做一个互换游戏
I want to, I want to do this interchange game.

258
00:13:04,050 --> 00:13:05,808
手下 因为我需要A和B
Now first, since I need both a and b,

259
00:13:06,320 --> 00:13:08,576
但首先 -- 虽然并不是必要的
but then the first-- and this is not necessary--

260
00:13:08,656 --> 00:13:09,728
我需要先把它们收集起来
I want to collect this.

261
00:13:11,070 --> 00:13:12,624
这里的值要送入到B中
This is the thing that's going to go into b.

262
00:13:13,240 --> 00:13:14,032
因此 我会说
So I'm going to say,

263
00:13:14,288 --> 00:13:16,272
用A和B的值来计算这个
take this, which depends upon both a and b,

264
00:13:16,368 --> 00:13:18,672
并把算得的余数放到这里
and put the remainder into here.

265
00:13:19,150 --> 00:13:20,336
因此 我首先要按下这个按钮
So I'm going to push this button first.

266
00:13:21,536 --> 00:13:24,432
然后我要把B的值送入A
Then, I'm going to transfer b to a,

267
00:13:24,448 --> 00:13:25,600
通过按这个钮来实现
push that button,

268
00:13:25,824 --> 00:13:27,632
然后我再把临时值送入B
and then I transfer the temporary into b,

269
00:13:28,768 --> 00:13:29,424
通过这个按钮实现
push that button.

270
00:13:32,030 --> 00:13:34,970
这是一个相当时序化的机器
So a very sequential machine,

271
00:13:35,392 --> 00:13:36,528
它非常的低效
it's very inefficient.

272
00:13:37,750 --> 00:13:39,056
但目前来说还好
But that's fine right now.

273
00:13:39,810 --> 00:13:40,970
我们来为按钮命名
We're going to name the buttons,

274
00:13:41,472 --> 00:13:42,720
T←R
t gets remainder.

275
00:13:46,750 --> 00:13:48,736
A←B
a gets b.

276
00:13:50,030 --> 00:13:54,816
B←T
And b gets t.

277
00:13:55,470 --> 00:13:57,632
然后我要来到这里
And then I'm going to go around here

278
00:13:58,784 --> 00:13:59,888
也就是回到开始的地方
and it's to go back to start.

279
00:14:01,620 --> 00:14:03,870
在这里 我们看到了什么？
And if you look, what are we seeing here?

280
00:14:03,870 --> 00:14:04,912
我们看到各种各样的 --
We're seeing the various--

281
00:14:05,056 --> 00:14:07,168
我们真正拥有的是某种机械连接
what I really have is some sort of mechanical connection,

282
00:14:07,424 --> 00:14:13,632
其中T←R控制了这个东西
where t gets r controls this thing.

283
00:14:16,830 --> 00:14:21,488
A←B控制了这个东西
And I have here that a gets b controls this fellow over here,

284
00:14:26,960 --> 00:14:28,120
而这里的这个东西
and this fellow over here.

285
00:14:28,120 --> 00:14:31,088
同学们 这简直太恶劣了
Boy, that's absolutely pessimal,

286
00:14:31,488 --> 00:14:32,480
一点也没有优化
the inverse of optimal.

287
00:14:32,630 --> 00:14:34,590
我画的所有线条都相互交叉
Every line heads across every other line the way I drew it.

288
00:14:38,540 --> 00:14:41,150
我想B←T控制的是这个
I suppose this goes here, b gets t.

289
00:14:45,690 --> 00:14:47,952
现在 我就要运行这台机器了
Now I'd like to run this machine.

290
00:14:48,040 --> 00:14:49,344
但是在我运行它之前
But before I run the machine,

291
00:14:49,376 --> 00:14:51,408
我想写下它的控制器的描述
I want to write down a description of this controller,

292
00:14:51,630 --> 00:14:52,816
以便使你们相信
just so you can see that these things,

293
00:14:52,848 --> 00:14:55,632
这些东西可以组织成某种良好的语言
of course, as usual, can be written down in some nice language,

294
00:14:56,080 --> 00:14:58,080
这样我们就不必总是像这样画图
so that we don't have to always draw these diagrams.

295
00:14:58,368 --> 00:15:00,688
图示的缺陷之一 就是占用了太多空间
One of the problems with diagrams is that they take up a lot of space.

296
00:15:00,896 --> 00:15:01,980
对于这样的一个小型机器来说
And for a machine this small,

297
00:15:02,000 --> 00:15:03,056
它占用了两块黑板
it takes two blackboards.

298
00:15:03,220 --> 00:15:05,248
而一台求值器机器
For a machine that's the evaluator machine,

299
00:15:05,408 --> 00:15:07,104
我就很难将它画在这间屋子里了
I have trouble putting it into this room,

300
00:15:07,952 --> 00:15:09,168
尽管它还不是非常大
even though it isn't very big.

301
00:15:09,900 --> 00:15:11,280
因此我要为它构造一门小型语言
So I'm going to make a little language for this

302
00:15:11,296 --> 00:15:12,512
用来描述这个机器
that's just a description of that,

303
00:15:13,104 --> 00:15:23,296
(DEFIME-MACHINE GCD
saying define a machine we'll call GCD.

304
00:15:24,420 --> 00:15:25,664
当然 一旦我们有了像这样的描述
Of course, once we have something like this,

305
00:15:25,680 --> 00:15:26,832
我们就能够模拟该机器
we have a simulator for it.

306
00:15:27,220 --> 00:15:29,424
我之所以想构建这种形式的语言
And the reason why we want to build a language in this form,

307
00:15:29,568 --> 00:15:32,944
是因为我们能够立即操纵这些表达式
is because all of a sudden we can manipulate these expressions that I'm writing down.

308
00:15:33,210 --> 00:15:34,912
因此 我也就能够
And then of course I can write things I can

309
00:15:35,290 --> 00:15:38,160
代数地操作 或者模拟这些东西
algebraically manipulate these things, simulate them

310
00:15:38,208 --> 00:15:39,968
以及各种各样我想进行的操作
all that sort of things that I might want to do,

311
00:15:40,128 --> 00:15:42,592
或者还可以把它们转换成布局图 谁知道呢？
perhaps transform them as a layout, who knows.

312
00:15:43,630 --> 00:15:48,384
一旦我有了寄存器的良好表示
Once I have a nice representation of registers,

313
00:15:48,510 --> 00:15:49,616
它有一些寄存器
it has certain registers,

314
00:15:53,008 --> 00:15:55,640
记作(REGISTERS A B T)
which we can call A, B, and T.

315
00:15:56,752 --> 00:15:57,808
它还有控制器
And there's a controller.

316
00:16:02,190 --> 00:16:04,464
实际上 更好的做法是让它跟显式一些
Actually, a better language, which would be more explicit,

317
00:16:04,496 --> 00:16:06,976
也就是说 为每一个按钮命名
would be one which named every button

318
00:16:08,144 --> 00:16:10,176
并指明它们的操作
also and said what it did.

319
00:16:10,420 --> 00:16:11,376
比如说这个按钮
Like, this button

320
00:16:11,552 --> 00:16:14,190
会让T的值送入到B中
causes the contents of T to go to the contents of B.

321
00:16:15,100 --> 00:16:16,096
但我却不想这么做
Well I don't want to do that,

322
00:16:16,112 --> 00:16:17,952
因为这样会让代码难以阅读
because it's actually harder to read to do that,

323
00:16:18,208 --> 00:16:19,344
也会占用更多空间
and it takes up more space.

324
00:16:19,510 --> 00:16:22,368
所以我会把相关的指令写在控制器中
So I'm going to have that in the instructions written in the controller.

325
00:16:23,290 --> 00:16:25,248
这样就隐式地指明了具体的操作
It's going to be implicit what the operations are.

326
00:16:26,320 --> 00:16:28,576
可以通过阅读代码推断出来
They can be deduced by reading these

327
00:16:29,168 --> 00:16:31,392
#TBD
and collecting together all the different things that can be done.

328
00:16:31,696 --> 00:16:33,500
我们来看一看
We look and see, see...

329
00:16:33,500 --> 00:16:34,704
我们来看下这些东西是什么吧
Well, let's just look at what these things are.

330
00:16:35,712 --> 00:16:37,296
首先是一个循环
There's a little loop that we go around

331
00:16:38,240 --> 00:16:40,208
先是一条分支指令
which says branch,

332
00:16:42,640 --> 00:16:46,464
这个就对应了机器中的小挡板
this is the representation of the little flap

333
00:16:46,896 --> 00:16:48,496
它决定了你在此处的走向
that decides which way you go here,

334
00:16:49,104 --> 00:16:58,000
判断 -- 取B的值 并判断是否为0
if 0, OK, fetch of B, the contents of B,

335
00:16:58,650 --> 00:17:00,064
如果B的值是0
and if the contents of B is 0,

336
00:17:00,320 --> 00:17:01,720
那么就跳转到一个叫DONE的地方
then go to a place called done.

337
00:17:03,640 --> 00:17:05,296
现在 你们在这里看到的是
Now, one thing you're seeing here,

338
00:17:05,296 --> 00:17:07,400
这个看起来非常像传统计算机语言
this looks very much like a traditional computer language.

339
00:17:08,170 --> 00:17:09,552
但你们所见的是
And what you're seeing here

340
00:17:10,032 --> 00:17:12,000
一些个标签
is things like labels

341
00:17:12,992 --> 00:17:16,864
#TBD
that represent places in a sequence written down as a sequence.

342
00:17:17,600 --> 00:17:18,944
之所以需要它们
The reason why they're needed

343
00:17:19,488 --> 00:17:21,152
是因为在这里
is because over here,

344
00:17:21,456 --> 00:17:22,816
我表达了“循环”的概念
I've written something with loops.

345
00:17:23,320 --> 00:17:26,112
但是如果我是在写英文之类的文本
But if I'm writing English text, or something like that,

346
00:17:26,448 --> 00:17:28,096
就很难去引用一个位置
it's hard to refer to a place.

347
00:17:28,580 --> 00:17:29,536
我没有箭头
I don't have arrows.

348
00:17:30,800 --> 00:17:33,024
#TBD
Arrows are represented by giving names

349
00:17:33,056 --> 00:17:34,440
#TBD
to the places where the arrows terminate,

350
00:17:34,576 --> 00:17:36,288
并通过名字来引用
and then referring to them by those names.

351
00:17:37,408 --> 00:17:38,592
这只是一种编码
Now this is just an encoding.

352
00:17:39,860 --> 00:17:41,888
而不是某种魔法
There's nothing magical about things like that.

353
00:17:43,150 --> 00:17:44,960
接下来我们要做的是
Next thing we're going to do is we're going to say,

354
00:17:45,024 --> 00:17:46,840
我们如何来实现T←R
how do we do T gets R?

355
00:17:47,450 --> 00:17:49,760
非常简单 用ASSIGN
Oh, that's easy enough, assign.

356
00:17:52,192 --> 00:17:55,552
我们把余数赋值给T
We assign to T the remainder.

357
00:17:56,320 --> 00:17:59,248
ASSIGN就是按钮的名字
Assign is the name of the button.

358
00:18:01,470 --> 00:18:02,640
就是按按钮的家伙
That's the button-pusher.

359
00:18:03,140 --> 00:18:04,976
把余数赋给T
Assign to T the remainder,

360
00:18:04,992 --> 00:18:06,768
这个操作是这样表示的
and here's the representation of the operation,

361
00:18:11,744 --> 00:18:17,536
取A、B的值 相除得到余数
when we divide the fetch of A by the fetch of B.

362
00:18:23,856 --> 00:18:30,992
同时 我们也要取B的值 赋给A
And we're also going to assign to A the fetch of B,

363
00:18:34,990 --> 00:18:47,888
再取T的值赋给B
assign to B the result of getting the contents of T.

364
00:18:49,616 --> 00:18:51,856
现在 我需要引用这个开头#TBD
And now I have to refer to the beginning here.

365
00:18:53,184 --> 00:18:55,920
呃 我为什么不把这里叫做LOOP呢？
I see, why don't I call that loop like I have here?

366
00:19:04,096 --> 00:19:07,040
这样的话 #TBD
OK? So that's that reference to that arrow.

367
00:19:07,610 --> 00:19:08,950
当执行到DONE时 就完成了所有操作
And when we're done, we're done.

368
00:19:09,024 --> 00:19:13,072
我们来到了这里 所有指令的结尾
We go to here, which is the end of the thing.

369
00:19:15,260 --> 00:19:17,040
这段文字化描述的就是
So here's just a written representation

370
00:19:17,696 --> 00:19:20,860
我们在这里画的一小部分机器
of this fragment of machinery that we've drawn here.

371
00:19:21,660 --> 00:19:24,848
下面 我就要运行它
Now the next thing I'd like to do is run this.

372
00:19:25,490 --> 00:19:26,656
我想让你们感受一下它的运行
I want us to feel it running.

373
00:19:27,620 --> 00:19:29,808
从来没有做过这个 你必须做一次#TBD
Never done this before, you got to do it once.

374
00:19:31,010 --> 00:19:32,624
让我们以一个具体的问题来演示
So let's take a particular problem.

375
00:19:33,100 --> 00:19:34,704
假设我们想要计算
Suppose we want to compute the GCD

376
00:19:35,040 --> 00:19:40,680
30和42的最大公约数
of a equals 30 and b equals 42.

377
00:19:42,210 --> 00:19:44,928
我现在不知道结果是多少
I have no idea what that is right now.

378
00:19:45,860 --> 00:19:47,600
但我知道A=30而B=42
But a 30 and b is 42.

379
00:19:50,960 --> 00:19:52,096
我就这么着开始
So that's how I start this thing up.

380
00:19:52,608 --> 00:19:53,904
那么 我首先要做些什么呢？
Well, what's the first thing I do?

381
00:19:54,240 --> 00:19:56,864
我先判断B是否为0：否
I say is B equal to 0, no.

382
00:19:57,590 --> 00:20:02,112
然后计算A除B的余数 并赋给T
Then assign to T the remainder of the fetch of A and the fetch of B.

383
00:20:02,800 --> 00:20:07,600
当然 30除以42的余数就是30自己
Well the remainder of 30 when divided by 42 is itself 30.

384
00:20:11,130 --> 00:20:12,032
按下那个按钮
Push that button.

385
00:20:12,920 --> 00:20:15,104
现在弹珠就滚动到了这里
Now the marble has rolled to here.

386
00:20:17,100 --> 00:20:18,064
A←B
A gets B.

387
00:20:19,024 --> 00:20:20,768
又按下了这个按钮
That pushes this button.

388
00:20:21,220 --> 00:20:22,544
因此42来到了这里
So 42 moves into here.

389
00:20:26,592 --> 00:20:27,600
B←T
B gets T.

390
00:20:28,368 --> 00:20:29,344
按下了这个按钮
Push that button.

391
00:20:29,870 --> 00:20:30,960
30来到了这里
The 30 goes here.

392
00:20:32,576 --> 00:20:33,696
这样我就交换了它们
Let met just interchange them.

393
00:20:34,660 --> 00:20:38,272
我们再来看看 回到开始
Now let's see, go back to the beginning.

394
00:20:38,640 --> 00:20:39,728
B为0么？不
B 0, no.

395
00:20:40,192 --> 00:20:41,504
将余数赋给T
T gets the remainder.

396
00:20:43,230 --> 00:20:46,304
我想 42除以30的余数是12
I suppose the remainder when dividing 42 by 30 is 12.

397
00:20:47,240 --> 00:20:48,304
按下这个钮
I push that one.

398
00:20:48,530 --> 00:20:51,408
下面 我想让30来到这里
Next thing I do is allow the 30 to go to here,

399
00:20:53,904 --> 00:20:55,950
按下这个钮 让12来到这里
push this one, allow the 12 to go to here.

400
00:20:58,416 --> 00:21:00,380
#TBD
OK? Go around this thing.

401
00:21:00,380 --> 00:21:01,312
程序执行完了么？
Is that done?

402
00:21:01,530 --> 00:21:02,128
并没有
No.

403
00:21:02,360 --> 00:21:08,224
现在 我需要求解30除以12的余数
How about-- so now I have to find out the remainder of 30 divided by 12.

404
00:21:08,850 --> 00:21:10,672
我想答案是6
And I believe that's 6.

405
00:21:12,420 --> 00:21:15,136
按下这个钮 6就到了这里
So 6 goes here on this button push.

406
00:21:16,208 --> 00:21:18,256
然后我又按下这个钮
Then the next thing I push is this one,

407
00:21:18,304 --> 00:21:19,616
这就让12来到了这里
which the 12 goes into here.

408
00:21:23,730 --> 00:21:25,090
然后我又按下这个按钮
Then I push this button.

409
00:21:25,090 --> 00:21:26,000
6就来到了这里
The 6 gets into here.

410
00:21:29,850 --> 00:21:31,680
6等于0么？
Is 6 equal to 0?

411
00:21:31,888 --> 00:21:32,496
不等于
No.

412
00:21:33,420 --> 00:21:33,984
好的
OK.

413
00:21:34,380 --> 00:21:36,800
因此这时
So then at that point,

414
00:21:36,890 --> 00:21:38,128
接下来又要计算余数
the next thing to do is divide it.

415
00:21:38,144 --> 00:21:39,808
哦 这个的余数是0
Ooh, this has got a remainder of 0.

416
00:21:40,660 --> 00:21:41,744
看起来我们就快完成了
Looks like we're almost done.

417
00:21:42,360 --> 00:21:44,360
将6从这里挪到这里
Move the 6 over here next.

418
00:21:47,008 --> 00:21:48,272
0移动到这里
0 over here.

419
00:21:49,090 --> 00:21:50,200
0等于0么？
Is the answer 0?

420
00:21:50,200 --> 00:21:50,736
是的
Yes.

421
00:21:51,340 --> 00:21:53,360
B的值等于0 因此答案就是A的值
B is 0, therefore the answer is in A.

422
00:21:54,288 --> 00:21:55,760
因此答案就是6
The answer is 6.

423
00:21:56,610 --> 00:21:57,616
这确实是正确的答案
And indeed that's right,

424
00:21:57,632 --> 00:21:59,472
因为如果我们回过头审视最初的问题
because if we look at the original problem,

425
00:22:00,080 --> 00:22:06,640
我们知道30=2×3×5
what we have is 30 is 2 times 3 times 5,

426
00:22:07,008 --> 00:22:11,120
42=2×3×7
and 42 is 2 times 3 times 7.

427
00:22:11,670 --> 00:22:14,112
因此最大公约数就是2×3
So the greatest common divisor is 2 times 3,

428
00:22:14,208 --> 00:22:15,088
也就是6
which is 6.

429
00:22:18,380 --> 00:22:20,560
我们通常在这里写一条另一条线
Now normally, we write one other little line here,

430
00:22:20,592 --> 00:22:22,528
为了使它更清晰一点
just to make it a little bit clearer,

431
00:22:22,896 --> 00:22:27,712
#TBD
which is that we leave in a connection saying

432
00:22:27,856 --> 00:22:31,010
#TBD
that this light is the guy that that flap looks at.

433
00:22:34,000 --> 00:22:37,328
当然 跟我给你们展示的东西相比
Of course, any real machine has a lot more

434
00:22:37,856 --> 00:22:40,000
真实计算机的组件更加复杂
complicated things in it than what I've just shown you.

435
00:22:41,350 --> 00:22:47,168
让我们来看看第一张幻灯片
Let's look for a second at the first still store.

436
00:22:47,980 --> 00:22:48,816
哇
Wow.

437
00:22:50,190 --> 00:22:52,432
我们看到 我们想要做的就是
Well you see, for example, one thing we might want to do

438
00:22:52,656 --> 00:22:55,856
IO形式的操作
is worry about the operations that are of IO form.

439
00:22:56,840 --> 00:23:01,424
我们需要从外部搜集一些东西
And we may have to collect something from the outside.

440
00:23:01,980 --> 00:23:03,936
因此 对我们的状态机器来说
So a state machine that we might have,

441
00:23:04,300 --> 00:23:07,024
它们的控制器
the controller may have to,

442
00:23:07,264 --> 00:23:10,560
可能会从某处取得某值
may have to, for example, get a value from something

443
00:23:10,784 --> 00:23:12,416
将它们放入寄存器并从中读取
and put register a to load it up.

444
00:23:13,490 --> 00:23:15,920
我还可以把另外的值加载到寄存器B中
I have to master load up register b with another value.

445
00:23:17,070 --> 00:23:18,608
稍后 当执行完毕后
And then later, when I'm done,

446
00:23:18,992 --> 00:23:20,528
我想要输出结果
I might want to print the answer out.

447
00:23:21,200 --> 00:23:25,232
当然 答案或简单或复杂
And of course, that might be either simple or complicated.

448
00:23:26,090 --> 00:23:28,032
我写代码的时候 总假设PRINT很简单
I'm writing, assuming print is very simple,

449
00:23:28,096 --> 00:23:29,296
READ也很简单
and read is very simple.

450
00:23:29,880 --> 00:23:31,088
但实际上 在真实世界中
But in fact, in the real world,

451
00:23:31,120 --> 00:23:32,896
这些都是非常复杂的操作
those are very complicated operations,

452
00:23:33,080 --> 00:23:35,520
跟你尝试求解的问题相比
fairly, usually much, much larger and more complicated

453
00:23:35,552 --> 00:23:38,330
它们通常更加庞大而复杂
than the thing you're doing as your problem you're trying to solve.

454
00:23:41,670 --> 00:23:43,904
另一方面 我犹记得
On the other hand, I can remember a time when,

455
00:23:44,896 --> 00:23:48,784
使用IBM 7090一类的计算机的时候
I remember using IBM 7090 computer of sorts,

456
00:23:49,056 --> 00:23:53,040
它的READ和WRITE只能操作单个对象
where things like read and write of a single object,

457
00:23:53,088 --> 00:23:54,624
也就是一个数字
a single number, a number,

458
00:23:55,840 --> 00:23:58,544
这就是一个基本的IO操作
is a primitive operation of the IO controller.

459
00:23:59,632 --> 00:24:02,048
我们这里有同样的操作
OK? And so we have that kind of thing in there.

460
00:24:02,330 --> 00:24:04,672
在这样的一台机器中
And in such a machine,

461
00:24:05,440 --> 00:24:06,896
我们实际上在做什么？
well, what are we really doing?

462
00:24:07,120 --> 00:24:11,600
我们看到 这个叫做“READ”的组件是数据源头
We're just saying that there's a source over here called "read"

463
00:24:12,208 --> 00:24:14,464
这个操作总是返回一个值
which is an operation which always has a value.

464
00:24:14,660 --> 00:24:17,136
我们可以把它看做 总是返回一个值
We have to think about this as always having a value

465
00:24:17,216 --> 00:24:19,840
它可以赋给寄存器A或B
which can be gated into either register a or b.

466
00:24:21,660 --> 00:24:23,232
而PRINT这个过程呢
And print is some sort of thing

467
00:24:23,376 --> 00:24:25,024
#TBD
which when you gate it appropriately,

468
00:24:25,248 --> 00:24:26,432
当你按下上面的按钮
when you push the button on it,

469
00:24:26,656 --> 00:24:29,616
就会打印出当前寄存器A中的值
will cause a print of the value that's currently in register a.

470
00:24:31,660 --> 00:24:32,736
这非常普通
Nothing very exciting.

471
00:24:33,328 --> 00:24:35,200
这是我们想要的一种功能
So that's one sort of thing you might want to have.

472
00:24:35,888 --> 00:24:38,320
#TBD
But these are also other things that are a little bit worrisome.

473
00:24:38,320 --> 00:24:40,672
比如说 这里我使用了一些复杂的机制
Like I've used here some complicated mechanisms.

474
00:24:41,050 --> 00:24:42,480
我们这里有REMAINDER组件
What you see here is remainder.

475
00:24:43,850 --> 00:24:44,448
这是个什么东西呢？
What is that?

476
00:24:44,690 --> 00:24:46,416
求取余数的计算过程并不是那么“显然”
That may not be so obvious how to compute.

477
00:24:46,920 --> 00:24:48,928
如果我们把这个组件给拆开
It may be something which when you open it up,

478
00:24:49,488 --> 00:24:50,624
就会得到一整台机器
you get a whole machine.

479
00:24:51,840 --> 00:24:53,664
事实就是这样的
OK? In fact, that's true.

480
00:24:54,540 --> 00:24:59,152
举例来说 如果要编程实现REMAINDER
For example, if I write down the program for remainder,

481
00:24:59,440 --> 00:25:02,440
最简单的算法就是 不断地做减法
the simplest program for it is by repeated subtraction.

482
00:25:04,780 --> 00:25:05,952
这是因为 除法可以通过
Because of course, division can be done

483
00:25:05,968 --> 00:25:08,990
对整数不断做减法来实现
by repeated subtraction of numbers, of integers.

484
00:25:09,800 --> 00:25:23,584
N除以D的余数不外乎就是
So the remainder of N divided by D

485
00:25:24,992 --> 00:25:31,440
如果N小于D的话
is nothing more than if N is less than D,

486
00:25:32,240 --> 00:25:33,664
答案就是N
then the result is N.

487
00:25:34,304 --> 00:25:35,904
否则的话就是
Otherwise, it's the remainder

488
00:25:41,150 --> 00:25:47,600
N先减去D
when we subtract D from N with respect to D,

489
00:25:48,272 --> 00:25:49,328
再除以D的余数
when divided by D.

490
00:25:51,280 --> 00:25:55,056
天啊 这个看起来就像是GCD程序
Gee, this looks just like the GCD program.

491
00:25:56,890 --> 00:25:59,488
当然 这个不是求余数的最优算法
Of course, it's not a very nice way to do remainders.

492
00:25:59,750 --> 00:26:00,912
在实际中 你应该使用那些
You'd really want to use something like

493
00:26:00,920 --> 00:26:05,424
二进制运算、移位运算等操作
binary notation and shift and things like that in a practical computer.

494
00:26:05,550 --> 00:26:06,976
但关键点就是
But the point of that is

495
00:26:07,136 --> 00:26:08,480
如果我把这些组件打开
that if I open this thing up,

496
00:26:08,928 --> 00:26:10,640
我可能会发现其中有一台计算机
I might find inside of it a computer.

497
00:26:11,880 --> 00:26:12,992
现在我们就知道它的原理了
Oh, we know how to do that.

498
00:26:13,510 --> 00:26:14,336
因为我们就造过一台
We just made one.

499
00:26:15,640 --> 00:26:17,104
这些个机器都大同小异
And it could be another thing just like this.

500
00:26:17,400 --> 00:26:18,064
另外一方面
On the other hand,

501
00:26:18,080 --> 00:26:21,680
On the other hand, we might want to make a more efficient or better-structured machine, or maybe make use of some of the registers more than once, or some horrible mess like that that hardware designers like to do, and for very good reasons.

502
00:26:21,856 --> 00:26:27,056
On the other hand, we might want to make a more efficient or better-structured machine, or maybe make use of some of the registers more than once, or some horrible mess like that that hardware designers like to do, and for very good reasons.

503
00:26:27,312 --> 00:26:28,608
On the other hand, we might want to make a more efficient or better-structured machine, or maybe make use of some of the registers more than once, or some horrible mess like that that hardware designers like to do, and for very good reasons.

504
00:26:29,250 --> 00:26:31,568
So for example, here's a machine that you see, which you're not supposed to be able to read.

505
00:26:32,528 --> 00:26:34,912
So for example, here's a machine that you see, which you're not supposed to be able to read.

506
00:26:35,050 --> 00:26:37,520
It's a little bit complicated. OK?

507
00:26:37,520 --> 00:26:39,872
But what it is is the integration of the remainder into the GCD machine.

508
00:26:40,096 --> 00:26:43,824
But what it is is the integration of the remainder into the GCD machine.

509
00:26:44,464 --> 00:26:46,020
And it takes, in fact, no more registers.

510
00:26:46,020 --> 00:26:48,624
There are three registers in the datapaths.

511
00:26:49,050 --> 00:26:50,640
But now there's a subtractor.

512
00:26:51,550 --> 00:26:52,992
There are two things that are tested.

513
00:26:53,020 --> 00:26:55,072
Is b equal to 0, or is t less than b?

514
00:26:55,232 --> 00:26:56,560
Is b equal to 0, or is t less than b?

515
00:26:57,250 --> 00:26:59,456
And then the controller, which you see over here, is not much more complicated.

516
00:27:00,224 --> 00:27:01,760
And then the controller, which you see over here, is not much more complicated.

517
00:27:01,850 --> 00:27:03,872
But it has two loops in it, one of which is the main one for doing the GCD, and one of which is the subtraction loop for doing the remainder sub-operation.

518
00:27:04,528 --> 00:27:08,336
But it has two loops in it, one of which is the main one for doing the GCD, and one of which is the subtraction loop for doing the remainder sub-operation.

519
00:27:08,400 --> 00:27:10,144
But it has two loops in it, one of which is the main one for doing the GCD, and one of which is the subtraction loop for doing the remainder sub-operation.

520
00:27:10,432 --> 00:27:12,800
But it has two loops in it, one of which is the main one for doing the GCD, and one of which is the subtraction loop for doing the remainder sub-operation.

521
00:27:14,030 --> 00:27:15,808
And there are ways, of course, of, if you think about it, taking the remainder program.

522
00:27:15,968 --> 00:27:18,688
And there are ways, of course, of, if you think about it, taking the remainder program.

523
00:27:19,920 --> 00:27:20,960
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

524
00:27:20,992 --> 00:27:22,832
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

525
00:27:23,568 --> 00:27:27,024
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

526
00:27:28,208 --> 00:27:30,128
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

527
00:27:30,320 --> 00:27:33,664
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

528
00:27:34,464 --> 00:27:35,952
If I take remainder, as you see over there, as a lambda expression, substitute it in for remainder over here in the GCD program, then do some simplification by substituting a and b for remainder in there, then I can unwind this loop.

529
00:27:36,630 --> 00:27:39,424
And I can get this piece of machinery by basically, a little bit of algebraic simplification on the lambda expressions.

530
00:27:40,736 --> 00:27:42,944
And I can get this piece of machinery by basically, a little bit of algebraic simplification on the lambda expressions.

531
00:27:43,360 --> 00:27:45,216
And I can get this piece of machinery by basically, a little bit of algebraic simplification on the lambda expressions.

532
00:27:48,550 --> 00:27:51,200
So I suppose you've seen your first very simple machines now.

533
00:27:51,952 --> 00:27:53,280
Are there any questions?

534
00:28:02,700 --> 00:28:03,104
Good.

535
00:28:05,360 --> 00:28:06,544
This looks easy, doesn't it?

536
00:28:10,144 --> 00:28:11,328
Thank you. I suppose, take a break.

537
00:28:11,350 --> 00:28:13,010
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

538
00:28:47,936 --> 00:28:48,704
PROFESSOR: Well, let's see.

539
00:28:49,376 --> 00:28:52,464
Now you know how to make an iterative procedure, or a procedure that yields an iterative process, turn into a machine.

540
00:28:52,544 --> 00:28:54,544
Now you know how to make an iterative procedure, or a procedure that yields an iterative process, turn into a machine.

541
00:28:55,184 --> 00:28:56,528
Now you know how to make an iterative procedure, or a procedure that yields an iterative process, turn into a machine.

542
00:28:57,770 --> 00:29:00,048
I suppose the next thing we want to do is worry about things that reveal recursive processes.

543
00:29:00,544 --> 00:29:02,304
I suppose the next thing we want to do is worry about things that reveal recursive processes.

544
00:29:02,816 --> 00:29:05,056
So let's play with a simple factorial procedure.

545
00:29:11,200 --> 00:29:16,944
We define factorial of N to be if n is 1, the result is 1, using 1 right now to decrease the amount of work I have to do to simulate it, else it's times N factorial N minus 1.

546
00:29:19,632 --> 00:29:24,256
We define factorial of N to be if n is 1, the result is 1, using 1 right now to decrease the amount of work I have to do to simulate it, else it's times N factorial N minus 1.

547
00:29:24,624 --> 00:29:27,696
We define factorial of N to be if n is 1, the result is 1, using 1 right now to decrease the amount of work I have to do to simulate it, else it's times N factorial N minus 1.

548
00:29:28,128 --> 00:29:33,940
We define factorial of N to be if n is 1, the result is 1, using 1 right now to decrease the amount of work I have to do to simulate it, else it's times N factorial N minus 1.

549
00:29:42,520 --> 00:29:46,048
And what's different with this program, as you know, is that after I've computed factorial of N minus 1 here, I have to do something to the result.

550
00:29:46,656 --> 00:29:50,368
And what's different with this program, as you know, is that after I've computed factorial of N minus 1 here, I have to do something to the result.

551
00:29:50,672 --> 00:29:52,260
And what's different with this program, as you know, is that after I've computed factorial of N minus 1 here, I have to do something to the result.

552
00:29:52,260 --> 00:29:53,680
I have to multiply it by N.

553
00:29:56,000 --> 00:29:58,880
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

554
00:29:59,136 --> 00:30:00,592
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

555
00:30:01,088 --> 00:30:02,016
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

556
00:30:02,352 --> 00:30:03,184
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

557
00:30:03,360 --> 00:30:04,944
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

558
00:30:05,088 --> 00:30:08,112
So the only way I can visualize what this machine is doing, because of the fact-- think of it this way, that I have a machine out here which somehow needs a factorial machine in order to compute its answer.

559
00:30:09,320 --> 00:30:11,168
But this machine, the outer machine, has to exist before and after the factorial machine, which is inside.

560
00:30:11,200 --> 00:30:13,136
But this machine, the outer machine, has to exist before and after the factorial machine, which is inside.

561
00:30:13,904 --> 00:30:15,712
But this machine, the outer machine, has to exist before and after the factorial machine, which is inside.

562
00:30:16,800 --> 00:30:17,904
Whereas in the iterative case, the outer machine doesn't need to exist after the inner machine is running, because you never need to go back to the outer machine to do anything.

563
00:30:18,752 --> 00:30:20,528
Whereas in the iterative case, the outer machine doesn't need to exist after the inner machine is running, because you never need to go back to the outer machine to do anything.

564
00:30:20,912 --> 00:30:24,016
Whereas in the iterative case, the outer machine doesn't need to exist after the inner machine is running, because you never need to go back to the outer machine to do anything.

565
00:30:24,832 --> 00:30:27,536
Whereas in the iterative case, the outer machine doesn't need to exist after the inner machine is running, because you never need to go back to the outer machine to do anything.

566
00:30:28,640 --> 00:30:30,064
So here we have a problem where we have a machine which has the same machine inside of it, an infinitely large machine.

567
00:30:30,272 --> 00:30:32,736
So here we have a problem where we have a machine which has the same machine inside of it, an infinitely large machine.

568
00:30:33,872 --> 00:30:35,520
So here we have a problem where we have a machine which has the same machine inside of it, an infinitely large machine.

569
00:30:40,390 --> 00:30:43,120
And it's got other things inside of it, like a multiplier, which takes some inputs, and there's a minus 1 box, and things like that.

570
00:30:44,768 --> 00:30:46,032
And it's got other things inside of it, like a multiplier, which takes some inputs, and there's a minus 1 box, and things like that.

571
00:30:46,272 --> 00:30:47,776
And it's got other things inside of it, like a multiplier, which takes some inputs, and there's a minus 1 box, and things like that.

572
00:30:48,128 --> 00:30:49,312
And it's got other things inside of it, like a multiplier, which takes some inputs, and there's a minus 1 box, and things like that.

573
00:30:50,690 --> 00:30:53,728
You can imagine that's what it looks like.

574
00:30:54,370 --> 00:30:56,768
But the important thing is that here I have something that happens before and after, in the outer machine, the execution of the inner machine.

575
00:30:57,024 --> 00:30:59,904
But the important thing is that here I have something that happens before and after, in the outer machine, the execution of the inner machine.

576
00:31:00,176 --> 00:31:01,600
But the important thing is that here I have something that happens before and after, in the outer machine, the execution of the inner machine.

577
00:31:02,540 --> 00:31:04,080
So this machine has to have a life.

578
00:31:05,570 --> 00:31:07,568
It has to exist on both times sides of this machine.

579
00:31:08,608 --> 00:31:11,440
It has to exist on both times sides of this machine.

580
00:31:13,490 --> 00:31:15,808
So somehow, I have to have a place to store the things that this thing needs to run.

581
00:31:16,192 --> 00:31:18,192
So somehow, I have to have a place to store the things that this thing needs to run.

582
00:31:20,030 --> 00:31:22,096
Infinite objects don't exist in the real world.

583
00:31:24,140 --> 00:31:25,584
What we have to do is arrange an illusion that we have an infinite object, we have an infinite amount of hardware somewhere.

584
00:31:26,128 --> 00:31:27,488
What we have to do is arrange an illusion that we have an infinite object, we have an infinite amount of hardware somewhere.

585
00:31:27,984 --> 00:31:29,776
What we have to do is arrange an illusion that we have an infinite object, we have an infinite amount of hardware somewhere.

586
00:31:31,830 --> 00:31:35,344
Now of course, illusion's all that really matters.

587
00:31:36,280 --> 00:31:40,320
If we can arrange that every time you look at some infinite object, the part of it that you look at is there, then it's as infinite as you need it to be.

588
00:31:40,976 --> 00:31:46,048
If we can arrange that every time you look at some infinite object, the part of it that you look at is there, then it's as infinite as you need it to be.

589
00:31:47,390 --> 00:31:49,440
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

590
00:31:49,824 --> 00:31:52,496
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

591
00:31:53,008 --> 00:31:54,976
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

592
00:31:56,048 --> 00:31:57,648
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

593
00:31:57,920 --> 00:32:02,352
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

594
00:32:03,184 --> 00:32:04,464
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

595
00:32:04,784 --> 00:32:07,616
And of course, one of the things we might want to do, just look at this thing over here, is the organization that we've had so far involves having a part of the machine, which is the controller, which sits right over here, which is perfectly finite and very simple.

596
00:32:09,170 --> 00:32:10,448
We have some datapaths, which consist of registers and operators.

597
00:32:10,464 --> 00:32:12,752
We have some datapaths, which consist of registers and operators.

598
00:32:13,080 --> 00:32:15,200
And what I propose to do here is decompose the machine into two parts, such that there is a part which is fundamentally finite, and some part where a certain amount of infinite stuff can be kept.

599
00:32:15,488 --> 00:32:16,960
And what I propose to do here is decompose the machine into two parts, such that there is a part which is fundamentally finite, and some part where a certain amount of infinite stuff can be kept.

600
00:32:17,360 --> 00:32:19,792
And what I propose to do here is decompose the machine into two parts, such that there is a part which is fundamentally finite, and some part where a certain amount of infinite stuff can be kept.

601
00:32:20,784 --> 00:32:23,536
And what I propose to do here is decompose the machine into two parts, such that there is a part which is fundamentally finite, and some part where a certain amount of infinite stuff can be kept.

602
00:32:24,230 --> 00:32:25,904
On the other hand this is very simple and really isn't infinite, but it's just very large.

603
00:32:26,416 --> 00:32:28,720
On the other hand this is very simple and really isn't infinite, but it's just very large.

604
00:32:29,430 --> 00:32:30,400
But it's so simple

605
00:32:30,528 --> 00:32:32,928
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

606
00:32:34,096 --> 00:32:34,928
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

607
00:32:35,952 --> 00:32:39,072
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

608
00:32:39,408 --> 00:32:41,232
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

609
00:32:41,450 --> 00:32:43,632
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

610
00:32:43,648 --> 00:32:46,960
But it's so simple that it could be cheaply reproduced in such large amounts, we call it memory, that we can make a structure called a stack out of it which will allow us to, in fact, simulate the existence of an infinite machine which is made out of a recursive nest of many machines.

611
00:32:48,340 --> 00:32:49,440
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

612
00:32:49,936 --> 00:32:50,416
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

613
00:32:50,560 --> 00:32:52,976
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

614
00:32:54,352 --> 00:32:55,632
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

615
00:32:55,888 --> 00:32:57,600
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

616
00:32:59,184 --> 00:33:01,072
And the way it's going to work is that we're going to store in this place called the stack the information required after the inner machine runs to resume the operation of the outer machine.

617
00:33:03,840 --> 00:33:05,488
So it will remember the important things about the life of the outer machine that will be needed for this computation.

618
00:33:05,632 --> 00:33:07,952
So it will remember the important things about the life of the outer machine that will be needed for this computation.

619
00:33:08,048 --> 00:33:10,304
So it will remember the important things about the life of the outer machine that will be needed for this computation.

620
00:33:11,390 --> 00:33:12,480
Since, of course, these machines are nested in a recursive manner, then in fact the stack will only be accessed in a manner which is the last thing that goes in is the first thing that comes out.

621
00:33:12,752 --> 00:33:16,336
Since, of course, these machines are nested in a recursive manner, then in fact the stack will only be accessed in a manner which is the last thing that goes in is the first thing that comes out.

622
00:33:18,336 --> 00:33:20,912
Since, of course, these machines are nested in a recursive manner, then in fact the stack will only be accessed in a manner which is the last thing that goes in is the first thing that comes out.

623
00:33:21,712 --> 00:33:26,448
Since, of course, these machines are nested in a recursive manner, then in fact the stack will only be accessed in a manner which is the last thing that goes in is the first thing that comes out.

624
00:33:29,330 --> 00:33:30,640
So we'll only need to access some little part of this stack memory.

625
00:33:30,800 --> 00:33:32,528
So we'll only need to access some little part of this stack memory.

626
00:33:34,930 --> 00:33:35,920
OK, well, let's do it.

627
00:33:36,810 --> 00:33:38,416
I'm going to build you a datapath now, and I'm going to write the controller.

628
00:33:38,448 --> 00:33:39,680
I'm going to build you a datapath now, and I'm going to write the controller.

629
00:33:40,370 --> 00:33:42,864
And then we're going to execute this to see how you do it.

630
00:33:43,510 --> 00:33:46,880
So the factorial machine isn't so bad.

631
00:33:47,900 --> 00:33:50,160
It's going to have a register called the value, where the answer is going to be stored, and a registered called N, which is where the number I'm taking factorial will be stored, factorial of.

632
00:33:52,224 --> 00:33:53,888
It's going to have a register called the value, where the answer is going to be stored, and a registered called N, which is where the number I'm taking factorial will be stored, factorial of.

633
00:33:54,896 --> 00:33:56,672
It's going to have a register called the value, where the answer is going to be stored, and a registered called N, which is where the number I'm taking factorial will be stored, factorial of.

634
00:33:59,856 --> 00:34:04,160
It's going to have a register called the value, where the answer is going to be stored, and a registered called N, which is where the number I'm taking factorial will be stored, factorial of.

635
00:34:04,512 --> 00:34:06,624
And it will be necessary in some instances to connect VAL to N.

636
00:34:07,520 --> 00:34:10,544
And it will be necessary in some instances to connect VAL to N.

637
00:34:11,760 --> 00:34:13,632
In fact, one nice case of this is if I just said over here, N, because that would be right for N equal 1N.

638
00:34:13,760 --> 00:34:15,632
In fact, one nice case of this is if I just said over here, N, because that would be right for N equal 1N.

639
00:34:16,380 --> 00:34:19,536
In fact, one nice case of this is if I just said over here, N, because that would be right for N equal 1N.

640
00:34:20,090 --> 00:34:23,264
And I could just move the answer over there if that's important.

641
00:34:23,900 --> 00:34:25,552
I'm not worried about that right now.

642
00:34:26,980 --> 00:34:28,608
And there are things I have to be able to do.

643
00:34:29,060 --> 00:34:31,024
Like I have to be able to, as we see here, multiply N by something in VAL, because VAL is the result of computing factorial.

644
00:34:31,216 --> 00:34:34,672
Like I have to be able to, as we see here, multiply N by something in VAL, because VAL is the result of computing factorial.

645
00:34:34,912 --> 00:34:37,456
Like I have to be able to, as we see here, multiply N by something in VAL, because VAL is the result of computing factorial.

646
00:34:38,688 --> 00:34:40,448
And I have to put the result back into VAL.

647
00:34:41,488 --> 00:34:42,656
So here we can see that the result of computing a factorial is N times the result of computing a factorial.

648
00:34:42,832 --> 00:34:46,432
So here we can see that the result of computing a factorial is N times the result of computing a factorial.

649
00:34:46,576 --> 00:34:49,200
So here we can see that the result of computing a factorial is N times the result of computing a factorial.

650
00:34:50,690 --> 00:34:53,776
VAL will be the representation of the answer of the inner factorial.

651
00:34:55,190 --> 00:35:00,256
And so I'm going to have to have a multiplier here, which is going to sample the value of N and the value of VAL and put the result back into VAL like that.

652
00:35:02,368 --> 00:35:04,608
And so I'm going to have to have a multiplier here, which is going to sample the value of N and the value of VAL and put the result back into VAL like that.

653
00:35:05,744 --> 00:35:07,152
And so I'm going to have to have a multiplier here, which is going to sample the value of N and the value of VAL and put the result back into VAL like that.

654
00:35:08,640 --> 00:35:15,600
And so I'm going to have to have a multiplier here, which is going to sample the value of N and the value of VAL and put the result back into VAL like that.

655
00:35:17,170 --> 00:35:19,392
I'm also going to have to be able to see if N is 1.

656
00:35:21,328 --> 00:35:22,384
So I need a light bulb.

657
00:35:28,200 --> 00:35:30,400
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

658
00:35:31,024 --> 00:35:32,848
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

659
00:35:34,848 --> 00:35:36,096
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

660
00:35:38,368 --> 00:35:39,232
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

661
00:35:39,552 --> 00:35:41,392
And I suppose the other thing I'm going to need to have is a way of decrementing N. So I'm going to have a decrementer, which takes N and is going to put back the result into N.

662
00:35:46,620 --> 00:35:48,400
That's pretty much what I need in my machine.

663
00:35:49,550 --> 00:35:51,648
Now, there's a little bit else I need.

664
00:35:52,304 --> 00:35:53,584
It's a little bit more complicated, because I'm also going to need a way to store, to save away, the things that are going to be needed for resuming the computation of a factorial after I've done a sub-factorial.

665
00:35:55,168 --> 00:35:56,880
It's a little bit more complicated, because I'm also going to need a way to store, to save away, the things that are going to be needed for resuming the computation of a factorial after I've done a sub-factorial.

666
00:35:57,168 --> 00:35:59,696
It's a little bit more complicated, because I'm also going to need a way to store, to save away, the things that are going to be needed for resuming the computation of a factorial after I've done a sub-factorial.

667
00:36:01,024 --> 00:36:04,864
It's a little bit more complicated, because I'm also going to need a way to store, to save away, the things that are going to be needed for resuming the computation of a factorial after I've done a sub-factorial.

668
00:36:06,250 --> 00:36:06,864
What's that?

669
00:36:07,230 --> 00:36:08,736
One thing I need is N.

670
00:36:09,850 --> 00:36:12,048
So I'm going to build here a thing called a stack.

671
00:36:14,700 --> 00:36:15,680
The stack is a bunch of stuff that I'm going to write in sequentially.

672
00:36:17,984 --> 00:36:24,976
The stack is a bunch of stuff that I'm going to write in sequentially.

673
00:36:27,152 --> 00:36:28,592
I don't how long it is.

674
00:36:29,152 --> 00:36:31,488
The longer it is, the better my illusion of infinity.

675
00:36:33,232 --> 00:36:34,448
And I'm going to have to have a way of getting stuff out of N and into the stack and vice versa.

676
00:36:34,544 --> 00:36:37,024
And I'm going to have to have a way of getting stuff out of N and into the stack and vice versa.

677
00:36:38,128 --> 00:36:39,088
And I'm going to have to have a way of getting stuff out of N and into the stack and vice versa.

678
00:36:39,936 --> 00:36:41,744
So I'm going to need a connection like this, which is two-way, whereby I can save the value of N and then restore it some other time through that connection.

679
00:36:44,416 --> 00:36:45,488
So I'm going to need a connection like this, which is two-way, whereby I can save the value of N and then restore it some other time through that connection.

680
00:36:50,448 --> 00:36:52,224
So I'm going to need a connection like this, which is two-way, whereby I can save the value of N and then restore it some other time through that connection.

681
00:36:52,240 --> 00:36:55,504
So I'm going to need a connection like this, which is two-way, whereby I can save the value of N and then restore it some other time through that connection.

682
00:36:56,048 --> 00:36:56,848
This is the stack.

683
00:36:58,100 --> 00:36:59,280
I also need a way of remembering where I was in the computation of factorial in the outer program.

684
00:37:00,352 --> 00:37:03,744
I also need a way of remembering where I was in the computation of factorial in the outer program.

685
00:37:04,432 --> 00:37:07,712
I also need a way of remembering where I was in the computation of factorial in the outer program.

686
00:37:08,530 --> 00:37:10,064
Now in the case of this machine, it isn't very much a problem.

687
00:37:10,768 --> 00:37:13,344
Now in the case of this machine, it isn't very much a problem.

688
00:37:14,176 --> 00:37:16,240
Factorial always returns, has to go back to the place where we multiply by N, except for the last time, when it has to return to whatever needs the factorial or go to done or stop.

689
00:37:16,864 --> 00:37:19,072
Factorial always returns, has to go back to the place where we multiply by N, except for the last time, when it has to return to whatever needs the factorial or go to done or stop.

690
00:37:19,344 --> 00:37:20,720
Factorial always returns, has to go back to the place where we multiply by N, except for the last time, when it has to return to whatever needs the factorial or go to done or stop.

691
00:37:21,152 --> 00:37:24,048
Factorial always returns, has to go back to the place where we multiply by N, except for the last time, when it has to return to whatever needs the factorial or go to done or stop.

692
00:37:25,660 --> 00:37:26,672
However, in general, I'm going to have to remember where I have been, because I might have computed factorial from somewhere else.

693
00:37:27,168 --> 00:37:28,736
However, in general, I'm going to have to remember where I have been, because I might have computed factorial from somewhere else.

694
00:37:29,136 --> 00:37:31,248
However, in general, I'm going to have to remember where I have been, because I might have computed factorial from somewhere else.

695
00:37:32,080 --> 00:37:34,896
I have to go back to that place and continue there.

696
00:37:36,070 --> 00:37:38,000
So I'm going to have to have some way of taking the place where the marble is in the finite state controller, the state of the controller, and storing that in the stack as well.

697
00:37:38,016 --> 00:37:40,864
So I'm going to have to have some way of taking the place where the marble is in the finite state controller, the state of the controller, and storing that in the stack as well.

698
00:37:41,328 --> 00:37:42,640
So I'm going to have to have some way of taking the place where the marble is in the finite state controller, the state of the controller, and storing that in the stack as well.

699
00:37:44,224 --> 00:37:46,352
So I'm going to have to have some way of taking the place where the marble is in the finite state controller, the state of the controller, and storing that in the stack as well.

700
00:37:47,400 --> 00:37:49,104
And I'm going to have to have ways of restoring that back to the state of the-- the marble.

701
00:37:49,456 --> 00:37:51,120
And I'm going to have to have ways of restoring that back to the state of the-- the marble.

702
00:37:52,144 --> 00:37:54,288
So I have to have something that moves the marble to the right place.

703
00:37:54,704 --> 00:37:56,528
Well, we're going to have a place which is the marble now.

704
00:37:57,872 --> 00:37:59,344
And it's called the continue register, called continue, which is the place to put the marble next time I go to continue.

705
00:38:03,616 --> 00:38:04,528
And it's called the continue register, called continue, which is the place to put the marble next time I go to continue.

706
00:38:09,168 --> 00:38:13,056
And it's called the continue register, called continue, which is the place to put the marble next time I go to continue.

707
00:38:14,912 --> 00:38:15,920
That's what that's for.

708
00:38:16,140 --> 00:38:18,480
And so there's got to be some path from that into the controller.

709
00:38:22,910 --> 00:38:27,120
I also have to have some way of saving that on the stack.

710
00:38:29,456 --> 00:38:31,216
And I have to have some way of setting that up to have various constants, a certain fixed number of constants.

711
00:38:31,872 --> 00:38:33,008
And I have to have some way of setting that up to have various constants, a certain fixed number of constants.

712
00:38:34,016 --> 00:38:35,696
And I have to have some way of setting that up to have various constants, a certain fixed number of constants.

713
00:38:36,860 --> 00:38:38,208
And that's very easy to arrange.

714
00:38:38,840 --> 00:38:40,144
So let's have some constants here.

715
00:38:40,180 --> 00:38:41,504
We'll call this one after-fact.

716
00:38:47,328 --> 00:38:48,752
And that's a constant which we'll get into the continue register, and also another one called fact-done.

717
00:38:48,848 --> 00:38:51,504
And that's a constant which we'll get into the continue register, and also another one called fact-done.

718
00:38:52,592 --> 00:38:54,432
And that's a constant which we'll get into the continue register, and also another one called fact-done.

719
00:39:05,210 --> 00:39:07,824
So this is the machine I want to build.

720
00:39:08,130 --> 00:39:09,488
That's its datapaths, at least. And it mixes a little with the controller here, because of the fact that I have to remember where I was and restore myself to that place.

721
00:39:09,920 --> 00:39:11,696
That's its datapaths, at least. And it mixes a little with the controller here, because of the fact that I have to remember where I was and restore myself to that place.

722
00:39:11,856 --> 00:39:14,592
That's its datapaths, at least. And it mixes a little with the controller here, because of the fact that I have to remember where I was and restore myself to that place.

723
00:39:14,704 --> 00:39:16,352
That's its datapaths, at least. And it mixes a little with the controller here, because of the fact that I have to remember where I was and restore myself to that place.

724
00:39:17,300 --> 00:39:19,936
But let's write the program now which represents the controller.

725
00:39:20,390 --> 00:39:22,624
I'm not going to write the define machine thing and the register list, because that's not very interesting.

726
00:39:22,640 --> 00:39:23,456
I'm not going to write the define machine thing and the register list, because that's not very interesting.

727
00:39:23,488 --> 00:39:24,890
I'm not going to write the define machine thing and the register list, because that's not very interesting.

728
00:39:25,136 --> 00:39:29,024
I'm just going to write down the sequence of instructions that constitute the controller.

729
00:39:31,488 --> 00:39:41,856
So we have assign, to set up, continue to done.

730
00:39:45,152 --> 00:39:56,080
We have a loop which says branch if equal 1 fetch N, if N is 1, then go to the base step of the induction, the simple case.

731
00:40:00,944 --> 00:40:04,112
We have a loop which says branch if equal 1 fetch N, if N is 1, then go to the base step of the induction, the simple case.

732
00:40:06,064 --> 00:40:07,200
We have a loop which says branch if equal 1 fetch N, if N is 1, then go to the base step of the induction, the simple case.

733
00:40:08,050 --> 00:40:08,768
Otherwise, I have to remember the things that are necessary to perform a sub-factorial.

734
00:40:08,880 --> 00:40:13,840
Otherwise, I have to remember the things that are necessary to perform a sub-factorial.

735
00:40:14,640 --> 00:40:15,184
I'm going to go over here, and I have to perform a sub-factorial.

736
00:40:15,200 --> 00:40:16,830
I'm going to go over here, and I have to perform a sub-factorial.

737
00:40:17,570 --> 00:40:19,296
So I have to remember what's needed after I will be done with that.

738
00:40:19,712 --> 00:40:22,528
So I have to remember what's needed after I will be done with that.

739
00:40:24,000 --> 00:40:25,510
See, I'm about to do something terrible.

740
00:40:25,728 --> 00:40:27,392
I'm about to change the value of N. But this guy has to know the old value of N. But in order to make the sub-factorial work, I have to change the value of N. So I have to remember the old value.

741
00:40:28,576 --> 00:40:30,400
I'm about to change the value of N. But this guy has to know the old value of N. But in order to make the sub-factorial work, I have to change the value of N. So I have to remember the old value.

742
00:40:32,144 --> 00:40:34,928
I'm about to change the value of N. But this guy has to know the old value of N. But in order to make the sub-factorial work, I have to change the value of N. So I have to remember the old value.

743
00:40:35,600 --> 00:40:37,104
I'm about to change the value of N. But this guy has to know the old value of N. But in order to make the sub-factorial work, I have to change the value of N. So I have to remember the old value.

744
00:40:38,000 --> 00:40:39,600
And I also have to remember where I've been.

745
00:40:40,850 --> 00:40:42,320
So I save up continue.

746
00:40:47,700 --> 00:40:51,296
And this is an instruction that says, put something in the stack.

747
00:40:53,120 --> 00:40:55,536
Save the contents of the continuation register, which in this case is done, because later I'm going to change that, too, because I need to go back to after-fact, as well.

748
00:40:56,512 --> 00:40:58,000
Save the contents of the continuation register, which in this case is done, because later I'm going to change that, too, because I need to go back to after-fact, as well.

749
00:40:58,880 --> 00:41:02,784
Save the contents of the continuation register, which in this case is done, because later I'm going to change that, too, because I need to go back to after-fact, as well.

750
00:41:03,550 --> 00:41:04,192
We'll see that.

751
00:41:05,040 --> 00:41:09,712
We save N, because I'm going to need that for later.

752
00:41:10,380 --> 00:41:20,544
Assign to N the decrement of fetch N. Assign continue, we're going to look at this now, to after, we'll call it.

753
00:41:23,264 --> 00:41:28,976
Assign to N the decrement of fetch N. Assign continue, we're going to look at this now, to after, we'll call it.

754
00:41:32,128 --> 00:41:33,424
Assign to N the decrement of fetch N. Assign continue, we're going to look at this now, to after, we'll call it.

755
00:41:34,064 --> 00:41:35,616
Assign to N the decrement of fetch N. Assign continue, we're going to look at this now, to after, we'll call it.

756
00:41:37,690 --> 00:41:38,704
That's a good name for this, a little bit easier and shorter, and fits in here.

757
00:41:38,736 --> 00:41:40,656
That's a good name for this, a little bit easier and shorter, and fits in here.

758
00:41:53,360 --> 00:41:54,640
Now look what I'm doing here.

759
00:41:55,330 --> 00:41:57,020
I'm saying, if the answer is 1, I'm done.

760
00:41:58,720 --> 00:41:59,664
I'm saying, if the answer is 1, I'm done.

761
00:42:00,464 --> 00:42:01,664
I'm going to have to just get the answer.

762
00:42:02,150 --> 00:42:04,880
Otherwise, I'm going to save the continuation, save N, make N one less than N, remember I'm going to come back to someplace else, and go back and start doing another factorial.

763
00:42:05,776 --> 00:42:07,328
Otherwise, I'm going to save the continuation, save N, make N one less than N, remember I'm going to come back to someplace else, and go back and start doing another factorial.

764
00:42:07,600 --> 00:42:09,632
Otherwise, I'm going to save the continuation, save N, make N one less than N, remember I'm going to come back to someplace else, and go back and start doing another factorial.

765
00:42:09,648 --> 00:42:11,488
Otherwise, I'm going to save the continuation, save N, make N one less than N, remember I'm going to come back to someplace else, and go back and start doing another factorial.

766
00:42:13,504 --> 00:42:15,744
However, I've got a different machine [? in me ?] now.

767
00:42:16,050 --> 00:42:18,380
N is 1, and continue is something else.

768
00:42:22,112 --> 00:42:23,216
N is N minus 1.

769
00:42:23,770 --> 00:42:25,280
Now after I'm done with that, I can go there.

770
00:42:26,944 --> 00:42:27,760
Now after I'm done with that, I can go there.

771
00:42:28,660 --> 00:42:30,464
I will restore the old value of N, which is the opposite of this save over here.

772
00:42:32,688 --> 00:42:36,560
I will restore the old value of N, which is the opposite of this save over here.

773
00:42:38,360 --> 00:42:39,888
I will restore the continuation.

774
00:42:49,660 --> 00:42:52,576
I will then go to here.

775
00:42:54,320 --> 00:43:00,864
I will assign to the VAL register the product of N and fetch VAL.

776
00:43:01,168 --> 00:43:08,130
I will assign to the VAL register the product of N and fetch VAL.

777
00:43:13,440 --> 00:43:18,304
VAL fetch product assign.

778
00:43:19,790 --> 00:43:21,440
And then I will be done.

779
00:43:21,440 --> 00:43:25,680
I will have my answer to the sub-factorial in VAL.

780
00:43:26,570 --> 00:43:27,376
At that point, I'm going to return by going to the place where the continuation is pointing.

781
00:43:27,664 --> 00:43:31,616
At that point, I'm going to return by going to the place where the continuation is pointing.

782
00:43:33,640 --> 00:43:35,776
That says, go to fetch continue.

783
00:43:45,870 --> 00:43:47,408
And then I have finally a base step, which is the immediate answer.

784
00:43:49,312 --> 00:43:50,512
And then I have finally a base step, which is the immediate answer.

785
00:43:50,680 --> 00:43:56,880
Assign to VAL fetch N, and go to fetch continue.

786
00:44:01,360 --> 00:44:02,752
Assign to VAL fetch N, and go to fetch continue.

787
00:44:12,670 --> 00:44:13,552
And then I'm done.

788
00:44:18,640 --> 00:44:21,216
Now let's see how this executes on a very simple case, because then we'll see the use of this stack to do the job we need.

789
00:44:22,512 --> 00:44:23,536
Now let's see how this executes on a very simple case, because then we'll see the use of this stack to do the job we need.

790
00:44:23,664 --> 00:44:26,528
Now let's see how this executes on a very simple case, because then we'll see the use of this stack to do the job we need.

791
00:44:26,890 --> 00:44:29,808
This is statically what it's doing, but we have look dynamically at this.

792
00:44:31,340 --> 00:44:32,096
So let's see.

793
00:44:32,300 --> 00:44:34,560
First thing we do is continue gets done.

794
00:44:36,730 --> 00:44:38,096
The way that happened is I pushed this.

795
00:44:38,300 --> 00:44:39,600
Let's call that done the way I have it.

796
00:44:46,336 --> 00:44:47,030
I push that button.

797
00:44:47,030 --> 00:44:48,112
Done goes into there.

798
00:44:48,950 --> 00:44:53,712
Now I also have to set this thing up to have an initial value.

799
00:44:53,850 --> 00:44:58,080
Let's consider a factorial of three, a simple case.

800
00:44:58,384 --> 00:44:59,248
Let's consider a factorial of three, a simple case.

801
00:45:00,544 --> 00:45:04,048
And we're going to start out with our stack growing over here.

802
00:45:05,900 --> 00:45:07,760
Stacks have their own little internal state saying where they are, where the next place I'm going to write is.

803
00:45:07,792 --> 00:45:09,056
Stacks have their own little internal state saying where they are, where the next place I'm going to write is.

804
00:45:09,808 --> 00:45:11,648
Stacks have their own little internal state saying where they are, where the next place I'm going to write is.

805
00:45:12,770 --> 00:45:14,590
So now we say, is N 1?

806
00:45:14,768 --> 00:45:15,712
The answer is no.

807
00:45:16,110 --> 00:45:18,560
So now I'm going to save continue, bang.

808
00:45:19,152 --> 00:45:20,656
Now that done goes in here.

809
00:45:22,080 --> 00:45:23,552
And this moves to here, the next place I'm going to write.

810
00:45:24,880 --> 00:45:26,144
And this moves to here, the next place I'm going to write.

811
00:45:26,660 --> 00:45:28,784
Save N 3.

812
00:45:29,950 --> 00:45:30,320
OK?

813
00:45:30,672 --> 00:45:33,616
Assign to N the decrement of N. That means I've pushed this button.

814
00:45:33,968 --> 00:45:35,376
Assign to N the decrement of N. That means I've pushed this button.

815
00:45:35,940 --> 00:45:37,320
This becomes 2.

816
00:45:38,736 --> 00:45:42,288
Assign to continue aft.

817
00:45:42,580 --> 00:45:43,610
So I've pushed that button.

818
00:45:43,610 --> 00:45:44,544
Aft goes in here.

819
00:45:49,140 --> 00:45:53,936
OK, now go to loop, bang, so up to here.

820
00:45:54,830 --> 00:45:56,570
Is N 1?

821
00:45:56,570 --> 00:45:57,040
No.

822
00:45:57,780 --> 00:45:59,232
So I have to save continue.

823
00:45:59,490 --> 00:46:00,272
What's continue?

824
00:46:00,600 --> 00:46:01,530
Continue is aft.

825
00:46:01,530 --> 00:46:02,320
Push this button.

826
00:46:02,780 --> 00:46:03,952
So this moves to here.

827
00:46:08,490 --> 00:46:09,744
I have to save N. N is over here.

828
00:46:10,512 --> 00:46:11,460
I have to save N. N is over here.

829
00:46:11,460 --> 00:46:12,144
I got to 2.

830
00:46:12,280 --> 00:46:13,376
Push that button.

831
00:46:13,856 --> 00:46:15,248
So a 2 gets written there.

832
00:46:16,050 --> 00:46:17,648
And then this thing moves down here.

833
00:46:20,060 --> 00:46:22,608
OK, save N. Assign N to the decrement of N.

834
00:46:24,608 --> 00:46:25,460
This becomes a 1.

835
00:46:29,240 --> 00:46:30,544
Assign continue to aft.

836
00:46:31,370 --> 00:46:34,480
A-F-T gets written there again.

837
00:46:34,960 --> 00:46:35,648
Go to loop.

838
00:46:36,520 --> 00:46:37,744
Is N equal to 1?

839
00:46:37,930 --> 00:46:39,520
Oh, yes, the answer is 1.

840
00:46:41,040 --> 00:46:43,264
OK, go to base step.

841
00:46:44,160 --> 00:46:45,776
Assign to VAL fetch of N. Bang, 1 gets put in there.

842
00:46:46,560 --> 00:46:50,720
Assign to VAL fetch of N. Bang, 1 gets put in there.

843
00:46:51,100 --> 00:46:52,200
Go to fetch continue.

844
00:46:52,200 --> 00:46:53,536
So we look in continue.

845
00:46:53,680 --> 00:46:56,064
Basically, I'm pushing a button over here that goes to the controller.

846
00:46:56,670 --> 00:46:58,288
The continue becomes aft, and all of a sudden, the program's running here.

847
00:46:58,320 --> 00:47:00,256
The continue becomes aft, and all of a sudden, the program's running here.

848
00:47:02,640 --> 00:47:05,632
I now have to restore the outer version of factorial.

849
00:47:06,650 --> 00:47:07,550
So we go here.

850
00:47:07,550 --> 00:47:09,488
We say, restore N. So restore N means take the contents that's here.

851
00:47:10,320 --> 00:47:13,040
We say, restore N. So restore N means take the contents that's here.

852
00:47:13,940 --> 00:47:18,176
Push this button, and it goes into here, 2, and the pointer moves up.

853
00:47:18,560 --> 00:47:20,048
Push this button, and it goes into here, 2, and the pointer moves up.

854
00:47:21,136 --> 00:47:24,496
Restore continue, pretty easy.

855
00:47:24,810 --> 00:47:26,496
Go push this button.

856
00:47:27,020 --> 00:47:28,928
And then aft gets written in here again.

857
00:47:31,280 --> 00:47:32,640
That means this thing moves up.

858
00:47:32,640 --> 00:47:35,190
I've gotten rid of something else on my stack.

859
00:47:42,240 --> 00:47:43,472
Right, then I go to here, which says, assign to VAL the product of N an VAL.

860
00:47:43,872 --> 00:47:47,152
Right, then I go to here, which says, assign to VAL the product of N an VAL.

861
00:47:47,850 --> 00:47:50,576
So I push this button over here, bang.

862
00:47:50,970 --> 00:47:52,912
2 times 1 gives me a 2, get written there.

863
00:47:54,016 --> 00:47:54,752
2 times 1 gives me a 2, get written there.

864
00:47:55,760 --> 00:47:57,200
OK? Go to fetch continue.

865
00:47:57,540 --> 00:47:59,856
Continue is aft. I go to aft.

866
00:48:01,150 --> 00:48:03,888
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

867
00:48:04,368 --> 00:48:05,728
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

868
00:48:05,872 --> 00:48:08,448
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

869
00:48:09,248 --> 00:48:10,336
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

870
00:48:10,600 --> 00:48:11,770
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

871
00:48:15,040 --> 00:48:17,296
Aft says restore N. Do your restore N, means I take the value over here, which is 3, push this up to here, and move it into here, N. Now it's pushing that button.

872
00:48:18,016 --> 00:48:19,904
The next thing I do is restore continue.

873
00:48:20,200 --> 00:48:22,208
Continue is now going to become done.

874
00:48:22,830 --> 00:48:26,784
So this moves up here when I push this button.

875
00:48:27,130 --> 00:48:31,552
Done may or may be there anymore, I'm not interested, but it certainly is here.

876
00:48:35,800 --> 00:48:38,120
Next thing I do is assign to VAL the product of the fetch of N and the fetch of VAL.

877
00:48:38,432 --> 00:48:40,768
Next thing I do is assign to VAL the product of the fetch of N and the fetch of VAL.

878
00:48:41,440 --> 00:48:44,300
That's pushing this button over here, bang.

879
00:48:44,300 --> 00:48:45,776
2 times 3 is 6.

880
00:48:46,520 --> 00:48:47,870
So I get a 6 over here.

881
00:48:50,976 --> 00:48:53,408
And go to fetch continue, whoops, I go to done, and I'm done.

882
00:48:53,488 --> 00:48:54,832
And go to fetch continue, whoops, I go to done, and I'm done.

883
00:48:55,020 --> 00:48:56,096
And my answer is 6, as you can see in the VAL register.

884
00:48:56,608 --> 00:48:57,824
And my answer is 6, as you can see in the VAL register.

885
00:48:58,950 --> 00:48:59,824
And in fact, the stack is in the state it originally was in.

886
00:49:00,912 --> 00:49:03,344
And in fact, the stack is in the state it originally was in.

887
00:49:08,208 --> 00:49:10,704
Now there's a bit of discipline in using these things like stacks that we have to be careful of.

888
00:49:11,200 --> 00:49:12,272
Now there's a bit of discipline in using these things like stacks that we have to be careful of.

889
00:49:13,620 --> 00:49:15,520
And we'll see that in the next segment.

890
00:49:16,260 --> 00:49:18,464
But first I want to ask if there are any questions for this.

891
00:49:28,560 --> 00:49:29,648
Are there any questions?

892
00:49:30,170 --> 00:49:30,630
Yes, Ron.

893
00:49:30,630 --> 00:49:33,376
AUDIENCE: What happens when you roll off the end of the stack with-- PROFESSOR: What do you mean, roll off of?

894
00:49:33,392 --> 00:49:34,624
AUDIENCE: What happens when you roll off the end of the stack with-- PROFESSOR: What do you mean, roll off of?

895
00:49:35,030 --> 00:49:37,504
AUDIENCE: Well, the largest number-- a larger starting point of N requires more memory, correct?

896
00:49:37,520 --> 00:49:38,720
AUDIENCE: Well, the largest number-- a larger starting point of N requires more memory, correct?

897
00:49:38,860 --> 00:49:39,440
PROFESSOR: Oh, yes.

898
00:49:39,440 --> 00:49:41,120
Well, I need to have a long enough stack.

899
00:49:41,530 --> 00:49:43,200
You say, what if I violate my illusion?

900
00:49:43,840 --> 00:49:44,128
AUDIENCE: Yes.

901
00:49:44,550 --> 00:49:46,736
PROFESSOR: Well, then the magic doesn't work.

902
00:49:47,968 --> 00:49:51,008
The truth of the matter is that every machine is finite.

903
00:49:51,640 --> 00:49:53,728
And for a procedure like this, there's a limit to the number of sub-factorials I could have.

904
00:49:54,176 --> 00:49:58,864
And for a procedure like this, there's a limit to the number of sub-factorials I could have.

905
00:49:59,950 --> 00:50:02,480
Remember when we were doing the y-operator a while ago, we pointed out that there was a sequence of exponentiation procedures, each of which was a little better than the previous one.

906
00:50:02,800 --> 00:50:06,224
Remember when we were doing the y-operator a while ago, we pointed out that there was a sequence of exponentiation procedures, each of which was a little better than the previous one.

907
00:50:06,256 --> 00:50:08,096
Remember when we were doing the y-operator a while ago, we pointed out that there was a sequence of exponentiation procedures, each of which was a little better than the previous one.

908
00:50:08,720 --> 00:50:11,600
Well, we're now seeing how we implement that mathematical idea.

909
00:50:13,090 --> 00:50:14,192
The limiting process is only so good as as far as you take the limit.

910
00:50:14,352 --> 00:50:16,336
The limiting process is only so good as as far as you take the limit.

911
00:50:17,990 --> 00:50:19,420
If you think about it, what am I using here?

912
00:50:19,420 --> 00:50:22,656
I'm using about two pieces of memory for every recursion of this process.

913
00:50:23,040 --> 00:50:27,072
I'm using about two pieces of memory for every recursion of this process.

914
00:50:29,100 --> 00:50:31,712
If we try to compute factorial of 10,000, that's not a lot of memory.

915
00:50:31,728 --> 00:50:32,816
If we try to compute factorial of 10,000, that's not a lot of memory.

916
00:50:33,180 --> 00:50:34,688
On the other hand, it's an awful big number.

917
00:50:35,952 --> 00:50:38,416
So the question is, is that a valuable thing in this case.

918
00:50:39,180 --> 00:50:42,192
But it really turns out not to be a terrible limit, because memory is el cheapo, and people are pretty expensive.

919
00:50:42,224 --> 00:50:43,536
But it really turns out not to be a terrible limit, because memory is el cheapo, and people are pretty expensive.

920
00:50:44,160 --> 00:50:45,344
But it really turns out not to be a terrible limit, because memory is el cheapo, and people are pretty expensive.

921
00:50:48,130 --> 00:50:50,224
OK, thank you, let's take a break.

922
00:50:51,050 --> 00:50:52,660
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

923
00:51:56,112 --> 00:51:57,040
PROFESSOR: Well, let's see.

924
00:51:58,704 --> 00:52:03,376
What I've shown you now is how to do a simple iterative process and a simple recursive process.

925
00:52:03,696 --> 00:52:05,312
What I've shown you now is how to do a simple iterative process and a simple recursive process.

926
00:52:05,640 --> 00:52:08,688
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

927
00:52:09,632 --> 00:52:11,120
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

928
00:52:11,216 --> 00:52:13,584
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

929
00:52:13,968 --> 00:52:17,136
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

930
00:52:17,232 --> 00:52:19,888
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

931
00:52:20,048 --> 00:52:22,688
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

932
00:52:22,768 --> 00:52:25,040
I just want to summarize the design of simple machines for specific applications by showing you a little bit more complicated design, that of a thing that does doubly recursive Fibonacci, because it will indicate to us, and we'll understand, a bit about the conventions required for making stacks operate correctly.

933
00:52:26,400 --> 00:52:27,110
So let's see.

934
00:52:27,110 --> 00:52:28,272
I'm just going to write down, first of all, the program I'm going to translate.

935
00:52:28,304 --> 00:52:29,712
I'm just going to write down, first of all, the program I'm going to translate.

936
00:52:34,150 --> 00:52:36,528
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

937
00:52:39,232 --> 00:52:41,584
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

938
00:52:44,576 --> 00:52:46,464
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

939
00:52:47,312 --> 00:52:48,560
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

940
00:52:49,264 --> 00:52:55,344
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

941
00:52:58,448 --> 00:52:59,856
I need a Fibonacci procedure, it's very simple, which says, if N is less than 2, the result is N, otherwise it's the sum of Fib of N minus 1 and Fib of N minus 2.

942
00:53:07,056 --> 00:53:09,290
That's the plan I have here.

943
00:53:09,290 --> 00:53:12,560
And we're just going to write down the controller for such a machine.

944
00:53:13,070 --> 00:53:19,152
We're going to assume that there are registers, N, which holds the number we're taking Fibonacci of, VAL, which is where the answer is going to get put, and continue, which is the thing that's linked to the controller, like before.

945
00:53:19,824 --> 00:53:21,808
We're going to assume that there are registers, N, which holds the number we're taking Fibonacci of, VAL, which is where the answer is going to get put, and continue, which is the thing that's linked to the controller, like before.

946
00:53:22,176 --> 00:53:24,976
We're going to assume that there are registers, N, which holds the number we're taking Fibonacci of, VAL, which is where the answer is going to get put, and continue, which is the thing that's linked to the controller, like before.

947
00:53:26,112 --> 00:53:26,810
We're going to assume that there are registers, N, which holds the number we're taking Fibonacci of, VAL, which is where the answer is going to get put, and continue, which is the thing that's linked to the controller, like before.

948
00:53:26,960 --> 00:53:29,216
But I'm not going to draw another physical datapath, because it's pretty much the same as the last one you've seen.

949
00:53:31,536 --> 00:53:34,000
But I'm not going to draw another physical datapath, because it's pretty much the same as the last one you've seen.

950
00:53:34,360 --> 00:53:37,840
And of course, one of the most amazing things about computation is that after a while, you build up a little more features and a few more features, and all of the sudden, you've got everything you need.

951
00:53:38,752 --> 00:53:39,888
And of course, one of the most amazing things about computation is that after a while, you build up a little more features and a few more features, and all of the sudden, you've got everything you need.

952
00:53:40,080 --> 00:53:41,936
And of course, one of the most amazing things about computation is that after a while, you build up a little more features and a few more features, and all of the sudden, you've got everything you need.

953
00:53:41,952 --> 00:53:43,328
And of course, one of the most amazing things about computation is that after a while, you build up a little more features and a few more features, and all of the sudden, you've got everything you need.

954
00:53:44,752 --> 00:53:47,600
So it's remarkable that it just gets there so fast. I don't need much more to make a universal computer.

955
00:53:48,176 --> 00:53:50,848
So it's remarkable that it just gets there so fast. I don't need much more to make a universal computer.

956
00:53:51,810 --> 00:53:54,688
But in any case, let's look at the controller for the Fibonacci thing.

957
00:53:55,060 --> 00:53:57,072
First thing I want to do is start the thing up by assign to continue a place called done, called Fib-done here.

958
00:53:57,328 --> 00:54:02,528
First thing I want to do is start the thing up by assign to continue a place called done, called Fib-done here.

959
00:54:07,136 --> 00:54:10,288
First thing I want to do is start the thing up by assign to continue a place called done, called Fib-done here.

960
00:54:14,144 --> 00:54:15,536
So that means that somewhere over here, I'm going to have a label, Fib-done, which is the place where I go when I want the machine to stop.

961
00:54:15,552 --> 00:54:18,480
So that means that somewhere over here, I'm going to have a label, Fib-done, which is the place where I go when I want the machine to stop.

962
00:54:19,712 --> 00:54:21,104
So that means that somewhere over here, I'm going to have a label, Fib-done, which is the place where I go when I want the machine to stop.

963
00:54:21,232 --> 00:54:22,448
So that means that somewhere over here, I'm going to have a label, Fib-done, which is the place where I go when I want the machine to stop.

964
00:54:24,000 --> 00:54:24,864
That's what that is.

965
00:54:25,920 --> 00:54:26,896
And I'm going to make up a loop.

966
00:54:31,110 --> 00:54:34,256
It's a place I'm going to go to in order to start up computing a Fib.

967
00:54:35,470 --> 00:54:36,864
Whatever is in N at this point, Fibonacci will be computed of, and we will return to the place specified by continue.

968
00:54:37,392 --> 00:54:38,992
Whatever is in N at this point, Fibonacci will be computed of, and we will return to the place specified by continue.

969
00:54:39,136 --> 00:54:42,016
Whatever is in N at this point, Fibonacci will be computed of, and we will return to the place specified by continue.

970
00:54:44,800 --> 00:54:48,400
So what you're going to see here at this place, what I want here is the contract that says, I'm going to write this with a comment syntax, the contract is N contains arg, the argument.

971
00:54:48,448 --> 00:54:50,480
So what you're going to see here at this place, what I want here is the contract that says, I'm going to write this with a comment syntax, the contract is N contains arg, the argument.

972
00:54:50,970 --> 00:54:54,256
So what you're going to see here at this place, what I want here is the contract that says, I'm going to write this with a comment syntax, the contract is N contains arg, the argument.

973
00:54:54,576 --> 00:55:00,992
So what you're going to see here at this place, what I want here is the contract that says, I'm going to write this with a comment syntax, the contract is N contains arg, the argument.

974
00:55:02,100 --> 00:55:09,824
Continue is the recipient.

975
00:55:13,360 --> 00:55:14,290
And that's where it is.

976
00:55:15,710 --> 00:55:18,960
At this point, if I ever go to this place, I'm expecting this to be true, the argument for computing the Fibonacci.

977
00:55:19,248 --> 00:55:21,040
At this point, if I ever go to this place, I'm expecting this to be true, the argument for computing the Fibonacci.

978
00:55:21,520 --> 00:55:23,328
At this point, if I ever go to this place, I'm expecting this to be true, the argument for computing the Fibonacci.

979
00:55:24,820 --> 00:55:26,832
Now the next thing I want to do is to branch.

980
00:55:30,220 --> 00:55:32,224
And if N is less than 2--  by the way, I'm using what looks like Lisp syntax.

981
00:55:35,072 --> 00:55:37,440
And if N is less than 2--  by the way, I'm using what looks like Lisp syntax.

982
00:55:38,730 --> 00:55:39,632
This is not Lisp.

983
00:55:41,310 --> 00:55:42,384
This does not run.

984
00:55:42,750 --> 00:55:45,472
What I'm writing here does not run as a simple Lisp program.

985
00:55:46,120 --> 00:55:49,312
This is a representation of another language.

986
00:55:49,710 --> 00:55:52,256
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

987
00:55:52,400 --> 00:55:54,704
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

988
00:55:55,328 --> 00:55:57,344
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

989
00:55:57,824 --> 00:55:59,184
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

990
00:55:59,296 --> 00:56:00,912
The reason I'm using the syntax of parentheses and so on is because I tend to use a Lisp system to write an interpreter for this which allows me to simulate the machine I'm trying to build.

991
00:56:03,380 --> 00:56:06,240
I don't want to confuse this to think that this is Lisp code.

992
00:56:06,940 --> 00:56:08,608
It's just I'm using a lot of the pieces of Lisp.

993
00:56:09,510 --> 00:56:10,848
I'm embedding a language in Lisp, using Lisp as pieces to make my process of making my simulator easy.

994
00:56:11,024 --> 00:56:12,448
I'm embedding a language in Lisp, using Lisp as pieces to make my process of making my simulator easy.

995
00:56:12,720 --> 00:56:15,120
I'm embedding a language in Lisp, using Lisp as pieces to make my process of making my simulator easy.

996
00:56:16,620 --> 00:56:18,560
So I'm inheriting from Lisp all of its properties.

997
00:56:19,100 --> 00:56:21,530
Fetch of N 2, I want to go to a place called immediate answer.

998
00:56:21,776 --> 00:56:23,728
Fetch of N 2, I want to go to a place called immediate answer.

999
00:56:26,208 --> 00:56:27,296
It's the base step.

1000
00:56:33,150 --> 00:56:34,352
Now, that's somewhere over here, just above done.

1001
00:56:35,920 --> 00:56:36,896
Now, that's somewhere over here, just above done.

1002
00:56:37,750 --> 00:56:38,640
And we'll see it later.

1003
00:56:39,424 --> 00:56:40,704
Now, in the general case, which is the part I'm going to write down now, let's just do it.

1004
00:56:40,720 --> 00:56:42,448
Now, in the general case, which is the part I'm going to write down now, let's just do it.

1005
00:56:43,136 --> 00:56:44,192
Now, in the general case, which is the part I'm going to write down now, let's just do it.

1006
00:56:44,860 --> 00:56:45,728
Well, first of all, I'm going to have to call Fibonacci twice.

1007
00:56:45,744 --> 00:56:48,208
Well, first of all, I'm going to have to call Fibonacci twice.

1008
00:56:49,420 --> 00:56:52,544
In each case-- well, in one case at least, I'm going to have to know what to do to come back and do the next one.

1009
00:56:52,784 --> 00:56:55,360
In each case-- well, in one case at least, I'm going to have to know what to do to come back and do the next one.

1010
00:56:56,310 --> 00:56:58,368
I have to remember, have I done the first Fib, or have I done the second one?

1011
00:56:59,200 --> 00:57:01,232
I have to remember, have I done the first Fib, or have I done the second one?

1012
00:57:01,264 --> 00:57:02,544
I have to remember, have I done the first Fib, or have I done the second one?

1013
00:57:04,500 --> 00:57:07,040
Do I have to come back to the place where I do the second Fib, or do I have to come back to the place where I do the add?

1014
00:57:07,072 --> 00:57:09,088
Do I have to come back to the place where I do the second Fib, or do I have to come back to the place where I do the add?

1015
00:57:10,128 --> 00:57:12,112
In the first case, over the first Fibonacci, I'm going to need the value of N for computing for the second one.

1016
00:57:12,140 --> 00:57:14,464
In the first case, over the first Fibonacci, I'm going to need the value of N for computing for the second one.

1017
00:57:14,512 --> 00:57:16,980
In the first case, over the first Fibonacci, I'm going to need the value of N for computing for the second one.

1018
00:57:19,840 --> 00:57:21,584
So I have to store some of these things up.

1019
00:57:23,360 --> 00:57:24,896
So first I'm going to save continue.

1020
00:57:26,192 --> 00:57:27,328
That's who needs the answer.

1021
00:57:31,320 --> 00:57:32,464
And the reason I'm doing that is because I'm about to assign continue to the place which is the place I want to go to after.

1022
00:57:32,480 --> 00:57:34,208
And the reason I'm doing that is because I'm about to assign continue to the place which is the place I want to go to after.

1023
00:57:40,112 --> 00:57:44,320
And the reason I'm doing that is because I'm about to assign continue to the place which is the place I want to go to after.

1024
00:57:46,832 --> 00:57:50,272
Let's call it Fib-N-minus-1, big long name, classic Lisp name.

1025
00:57:51,040 --> 00:57:53,760
Let's call it Fib-N-minus-1, big long name, classic Lisp name.

1026
00:57:57,360 --> 00:58:00,224
Because I'm going to compute the first Fib of N minus 1, and then after that, I want to come back and do something else.

1027
00:58:00,848 --> 00:58:03,296
Because I'm going to compute the first Fib of N minus 1, and then after that, I want to come back and do something else.

1028
00:58:03,960 --> 00:58:06,528
That's the place I want to go to after I've done the first Fibonacci calculation.

1029
00:58:07,552 --> 00:58:09,488
That's the place I want to go to after I've done the first Fibonacci calculation.

1030
00:58:11,520 --> 00:58:13,136
And I want to do a save of N, because I'm going to need it later, after that.

1031
00:58:14,416 --> 00:58:17,264
And I want to do a save of N, because I'm going to need it later, after that.

1032
00:58:19,130 --> 00:58:20,544
Now I'm going to, at this point, get ready to do the Fibonacci of N minus 1.

1033
00:58:20,672 --> 00:58:22,848
Now I'm going to, at this point, get ready to do the Fibonacci of N minus 1.

1034
00:58:23,024 --> 00:58:33,950
So assign to N the difference of the fetch of N and 1.

1035
00:58:38,110 --> 00:58:40,270
Now I'm ready to go back to doing the Fib loop.

1036
00:58:47,184 --> 00:58:49,872
Have I satisfied my contract?

1037
00:58:50,400 --> 00:58:51,504
And the answer is yes.

1038
00:58:51,770 --> 00:58:55,120
N contains N minus 1, which is what I need.

1039
00:58:56,432 --> 00:59:00,096
Continue contains a place I want to go to when I'm done with calculating N minus 1.

1040
00:59:01,280 --> 00:59:03,072
Continue contains a place I want to go to when I'm done with calculating N minus 1.

1041
00:59:04,100 --> 00:59:05,440
So I've satisfied the contract.

1042
00:59:05,440 --> 00:59:09,024
And therefore, I can write down here a label, after-Fib-N-minus-1.

1043
00:59:11,472 --> 00:59:17,568
And therefore, I can write down here a label, after-Fib-N-minus-1.

1044
00:59:20,490 --> 00:59:21,632
Now what am I going to do here?

1045
00:59:22,690 --> 00:59:24,352
Here's a place where I now have to get ready to do Fib of N minus 2.

1046
00:59:24,448 --> 00:59:26,752
Here's a place where I now have to get ready to do Fib of N minus 2.

1047
00:59:29,270 --> 00:59:30,800
But in order to do a Fib of N minus 2, look, I don't know.

1048
00:59:30,832 --> 00:59:31,632
But in order to do a Fib of N minus 2, look, I don't know.

1049
00:59:31,780 --> 00:59:33,408
I've clobbered my N over here.

1050
00:59:33,810 --> 00:59:37,136
And presumably my N is counted down all the way to 1 or 0 or something at this point.

1051
00:59:37,856 --> 00:59:38,800
And presumably my N is counted down all the way to 1 or 0 or something at this point.

1052
00:59:39,780 --> 00:59:42,512
So I don't know what the value of N in the N register is.

1053
00:59:43,030 --> 00:59:44,752
I want the value of N that was on the stack that I saved over here so that could restore it over here.

1054
00:59:44,800 --> 00:59:46,000
I want the value of N that was on the stack that I saved over here so that could restore it over here.

1055
00:59:46,176 --> 00:59:47,888
I want the value of N that was on the stack that I saved over here so that could restore it over here.

1056
00:59:49,520 --> 00:59:51,024
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1057
00:59:51,152 --> 00:59:52,528
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1058
00:59:53,648 --> 00:59:54,496
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1059
00:59:54,896 --> 00:59:57,376
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1060
00:59:57,530 --> 00:59:59,640
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1061
00:59:59,680 --> 01:00:00,864
I saved up the value of N, which is this value of N at this point, so that I could restore it after computing Fib of N minus 1, so that I could count that down to N minus 2 and then compute Fib of N minus 2.

1062
01:00:01,810 --> 01:00:02,752
So let's restore that.

1063
01:00:08,830 --> 01:00:09,776
Restore of N.

1064
01:00:11,130 --> 01:00:15,984
Now I'm about to do something which is superstitious, and we will remove it shortly.

1065
01:00:16,000 --> 01:00:17,408
Now I'm about to do something which is superstitious, and we will remove it shortly.

1066
01:00:18,520 --> 01:00:20,480
I am about to finish the sequence of doing the subroutine call, if you will.

1067
01:00:20,592 --> 01:00:23,440
I am about to finish the sequence of doing the subroutine call, if you will.

1068
01:00:24,800 --> 01:00:25,952
I'm going to say, well, I also saved up the continuation, since I'm going to restore it now.

1069
01:00:26,064 --> 01:00:27,904
I'm going to say, well, I also saved up the continuation, since I'm going to restore it now.

1070
01:00:28,480 --> 01:00:30,432
I'm going to say, well, I also saved up the continuation, since I'm going to restore it now.

1071
01:00:31,600 --> 01:00:32,448
But actually, I don't have to, because I'm not going to need it.

1072
01:00:32,480 --> 01:00:33,552
But actually, I don't have to, because I'm not going to need it.

1073
01:00:34,610 --> 01:00:35,728
We'll fix that in a second.

1074
01:00:36,260 --> 01:00:37,952
So we'll do a restore of continue, which is what I would in general need to do.

1075
01:00:46,048 --> 01:00:48,020
So we'll do a restore of continue, which is what I would in general need to do.

1076
01:00:48,020 --> 01:00:49,232
And we're just going to see what you would call in the compiler world a peephole optimization, which says, whoops, you didn't have to do that.

1077
01:00:49,312 --> 01:00:52,144
And we're just going to see what you would call in the compiler world a peephole optimization, which says, whoops, you didn't have to do that.

1078
01:00:52,272 --> 01:00:53,728
And we're just going to see what you would call in the compiler world a peephole optimization, which says, whoops, you didn't have to do that.

1079
01:00:55,420 --> 01:00:57,104
OK, so the next thing I see here is that I have to get ready now to do Fibonacci of N minus 2.

1080
01:00:58,464 --> 01:01:02,288
OK, so the next thing I see here is that I have to get ready now to do Fibonacci of N minus 2.

1081
01:01:02,770 --> 01:01:04,496
But I don't have to save N anymore.

1082
01:01:05,050 --> 01:01:06,720
The reason why I don't have to save N anymore is because I don't need N after I've done Fib of N minus 2, because the next thing I do is add.

1083
01:01:06,800 --> 01:01:09,344
The reason why I don't have to save N anymore is because I don't need N after I've done Fib of N minus 2, because the next thing I do is add.

1084
01:01:09,360 --> 01:01:10,720
The reason why I don't have to save N anymore is because I don't need N after I've done Fib of N minus 2, because the next thing I do is add.

1085
01:01:13,540 --> 01:01:15,856
So I'm just going to set up my N that way.

1086
01:01:16,608 --> 01:01:28,990
Assign N minus difference of fetch N and 2.

1087
01:01:31,850 --> 01:01:34,016
Now I have to finish the setup for calling Fibonacci of N minus 2.

1088
01:01:34,272 --> 01:01:36,730
Now I have to finish the setup for calling Fibonacci of N minus 2.

1089
01:01:36,950 --> 01:01:38,336
Well, I have to save up continue and assign continue, continue, to the place which is after Fib N 2, that place over here somewhere.

1090
01:01:44,224 --> 01:01:49,024
Well, I have to save up continue and assign continue, continue, to the place which is after Fib N 2, that place over here somewhere.

1091
01:01:52,304 --> 01:01:59,952
Well, I have to save up continue and assign continue, continue, to the place which is after Fib N 2, that place over here somewhere.

1092
01:02:02,576 --> 01:02:04,032
Well, I have to save up continue and assign continue, continue, to the place which is after Fib N 2, that place over here somewhere.

1093
01:02:05,320 --> 01:02:07,232
However, I've got to be very careful.

1094
01:02:08,650 --> 01:02:11,424
The old value, the value of Fib of N minus 1, I'm going to need later.

1095
01:02:12,064 --> 01:02:13,120
The old value, the value of Fib of N minus 1, I'm going to need later.

1096
01:02:15,300 --> 01:02:17,376
The value of Fibonacci of N minus 1, I'm going to need.

1097
01:02:17,616 --> 01:02:18,480
The value of Fibonacci of N minus 1, I'm going to need.

1098
01:02:18,784 --> 01:02:19,808
And I can't clobber it, because I'm going to have to add it to the value of Fib of N minus 2.

1099
01:02:21,072 --> 01:02:23,600
And I can't clobber it, because I'm going to have to add it to the value of Fib of N minus 2.

1100
01:02:24,150 --> 01:02:25,888
That's in the value register, so I'm going to save it.

1101
01:02:27,792 --> 01:02:32,608
So I have to save this right now, save up VAL.

1102
01:02:33,780 --> 01:02:39,540
And now I can go off to my subroutine, go to Fib loop.

1103
01:02:44,220 --> 01:02:46,576
Now before I go any further and finish this program, I just want to look at this segment so far and see, oh yes, there's a sequence of instructions here, if you will, that I can do something about.

1104
01:02:46,800 --> 01:02:51,056
Now before I go any further and finish this program, I just want to look at this segment so far and see, oh yes, there's a sequence of instructions here, if you will, that I can do something about.

1105
01:02:51,232 --> 01:02:56,000
Now before I go any further and finish this program, I just want to look at this segment so far and see, oh yes, there's a sequence of instructions here, if you will, that I can do something about.

1106
01:02:57,840 --> 01:02:59,088
Now before I go any further and finish this program, I just want to look at this segment so far and see, oh yes, there's a sequence of instructions here, if you will, that I can do something about.

1107
01:03:01,580 --> 01:03:03,200
Here I have a restore of continue, a save of continue, and then an assign of continue, with no other references to continue in between.

1108
01:03:04,256 --> 01:03:05,488
Here I have a restore of continue, a save of continue, and then an assign of continue, with no other references to continue in between.

1109
01:03:06,016 --> 01:03:07,408
Here I have a restore of continue, a save of continue, and then an assign of continue, with no other references to continue in between.

1110
01:03:08,704 --> 01:03:10,640
Here I have a restore of continue, a save of continue, and then an assign of continue, with no other references to continue in between.

1111
01:03:13,840 --> 01:03:15,488
The restore followed by the save leaves the stack unchanged.

1112
01:03:15,504 --> 01:03:16,670
The restore followed by the save leaves the stack unchanged.

1113
01:03:19,090 --> 01:03:21,728
The only difference is that I set the continue register to a value, which is the value that was on the stack.

1114
01:03:21,968 --> 01:03:23,280
The only difference is that I set the continue register to a value, which is the value that was on the stack.

1115
01:03:24,330 --> 01:03:25,792
Since I now clobber that value, as in it was never referenced, these instructions are unnecessary.

1116
01:03:26,448 --> 01:03:27,936
Since I now clobber that value, as in it was never referenced, these instructions are unnecessary.

1117
01:03:28,592 --> 01:03:30,096
Since I now clobber that value, as in it was never referenced, these instructions are unnecessary.

1118
01:03:31,760 --> 01:03:35,390
So we will remove these.

1119
01:03:38,880 --> 01:03:40,784
But I couldn't have seen that unless I had written them down.

1120
01:03:43,780 --> 01:03:44,720
Was that really true?

1121
01:03:45,776 --> 01:03:46,608
Well, I don't know.

1122
01:03:48,610 --> 01:03:52,912
OK, so we've now gone off to compute Fibonacci of N minus 2.

1123
01:03:53,660 --> 01:03:54,592
So after that, what are we going to do?

1124
01:04:02,960 --> 01:04:03,856
So after that, what are we going to do?

1125
01:04:05,070 --> 01:04:06,768
Well, I suppose the first thing we have to do-- we've got two things.

1126
01:04:06,992 --> 01:04:07,888
Well, I suppose the first thing we have to do-- we've got two things.

1127
01:04:07,960 --> 01:04:10,496
We've got a thing in the value register which is now valuable.

1128
01:04:10,920 --> 01:04:11,984
We also have a thing on the stack that can be restored into the value register.

1129
01:04:12,048 --> 01:04:13,632
We also have a thing on the stack that can be restored into the value register.

1130
01:04:14,810 --> 01:04:16,576
And what I have to be careful with now is I want to shuffle this right so I can do the multiply.

1131
01:04:16,880 --> 01:04:18,992
And what I have to be careful with now is I want to shuffle this right so I can do the multiply.

1132
01:04:19,470 --> 01:04:21,248
Now there are various conventions I might use, but I'm going to be very picky and say, I'm only going to restore into a register I've saved from.

1133
01:04:21,472 --> 01:04:23,520
Now there are various conventions I might use, but I'm going to be very picky and say, I'm only going to restore into a register I've saved from.

1134
01:04:23,552 --> 01:04:25,888
Now there are various conventions I might use, but I'm going to be very picky and say, I'm only going to restore into a register I've saved from.

1135
01:04:26,740 --> 01:04:28,288
If that's the case, I have to do a shuffle here.

1136
01:04:29,248 --> 01:04:31,840
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1137
01:04:32,688 --> 01:04:37,136
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1138
01:04:37,168 --> 01:04:39,376
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1139
01:04:39,920 --> 01:04:41,216
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1140
01:04:45,216 --> 01:04:47,340
It's the same problem with how many hands I have. So I'm going to assign to N, because I'm not going to need N anymore, N is useless, the current value of VAL, which was the value of Fib of N minus 2.

1141
01:04:52,950 --> 01:04:56,352
And I'm going to restore the value register now.

1142
01:05:01,850 --> 01:05:03,920
This restore matches this save. And if you're very careful and examine very carefully what goes on, restores and saves are always matched.

1143
01:05:05,584 --> 01:05:08,832
This restore matches this save. And if you're very careful and examine very carefully what goes on, restores and saves are always matched.

1144
01:05:09,216 --> 01:05:11,968
This restore matches this save. And if you're very careful and examine very carefully what goes on, restores and saves are always matched.

1145
01:05:13,840 --> 01:05:15,152
Now there's an outstanding save, of course, that we have to get rid of soon.
Now there's an outstanding save, of course, that we have to get rid of soon.

1146
01:05:15,152 --> 01:05:15,184
Now there's an outstanding save, of course, that we have to get rid of soon.

1147
01:05:15,184 --> 01:05:16,384
Now there's an outstanding save, of course, that we have to get rid of soon.
Now there's an outstanding save, of course, that we have to get rid of soon.

1148
01:05:16,384 --> 01:05:19,000
Now there's an outstanding save, of course, that we have to get rid of soon.

1149
01:05:19,000 --> 01:05:20,590
And so I restored the value register.

1150
01:05:20,944 --> 01:05:22,576
Now I restore the continue one, which matches this one, dot, dot, dot, dot, dot, dot, dot, down to here, restoring that continuation.

1151
01:05:31,152 --> 01:05:32,400
Now I restore the continue one, which matches this one, dot, dot, dot, dot, dot, dot, dot, down to here, restoring that continuation.

1152
01:05:34,800 --> 01:05:37,856
Now I restore the continue one, which matches this one, dot, dot, dot, dot, dot, dot, dot, down to here, restoring that continuation.

1153
01:05:40,592 --> 01:05:42,464
Now I restore the continue one, which matches this one, dot, dot, dot, dot, dot, dot, dot, down to here, restoring that continuation.

1154
01:05:42,860 --> 01:05:45,712
That continuation is a continuation of Fib of N, which is the problem I was trying to solve, a major problem I'm trying to solve.

1155
01:05:46,464 --> 01:05:49,328
That continuation is a continuation of Fib of N, which is the problem I was trying to solve, a major problem I'm trying to solve.

1156
01:05:49,984 --> 01:05:52,352
So that's the guy I have to go back to who wants Fib of N. I saved them all the way up here when I realized N was not less than 2.

1157
01:05:52,544 --> 01:05:54,032
So that's the guy I have to go back to who wants Fib of N. I saved them all the way up here when I realized N was not less than 2.

1158
01:05:54,160 --> 01:05:56,608
So that's the guy I have to go back to who wants Fib of N. I saved them all the way up here when I realized N was not less than 2.

1159
01:05:57,360 --> 01:05:59,072
And so I had to do a complicated operation.

1160
01:06:00,840 --> 01:06:02,576
Now I've got everything I need to do it.

1161
01:06:03,240 --> 01:06:04,368
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1162
01:06:05,440 --> 01:06:10,000
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1163
01:06:12,288 --> 01:06:18,224
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1164
01:06:19,552 --> 01:06:21,072
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1165
01:06:27,440 --> 01:06:28,608
So I'm going to restore that, assign to VAL the sum of fetch VAL and fetch of N, and go to continue.

1166
01:06:38,260 --> 01:06:44,784
So now I've returned from computing Fibonacci of N, the general case.

1167
01:06:45,392 --> 01:06:46,576
So now I've returned from computing Fibonacci of N, the general case.

1168
01:06:47,110 --> 01:06:50,608
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1169
01:06:50,992 --> 01:06:55,536
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1170
01:07:02,576 --> 01:07:05,088
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1171
01:07:05,776 --> 01:07:07,488
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1172
01:07:08,544 --> 01:07:11,856
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1173
01:07:13,648 --> 01:07:16,896
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1174
01:07:16,990 --> 01:07:18,192
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1175
01:07:19,232 --> 01:07:36,130
Now what's left is we have to fix up a few details, like there's the base case of this induction, immediate answer, which is nothing more than assign to VAL fetch of N, because N was less than 2, and therefore, the answer is N in our original program, and return continue--  bobble, bobble almost-- and finally Fib done.

1176
01:07:43,460 --> 01:07:45,640
So that's a fairly complicated program.

1177
01:07:45,640 --> 01:07:47,344
And the reason I wanted you see to that is because I want you to see the particular flavors of stack discipline that I was obeying.

1178
01:07:47,504 --> 01:07:51,216
And the reason I wanted you see to that is because I want you to see the particular flavors of stack discipline that I was obeying.

1179
01:07:51,760 --> 01:07:52,656
And the reason I wanted you see to that is because I want you to see the particular flavors of stack discipline that I was obeying.

1180
01:07:53,328 --> 01:07:55,216
It was first of all, I don't want to take anything that I'm not going to need later.

1181
01:07:56,928 --> 01:07:58,128
It was first of all, I don't want to take anything that I'm not going to need later.

1182
01:08:00,576 --> 01:08:01,850
I was being very careful.

1183
01:08:01,850 --> 01:08:02,912
And it's very important.

1184
01:08:03,940 --> 01:08:06,528
And there are all sorts of other disciplines people make with frames and things like that of some sort, where you save all sorts of junk you're not going to need later and restore it because, in some sense, it's easier to do that.

1185
01:08:07,376 --> 01:08:09,616
And there are all sorts of other disciplines people make with frames and things like that of some sort, where you save all sorts of junk you're not going to need later and restore it because, in some sense, it's easier to do that.

1186
01:08:10,192 --> 01:08:12,624
And there are all sorts of other disciplines people make with frames and things like that of some sort, where you save all sorts of junk you're not going to need later and restore it because, in some sense, it's easier to do that.

1187
01:08:12,640 --> 01:08:15,264
And there are all sorts of other disciplines people make with frames and things like that of some sort, where you save all sorts of junk you're not going to need later and restore it because, in some sense, it's easier to do that.

1188
01:08:15,830 --> 01:08:17,408
That's going to lead to various disasters, which we'll see a little later.

1189
01:08:18,592 --> 01:08:20,256
That's going to lead to various disasters, which we'll see a little later.

1190
01:08:21,440 --> 01:08:24,240
It's crucial to save exactly what you're going to need later.

1191
01:08:26,890 --> 01:08:28,016
It's an important idea.

1192
01:08:29,850 --> 01:08:31,328
And the responsibility of that is whoever saves something is the guy who restores it, because he needs it.

1193
01:08:31,904 --> 01:08:33,360
And the responsibility of that is whoever saves something is the guy who restores it, because he needs it.

1194
01:08:33,760 --> 01:08:35,328
And the responsibility of that is whoever saves something is the guy who restores it, because he needs it.

1195
01:08:36,930 --> 01:08:38,544
And in such discipline, you can see what things are unnecessary, operations that are unimportant.

1196
01:08:38,864 --> 01:08:40,768
And in such discipline, you can see what things are unnecessary, operations that are unimportant.

1197
01:08:43,456 --> 01:08:44,736
And in such discipline, you can see what things are unnecessary, operations that are unimportant.

1198
01:08:47,150 --> 01:08:50,400
Now, one other thing I want to tell you about that's very simple is that, of course, the picture you see is not the whole picture.

1199
01:08:51,664 --> 01:08:54,672
Now, one other thing I want to tell you about that's very simple is that, of course, the picture you see is not the whole picture.

1200
01:08:55,350 --> 01:08:56,688
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1201
01:08:56,800 --> 01:09:01,520
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1202
01:09:03,536 --> 01:09:05,600
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1203
01:09:05,888 --> 01:09:07,328
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1204
01:09:08,304 --> 01:09:09,216
Supposing I had systems that had things like other operations, CAR, CDR, cons, building a vector and referencing the nth element of it, or things like that.

1205
01:09:10,400 --> 01:09:13,600
Well, at this level of detail, whatever it is, we can conceptualize those as primitive operations in the datapath.

1206
01:09:13,872 --> 01:09:17,856
Well, at this level of detail, whatever it is, we can conceptualize those as primitive operations in the datapath.

1207
01:09:18,752 --> 01:09:21,952
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1208
01:09:22,320 --> 01:09:24,112
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1209
01:09:24,208 --> 01:09:26,464
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1210
01:09:26,640 --> 01:09:29,808
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1211
01:09:29,888 --> 01:09:33,184
In other words, we could say that some machine that, for example, has the append machine, which has to do cons of the CAR of x with the append of the CDR of x and y, well, gee, that's exactly the same as the factorial structure.

1212
01:09:33,630 --> 01:09:35,296
Well, it's got about the same structure.

1213
01:09:36,544 --> 01:09:37,270
And what do we have?

1214
01:09:37,270 --> 01:09:39,392
We have some sort of things in it which may be registers, x and y, and then x has to somehow move to y sometimes, x has to get the value of y.

1215
01:09:39,760 --> 01:09:42,480
We have some sort of things in it which may be registers, x and y, and then x has to somehow move to y sometimes, x has to get the value of y.

1216
01:09:42,512 --> 01:09:46,752
We have some sort of things in it which may be registers, x and y, and then x has to somehow move to y sometimes, x has to get the value of y.

1217
01:09:46,930 --> 01:09:48,416
And then we may have to be able to do something which is a cons.

1218
01:09:48,544 --> 01:09:50,128
And then we may have to be able to do something which is a cons.

1219
01:09:51,700 --> 01:09:57,936
I don't remember if I need to like this is in this system, but cons is sort of like subtract or add or something.

1220
01:09:57,952 --> 01:10:01,104
I don't remember if I need to like this is in this system, but cons is sort of like subtract or add or something.

1221
01:10:01,420 --> 01:10:02,704
It combines two things, producing a thing which is the cons, which we may then think goes into there.

1222
01:10:02,736 --> 01:10:04,272
It combines two things, producing a thing which is the cons, which we may then think goes into there.

1223
01:10:04,512 --> 01:10:06,496
It combines two things, producing a thing which is the cons, which we may then think goes into there.

1224
01:10:07,600 --> 01:10:09,728
And then maybe a thing called the CAR, which will produce-- I can get the CAR or something.

1225
01:10:12,880 --> 01:10:16,224
And then maybe a thing called the CAR, which will produce-- I can get the CAR or something.

1226
01:10:16,920 --> 01:10:19,552
And maybe I can get the CDR of something, and so on.

1227
01:10:20,150 --> 01:10:22,304
But we shouldn't be too afraid of saying things this way, because the worst that could happen is if we open up cons, what we're going to find is some machine.

1228
01:10:22,928 --> 01:10:24,240
But we shouldn't be too afraid of saying things this way, because the worst that could happen is if we open up cons, what we're going to find is some machine.

1229
01:10:24,944 --> 01:10:26,416
But we shouldn't be too afraid of saying things this way, because the worst that could happen is if we open up cons, what we're going to find is some machine.

1230
01:10:27,312 --> 01:10:29,824
But we shouldn't be too afraid of saying things this way, because the worst that could happen is if we open up cons, what we're going to find is some machine.

1231
01:10:31,888 --> 01:10:34,448
And cons may in fact overlap with CAR and CDR, and it always does, in the same way that plus and minus overlap, and really the same business.

1232
01:10:35,504 --> 01:10:38,128
And cons may in fact overlap with CAR and CDR, and it always does, in the same way that plus and minus overlap, and really the same business.

1233
01:10:38,576 --> 01:10:39,856
And cons may in fact overlap with CAR and CDR, and it always does, in the same way that plus and minus overlap, and really the same business.

1234
01:10:41,210 --> 01:10:42,608
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1235
01:10:42,624 --> 01:10:44,528
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1236
01:10:45,504 --> 01:10:46,544
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1237
01:10:48,032 --> 01:10:49,648
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1238
01:10:50,000 --> 01:10:52,864
Cons, CAR, and CDR are going to overlap, and we're going to find a little controller, a little datapath, which may have some registers in it, some stuff like that.

1239
01:10:53,300 --> 01:10:54,416
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1240
01:10:54,432 --> 01:10:56,160
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1241
01:10:56,464 --> 01:10:58,704
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1242
01:10:58,816 --> 01:11:00,656
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1243
01:11:00,960 --> 01:11:02,030
And maybe inside it, there may also be an infinite part, a part that's semi-infinite or something, which is a lot of very uniform stuff, which we'll call memory.

1244
01:11:06,570 --> 01:11:08,832
And I wouldn't be so horrified if that were the way it works.

1245
01:11:09,330 --> 01:11:11,072
In fact, it does, and we'll talk about that later.

1246
01:11:13,320 --> 01:11:14,570
So are there any questions?

1247
01:11:24,340 --> 01:11:25,808
Gee, what an unquestioning audience.

1248
01:11:28,670 --> 01:11:30,330
Suppose I tell you a horrible pile of lies.

1249
01:11:39,690 --> 01:11:40,384
OK.

1250
01:11:41,990 --> 01:11:42,520
Well, thank you.

1251
01:11:42,520 --> 01:11:43,280
Let's take our break.

1252
01:11:44,230 --> 01:11:48,780
[MUSIC PLAYING - "JESU, JOY OF MAN'S DESIRING" BY JOHANN SEBASTIAN BACH]

