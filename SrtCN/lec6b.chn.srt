1
00:00:20,970 --> 00:00:28,870
之前我们考查了流，可以用信号处理类似的方式来组织程序

2
00:00:28,870 --> 00:00:40,635
要记住的是，关键在于我们将程序看起来的运算顺序与实际在机器中计算的顺序分离开来

3
00:00:40,635 --> 00:00:47,500
那就意味着，我们着手处理非常长的流，其中的元素只是在需要的时候才生成

4
00:00:47,500 --> 00:00:51,560
这种按需计算的方式是内建在流的数据结构中的

5
00:00:54,450 --> 00:00:58,040
即使这个流非常之长，我们也可以只计算我们需要的

6
00:00:58,040 --> 00:01:00,750
只有当我们要求的时候，新的数据才会生成

7
00:01:00,750 --> 00:01:02,110
例子是什么呢？

8
00:01:02,110 --> 00:01:04,800
真的像我们所说的那样吗？

9
00:01:04,800 --> 00:01:11,050
举个例子，假如我们想要一个流中的第n个元素

10
00:01:16,360 --> 00:01:20,400
这个过程可以计算出来

11
00:01:20,400 --> 00:01:25,570
n代表第n个，s是一个流，剩下的只需要沿着流递归下去

12
00:01:25,570 --> 00:01:27,960
n是0的时候就是终点

13
00:01:27,960 --> 00:01:34,310
否则，就在流的TAIL查找第n-1个元素

14
00:01:34,310 --> 00:01:41,700
看起来是LISP中很普通的编程方式，但是不同之处在于，我们沿着流取值，只有途经的n个元素被计算出来

15
00:01:41,700 --> 00:01:45,910
因为它们被FORCE了

16
00:01:45,910 --> 00:01:49,300
这里有另一个简单的过程，打印一个流

17
00:01:49,300 --> 00:01:54,150
把流中的元素依次打印输出

18
00:01:54,150 --> 00:01:55,315
我们要怎么做呢？

19
00:01:55,315 --> 00:01:59,720
先打印流的head，流的head这时就被计算出来

20
00:01:59,720 --> 00:02:04,990
然后再递归打印流的tail

21
00:02:04,990 --> 00:02:09,660
如果流为空，就返回一个“done”的消息

22
00:02:09,660 --> 00:02:14,310
如果你构造了一个流 这个流非常之长

23
00:02:14,310 --> 00:02:21,320
这时你再来打印这个流 流中的元素会依次的计算并打印出来

24
00:02:21,320 --> 00:02:24,680
并不会一次性的全部计算出来

25
00:02:24,680 --> 00:02:30,190
正因为如此 我们就能处理非常长的流

26
00:02:30,190 --> 00:02:33,600
多长呢？

27
00:02:33,600 --> 00:02:36,360
无穷

28
00:02:36,360 --> 00:02:38,920
我们用电脑来实践一下

29
00:02:38,920 --> 00:02:57,420
在解释器里，我们输入(DEFINE (INTEGERS-FROM N) 定义一个从N开始的整数流

30
00:02:59,760 --> 00:03:19,010
(CONS-STREAM N (INTEGERS-FROM (+ N 1))))

31
00:03:24,680 --> 00:03:25,930
这样就我们要的全部整数

32
00:03:28,800 --> 00:03:31,500
现在我们用这个表示所有的整数

33
00:03:34,410 --> 00:03:44,580
(DEFINE INTEGERS (INTEGERS-FROM 1))

34
00:03:48,840 --> 00:04:02,995
现在执行 (NTH-STREAM 20 INTEGERS) 查看第20个元素

35
00:04:02,995 --> 00:04:07,270
得到21 因为我们以n=0为结束条件

36
00:04:07,270 --> 00:04:09,450
或者我们来点更复杂的

37
00:04:09,450 --> 00:04:10,840
我再来定义一个谓词

38
00:04:13,740 --> 00:04:19,160
(DEFINE (NO-SEVEN X）

39
00:04:19,160 --> 00:04:23,376
它可以检测一个整数，判断是否是7的倍数

40
00:04:28,820 --> 00:04:38,175
(NOT (= (REMAINDER X 7) 0))) X对7的余数不为0

41
00:04:41,890 --> 00:04:58,885
这时用NO-SEVEN这个谓词，过滤全部的整数

42
00:05:11,570 --> 00:05:16,360
这样就得到了所有不是7的倍数的整数

43
00:05:16,360 --> 00:05:28,320
现在我来查看第100个不是7的倍数的整数

44
00:05:28,320 --> 00:05:35,270
或者你也想知道这个流的全部元素

45
00:05:35,270 --> 00:05:41,700
(PRINT-STREAM NS) 来尝试打印这个流 现在输出个不停

46
00:05:45,100 --> 00:05:47,070
无穷的数应该永远打印不完吧

47
00:05:52,670 --> 00:06:01,100
你可能会问了，你写的这个INTEGERS真的是全部的整数吗？

48
00:06:01,100 --> 00:06:04,053
现在我画一个图来表示下这个过程

49
00:06:08,170 --> 00:06:19,775
这是我们刚才对整数的定义，它组合起第一个整数和剩下的整数，现在我们画个图来看看

50
00:06:22,720 --> 00:06:27,420
抽象地来看，我画一个盒子来表示从n开始的所有整数

51
00:06:27,420 --> 00:06:37,705
它接受一个参数n，然后返回一个流，这个流表示从n开始的所有整数

52
00:06:37,705 --> 00:06:38,690
接下来

53
00:06:38,690 --> 00:06:42,470
哦 给盒子写上名字

54
00:06:45,070 --> 00:06:45,800
里面是什么样子

55
00:06:45,800 --> 00:06:54,110
取得参数n之后，将其 +1

56
00:06:58,030 --> 00:07:03,170
然后递归的作为另一个INT-FROM盒子的参数

57
00:07:06,870 --> 00:07:14,270
最后的这个结果和n组合起来，构成了最后外层盒子所返回的流

58
00:07:14,270 --> 00:07:18,530
刚才那个过程画出来就是这样子

59
00:07:18,530 --> 00:07:18,780
很有意思

60
00:07:18,780 --> 00:07:23,320
这种画法是Peter Henderson发明的，就是之前绘图语言的发明者

61
00:07:23,320 --> 00:07:28,530
这种图也被称为Henderson diagram  画这种图需要遵守一定的约定

62
00:07:28,530 --> 00:07:37,270
这些实线代表生成的流，这些虚线则作为盒子的输入初始值

63
00:07:37,270 --> 00:07:43,070
这些有形状的盒子，它们则是取一个初始值输入，然后生成一个流

64
00:07:46,410 --> 00:07:48,380
现在，你可能又要问了

65
00:07:48,380 --> 00:07:52,340
那个INTEGERS的数据结构真的代表着全部的整数吗？

66
00:07:52,340 --> 00:07:58,190
或者它只是经过了你的精心组织，以至于我们总可以在其中找到我们需要的那个整数？

67
00:07:58,190 --> 00:07:59,780
这有点哲学的味道，不是么

68
00:07:59,780 --> 00:08:04,450
一个东西你无论什么时候去看，它都在那里，但是它真的是一直的在那里吗？

69
00:08:04,450 --> 00:08:09,420
有点类似地，就比如你的存款是否一直在银行里一样

70
00:08:12,380 --> 00:08:19,830
好的 我们再来看一个例子

71
00:08:19,830 --> 00:08:28,470
课程的一开始 我们讲了一个亚力山大海伦的计算平方根的算法

72
00:08:28,470 --> 00:08:32,030
现在再来看一个同样来自亚力山大的算法

73
00:08:32,030 --> 00:08:39,110
Eratosthenes发明的计算所有质数的算法

74
00:08:41,169 --> 00:08:42,830
它被称为Eratosthenes筛法

75
00:08:42,830 --> 00:08:53,880
它是这样的，一开始，先列举所有的整数，从2开始

76
00:08:53,880 --> 00:08:57,310
然后取第一个整数，哦，2是一个质数

77
00:08:57,310 --> 00:09:01,230
然后对于除了2以外的所有整数，划掉可以被2整除的数

78
00:09:01,230 --> 00:09:05,250
我把这个划掉，还有这个，这个...

79
00:09:05,250 --> 00:09:11,160
有点费时，因为我要把这一页上能划掉的都划掉

80
00:09:11,160 --> 00:09:22,010
我一个一个地划掉所有被2整除的数

81
00:09:22,010 --> 00:09:27,040
结束之后，回头看看我们还剩下点什么

82
00:09:27,040 --> 00:09:29,330
好的，我们继续，下一个数就是3了

83
00:09:29,330 --> 00:09:30,770
3也是一个质数

84
00:09:30,770 --> 00:09:35,120
然后同样的，在除掉3的剩下的所有数中，划掉所有被3整除的数

85
00:09:35,120 --> 00:09:44,050
划掉9 15 21 27 33等等

86
00:09:44,050 --> 00:09:45,350
一页实在太多了，我先不划完

87
00:09:45,350 --> 00:09:47,250
看看我们还剩下什么

88
00:09:47,250 --> 00:09:50,860
依次地下一个就是5了

89
00:09:50,860 --> 00:09:54,540
同样地，从除5以外剩下的数中，划掉被5整除的数

90
00:09:54,540 --> 00:09:58,030
这样继续开始划

91
00:09:58,030 --> 00:10:01,890
做完这个之后，取一个数，也就是7

92
00:10:01,890 --> 00:10:06,810
同样划掉所有被7整除的数，然后一直这样下去

93
00:10:06,810 --> 00:10:10,120
全部结束的时候，我也就得到了所有的质数

94
00:10:10,120 --> 00:10:15,430
这就是Eratosthenes筛法

95
00:10:15,430 --> 00:10:17,930
我们来看下实际代码

96
00:10:17,930 --> 00:10:19,550
这个过程命名为sieve

97
00:10:27,910 --> 00:10:30,480
我只是用代码表示了我们刚才那样筛选的过程

98
00:10:30,480 --> 00:10:34,510
sieve，以一个流为参数

99
00:10:38,770 --> 00:10:41,870
返回一个新的流，第一个元素就是参数s流的第一个元素

100
00:10:41,870 --> 00:10:59,020
这和我们刚才演示的是相符合的，然后我们从(tail s)中过滤掉所有被(head s)整除的数，再用sieve来筛选，作为结果流的TAIL部分

101
00:10:59,020 --> 00:11:01,980
就这么简单

102
00:11:01,980 --> 00:11:06,900
为了得到所有的质数，我们以从2开始的所有整数作为sieve的参数

103
00:11:14,920 --> 00:11:16,300
我们来实践一下

104
00:11:16,300 --> 00:11:19,760
这是可以运行的

105
00:11:19,760 --> 00:11:41,350
我已经预先输入过了sieve的定义，所以这里我直接输入primes的定义

106
00:11:46,760 --> 00:11:48,100
解释器打印PRIMES

107
00:11:48,100 --> 00:11:50,990
这样就得到了所有的质数，是不是这样呢？

108
00:11:50,990 --> 00:12:01,010
拿个例子来看一下，第20个质数是什么？

109
00:12:01,010 --> 00:12:02,540
打印结果是73

110
00:12:02,540 --> 00:12:07,750
看，我才刚按下回车，结果就输出了，非常快

111
00:12:10,370 --> 00:12:14,960
现在我要求打印所有的质数

112
00:12:22,780 --> 00:12:25,350
解释器就开始打印所有的质数

113
00:12:25,350 --> 00:12:28,570
肯定输出不完的 现在我们把它停掉

114
00:12:32,030 --> 00:12:33,130
现在我用图形来表示这个过程

115
00:12:33,130 --> 00:12:34,890
我已经画好了

116
00:12:34,890 --> 00:12:37,900
这个过程的图形应该是什么样子呢？

117
00:12:37,900 --> 00:12:42,610
就像其它所有的图一样，一开始就是一个盒子，名字是sieve

118
00:12:42,610 --> 00:12:43,560
它是如何运作的呢？

119
00:12:43,560 --> 00:12:44,810
它接收一个流作为输入

120
00:12:48,850 --> 00:12:50,870
head 和 tail 分开

121
00:12:50,870 --> 00:12:54,970
sieve盒子输出的也是一个流，第一个元素就是head

122
00:12:57,796 --> 00:13:02,550
这个head也还用在了filter这里

123
00:13:02,550 --> 00:13:03,850
这里下面，取得tail流

124
00:13:03,850 --> 00:13:09,152
filter盒子过滤掉tail中所有整除head的数

125
00:13:09,152 --> 00:13:15,130
输出的流又作为一个新的sieve盒子的输入，这个sieve输出的流最后和head一起构成了最外层sieve输出的流

126
00:13:15,130 --> 00:13:19,650
你也可以把sieve想像为一个过滤器，不过它是一个无穷递归的过滤器

127
00:13:19,650 --> 00:13:27,130
因为这个sieve盒子内部还有一个sieve，内层的sieve内部肯定还有一个sieve，无穷下去

128
00:13:27,130 --> 00:13:28,960
我们已经开始接触一些不得了的东西了

129
00:13:28,960 --> 00:13:36,690
我们开始把 以信号处理观察现实的视角和lisp计算中的递归结合在一起

130
00:13:36,690 --> 00:13:40,970
你们可以用它来做很多事

131
00:13:40,970 --> 00:13:42,220
好的，有什么问题吗？

132
00:13:48,190 --> 00:13:49,440
没有，那我们休息一下

133
00:14:28,820 --> 00:14:32,690
我们已经了解了许多如何用流进行编程的例子

134
00:14:34,790 --> 00:14:41,490
那些盒子都有一个共同的特征

135
00:14:41,490 --> 00:14:51,000
我们总是递归地一次生成一个元素，再用cons-stream连接起来。因此我们必须一起思考生成流的过程

136
00:14:51,000 --> 00:15:07,350
这里我们用另一种方式来思考流，不是那种需要沿着流一个逐个元素来思考，而是把流作为一个整体

137
00:15:07,350 --> 00:15:12,410
为了把意思表示清楚，我们来看两个过程

138
00:15:12,410 --> 00:15:22,330
第一个过程是 add-streams，两以两个流s1 s2作为参数

139
00:15:22,330 --> 00:15:22,460
然后

140
00:15:22,460 --> 00:15:32,970
生成一个新的流，其元素是两个流相应位置元素的和

141
00:15:32,970 --> 00:15:36,810
如果其中一个流是空的，我们就返回另一个流

142
00:15:36,810 --> 00:15:50,090
否则，我们就构建一个新的流，head元素是两个参数head的和，然后再递归求tail部分

143
00:15:50,090 --> 00:15:53,150
这就是“逐个元素来思考”来表示的整个过程

144
00:15:53,150 --> 00:15:57,500
另一个过程是scale-stream

145
00:15:57,500 --> 00:16:09,710
两个参数，c是一个常数，s是一个流，结果生成的流相当于是将流s整体缩放了c倍

146
00:16:09,710 --> 00:16:18,290
这个过程表述起来很简单，就是用map-stream和这个lambda对流s进行映射

147
00:16:20,520 --> 00:16:27,910
考虑清楚这两个例子的区别，现在我来具体用程序演示“将流作为整体来思考”到底是什么意思

148
00:16:27,910 --> 00:16:30,200
我们来看这个

149
00:16:30,200 --> 00:16:31,680
假设这样

150
00:16:31,680 --> 00:16:52,190
(DEFINE ONES (CONS-STREAM 1 ONES))

151
00:16:54,860 --> 00:16:56,950
这是什么？

152
00:16:56,950 --> 00:17:03,330
这是一个表示无穷个1的流，因为我们看到第一个元素是1

153
00:17:03,330 --> 00:17:11,780
tail部分是ONES，ONES的head也是1，ONES的tail又是ONES，其head又是1，以此类推

154
00:17:11,780 --> 00:17:15,130
这就是无穷个1的流

155
00:17:15,130 --> 00:17:18,599
现在根据ONES，我再给出另一种定义整数的方式

156
00:17:18,599 --> 00:17:48,270
(DEFINE INTEGERS (CONS-STREAM 1 (ADD-STREAM INTEGERS ONES)))

157
00:17:54,950 --> 00:18:06,640
整数的第一个数是1，其余的数则是将整数全部加1

158
00:18:06,640 --> 00:18:13,940
按这种方式，第二个整数就是第一个整数加1

159
00:18:13,940 --> 00:18:31,250
得到第三个整数的过程也和得到第二个整数的过程类似，就是一个不断加1的过程

160
00:18:35,240 --> 00:18:36,310
它居然可以运行，有点匪夷所思，

161
00:18:36,310 --> 00:18:40,150
这样的过程可以正常运行的关键在于延时求值

162
00:18:40,150 --> 00:18:43,870
我们来看这个ONES

163
00:18:43,870 --> 00:18:51,130
这看起来根本不可能，我想知道ONES是什么，你却告诉我说把1和ONES连接在一起就是ONES

164
00:18:51,130 --> 00:18:55,250
它之所以可以运行是因为暗中隐藏的delay

165
00:18:55,250 --> 00:19:00,290
关键是，cons-stream是只是一个缩写

166
00:19:00,290 --> 00:19:08,785
实际是(CONS 1 (DELAY ONES))

167
00:19:12,140 --> 00:19:15,500
再来实际看一下

168
00:19:15,500 --> 00:19:18,020
这里定义ONES

169
00:19:18,020 --> 00:19:20,700
首先我发现ONES是一个CONS

170
00:19:20,700 --> 00:19:32,710
CAR部分是1，CDR部分则是一个计算的约定

171
00:19:32,710 --> 00:19:37,270
不用担心说ONES还没有被定义，你这里怎么可以写一个ONES

172
00:19:37,270 --> 00:19:40,670
将运行整个定义的时候，ONES就被定义了

173
00:19:40,670 --> 00:19:44,920
所以当我再访问到这个部分时，ONES已经被定义过了

174
00:19:44,920 --> 00:19:46,590
这一点非常隐讳

175
00:19:46,590 --> 00:19:48,470
下面整数的定义也是如此

176
00:19:48,470 --> 00:19:53,210
我可以在这里使用INTEGERS也是因为CONS-STREAM的缘故

177
00:19:53,210 --> 00:19:57,050
CONS-STREAM把1和剩下的部分连接起来

178
00:19:57,050 --> 00:20:02,570
所以我根本不用关注INTEGERS有没有定义的问题

179
00:20:06,320 --> 00:20:12,430
这个定义好像还是不那么牢靠的样子，这里我们用图形来表示一下

180
00:20:12,430 --> 00:20:15,020
怎么画呢？

181
00:20:15,020 --> 00:20:26,590
ONES这个流，作为输出进入一个加法器，进行流的加法

182
00:20:29,310 --> 00:20:35,760
输出是INTEGERS

183
00:20:40,760 --> 00:20:48,060
加法器另一个加数则是INTEGERS，返过来构成一个循环

184
00:20:48,060 --> 00:20:53,180
还需要在这里加一个初始值1才算完成

185
00:20:57,100 --> 00:21:02,910
要是在1这里加上一个延时的器件，看起来就完全和信号处理是一回事

186
00:21:02,910 --> 00:21:07,860
当然也得除去ONES这个部分

187
00:21:07,860 --> 00:21:17,360
如果你了解信号处理的话，你会发现这个图很像一个有穷状态的accumulator

188
00:21:17,360 --> 00:21:28,440
我们可以稍加修改，就可以将其变成一个有穷状态的accumulator

189
00:21:28,440 --> 00:21:45,700
把ONES换成一个流，INTEGERS就应该是这个流的积分

190
00:21:45,700 --> 00:21:54,260
还需要修改的一点就是，在S输入加法器之前，先将其乘以dt

191
00:21:57,680 --> 00:22:00,000
剩下的就不用改了

192
00:22:00,000 --> 00:22:04,020
用盒子包裹起来，就是一个积分器

193
00:22:09,790 --> 00:22:19,980
对一个流S进行积分，这里的1可以换成一个积分的初始值

194
00:22:19,980 --> 00:22:25,270
这个看起来就非常像是信号处理了

195
00:22:25,270 --> 00:22:27,980
这里，还有一个程序来表示这个图

196
00:22:31,490 --> 00:22:34,010
对一个流进行积分

197
00:22:34,010 --> 00:22:42,230
接收一个流s，一个初始值和dt，产生一个新的流表示积分

198
00:22:42,230 --> 00:22:43,040
然后呢？

199
00:22:43,040 --> 00:22:49,400
内部定义一个流int，将其命名的原因在于可以回调它构成一个循环

200
00:22:49,400 --> 00:23:01,280
这个int流初始值是initial-value

201
00:23:01,280 --> 00:23:06,880
剩下的则是将s缩放dt倍，和int相加

202
00:23:06,880 --> 00:23:10,690
最后我们返回流int

203
00:23:10,690 --> 00:23:15,920
我们为int命名是为了在int内部可以引用int

204
00:23:21,880 --> 00:23:23,710
我们还可以做的更多

205
00:23:23,710 --> 00:23:25,500
来看这个

206
00:23:25,500 --> 00:23:26,895
斐波那契数

207
00:23:26,895 --> 00:23:32,625
定义FIBS

208
00:23:36,350 --> 00:23:37,985
斐波那契数是什么呢？

209
00:23:37,985 --> 00:23:50,090
从0开始，下一个是1

210
00:23:56,260 --> 00:24:11,000
剩下的就是FIBS和FIBS的tail的和

211
00:24:17,570 --> 00:24:20,580
这样来定义斐波那契数

212
00:24:20,580 --> 00:24:21,430
这是如何运作的呢？

213
00:24:21,430 --> 00:24:31,870
假如开始计算斐波那契数，第一个是0，第二个是1

214
00:24:35,790 --> 00:24:45,830
剩下的是两个流的和，一个流是FIBS本身，另一个是FIBS的tail

215
00:24:48,870 --> 00:24:58,360
现在的定义中，我已经能看到FIBS是以0,1开始 FIBS的tail则应该以1开始

216
00:24:58,360 --> 00:25:06,300
这样，FIBS的第三个数就应该是0+1=1，这里写上1，这是也写上1

217
00:25:06,300 --> 00:25:09,390
知道了这些之后，下一个就是2

218
00:25:09,390 --> 00:25:11,700
这里和那里就写上2

219
00:25:11,700 --> 00:25:12,950
下一个是3

220
00:25:14,720 --> 00:25:18,530
这里就是3，这下面就是5了

221
00:25:18,530 --> 00:25:21,500
非常精妙的定义

222
00:25:21,500 --> 00:25:22,830
用不了一行

223
00:25:22,830 --> 00:25:30,150
我也可以把这个定义写到解释器里，然后要求输出FIBS，斐波那契数就开始刷屏了

224
00:25:32,790 --> 00:25:36,810
到了这里，相信我们对递归又多了一些理解

225
00:25:36,810 --> 00:25:45,160
过程可以递归地定义，类似地数据对象也可以递归地定义

226
00:25:45,160 --> 00:25:53,090
想想也比较合理，因为我们早就了解了过程与数据之间没有明显的界限

227
00:25:53,090 --> 00:25:58,210
具体地来讲，流也是由过程来实现的，只不过出于抽象的原因我们用流的时候并不想象的那么清楚罢了

228
00:25:58,210 --> 00:26:03,630
因此，存在递归的过程，有递归的数据也就不足为怪了

229
00:26:07,840 --> 00:26:09,720
非常和谐

230
00:26:09,720 --> 00:26:14,990
不幸地是，流并非什么问题都能解决

231
00:26:14,990 --> 00:26:17,580
我举个例子

232
00:26:17,580 --> 00:26:36,390
假如我们构建了模拟计算机来求解微分方程，比如 y' = y^2，还需要些初始值

233
00:26:36,390 --> 00:26:38,030
y(0) = 1

234
00:26:41,060 --> 00:26:43,690
dt = .0001

235
00:26:46,770 --> 00:26:51,040
很久之间就有人构建模拟计算机来解决这类问题

236
00:26:51,040 --> 00:26:53,020
原理非常简单

237
00:26:53,020 --> 00:27:03,055
先拿一个积分器

238
00:27:03,055 --> 00:27:08,530
初始值是1

239
00:27:08,530 --> 00:27:13,890
还差一个输入和一个输出，输出的结果就是y

240
00:27:13,890 --> 00:27:21,490
输入的是y的导数，在这是y' = y^2

241
00:27:21,490 --> 00:27:42,910
所以这里使用square进行map，返回去作为这里的输入，这就是用来求解这个微分方程的图

242
00:27:42,910 --> 00:27:47,230
现在我们用代码来表示下这个过程

243
00:27:47,230 --> 00:27:49,390
这个图究竟表示的是什么呢？

244
00:27:49,390 --> 00:28:13,790
y可以这样来定义，就是对dy进行积分，初始值是1，间隔是.0001

245
00:28:13,790 --> 00:28:16,805
接下来

246
00:28:16,805 --> 00:28:20,850
来表示y' = y^2

247
00:28:20,850 --> 00:28:33,510
dy就定义为(MAP SQUARE Y)

248
00:28:33,510 --> 00:28:41,410
这就是使用流对整个图的解释，不幸的是，并不能运行

249
00:28:41,410 --> 00:28:51,190
你可以看到这为什么不行，因为这个定义y的地方，是dy的积分，额，dy是什么

250
00:28:51,190 --> 00:28:53,710
没定义啊

251
00:28:53,710 --> 00:28:58,770
所以我得先定义dy

252
00:28:58,770 --> 00:29:03,580
另一方面，如果先定义了dy，又会发现(MAP SQUARE Y)

253
00:29:03,580 --> 00:29:05,770
y也没有定义

254
00:29:05,770 --> 00:29:11,580
这个不能先写，那个也不能，没法玩儿了

255
00:29:17,560 --> 00:29:20,460
有没有什么解决办法呢？

256
00:29:20,460 --> 00:29:22,200
所幸的是这可以解决

257
00:29:22,200 --> 00:29:34,770
这边，我们可以用ONES来定义ONES是因为CONS-STREAM中ONES可以延时求值

258
00:29:34,770 --> 00:29:36,070
巧妙在什么地方呢？

259
00:29:36,070 --> 00:29:40,730
为什么CONS-STREAM增加了DELAY就变得巧妙了呢？

260
00:29:40,730 --> 00:29:45,950
原因在于CONS-STERAM这样做之后就完全不用关心TAIL的部分了

261
00:29:45,950 --> 00:29:54,870
只用关心我把1和什么东西连接在一起了，而且那个东西以1开始

262
00:29:54,870 --> 00:29:57,910
CONS-STREAM就巧妙在这里

263
00:29:59,960 --> 00:30:06,320
增加了一个DELAY，就可以进行自引用的定义了

264
00:30:06,320 --> 00:30:08,190
INTEGRAL也可以用这种方式来解决

265
00:30:08,190 --> 00:30:17,580
我们回头再看看INTEGRAL的定义

266
00:30:17,580 --> 00:30:28,970
求积分的时候，只需要关心我们从initial-value开始积分，并不需要了解整个流

267
00:30:28,970 --> 00:30:33,140
因为积分结果的第一个元素肯定是initial-value

268
00:30:33,140 --> 00:30:37,090
integral的内部就是cons-stream实现的

269
00:30:37,090 --> 00:30:46,710
我们可以这样定义，甚至不用知道要积分的流是什么，只需要知道初始值是什么就行了

270
00:30:46,710 --> 00:30:58,430
INTEGRAL还可以修改地更为精妙，以一个初始值和一个流进行积分，我甚至不用关心这个流是什么，直到积分的时候再来查看这个流

271
00:30:58,430 --> 00:31:03,710
换句话说，这个INTEGRAL就像CONS-STREAM一样，被积分的流延时求值

272
00:31:03,710 --> 00:31:05,610
我们这样修改

273
00:31:05,610 --> 00:31:07,650
来看这个过程

274
00:31:07,650 --> 00:31:17,110
改动的并不多，只是这里的s变成了delay-s，一个经过DELAY的流

275
00:31:17,110 --> 00:31:18,850
这个INTEGRAL又是怎么运作的呢？

276
00:31:18,850 --> 00:31:32,300
内部还是一个CONS-STREAM，初始值就是initial-value，这里还要记住，delay-s是一个被DELAY过的流

277
00:31:34,950 --> 00:31:43,180
到了实际计算的时候，就用FORCE来查看流的实际内容

278
00:31:43,180 --> 00:31:45,970
第一个元素是initial-value

279
00:31:45,970 --> 00:31:59,260
如果有人想要查看流的实际内容是什么，就对延时对象应用FORCE，这里称其为s，然后做流的加法。整个过程有点像CONS-STREAM的感觉

280
00:31:59,260 --> 00:32:07,330
这个被积分的流是什么我根本不会去深究，直到你需要它的时候我才会去查看这个流

281
00:32:10,120 --> 00:32:27,090
如果这样的话，对于y' = y^2的问题也就解决了，只需要将Y的定义中dt改为(DELAY DY)

282
00:32:27,090 --> 00:32:35,280
Y就是对(DELAY Y)的积分，这样一来就可以了

283
00:32:35,280 --> 00:32:44,600
我输入Y的定义，要求一个什么的积分，具体是什么我也不关心，因为是一个延时对象

284
00:32:44,600 --> 00:32:46,320
这之后，再定义dy

285
00:32:46,320 --> 00:32:47,550
没有问题了，因为y已经被定义了

286
00:32:47,550 --> 00:32:51,700
所以在dy内部引用y并没有问题

287
00:32:51,700 --> 00:32:52,840
一切都正常了

288
00:32:52,840 --> 00:32:54,920
这两个流都有初始值

289
00:32:54,920 --> 00:33:00,590
当用SQUARE进行MAP的时候，查看后继的元素并不会引发什么问题，y和dy都被定义过了

290
00:33:00,590 --> 00:33:08,660
DELAY除了在CONS-STREAM之内还是很有用的不是吗？好的，大家有问题么

291
00:33:13,178 --> 00:33:14,428
没有的话，休息一下吧

292
00:34:07,300 --> 00:34:14,320
在刚才休息的时候，我不知道你们有没有发现什么事不对劲

293
00:34:14,320 --> 00:34:34,389
我们通过流将程序表面表现的时间关系与实际在计算机中运行的时间关系分离开来，可以这样分离的原因在于流中的DELAY。在某些时候，我们为了利用这种优势，需要更多的DELAY

294
00:34:34,389 --> 00:34:39,030
也就是要显式地来使用DELAY

295
00:34:39,030 --> 00:34:49,929
我已经用微分方程示例过了，如果你遇到非常复杂的系统，其中有很多自引用的循环，这时你需要在什么地方用DELAY就非常模糊了

296
00:34:49,929 --> 00:34:55,550
假如你一不小心漏了一个，程序会出错而且你还不知道哪里出了错

297
00:34:55,550 --> 00:35:08,690
我们显式使用DELAY获得的力量不足以克服大型的复杂的系统，因为它们并不能像流一样把DELAY隐藏起来，这非常混乱

298
00:35:08,690 --> 00:35:11,036
有没有什么解决方案呢？

299
00:35:11,036 --> 00:35:13,480
所幸地是 有

300
00:35:13,480 --> 00:35:25,450
我可以改变整个语言，所有过程表现起来就像CONS-STREAM一样，因此每一个过程都对其参数延时求值

301
00:35:25,450 --> 00:35:27,520
什么意思呢？

302
00:35:27,520 --> 00:35:32,210
就是说 你执行一个过程，并不马上对参数求值

303
00:35:32,210 --> 00:35:39,260
相反地，它们只有在需要被求值的时候才会被求值，因此它们可以不被求值的传递至其它过程中，一直这样传递下去

304
00:35:39,260 --> 00:35:42,150
过程传递的只是计算的约定而已

305
00:35:42,150 --> 00:35:52,380
直到最后你需要查看某个值的时候，这才真正的求出这个部分的值

306
00:35:52,380 --> 00:36:02,920
假如我们这样做了，就不需要显式的使用DELAY了，任何东西都有DELAY，它完全内建在语言之中了

307
00:36:02,920 --> 00:36:34,560
换句话说，技术上这是一种正则序求值的语言，和我们一直使用的应用序求值不同

308
00:36:34,560 --> 00:36:36,835
还记得应用序吧

309
00:36:36,835 --> 00:36:43,590
就是你求值一个表达式的时候，每个部分都要预先计算出来

310
00:36:43,590 --> 00:36:47,600
参数具体求值之后，才代换入过程

311
00:36:47,600 --> 00:36:49,890
正则序则不是这样

312
00:36:49,890 --> 00:36:58,640
代换的过程是一样的，不过并不先对参数求值，只是代换入了一个计算的约定

313
00:36:58,640 --> 00:37:09,340
换句话说，这个表达式作为参数，就直接的把这个表达式代换入过程，并不进行求值直到需要求值的时候

314
00:37:09,340 --> 00:37:11,840
这就是所谓的正则序求值语言

315
00:37:11,840 --> 00:37:13,490
为什么不这样做呢？

316
00:37:13,490 --> 00:37:18,940
这样做了之后，我们就获得了延时求值的所有优点

317
00:37:18,940 --> 00:37:24,710
CONS也会是延时求值的，就和CONS-STREAM一样

318
00:37:24,710 --> 00:37:32,350
也不需要流了，因为列表会自动的像流那样，所有的数据对象都会被延时求值

319
00:37:32,350 --> 00:37:35,270
所有的，不是么？

320
00:37:35,270 --> 00:37:41,020
直到需要答案的时候才去实际的求值

321
00:37:41,020 --> 00:37:44,790
也不用担心这些显式的DELAY了

322
00:37:44,790 --> 00:37:47,160
为什么不这样做呢？

323
00:37:47,160 --> 00:37:49,230
首先，已经有人这样做过了

324
00:37:49,230 --> 00:37:51,850
这是一类十分优雅的语言

325
00:37:51,850 --> 00:38:00,710
其中最为人称道的是一门名为Miranda的语言，是肯特大学的David Turner发明的

326
00:38:00,710 --> 00:38:01,930
它就是用这样的原理实现的

327
00:38:01,930 --> 00:38:14,970
正则序求值，列表就像流一样。如果你用Miranda来解决像质数，八皇后这样的问题，写出来的过程看起来就很普通

328
00:38:14,970 --> 00:38:17,790
DELAY已经内建入语言了

329
00:38:17,790 --> 00:38:19,040
但是这样也有不足之处

330
00:38:21,190 --> 00:38:23,170
还记得我们为什么引入流了吗

331
00:38:23,170 --> 00:38:27,480
我们把程序的时间和它实际执行的时间相分离

332
00:38:27,480 --> 00:38:33,140
如果我们在所有地方都引入了DELAY，这也是我们现在正在做的

333
00:38:33,140 --> 00:38:39,300
编程就完全是单纯地描述解决方案的事了

334
00:38:39,300 --> 00:38:47,030
我们完全放弃了对时间的控制，尽管语言变的优雅起来，但是牺牲了太多东西

335
00:38:47,030 --> 00:38:51,480
并且还有一些致命的缺陷

336
00:38:51,480 --> 00:38:53,980
其中之一就是迭代

337
00:38:53,980 --> 00:39:01,230
我们以前写过，迭代的来求阶乘

338
00:39:01,230 --> 00:39:12,120
fact-iter内部定义一个过程iter，它时刻记录着product和counter的状态，就这样迭代的求解

339
00:39:12,120 --> 00:39:15,730
我们说这是一个迭代过程是因为它并没有把状态堆积给解释器

340
00:39:15,730 --> 00:39:23,900
因为状态时刻作为参数传递给了自身

341
00:39:23,900 --> 00:39:31,660
也可以用代换具体的实践来看，这个迭代的过程，并没有状态堆积导致表达式增长的情况

342
00:39:31,660 --> 00:39:34,840
因此这是一个迭代过程

343
00:39:34,840 --> 00:39:41,150
但是现在用正则序的思维来看

344
00:39:41,150 --> 00:39:45,650
这个迭代过程会变成什么样子

345
00:39:45,650 --> 00:39:52,330
如果你用正则序去进行代换，一直代换下去表达式就会变得越来越长

346
00:39:52,330 --> 00:39:53,280
为什么会这样？

347
00:39:53,280 --> 00:39:58,080
因为iter递归的调用自己，把product代换为(* counter product)

348
00:39:58,080 --> 00:40:02,510
在正则序里，这个乘法在这里并没有求值

349
00:40:02,510 --> 00:40:06,670
传递并代换的只是这个乘法计算的约定

350
00:40:06,670 --> 00:40:09,760
然后iter继续代换下去

351
00:40:09,760 --> 00:40:18,400
用这样的计算约定反复的递归代换

352
00:40:18,400 --> 00:40:19,430
代换

353
00:40:19,430 --> 00:40:31,790
如果你实际模拟下这个过程，你会清楚的看到状态的堆积，所有的约定直到最后才被计算

354
00:40:31,790 --> 00:40:36,980
所以正则序不能表达迭代的计算过程

355
00:40:36,980 --> 00:40:54,610
或许这个问题有更深层次的理论上的原因，事实上许多写操作系统的人都很头疼这类问题。比如你用这类语言实现了一个文本编辑器

356
00:40:54,610 --> 00:41:10,230
但是你才用了一会儿，就会发现已经占用了3MB空间，充斥了未被计算的约定，这个应该是被称为拖尾问题，就因为不能表示迭代过程的缘故

357
00:41:10,230 --> 00:41:20,110
一个针对这种语言的研究方向就是如何采用一种编译技术来避免拖尾问题

358
00:41:20,110 --> 00:41:23,940
非常困难

359
00:41:23,940 --> 00:41:32,056
在不能表示迭代之外，正则序求值还有另一个缺点

360
00:41:32,056 --> 00:41:42,000
很遗憾的是，正则序求值与赋值副作用是不相容的

361
00:41:42,000 --> 00:41:45,350
它们在一起效果并不好

362
00:41:45,350 --> 00:42:00,400
你不能对有局部状态的对象同时应用正则序求值来分离时间延时求值

363
00:42:00,400 --> 00:42:03,790
我来举一个非常简单的例子

364
00:42:03,790 --> 00:42:07,520
假设语言是正则序求值

365
00:42:07,520 --> 00:42:09,550
例子是这样的

366
00:42:09,550 --> 00:42:10,520
注意现在是正则序求值

367
00:42:10,520 --> 00:42:13,570
定义x是0

368
00:42:13,570 --> 00:42:15,750
初始化的变量

369
00:42:15,750 --> 00:42:22,640
下面这个过程 id 比较有趣

370
00:42:22,640 --> 00:42:26,770
它用x来记录上一次id过程的参数值

371
00:42:31,620 --> 00:42:36,760
这个过程最后只是返回了n，但是还把x赋值为n

372
00:42:36,760 --> 00:42:42,580
最后再定义一个过程inc，也非常简单

373
00:42:42,580 --> 00:42:47,230
假设在正则序求值的语言里，求值下面的表达式

374
00:42:47,230 --> 00:42:54,190
(define y (inc (id 3)))，y的值应该是4

375
00:42:57,410 --> 00:42:59,520
x应该是多少呢？

376
00:42:59,520 --> 00:43:04,710
x应该是上一次我们执行过程id的参数值

377
00:43:04,710 --> 00:43:08,530
你可能会想，这里x应该是3，但是并不是这样

378
00:43:08,530 --> 00:43:17,000
因为我定义y的时候，只是一个计算的约定

379
00:43:17,000 --> 00:43:21,560
所以(id 3)的这部分并没有求值

380
00:43:21,560 --> 00:43:25,320
我输入这个定义之后，x并没有改变，还是0

381
00:43:28,360 --> 00:43:38,342
现在我输入y，要求对y求值，y就是4，(id 3)就在求值y的过程中被求值

382
00:43:38,342 --> 00:43:40,740
所以再来看x，x就应该是3

383
00:43:40,740 --> 00:43:42,020
上面这里的x是0

384
00:43:42,020 --> 00:43:43,280
下面这里是3

385
00:43:43,280 --> 00:43:57,100
这是一个非常简单的模拟场景，但是你可以观察到当你用正则序求值，甚至连变量的值都很难弄清楚

386
00:43:57,100 --> 00:43:59,690
很令人迷惑

387
00:43:59,690 --> 00:44:09,780
深层次的原因，我想应该是所有都有了DELAY之后，我们也就完全脱离了时间的概念

388
00:44:09,780 --> 00:44:11,750
也因为如此我们可以处理一些无穷的情况

389
00:44:11,750 --> 00:44:17,790
脱离了时间之后，就没有必要非要等到哪一刻才开始运行，不是吗？

390
00:44:17,790 --> 00:44:28,760
这样我就把程序所表示的时间顺序与实际运行的时间顺序分离开来。但是当我们谈及状态、赋值和改变，它们都和时间相关

391
00:44:28,760 --> 00:44:34,570
从根本上相矛盾

392
00:44:34,570 --> 00:44:42,410
这仿佛是一个哲学问题，从什么样的角度观察世界，构建什么样的模型

393
00:44:42,410 --> 00:44:47,140
有时这也被称为“函数式程序设计的争论”

394
00:44:53,570 --> 00:45:00,440
所谓完全函数式的语言是那种完全没有副作用的语言

395
00:45:00,440 --> 00:45:06,360
没有副作用，没有赋值，也不用担心有什么糟糕的后果

396
00:45:06,360 --> 00:45:07,930
可以使用代换模型

397
00:45:07,930 --> 00:45:15,050
程序更像是数学计算，而不是构建模型或对象

398
00:45:15,050 --> 00:45:17,170
函数式语言有很多了不起的特性

399
00:45:17,170 --> 00:45:29,260
没有时间的概念，所以完全不用担心同步的问题。如果你把这些应用在并行算法上，就可以并行计算不同的部分

400
00:45:29,260 --> 00:45:33,640
从来不担心同步问题，这几乎是与生俱来的

401
00:45:33,640 --> 00:45:35,450
代价是放弃了赋值

402
00:45:39,060 --> 00:45:44,520
一些函数式编程的狂热分子会说，这点代价算不了什么

403
00:45:44,520 --> 00:45:46,510
确实，在大部分情况下不用赋值也可以

404
00:45:46,510 --> 00:45:54,190
如果用你用赋值，就得想办法用其它方式来解决原来用对象解决的问题

405
00:45:54,190 --> 00:45:56,300
有没有什么例子呢？

406
00:45:56,300 --> 00:46:00,300
想想我们如何走到这一步的

407
00:46:00,300 --> 00:46:04,440
我们构造有独立状态的对象

408
00:46:04,440 --> 00:46:06,840
还记得Jerry的随机数生成器吧

409
00:46:06,840 --> 00:46:14,080
随机数生成器内部有一个状态，根据这个状态计算下一个随机数，下下一个等等

410
00:46:14,080 --> 00:46:21,050
我们可以将随机数生成与蒙特卡洛算法分离开来，因此赋值在这里就异常重要了

411
00:46:21,050 --> 00:46:24,070
我们用模块化来封装状态

412
00:46:24,070 --> 00:46:27,560
使用函数式编程的程序员可能会说，“你搞错了”

413
00:46:27,560 --> 00:46:29,840
“我的意思是，你能写出另一种更具模块化的程序”

414
00:46:29,840 --> 00:46:33,250
“从另一种角度来思考模块化”

415
00:46:33,250 --> 00:46:36,880
一直为生成一个又一个的随机数所烦恼

416
00:46:36,880 --> 00:46:39,880
为什么不写一个这样的程序

417
00:46:39,880 --> 00:46:44,445
写一个枚举器，生成一个无穷的随机数的流

418
00:46:49,010 --> 00:46:54,540
一次性就生成所有的随机数，而且还可以为其它地方使用

419
00:46:54,540 --> 00:47:06,880
如果你想的话，就可以把这个流接过来，到这个蒙特卡洛测试的过程

420
00:47:06,880 --> 00:47:28,140
输出的是一个流，其中是一连串的对PI的估计值

421
00:47:28,140 --> 00:47:35,540
和前面讲的类似，这样用流的连接，可以“拖出“无限个随机数来计算蒙特卡洛测试

422
00:47:35,540 --> 00:47:39,720
我们使用的随机数越多，最后对PI的估计值就越准

423
00:47:39,720 --> 00:47:43,890
具体的计算过程还是一样的，只不过使用了另一种模块化的方式

424
00:47:43,890 --> 00:47:49,400
我们假如一次性生成了所有的随机数

425
00:47:49,400 --> 00:47:53,860
这个过程的细节在书上有

426
00:47:53,860 --> 00:48:03,280
相似地还有别的例子，我们也习惯于一次一次来，但完全可以不这么来想

427
00:48:03,280 --> 00:48:08,900
我们来思考一下银行系统

428
00:48:08,900 --> 00:48:12,210
假设我们这里这个程序代表了银行帐户

429
00:48:18,810 --> 00:48:31,510
如果我们以信息传递的角度来看，银行帐户应该是一个对象，内部保存着局部状态balance金额

430
00:48:34,110 --> 00:48:48,560
如果一个用户发出交易申请，比如存钱，这个银行帐户就会用最新的balance金额作出回应

431
00:48:48,560 --> 00:48:54,350
比如我们存点钱，帐户就会返回存钱后总金额是多少

432
00:48:54,350 --> 00:48:59,150
用户发出信息，帐户反馈信息

433
00:48:59,150 --> 00:49:03,200
就随机数生成器一样，我们得用赋值才可以

434
00:49:03,200 --> 00:49:09,570
帐户的内部保存了局部状态balance，因此就把用户的状态和帐户的状态分离开来

435
00:49:13,280 --> 00:49:16,420
这是从信息传递的角度来看

436
00:49:16,420 --> 00:49:22,740
如果从流的角度来看，就不需要赋值或副作用之类

437
00:49:22,740 --> 00:49:31,180
我们不想任何有关局部状态的事

438
00:49:31,180 --> 00:49:38,640
可以认为银行帐户是一个处理一系列交易请求的东西

439
00:49:38,640 --> 00:49:49,490
帐户不是一个处理信息的对象了，而是处理交易请求流的东西

440
00:49:49,490 --> 00:49:55,940
比如1 2 2 4，连续的存钱交易

441
00:49:55,940 --> 00:50:03,770
从帐户出来的流应该是1 3 5 9

442
00:50:03,770 --> 00:50:10,820
帐户没有局部状态，它只是一个流处理器

443
00:50:10,820 --> 00:50:12,370
记住，这样想的话，就没有了时间的概念

444
00:50:12,370 --> 00:50:30,010
如果这里有一个用户，我们把他的所有交易看做是无穷的流，帐户一次处理一个元素，所有的balance金额也作为一个流

445
00:50:30,010 --> 00:50:39,560
如果在这里划一条线，用户从外面来看，根本不能分辨银行帐户到底有没有状态

446
00:50:39,560 --> 00:50:42,660
因为它们对外表现是一样的

447
00:50:45,120 --> 00:50:53,835
哦，顺便提一个，这里有一个具体的代码实现 -- 假设我们只存钱

448
00:50:53,835 --> 00:51:00,020
这个过程接受一个balance初始值和一个存钱交易流

449
00:51:00,020 --> 00:51:00,820
具体怎么做呢？

450
00:51:00,820 --> 00:51:18,300
很简单，只不过是用CONS-STREAM把初始金额和递归调用make-deposit-account的结果组合在一起，递归调用的时候，金额参数要加上第一次要存的钱，流参数变为交易流的TAIL

451
00:51:18,300 --> 00:51:28,790
原来用面向对象解决的问题，我们用流就可以解决

452
00:51:28,790 --> 00:51:32,250
很多地方都可以这样思考

453
00:51:32,250 --> 00:51:36,400
可能你会想了，我能不用赋值做所有的事情吗？

454
00:51:36,400 --> 00:51:40,050
可以只用纯函数式语言来编程吗？

455
00:51:40,050 --> 00:51:48,100
这个问题谁也说不清，好像有些地方用函数式编程不太妥当

456
00:51:48,100 --> 00:51:58,850
比如关于银行帐户的一个更复杂的例子，函数式也会有点吃力因为我们混入了共享的问题，这里两个用户共享一个帐户

457
00:51:58,850 --> 00:52:02,960
在这种情况下，假如你来扩展这个帐户

458
00:52:02,960 --> 00:52:04,210
这是一个帐户

459
00:52:12,220 --> 00:52:18,780
帐户取一个交易流，生成一个新的流

460
00:52:18,780 --> 00:52:26,090
假如这个帐户是两个独立的用户共享的会怎么样

461
00:52:26,090 --> 00:52:33,140
假设两个人Bill和Dave，共享一个帐户

462
00:52:35,960 --> 00:52:36,850
怎么来建模呢？

463
00:52:36,850 --> 00:52:45,880
Bill有一个交易流，Dave也有一个交易流，可以把这两个流合并在一起再输入帐户

464
00:52:45,880 --> 00:53:01,190
所以我们只需要一个merge的过程，将这两个流合并为一个流就行

465
00:53:01,190 --> 00:53:03,610
现在他们就共享一个帐户了

466
00:53:03,610 --> 00:53:06,600
看起来不错，问题是怎么来实现merge

467
00:53:06,600 --> 00:53:09,730
merge根据什么来合并？

468
00:53:09,730 --> 00:53:12,760
而且要合并的合理

469
00:53:12,760 --> 00:53:24,150
第一反应可能这样想，两个流依次一个一个取，但是如果突然Dave外出度假了两年会怎么样？

470
00:53:24,150 --> 00:53:27,690
Bill的交易就完全被阻塞了

471
00:53:27,690 --> 00:53:29,750
你想要的是

472
00:53:29,750 --> 00:53:33,380
是一种公平的合并

473
00:53:38,410 --> 00:53:46,010
这个所谓公平的合并应该是交替地一次处理一个，但是如果一个人没有了交易，应该继续去处理另一个人的交易

474
00:53:46,010 --> 00:53:48,450
你们可以注意到我完全没有谈论时间

475
00:53:51,300 --> 00:54:18,010
一个在函数式编程研究方面比较活跃的课题之一就是发明一种公平合并的方式，取代原来用面向对象开发的系统，避免赋值与状态带来的问题

476
00:54:20,780 --> 00:54:38,360
你们也看到了，我现在所触及的是计算机科学方面非常根本的一个问题，如何开发一种语言，使其可以延时求值同时又可以面向对象

477
00:54:38,360 --> 00:54:41,230
怎么样才能两者兼有之？

478
00:54:41,230 --> 00:54:43,040
想来这很困难

479
00:54:43,040 --> 00:54:53,840
但是这个很困难的问题却和计算机科学的关系不大，它真正涉及的是两个看待世界不同的方式

480
00:54:53,840 --> 00:54:55,090
大家有问题吗？

481
00:55:17,556 --> 00:55:25,890
你之前提到过，一旦引入了赋值，就不能使用代换模型了

482
00:55:25,890 --> 00:55:27,570
除非你非常小心

483
00:55:27,570 --> 00:55:28,260
对的

484
00:55:28,260 --> 00:55:40,300
有什么方法或者什么原则来说明清楚这个“很小心”是怎么回事吗？

485
00:55:40,300 --> 00:55:42,890
我不知道

486
00:55:42,890 --> 00:55:45,430
我想想

487
00:55:45,430 --> 00:55:51,480
当然，在实现DELAY中的memo-proc也使用了赋值，但是它被隐藏了起来

488
00:55:51,480 --> 00:55:53,480
因为它没有对结果造成其它的不同

489
00:55:53,480 --> 00:56:00,390
部分原因之一在于一旦这个过程被求值，得到answer，answer就不会再变化了

490
00:56:00,390 --> 00:56:02,080
有点像一次赋值

491
00:56:02,080 --> 00:56:11,250
所以如果你只用这种一次赋值并且它不再改变，我想应该不会有太大问题

492
00:56:11,250 --> 00:56:18,490
还有一个问题在于merge -- 让我想想对不对

493
00:56:18,490 --> 00:56:30,820
我认为有了公平合并这一技术，在其它的地方你都可以有效的来模拟赋值

494
00:56:30,820 --> 00:56:39,520
这有点像你把要做的事转移到了外面 -- 我不知道这对于公平合并是否准确，但是对一些更广泛的事是适用的

495
00:56:39,520 --> 00:56:47,970
所以可能真的实现了这种技术，突然你能用这种语言来做任何事，其实应该和你拥有了赋值一样也会遇到糟糕的情况

496
00:56:47,970 --> 00:56:51,590
这也是人们在研究的一个领域

497
00:56:51,590 --> 00:57:04,730
在merge这一点我有点问题，如是Bill是一个过程，当我调用Bill的时候，Bill就应该来存款或者说构造一个元素来输入

498
00:57:04,730 --> 00:57:07,170
如果我调用Dave两次，他肯定也会存款两次

499
00:57:07,170 --> 00:57:09,350
所以何来的公平合并呢

500
00:57:09,350 --> 00:57:11,200
关键在于你得把这些当作真人一样

501
00:57:11,200 --> 00:57:14,850
就是，这里有一个用户来操作帐户

502
00:57:14,850 --> 00:57:17,070
请求一次，得到结果

503
00:57:17,070 --> 00:57:18,200
对

504
00:57:18,200 --> 00:57:24,220
但是如果我交替的来处理两个人的请求 AUDIENCE：为什么要交替着？

505
00:57:24,220 --> 00:57:25,070
为什么不呢？

506
00:57:25,070 --> 00:57:26,140
嗯？

507
00:57:26,140 --> 00:57:26,580
为什么要？

508
00:57:26,580 --> 00:57:27,640
假设这些是现实中的人，对吗？

509
00:57:27,640 --> 00:57:29,280
这个人外出一年

510
00:57:29,280 --> 00:57:35,480
你只能空守在帐户旁边就是不能处理两个请求，因为你还得等这个度假的人

511
00:57:35,480 --> 00:57:37,380
为什么非得等他呢？

512
00:57:37,380 --> 00:57:39,110
因为这里是在计算一个函数

513
00:57:39,110 --> 00:57:41,720
我必须定义一个函数

514
00:57:41,720 --> 00:57:51,690
换种方式来说，merge的输出并不是merge输入的函数

515
00:57:51,690 --> 00:57:53,490
明白了吗？再来看看这个merge是怎么运行的

516
00:57:53,490 --> 00:58:03,470
假设Bill输入 1 1 1 1，Dave输入2 2 2 2

517
00:58:03,470 --> 00:58:05,910
merge应该输出什么呢？

518
00:58:05,910 --> 00:58:08,740
这里应该是1 2 1 2 1 2

519
00:58:08,740 --> 00:58:09,390
我明白了

520
00:58:09,390 --> 00:58:11,560
当Bill再输入1 1，merge再输出两个11

521
00:58:11,560 --> 00:58:13,950
Dave再输入两个2，merge就输出两个2

522
00:58:13,950 --> 00:58:15,450
就是这样

523
00:58:15,450 --> 00:58:23,980
为什么不能在输入的数据上加上时间信息呢？PROFESSOR：因为这里没有时间这个概念

524
00:58:23,980 --> 00:58:26,900
我只是定义一个函数

525
00:58:26,900 --> 00:58:28,150
没有时间概念

526
00:58:32,070 --> 00:58:38,420
除掉那种没人在需要等他的情况，如果我们交替的来merge

527
00:58:38,420 --> 00:58:47,810
这里有两个流，一个是Dave生成的与时间无关的无穷长度的流

528
00:58:47,810 --> 00:58:51,690
另一个是Bill的，我现在要操作这些东西

529
00:58:51,690 --> 00:58:53,510
这就是银行帐户的工作原理

530
00:58:56,710 --> 00:59:05,340
带来的问题就是倒霉的人可能提出了交易，但是并不能及时的得到回复

531
00:59:05,340 --> 00:59:10,070
他们也没有意识到他们所做过的交易是以一种流的方式来处理的

532
00:59:10,070 --> 00:59:11,550
他们只是等着，等待帐户的响应

533
00:59:14,290 --> 00:59:25,290
假设你坐在屏幕前操作着一台分时系统的计算机，你输入一些指令想看到结果

534
00:59:25,290 --> 00:59:30,910
但是你并不想主机在处理完所有其它人的命令之后再来处理你的命令

535
00:59:30,910 --> 00:59:33,890
这就是问题所在

536
00:59:33,890 --> 00:59:36,850
我的意思是，人们总能及时的得到结果

537
00:59:36,850 --> 00:59:38,620
如果没有，这也不能算作一个问题

538
00:59:49,100 --> 00:59:54,740
我想我还是不太理解这个银行交易中没有时间概念这一要点

539
00:59:54,740 --> 00:59:56,880
时间不重要吗？

540
00:59:56,880 --> 01:00:00,790
举例说，有一系列事件

541
01:00:00,790 --> 01:00:08,400
比如Dave取款$100，这些顺序应该很重要才对

542
01:00:08,400 --> 01:00:11,260
你怎么能把它们看作是流呢？

543
01:00:11,260 --> 01:00:14,260
这个问题非常好

544
01:00:14,260 --> 01:00:17,510
在这个例子中确实做不到那一点

545
01:00:17,510 --> 01:00:18,610
做不到

546
01:00:18,610 --> 01:00:24,170
关键在于这里的输出不只是这两个流的函数

547
01:00:24,170 --> 01:00:32,860
它是这两个流和某种关于时间的信息的函数，但是由于正则序语言的原因，这种时间信息表示不出来

548
01:00:34,810 --> 01:00:46,400
为了让这个银行系统更为有效，我们能不能把时间戳信息加在Bill和Dave的交易请求之前，以便merge可以根据这个来运作？

549
01:00:49,150 --> 01:00:49,550
当然，当然可以

550
01:00:49,550 --> 01:00:50,600
你可以那样做

551
01:00:50,600 --> 01:01:00,970
我们可以想像这个merge每毫秒读一次输入，如果这个时间点没有请求，就什么都不做

552
01:01:00,970 --> 01:01:03,610
这和你刚刚说的那种方式是相同的

553
01:01:03,610 --> 01:01:07,110
当然可以这样做，但是那不是我们关注的重点

554
01:01:07,110 --> 01:01:10,170
我们不只是关心函数的具体实现

555
01:01:10,170 --> 01:01:18,824
我们更关心语言的表现力，现在我们遇到的问题主要在于我们能轻松表达出来的和我们想要表达的不相符

556
01:01:18,824 --> 01:01:26,080
听起来好像如果两个人同时发出请求，这个方法就会出问题

557
01:01:26,080 --> 01:01:28,530
也不是特指这一个问题，而是关乎你如何来定义这个函数的问题

558
01:01:28,530 --> 01:01:36,110
你也可以说Dave一次性处理两个请求，但是如果你预先定义些什么，这种方式也会出问题

559
01:01:36,110 --> 01:01:41,930
所以说交易有很多种方式，你无法根据特定的交易情况来决定如何定义

560
01:01:41,930 --> 01:01:47,290
有一个更坏的消息是，甚至有一些情况连merge也处理不了

561
01:01:47,290 --> 01:01:52,470
假如你把更多的人关联在这个银行帐户上

562
01:01:52,470 --> 01:01:56,030
假如这个人是John

563
01:01:56,030 --> 01:02:02,040
这个流我就先不往上画了，也同样连接在merge上

564
01:02:02,040 --> 01:02:08,860
这种情况甚至公平合并也无法给出合理的合并，我们称其为natagers还是什么我记不清了

565
01:02:08,860 --> 01:02:11,790
需要一种更为广泛化的公平合并也解决

566
01:02:11,790 --> 01:02:19,580
有很多研究都在讨论，引入越来越多的机制，函数式思维能达到怎样的程度？

567
01:02:19,580 --> 01:02:25,610
到什么样的程度它也会出问题，就和我们使用赋值一样

568
01:02:25,610 --> 01:02:28,960
干脆自动取款好了

569
01:02:28,960 --> 01:02:39,630
[笑声]

570
01:02:39,630 --> 01:02:40,880
好的，今天就到这里

