1
00:00:20,970 --> 00:00:28,870
之前我们考查了流，可以用信号处理类似的方式来组织程序

2
00:00:28,870 --> 00:00:40,635
要记住的是，关键在于我们将程序看起来的运算顺序与实际在机器中计算的顺序分离开来

3
00:00:40,635 --> 00:00:47,500
那就意味着，我们着手处理非常长的流，其中的元素只是在需要的时候才生成

4
00:00:47,500 --> 00:00:51,560
这种按需计算的方式是内建在流的数据结构中的

5
00:00:54,450 --> 00:00:58,040
即使这个流非常之长，我们也可以只计算我们需要的

6
00:00:58,040 --> 00:01:00,750
只有当我们要求的时候，新的数据才会生成

7
00:01:00,750 --> 00:01:02,110
例子是什么呢？

8
00:01:02,110 --> 00:01:04,800
真的像我们所说的那样吗？

9
00:01:04,800 --> 00:01:11,050
举个例子，假如我们想要一个流中的第n个元素

10
00:01:16,360 --> 00:01:20,400
这个过程可以计算出来

11
00:01:20,400 --> 00:01:25,570
n代表第n个，s是一个流，剩下的只需要沿着流递归下去

12
00:01:25,570 --> 00:01:27,960
n是0的时候就是终点

13
00:01:27,960 --> 00:01:34,310
否则，就在流的TAIL查找第n-1个元素

14
00:01:34,310 --> 00:01:41,700
看起来是LISP中很普通的编程方式，但是不同之处在于，我们沿着流取值，只有途经的n个元素被计算出来

15
00:01:41,700 --> 00:01:45,910
因为它们被FORCE了

16
00:01:45,910 --> 00:01:49,300
这里有另一个简单的过程，打印一个流

17
00:01:49,300 --> 00:01:54,150
把流中的元素依次打印输出

18
00:01:54,150 --> 00:01:55,315
我们要怎么做呢？

19
00:01:55,315 --> 00:01:59,720
先打印流的head，流的head这时就被计算出来

20
00:01:59,720 --> 00:02:04,990
然后再递归打印流的tail

21
00:02:04,990 --> 00:02:09,660
如果流为空，就返回一个“done”的消息

22
00:02:09,660 --> 00:02:14,310
如果你构造了一个流 这个流非常之长

23
00:02:14,310 --> 00:02:21,320
这时你再来打印这个流 流中的元素会依次的计算并打印出来

24
00:02:21,320 --> 00:02:24,680
并不会一次性的全部计算出来

25
00:02:24,680 --> 00:02:30,190
正因为如此 我们就能处理非常长的流

26
00:02:30,190 --> 00:02:33,600
多长呢？

27
00:02:33,600 --> 00:02:36,360
无穷

28
00:02:36,360 --> 00:02:38,920
我们用电脑来实践一下

29
00:02:38,920 --> 00:02:57,420
在解释器里，我们输入(DEFINE (INTEGERS-FROM N) 定义一个从N开始的整数流

30
00:02:59,760 --> 00:03:19,010
(CONS-STREAM N (INTEGERS-FROM (+ N 1))))

31
00:03:24,680 --> 00:03:25,930
这样就我们要的全部整数

32
00:03:28,800 --> 00:03:31,500
现在我们用这个表示所有的整数

33
00:03:34,410 --> 00:03:44,580
(DEFINE INTEGERS (INTEGERS-FROM 1))

34
00:03:48,840 --> 00:04:02,995
现在执行 (NTH-STREAM 20 INTEGERS) 查看第20个元素

35
00:04:02,995 --> 00:04:07,270
得到21 因为我们以n=0为结束条件

36
00:04:07,270 --> 00:04:09,450
或者我们来点更复杂的

37
00:04:09,450 --> 00:04:10,840
我再来定义一个谓词

38
00:04:13,740 --> 00:04:19,160
(DEFINE (NO-SEVEN X）

39
00:04:19,160 --> 00:04:23,376
它可以检测一个整数，判断是否是7的倍数

40
00:04:28,820 --> 00:04:38,175
(NOT (= (REMAINDER X 7) 0))) X对7的余数不为0

41
00:04:41,890 --> 00:04:58,885
这时用NO-SEVEN这个谓词，过滤全部的整数

42
00:05:11,570 --> 00:05:16,360
这样就得到了所有不是7的倍数的整数

43
00:05:16,360 --> 00:05:28,320
现在我来查看第100个不是7的倍数的整数

44
00:05:28,320 --> 00:05:35,270
或者你也想知道这个流的全部元素

45
00:05:35,270 --> 00:05:41,700
(PRINT-STREAM NS) 来尝试打印这个流 现在输出个不停

46
00:05:45,100 --> 00:05:47,070
无穷的数应该永远打印不完吧

47
00:05:52,670 --> 00:06:01,100
你可能会问了，你写的这个INTEGERS真的是全部的整数吗？

48
00:06:01,100 --> 00:06:04,053
现在我画一个图来表示下这个过程

49
00:06:08,170 --> 00:06:19,775
这是我们刚才对整数的定义，它组合起第一个整数和剩下的整数，现在我们画个图来看看

50
00:06:22,720 --> 00:06:27,420
抽象地来看，我画一个盒子来表示从n开始的所有整数

51
00:06:27,420 --> 00:06:37,705
它接受一个参数n，然后返回一个流，这个流表示从n开始的所有整数

52
00:06:37,705 --> 00:06:38,690
接下来

53
00:06:38,690 --> 00:06:42,470
哦 给盒子写上名字

54
00:06:45,070 --> 00:06:45,800
里面是什么样子

55
00:06:45,800 --> 00:06:54,110
取得参数n之后，将其 +1

56
00:06:58,030 --> 00:07:03,170
然后递归的作为另一个INT-FROM盒子的参数

57
00:07:06,870 --> 00:07:14,270
最后的这个结果和n组合起来，构成了最后外层盒子所返回的流

58
00:07:14,270 --> 00:07:18,530
刚才那个过程画出来就是这样子

59
00:07:18,530 --> 00:07:18,780
很有意思

60
00:07:18,780 --> 00:07:23,320
这种画法是Peter Henderson发明的，就是之前绘图语言的发明者

61
00:07:23,320 --> 00:07:28,530
这种图也被称为Henderson diagram  画这种图需要遵守一定的约定

62
00:07:28,530 --> 00:07:37,270
这些实线代表生成的流，这些虚线则作为盒子的输入初始值

63
00:07:37,270 --> 00:07:43,070
这些有形状的盒子，它们则是取一个初始值输入，然后生成一个流

64
00:07:46,410 --> 00:07:48,380
现在，你可能又要问了

65
00:07:48,380 --> 00:07:52,340
那个INTEGERS的数据结构真的代表着全部的整数吗？

66
00:07:52,340 --> 00:07:58,190
或者它只是经过了你的精心组织，以至于我们总可以在其中找到我们需要的那个整数？

67
00:07:58,190 --> 00:07:59,780
这有点哲学的味道，不是么

68
00:07:59,780 --> 00:08:04,450
一个东西你无论什么时候去看，它都在那里，但是它真的是一直的在那里吗？

69
00:08:04,450 --> 00:08:09,420
有点类似地，就比如你的存款是否一直在银行里一样

70
00:08:12,380 --> 00:08:19,830
好的 我们再来看一个例子

71
00:08:19,830 --> 00:08:28,470
课程的一开始 我们讲了一个亚力山大海伦的计算平方根的算法

72
00:08:28,470 --> 00:08:32,030
现在再来看一个同样来自亚力山大的算法

73
00:08:32,030 --> 00:08:39,110
Eratosthenes发明的计算所有质数的算法

74
00:08:41,169 --> 00:08:42,830
它被称为Eratosthenes筛法

75
00:08:42,830 --> 00:08:53,880
它是这样的，一开始，先列举所有的整数，从2开始

76
00:08:53,880 --> 00:08:57,310
然后取第一个整数，哦，2是一个质数

77
00:08:57,310 --> 00:09:01,230
然后对于除了2以外的所有整数，划掉可以被2整除的数

78
00:09:01,230 --> 00:09:05,250
我把这个划掉，还有这个，这个...

79
00:09:05,250 --> 00:09:11,160
有点费时，因为我要把这一页上能划掉的都划掉

80
00:09:11,160 --> 00:09:22,010
我一个一个地划掉所有被2整除的数

81
00:09:22,010 --> 00:09:27,040
结束之后，回头看看我们还剩下点什么

82
00:09:27,040 --> 00:09:29,330
好的，我们继续，下一个数就是3了

83
00:09:29,330 --> 00:09:30,770
3也是一个质数

84
00:09:30,770 --> 00:09:35,120
然后同样的，在除掉3的剩下的所有数中，划掉所有被3整除的数

85
00:09:35,120 --> 00:09:44,050
划掉9 15 21 27 33等等

86
00:09:44,050 --> 00:09:45,350
一页实在太多了，我先不划完

87
00:09:45,350 --> 00:09:47,250
看看我们还剩下什么

88
00:09:47,250 --> 00:09:50,860
依次地下一个就是5了

89
00:09:50,860 --> 00:09:54,540
同样地，从除5以外剩下的数中，划掉被5整除的数

90
00:09:54,540 --> 00:09:58,030
这样继续开始划

91
00:09:58,030 --> 00:10:01,890
做完这个之后，取一个数，也就是7

92
00:10:01,890 --> 00:10:06,810
同样划掉所有被7整除的数，然后一直这样下去

93
00:10:06,810 --> 00:10:10,120
全部结束的时候，我也就得到了所有的质数

94
00:10:10,120 --> 00:10:15,430
这就是Eratosthenes筛法

95
00:10:15,430 --> 00:10:17,930
我们来看下实际代码

96
00:10:17,930 --> 00:10:19,550
这个过程命名为sieve

97
00:10:27,910 --> 00:10:30,480
我只是用代码表示了我们刚才那样筛选的过程

98
00:10:30,480 --> 00:10:34,510
sieve，以一个流为参数

99
00:10:38,770 --> 00:10:41,870
返回一个新的流，第一个元素就是参数s流的第一个元素

100
00:10:41,870 --> 00:10:59,020
这和我们刚才演示的是相符合的，然后我们从(tail s)中过滤掉所有被(head s)整除的数，再用sieve来筛选，作为结果流的TAIL部分

101
00:10:59,020 --> 00:11:01,980
就这么简单

102
00:11:01,980 --> 00:11:06,900
为了得到所有的质数，我们以从2开始的所有整数作为sieve的参数

103
00:11:14,920 --> 00:11:16,300
我们来实践一下

104
00:11:16,300 --> 00:11:19,760
这是可以运行的

105
00:11:19,760 --> 00:11:41,350
我已经预先输入过了sieve的定义，所以这里我直接输入primes的定义

106
00:11:46,760 --> 00:11:48,100
解释器打印PRIMES

107
00:11:48,100 --> 00:11:50,990
这样就得到了所有的质数，是不是这样呢？

108
00:11:50,990 --> 00:12:01,010
拿个例子来看一下，第20个质数是什么？

109
00:12:01,010 --> 00:12:02,540
打印结果是73

110
00:12:02,540 --> 00:12:07,750
看，我才刚按下回车，结果就输出了，非常快

111
00:12:10,370 --> 00:12:14,960
现在我要求打印所有的质数

112
00:12:22,780 --> 00:12:25,350
解释器就开始打印所有的质数

113
00:12:25,350 --> 00:12:28,570
肯定输出不完的 现在我们把它停掉

114
00:12:32,030 --> 00:12:33,130
现在我用图形来表示这个过程

115
00:12:33,130 --> 00:12:34,890
我已经画好了

116
00:12:34,890 --> 00:12:37,900
这个过程的图形应该是什么样子呢？

117
00:12:37,900 --> 00:12:42,610
就像其它所有的图一样，一开始就是一个盒子，名字是sieve

118
00:12:42,610 --> 00:12:43,560
它是如何运作的呢？

119
00:12:43,560 --> 00:12:44,810
它接收一个流作为输入

120
00:12:48,850 --> 00:12:50,870
head 和 tail 分开

121
00:12:50,870 --> 00:12:54,970
sieve盒子输出的也是一个流，第一个元素就是head

122
00:12:57,796 --> 00:13:02,550
这个head也还用在了filter这里

123
00:13:02,550 --> 00:13:03,850
这里下面，取得tail流

124
00:13:03,850 --> 00:13:09,152
filter盒子过滤掉tail中所有整除head的数

125
00:13:09,152 --> 00:13:15,130
输出的流又作为一个新的sieve盒子的输入，这个sieve输出的流最后和head一起构成了最外层sieve输出的流

126
00:13:15,130 --> 00:13:19,650
你也可以把sieve想像为一个过滤器，不过它是一个无穷递归的过滤器

127
00:13:19,650 --> 00:13:27,130
因为这个sieve盒子内部还有一个sieve，内层的sieve内部肯定还有一个sieve，无穷下去

128
00:13:27,130 --> 00:13:28,960
我们已经开始接触一些不得了的东西了

129
00:13:28,960 --> 00:13:36,690
我们开始把 以信号处理观察现实的视角和lisp计算中的递归结合在一起

130
00:13:36,690 --> 00:13:40,970
你们可以用它来做很多事

131
00:13:40,970 --> 00:13:42,220
好的，有什么问题吗？

132
00:13:48,190 --> 00:13:49,440
没有，那我们休息一下

133
00:14:28,820 --> 00:14:32,690
我们已经了解了许多如何用流进行编程的例子

134
00:14:34,790 --> 00:14:41,490
那些盒子都有一个共同的特征

135
00:14:41,490 --> 00:14:51,000
我们总是递归地一次生成一个元素，再用cons-stream连接起来。因此我们必须一起思考生成流的过程

136
00:14:51,000 --> 00:15:07,350
这里我们用另一种方式来思考流，不是那种需要沿着流一个逐个元素来思考，而是把流作为一个整体

137
00:15:07,350 --> 00:15:12,410
为了把意思表示清楚，我们来看两个过程

138
00:15:12,410 --> 00:15:22,330
第一个过程是 add-streams，两以两个流s1 s2作为参数

139
00:15:22,330 --> 00:15:22,460
然后

140
00:15:22,460 --> 00:15:32,970
生成一个新的流，其元素是两个流相应位置元素的和

141
00:15:32,970 --> 00:15:36,810
如果其中一个流是空的，我们就返回另一个流

142
00:15:36,810 --> 00:15:50,090
否则，我们就构建一个新的流，head元素是两个参数head的和，然后再递归求tail部分

143
00:15:50,090 --> 00:15:53,150
这就是“逐个元素来思考”来表示的整个过程

144
00:15:53,150 --> 00:15:57,500
另一个过程是scale-stream

145
00:15:57,500 --> 00:16:09,710
两个参数，c是一个常数，s是一个流，结果生成的流相当于是将流s整体缩放了c倍

146
00:16:09,710 --> 00:16:18,290
这个过程表述起来很简单，就是用map-stream和这个lambda对流s进行映射

147
00:16:20,520 --> 00:16:27,910
考虑清楚这两个例子的区别，现在我来具体用程序演示“将流作为整体来思考”到底是什么意思

148
00:16:27,910 --> 00:16:30,200
我们来看这个

149
00:16:30,200 --> 00:16:31,680
假设这样

150
00:16:31,680 --> 00:16:52,190
(DEFINE ONES (CONS-STREAM 1 ONES))

151
00:16:54,860 --> 00:16:56,950
这是什么？

152
00:16:56,950 --> 00:17:03,330
这是一个表示无穷个1的流，因为我们看到第一个元素是1

153
00:17:03,330 --> 00:17:11,780
tail部分是ONES，ONES的head也是1，ONES的tail又是ONES，其head又是1，以此类推

154
00:17:11,780 --> 00:17:15,130
这就是无穷个1的流

155
00:17:15,130 --> 00:17:18,599
现在根据ONES，我再给出另一种定义整数的方式

156
00:17:18,599 --> 00:17:48,270
(DEFINE INTEGERS (CONS-STREAM 1 (ADD-STREAM INTEGERS ONES)))

157
00:17:54,950 --> 00:18:06,640
整数的第一个数是1，其余的数则是将整数全部加1

158
00:18:06,640 --> 00:18:13,940
按这种方式，第二个整数就是第一个整数加1

159
00:18:13,940 --> 00:18:31,250
得到第三个整数的过程也和得到第二个整数的过程类似，就是一个不断加1的过程

160
00:18:35,240 --> 00:18:36,310
它居然可以运行，有点匪夷所思，

161
00:18:36,310 --> 00:18:40,150
这样的过程可以正常运行的关键在于延时求值

162
00:18:40,150 --> 00:18:43,870
我们来看这个ONES

163
00:18:43,870 --> 00:18:51,130
这看起来根本不可能，我想知道ONES是什么，你却告诉我说把1和ONES连接在一起就是ONES

164
00:18:51,130 --> 00:18:55,250
它之所以可以运行是因为暗中隐藏的delay

165
00:18:55,250 --> 00:19:00,290
关键是，cons-stream是只是一个缩写

166
00:19:00,290 --> 00:19:08,785
实际是(CONS 1 (DELAY ONES))

167
00:19:12,140 --> 00:19:15,500
再来实际看一下

168
00:19:15,500 --> 00:19:18,020
这里定义ONES

169
00:19:18,020 --> 00:19:20,700
首先我发现ONES是一个CONS

170
00:19:20,700 --> 00:19:32,710
CAR部分是1，CDR部分则是一个计算的约定

171
00:19:32,710 --> 00:19:37,270
不用担心说ONES还没有被定义，你这里怎么可以写一个ONES

172
00:19:37,270 --> 00:19:40,670
将运行整个定义的时候，ONES就被定义了

173
00:19:40,670 --> 00:19:44,920
所以当我再访问到这个部分时，ONES已经被定义过了

174
00:19:44,920 --> 00:19:46,590
这一点非常隐讳

175
00:19:46,590 --> 00:19:48,470
下面整数的定义也是如此

176
00:19:48,470 --> 00:19:53,210
我可以在这里使用INTEGERS也是因为CONS-STREAM的缘故

177
00:19:53,210 --> 00:19:57,050
CONS-STREAM把1和剩下的部分连接起来

178
00:19:57,050 --> 00:20:02,570
所以我根本不用关注INTEGERS有没有定义的问题

179
00:20:06,320 --> 00:20:12,430
这个定义好像还是不那么牢靠的样子，这里我们用图形来表示一下

180
00:20:12,430 --> 00:20:15,020
怎么画呢？

181
00:20:15,020 --> 00:20:26,590
ONES这个流，作为输出进入一个加法器，进行流的加法

182
00:20:29,310 --> 00:20:35,760
输出是INTEGERS

183
00:20:40,760 --> 00:20:48,060
加法器另一个加数则是INTEGERS，返过来构成一个循环

184
00:20:48,060 --> 00:20:53,180
还需要在这里加一个初始值1才算完成

185
00:20:57,100 --> 00:21:02,910
要是在1这里加上一个延时的器件，看起来就完全和信号处理是一回事

186
00:21:02,910 --> 00:21:07,860
当然也得除去ONES这个部分

187
00:21:07,860 --> 00:21:17,360
如果你了解信号处理的话，你会发现这个图很像一个有穷状态的accumulator

188
00:21:17,360 --> 00:21:28,440
我们可以稍加修改，就可以将其变成一个有穷状态的accumulator

189
00:21:28,440 --> 00:21:45,700
把ONES换成一个流，INTEGERS就应该是这个流的积分

190
00:21:45,700 --> 00:21:54,260
还需要修改的一点就是，在S输入加法器之前，先将其乘以dt

191
00:21:57,680 --> 00:22:00,000
剩下的就不用改了

192
00:22:00,000 --> 00:22:04,020
用盒子包裹起来，就是一个积分器

193
00:22:09,790 --> 00:22:19,980
对一个流S进行积分，这里的1可以换成一个积分的初始值

194
00:22:19,980 --> 00:22:25,270
这个看起来就非常像是信号处理了

195
00:22:25,270 --> 00:22:27,980
这里，还有一个程序来表示这个图

196
00:22:31,490 --> 00:22:34,010
对一个流进行积分

197
00:22:34,010 --> 00:22:42,230
接收一个流s，一个初始值和dt，产生一个新的流表示积分

198
00:22:42,230 --> 00:22:43,040
然后呢？

199
00:22:43,040 --> 00:22:49,400
内部定义一个流int，将其命名的原因在于可以回调它构成一个循环

200
00:22:49,400 --> 00:23:01,280
这个int流初始值是initial-value

201
00:23:01,280 --> 00:23:06,880
剩下的则是将s缩放dt倍，和int相加

202
00:23:06,880 --> 00:23:10,690
最后我们返回流int

203
00:23:10,690 --> 00:23:15,920
我们为int命名是为了在int内部可以引用int

204
00:23:21,880 --> 00:23:23,710
我们还可以做的更多

205
00:23:23,710 --> 00:23:25,500
来看这个

206
00:23:25,500 --> 00:23:26,895
斐波那契数

207
00:23:26,895 --> 00:23:32,625
定义FIBS

208
00:23:36,350 --> 00:23:37,985
斐波那契数是什么呢？

209
00:23:37,985 --> 00:23:50,090
从0开始，下一个是1

210
00:23:56,260 --> 00:24:11,000
剩下的就是FIBS和FIBS的tail的和

211
00:24:17,570 --> 00:24:20,580
这样来定义斐波那契数

212
00:24:20,580 --> 00:24:21,430
这是如何运作的呢？

213
00:24:21,430 --> 00:24:31,870
假如开始计算斐波那契数，第一个是0，第二个是1

214
00:24:35,790 --> 00:24:45,830
剩下的是两个流的和，一个流是FIBS本身，另一个是FIBS的tail

215
00:24:48,870 --> 00:24:58,360
现在的定义中，我已经能看到FIBS是以0,1开始 FIBS的tail则应该以1开始

216
00:24:58,360 --> 00:25:06,300
这样，FIBS的第三个数就应该是0+1=1，这里写上1，这是也写上1

217
00:25:06,300 --> 00:25:09,390
知道了这些之后，下一个就是2

218
00:25:09,390 --> 00:25:11,700
这里和那里就写上2

219
00:25:11,700 --> 00:25:12,950
下一个是3

220
00:25:14,720 --> 00:25:18,530
这里就是3，这下面就是5了

221
00:25:18,530 --> 00:25:21,500
非常精妙的定义

222
00:25:21,500 --> 00:25:22,830
用不了一行

223
00:25:22,830 --> 00:25:30,150
我也可以把这个定义写到解释器里，然后要求输出FIBS，斐波那契数就开始刷屏了

224
00:25:32,790 --> 00:25:36,810
到了这里，相信我们对递归又多了一些理解

225
00:25:36,810 --> 00:25:45,160
过程可以递归地定义，类似地数据对象也可以递归地定义

226
00:25:45,160 --> 00:25:53,090
想想也比较合理，因为我们早就了解了过程与数据之间没有明显的界限

227
00:25:53,090 --> 00:25:58,210
具体地来讲，流也是由过程来实现的，只不过出于抽象的原因我们用流的时候并不想象的那么清楚罢了

228
00:25:58,210 --> 00:26:03,630
因此，存在递归的过程，有递归的数据也就不足为怪了

229
00:26:07,840 --> 00:26:09,720
非常和谐

230
00:26:09,720 --> 00:26:14,990
不幸地是，流并非什么问题都能解决

231
00:26:14,990 --> 00:26:17,580
我举个例子

232
00:26:17,580 --> 00:26:36,390
假如我们构建了模拟计算机来求解微分方程，比如 y' = y^2，还需要些初始值

233
00:26:36,390 --> 00:26:38,030
y(0) = 1

234
00:26:41,060 --> 00:26:43,690
dt = .0001

235
00:26:46,770 --> 00:26:51,040
很久之间就有人构建模拟计算机来解决这类问题

236
00:26:51,040 --> 00:26:53,020
原理非常简单

237
00:26:53,020 --> 00:27:03,055
先拿一个积分器

238
00:27:03,055 --> 00:27:08,530
初始值是1

239
00:27:08,530 --> 00:27:13,890
还差一个输入和一个输出，输出的结果就是y

240
00:27:13,890 --> 00:27:21,490
输入的是y的导数，在这是y' = y^2

241
00:27:21,490 --> 00:27:42,910
所以这里使用square进行map，返回去作为这里的输入，这就是用来求解这个微分方程的图

242
00:27:42,910 --> 00:27:47,230
现在我们用代码来表示下这个过程

243
00:27:47,230 --> 00:27:49,390
这个图究竟表示的是什么呢？

244
00:27:49,390 --> 00:28:13,790
y可以这样来定义，就是对dy进行积分，初始值是1，间隔是.0001

245
00:28:13,790 --> 00:28:16,805
接下来

246
00:28:16,805 --> 00:28:20,850
来表示y' = y^2

247
00:28:20,850 --> 00:28:33,510
dy就定义为(MAP SQUARE Y)

248
00:28:33,510 --> 00:28:41,410
这就是使用流对整个图的解释，不幸的是，并不能运行

249
00:28:41,410 --> 00:28:51,190
你可以看到这为什么不行，因为这个定义y的地方，是dy的积分，额，dy是什么

250
00:28:51,190 --> 00:28:53,710
没定义啊

251
00:28:53,710 --> 00:28:58,770
所以我得先定义dy

252
00:28:58,770 --> 00:29:03,580
另一方面，如果先定义了dy，又会发现(MAP SQUARE Y)

253
00:29:03,580 --> 00:29:05,770
y也没有定义

254
00:29:05,770 --> 00:29:11,580
这个不能先写，那个也不能，没法玩儿了

255
00:29:17,560 --> 00:29:20,460
有没有什么解决办法呢？

256
00:29:20,460 --> 00:29:22,200
所幸的是这可以解决

257
00:29:22,200 --> 00:29:34,770
这边，我们可以用ONES来定义ONES是因为CONS-STREAM中ONES可以延时求值

258
00:29:34,770 --> 00:29:36,070
巧妙在什么地方呢？

259
00:29:36,070 --> 00:29:40,730
为什么CONS-STREAM增加了DELAY就变得巧妙了呢？

260
00:29:40,730 --> 00:29:45,950
原因在于CONS-STERAM这样做之后就完全不用关心TAIL的部分了

261
00:29:45,950 --> 00:29:54,870
只用关心我把1和什么东西连接在一起了，而且那个东西以1开始

262
00:29:54,870 --> 00:29:57,910
CONS-STREAM就巧妙在这里

263
00:29:59,960 --> 00:30:06,320
增加了一个DELAY，就可以进行自引用的定义了

264
00:30:06,320 --> 00:30:08,190
INTEGRAL也可以用这种方式来解决

265
00:30:08,190 --> 00:30:17,580
我们回头再看看INTEGRAL的定义

266
00:30:17,580 --> 00:30:28,970
求积分的时候，只需要关心我们从initial-value开始积分，并不需要了解整个流

267
00:30:28,970 --> 00:30:33,140
因为积分结果的第一个元素肯定是initial-value

268
00:30:33,140 --> 00:30:37,090
integral的内部就是cons-stream实现的

269
00:30:37,090 --> 00:30:46,710
我们可以这样定义，甚至不用知道要积分的流是什么，只需要知道初始值是什么就行了

270
00:30:46,710 --> 00:30:58,430
INTEGRAL还可以修改地更为精妙，以一个初始值和一个流进行积分，我甚至不用关心这个流是什么，直到积分的时候再来查看这个流

271
00:30:58,430 --> 00:31:03,710
换句话说，这个INTEGRAL就像CONS-STREAM一样，被积分的流延时求值

272
00:31:03,710 --> 00:31:05,610
我们这样修改

273
00:31:05,610 --> 00:31:07,650
来看这个过程

274
00:31:07,650 --> 00:31:17,110
改动的并不多，只是这里的s变成了delay-s，一个经过DELAY的流

275
00:31:17,110 --> 00:31:18,850
这个INTEGRAL又是怎么运作的呢？

276
00:31:18,850 --> 00:31:32,300
内部还是一个CONS-STREAM，初始值就是initial-value，这里还要记住，delay-s是一个被DELAY过的流

277
00:31:34,950 --> 00:31:43,180
到了实际计算的时候，就用FORCE来查看流的实际内容

278
00:31:43,180 --> 00:31:45,970
第一个元素是initial-value

279
00:31:45,970 --> 00:31:59,260
如果有人想要查看流的实际内容是什么，就对延时对象应用FORCE，这里称其为s，然后做流的加法。整个过程有点像CONS-STREAM的感觉

280
00:31:59,260 --> 00:32:07,330
这个被积分的流是什么我根本不会去深究，直到你需要它的时候我才会去查看这个流

281
00:32:10,120 --> 00:32:27,090
如果这样的话，对于y' = y^2的问题也就解决了，只需要将Y的定义中dt改为(DELAY DY)

282
00:32:27,090 --> 00:32:35,280
Y就是对(DELAY Y)的积分，这样一来就可以了

283
00:32:35,280 --> 00:32:44,600
我输入Y的定义，要求一个什么的积分，具体是什么我也不关心，因为是一个延时对象

284
00:32:44,600 --> 00:32:46,320
这之后，再定义dy

285
00:32:46,320 --> 00:32:47,550
没有问题了，因为y已经被定义了

286
00:32:47,550 --> 00:32:51,700
所以在dy内部引用y并没有问题

287
00:32:51,700 --> 00:32:52,840
一切都正常了

288
00:32:52,840 --> 00:32:54,920
这两个流都有初始值

289
00:32:54,920 --> 00:33:00,590
当用SQUARE进行MAP的时候，查看后继的元素并不会引发什么问题，y和dy都被定义过了

290
00:33:00,590 --> 00:33:08,660
DELAY除了在CONS-STREAM之内还是很有用的不是吗？好的，大家有问题么

291
00:33:13,178 --> 00:33:14,428
没有的话，休息一下吧

292
00:34:07,300 --> 00:34:14,320
在刚才休息的时候，我不知道你们有没有发现什么事不对劲

293
00:34:14,320 --> 00:34:34,389
我们通过流将程序表面表现的时间关系与实际在计算机中运行的时间关系分离开来，可以这样分离的原因在于流中的DELAY。在某些时候，我们为了利用这种优势，需要更多的DELAY

294
00:34:34,389 --> 00:34:39,030
也就是要显式地来使用DELAY

295
00:34:39,030 --> 00:34:49,929
我已经用微分方程示例过了，如果你遇到非常复杂的系统，其中有很多自引用的循环，这时你需要在什么地方用DELAY就非常模糊了

296
00:34:49,929 --> 00:34:55,550
假如你一不小心漏了一个，程序会出错而且你还不知道哪里出了错

297
00:34:55,550 --> 00:35:08,690
我们显式使用DELAY获得的力量不足以克服大型的复杂的系统，因为它们并不能像流一样把DELAY隐藏起来，这非常混乱

298
00:35:08,690 --> 00:35:11,036
有没有什么解决方案呢？

299
00:35:11,036 --> 00:35:13,480
所幸地是 有

300
00:35:13,480 --> 00:35:25,450
我可以改变整个语言，所有过程表现起来就像CONS-STREAM一样，因此每一个过程都对其参数延时求值

301
00:35:25,450 --> 00:35:27,520
什么意思呢？

302
00:35:27,520 --> 00:35:32,210
就是说 你执行一个过程，并不马上对参数求值

303
00:35:32,210 --> 00:35:39,260
相反地，它们只有在需要被求值的时候才会被求值，因此它们可以不被求值的传递至其它过程中，一直这样传递下去

304
00:35:39,260 --> 00:35:42,150
过程传递的只是计算的约定而已

305
00:35:42,150 --> 00:35:52,380
直到最后你需要查看某个值的时候，这才真正的求出这个部分的值

306
00:35:52,380 --> 00:36:02,920
假如我们这样做了，就不需要显式的使用DELAY了，任何东西都有DELAY，它完全内建在语言之中了

307
00:36:02,920 --> 00:36:34,560
换句话说，技术上这是一种正则序求值的语言，和我们一直使用的应用序求值不同

308
00:36:34,560 --> 00:36:36,835
还记得应用序吧

309
00:36:36,835 --> 00:36:43,590
就是你求值一个表达式的时候，每个部分都要预先计算出来

310
00:36:43,590 --> 00:36:47,600
参数具体求值之后，才代换入过程

311
00:36:47,600 --> 00:36:49,890
正则序则不是这样

312
00:36:49,890 --> 00:36:58,640
代换的过程是一样的，不过并不先对参数求值，只是代换入了一个计算的约定

313
00:36:58,640 --> 00:37:09,340
换句话说，这个表达式作为参数，就直接的把这个表达式代换入过程，并不进行求值直到需要求值的时候

314
00:37:09,340 --> 00:37:11,840
这就是所谓的正则序求值语言

315
00:37:11,840 --> 00:37:13,490
为什么不这样做呢？

316
00:37:13,490 --> 00:37:18,940
这样做了之后，我们就获得了延时求值的所有优点

317
00:37:18,940 --> 00:37:24,710
CONS也会是延时求值的，就和CONS-STREAM一样

318
00:37:24,710 --> 00:37:32,350
也不需要流了，因为列表会自动的像流那样，所有的数据对象都会被延时求值

319
00:37:32,350 --> 00:37:35,270
所有的，不是么？

320
00:37:35,270 --> 00:37:41,020
直到需要答案的时候才去实际的求值

321
00:37:41,020 --> 00:37:44,790
也不用担心这些显式的DELAY了

322
00:37:44,790 --> 00:37:47,160
为什么不这样做呢？

323
00:37:47,160 --> 00:37:49,230
首先，已经有人这样做过了

324
00:37:49,230 --> 00:37:51,850
这是一类十分优雅的语言

325
00:37:51,850 --> 00:38:00,710
其中最为人称道的是一门名为Miranda的语言，是肯特大学的David Turner发明的

326
00:38:00,710 --> 00:38:01,930
它就是用这样的原理实现的

327
00:38:01,930 --> 00:38:14,970
正则序求值，列表就像流一样。如果你用Miranda来解决像质数，八皇后这样的问题，写出来的过程看起来就很普通

328
00:38:14,970 --> 00:38:17,790
DELAY已经内建入语言了

329
00:38:17,790 --> 00:38:19,040
但是这样也有不足之处

330
00:38:21,190 --> 00:38:23,170
还记得我们为什么引入流了吗

331
00:38:23,170 --> 00:38:27,480
我们把程序的时间和它实际执行的时间相分离

332
00:38:27,480 --> 00:38:33,140
如果我们在所有地方都引入了DELAY，这也是我们现在正在做的

333
00:38:33,140 --> 00:38:39,300
编程就完全是单纯地描述解决方案的事了

334
00:38:39,300 --> 00:38:47,030
我们完全放弃了对时间的控制，尽管语言变的优雅起来，但是牺牲了太多东西

335
00:38:47,030 --> 00:38:51,480
并且还有一些致命的缺陷

336
00:38:51,480 --> 00:38:53,980
其中之一就是迭代

337
00:38:53,980 --> 00:39:01,230
我们以前写过，迭代的来求阶乘

338
00:39:01,230 --> 00:39:12,120
fact-iter内部定义一个过程iter，它时刻记录着product和counter的状态，就这样迭代的求解

339
00:39:12,120 --> 00:39:15,730
我们说这是一个迭代过程是因为它并没有把状态堆积给解释器

340
00:39:15,730 --> 00:39:23,900
因为状态时刻作为参数传递给了自身

341
00:39:23,900 --> 00:39:31,660
也可以用代换具体的实践来看，这个迭代的过程，并没有状态堆积导致表达式增长的情况

342
00:39:31,660 --> 00:39:34,840
因此这是一个迭代过程

343
00:39:34,840 --> 00:39:41,150
但是现在用正则序的思维来看

344
00:39:41,150 --> 00:39:45,650
这个迭代过程会变成什么样子

345
00:39:45,650 --> 00:39:52,330
如果你用正则序去进行代换，一直代换下去表达式就会变得越来越长

346
00:39:52,330 --> 00:39:53,280
为什么会这样？

347
00:39:53,280 --> 00:39:58,080
因为iter递归的调用自己，把product代换为(* counter product)

348
00:39:58,080 --> 00:40:02,510
在正则序里，这个乘法在这里并没有求值

349
00:40:02,510 --> 00:40:06,670
传递并代换的只是这个乘法计算的约定

350
00:40:06,670 --> 00:40:09,760
然后iter继续代换下去

351
00:40:09,760 --> 00:40:18,400
用这样的计算约定反复的递归代换

352
00:40:18,400 --> 00:40:19,430
代换

353
00:40:19,430 --> 00:40:31,790
如果你实际模拟下这个过程，你会清楚的看到状态的堆积，所有的约定直到最后才被计算

354
00:40:31,790 --> 00:40:36,980
所以正则序不能表达迭代的计算过程

355
00:40:36,980 --> 00:40:54,610
或许这个问题有更深层次的理论上的原因，事实上许多写操作系统的人都很头疼这类问题。比如你用这类语言实现了一个文本编辑器

356
00:40:54,610 --> 00:41:10,230
但是你才用了一会儿，就会发现已经占用了3MB空间，充斥了未被计算的约定，这个应该是被称为拖尾问题，就因为不能表示迭代过程的缘故

357
00:41:10,230 --> 00:41:20,110
一个针对这种语言的研究方向就是如何采用一种编译技术来避免拖尾问题

358
00:41:20,110 --> 00:41:23,940
非常困难

359
00:41:23,940 --> 00:41:32,056
在不能表示迭代之外，正则序求值还有另一个缺点

360
00:41:32,056 --> 00:41:42,000
很遗憾的是，正则序求值与赋值副作用是不相容的

361
00:41:42,000 --> 00:41:45,350
它们在一起效果并不好

362
00:41:45,350 --> 00:42:00,400
你不能对有局部状态的对象同时应用正则序求值来分离时间延时求值

363
00:42:00,400 --> 00:42:03,790
我来举一个非常简单的例子

364
00:42:03,790 --> 00:42:07,520
假设语言是正则序求值

365
00:42:07,520 --> 00:42:09,550
例子是这样的

366
00:42:09,550 --> 00:42:10,520
注意现在是正则序求值

367
00:42:10,520 --> 00:42:13,570
定义x是0

368
00:42:13,570 --> 00:42:15,750
初始化的变量

369
00:42:15,750 --> 00:42:22,640
下面这个过程 id 比较有趣

370
00:42:22,640 --> 00:42:26,770
And what it does, it keeps track of the last time you called it using x.

371
00:42:31,620 --> 00:42:36,760
So the identity of n just returns n, but it sets x to be n.

372
00:42:36,760 --> 00:42:42,580
And now I'll define a little increment function, which is a very little, simple scenario.

373
00:42:42,580 --> 00:42:47,230
Now, imagine I'm interacting with this in the normal-order language, and I type the following.

374
00:42:47,230 --> 00:42:54,190
I say define y to be increment the identity function of 3, so y is going to be 4.

375
00:42:57,410 --> 00:42:59,520
Now, I say what's x?

376
00:42:59,520 --> 00:43:04,710
Well, x should have been the value that was remembered last when I called the identity function.

377
00:43:04,710 --> 00:43:08,530
So you'd expect to say, well, x is 3 at this point, but it's not.

378
00:43:08,530 --> 00:43:17,000
Because when I defined y here, what I really defined y to be increment of a promise to do this thing.

379
00:43:17,000 --> 00:43:21,560
So I didn't look at y, so that identity function didn't get run.

380
00:43:21,560 --> 00:43:25,320
So if I type in this definition and look at x, I'm going to get 0.

381
00:43:28,360 --> 00:43:38,342
Now, if I go look at y and say what's y, say y is 4, looking at y, that very active looking at y caused the identity function to be run.

382
00:43:38,342 --> 00:43:40,740
And now x will get remembered as 3.

383
00:43:40,740 --> 00:43:42,020
So here x will be 0.

384
00:43:42,020 --> 00:43:43,280
Here, x will be 3.

385
00:43:43,280 --> 00:43:57,100
That's a tiny, little, simple scenario, but you can see what kind of a mess that's going to make for debugging interactive programs when you have normal-order evaluation.

386
00:43:57,100 --> 00:43:59,690
It's very confusing.

387
00:43:59,690 --> 00:44:09,780
But it's very confusing for a very deep reason, which is that the whole idea of putting in delays is that you throw away time.

388
00:44:09,780 --> 00:44:11,750
That's why we can have these infinite processes.

389
00:44:11,750 --> 00:44:17,790
Since we've thrown away time, we don't have to wait for them to run, right?

390
00:44:17,790 --> 00:44:28,760
We decouple the order of events in the computer from what we write in our programs. But when we talk about state and set and change, that's exactly what we do want control of.

391
00:44:28,760 --> 00:44:34,570
So it's almost as if there's this fundamental contradiction in what you want.

392
00:44:34,570 --> 00:44:42,410
And that brings us back to these sort of philosophical mutterings about what is it that you're trying to model and how do you look at the world.

393
00:44:42,410 --> 00:44:47,140
Or sometimes this is called the debate over functional programming.

394
00:44:53,570 --> 00:45:00,440
A so-called purely functional language is one that just doesn't have any side effects.

395
00:45:00,440 --> 00:45:06,360
Since you have no side effects, there's no assignment operator, so there are no terrible consequences of it.

396
00:45:06,360 --> 00:45:07,930
You can use a substitution-like thing.

397
00:45:07,930 --> 00:45:15,050
Programs really are like mathematics and not like models in the real world, not like objects in the real world.

398
00:45:15,050 --> 00:45:17,170
There are a lot of wonderful things about functional languages.

399
00:45:17,170 --> 00:45:29,260
Since there's no time, you never have any synchronization problems. And if you want to put something into a parallel algorithm, you can run the pieces of that parallel processing any way you want.

400
00:45:29,260 --> 00:45:33,640
There's just never any synchronization to worry that, and it's a very congenial environment for doing this.

401
00:45:33,640 --> 00:45:35,450
The price is you give up assignment.

402
00:45:39,060 --> 00:45:44,520
So an advocate of a functional language would say, gee, that's just a tiny price to pay.

403
00:45:44,520 --> 00:45:46,510
You probably shouldn't use assignment most of the time anyway.

404
00:45:46,510 --> 00:45:54,190
And if you just give up assignment, you can be in this much, much nicer world than this place with objects.

405
00:45:54,190 --> 00:45:56,300
Well, what's the rejoinder to that?

406
00:45:56,300 --> 00:46:00,300
Remember how we got into this mess.

407
00:46:00,300 --> 00:46:04,440
We started trying to model things that had local state.

408
00:46:04,440 --> 00:46:06,840
So remember Jerry's random number generator.

409
00:46:06,840 --> 00:46:14,080
There was this random number generator that had some little state in it to compute the next random number and the next random number and the next random number.

410
00:46:14,080 --> 00:46:21,050
And we wanted to hide that state away from the Cesaro compute part process, and that's why we needed set.

411
00:46:21,050 --> 00:46:24,070
We wanted to package that stated modularly.

412
00:46:24,070 --> 00:46:27,560
Well, a functional programming person would say, well, you're just all wet.

413
00:46:27,560 --> 00:46:29,840
I mean, you can write a perfectly good modular program.

414
00:46:29,840 --> 00:46:33,250
It's just you're thinking about modularity wrong.

415
00:46:33,250 --> 00:46:36,880
You're hung up in this next random number and the next random number and the next random number.

416
00:46:36,880 --> 00:46:39,880
Why don't you just say let's write a program.

417
00:46:39,880 --> 00:46:44,445
Let's write an enumerator which just generates an infinite stream of random numbers.

418
00:46:49,010 --> 00:46:54,540
We can sort of have that stream all at once, and that's going to be our source of random numbers.

419
00:46:54,540 --> 00:47:06,880
And then if you like, you can put that through some sort of processor, which is-- I don't know-- a Cesaro test, and that can do what it wants.

420
00:47:06,880 --> 00:47:28,140
And what would come out of there would be a stream of successive approximations to pi.

421
00:47:28,140 --> 00:47:35,540
So as we looked further down this stream, we'd tug on this Cesaro thing, and it would pull out more and more random numbers.

422
00:47:35,540 --> 00:47:39,720
And the further and further we look down the stream, the better an approximation we'd get to pi.

423
00:47:39,720 --> 00:47:43,890
And it would do exactly the same as the other computation, except we're thinking about the modularity different.

424
00:47:43,890 --> 00:47:49,400
We're saying imagine we had all those infinite streams of random numbers all at once.

425
00:47:49,400 --> 00:47:53,860
You can see the details of this procedure in the book.

426
00:47:53,860 --> 00:48:03,280
Similarly, there are other things that we tend to get locked into on this one and that one and the next one and the next one, which don't have to be that way.

427
00:48:03,280 --> 00:48:08,900
Like you might think about like a banking system, which is a very simple idea.

428
00:48:08,900 --> 00:48:12,210
Imagine we have a program that sort of represents a bank account.

429
00:48:18,810 --> 00:48:31,510
The bank account might have in it-- if we looked at this in a sort of message-passing view of the world, we'd say a bank account is an object that has some local state in there, which is the balance, say.

430
00:48:34,110 --> 00:48:48,560
And a user using this system comes and sends a transaction request. So the user sends a transaction request, like deposit some money, and the bank account maybe-- let's say the bank account always responds with what the current balance is.

431
00:48:48,560 --> 00:48:54,350
The user says let's deposits some money, and the bank account sends back a message which is the balance.

432
00:48:54,350 --> 00:48:59,150
And the user says deposit some more, and the bank account sends back a message.

433
00:48:59,150 --> 00:49:03,200
And just like the random number generator, you'd say, gee, we would like to use set.

434
00:49:03,200 --> 00:49:09,570
We'd like to have balance be a piece of local state inside this bank account because we want to separate the state of the user from the state of the bank account.

435
00:49:13,280 --> 00:49:16,420
Well, that's the message-processing view.

436
00:49:16,420 --> 00:49:22,740
There's a stream view with that thing, which does the same thing without any set or side effects.

437
00:49:22,740 --> 00:49:31,180
And the idea is again we don't think about anything having local state.

438
00:49:31,180 --> 00:49:38,640
We think about the bank account as something that's going to process a stream of transaction requests.

439
00:49:38,640 --> 00:49:49,490
So think about this bank account not as something that goes message by message, but something that takes in a stream of transaction requests like maybe successive deposit announced.

440
00:49:49,490 --> 00:49:55,940
1, 2, 2, 4, those might be successive amounts to deposit.

441
00:49:55,940 --> 00:50:03,770
And then coming out of it is the successive balances 1, 3, 5, 9.

442
00:50:03,770 --> 00:50:10,820
So we think of the bank account not as something that has state, but something that acts sort of on the infinite stream of requests.

443
00:50:10,820 --> 00:50:12,370
But remember, we've thrown away time.

444
00:50:12,370 --> 00:50:30,010
So what we can do is if the user's here, we can have this infinite stream of requests being generated one at a time coming from the user and this transaction stream coming back on a printer being printed one at a time.

445
00:50:30,010 --> 00:50:39,560
And if we drew a little line here, right there to the user, the user couldn't tell that this system doesn't have state.

446
00:50:39,560 --> 00:50:42,660
It looks just like the other one, but there's no state in there.

447
00:50:45,120 --> 00:50:53,835
And by the way, just to show you, here's an actual implementation of this-- we'll call it make deposit account because you can only deposit.

448
00:50:53,835 --> 00:51:00,020
It takes an initial balance and then a stream of deposits you might make.

449
00:51:00,020 --> 00:51:00,820
And what is it?

450
00:51:00,820 --> 00:51:18,300
Well, it's just cons-stream of the balance onto make a new account stream whose initial balance is the old balance plus the first thing in the deposit stream and make deposit account works on the rest of which is the tail of the deposit stream.

451
00:51:18,300 --> 00:51:28,790
So there's sort of a very typical message-passing, object-oriented thing that's done without side effects at all.

452
00:51:28,790 --> 00:51:32,250
There are very many things you can do this way.

453
00:51:32,250 --> 00:51:36,400
Well, can you do everything without assignment?

454
00:51:36,400 --> 00:51:40,050
Can everybody go over to purely functional languages?

455
00:51:40,050 --> 00:51:48,100
Well, we don't know, but there seem to be places where purely functional programming breaks down.

456
00:51:48,100 --> 00:51:58,850
Where it starts hurting is when you have things like this, but you also mix it up with the other things that we had to worry that, which are objects and sharing and two independent agents being the same.

457
00:51:58,850 --> 00:52:02,960
So under a typical one, suppose you want to extend this bank account.

458
00:52:02,960 --> 00:52:04,210
So here's a bank account.

459
00:52:12,220 --> 00:52:18,780
Bank accounts take in a stream of transaction requests and put out streams of, say, balances or responses to that.

460
00:52:18,780 --> 00:52:26,090
But suppose you want to model the fact that this is a joint bank account between two independent people.

461
00:52:26,090 --> 00:52:33,140
So suppose there are two people, say, Bill and Dave, who have a joint bank account.

462
00:52:35,960 --> 00:52:36,850
How would you model this?

463
00:52:36,850 --> 00:52:45,880
Well, Bill puts out a stream of transaction requests, and Dave puts out a stream of transaction requests, and somehow, they have to merge into this bank account.

464
00:52:45,880 --> 00:53:01,190
So what you might do is write a little stream processing thing called merge, which sort of takes these, merges them together, produces a single stream for the bank account.

465
00:53:01,190 --> 00:53:03,610
Now they're both talking to the same bank account.

466
00:53:03,610 --> 00:53:06,600
That's all great, but how do you write merge?

467
00:53:06,600 --> 00:53:09,730
What's this procedure merge?

468
00:53:09,730 --> 00:53:12,760
You want to do something that's reasonable.

469
00:53:12,760 --> 00:53:24,150
Your first guess might be to say, well, we'll take alternate requests from Bill and Dave. But what happens if suddenly in the middle of this thing, Dave goes away on vacation for two years?

470
00:53:24,150 --> 00:53:27,690
Then Bill's sort of stuck.

471
00:53:27,690 --> 00:53:29,750
So what you want to do is-- well, it's hard to describe.

472
00:53:29,750 --> 00:53:33,380
What you want to do is what people call fair merge.

473
00:53:38,410 --> 00:53:46,010
The idea of fair merge is it sort of should do them alternately, but if there's nothing waiting here, it should take one twice.

474
00:53:46,010 --> 00:53:48,450
Notice I can't even say that without talking about time.

475
00:53:51,300 --> 00:54:18,010
So one of the other active researcher areas in functional languages is inventing little things like fair merge and maybe some others, which will take the places where I used to need side effects and objects and sort of hide them away in some very well-defined modules of the system so that all the problems of assignment don't sort of leak out all over the system but are captured in some fairly well-understood things.

476
00:54:20,780 --> 00:54:38,360
More generally, I think what you're seeing is that we're running across what I think is a very basic problem in computer science, which is how to define languages that somehow can talk about delayed evaluation, but also be able to reflect this view that there are objects in the world.

477
00:54:38,360 --> 00:54:41,230
How do we somehow get both?

478
00:54:41,230 --> 00:54:43,040
And I think that's a very hard problem.

479
00:54:43,040 --> 00:54:53,840
And it may be that it's a very hard problem that has almost nothing to do with computer science, that it really is a problem having to do with two very incompatible ways of looking at the world.

480
00:54:53,840 --> 00:54:55,090
OK, questions?

481
00:55:17,556 --> 00:55:25,890
AUDIENCE: You mentioned earlier that once you introduce assignment, the general rule for using the substitution model is you can't.

482
00:55:25,890 --> 00:55:27,570
Unless you're very careful, you can't.

483
00:55:27,570 --> 00:55:28,260
PROFESSOR: Right.

484
00:55:28,260 --> 00:55:40,300
AUDIENCE: Is there a set of techniques or a set of guidelines for localizing the effects of assignment so that the very careful becomes defined?

485
00:55:40,300 --> 00:55:42,890
PROFESSOR: I don't know.

486
00:55:42,890 --> 00:55:45,430
Let me think.

487
00:55:45,430 --> 00:55:51,480
Well, certainly, there was an assignment inside memo proc, but that was sort of hidden away.

488
00:55:51,480 --> 00:55:53,480
It ended up not making any difference.

489
00:55:53,480 --> 00:56:00,390
Part of the reason for that is once this thing triggered that it had run and gotten an answer, that answer will never change.

490
00:56:00,390 --> 00:56:02,080
So that was sort of a one-time assignment.

491
00:56:02,080 --> 00:56:11,250
So one very general thing you can do is if you only do what's called a one-time assignment and never change anything, then you can do better.

492
00:56:11,250 --> 00:56:18,490
One of the problems in this merge thing, people have-- let me see if this is right.

493
00:56:18,490 --> 00:56:30,820
I think it's true that with fair merge, with just fair merge, you can begin effectively simulating assignment in the rest of the language.

494
00:56:30,820 --> 00:56:39,520
It seems like anything you do to go outside-- I'm not quite sure that's true for fair merge, but it's true of a little bit more general things that people have been doing.

495
00:56:39,520 --> 00:56:47,970
So it might be that any little bit you put in, suddenly if they allow you to build arbitrary stuff, it's almost as bad as having assignment altogether.

496
00:56:47,970 --> 00:56:51,590
But that's an area that people are thinking about now.

497
00:56:51,590 --> 00:57:04,730
AUDIENCE: I guess I don't see the problem here with merge if I call Bill, if Bill is a procedure, then Bill is going to increment the bank account or build the list that 's going to put in the next element.

498
00:57:04,730 --> 00:57:07,170
If I call Dave twice in a row, that will do that.

499
00:57:07,170 --> 00:57:09,350
I'm not sure where fair merge has to be involved.

500
00:57:09,350 --> 00:57:11,200
PROFESSOR: The problem is imagine these really as people.

501
00:57:11,200 --> 00:57:14,850
See, here I have the user who's interacting with this bank account.

502
00:57:14,850 --> 00:57:17,070
Put in a request, get an answer.

503
00:57:17,070 --> 00:57:18,200
AUDIENCE: Right.

504
00:57:18,200 --> 00:57:24,220
PROFESSOR: But if the only way I can process request is to alternate them from two people-- AUDIENCE: Well, why would you alternate them?

505
00:57:24,220 --> 00:57:25,070
PROFESSOR: Why don't I?

506
00:57:25,070 --> 00:57:26,140
AUDIENCE: Yes.

507
00:57:26,140 --> 00:57:26,580
Why do you?

508
00:57:26,580 --> 00:57:27,640
PROFESSOR: Think of them as real people, right?

509
00:57:27,640 --> 00:57:29,280
This guy might go away for a year.

510
00:57:29,280 --> 00:57:35,480
And you're sitting here at the bank account window, and you can't put in two requests because it's waiting for this guy.

511
00:57:35,480 --> 00:57:37,380
AUDIENCE: Why does it have to be waiting for one?

512
00:57:37,380 --> 00:57:39,110
PROFESSOR: Because it's trying to compute a function.

513
00:57:39,110 --> 00:57:41,720
I have to define a function.

514
00:57:41,720 --> 00:57:51,690
Another way to say that is the answer to what comes out of this merge box is not a function of what goes in.

515
00:57:51,690 --> 00:57:53,490
Because, see, what would the function be?

516
00:57:53,490 --> 00:58:03,470
Suppose he puts in 1, 1, 1, 1, and he puts in 2, 2, 2, 2.

517
00:58:03,470 --> 00:58:05,910
What's the answer supposed to be?

518
00:58:05,910 --> 00:58:08,740
It's not good enough to say it's 1, 2, 1, 2, 1, 2.

519
00:58:08,740 --> 00:58:09,390
AUDIENCE: I understand.

520
00:58:09,390 --> 00:58:11,560
But when Bill puts in 1, 1 goes in.

521
00:58:11,560 --> 00:58:13,950
When Dave puts in 2 twice, 2 goes in twice.

522
00:58:13,950 --> 00:58:15,450
When Bill puts in-- PROFESSOR: Right.

523
00:58:15,450 --> 00:58:23,980
AUDIENCE: Why can't it be hooked to the time of the input-- the actual procedural-- PROFESSOR: Because I don't have time.

524
00:58:23,980 --> 00:58:26,900
See, all I can say is I'm going to define a function.

525
00:58:26,900 --> 00:58:28,150
I don't have time.

526
00:58:32,070 --> 00:58:38,420
There's no concept if it's going to alternate, except if nobody's there, it's going to wait a while for him.

527
00:58:38,420 --> 00:58:47,810
It's just going to say I have the stream of requests, the timeless infinite streams of all the requests that Dave would have made, right?

528
00:58:47,810 --> 00:58:51,690
And the timeless infinite stream of all the requests Bill would have made, and I want to operate on them.

529
00:58:51,690 --> 00:58:53,510
See, that's how this bank account is working.

530
00:58:56,710 --> 00:59:05,340
And the problem is that these poor people who are sitting at the bank account windows have the misfortune to exist in time.

531
00:59:05,340 --> 00:59:10,070
They don't see their infinite stream of all the requests they would have ever made.

532
00:59:10,070 --> 00:59:11,550
They're waiting now, and they want an answer.

533
00:59:14,290 --> 00:59:25,290
So if you're sitting there-- if this is the screen operation on some time-sharing system and it's working functionally, you want an answer then when you talk the character.

534
00:59:25,290 --> 00:59:30,910
You don't want it to have to wait for everybody in the whole system to have typed one character before it can get around to service you.

535
00:59:30,910 --> 00:59:33,890
So that's the problem.

536
00:59:33,890 --> 00:59:36,850
I mean, the fact that people live in time, apparently.

537
00:59:36,850 --> 00:59:38,620
If they didn't, it wouldn't be a problem.

538
00:59:49,100 --> 00:59:54,740
AUDIENCE: I'm afraid I miss the point of having no time in this banking transaction.

539
00:59:54,740 --> 00:59:56,880
Isn't time very important?

540
00:59:56,880 --> 01:00:00,790
For instance, the sequence of events.

541
01:00:00,790 --> 01:00:08,400
If Dave take out $100, then the timing sequence should be important.

542
01:00:08,400 --> 01:00:11,260
How do you treat transactions as streams?

543
01:00:11,260 --> 01:00:14,260
PROFESSOR: Well, that's the thing I'm saying.

544
01:00:14,260 --> 01:00:17,510
This is an example where you can't.

545
01:00:17,510 --> 01:00:18,610
You can't.

546
01:00:18,610 --> 01:00:24,170
The point is what comes out of here is simply not a function of the stream going in here and the stream going in here.

547
01:00:24,170 --> 01:00:32,860
It's a function of the stream going in here and the stream going in here and some kind of information about time, which is precisely what a normal-order language won't let you say.

548
01:00:34,810 --> 01:00:46,400
AUDIENCE: In order to brings this back into a more functional perspective, could we just explicitly time stamp all the inputs from Bill and Dave and define fair merge to just be the sort on those time stamps?

549
01:00:49,150 --> 01:00:49,550
PROFESSOR: Yeah, you can do that.

550
01:00:49,550 --> 01:00:50,600
You can do that sort of thing.

551
01:00:50,600 --> 01:01:00,970
Another thing you could say is imagine that really what this function is, is that it does a read every microsecond, and then if there's none there, that's considered an empty one.

552
01:01:00,970 --> 01:01:03,610
That's about equivalent to what you said.

553
01:01:03,610 --> 01:01:07,110
And yes, you can do that, but that's a clg.

554
01:01:07,110 --> 01:01:10,170
So it's not quite only implementation we're worried about.

555
01:01:10,170 --> 01:01:18,824
We're worried about expressive power in the language, and what we're running across is a real mismatch between what we can say easily and what we'd like to say.

556
01:01:18,824 --> 01:01:26,080
AUDIENCE: It sounds like where we're getting hung up with that is the fact it expects one input from both Bill and Dave at the same time.

557
01:01:26,080 --> 01:01:28,530
PROFESSOR: It's not quite one, but it's anything you define.

558
01:01:28,530 --> 01:01:36,110
So you can say Dave can go twice as often, but if anything you predefine, it's not the right thing.

559
01:01:36,110 --> 01:01:41,930
You can't decide at some particular function of their input requests.

560
01:01:41,930 --> 01:01:47,290
Worse yet, I mean, worse yet, there are things that even merge can't do.

561
01:01:47,290 --> 01:01:52,470
One thing you might want to do that's even more general is suddenly you add somebody else to this bank account system.

562
01:01:52,470 --> 01:01:56,030
You go and you add John to this bank account system.

563
01:01:56,030 --> 01:02:02,040
And now there's yet another stream that's going to come into the picture at some time which we haven't prespecified.

564
01:02:02,040 --> 01:02:08,860
So that's something even fair merge can't do, and they're things called-- I forget-- natagers or something.

565
01:02:08,860 --> 01:02:11,790
That's a generalization of fair merge to allow that.

566
01:02:11,790 --> 01:02:19,580
There's a whole sort of research discipline saying how far can you push this functional perspective by adding more and more mechanism?

567
01:02:19,580 --> 01:02:25,610
And how far does that go before the whole thing breaks down and you might as well been using set anyway.

568
01:02:25,610 --> 01:02:28,960
AUDIENCE: You need to set him up on automatic deposit.

569
01:02:28,960 --> 01:02:39,630
[LAUGHTER]

570
01:02:39,630 --> 01:02:40,880
PROFESSOR: OK, thank you.

