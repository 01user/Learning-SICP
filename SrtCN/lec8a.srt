1
00:00:00,000 --> 00:00:02,672
Learning-SICP学习小组
倾情制作

2
00:00:18,272 --> 00:00:21,376
教授：上节课中我们学习了如何构造语言
PROFESSOR: The last time we began having a look at how languages are constructed.

3
00:00:22,416 --> 00:00:25,888
重点就是 像Lisp这样的求值器
Remember the main point that an evaluator for, LISP, say,

4
00:00:26,080 --> 00:00:27,580
有两个主要部分
has two main elements.

5
00:00:27,580 --> 00:00:28,400
一个是EVAL
There is EVAL,

6
00:00:31,040 --> 00:00:37,424
EVAL接受一个表达式EXP和环境ENV
and EVAL's job is to take in an expression and an environment

7
00:00:38,912 --> 00:00:44,448
然后返回一个过程和相关的实际参数
and turn that into a procedure and some arguments

8
00:00:45,424 --> 00:00:47,056
并把它们传递给APPLY
and pass that off to APPLY.

9
00:00:49,410 --> 00:00:51,296
APPLY接收这些过程和实际参数
And APPLY takes the procedure in the arguments,

10
00:00:51,696 --> 00:00:55,120
通常来说 APPLY会返回另一个表达式
turns that back into, in a general case, another expression

11
00:00:55,392 --> 00:00:57,712
返回另在另一个环境中求值的表达式
to be evaluated in another environment

12
00:00:57,744 --> 00:01:00,000
表达式就像这样在EVAL-APPLY之间传递
and passes that off to EVAL, which passes it to APPLY,

13
00:01:00,272 --> 00:01:01,440
这就是整个元循环
and there's this whole big circle

14
00:01:01,470 --> 00:01:02,944
表达式在这里面循环往复
where things go around and around and around

15
00:01:03,024 --> 00:01:06,560
直到最后求值为基本数据或基本过程
until you get either to some very primitive data or to a primitive procedure.

16
00:01:07,740 --> 00:01:09,248
这个循环要做的就是
See, what this cycle has to do with

17
00:01:09,440 --> 00:01:12,576
把语言中的组合手段
is unwinding the means of combination

18
00:01:12,590 --> 00:01:14,368
和抽象手段展开
and the means of abstraction in the language.

19
00:01:15,020 --> 00:01:17,728
比如说在Lisp中 你有一个过程
So for instance, you have a procedure in LISP--

20
00:01:17,744 --> 00:01:20,528
定义过程是为了
a procedure is a general way of saying,

21
00:01:20,540 --> 00:01:22,576
让表达式的计算过程
I want to be able to evaluate this expression

22
00:01:22,672 --> 00:01:24,410
适用于任意的参数
for any value of the arguments,

23
00:01:25,760 --> 00:01:27,184
这就是这里面发生的事情
and that's sort of what's going on here.

24
00:01:27,670 --> 00:01:28,510
这就是APPLY做的事
That's what APPLY does.

25
00:01:28,510 --> 00:01:30,688
当一个带参数的一般性表达式进入以后
It says the general thing coming in with the arguments

26
00:01:30,720 --> 00:01:32,704
它将其归约为过程体的表达式
reduces to the expression that's the body,

27
00:01:33,056 --> 00:01:34,720
如果归约得到的是复合表达式
and then if that's a compound expression

28
00:01:34,832 --> 00:01:36,464
或者是另外的过程应用
or another procedure application,

29
00:01:36,784 --> 00:01:38,448
那么这个循环就会不断地进行
the thing will go around and around the circle.

30
00:01:40,336 --> 00:01:44,080
这基本上就是 -- 大部分解释器的基本结构了
Anyway, that's sort of the basic structure of gee, pretty much any interpreter.

31
00:01:45,200 --> 00:01:46,256
另外一点就是
The other thing that you saw

32
00:01:46,288 --> 00:01:47,660
一旦你有了一个解释器
once you have the interpreter in your hands,

33
00:01:47,696 --> 00:01:49,870
你就有了操作这门语言的所有能力
you have all this power to start playing with the language.

34
00:01:49,870 --> 00:01:51,520
因此你可以让它成为动态作用域
So you can make it dynamically scoped,

35
00:01:51,840 --> 00:01:54,560
你也可以引入正则序求值
or you can put in normal order evaluation,

36
00:01:54,590 --> 00:01:56,480
你也可以为语言添加新的形式
or you can add new forms to the language,

37
00:01:56,860 --> 00:01:57,504
想怎么样都行
whatever you like.

38
00:01:57,584 --> 00:01:58,624
或者更一般地说
Or more generally,

39
00:01:58,768 --> 00:02:01,328
这种元语言抽象的概念
there's this notion of metalinguistic abstraction,

40
00:02:02,640 --> 00:02:06,016
它告诉我们 作为一名软件工程师
which says that part of your perspective

41
00:02:07,616 --> 00:02:10,528
从广义的“工程师”的角度来看
as an engineer, as a software engineer, but as an engineer in general

42
00:02:11,392 --> 00:02:13,888
有时你可以通过发明新的语言
is that you can gain control of complexity

43
00:02:14,960 --> 00:02:17,168
来获得控制复杂度的能力
by inventing new languages sometimes.

44
00:02:18,010 --> 00:02:20,816
一种思考计算机程序设计的方法就是
See, one way to think about computer programming

45
00:02:21,552 --> 00:02:26,270
它只是偶然地让计算机执行某事儿
is that it only incidentally has to do with getting a computer to do something.

46
00:02:26,440 --> 00:02:28,976
计算机程序的主要工作却是
Primarily what a computer program has to do with,

47
00:02:29,008 --> 00:02:32,520
用来表达和交流思想
it's a way of expressing ideas with communicating ideas.

48
00:02:33,168 --> 00:02:34,048
有时
And sometimes

49
00:02:34,896 --> 00:02:36,624
当我们想要表达新的思想时
when you want to communicate new kinds of ideas,

50
00:02:36,656 --> 00:02:38,736
我们就想要发明新的模式来表达它们
you'd like to invent new modes of expressing that.

51
00:02:39,824 --> 00:02:44,992
那么 今天我们就将按照这个框架来创建新语言
Well, today we're going to apply this framework to build a new language.

52
00:02:45,730 --> 00:02:48,000
一旦我们了解了解释器的基本结构
See, once we have the basic idea of the interpreter,

53
00:02:48,032 --> 00:02:50,272
我们就可以按意愿来构造任意的语言
you can pretty much go build any language that you like.

54
00:02:50,830 --> 00:02:53,216
比如说 我们可以构造Pascal（的解释器）
So for example, we can go off and build Pascal.

55
00:02:54,370 --> 00:02:55,152
以及
And...

56
00:02:56,170 --> 00:02:58,192
我们需要操心语法的表示与解析
gee, we would worry about syntax and parsing

57
00:02:58,192 --> 00:03:00,510
还有一大堆的编译器优化
and various kinds of compiler optimizations,

58
00:03:01,120 --> 00:03:03,296
还有一些人会这样做
and there are people who make honest livings doing that,

59
00:03:03,856 --> 00:03:07,600
但是就在我们所讨论的抽象层次来说
but at the level of abstraction that we're talking,

60
00:03:08,048 --> 00:03:10,992
一个Pascal语言的解释器看起来
a Pascal interpreter would not look very different at all

61
00:03:12,032 --> 00:03:13,760
跟Gerry教授上节课所讲的大同小异
from what you saw Gerry do last time.

62
00:03:15,024 --> 00:03:18,960
但是今天 我们要构建一门与众不同的语言
Instead of that, we'll spend today building a really different language,

63
00:03:20,510 --> 00:03:22,816
这门语言
a language that encourages you

64
00:03:23,056 --> 00:03:26,040
不推荐你用过程式的思维来思考程序设计
to think about programming not in terms of procedures,

65
00:03:26,240 --> 00:03:27,648
而是用一种非常不同的方式
but in a really different way.

66
00:03:29,090 --> 00:03:31,024
今天的课程呢
And the lecture today is

67
00:03:31,744 --> 00:03:34,640
将会在两个层次中同时进行
going to be at two levels simultaneously.

68
00:03:34,810 --> 00:03:35,520
一方面
On the one hand,

69
00:03:35,904 --> 00:03:37,710
我会向大家介绍这门语言是如何使用的
I'm going to show you what this language looks like,

70
00:03:38,960 --> 00:03:41,080
另一方面呢 我会带领大家实现这门语言
and on the other hand, I'll show you how it's implemented.

71
00:03:41,320 --> 00:03:42,960
我们将会用Lisp来实现
And we'll build an implementation in LISP

72
00:03:42,992 --> 00:03:43,900
并观察它的运行原理
and see how that works.

73
00:03:44,048 --> 00:03:48,256
你应该在两个层次上学到知识
And you should be drawing lessons on two levels.

74
00:03:48,688 --> 00:03:53,000
首先要认识到 语言之间可以有多么地“不同”
The first is to realize just how different a language can be.

75
00:03:53,790 --> 00:03:58,144
如果你认为Fortran和Lisp算是天差地别的话
So if you think that the jump from Fortran to LISP is a big deal,

76
00:03:58,240 --> 00:03:59,360
那就小巫见大巫了
you haven't seen anything yet.

77
00:04:01,560 --> 00:04:03,680
其次
And secondly,

78
00:04:03,776 --> 00:04:06,544
甚至于在这门与众不同的语言中
you'll see that even with such a very different language,

79
00:04:07,360 --> 00:04:09,520
这门既不讨论函数
which will turn out to not have procedures at all

80
00:04:09,920 --> 00:04:11,648
也没有过程的语言中
and not talk about functions at all,

81
00:04:12,200 --> 00:04:15,720
其中也有基本的EVAL-APPLY循环
there will still be this basic cycle of eval and apply

82
00:04:16,192 --> 00:04:19,984
也就是对组合手段和抽象手段的展开
that's unwinds the means of combination and the means an abstraction.

83
00:04:20,950 --> 00:04:24,688
第三点 是一个不太重要但非常优雅的技术技巧
And then thirdly, as kind of a minor but elegant technical point,

84
00:04:24,890 --> 00:04:28,528
就是如何使用流来规避回溯
you'll see a nice use of streams to avoid backtracking.

85
00:04:32,330 --> 00:04:34,400
好吧 我说过这门语言与众不同
OK, well, I said that this language is very different.

86
00:04:35,860 --> 00:04:36,640
为了解释这点
To explain that,

87
00:04:37,050 --> 00:04:42,816
让我们回到这门课最初的理念上
let's go back to the very first idea that we talked about in this course,

88
00:04:43,260 --> 00:04:46,544
就是要区别
and that was the idea of the distinction between

89
00:04:46,720 --> 00:04:49,520
数学中“陈述性”的知识
the declarative knowledge of mathematics--

90
00:04:50,192 --> 00:04:54,144
比如平方根的定义就是一条数学事实
the definition of a square root as a mathematical truth--

91
00:04:55,488 --> 00:04:59,568
而计算机科学讨论的是“如何做”的只是
and the idea that computer science talks about the how to knowledge--

92
00:04:59,760 --> 00:05:04,592
“什么是平方根”和“如何计算平方根”是不同的
contrast that definition of square root with a program to compute a square root.

93
00:05:05,970 --> 00:05:07,072
我们是从这里开始的
That's where we started off.

94
00:05:08,512 --> 00:05:09,520
如果我们能够通过某种方式
Well, wouldn't it be great

95
00:05:09,888 --> 00:05:12,160
弥合这种差距 岂不是更好么？
if you could somehow bridge this gap

96
00:05:12,810 --> 00:05:16,432
我们创建一门这样的语言
and make a programming language which sort of did things,

97
00:05:16,672 --> 00:05:21,610
以声明式的方式、用数学事实来完成计算
but you talked about it in terms of truth, in declarative terms?

98
00:05:22,380 --> 00:05:25,504
你用这种该语言来指定事实
So that would be a programming language in which you specify facts.

99
00:05:27,690 --> 00:05:28,880
你告诉它
You tell it what is.

100
00:05:28,880 --> 00:05:29,968
什么是事实
You say what is true.

101
00:05:30,950 --> 00:05:33,072
而当你需要一个答案时
And then when you want an answer,

102
00:05:33,216 --> 00:05:36,384
语言已经自动地内建了
somehow the language has built into it automatically

103
00:05:37,600 --> 00:05:39,456
有关于“如何做”的一般性知识
general kinds of how to knowledge

104
00:05:39,472 --> 00:05:40,640
这样它就可以根据你给出的事实
so it can just take your facts

105
00:05:40,896 --> 00:05:42,832
自行地演进这些方法
and it can evolve these methods on its own

106
00:05:43,312 --> 00:05:46,128
通过你给定的事实和某种一般性的逻辑规则
using the facts you gave it and maybe some general rules of logic.

107
00:05:49,330 --> 00:05:50,544
就比如说
So for instance,

108
00:05:52,064 --> 00:05:55,120
我会告诉程序下述事实
I might go up to this program and start telling it some things.

109
00:05:56,000 --> 00:06:07,080
我告诉它 (SON-OF ADAM ABEL)
So I might tell it that the son of Adam is Abel.

110
00:06:08,920 --> 00:06:16,512
同时告诉它 (SON-OF ADAM CAIN)
And I might tell it that the son of Adam is Cain.

111
00:06:17,660 --> 00:06:25,088
以及 (SON-OF CAIN ENOCH)
And I might tell it that the son of Cain is Enoch.

112
00:06:27,792 --> 00:06:34,896
还有 (SON-OF ENOCH IRAD)
And I might tell it that the son of Enoch is Irad,

113
00:06:37,024 --> 00:06:40,720
#TBD
and all through the rest of our chapter whatever of Genesis,

114
00:06:41,152 --> 00:06:43,184
最后终止于ADAH
which ends up ending in Adah, by the way,

115
00:06:43,328 --> 00:06:46,784
这些是从ADAH到CAIN的家谱
and this shows the genealogy of Adah from Cain.

116
00:06:48,440 --> 00:06:50,672
总之 一旦你指明了这些事实
Anyway, once you tell it these facts,

117
00:06:52,352 --> 00:06:53,408
你就可以提出问题
you might ask it things.

118
00:06:53,510 --> 00:06:55,056
你可以对语言系统发问
You might go up to your language and say,

119
00:06:56,064 --> 00:06:59,296
谁是ADAM的孩子？
who's the son of Adam?

120
00:07:00,420 --> 00:07:04,912
可以很容易地想到一个通用搜索程序
And you can very easily imagine having a little general purpose search program

121
00:07:05,520 --> 00:07:06,960
它会遍历所有的事实
which would be able to go through

122
00:07:07,008 --> 00:07:09,260
然后回答：“哦 有两个答案”
and in response to that say, oh yeah, there are two answers:

123
00:07:09,296 --> 00:07:10,448
ABEL是ADAM的孩子
the son of Adam is Abel

124
00:07:10,688 --> 00:07:12,176
CAIN也是ADAM的孩子
and the son of Adam is Cain.

125
00:07:14,140 --> 00:07:14,976
你也可以这样问
Or you might say,

126
00:07:15,070 --> 00:07:16,890
基于同样的事实
based on the very same facts,

127
00:07:18,048 --> 00:07:19,952
CAIN是谁的孩子？
who is Cain the son of?

128
00:07:21,950 --> 00:07:27,024
你们就会想到生成另外一个略微不同的搜索程序
And then you can imagine generating another slightly different search program

129
00:07:27,920 --> 00:07:29,216
它也会遍历所有的事实
which would be able to go through

130
00:07:29,450 --> 00:07:33,056
检查谁的孩子是CAIN
and checked for who is Cain, and son of,

131
00:07:33,520 --> 00:07:34,440
发现结果是ADAM
and come up with Adam.

132
00:07:35,890 --> 00:07:36,992
你也可以问
Or you might say,

133
00:07:38,016 --> 00:07:41,408
CAIN和ENOCH之间是什么关系？
what's the relationship between Cain and Enoch?

134
00:07:42,070 --> 00:07:45,088
又会生成另一个略微不同的搜索程序
And again, a minor variant on that search program.

135
00:07:46,340 --> 00:07:48,160
得到的结果是亲子关系（SON-OF）
You could figure out that it said son of.

136
00:07:52,880 --> 00:07:54,928
在这个非常简单的例子中
But even here in this very simple example,

137
00:07:56,144 --> 00:07:58,448
我们发现 即使是单条事实
what you see is that a single fact,

138
00:07:58,816 --> 00:08:01,520
比如说 (SON-OF ADAM CAIN)
see, a single fact like the son of Adam is Cain

139
00:08:02,848 --> 00:08:05,520
可以被用来回答不同种类的问题
can be used to answer different kinds of questions.

140
00:08:06,520 --> 00:08:08,128
你可以问CAIN是谁的孩子？
You can say, who's Cain the son of,

141
00:08:08,144 --> 00:08:10,928
你也可以问ADAM的孩子是谁？
or you can say who's the son of Adam,

142
00:08:10,928 --> 00:08:10,944
你也可以问ADAM和CAIN之间的关系是什么？
or you can say what's the relation between Adam and Cain?
你也可以问ADAM的孩子是谁？
or you can say who's the son of Adam,

143
00:08:10,944 --> 00:08:12,864
你也可以问ADAM和CAIN之间的关系是什么？
or you can say what's the relation between Adam and Cain?

144
00:08:12,880 --> 00:08:14,480
这些由不同的传统程序
Those are different questions

145
00:08:15,536 --> 00:08:18,544
所解答的不同的问题
being run by different traditional procedures

146
00:08:18,688 --> 00:08:20,720
都基于同样的事实
all based on the same fact.

147
00:08:22,752 --> 00:08:25,920
这正是这种程序设计风格的威力所在
And that's going to be the essence of the power of this programming style,

148
00:08:26,912 --> 00:08:29,504
也就是一条陈述性知识
that one piece of declarative knowledge

149
00:08:30,040 --> 00:08:34,016
可以作为大量关于“如何做”的各种知识的基础
can be used as the basis for a lot of different kinds of how-to knowledge,

150
00:08:34,816 --> 00:08:37,088
这跟我们正在编写的过程是不同的
as opposed to the kinds of procedures we're writing

151
00:08:37,152 --> 00:08:39,552
我们编写的过程描述了输入
where you sort of tell it what input you're giving in

152
00:08:39,616 --> 00:08:40,656
以及想要的输出
and what answer you want.

153
00:08:41,490 --> 00:08:44,704
比如说 我们的平方根程序可以完美地回答
So for instance, our square root program can perfectly well answer the question,

154
00:08:44,768 --> 00:08:47,168
144的平方根是多少？
what's the square root of 144?

155
00:08:48,900 --> 00:08:49,776
但从原理上来说
But in principle,

156
00:08:49,824 --> 00:08:52,830
平方根的数学定义告诉了你另外的东西
the mathematical definition of square root tells you other things.

157
00:08:52,848 --> 00:08:56,430
就比如说 17是谁的平方根
Like it could say, what is 17 the square root of?

158
00:08:57,590 --> 00:08:59,712
这就需要另外一个程序来解答
And that would be have to be answered by a different program.

159
00:09:01,920 --> 00:09:03,504
因此 数学定义
So the mathematical definition,

160
00:09:03,980 --> 00:09:05,120
或者更一般地说
or in general, the

161
00:09:05,536 --> 00:09:10,300
你给定的事实 对于问题是没有偏向性的
the facts that you give it are somehow unbiased as to what the question is.

162
00:09:10,900 --> 00:09:12,816
而我们倾向于编写专门的程序
Whereas the programs we tend to write specifically

163
00:09:12,830 --> 00:09:14,208
因为它们是关于“如何做”的知识
because they are how-to knowledge

164
00:09:14,240 --> 00:09:16,368
倾向于寻找特定的答案
tend to be looking for a specific answer.

165
00:09:17,568 --> 00:09:20,120
所以这是我们正在讨论的一个特点
So that's going to be one characteristic of what we're talking about.

166
00:09:21,810 --> 00:09:22,608
然而我们可以更进一步
We can go on.

167
00:09:23,480 --> 00:09:27,520
想象一下 我们可以向语言给定一些事实
We can imagine that we've given our language some sort of facts.

168
00:09:27,710 --> 00:09:29,616
现在 我们给它一些推理规则
Now let's give it some rules of inference.

169
00:09:30,020 --> 00:09:31,360
比如说
We can say, for instance,

170
00:09:31,952 --> 00:09:36,192
这里 我们先用某种语法表示
if the-- make up some syntax here--

171
00:09:36,448 --> 00:09:41,536
如果(SON-OF ?X ?Y)成立
if the son of x is y--

172
00:09:41,680 --> 00:09:45,210
在这里 我用问号来标识变量
I'll put question marks to indicate variables here--

173
00:09:45,616 --> 00:09:56,060
如果(SON-OF ?X ?Y)和(SON-OF ?Y ?Z)都成立
if the son of x is y and the son of y is z,

174
00:09:58,960 --> 00:10:08,464
那么就有(GRANSON ?X ?Z)
then the grandson of x is z.

175
00:10:09,320 --> 00:10:13,408
想象一下 如果把这条规则告诉机器
So I can imagine telling my machine that rule

176
00:10:15,008 --> 00:10:17,280
那么我们就可以这么来询问
and then being able to say, for instance,

177
00:10:17,440 --> 00:10:18,688
谁是ADAM的孙子？
who's the grandson of Adam?

178
00:10:20,610 --> 00:10:23,648
或者说 IRAD是谁的孙子？
Or who is Irad the grandson of?

179
00:10:24,790 --> 00:10:29,088
或者从这些信息中尽可能地推断出所有的祖孙关系
Or deduce all grandson relationships you possibly can from this information.

180
00:10:31,136 --> 00:10:35,600
我们可以想象 语言知道如何自动求解
We can imagine somehow the language knowing how to do that automatically.

181
00:10:40,224 --> 00:10:45,200
好吧 我再举一个更具体一点的例子
Ok, Let me give you maybe a little bit more concrete example.

182
00:10:45,776 --> 00:10:51,952
这是个用来合并两个有序表的过程
Here's a procedure that merges two sorted lists.

183
00:10:53,920 --> 00:11:00,272
X和Y是两个由数字构成的表
So x and y are two, say, lists of numbers,

184
00:11:00,304 --> 00:11:04,208
我们可以认为它们是严格升序的表
lists of distinct numbers, if you like, that are in increasing order.

185
00:11:04,768 --> 00:11:07,530
MERGE会把这两个表
And what merge does is take two such lists

186
00:11:07,712 --> 00:11:10,384
合并成一个有序的表
and combine them into a list where everything's in increasing order,

187
00:11:11,210 --> 00:11:15,000
这个程序非常简单
and this is a pretty easy programs

188
00:11:15,024 --> 00:11:16,144
你们可以轻松地写出来
that you ought to be able to write.

189
00:11:16,390 --> 00:11:18,640
也就是 如果X为空 那么结果就是Y
It says, if x is empty, the answer is y.

190
00:11:18,860 --> 00:11:20,464
如果Y为空 那结果就是X
If y is empty, the answer is x.

191
00:11:21,180 --> 00:11:22,990
否则的话 就要比较为首的两个元素
Otherwise, you compare the first two elements.

192
00:11:22,990 --> 00:11:24,464
取出X中的第一个元素
So you pick out the first thing in x

193
00:11:24,848 --> 00:11:26,016
以及Y中的第一个元素
and the first thing in y,

194
00:11:26,810 --> 00:11:31,680
把它们当中谁是最小的那一个
and then depending on which of those first elements is less,

195
00:11:32,832 --> 00:11:36,608
CONS在递归地调用MERGE的结果上
you stick the lower one on to the result a recursively merging,

196
00:11:37,872 --> 00:11:39,920
要么就是(MERGE (CDR X) Y)
either chopping the first one off x

197
00:11:40,112 --> 00:11:41,616
要么就是(MERGE X (CDR Y))
or chopping the first one off y.

198
00:11:42,400 --> 00:11:43,960
这是标准的程序
That's a standard kind of program.

199
00:11:46,470 --> 00:11:48,416
我们来考察下其中的逻辑
Let's look at the logic.

200
00:11:48,620 --> 00:11:49,792
先不考虑程序
Let's forget about the program

201
00:11:50,288 --> 00:11:52,768
来看看这个过程所基于的逻辑
and look at the logic on which that procedure is based.

202
00:11:53,820 --> 00:11:55,008
这其中的逻辑是
See, there's some logic which says,

203
00:11:55,024 --> 00:11:57,210
如果第一个元素较小
gee, if the first one is less,

204
00:11:57,536 --> 00:12:00,000
那么最后的结果就是把它
then we get the answer by sticking something onto the

205
00:12:00,160 --> 00:12:02,128
跟递归MERGE的结果CONS起来
the result of recursively merging the rest.

206
00:12:02,848 --> 00:12:04,096
让我们试着把
So let's try and be explicit about

207
00:12:04,240 --> 00:12:06,416
使这个程序运作的逻辑说清楚一点
what that logic is that's making the program work.

208
00:12:08,304 --> 00:12:09,440
#TBD
So here's one piece.

209
00:12:10,130 --> 00:12:11,536
这段程序
Here's the piece of the program which

210
00:12:12,640 --> 00:12:15,264
递归地剥离X
recursively chops down x

211
00:12:15,664 --> 00:12:17,824
如果X中的首元素较小的话
if the first thing in x is smaller.

212
00:12:19,980 --> 00:12:22,544
如果要显式地指出其中的逻辑的话
And if you want to be very explicit about what the logic is there,

213
00:12:23,450 --> 00:12:26,496
它其实就是演绎推理
what's really going on is a deduction,

214
00:12:26,720 --> 00:12:32,384
其中 如果知道表CDR-X和表Y
which says, if you know that some list, that we'll call cdr of x, and y

215
00:12:33,290 --> 00:12:35,440
能够通过MERGE-TO-FORM形成Z
merged to form z,

216
00:12:37,840 --> 00:12:41,520
并且还知道A比Y中的第一个元素小
And you know that a is less than the first thing in y.

217
00:12:43,600 --> 00:12:48,520
那么你就知道 如果你把A和CDR-X给CONS起来
then you know that if you put a onto the cdr of x.

218
00:12:49,740 --> 00:12:51,850
得到的结果和Y一起
and that result and y

219
00:12:52,608 --> 00:12:54,992
可以通过MERGE-TO-FORM形成Z
merge-to-form a onto z.

220
00:12:55,820 --> 00:12:58,096
这就是它所基于的逻辑
And what that is, that's the underlying piece of logic--

221
00:12:58,720 --> 00:12:59,952
我没有把它写成程序
I haven't written it as a program,

222
00:12:59,968 --> 00:13:02,000
我把它写成了某种演绎
I wrote it a sort of deduction

223
00:13:02,032 --> 00:13:04,896
正是属于这个特定子句的
that sits underneath this particular clause

224
00:13:05,216 --> 00:13:07,264
它告诉我们可以在这里使用递归
that says we can use the recursion there.

225
00:13:09,410 --> 00:13:12,784
同样地 这里还有些句子来补全其中的逻辑
And then similar, here's the other clause just to complete it.

226
00:13:14,000 --> 00:13:15,872
其它的句子都是基于这些逻辑
The other clause is based on this piece of logic,

227
00:13:15,920 --> 00:13:18,352
由于它们大部分是相同的 我就不细讲了
which is almost the same and I won't go through it,

228
00:13:19,008 --> 00:13:20,352
然后就是终止条件
and then there's the end cases

229
00:13:20,416 --> 00:13:22,016
是用来检查NULL的
where we tested for null,

230
00:13:22,032 --> 00:13:24,048
其基本想法是 对于任意的X
and that's based on the idea that for any x,

231
00:13:24,510 --> 00:13:27,200
X和空表可以通过MERGE-TO-FORM形成X
x and the empty list merge to form an x,

232
00:13:28,048 --> 00:13:30,864
而空表可以和任意的Y通过MERGE-TO-FORM形成Y
or for any y, the empty list and y merge to form y.

233
00:13:33,360 --> 00:13:38,128
这就是一段过程的代码
OK, so there's a piece of procedure

234
00:13:38,432 --> 00:13:40,112
以及它所基于的逻辑
and the logic on which it's based.

235
00:13:41,740 --> 00:13:42,976
请注意其中的巨大差异
And notice a big difference.

236
00:13:45,104 --> 00:13:50,528
过程看起来是像这样的：
The procedure looked like this:

237
00:13:50,656 --> 00:13:52,288
首先这有一个盒子
it said there was a box--

238
00:13:52,860 --> 00:13:55,392
我们到目前为止所做的事都有这样的特征
and all the things we've been doing have the characteristic

239
00:13:55,408 --> 00:13:57,690
我们有一个盒子 有东西进去 也有东西出来
we have boxes and things going in and things going out--

240
00:13:58,080 --> 00:13:59,610
这儿有个MERGE盒子
there was this box called merge,

241
00:14:01,296 --> 00:14:03,856
输入是X和Y
and in came an x and y,

242
00:14:04,448 --> 00:14:05,376
输出ANS
and out came an answer.

243
00:14:07,632 --> 00:14:09,488
这是我们所编写的程序的特征
That's the character of the procedure that we wrote.

244
00:14:13,024 --> 00:14:14,660
但是规则并不像这样
These rules don't look like that.

245
00:14:14,660 --> 00:14:16,768
规则讨论的是关系
These rules talk about a relation.

246
00:14:17,920 --> 00:14:24,160
也就是在幻灯片中我称作MERGE-TO-FORM的关系
There's some sort of relation that in those slides I called mrege-to-form.

247
00:14:25,370 --> 00:14:28,768
每当我说X和Y通过MERGE-TO-FORM形成Z
So I said x and y merge to form z,

248
00:14:29,008 --> 00:14:32,336
这个是一个函数
and somehow this is not -- this is a function.

249
00:14:32,610 --> 00:14:32,850
对吧？
Right?

250
00:14:32,850 --> 00:14:34,416
ANS是X和Y的函数
The answer is a function of x and y,

251
00:14:34,592 --> 00:14:38,192
而我这里得到的是三个东西之间的关系
and here what I have is a relation between three things.

252
00:14:39,720 --> 00:14:41,328
我不会指明
And I'm not going to specify

253
00:14:42,096 --> 00:14:43,770
哪个是输入 哪个是输出
which is the input and which is the output.

254
00:14:44,200 --> 00:14:47,408
我之所以这么说 是因为原理上
And the reason I want to say that is because in principle,

255
00:14:48,640 --> 00:14:50,832
我们可以用同样的逻辑规则
we could use exactly those same logic rules

256
00:14:50,848 --> 00:14:52,448
来回答相当多的问题
answer a lot of different questions.

257
00:14:54,570 --> 00:14:56,304
比如 我们可以问
So we can say, for instance-- giving

258
00:14:56,720 --> 00:14:59,050
想象一下 如果把这些逻辑规则输入机器
imagine giving our machine those rules of logic.

259
00:14:59,050 --> 00:15:01,200
不是输入程序 而是其中依赖的逻辑
Not the program, the underlying rules of logic.

260
00:15:01,400 --> 00:15:03,120
那么 它也就应该回答--
Then it ought to be able to say--

261
00:15:04,752 --> 00:15:05,520
我们可以问它
we could ask it--

262
00:15:06,736 --> 00:15:19,184
(1 3 7)和(2 4 8)可以通过MERGE-TO-FORM形成什么？
1, 3, 7 and 2, 4, 8 merge to form what?

263
00:15:20,910 --> 00:15:23,424
机器能够回答这样的问题
And that's a question it ought to be able to answer.

264
00:15:23,880 --> 00:15:27,360
这同样也是我们的Lisp程序所回答的问题
That's exactly the same question that our Lisp procedure answered.

265
00:15:28,180 --> 00:15:30,144
但这同样的规则
But the exact same rules

266
00:15:30,896 --> 00:15:34,800
也能够回答像这样的问题：
should also be able to answer a question like this:

267
00:15:36,192 --> 00:15:43,248
(1 3 7)和什么能够通过MERGE-TO-FORM形成(1 2 3 4 7 8)
1, 3, 7 and what merged to form 1, 2, 3, 4, 7, 8?

268
00:15:45,560 --> 00:15:47,808
同样的逻辑规则也能够回答这个
The same rules of logic can answer this,

269
00:15:47,840 --> 00:15:49,904
但我们编写的过程却无法回答这个问题
although the procedure we wrote can't answer that question.

270
00:15:50,800 --> 00:15:52,336
又或者 我们可以问
Or we might be able to say what

271
00:15:53,710 --> 00:16:01,120
什么和什么能通过MERGE-TO-FORM
what and what else merge to form--

272
00:16:04,288 --> 00:16:12,688
哪两个东西可以通过MERGE-TO-FORM形成(1 2 3 4 7 8)？
what and what else merge to form 1, 2, 3, 4, 7, 8?

273
00:16:13,780 --> 00:16:15,344
机器能够进行遍历
And the thing should be able to go through,

274
00:16:15,840 --> 00:16:17,312
如果它能应用这些逻辑规则的话
if it really can apply that logic,

275
00:16:17,792 --> 00:16:22,540
就能够推断出这个问题所有的2^6种答案
and deduce all, whatever is, 2 to the sixth answers to that question.

276
00:16:25,600 --> 00:16:27,690
因为可以分别是 (1)和其余的
Cause it could be 1 and the rester, or it could be 1, 2 and the rest.

277
00:16:27,696 --> 00:16:28,752
也可以是 (1 2)和其余的
or it could be 1, 2 and the rester.

278
00:16:28,790 --> 00:16:31,536
也可以是(1 3 7)和其余的
Or it could be 1 and 3 and 7 and the rest.

279
00:16:32,016 --> 00:16:33,264
有一大堆的答案
There's a whole bunch of answers.

280
00:16:33,410 --> 00:16:37,760
但原理上来说 逻辑能推断出所有的答案
And in principle, the logic should be enough to deduce that.

281
00:16:38,550 --> 00:16:42,032
因此这里面就有两个巨大的不同
So there are going to be two big differences

282
00:16:44,048 --> 00:16:46,000
在我们所编写的程序中
in the kind of program we're going to look at

283
00:16:46,540 --> 00:16:48,192
不只是Lisp程序
and not only Lisp,

284
00:16:48,208 --> 00:16:50,560
基本上是你们目前编写过的所有程序
but essentially all the programming you've probably done so far

285
00:16:52,032 --> 00:16:53,600
用你能叫出名字的程序语言所编写的程序
in pretty much any language you can think of.

286
00:16:54,150 --> 00:16:57,792
首先 我们并不准备计算一个函数
The first is, we're not going to be computing functions.

287
00:17:00,620 --> 00:17:02,016
我们将要讨论的东西
We're not going to be talking about

288
00:17:02,624 --> 00:17:04,410
并不具有输入和输出
about things that take input and output.

289
00:17:04,410 --> 00:17:05,824
我们讨论的是关系
We're going to be talking about relations.

290
00:17:06,890 --> 00:17:10,000
也就是说 原理上 关系是没有方向性的
And that means in principle, these relations don't have directionality.

291
00:17:11,080 --> 00:17:15,056
所以你指明用来回答这个问题的知识
So the knowledge that you specify to answer this question,

292
00:17:16,460 --> 00:17:18,416
也同样应该能够反过来
should be same, that same knowledge

293
00:17:18,432 --> 00:17:21,800
让你回答其它的这些问题
also allow you to answer these other questions and conversely.

294
00:17:26,608 --> 00:17:29,408
其次则是
And the second issue is that

295
00:17:29,616 --> 00:17:31,232
因为我们讨论的是关系
since we're talking about relations,

296
00:17:32,320 --> 00:17:34,448
关系的答案并不唯一
these relations don't necessarily have one answer.

297
00:17:35,610 --> 00:17:37,008
所以在第三个问题中
So that third question down there

298
00:17:37,020 --> 00:17:38,360
并没有特定的答案
doesn't have a particular answer,

299
00:17:38,400 --> 00:17:39,584
它有很多的答案
it has a whole bunch of answers.

300
00:17:42,270 --> 00:17:44,640
这就是我们的目标
Well, that's where we're going.

301
00:17:44,640 --> 00:17:45,904
顺便说一下
This style of programming,

302
00:17:46,720 --> 00:17:49,216
这种程序设计风格被称作逻辑式程序设计
by the way, is called logic programming,

303
00:17:50,224 --> 00:17:51,584
原因是显而易见的
for kind of obvious reasons.

304
00:17:56,160 --> 00:18:00,384
用逻辑式进行程序设计的那群人之间
And people who do logic programming say that --

305
00:18:00,400 --> 00:18:03,150
流传着几句箴言
they have this little phrase--

306
00:18:03,168 --> 00:18:04,672
他们把逻辑式程序设计的要点归纳为
they say the point of logic programming

307
00:18:04,768 --> 00:18:09,008
用逻辑来表达什么算是“真的”
is that you use logic to express what is true,

308
00:18:10,096 --> 00:18:13,888
用逻辑来检测是否是“真的”
you use logic to check whether something is true,

309
00:18:14,672 --> 00:18:17,248
用逻辑来找出这些“真的”
and you use logic to find out what is true.

310
00:18:19,200 --> 00:18:22,096
最为大家所熟知的逻辑式程序设计语言
The best known logic programming language,

311
00:18:22,976 --> 00:18:24,784
你们可能也听过 -- 叫做Prolog
as you probably know, is called Prolog.

312
00:18:25,780 --> 00:18:28,880
今天早上我们将要实现的这门语言
The language that we're going to implement this morning

313
00:18:29,824 --> 00:18:32,320
是一种查询语言
is something we call the query language,

314
00:18:32,480 --> 00:18:34,416
它基本上就是Prolog的本质了
and it essentially has the essence of prolog.

315
00:18:35,320 --> 00:18:36,736
它可以完成相同的工作
It can do about the same stuff,

316
00:18:37,290 --> 00:18:38,736
虽然它比Prolog慢得多
although it's a lot slower

317
00:18:38,736 --> 00:18:40,010
这是因为我们是通过Lisp来解释的
because we're going to implement it in LISP

318
00:18:41,904 --> 00:18:44,368
而非构造一个专门的编译器
rather than building a particular compiler.

319
00:18:44,464 --> 00:18:46,624
对它的解释 将运行在Lisp解释器之上
We're going to interpret it on top of the LISP interpreter.

320
00:18:47,510 --> 00:18:49,840
除此之外 它可以完成与Prolog相同的事儿
But other than that, it can do about the same stuff as prolog.

321
00:18:49,888 --> 00:18:52,784
不但同样的能力 也有同样的局限
It has about the same power and about the same limitations.

322
00:18:55,088 --> 00:18:56,176
好吧 先解答一下疑惑
All right, let's break for question.

323
00:19:00,430 --> 00:19:02,848
学生：您能再重复一下
STUDENT: Yes, could you please repeat what the three

324
00:19:03,488 --> 00:19:06,090
用逻辑去寻找的三件事么？
things you use logic programming to find?

325
00:19:06,720 --> 00:19:09,840
就是那些 找出什么为真 知道什么是真 等等
In other words, to find what is true, learn what is true-- what is the?

326
00:19:09,840 --> 00:19:10,520
教授：好的
PROFESSOR: Right.

327
00:19:10,560 --> 00:19:15,744
这算是程序员的某种“教义问答”
Sort of a logic programmer's little catechism.

328
00:19:15,850 --> 00:19:19,160
我们用逻辑来表达怎么算是“真的”
You use logic to express what is true,

329
00:19:20,800 --> 00:19:21,792
就像这些规则一样
like these rules.

330
00:19:22,610 --> 00:19:25,568
我们用逻辑来检测某事是否是“真的”
You use logic to check whether something is true,

331
00:19:25,600 --> 00:19:27,760
但在这里我没有回答这个问题
and that's the kind of question I didn't answer here.

332
00:19:28,550 --> 00:19:29,296
我可以问
I might say--

333
00:19:29,680 --> 00:19:32,144
在这里我可以这样来问
another question I could put down here is to say,

334
00:19:33,264 --> 00:19:36,560
(1 3 7)和(2 4 8)是否能够
is it true that 1, 3, 7 and 2, 4, 8

335
00:19:36,910 --> 00:19:40,380
通过MERGE-TO-FORM形成(1 2 6 19)
merge to form 1, 2, 6, 10

336
00:19:41,120 --> 00:19:44,688
同样的逻辑规则会告诉我们不行
And that same logic should be enough to say no.

337
00:19:45,690 --> 00:19:47,936
这里 我使用逻辑来检测是否为真
So I use logic to check what is true,

338
00:19:48,288 --> 00:19:50,480
然后 我们也可以使用逻辑来找出为真的东西
and then you also use logic to find out what's true.

339
00:20:04,464 --> 00:20:05,168
休息一下吧
Let's break.

340
00:20:06,130 --> 00:20:17,024
[音乐]
[JESU, JOY OF MAN'S DESIRING]

341
00:20:17,050 --> 00:20:20,688
《计算机程序的构造和解释》

342
00:20:47,590 --> 00:20:51,024
讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授

343
00:20:51,070 --> 00:20:55,600
《计算机程序的构造和解释》

344
00:20:55,630 --> 00:21:00,688
逻辑式程序设计

345
00:21:03,248 --> 00:21:04,976
教授：让我们继续来看一看
PROFESSOR: OK, let's go ahead and

346
00:21:05,840 --> 00:21:08,448
这个查询语言及其操作
take a look at this query language and operation.

347
00:21:10,520 --> 00:21:11,840
首先需要注意到
The first thing you might notice,

348
00:21:12,240 --> 00:21:14,144
当我建立好那个小型的圣经数据库后
when I put up that little biblical database,

349
00:21:14,160 --> 00:21:17,240
我们就能够针对一系列的事实
is that it's nice to be able to ask this language questions

350
00:21:17,488 --> 00:21:19,920
以关系的方式来向这个语言提问
in relation to some collection of facts.

351
00:21:21,330 --> 00:21:25,152
因此 我们先来陈述一些事实
So let's start off and make a little collection of facts.

352
00:21:26,060 --> 00:21:29,680
这是波士顿一家高科技公司的
This is a tiny fragment of personnel records

353
00:21:30,080 --> 00:21:32,624
一小部分人事档案
for a Boston high tech company,

354
00:21:33,056 --> 00:21:36,800
这部分档案是Ben Bitdiddle的
and here's a piece of the personnel records of Ben Bitdiddle.

355
00:21:37,500 --> 00:21:41,952
Bitdiddle是这家公司的计算机向导
And Ben Bitdiddle is the computer wizard in this company,

356
00:21:42,848 --> 00:21:45,808
他是这家公司的低薪向导
he's the underpaid computer wizard in this company.

357
00:21:46,420 --> 00:21:48,784
他的上司是Oliver Warbucks
His supervisor is all Oliver Warbucks,

358
00:21:49,280 --> 00:21:50,704
这里是他的住址
and here's his address.

359
00:21:52,150 --> 00:21:56,544
我们按照这样的格式给出信息：职务、薪水、上司、住址
So the format is we're giving this information: job, salary, supervisor, address.

360
00:21:57,568 --> 00:21:59,250
还有一些其它的约定
And there are some other conventions.

361
00:21:59,250 --> 00:22:02,224
这里的COMPUTER表示BEN在计算机分部工作
Computer here means that Ben works in the computer division, and

362
00:22:02,768 --> 00:22:04,944
而他在这个分部的工作是向导
his position in the computer division is wizard.

363
00:22:05,660 --> 00:22:07,152
这里是其他人的
Here's somebody else.

364
00:22:07,168 --> 00:22:12,280
ALyssa P.Hacker是一名计算机程序员
Alyssa, Alyssa P. Hacker is a computer programmer,

365
00:22:13,360 --> 00:22:14,608
她的上司是Ben
and she works for Ben,

366
00:22:15,216 --> 00:22:16,544
而她住在Cambridge
and she lives in Cambridge.

367
00:22:17,550 --> 00:22:19,424
Ben手下的另外一个程序员
And there's another programmer who works for Ben

368
00:22:20,032 --> 00:22:21,440
叫做Lem E. Tweakit
who's Lem E. Tweakit.

369
00:22:22,820 --> 00:22:26,736
实习程序员 Louis Reasoner
And there's a programmer trainee, who is Louis Reasoner,

370
00:22:27,424 --> 00:22:28,624
在Alyssa手下工作
and he works for Alyssa.

371
00:22:30,100 --> 00:22:35,456
公司里的“老大哥”不为任何人工作
And the big wheel of the company doesn't work for anybody.

372
00:22:36,816 --> 00:22:38,110
这就是Oliver Warbucks的档案了
Right, That's Oliver Warbucks.

373
00:22:38,110 --> 00:22:39,312
我们将要做的就是
Anyway, what we're going to do is

374
00:22:40,944 --> 00:22:43,664
对这个小型的世界提问
is ask questions about that little world.

375
00:22:44,970 --> 00:22:48,400
这将是我们进行逻辑运算的样本世界
And that'll be a sample world that we're going to do logic in.

376
00:22:51,420 --> 00:22:54,960
我再最后一次强调一下
Let me just write up here, for probably the last time,

377
00:22:55,600 --> 00:22:58,208
你们应该从这门课中学到的最重要的知识
what I said is the very most important thing you should get out of this course,

378
00:22:58,800 --> 00:23:01,664
也就是 当别人向你介绍语言时
and that is, when somebody tells you about a language,

379
00:23:02,256 --> 00:23:04,432
你要问：“它的基本元素是什么？”
you say, fine-- what are the primitives,

380
00:23:06,120 --> 00:23:07,790
组合的手段有哪些？
what are the means of combination,

381
00:23:14,704 --> 00:23:16,400
如何把基本元素组织在一起
how do you put the primitives together,

382
00:23:16,672 --> 00:23:19,376
然后把它们抽象出来？and then how do you abstract them,

383
00:23:19,968 --> 00:23:21,936
如何抽象这些复合元素
how do you abstract the compound pieces

384
00:23:24,688 --> 00:23:27,584
以便于你能够复用它们构造更复杂的东西？
so you can use them as pieces to make something more complicated?

385
00:23:29,024 --> 00:23:30,816
我已经强调过很多次了
And we've said this a whole bunch of times already,

386
00:23:31,168 --> 00:23:32,480
但还是值得重申一遍
but it's worth saying again.

387
00:23:35,008 --> 00:23:36,670
记住了么？我们开始了
OKay? Let's start.

388
00:23:36,670 --> 00:23:37,344
首先是基本元素
The primitives.

389
00:23:37,776 --> 00:23:39,440
这其中 只有唯一的基本元素
Well, there's really only one primitive,

390
00:23:40,960 --> 00:23:43,200
这门语言中的基本元素就是“查询”
and the primitive in this language is called a query.

391
00:23:44,144 --> 00:23:45,744
一条基本查询
A primitive query.

392
00:23:46,810 --> 00:23:48,256
我们先来看几条基本查询
Let's look at some primitive queries.

393
00:23:51,824 --> 00:23:53,024
首先 这条查询问的是
Alright. Job x.

394
00:23:53,100 --> 00:23:54,816
“谁是计算机程序员？”
Who is a computer programmer?

395
00:23:55,550 --> 00:23:59,888
或者可以解释为：找出数据库中
Or find every fact in the database

396
00:24:01,552 --> 00:24:06,144
所有JOB栏为COMPUTER PROGRAMMER的事实
that matches job of the x is computer programmer.

397
00:24:06,640 --> 00:24:08,016
这里有一些小语法
And you see a little syntax here.

398
00:24:08,470 --> 00:24:10,592
不带问号的都是字面量
Things without question marks are meant to be literal,

399
00:24:11,280 --> 00:24:13,152
?X表示X是变量
question mark x means that's a variable,

400
00:24:13,312 --> 00:24:15,568
而这条查询会匹配 比如说 --
and this thing will match, for example,

401
00:24:16,032 --> 00:24:19,008
Alyssa P. Hacker 是程序员
the fact that Alyssa P. Hacker is a computer programmer,

402
00:24:19,280 --> 00:24:21,930
其中X为Alyssa P. Hacker这条事实
or x is Alyssa P. Hacker.

403
00:24:26,820 --> 00:24:29,984
Or more generally, I could have something with two variables in it.

404
00:24:30,750 --> 00:24:31,456
I could say, the job of x is computer something, and that'll match computer wizard.

405
00:24:31,600 --> 00:24:35,888
I could say, the job of x is computer something, and that'll match computer wizard.

406
00:24:39,344 --> 00:24:41,392
I could say, the job of x is computer something, and that'll match computer wizard.

407
00:24:42,140 --> 00:24:44,288
So there's something here: type will match wizard, or type will match programmer, or x might match various certain things.

408
00:24:44,928 --> 00:24:46,464
So there's something here: type will match wizard, or type will match programmer, or x might match various certain things.

409
00:24:47,488 --> 00:24:50,370
So there's something here: type will match wizard, or type will match programmer, or x might match various certain things.

410
00:24:50,370 --> 00:24:52,240
So there are, in our little example, only three facts in that database that match that query.

411
00:24:52,256 --> 00:24:55,150
So there are, in our little example, only three facts in that database that match that query.

412
00:24:59,210 --> 00:25:00,736
Let's see, just to show you some syntax, the same query, this query doesn't match the job of x, doesn't match Lewis Reasoner, the reason for that is when I write something here, what I mean is that this is going to be a list of two symbols, of which the first is the word computer, and the second can be anything.

413
00:25:00,960 --> 00:25:02,080
Let's see, just to show you some syntax, the same query, this query doesn't match the job of x, doesn't match Lewis Reasoner, the reason for that is when I write something here, what I mean is that this is going to be a list of two symbols, of which the first is the word computer, and the second can be anything.

414
00:25:05,296 --> 00:25:08,096
Let's see, just to show you some syntax, the same query, this query doesn't match the job of x, doesn't match Lewis Reasoner, the reason for that is when I write something here, what I mean is that this is going to be a list of two symbols, of which the first is the word computer, and the second can be anything.

415
00:25:09,856 --> 00:25:11,792
Let's see, just to show you some syntax, the same query, this query doesn't match the job of x, doesn't match Lewis Reasoner, the reason for that is when I write something here, what I mean is that this is going to be a list of two symbols, of which the first is the word computer, and the second can be anything.

416
00:25:11,840 --> 00:25:13,648
Let's see, just to show you some syntax, the same query, this query doesn't match the job of x, doesn't match Lewis Reasoner, the reason for that is when I write something here, what I mean is that this is going to be a list of two symbols, of which the first is the word computer, and the second can be anything.

417
00:25:14,224 --> 00:25:17,744
Let's see, just to show you some syntax, the same query, this query doesn't match the job of x, doesn't match Lewis Reasoner, the reason for that is when I write something here, what I mean is that this is going to be a list of two symbols, of which the first is the word computer, and the second can be anything.

418
00:25:19,968 --> 00:25:21,968
Let's see, just to show you some syntax, the same query, this query doesn't match the job of x, doesn't match Lewis Reasoner, the reason for that is when I write something here, what I mean is that this is going to be a list of two symbols, of which the first is the word computer, and the second can be anything.

419
00:25:22,320 --> 00:25:23,808
Let's see, just to show you some syntax, the same query, this query doesn't match the job of x, doesn't match Lewis Reasoner, the reason for that is when I write something here, what I mean is that this is going to be a list of two symbols, of which the first is the word computer, and the second can be anything.

420
00:25:25,080 --> 00:25:27,320
And Lewis's job description here has three symbols, so it doesn't match.

421
00:25:27,808 --> 00:25:28,832
And Lewis's job description here has three symbols, so it doesn't match.

422
00:25:30,340 --> 00:25:32,192
And just to show you a little bit of syntax, the more general thing I might want to type is a thing with a dot here, and this is just standard this notation for saying, this is a list, of which the first element is the word computers, and THE REST, is something that I'll call type.

423
00:25:35,040 --> 00:25:36,576
And just to show you a little bit of syntax, the more general thing I might want to type is a thing with a dot here, and this is just standard this notation for saying, this is a list, of which the first element is the word computers, and THE REST, is something that I'll call type.

424
00:25:36,960 --> 00:25:38,224
And just to show you a little bit of syntax, the more general thing I might want to type is a thing with a dot here, and this is just standard this notation for saying, this is a list, of which the first element is the word computers, and THE REST, is something that I'll call type.

425
00:25:40,176 --> 00:25:42,928
And just to show you a little bit of syntax, the more general thing I might want to type is a thing with a dot here, and this is just standard this notation for saying, this is a list, of which the first element is the word computers, and THE REST, is something that I'll call type.

426
00:25:43,040 --> 00:25:47,328
And just to show you a little bit of syntax, the more general thing I might want to type is a thing with a dot here, and this is just standard this notation for saying, this is a list, of which the first element is the word computers, and THE REST, is something that I'll call type.

427
00:25:47,584 --> 00:25:50,224
And just to show you a little bit of syntax, the more general thing I might want to type is a thing with a dot here, and this is just standard this notation for saying, this is a list, of which the first element is the word computers, and THE REST, is something that I'll call type.

428
00:25:53,730 --> 00:25:55,504
So this one would match.

429
00:25:56,930 --> 00:25:59,312
Lewis's job is computer programmer trainee, and type here would be the cdr of this list. It would be the list programmer trainee.

430
00:25:59,440 --> 00:26:03,296
Lewis's job is computer programmer trainee, and type here would be the cdr of this list. It would be the list programmer trainee.

431
00:26:03,328 --> 00:26:05,648
Lewis's job is computer programmer trainee, and type here would be the cdr of this list. It would be the list programmer trainee.

432
00:26:06,960 --> 00:26:10,460
And that kind of dot processing is done automatically by the LISP reader.

433
00:26:15,900 --> 00:26:17,760
Well, let's actually try this.

434
00:26:17,760 --> 00:26:20,512
The idea is I'm going to type in queries in this language, and answers will come out.

435
00:26:20,768 --> 00:26:21,824
The idea is I'm going to type in queries in this language, and answers will come out.

436
00:26:22,544 --> 00:26:24,480
Let's look at this.

437
00:26:25,180 --> 00:26:26,512
I can go up and say, who works in the computer division?

438
00:26:27,344 --> 00:26:28,880
I can go up and say, who works in the computer division?

439
00:26:30,000 --> 00:26:38,224
Job of x is computer dot y.

440
00:26:39,730 --> 00:26:41,488
Doesn't matter what I call the dummy variables.

441
00:26:42,768 --> 00:26:44,144
It says the answers to that, and it's found four answers.

442
00:26:44,416 --> 00:26:45,680
It says the answers to that, and it's found four answers.

443
00:26:48,650 --> 00:26:50,096
Or I can go off and say, tell me about everybody's supervisor.

444
00:26:50,560 --> 00:26:52,384
Or I can go off and say, tell me about everybody's supervisor.

445
00:26:52,816 --> 00:26:54,880
So I'll put in the query, the primitive query, the supervisor of x is y.

446
00:26:56,528 --> 00:26:59,390
So I'll put in the query, the primitive query, the supervisor of x is y.

447
00:27:02,560 --> 00:27:05,424
There are all the supervisor relationships I know.

448
00:27:05,540 --> 00:27:08,830
Or I could go type in, who lives in Cambridge?

449
00:27:08,830 --> 00:27:09,472
So I can say, the address of x is Cambridge dot anything.

450
00:27:10,240 --> 00:27:20,928
So I can say, the address of x is Cambridge dot anything.

451
00:27:25,090 --> 00:27:26,896
And only one person lives in Cambridge.

452
00:27:30,820 --> 00:27:32,170
OK, so those are primitive queries.

453
00:27:32,170 --> 00:27:34,960
And you see what happens to basic interaction with the system is you type in a query, and it types out all possible answers.

454
00:27:35,296 --> 00:27:39,248
And you see what happens to basic interaction with the system is you type in a query, and it types out all possible answers.

455
00:27:39,620 --> 00:27:40,656
Or another way to say that: it finds out all the possible values of those variables x and y or t or whatever I've called them, and it types out all ways of taking that query and instantiating it-- remember that from the rule system lecture-- instantiates the query with all possible values for those variables and then types out all of them.

456
00:27:40,672 --> 00:27:45,984
Or another way to say that: it finds out all the possible values of those variables x and y or t or whatever I've called them, and it types out all ways of taking that query and instantiating it-- remember that from the rule system lecture-- instantiates the query with all possible values for those variables and then types out all of them.

457
00:27:46,096 --> 00:27:52,080
Or another way to say that: it finds out all the possible values of those variables x and y or t or whatever I've called them, and it types out all ways of taking that query and instantiating it-- remember that from the rule system lecture-- instantiates the query with all possible values for those variables and then types out all of them.

458
00:27:52,928 --> 00:27:55,056
Or another way to say that: it finds out all the possible values of those variables x and y or t or whatever I've called them, and it types out all ways of taking that query and instantiating it-- remember that from the rule system lecture-- instantiates the query with all possible values for those variables and then types out all of them.

459
00:27:55,080 --> 00:27:58,830
Or another way to say that: it finds out all the possible values of those variables x and y or t or whatever I've called them, and it types out all ways of taking that query and instantiating it-- remember that from the rule system lecture-- instantiates the query with all possible values for those variables and then types out all of them.

460
00:27:59,008 --> 00:28:00,352
Or another way to say that: it finds out all the possible values of those variables x and y or t or whatever I've called them, and it types out all ways of taking that query and instantiating it-- remember that from the rule system lecture-- instantiates the query with all possible values for those variables and then types out all of them.

461
00:28:01,000 --> 00:28:03,350
And there are a lot of ways you can arrange a logic language.

462
00:28:03,350 --> 00:28:06,010
Prolog, for instance, does something slightly different.

463
00:28:06,010 --> 00:28:07,440
Rather than typing back your query, prolog would type out, x equals this and y equals that, or x sequels this and y equals that.

464
00:28:07,760 --> 00:28:10,784
Rather than typing back your query, prolog would type out, x equals this and y equals that, or x sequels this and y equals that.

465
00:28:10,976 --> 00:28:12,944
Rather than typing back your query, prolog would type out, x equals this and y equals that, or x sequels this and y equals that.

466
00:28:13,660 --> 00:28:15,488
And that's a very surface level thing, you can decide what you like.

467
00:28:15,712 --> 00:28:17,050
And that's a very surface level thing, you can decide what you like.

468
00:28:18,976 --> 00:28:19,584
OK.

469
00:28:21,008 --> 00:28:22,688
Alright. So the primitives in this language?

470
00:28:23,390 --> 00:28:24,570
Only one, right?

471
00:28:24,570 --> 00:28:27,230
Primitive query.

472
00:28:31,312 --> 00:28:32,560
Means of combination.

473
00:28:34,330 --> 00:28:37,680
Let's look at some compound queries in this language.

474
00:28:39,770 --> 00:28:40,464
Here's one.

475
00:28:41,790 --> 00:28:42,512
This one says, tell me all the people who work in the computer division.

476
00:28:45,056 --> 00:28:48,224
This one says, tell me all the people who work in the computer division.

477
00:28:49,810 --> 00:28:53,968
Tell me all the people who work in the computer division together with their supervisors.

478
00:28:56,800 --> 00:28:58,832
The way I write that is the query is and.

479
00:29:00,220 --> 00:29:04,064
And the job of the x is computer something or other.

480
00:29:04,920 --> 00:29:06,832
And job of x is computer dot y.

481
00:29:07,560 --> 00:29:10,032
And the supervisor of x is z.

482
00:29:11,440 --> 00:29:14,160
Tell me all the people in the computer division-- that's this-- together with their supervisors.

483
00:29:14,304 --> 00:29:15,888
Tell me all the people in the computer division-- that's this-- together with their supervisors.

484
00:29:16,460 --> 00:29:17,824
And notice in this query I have three variables-- x, y, and z.

485
00:29:18,672 --> 00:29:22,416
And notice in this query I have three variables-- x, y, and z.

486
00:29:23,660 --> 00:29:25,200
And this x is supposed to be the same as that x.

487
00:29:26,992 --> 00:29:28,656
And this x is supposed to be the same as that x.

488
00:29:29,450 --> 00:29:31,168
So x works in the computer division, and the supervisor of x is z.

489
00:29:31,312 --> 00:29:33,008
So x works in the computer division, and the supervisor of x is z.

490
00:29:34,810 --> 00:29:35,808
Let's try another one.

491
00:29:37,250 --> 00:29:39,280
So one means of combination is and.

492
00:29:41,440 --> 00:29:43,968
Who are all the people who make more than $30,000?

493
00:29:45,712 --> 00:29:51,712
And the salary of some person p is some amount a.

494
00:29:54,590 --> 00:29:57,456
And when I go and look at a, a is greater than $30,000.

495
00:29:57,488 --> 00:30:00,128
And when I go and look at a, a is greater than $30,000.

496
00:30:00,600 --> 00:30:03,232
And LISP value here is a little piece of interface that interfaces the query language to the underlying LISP.

497
00:30:04,304 --> 00:30:10,048
And LISP value here is a little piece of interface that interfaces the query language to the underlying LISP.

498
00:30:10,600 --> 00:30:12,720
And what the LISP value allows you to do is call any LISP predicate inside a query.

499
00:30:12,752 --> 00:30:16,912
And what the LISP value allows you to do is call any LISP predicate inside a query.

500
00:30:17,180 --> 00:30:20,112
So here I'm using the LISP predicate greater than, so I say LISP value.

501
00:30:21,020 --> 00:30:21,750
This I say and.

502
00:30:21,750 --> 00:30:24,480
So all the people whose salary is greater than $30,000.

503
00:30:28,190 --> 00:30:30,032
Or here's a more complicated one.

504
00:30:31,270 --> 00:30:35,024
Tell me all the people who work in the computer division who do not have a supervisor who works in the computer division.

505
00:30:36,256 --> 00:30:39,360
Tell me all the people who work in the computer division who do not have a supervisor who works in the computer division.

506
00:30:42,790 --> 00:30:45,510
and x works in the computer division.

507
00:30:45,510 --> 00:30:47,328
The job of x is computer dot y.

508
00:30:47,780 --> 00:30:49,248
And it's not the case that both x has a supervisor z and the job of z is computer something or other.

509
00:30:50,496 --> 00:30:54,256
And it's not the case that both x has a supervisor z and the job of z is computer something or other.

510
00:30:55,376 --> 00:30:57,872
And it's not the case that both x has a supervisor z and the job of z is computer something or other.

511
00:30:59,620 --> 00:31:00,352
All right, so again, this x has got to be that x, and this z is going to be that z.

512
00:31:00,512 --> 00:31:02,384
All right, so again, this x has got to be that x, and this z is going to be that z.

513
00:31:03,200 --> 00:31:05,760
All right, so again, this x has got to be that x, and this z is going to be that z.

514
00:31:09,390 --> 00:31:11,380
And then you see another means a combination, not.

515
00:31:17,712 --> 00:31:18,672
All right, well, let's look at that.

516
00:31:20,880 --> 00:31:22,080
It works the same way.

517
00:31:22,400 --> 00:31:24,128
I can go up to the machine and say and the job of the x is computer dot y.

518
00:31:26,896 --> 00:31:35,400
I can go up to the machine and say and the job of the x is computer dot y.

519
00:31:38,848 --> 00:31:45,952
And the supervisor of x is z.

520
00:31:46,832 --> 00:31:49,536
And I typed that in like a query.

521
00:31:51,072 --> 00:31:52,976
And what it types back, what you see are the queries I typed in instantiated by all possible answers.

522
00:31:54,000 --> 00:31:57,072
And what it types back, what you see are the queries I typed in instantiated by all possible answers.

523
00:31:57,344 --> 00:31:58,704
And what it types back, what you see are the queries I typed in instantiated by all possible answers.

524
00:31:58,930 --> 00:32:00,080
And then you see there are a lot of answers.

525
00:32:01,696 --> 00:32:02,144
All right.

526
00:32:02,190 --> 00:32:04,048
So the means of combination in this language-- and this is why it's called a logic language-- are logical operations.

527
00:32:05,216 --> 00:32:06,608
So the means of combination in this language-- and this is why it's called a logic language-- are logical operations.

528
00:32:06,640 --> 00:32:09,472
So the means of combination in this language-- and this is why it's called a logic language-- are logical operations.

529
00:32:09,800 --> 00:32:11,536
Means of combinations are things like AND and NOT and there's one I didn't show you, which is OR.

530
00:32:12,848 --> 00:32:17,920
Means of combinations are things like AND and NOT and there's one I didn't show you, which is OR.

531
00:32:18,490 --> 00:32:20,368
And then I showed you LISP value, which is not logic, of course, but is a little special hack to interface that to LISP so you can get more power.

532
00:32:20,720 --> 00:32:26,880
And then I showed you LISP value, which is not logic, of course, but is a little special hack to interface that to LISP so you can get more power.

533
00:32:27,344 --> 00:32:28,752
And then I showed you LISP value, which is not logic, of course, but is a little special hack to interface that to LISP so you can get more power.

534
00:32:29,250 --> 00:32:30,672
Those are the means of combination.

535
00:32:32,592 --> 00:32:33,984
OK, the means of abstraction.

536
00:32:34,160 --> 00:32:35,216
What we'd like to do--  let's go back for second and look at that last slide.

537
00:32:38,272 --> 00:32:41,248
What we'd like to do--  let's go back for second and look at that last slide.

538
00:32:42,260 --> 00:32:44,256
We might like to take very complicated thing, the idea that someone works in a division but does not have a supervisor in the division.

539
00:32:44,464 --> 00:32:45,360
We might like to take very complicated thing, the idea that someone works in a division but does not have a supervisor in the division.

540
00:32:45,840 --> 00:32:50,096
We might like to take very complicated thing, the idea that someone works in a division but does not have a supervisor in the division.

541
00:32:52,400 --> 00:32:55,104
And as before, name that.

542
00:32:56,090 --> 00:33:00,256
Well, if someone works in a division and does not have a supervisor who works in that division, that means that person is a big shot.

543
00:33:00,480 --> 00:33:01,936
Well, if someone works in a division and does not have a supervisor who works in that division, that means that person is a big shot.

544
00:33:02,750 --> 00:33:05,136
So let's make a rule that somebody x is a big shot in some department if x works in the department and it's not the case that x has a supervisor who works in the department.

545
00:33:06,432 --> 00:33:09,168
So let's make a rule that somebody x is a big shot in some department if x works in the department and it's not the case that x has a supervisor who works in the department.

546
00:33:10,912 --> 00:33:14,688
So let's make a rule that somebody x is a big shot in some department if x works in the department and it's not the case that x has a supervisor who works in the department.

547
00:33:16,048 --> 00:33:20,080
So let's make a rule that somebody x is a big shot in some department if x works in the department and it's not the case that x has a supervisor who works in the department.

548
00:33:21,510 --> 00:33:22,940
So this is our means of abstraction.

549
00:33:22,940 --> 00:33:23,904
This is a rule.

550
00:33:26,220 --> 00:33:27,580
And a rule has three parts.

551
00:33:31,008 --> 00:33:32,480
The thing that says it's a rule.

552
00:33:33,408 --> 00:33:35,488
And then there's the conclusion of the rule.

553
00:33:37,530 --> 00:33:39,072
And then there's the body of the rule.

554
00:33:40,000 --> 00:33:45,152
And you can read this as a piece of logic which says, if you know that the body of the rule is true, then you can conclude that the conclusion is true.

555
00:33:46,400 --> 00:33:48,720
And you can read this as a piece of logic which says, if you know that the body of the rule is true, then you can conclude that the conclusion is true.

556
00:33:49,470 --> 00:33:51,280
Or in order to deduce that x is a big shot in some department, it's enough to verify that.

557
00:33:51,328 --> 00:33:53,280
Or in order to deduce that x is a big shot in some department, it's enough to verify that.

558
00:33:53,792 --> 00:33:55,712
Or in order to deduce that x is a big shot in some department, it's enough to verify that.

559
00:33:57,480 --> 00:33:58,820
So that's what rules look like.

560
00:34:03,280 --> 00:34:06,128
Let's go back and look at that merge example that I did before the break.

561
00:34:06,688 --> 00:34:07,952
Let's go back and look at that merge example that I did before the break.

562
00:34:08,110 --> 00:34:10,688
Let's look at how that would look in terms of rules.

563
00:34:11,440 --> 00:34:12,848
I'm going to take the logic I put up and just change it into a bunch of rules in this format.

564
00:34:13,088 --> 00:34:15,500
I'm going to take the logic I put up and just change it into a bunch of rules in this format.

565
00:34:18,739 --> 00:34:19,350
We have a rule.

566
00:34:19,350 --> 00:34:20,960
Remember, there was this thing merge-to-form.

567
00:34:21,710 --> 00:34:22,976
There is a rule that says, the empty list and y merge to form y.

568
00:34:26,288 --> 00:34:29,620
There is a rule that says, the empty list and y merge to form y.

569
00:34:29,620 --> 00:34:30,870
This is the rule conclusion.

570
00:34:33,210 --> 00:34:35,744
And notice this particular rule has no body.

571
00:34:36,650 --> 00:34:37,664
And in this language, a rule with no body is something that is always true.

572
00:34:38,112 --> 00:34:40,864
And in this language, a rule with no body is something that is always true.

573
00:34:41,239 --> 00:34:42,510
You can always assume that's true.

574
00:34:45,190 --> 00:34:46,496
And there was another piece of logic that said anything in the empty list merged to form the anything.

575
00:34:46,640 --> 00:34:49,460
And there was another piece of logic that said anything in the empty list merged to form the anything.

576
00:34:49,460 --> 00:34:50,128
That's this.

577
00:34:50,900 --> 00:34:53,552
A rule y and the empty list merge to form y.

578
00:34:55,510 --> 00:34:58,400
Those corresponded to the two end cases in our merge procedure, but now we're talking about logic, not about procedures.

579
00:34:58,448 --> 00:34:59,776
Those corresponded to the two end cases in our merge procedure, but now we're talking about logic, not about procedures.

580
00:35:00,416 --> 00:35:01,456
Those corresponded to the two end cases in our merge procedure, but now we're talking about logic, not about procedures.

581
00:35:03,490 --> 00:35:04,480
Then we had another rule, which said if you know how shorter things merge, you can put them together.

582
00:35:04,832 --> 00:35:08,736
Then we had another rule, which said if you know how shorter things merge, you can put them together.

583
00:35:08,912 --> 00:35:09,830
Then we had another rule, which said if you know how shorter things merge, you can put them together.

584
00:35:09,830 --> 00:35:14,160
So this says, if you have a list x and y and z, and if you want to deduce that a dot x-- this means constant a onto x, or a list whose first thing is a and whose rest is x-- so if you want to deduce that a dot x and b dot y merge to form b dot c--  that would say you merge these two lists a x and b y and you're going to get something that starts with b-- you can deduce that if you know that it's the case both that a dot x and y merge to form z and a is larger than b.

585
00:35:14,928 --> 00:35:17,616
So this says, if you have a list x and y and z, and if you want to deduce that a dot x-- this means constant a onto x, or a list whose first thing is a and whose rest is x-- so if you want to deduce that a dot x and b dot y merge to form b dot c--  that would say you merge these two lists a x and b y and you're going to get something that starts with b-- you can deduce that if you know that it's the case both that a dot x and y merge to form z and a is larger than b.

586
00:35:17,632 --> 00:35:19,088
So this says, if you have a list x and y and z, and if you want to deduce that a dot x-- this means constant a onto x, or a list whose first thing is a and whose rest is x-- so if you want to deduce that a dot x and b dot y merge to form b dot c--  that would say you merge these two lists a x and b y and you're going to get something that starts with b-- you can deduce that if you know that it's the case both that a dot x and y merge to form z and a is larger than b.

587
00:35:19,488 --> 00:35:22,368
So this says, if you have a list x and y and z, and if you want to deduce that a dot x-- this means constant a onto x, or a list whose first thing is a and whose rest is x-- so if you want to deduce that a dot x and b dot y merge to form b dot c--  that would say you merge these two lists a x and b y and you're going to get something that starts with b-- you can deduce that if you know that it's the case both that a dot x and y merge to form z and a is larger than b.

588
00:35:23,168 --> 00:35:27,408
So this says, if you have a list x and y and z, and if you want to deduce that a dot x-- this means constant a onto x, or a list whose first thing is a and whose rest is x-- so if you want to deduce that a dot x and b dot y merge to form b dot c--  that would say you merge these two lists a x and b y and you're going to get something that starts with b-- you can deduce that if you know that it's the case both that a dot x and y merge to form z and a is larger than b.

589
00:35:48,690 --> 00:35:50,592
So when I merge them, b will come first in the list. That's a little translation of the logic rule that I wrote in pseudo-English before.

590
00:35:51,824 --> 00:35:54,912
So when I merge them, b will come first in the list. That's a little translation of the logic rule that I wrote in pseudo-English before.

591
00:35:55,248 --> 00:35:57,184
So when I merge them, b will come first in the list. That's a little translation of the logic rule that I wrote in pseudo-English before.

592
00:35:57,960 --> 00:36:00,256
And then just for completeness, here's the other case.

593
00:36:00,608 --> 00:36:01,660
And then just for completeness, here's the other case.

594
00:36:02,880 --> 00:36:05,952
a dot x and b dot y merge to form a dot z if x and b dot y merged to form z and b is larger than a.

595
00:36:06,080 --> 00:36:09,168
a dot x and b dot y merge to form a dot z if x and b dot y merged to form z and b is larger than a.

596
00:36:09,472 --> 00:36:11,008
a dot x and b dot y merge to form a dot z if x and b dot y merged to form z and b is larger than a.

597
00:36:12,190 --> 00:36:14,096
So that's a little program that I've typed in in this language, and now let's look at it run.

598
00:36:14,240 --> 00:36:17,072
So that's a little program that I've typed in in this language, and now let's look at it run.

599
00:36:21,900 --> 00:36:23,904
So I typed in the merge rules before, and I could use this like a procedure.

600
00:36:24,624 --> 00:36:25,776
So I typed in the merge rules before, and I could use this like a procedure.

601
00:36:27,040 --> 00:36:28,510
So I typed in the merge rules before, and I could use this like a procedure.

602
00:36:28,510 --> 00:36:38,240
I could say merge to form 1 and 3 and 2 and 7.

603
00:36:39,424 --> 00:36:41,552
So here I'm using it like the LISP procedure.

604
00:36:43,168 --> 00:36:44,976
Now it's going to think about that for a while and apply these rules.

605
00:36:46,432 --> 00:36:47,568
Now it's going to think about that for a while and apply these rules.

606
00:36:50,780 --> 00:36:51,920
So it found an answer.

607
00:36:52,800 --> 00:36:54,544
Now it's going to see if there are any other answers but it doesn't know a priori there's only one answer.

608
00:36:55,072 --> 00:36:57,328
Now it's going to see if there are any other answers but it doesn't know a priori there's only one answer.

609
00:36:57,810 --> 00:36:59,904
So it's sitting here checking all possibilities, and it says, no more.

610
00:37:00,416 --> 00:37:02,544
So it's sitting here checking all possibilities, and it says, no more. Done.

611
00:37:03,168 --> 00:37:05,072
So there I've used those rules like a procedure.

612
00:37:05,210 --> 00:37:09,056
Or remember the whole point is that I can ask different kinds of questions.

613
00:37:10,220 --> 00:37:11,072
I could say merge to form, let's see, how about 2 and a.

614
00:37:18,560 --> 00:37:24,590
I could say merge to form, let's see, how about 2 and a.

615
00:37:24,590 --> 00:37:25,952
Some list of two elements which I know starts with 2, and the other thing I don't know, and x and some other list merge to form a 1, 2, 3 and 4.

616
00:37:26,336 --> 00:37:27,840
Some list of two elements which I know starts with 2, and the other thing I don't know, and x and some other list merge to form a 1, 2, 3 and 4.

617
00:37:29,376 --> 00:37:31,264
Some list of two elements which I know starts with 2, and the other thing I don't know, and x and some other list merge to form a 1, 2, 3 and 4.

618
00:37:33,056 --> 00:37:35,040
Some list of two elements which I know starts with 2, and the other thing I don't know, and x and some other list merge to form a 1, 2, 3 and 4.

619
00:37:36,480 --> 00:37:39,510
Some list of two elements which I know starts with 2, and the other thing I don't know, and x and some other list merge to form a 1, 2, 3 and 4.

620
00:37:42,760 --> 00:37:44,112
So now it's going to think about that.

621
00:37:44,590 --> 00:37:49,408
It's got to find--  so it found one possibility.

622
00:37:49,520 --> 00:37:52,464
It said a could be 3, and x could be the list 1, 4.

623
00:37:53,830 --> 00:37:55,152
And now, again, it's got to check because it doesn't a priori know that there aren't any other possibilities going on.

624
00:37:56,496 --> 00:38:00,304
And now, again, it's got to check because it doesn't a priori know that there aren't any other possibilities going on.

625
00:38:03,680 --> 00:38:06,576
Or like I said, I could say something like merge to form, like, what and what else merge to form 1, 2, 3, 4, 5?

626
00:38:07,008 --> 00:38:09,840
Or like I said, I could say something like merge to form, like, what and what else merge to form 1, 2, 3, 4, 5?

627
00:38:10,544 --> 00:38:17,552
Or like I said, I could say something like merge to form, like, what and what else merge to form 1, 2, 3, 4, 5?

628
00:38:23,680 --> 00:38:25,536
Now it's going to think about that.

629
00:38:28,490 --> 00:38:30,310
And there are a lot of answers that it might get.

630
00:38:35,180 --> 00:38:38,576
And what you see is here you're really paying the price of slowness.

631
00:38:42,210 --> 00:38:43,880
And kind of for three reasons.

632
00:38:43,880 --> 00:38:46,224
One is that this language is doubly interpreted.

633
00:38:47,630 --> 00:38:49,728
Whereas in a real implementation, you would go compile this down to primitive operations.

634
00:38:49,760 --> 00:38:52,048
Whereas in a real implementation, you would go compile this down to primitive operations.

635
00:38:52,190 --> 00:38:53,872
The other reason is that this particular algorithm for merges is doubly recursive.

636
00:38:53,888 --> 00:38:58,112
The other reason is that this particular algorithm for merges is doubly recursive.

637
00:38:58,380 --> 00:39:00,064
So it's going to take a very long time.

638
00:39:01,020 --> 00:39:07,130
And eventually, this is going to go through and find-- find what?

639
00:39:07,130 --> 00:39:08,730
Two to the fifth possible answers.

640
00:39:12,140 --> 00:39:14,960
And you see they come out in some fairly arbitrary order, depending on which order it's going to be trying these rules.

641
00:39:15,008 --> 00:39:18,144
And you see they come out in some fairly arbitrary order, depending on which order it's going to be trying these rules.

642
00:39:20,160 --> 00:39:22,240
In fact, what we're going to do when they edit the videotape is speed all this up.

643
00:39:22,448 --> 00:39:23,440
In fact, what we're going to do when they edit the videotape is speed all this up.

644
00:39:24,080 --> 00:39:26,600
Don't you like taking out these weights?

645
00:39:26,600 --> 00:39:28,272
And don't you wish you could do that in your demos?

646
00:39:29,488 --> 00:39:34,240
Anyway, it's still grinding there.

647
00:39:39,220 --> 00:39:41,120
Anyway, there are 32 possibilities-- we won't wait for it to print out all of them.

648
00:39:41,136 --> 00:39:42,630
Anyway, there are 32 possibilities-- we won't wait for it to print out all of them.

649
00:39:47,850 --> 00:39:50,448
OK, so the needs of abstraction in this language are rules.

650
00:39:53,536 --> 00:39:58,016
So we take some bunch of things that are put together with logic and we name them.

651
00:39:59,120 --> 00:40:00,080
So we take some bunch of things that are put together with logic and we name them.

652
00:40:00,350 --> 00:40:03,410
And you can think of that as naming a particular pattern of logic.

653
00:40:03,410 --> 00:40:06,752
Or you can think of that as saying, if you want to deduce some conclusion, you can apply those rules of logic.

654
00:40:07,904 --> 00:40:09,520
Or you can think of that as saying, if you want to deduce some conclusion, you can apply those rules of logic.

655
00:40:10,660 --> 00:40:13,200
And those are three elements of this language.

656
00:40:13,420 --> 00:40:16,592
Let's break now, and then we'll talk about how it's actually implemented.

657
00:40:23,616 --> 00:40:28,848
STUDENT: Does using LISP value primitive or whatever interfere with your means to go both directions on a query?

658
00:40:29,152 --> 00:40:30,640
STUDENT: Does using LISP value primitive or whatever interfere with your means to go both directions on a query?

659
00:40:31,770 --> 00:40:34,480
PROFESSOR: OK, that's a-- the question is, does using LISP value interfere with the ability to go both directions on the query?

660
00:40:35,088 --> 00:40:36,928
PROFESSOR: OK, that's a-- the question is, does using LISP value interfere with the ability to go both directions on the query?

661
00:40:37,536 --> 00:40:40,090
PROFESSOR: OK, that's a-- the question is, does using LISP value interfere with the ability to go both directions on the query?

662
00:40:40,090 --> 00:40:42,816
We haven't really talked about the implementation yet, but the answer is, yes, it can.

663
00:40:43,680 --> 00:40:45,520
We haven't really talked about the implementation yet, but the answer is, yes, it can.

664
00:40:46,890 --> 00:40:52,176
In general, as we'll see at the end-- although I really won't to go into details-- it's fairly complicated, especially when you use either not or LISP value-- or actually, if you use anything besides only and, it becomes very complicated to say when these things will work.

665
00:40:53,216 --> 00:40:59,360
In general, as we'll see at the end-- although I really won't to go into details-- it's fairly complicated, especially when you use either not or LISP value-- or actually, if you use anything besides only and, it becomes very complicated to say when these things will work.

666
00:40:59,550 --> 00:41:02,890
In general, as we'll see at the end-- although I really won't to go into details-- it's fairly complicated, especially when you use either not or LISP value-- or actually, if you use anything besides only and, it becomes very complicated to say when these things will work.

667
00:41:04,096 --> 00:41:06,016
In general, as we'll see at the end-- although I really won't to go into details-- it's fairly complicated, especially when you use either not or LISP value-- or actually, if you use anything besides only and, it becomes very complicated to say when these things will work.

668
00:41:06,336 --> 00:41:08,480
In general, as we'll see at the end-- although I really won't to go into details-- it's fairly complicated, especially when you use either not or LISP value-- or actually, if you use anything besides only and, it becomes very complicated to say when these things will work.

669
00:41:08,700 --> 00:41:10,360
They won't work quite in all situations.

670
00:41:10,360 --> 00:41:13,392
I'll talk about that at the end of the second half today.

671
00:41:14,300 --> 00:41:15,840
But the answer to your question is, yes, by dragging in a lot more power from LISP value, you lose some of the principal power of logic programming.

672
00:41:16,192 --> 00:41:19,216
But the answer to your question is, yes, by dragging in a lot more power from LISP value, you lose some of the principal power of logic programming.

673
00:41:19,408 --> 00:41:23,776
But the answer to your question is, yes, by dragging in a lot more power from LISP value, you lose some of the principal power of logic programming.

674
00:41:24,170 --> 00:41:25,568
That's a trade-off that you have to make.

675
00:41:28,480 --> 00:41:29,392
OK, let's take a break.

676
00:41:30,176 --> 00:41:37,392
MIT OpenCourseWare
http://ocw.mit.edu

677
00:41:37,408 --> 00:41:44,304
本项目主页
https://github.com/DeathKing/Learning-SICP

