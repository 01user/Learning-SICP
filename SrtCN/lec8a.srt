1
00:00:00,000 --> 00:00:17,814
[MUSIC PLAYING BY J.S. BACH]

2
00:00:18,272 --> 00:00:21,376
PROFESSOR: The last time we began having a look at how languages are constructed.

3
00:00:22,416 --> 00:00:25,888
Remember the main point that an evaluator for, LISP, say, has two main elements.

4
00:00:26,080 --> 00:00:27,580
Remember the main point that an evaluator for, LISP, say, has two main elements.

5
00:00:27,580 --> 00:00:28,400
There is EVAL, and EVAL's job is to take in an expression and an environment and turn that into a procedure and some arguments and pass that off to APPLY.

6
00:00:31,040 --> 00:00:37,424
There is EVAL, and EVAL's job is to take in an expression and an environment and turn that into a procedure and some arguments and pass that off to APPLY.

7
00:00:38,912 --> 00:00:44,448
There is EVAL, and EVAL's job is to take in an expression and an environment and turn that into a procedure and some arguments and pass that off to APPLY.

8
00:00:45,424 --> 00:00:47,056
There is EVAL, and EVAL's job is to take in an expression and an environment and turn that into a procedure and some arguments and pass that off to APPLY.

9
00:00:49,410 --> 00:00:51,296
And APPLY takes the procedure in the arguments, turns that back into, in a general case, another expression to be evaluated in another environment and passes that off to EVAL, which passes it to APPLY, and there's this whole big circle where things go around and around and around until you get either to some very primitive data or to a primitive procedure.

10
00:00:51,696 --> 00:00:53,040
And APPLY takes the procedure in the arguments, turns that back into, in a general case, another expression to be evaluated in another environment and passes that off to EVAL, which passes it to APPLY, and there's this whole big circle where things go around and around and around until you get either to some very primitive data or to a primitive procedure.

11
00:00:53,312 --> 00:00:55,120
And APPLY takes the procedure in the arguments, turns that back into, in a general case, another expression to be evaluated in another environment and passes that off to EVAL, which passes it to APPLY, and there's this whole big circle where things go around and around and around until you get either to some very primitive data or to a primitive procedure.

12
00:00:55,392 --> 00:00:57,712
And APPLY takes the procedure in the arguments, turns that back into, in a general case, another expression to be evaluated in another environment and passes that off to EVAL, which passes it to APPLY, and there's this whole big circle where things go around and around and around until you get either to some very primitive data or to a primitive procedure.

13
00:00:57,744 --> 00:01:00,000
And APPLY takes the procedure in the arguments, turns that back into, in a general case, another expression to be evaluated in another environment and passes that off to EVAL, which passes it to APPLY, and there's this whole big circle where things go around and around and around until you get either to some very primitive data or to a primitive procedure.

14
00:01:00,272 --> 00:01:01,440
And APPLY takes the procedure in the arguments, turns that back into, in a general case, another expression to be evaluated in another environment and passes that off to EVAL, which passes it to APPLY, and there's this whole big circle where things go around and around and around until you get either to some very primitive data or to a primitive procedure.

15
00:01:01,472 --> 00:01:03,888
And APPLY takes the procedure in the arguments, turns that back into, in a general case, another expression to be evaluated in another environment and passes that off to EVAL, which passes it to APPLY, and there's this whole big circle where things go around and around and around until you get either to some very primitive data or to a primitive procedure.

16
00:01:04,048 --> 00:01:06,640
And APPLY takes the procedure in the arguments, turns that back into, in a general case, another expression to be evaluated in another environment and passes that off to EVAL, which passes it to APPLY, and there's this whole big circle where things go around and around and around until you get either to some very primitive data or to a primitive procedure.

17
00:01:07,740 --> 00:01:09,248
See, what this cycle has to do with is unwinding the means of combination and the means of abstraction in the language.

18
00:01:09,440 --> 00:01:12,576
See, what this cycle has to do with is unwinding the means of combination and the means of abstraction in the language.

19
00:01:12,590 --> 00:01:14,368
See, what this cycle has to do with is unwinding the means of combination and the means of abstraction in the language.

20
00:01:15,020 --> 00:01:16,576
So for instance, you have a procedure in LISP-- a procedure is a general way of saying, I want to be able to evaluate this expression for any value of the arguments, and that's sort of what's going on here.

21
00:01:17,184 --> 00:01:19,360
So for instance, you have a procedure in LISP-- a procedure is a general way of saying, I want to be able to evaluate this expression for any value of the arguments, and that's sort of what's going on here.

22
00:01:20,128 --> 00:01:22,608
So for instance, you have a procedure in LISP-- a procedure is a general way of saying, I want to be able to evaluate this expression for any value of the arguments, and that's sort of what's going on here.

23
00:01:22,656 --> 00:01:24,416
So for instance, you have a procedure in LISP-- a procedure is a general way of saying, I want to be able to evaluate this expression for any value of the arguments, and that's sort of what's going on here.

24
00:01:25,760 --> 00:01:27,184
So for instance, you have a procedure in LISP-- a procedure is a general way of saying, I want to be able to evaluate this expression for any value of the arguments, and that's sort of what's going on here.

25
00:01:27,670 --> 00:01:28,510
That's what APPLY does.

26
00:01:28,510 --> 00:01:30,688
It says the general thing coming in with the arguments reduces to the expression that's the body, and then if that's a compound expression or another procedure application, the thing will go around and around the circle.

27
00:01:30,720 --> 00:01:32,704
It says the general thing coming in with the arguments reduces to the expression that's the body, and then if that's a compound expression or another procedure application, the thing will go around and around the circle.

28
00:01:33,056 --> 00:01:34,720
It says the general thing coming in with the arguments reduces to the expression that's the body, and then if that's a compound expression or another procedure application, the thing will go around and around the circle.

29
00:01:34,832 --> 00:01:36,464
It says the general thing coming in with the arguments reduces to the expression that's the body, and then if that's a compound expression or another procedure application, the thing will go around and around the circle.

30
00:01:36,784 --> 00:01:38,448
It says the general thing coming in with the arguments reduces to the expression that's the body, and then if that's a compound expression or another procedure application, the thing will go around and around the circle.

31
00:01:40,440 --> 00:01:42,320
Anyway, that's sort of the basic structure of gee, pretty much any interpreter.

32
00:01:42,480 --> 00:01:44,080
Anyway, that's sort of the basic structure of gee, pretty much any interpreter.

33
00:01:45,200 --> 00:01:47,664
The other thing that you saw is once you have the interpreter in your hands, you have all this power to start playing with the language.

34
00:01:47,696 --> 00:01:49,870
The other thing that you saw is once you have the interpreter in your hands, you have all this power to start playing with the language.

35
00:01:49,870 --> 00:01:51,520
So you can make it dynamically scoped, or you can put in normal order evaluation, or you can add new forms to the language, whatever you like.

36
00:01:51,840 --> 00:01:56,512
So you can make it dynamically scoped, or you can put in normal order evaluation, or you can add new forms to the language, whatever you like.

37
00:01:56,800 --> 00:01:57,504
So you can make it dynamically scoped, or you can put in normal order evaluation, or you can add new forms to the language, whatever you like.

38
00:01:57,584 --> 00:01:58,624
Or more generally, there's this notion of metalinguistic abstraction, which says that part of your perspective as an engineer, as a software engineer, but as an engineer in general is that you can gain control of complexity by inventing new languages sometimes.

39
00:01:58,768 --> 00:02:01,328
Or more generally, there's this notion of metalinguistic abstraction, which says that part of your perspective as an engineer, as a software engineer, but as an engineer in general is that you can gain control of complexity by inventing new languages sometimes.

40
00:02:02,592 --> 00:02:03,184
Or more generally, there's this notion of metalinguistic abstraction, which says that part of your perspective as an engineer, as a software engineer, but as an engineer in general is that you can gain control of complexity by inventing new languages sometimes.

41
00:02:03,424 --> 00:02:06,032
Or more generally, there's this notion of metalinguistic abstraction, which says that part of your perspective as an engineer, as a software engineer, but as an engineer in general is that you can gain control of complexity by inventing new languages sometimes.

42
00:02:07,616 --> 00:02:10,528
Or more generally, there's this notion of metalinguistic abstraction, which says that part of your perspective as an engineer, as a software engineer, but as an engineer in general is that you can gain control of complexity by inventing new languages sometimes.

43
00:02:11,392 --> 00:02:13,888
Or more generally, there's this notion of metalinguistic abstraction, which says that part of your perspective as an engineer, as a software engineer, but as an engineer in general is that you can gain control of complexity by inventing new languages sometimes.

44
00:02:14,960 --> 00:02:17,168
Or more generally, there's this notion of metalinguistic abstraction, which says that part of your perspective as an engineer, as a software engineer, but as an engineer in general is that you can gain control of complexity by inventing new languages sometimes.

45
00:02:18,010 --> 00:02:20,816
See, one way to think about computer programming is that it only incidentally has to do with getting a computer to do something.

46
00:02:21,552 --> 00:02:23,984
See, one way to think about computer programming is that it only incidentally has to do with getting a computer to do something.

47
00:02:24,144 --> 00:02:26,272
See, one way to think about computer programming is that it only incidentally has to do with getting a computer to do something.

48
00:02:26,440 --> 00:02:29,088
Primarily what a computer program has to do with, it's a way of expressing ideas with communicating ideas.

49
00:02:29,120 --> 00:02:32,528
Primarily what a computer program has to do with, it's a way of expressing ideas with communicating ideas.

50
00:02:33,168 --> 00:02:34,048
And sometimes when you want to communicate new kinds of ideas, you'd like to invent new modes of expressing that.

51
00:02:34,896 --> 00:02:36,624
And sometimes when you want to communicate new kinds of ideas, you'd like to invent new modes of expressing that.

52
00:02:36,656 --> 00:02:38,736
And sometimes when you want to communicate new kinds of ideas, you'd like to invent new modes of expressing that.

53
00:02:39,824 --> 00:02:44,992
Well, today we're going to apply this framework to build a new language.

54
00:02:45,730 --> 00:02:48,128
See, once we have the basic idea of the interpreter, you can pretty much go build any language that you like.

55
00:02:48,160 --> 00:02:50,224
See, once we have the basic idea of the interpreter, you can pretty much go build any language that you like.

56
00:02:50,830 --> 00:02:53,216
So for example, we can go off and build Pascal.

57
00:02:54,370 --> 00:02:55,152
And gee, we would worry about syntax and parsing and various kinds of compiler optimizations, and there are people who make honest livings doing that, but at the level of abstraction that we're talking, a Pascal interpreter would not look very different at all from what you saw Gerry do last time.

58
00:02:56,176 --> 00:03:00,512
And gee, we would worry about syntax and parsing and various kinds of compiler optimizations, and there are people who make honest livings doing that, but at the level of abstraction that we're talking, a Pascal interpreter would not look very different at all from what you saw Gerry do last time.

59
00:03:01,120 --> 00:03:03,296
And gee, we would worry about syntax and parsing and various kinds of compiler optimizations, and there are people who make honest livings doing that, but at the level of abstraction that we're talking, a Pascal interpreter would not look very different at all from what you saw Gerry do last time.

60
00:03:03,856 --> 00:03:07,600
And gee, we would worry about syntax and parsing and various kinds of compiler optimizations, and there are people who make honest livings doing that, but at the level of abstraction that we're talking, a Pascal interpreter would not look very different at all from what you saw Gerry do last time.

61
00:03:08,048 --> 00:03:10,992
And gee, we would worry about syntax and parsing and various kinds of compiler optimizations, and there are people who make honest livings doing that, but at the level of abstraction that we're talking, a Pascal interpreter would not look very different at all from what you saw Gerry do last time.

62
00:03:12,032 --> 00:03:13,760
And gee, we would worry about syntax and parsing and various kinds of compiler optimizations, and there are people who make honest livings doing that, but at the level of abstraction that we're talking, a Pascal interpreter would not look very different at all from what you saw Gerry do last time.

63
00:03:15,024 --> 00:03:18,960
Instead of that, we'll spend today building a really different language, a language that encourages you to think about programming not in terms of procedures, but in a really different way.

64
00:03:20,512 --> 00:03:24,320
Instead of that, we'll spend today building a really different language, a language that encourages you to think about programming not in terms of procedures, but in a really different way.

65
00:03:24,688 --> 00:03:26,048
Instead of that, we'll spend today building a really different language, a language that encourages you to think about programming not in terms of procedures, but in a really different way.

66
00:03:26,240 --> 00:03:27,648
Instead of that, we'll spend today building a really different language, a language that encourages you to think about programming not in terms of procedures, but in a really different way.

67
00:03:29,090 --> 00:03:30,800
And the lecture today is going to be at two levels simultaneously.

68
00:03:31,744 --> 00:03:34,640
And the lecture today is going to be at two levels simultaneously.

69
00:03:34,810 --> 00:03:37,712
On the one hand, I'm going to show you what this language looks like, and on the other hand, I'll show you how it's implemented.

70
00:03:38,960 --> 00:03:41,088
On the one hand, I'm going to show you what this language looks like, and on the other hand, I'll show you how it's implemented.

71
00:03:41,328 --> 00:03:43,904
And we'll build an implementation in LISP and see how that works.

72
00:03:44,048 --> 00:03:48,256
And you should be drawing lessons on two levels.

73
00:03:48,730 --> 00:03:49,440
The first is to realize just how different a language can be.

74
00:03:50,832 --> 00:03:53,008
The first is to realize just how different a language can be.

75
00:03:53,790 --> 00:03:58,144
So if you think that the jump from Fortran to LISP is a big deal, you haven't seen anything yet.

76
00:03:58,240 --> 00:03:59,360
So if you think that the jump from Fortran to LISP is a big deal, you haven't seen anything yet.

77
00:04:01,560 --> 00:04:03,680
And secondly, you'll see that even with such a very different language, which will turn out to not have procedures at all and not talk about functions at all, there will still be this basic cycle of eval and apply that's unwinds the means of combination and the means an abstraction.

78
00:04:03,776 --> 00:04:06,544
And secondly, you'll see that even with such a very different language, which will turn out to not have procedures at all and not talk about functions at all, there will still be this basic cycle of eval and apply that's unwinds the means of combination and the means an abstraction.

79
00:04:07,360 --> 00:04:09,520
And secondly, you'll see that even with such a very different language, which will turn out to not have procedures at all and not talk about functions at all, there will still be this basic cycle of eval and apply that's unwinds the means of combination and the means an abstraction.

80
00:04:09,920 --> 00:04:11,648
And secondly, you'll see that even with such a very different language, which will turn out to not have procedures at all and not talk about functions at all, there will still be this basic cycle of eval and apply that's unwinds the means of combination and the means an abstraction.

81
00:04:12,200 --> 00:04:15,720
And secondly, you'll see that even with such a very different language, which will turn out to not have procedures at all and not talk about functions at all, there will still be this basic cycle of eval and apply that's unwinds the means of combination and the means an abstraction.

82
00:04:16,192 --> 00:04:19,984
And secondly, you'll see that even with such a very different language, which will turn out to not have procedures at all and not talk about functions at all, there will still be this basic cycle of eval and apply that's unwinds the means of combination and the means an abstraction.

83
00:04:20,950 --> 00:04:24,688
And then thirdly, as kind of a minor but elegant technical point, you'll see a nice use of streams to avoid backtracking.

84
00:04:24,896 --> 00:04:26,512
And then thirdly, as kind of a minor but elegant technical point, you'll see a nice use of streams to avoid backtracking.

85
00:04:27,136 --> 00:04:28,480
And then thirdly, as kind of a minor but elegant technical point, you'll see a nice use of streams to avoid backtracking.

86
00:04:32,330 --> 00:04:34,400
OK, well, I said that this language is very different.

87
00:04:35,860 --> 00:04:36,640
To explain that, let's go back to the very first idea that we talked about in this course, and that was the idea of the distinction between the declarative knowledge of mathematics-- the definition of a square root as a mathematical truth-- and the idea that computer science talks about the how to knowledge-- contrast that definition of square root with a program to compute a square root.

88
00:04:37,056 --> 00:04:40,304
To explain that, let's go back to the very first idea that we talked about in this course, and that was the idea of the distinction between the declarative knowledge of mathematics-- the definition of a square root as a mathematical truth-- and the idea that computer science talks about the how to knowledge-- contrast that definition of square root with a program to compute a square root.

89
00:04:41,280 --> 00:04:42,768
To explain that, let's go back to the very first idea that we talked about in this course, and that was the idea of the distinction between the declarative knowledge of mathematics-- the definition of a square root as a mathematical truth-- and the idea that computer science talks about the how to knowledge-- contrast that definition of square root with a program to compute a square root.

90
00:04:43,264 --> 00:04:45,376
To explain that, let's go back to the very first idea that we talked about in this course, and that was the idea of the distinction between the declarative knowledge of mathematics-- the definition of a square root as a mathematical truth-- and the idea that computer science talks about the how to knowledge-- contrast that definition of square root with a program to compute a square root.

91
00:04:46,040 --> 00:04:49,840
To explain that, let's go back to the very first idea that we talked about in this course, and that was the idea of the distinction between the declarative knowledge of mathematics-- the definition of a square root as a mathematical truth-- and the idea that computer science talks about the how to knowledge-- contrast that definition of square root with a program to compute a square root.

92
00:04:50,192 --> 00:04:54,144
To explain that, let's go back to the very first idea that we talked about in this course, and that was the idea of the distinction between the declarative knowledge of mathematics-- the definition of a square root as a mathematical truth-- and the idea that computer science talks about the how to knowledge-- contrast that definition of square root with a program to compute a square root.

93
00:04:55,488 --> 00:04:59,568
To explain that, let's go back to the very first idea that we talked about in this course, and that was the idea of the distinction between the declarative knowledge of mathematics-- the definition of a square root as a mathematical truth-- and the idea that computer science talks about the how to knowledge-- contrast that definition of square root with a program to compute a square root.

94
00:04:59,760 --> 00:05:04,592
To explain that, let's go back to the very first idea that we talked about in this course, and that was the idea of the distinction between the declarative knowledge of mathematics-- the definition of a square root as a mathematical truth-- and the idea that computer science talks about the how to knowledge-- contrast that definition of square root with a program to compute a square root.

95
00:05:05,970 --> 00:05:07,072
That's where we started off.

96
00:05:08,512 --> 00:05:09,520
Well, wouldn't it be great if you could somehow bridge this gap and make a programming language which sort of did things, but you talked about it in terms of truth, in declarative terms?

97
00:05:09,888 --> 00:05:12,160
Well, wouldn't it be great if you could somehow bridge this gap and make a programming language which sort of did things, but you talked about it in terms of truth, in declarative terms?

98
00:05:12,816 --> 00:05:14,640
Well, wouldn't it be great if you could somehow bridge this gap and make a programming language which sort of did things, but you talked about it in terms of truth, in declarative terms?

99
00:05:15,040 --> 00:05:18,160
Well, wouldn't it be great if you could somehow bridge this gap and make a programming language which sort of did things, but you talked about it in terms of truth, in declarative terms?

100
00:05:18,768 --> 00:05:21,616
Well, wouldn't it be great if you could somehow bridge this gap and make a programming language which sort of did things, but you talked about it in terms of truth, in declarative terms?

101
00:05:22,380 --> 00:05:23,744
So that would be a programming language in which you specify facts.

102
00:05:23,968 --> 00:05:25,488
So that would be a programming language in which you specify facts.

103
00:05:27,690 --> 00:05:28,880
You tell it what is.

104
00:05:28,880 --> 00:05:29,968
You say what is true.

105
00:05:30,950 --> 00:05:33,072
And then when you want an answer, somehow the language has built into it automatically general kinds of how to knowledge so it can just take your facts and it can evolve these methods on its on using the facts you gave it and maybe some general rules of logic.

106
00:05:33,216 --> 00:05:36,384
And then when you want an answer, somehow the language has built into it automatically general kinds of how to knowledge so it can just take your facts and it can evolve these methods on its on using the facts you gave it and maybe some general rules of logic.

107
00:05:37,600 --> 00:05:40,640
And then when you want an answer, somehow the language has built into it automatically general kinds of how to knowledge so it can just take your facts and it can evolve these methods on its on using the facts you gave it and maybe some general rules of logic.

108
00:05:40,896 --> 00:05:42,832
And then when you want an answer, somehow the language has built into it automatically general kinds of how to knowledge so it can just take your facts and it can evolve these methods on its on using the facts you gave it and maybe some general rules of logic.

109
00:05:43,312 --> 00:05:46,128
And then when you want an answer, somehow the language has built into it automatically general kinds of how to knowledge so it can just take your facts and it can evolve these methods on its on using the facts you gave it and maybe some general rules of logic.

110
00:05:49,330 --> 00:05:50,544
So for instance, I might go up to this program and start telling it some things.

111
00:05:52,064 --> 00:05:53,376
So for instance, I might go up to this program and start telling it some things.

112
00:05:53,392 --> 00:05:55,120
So for instance, I might go up to this program and start telling it some things.

113
00:05:55,984 --> 00:05:57,136
So I might tell it that the son of Adam is Abel.

114
00:05:58,608 --> 00:06:07,088
So I might tell it that the son of Adam is Abel.

115
00:06:08,920 --> 00:06:16,512
And I might tell it that the son of Adam is Cain.

116
00:06:17,660 --> 00:06:25,088
And I might tell it that the son of Cain is Enoch.

117
00:06:27,792 --> 00:06:34,896
And I might tell it that the son of Enoch is Irad, and all through the rest of our chapter whatever of Genesis, which ends up ending in Adah, by the way, and this shows the genealogy of Adah from Cain.

118
00:06:37,024 --> 00:06:40,720
And I might tell it that the son of Enoch is Irad, and all through the rest of our chapter whatever of Genesis, which ends up ending in Adah, by the way, and this shows the genealogy of Adah from Cain.

119
00:06:41,152 --> 00:06:43,184
And I might tell it that the son of Enoch is Irad, and all through the rest of our chapter whatever of Genesis, which ends up ending in Adah, by the way, and this shows the genealogy of Adah from Cain.

120
00:06:43,328 --> 00:06:46,784
And I might tell it that the son of Enoch is Irad, and all through the rest of our chapter whatever of Genesis, which ends up ending in Adah, by the way, and this shows the genealogy of Adah from Cain.

121
00:06:48,440 --> 00:06:50,672
Anyway, once you tell it these facts, you might ask it things.

122
00:06:52,352 --> 00:06:53,408
Anyway, once you tell it these facts, you might ask it things.

123
00:06:53,510 --> 00:06:55,056
You might go up to your language and say, who's the son of Adam?

124
00:06:56,064 --> 00:06:59,296
You might go up to your language and say, who's the son of Adam?

125
00:07:00,420 --> 00:07:04,912
And you can very easily imagine having a little general purpose search program which would be able to go through and in response to that say, oh yeah, there are two answers: the son of Adam is Abel and the son of Adam is Cain.

126
00:07:05,520 --> 00:07:09,264
And you can very easily imagine having a little general purpose search program which would be able to go through and in response to that say, oh yeah, there are two answers: the son of Adam is Abel and the son of Adam is Cain.

127
00:07:09,296 --> 00:07:10,448
And you can very easily imagine having a little general purpose search program which would be able to go through and in response to that say, oh yeah, there are two answers: the son of Adam is Abel and the son of Adam is Cain.

128
00:07:10,688 --> 00:07:12,176
And you can very easily imagine having a little general purpose search program which would be able to go through and in response to that say, oh yeah, there are two answers: the son of Adam is Abel and the son of Adam is Cain.

129
00:07:14,140 --> 00:07:14,976
Or you might say, based on the very same facts, who is Cain the son of?

130
00:07:15,070 --> 00:07:16,890
Or you might say, based on the very same facts, who is Cain the son of?

131
00:07:18,048 --> 00:07:19,952
Or you might say, based on the very same facts, who is Cain the son of?

132
00:07:21,950 --> 00:07:27,024
And then you can imagine generating another slightly different search program which would be able to go through and checked for who is Cain, and son of, and come up with Adam.

133
00:07:27,920 --> 00:07:30,400
And then you can imagine generating another slightly different search program which would be able to go through and checked for who is Cain, and son of, and come up with Adam.

134
00:07:31,296 --> 00:07:34,448
And then you can imagine generating another slightly different search program which would be able to go through and checked for who is Cain, and son of, and come up with Adam.

135
00:07:35,890 --> 00:07:36,992
Or you might say, what's the relationship between Cain and Enoch?

136
00:07:38,016 --> 00:07:41,408
Or you might say, what's the relationship between Cain and Enoch?

137
00:07:42,070 --> 00:07:45,088
And again, a minor variant on that search program.

138
00:07:46,340 --> 00:07:48,160
You could figure out that it said son of.

139
00:07:52,880 --> 00:07:54,928
But even here in this very simple example, what you see is that a single fact, see, a single fact like the son of Adam is Cain can be used to answer different kinds of questions.

140
00:07:56,144 --> 00:07:58,448
But even here in this very simple example, what you see is that a single fact, see, a single fact like the son of Adam is Cain can be used to answer different kinds of questions.

141
00:07:58,816 --> 00:08:01,520
But even here in this very simple example, what you see is that a single fact, see, a single fact like the son of Adam is Cain can be used to answer different kinds of questions.

142
00:08:02,848 --> 00:08:05,520
But even here in this very simple example, what you see is that a single fact, see, a single fact like the son of Adam is Cain can be used to answer different kinds of questions.

143
00:08:06,520 --> 00:08:09,136
You can say, who's the son of, or you can say who's the son of Adam, or you can say what's the relation between Adam and Cain?

144
00:08:09,984 --> 00:08:11,712
You can say, who's the son of, or you can say who's the son of Adam, or you can say what's the relation between Adam and Cain?

145
00:08:11,728 --> 00:08:12,752
You can say, who's the son of, or you can say who's the son of Adam, or you can say what's the relation between Adam and Cain?

146
00:08:12,800 --> 00:08:14,480
Those are different questions being run by different traditional procedures all based on the same fact.

147
00:08:15,536 --> 00:08:18,544
Those are different questions being run by different traditional procedures all based on the same fact.

148
00:08:18,688 --> 00:08:20,720
Those are different questions being run by different traditional procedures all based on the same fact.

149
00:08:22,752 --> 00:08:25,920
And that's going to be the essence of the power of this programming style, that one piece of declarative knowledge can be used as the basis for a lot of different kinds of how-to knowledge, as opposed to the kinds of procedures we're writing where you sort of tell it what input you're giving it and what answer you want.

150
00:08:26,912 --> 00:08:29,504
And that's going to be the essence of the power of this programming style, that one piece of declarative knowledge can be used as the basis for a lot of different kinds of how-to knowledge, as opposed to the kinds of procedures we're writing where you sort of tell it what input you're giving it and what answer you want.

151
00:08:30,048 --> 00:08:31,856
And that's going to be the essence of the power of this programming style, that one piece of declarative knowledge can be used as the basis for a lot of different kinds of how-to knowledge, as opposed to the kinds of procedures we're writing where you sort of tell it what input you're giving it and what answer you want.

152
00:08:32,064 --> 00:08:34,032
And that's going to be the essence of the power of this programming style, that one piece of declarative knowledge can be used as the basis for a lot of different kinds of how-to knowledge, as opposed to the kinds of procedures we're writing where you sort of tell it what input you're giving it and what answer you want.

153
00:08:34,816 --> 00:08:37,088
And that's going to be the essence of the power of this programming style, that one piece of declarative knowledge can be used as the basis for a lot of different kinds of how-to knowledge, as opposed to the kinds of procedures we're writing where you sort of tell it what input you're giving it and what answer you want.

154
00:08:37,152 --> 00:08:39,552
And that's going to be the essence of the power of this programming style, that one piece of declarative knowledge can be used as the basis for a lot of different kinds of how-to knowledge, as opposed to the kinds of procedures we're writing where you sort of tell it what input you're giving it and what answer you want.

155
00:08:39,616 --> 00:08:40,656
And that's going to be the essence of the power of this programming style, that one piece of declarative knowledge can be used as the basis for a lot of different kinds of how-to knowledge, as opposed to the kinds of procedures we're writing where you sort of tell it what input you're giving it and what answer you want.

156
00:08:41,490 --> 00:08:44,704
So for instance, our square root program can perfectly well answer the question, what's the square root of 144?

157
00:08:44,768 --> 00:08:47,168
So for instance, our square root program can perfectly well answer the question, what's the square root of 144?

158
00:08:48,900 --> 00:08:49,776
But in principle, the mathematical definition of square root tells you other things.

159
00:08:49,824 --> 00:08:52,830
But in principle, the mathematical definition of square root tells you other things.

160
00:08:52,830 --> 00:08:53,920
Like it could say, what is 17 the square root of?

161
00:08:54,400 --> 00:08:56,432
Like it could say, what is 17 the square root of?

162
00:08:57,590 --> 00:08:59,712
And that would be have to be answered by a different program.

163
00:09:01,920 --> 00:09:03,504
So the mathematical definition, or in general, the facts that you give it are somehow unbiased as to what the question is.

164
00:09:03,984 --> 00:09:07,632
So the mathematical definition, or in general, the facts that you give it are somehow unbiased as to what the question is.

165
00:09:08,032 --> 00:09:10,304
So the mathematical definition, or in general, the facts that you give it are somehow unbiased as to what the question is.

166
00:09:10,900 --> 00:09:12,816
Whereas the programs we tend to write specifically because they are how-to knowledge tend to be looking for a specific answer.

167
00:09:12,830 --> 00:09:14,208
Whereas the programs we tend to write specifically because they are how-to knowledge tend to be looking for a specific answer.

168
00:09:14,240 --> 00:09:16,368
Whereas the programs we tend to write specifically because they are how-to knowledge tend to be looking for a specific answer.

169
00:09:17,700 --> 00:09:20,128
So that's going to be one characteristic of what we're talking about.

170
00:09:21,810 --> 00:09:22,608
We can go on.

171
00:09:23,480 --> 00:09:27,520
We can imagine that we've given our language some sort of facts.

172
00:09:27,710 --> 00:09:29,616
Now let's give it some rules of inference.

173
00:09:30,020 --> 00:09:31,360
We can say, for instance, if the-- make up some syntax here-- if the son of x is y-- I'll put question marks to indicate variables here-- if the son of x is y and the son of y is z, then the grandson of x is z.

174
00:09:31,952 --> 00:09:36,192
We can say, for instance, if the-- make up some syntax here-- if the son of x is y-- I'll put question marks to indicate variables here-- if the son of x is y and the son of y is z, then the grandson of x is z.

175
00:09:36,448 --> 00:09:41,536
We can say, for instance, if the-- make up some syntax here-- if the son of x is y-- I'll put question marks to indicate variables here-- if the son of x is y and the son of y is z, then the grandson of x is z.

176
00:09:41,680 --> 00:09:45,210
We can say, for instance, if the-- make up some syntax here-- if the son of x is y-- I'll put question marks to indicate variables here-- if the son of x is y and the son of y is z, then the grandson of x is z.

177
00:09:45,600 --> 00:09:47,552
We can say, for instance, if the-- make up some syntax here-- if the son of x is y-- I'll put question marks to indicate variables here-- if the son of x is y and the son of y is z, then the grandson of x is z.

178
00:09:50,200 --> 00:09:56,060
We can say, for instance, if the-- make up some syntax here-- if the son of x is y-- I'll put question marks to indicate variables here-- if the son of x is y and the son of y is z, then the grandson of x is z.

179
00:09:58,960 --> 00:10:08,464
We can say, for instance, if the-- make up some syntax here-- if the son of x is y-- I'll put question marks to indicate variables here-- if the son of x is y and the son of y is z, then the grandson of x is z.

180
00:10:09,320 --> 00:10:13,408
So I can imagine telling my machine that rule and then being able to say, for instance, who's the grandson of Adam?

181
00:10:15,008 --> 00:10:17,280
So I can imagine telling my machine that rule and then being able to say, for instance, who's the grandson of Adam?

182
00:10:17,440 --> 00:10:18,688
So I can imagine telling my machine that rule and then being able to say, for instance, who's the grandson of Adam?

183
00:10:20,610 --> 00:10:23,648
Or who is Irad the grandson of?

184
00:10:24,790 --> 00:10:29,330
Or deduce all grandson relationships you possibly can from this information.

185
00:10:31,220 --> 00:10:33,264
We can imagine somehow the language knowing how to do that automatically.

186
00:10:33,504 --> 00:10:35,600
We can imagine somehow the language knowing how to do that automatically.

187
00:10:40,224 --> 00:10:45,200
Ok, Let me give you maybe a little bit more concrete example.

188
00:10:45,808 --> 00:10:46,336
Here's a procedure that merges two sorted lists.

189
00:10:49,664 --> 00:10:51,936
Here's a procedure that merges two sorted lists.

190
00:10:53,920 --> 00:11:00,272
So x and y are two, say, lists of numbers, lists of distinct numbers, if you like, that are in increasing order.

191
00:11:00,304 --> 00:11:04,208
So x and y are two, say, lists of numbers, lists of distinct numbers, if you like, that are in increasing order.

192
00:11:04,780 --> 00:11:05,760
And what merge does is take two such lists and combine them into a list where everything's in increasing order, and this is a pretty easy programs that you ought to be able to write.

193
00:11:06,112 --> 00:11:07,536
And what merge does is take two such lists and combine them into a list where everything's in increasing order, and this is a pretty easy programs that you ought to be able to write.

194
00:11:07,712 --> 00:11:10,384
And what merge does is take two such lists and combine them into a list where everything's in increasing order, and this is a pretty easy programs that you ought to be able to write.

195
00:11:11,210 --> 00:11:15,000
And what merge does is take two such lists and combine them into a list where everything's in increasing order, and this is a pretty easy programs that you ought to be able to write.

196
00:11:15,024 --> 00:11:16,144
And what merge does is take two such lists and combine them into a list where everything's in increasing order, and this is a pretty easy programs that you ought to be able to write.

197
00:11:16,390 --> 00:11:18,640
It says, if x is empty, the answer is y.

198
00:11:18,860 --> 00:11:20,464
If y is empty, the answer is x.

199
00:11:21,180 --> 00:11:22,990
Otherwise, you compare the first two elements.

200
00:11:22,990 --> 00:11:24,464
So you pick out the first thing in x and the first thing in y, and then depending on which of those first elements is less, you stick the lower one on to the result a recursively merging, either chopping the first one off x or chopping the first one off y.

201
00:11:24,848 --> 00:11:26,016
So you pick out the first thing in x and the first thing in y, and then depending on which of those first elements is less, you stick the lower one on to the result a recursively merging, either chopping the first one off x or chopping the first one off y.

202
00:11:26,816 --> 00:11:28,448
So you pick out the first thing in x and the first thing in y, and then depending on which of those first elements is less, you stick the lower one on to the result a recursively merging, either chopping the first one off x or chopping the first one off y.

203
00:11:29,264 --> 00:11:31,664
So you pick out the first thing in x and the first thing in y, and then depending on which of those first elements is less, you stick the lower one on to the result a recursively merging, either chopping the first one off x or chopping the first one off y.

204
00:11:32,832 --> 00:11:36,608
So you pick out the first thing in x and the first thing in y, and then depending on which of those first elements is less, you stick the lower one on to the result a recursively merging, either chopping the first one off x or chopping the first one off y.

205
00:11:37,872 --> 00:11:39,920
So you pick out the first thing in x and the first thing in y, and then depending on which of those first elements is less, you stick the lower one on to the result a recursively merging, either chopping the first one off x or chopping the first one off y.

206
00:11:40,112 --> 00:11:41,616
So you pick out the first thing in x and the first thing in y, and then depending on which of those first elements is less, you stick the lower one on to the result a recursively merging, either chopping the first one off x or chopping the first one off y.

207
00:11:42,400 --> 00:11:43,960
That's a standard kind of program.

208
00:11:46,470 --> 00:11:48,416
Let's look at the logic.

209
00:11:48,620 --> 00:11:49,792
Let's forget about the program and look at the logic on which that procedure is based.

210
00:11:50,288 --> 00:11:52,768
Let's forget about the program and look at the logic on which that procedure is based.

211
00:11:53,820 --> 00:11:55,488
See, there's some logic which says, gee, if the first one is less, then we get the answer by sticking something onto the result of recursively merging the rest. So let's try and be explicit about what that logic is that's making the program work.

212
00:11:55,968 --> 00:11:57,216
See, there's some logic which says, gee, if the first one is less, then we get the answer by sticking something onto the result of recursively merging the rest. So let's try and be explicit about what that logic is that's making the program work.

213
00:11:57,536 --> 00:12:00,000
See, there's some logic which says, gee, if the first one is less, then we get the answer by sticking something onto the result of recursively merging the rest. So let's try and be explicit about what that logic is that's making the program work.

214
00:12:00,160 --> 00:12:02,128
See, there's some logic which says, gee, if the first one is less, then we get the answer by sticking something onto the result of recursively merging the rest. So let's try and be explicit about what that logic is that's making the program work.

215
00:12:02,848 --> 00:12:04,096
See, there's some logic which says, gee, if the first one is less, then we get the answer by sticking something onto the result of recursively merging the rest. So let's try and be explicit about what that logic is that's making the program work.

216
00:12:04,240 --> 00:12:06,416
See, there's some logic which says, gee, if the first one is less, then we get the answer by sticking something onto the result of recursively merging the rest. So let's try and be explicit about what that logic is that's making the program work.

217
00:12:08,304 --> 00:12:09,440
So here's one piece.

218
00:12:10,130 --> 00:12:11,536
Here's the piece of the program which recursively chops down x if the first thing in x is smaller.

219
00:12:12,640 --> 00:12:15,264
Here's the piece of the program which recursively chops down x if the first thing in x is smaller.

220
00:12:15,664 --> 00:12:17,824
Here's the piece of the program which recursively chops down x if the first thing in x is smaller.

221
00:12:19,980 --> 00:12:22,544
And if you want to be very explicit about what the logic is there, what's really going on is a deduction, which says, if you know that some list, that we'll call cdr of x, and y merged to form z, and you know that a is less than the first thing in y, then you know that if you put a onto the cdr of x, then that result and y merge to form a onto z.

222
00:12:23,450 --> 00:12:26,496
And if you want to be very explicit about what the logic is there, what's really going on is a deduction, which says, if you know that some list, that we'll call cdr of x, and y merged to form z, and you know that a is less than the first thing in y, then you know that if you put a onto the cdr of x, then that result and y merge to form a onto z.

223
00:12:26,688 --> 00:12:27,824
And if you want to be very explicit about what the logic is there, what's really going on is a deduction, which says, if you know that some list, that we'll call cdr of x, and y merged to form z, and you know that a is less than the first thing in y, then you know that if you put a onto the cdr of x, then that result and y merge to form a onto z.

224
00:12:28,120 --> 00:12:32,368
And if you want to be very explicit about what the logic is there, what's really going on is a deduction, which says, if you know that some list, that we'll call cdr of x, and y merged to form z, and you know that a is less than the first thing in y, then you know that if you put a onto the cdr of x, then that result and y merge to form a onto z.

225
00:12:33,296 --> 00:12:35,440
And if you want to be very explicit about what the logic is there, what's really going on is a deduction, which says, if you know that some list, that we'll call cdr of x, and y merged to form z, and you know that a is less than the first thing in y, then you know that if you put a onto the cdr of x, then that result and y merge to form a onto z.

226
00:12:55,820 --> 00:12:58,096
And what that is, that's the underlying piece of logic-- I haven't written it as a program, I wrote it a sort of deduction that's underneath this particular clause that says we can use the recursion there.

227
00:12:58,720 --> 00:12:59,952
And what that is, that's the underlying piece of logic-- I haven't written it as a program, I wrote it a sort of deduction that's underneath this particular clause that says we can use the recursion there.

228
00:12:59,968 --> 00:13:02,000
And what that is, that's the underlying piece of logic-- I haven't written it as a program, I wrote it a sort of deduction that's underneath this particular clause that says we can use the recursion there.

229
00:13:02,032 --> 00:13:04,896
And what that is, that's the underlying piece of logic-- I haven't written it as a program, I wrote it a sort of deduction that's underneath this particular clause that says we can use the recursion there.

230
00:13:05,216 --> 00:13:07,264
And what that is, that's the underlying piece of logic-- I haven't written it as a program, I wrote it a sort of deduction that's underneath this particular clause that says we can use the recursion there.

231
00:13:09,410 --> 00:13:12,784
And then similar, here's the other clause just to complete it.

232
00:13:14,000 --> 00:13:15,872
The other clause is based on this piece of logic, which is almost the same and I won't go through it, and then there's the n cases where we tested for null, and that's based on the idea that for any x, x and the empty list merge to form an x, or for any y, the empty list and y merge to form y.

233
00:13:15,920 --> 00:13:18,352
The other clause is based on this piece of logic, which is almost the same and I won't go through it, and then there's the n cases where we tested for null, and that's based on the idea that for any x, x and the empty list merge to form an x, or for any y, the empty list and y merge to form y.

234
00:13:19,008 --> 00:13:20,352
The other clause is based on this piece of logic, which is almost the same and I won't go through it, and then there's the n cases where we tested for null, and that's based on the idea that for any x, x and the empty list merge to form an x, or for any y, the empty list and y merge to form y.

235
00:13:20,416 --> 00:13:22,016
The other clause is based on this piece of logic, which is almost the same and I won't go through it, and then there's the n cases where we tested for null, and that's based on the idea that for any x, x and the empty list merge to form an x, or for any y, the empty list and y merge to form y.

236
00:13:22,032 --> 00:13:24,048
The other clause is based on this piece of logic, which is almost the same and I won't go through it, and then there's the n cases where we tested for null, and that's based on the idea that for any x, x and the empty list merge to form an x, or for any y, the empty list and y merge to form y.

237
00:13:24,510 --> 00:13:27,200
The other clause is based on this piece of logic, which is almost the same and I won't go through it, and then there's the n cases where we tested for null, and that's based on the idea that for any x, x and the empty list merge to form an x, or for any y, the empty list and y merge to form y.

238
00:13:28,048 --> 00:13:30,864
The other clause is based on this piece of logic, which is almost the same and I won't go through it, and then there's the n cases where we tested for null, and that's based on the idea that for any x, x and the empty list merge to form an x, or for any y, the empty list and y merge to form y.

239
00:13:33,360 --> 00:13:38,128
OK, so there's a piece of procedure and the logic on which it's based.

240
00:13:38,432 --> 00:13:40,112
OK, so there's a piece of procedure and the logic on which it's based.

241
00:13:41,740 --> 00:13:42,976
And notice a big difference.

242
00:13:45,104 --> 00:13:50,528
The procedure looked like this: it said there was a box-- and all the things we've been doing have the characteristic we have boxes and things going in and things going out-- there was this box called merge, and in came an x and y, and out came an answer.

243
00:13:50,656 --> 00:13:52,288
The procedure looked like this: it said there was a box-- and all the things we've been doing have the characteristic we have boxes and things going in and things going out-- there was this box called merge, and in came an x and y, and out came an answer.

244
00:13:52,864 --> 00:13:57,696
The procedure looked like this: it said there was a box-- and all the things we've been doing have the characteristic we have boxes and things going in and things going out-- there was this box called merge, and in came an x and y, and out came an answer.

245
00:13:58,080 --> 00:13:59,610
The procedure looked like this: it said there was a box-- and all the things we've been doing have the characteristic we have boxes and things going in and things going out-- there was this box called merge, and in came an x and y, and out came an answer.

246
00:14:01,296 --> 00:14:03,856
The procedure looked like this: it said there was a box-- and all the things we've been doing have the characteristic we have boxes and things going in and things going out-- there was this box called merge, and in came an x and y, and out came an answer.

247
00:14:04,448 --> 00:14:05,376
The procedure looked like this: it said there was a box-- and all the things we've been doing have the characteristic we have boxes and things going in and things going out-- there was this box called merge, and in came an x and y, and out came an answer.

248
00:14:07,632 --> 00:14:09,488
That's the character of the procedure that we wrote.

249
00:14:13,024 --> 00:14:14,660
These rules don't look like that.

250
00:14:14,660 --> 00:14:16,768
These rules talk about a relation.

251
00:14:17,952 --> 00:14:19,248
There's some sort of relation that in those slides I called mrege-to-form.

252
00:14:19,808 --> 00:14:24,160
There's some sort of relation that in those slides I called mrege-to-form.

253
00:14:25,370 --> 00:14:28,768
So I said x and y merge to form z, and somehow this is a function.

254
00:14:29,008 --> 00:14:32,336
So I said x and y merge to form z, and somehow this is a function.

255
00:14:32,610 --> 00:14:32,850
Right?

256
00:14:32,850 --> 00:14:34,416
The answer is a function of x and y, and here what I have is a relation between three things.

257
00:14:34,592 --> 00:14:38,192
The answer is a function of x and y, and here what I have is a relation between three things.

258
00:14:39,720 --> 00:14:41,328
And I'm not going to specify which is the input and which is the output.

259
00:14:42,096 --> 00:14:43,770
And I'm not going to specify which is the input and which is the output.

260
00:14:44,200 --> 00:14:47,408
And the reason I want to say that is because in principle, we could use exactly those same logic rules to answer a lot of different questions.

261
00:14:48,640 --> 00:14:52,448
And the reason I want to say that is because in principle, we could use exactly those same logic rules to answer a lot of different questions.

262
00:14:54,570 --> 00:14:56,304
So we can say, for instance-- imagine giving our machine those rules of logic.

263
00:14:56,720 --> 00:14:59,050
So we can say, for instance-- imagine giving our machine those rules of logic.

264
00:14:59,050 --> 00:15:01,200
Not the program, the underlying rules of logic.

265
00:15:01,400 --> 00:15:03,120
Then it ought to be able to say-- we could ask it-- 1, 3, 7 and 2, 4, 8 merge to form what?

266
00:15:04,752 --> 00:15:05,520
Then it ought to be able to say-- we could ask it-- 1, 3, 7 and 2, 4, 8 merge to form what?

267
00:15:06,736 --> 00:15:19,184
Then it ought to be able to say-- we could ask it-- 1, 3, 7 and 2, 4, 8 merge to form what?

268
00:15:20,910 --> 00:15:23,424
And that's a question it ought to be able to answer.

269
00:15:23,880 --> 00:15:27,360
That's exactly the same question that our list procedure answered.

270
00:15:28,180 --> 00:15:30,144
But the exact same rules should also be able to answer a question like this: 1, 3, 7 and what merged to form 1, 2, 3, 4, 7, 8?

271
00:15:30,896 --> 00:15:34,800
But the exact same rules should also be able to answer a question like this: 1, 3, 7 and what merged to form 1, 2, 3, 4, 7, 8?

272
00:15:36,192 --> 00:15:43,248
But the exact same rules should also be able to answer a question like this: 1, 3, 7 and what merged to form 1, 2, 3, 4, 7, 8?

273
00:15:45,560 --> 00:15:47,808
The same rules of logic can answer this, although the procedure we wrote can't answer that question.

274
00:15:47,840 --> 00:15:49,904
The same rules of logic can answer this, although the procedure we wrote can't answer that question.

275
00:15:50,800 --> 00:15:52,336
Or we might be able to say what and what else merge to form-- what and what else merge to form 1, 2, 3, 4, 7, 8?

276
00:15:53,710 --> 00:16:01,120
Or we might be able to say what and what else merge to form-- what and what else merge to form 1, 2, 3, 4, 7, 8?

277
00:16:04,288 --> 00:16:12,688
Or we might be able to say what and what else merge to form-- what and what else merge to form 1, 2, 3, 4, 7, 8?

278
00:16:13,780 --> 00:16:15,344
And the thing should be able to go through, if it really can apply that logic, and deduce all, whatever is, 2 to the sixth answers to that question.

279
00:16:15,840 --> 00:16:17,312
And the thing should be able to go through, if it really can apply that logic, and deduce all, whatever is, 2 to the sixth answers to that question.

280
00:16:17,792 --> 00:16:22,540
And the thing should be able to go through, if it really can apply that logic, and deduce all, whatever is, 2 to the sixth answers to that question.

281
00:16:25,600 --> 00:16:28,790
It could be 1 and the rest, or it could be 1, 2 and the rest.

282
00:16:28,790 --> 00:16:31,536
Or it could be 1 and 3 and 7 and the rest. There's a whole bunch of answers.

283
00:16:32,016 --> 00:16:33,264
Or it could be 1 and 3 and 7 and the rest. There's a whole bunch of answers.

284
00:16:33,410 --> 00:16:37,760
And in principle, the logic should be enough to deduce that.

285
00:16:38,550 --> 00:16:42,032
So there are going to be two big differences in the kind of program we're going to look at and not only list, but essentially all the programming you've probably done so far in pretty much any language you can think of.

286
00:16:44,048 --> 00:16:46,000
So there are going to be two big differences in the kind of program we're going to look at and not only list, but essentially all the programming you've probably done so far in pretty much any language you can think of.

287
00:16:46,544 --> 00:16:50,560
So there are going to be two big differences in the kind of program we're going to look at and not only list, but essentially all the programming you've probably done so far in pretty much any language you can think of.

288
00:16:52,032 --> 00:16:53,600
So there are going to be two big differences in the kind of program we're going to look at and not only list, but essentially all the programming you've probably done so far in pretty much any language you can think of.

289
00:16:54,150 --> 00:16:57,792
The first is, we're not going to be computing functions.

290
00:17:00,620 --> 00:17:02,016
We're not going to be talking about things that take input and output.

291
00:17:02,624 --> 00:17:04,410
We're not going to be talking about things that take input and output.

292
00:17:04,410 --> 00:17:05,824
We're going to be talking about relations.

293
00:17:06,890 --> 00:17:10,000
And that means in principle, these relations don't have directionality.

294
00:17:11,080 --> 00:17:15,056
So the knowledge that you specify to answer this question, that same knowledge should also allow you to answer these other questions and conversely.

295
00:17:16,460 --> 00:17:18,416
So the knowledge that you specify to answer this question, that same knowledge should also allow you to answer these other questions and conversely.

296
00:17:18,432 --> 00:17:21,800
So the knowledge that you specify to answer this question, that same knowledge should also allow you to answer these other questions and conversely.

297
00:17:26,608 --> 00:17:29,408
And the second issue is that since we're talking about relations, these relations don't necessarily have one answer.

298
00:17:29,616 --> 00:17:31,232
And the second issue is that since we're talking about relations, these relations don't necessarily have one answer.

299
00:17:32,320 --> 00:17:34,448
And the second issue is that since we're talking about relations, these relations don't necessarily have one answer.

300
00:17:35,610 --> 00:17:37,008
So that third question down there doesn't have a particular answer, it has a whole bunch of answers.

301
00:17:37,020 --> 00:17:38,360
So that third question down there doesn't have a particular answer, it has a whole bunch of answers.

302
00:17:38,400 --> 00:17:39,584
So that third question down there doesn't have a particular answer, it has a whole bunch of answers.

303
00:17:42,270 --> 00:17:44,640
Well, that's where we're going.

304
00:17:44,640 --> 00:17:51,310
This style of programming, by the way, is called logic programming, for kind of obvious reasons.

305
00:17:56,160 --> 00:18:19,200
And people who do logic programming say that-- they have this little phrase-- they say the point of logic programming is that you use logic to express what is true, you use logic to check whether something is true, and you use logic to find out what is true.

306
00:18:19,200 --> 00:18:25,780
The best known logic programming language, as you probably know, is called Prolog.

307
00:18:25,780 --> 00:18:35,320
The language that we're going to implement this morning is something we call the query language, and it essentially has the essence of prologue.

308
00:18:35,320 --> 00:18:44,210
It can do about the same stuff, although it's a lot slower because we're going to implement it in LISP rather than building a particular compiler.

309
00:18:44,210 --> 00:18:47,510
We're going to interpret it on top of the LISP interpreter.

310
00:18:47,510 --> 00:18:49,750
But other than that, it can do about the same stuff as prolog.

311
00:18:49,750 --> 00:18:54,696
It has about the same power and about the same limitations.

312
00:18:54,696 --> 00:18:56,120
All right, let's break for question.

313
00:19:00,040 --> 00:19:06,720
STUDENT: Yes, could you please repeat what the three things you use logic programming to find?

314
00:19:06,720 --> 00:19:09,840
In other words, to find what is true, learn what is true-- what is the?

315
00:19:09,840 --> 00:19:10,520
PROFESSOR: Right.

316
00:19:10,520 --> 00:19:15,850
Sort of a logic programmer's little catechism.

317
00:19:15,850 --> 00:19:22,610
You use logic to express what is true, like these rules.

318
00:19:22,610 --> 00:19:28,550
You use logic to check whether something is true, and that's the kind of question I didn't answer here.

319
00:19:28,550 --> 00:19:45,690
I might say-- another question I could put down here is to say, is it true that 1, 3, 7 and 2, 4, 8 merge to form 1, 2, 6, 10 And that same logic should be enough to say no.

320
00:19:45,690 --> 00:19:50,480
So I use logic to check what is true, and then you also use logic to find out what's true.

321
00:20:04,060 --> 00:20:04,570
All right.

322
00:20:04,570 --> 00:20:06,138
Let's break.

323
00:20:06,138 --> 00:20:22,106
[MUSIC PLAYING BY J.S. BACH]

324
00:20:22,106 --> 00:20:47,590
[MUSIC ENDS]

325
00:20:47,590 --> 00:21:02,901
[MUSIC PLAYING BY J.S. BACH]

326
00:21:02,901 --> 00:21:10,520
PROFESSOR: OK, let's go ahead and take a look at this query language and operation.

327
00:21:10,520 --> 00:21:21,330
The first thing you might notice, when I put up that little biblical database, is that it's nice to be able to ask this language questions in relation to some collection of facts.

328
00:21:21,330 --> 00:21:26,060
So let's start off and make a little collection of facts.

329
00:21:26,060 --> 00:21:37,500
This is a tiny fragment of personnel records for a Boston high tech company, and here's a piece of the personnel records of Ben Bitdiddle.

330
00:21:37,500 --> 00:21:46,420
And Ben Bitdiddle is the computer wizard in this company, he's the underpaid computer wizard in this company.

331
00:21:46,420 --> 00:21:52,150
His supervisor is all Oliver Warbucks, and here's his address.

332
00:21:52,150 --> 00:21:57,300
So the format is we're giving this information: job, salary, supervisor, address.

333
00:21:57,300 --> 00:21:59,250
And there are some other conventions.

334
00:21:59,250 --> 00:22:06,440
Computer here means that Ben works in the computer division, and his position in the computer division is wizard.

335
00:22:06,440 --> 00:22:07,580
Here's somebody else.

336
00:22:07,580 --> 00:22:17,550
Alyssa, Alyssa P. Hacker is a computer programmer, and she works for Ben, and she lives in Cambridge.

337
00:22:17,550 --> 00:22:22,820
And there's another programmer who works for Ben who's Lem E. Tweakit.

338
00:22:22,820 --> 00:22:30,100
And there's a programmer trainee, who is Louis Reasoner, and he works for Alyssa.

339
00:22:30,100 --> 00:22:37,010
And the big wheel of the company doesn't work for anybody, right?

340
00:22:37,010 --> 00:22:38,110
That's Oliver Warbucks.

341
00:22:38,110 --> 00:22:44,971
Anyway, what we're going to do is ask questions about that little world.

342
00:22:44,971 --> 00:22:48,660
And that'll be a sample world that we're going to do logic in.

343
00:22:51,420 --> 00:23:28,500
Let me just write up here, for probably the last time, what I said is the very most important thing you should get out of this course, and that is, when somebody tells you about a language, you say, fine-- what are the primitives, what are the means of combination, how do you put the primitives together, and then how do you abstract them, how do you abstract the compound pieces so you can use them as pieces to make something more complicated?

344
00:23:28,500 --> 00:23:32,690
And we've said this a whole bunch of times already, but it's worth saying again.

345
00:23:36,210 --> 00:23:36,670
Let's start.

346
00:23:36,670 --> 00:23:38,040
The primitives.

347
00:23:38,040 --> 00:23:44,400
Well, there's really only one primitive, and the primitive in this language is called a query.

348
00:23:44,400 --> 00:23:46,810
A primitive query.

349
00:23:46,810 --> 00:23:48,060
Let's look at some primitive queries.

350
00:23:52,160 --> 00:23:53,100
Job x.

351
00:23:53,100 --> 00:23:55,550
Who is a computer programmer?

352
00:23:55,550 --> 00:24:06,640
Or find every fact in the database that matches job of the x is computer programmer.

353
00:24:06,640 --> 00:24:08,470
And you see a little syntax here.

354
00:24:08,470 --> 00:24:21,930
Things without question marks are meant to be literal, question mark x means that's a variable, and this thing will match, for example, the fact that Alyssa P. Hacker is a computer programmer, or x is Alyssa P. Hacker.

355
00:24:26,820 --> 00:24:30,750
Or more generally, I could have something with two variables in it.

356
00:24:30,750 --> 00:24:42,140
I could say, the job of x is computer something, and that'll match computer wizard.

357
00:24:42,140 --> 00:24:50,370
So there's something here: type will match wizard, or type will match programmer, or x might match various certain things.

358
00:24:50,370 --> 00:24:55,150
So there are, in our little example, only three facts in that database that match that query.

359
00:24:59,210 --> 00:25:24,810
Let's see, just to show you some syntax, the same query, this query doesn't match the job of x, doesn't match Lewis Reasoner, the reason for that is when I write something here, what I mean is that this is going to be a list of two symbols, of which the first is the word computer, and the second can be anything.

360
00:25:24,810 --> 00:25:30,340
And Lewis's job description here has three symbols, so it doesn't match.

361
00:25:30,340 --> 00:25:50,600
And just to show you a little bit of syntax, the more general thing I might want to type is a thing with a dot here, and this is just standard this notation for saying, this is a list, of which the first element is the word computers, and THE REST, is something that I'll call type.

362
00:25:53,730 --> 00:25:56,930
So this one would match.

363
00:25:56,930 --> 00:26:06,960
Lewis's job is computer programmer trainee, and type here would be the cdr of this list. It would be the list programmer trainee.

364
00:26:06,960 --> 00:26:10,460
And that kind of dot processing is done automatically by the LISP reader.

365
00:26:15,900 --> 00:26:17,760
Well, let's actually try this.

366
00:26:17,760 --> 00:26:23,630
The idea is I'm going to type in queries in this language, and answers will come out.

367
00:26:23,630 --> 00:26:25,180
Let's look at this.

368
00:26:25,180 --> 00:26:30,000
I can go up and say, who works in the computer division?

369
00:26:30,000 --> 00:26:39,730
Job of x is computer dot y.

370
00:26:39,730 --> 00:26:42,562
Doesn't matter what I call the dummy variables.

371
00:26:42,562 --> 00:26:45,690
It says the answers to that, and it's found four answers.

372
00:26:48,650 --> 00:26:52,505
Or I can go off and say, tell me about everybody's supervisor.

373
00:26:52,505 --> 00:26:59,390
So I'll put in the query, the primitive query, the supervisor of x is y.

374
00:27:02,860 --> 00:27:05,540
There are all the supervisor relationships I know.

375
00:27:05,540 --> 00:27:08,830
Or I could go type in, who lives in Cambridge?

376
00:27:08,830 --> 00:27:20,670
So I can say, the address of x is Cambridge dot anything.

377
00:27:25,090 --> 00:27:26,585
And only one person lives in Cambridge.

378
00:27:30,820 --> 00:27:32,170
OK, so those are primitive queries.

379
00:27:32,170 --> 00:27:39,620
And you see what happens to basic interaction with the system is you type in a query, and it types out all possible answers.

380
00:27:39,620 --> 00:28:01,000
Or another way to say that: it finds out all the possible values of those variables x and y or t or whatever I've called them, and it types out all ways of taking that query and instantiating it-- remember that from the rule system lecture-- instantiates the query with all possible values for those variables and then types out all of them.

381
00:28:01,000 --> 00:28:03,350
And there are a lot of ways you can arrange a logic language.

382
00:28:03,350 --> 00:28:06,010
Prolog, for instance, does something slightly different.

383
00:28:06,010 --> 00:28:12,650
Rather than typing back your query, prolog would type out, x equals this and y equals that, or x sequels this and y equals that.

384
00:28:12,650 --> 00:28:19,070
And that's a very surface level thing, you can decide what you like.

385
00:28:19,070 --> 00:28:20,760
OK.

386
00:28:20,760 --> 00:28:21,340
All right.

387
00:28:21,340 --> 00:28:23,390
So the primitives in this language?

388
00:28:23,390 --> 00:28:24,570
Only one, right?

389
00:28:24,570 --> 00:28:27,230
Primitive query.

390
00:28:31,360 --> 00:28:31,650
OK.

391
00:28:31,650 --> 00:28:34,330
Means of combination.

392
00:28:34,330 --> 00:28:39,770
Let's look at some compound queries in this language.

393
00:28:39,770 --> 00:28:41,790
Here's one.

394
00:28:41,790 --> 00:28:49,810
This one says, tell me all the people who work in the computer division.

395
00:28:49,810 --> 00:28:53,860
Tell me all the people who work in the computer division together with their supervisors.

396
00:28:56,800 --> 00:29:00,220
The way I write that is the query is and.

397
00:29:00,220 --> 00:29:04,920
And the job of the x is computer something or other.

398
00:29:04,920 --> 00:29:07,560
And job of x is computer dot y.

399
00:29:07,560 --> 00:29:11,650
And the supervisor of x is z.

400
00:29:11,650 --> 00:29:16,460
Tell me all the people in the computer division-- that's this-- together with their supervisors.

401
00:29:16,460 --> 00:29:23,660
And notice in this query I have three variables-- x, y, and z.

402
00:29:23,660 --> 00:29:29,450
And this x is supposed to be the same as that x.

403
00:29:29,450 --> 00:29:34,810
So x works in the computer division, and the supervisor of x is z.

404
00:29:34,810 --> 00:29:37,250
Let's try another one.

405
00:29:37,250 --> 00:29:39,005
So one means of combination is and.

406
00:29:41,540 --> 00:29:45,790
Who are all the people who make more than $30,000?

407
00:29:45,790 --> 00:29:51,640
And the salary of some person p is some amount a.

408
00:29:54,590 --> 00:30:00,600
And when I go and look at a, a is greater than $30,000.

409
00:30:00,600 --> 00:30:10,600
And LISP value here is a little piece of interface that interfaces the query language to the underlying LISP.

410
00:30:10,600 --> 00:30:17,180
And what the LISP value allows you to do is call any LISP predicate inside a query.

411
00:30:17,180 --> 00:30:21,020
So here I'm using the LISP predicate greater than, so I say LISP value.

412
00:30:21,020 --> 00:30:21,750
This I say and.

413
00:30:21,750 --> 00:30:28,190
So all the people whose salary is greater than $30,000.

414
00:30:28,190 --> 00:30:31,270
Or here's a more complicated one.

415
00:30:31,270 --> 00:30:39,810
Tell me all the people who work in the computer division who do not have a supervisor who works in the computer division.

416
00:30:42,790 --> 00:30:45,510
and x works in the computer division.

417
00:30:45,510 --> 00:30:47,780
The job of x is computer dot y.

418
00:30:47,780 --> 00:30:59,620
And it's not the case that both x has a supervisor z and the job of z is computer something or other.

419
00:30:59,620 --> 00:31:05,710
All right, so again, this x has got to be that x, and this z is going to be that z.

420
00:31:09,390 --> 00:31:11,380
And then you see another means a combination, not.

421
00:31:17,272 --> 00:31:20,880
All right, well, let's look at that.

422
00:31:20,880 --> 00:31:22,400
It works the same way.

423
00:31:22,400 --> 00:31:35,400
I can go up to the machine and say and the job of the x is computer dot y.

424
00:31:38,480 --> 00:31:46,600
And the supervisor of x is z.

425
00:31:46,600 --> 00:31:50,794
And I typed that in like a query.

426
00:31:50,794 --> 00:31:58,930
And what it types back, what you see are the queries I typed in instantiated by all possible answers.

427
00:31:58,930 --> 00:32:02,000
And then you see there are a lot of answers.

428
00:32:02,000 --> 00:32:02,190
All right.

429
00:32:02,190 --> 00:32:09,800
So the means of combination in this language-- and this is why it's called a logic language-- are logical operations.

430
00:32:09,800 --> 00:32:18,490
Means of combinations are things like AND and NOT and there's one I didn't show you, which is OR.

431
00:32:18,490 --> 00:32:29,250
And then I showed you LISP value, which is not logic, of course, but is a little special hack to interface that to LISP so you can get more power.

432
00:32:29,250 --> 00:32:32,690
Those are the means of combination.

433
00:32:32,690 --> 00:32:34,160
OK, the means of abstraction.

434
00:32:34,160 --> 00:32:42,260
What we'd like to do--  let's go back for second and look at that last slide.

435
00:32:42,260 --> 00:32:52,400
We might like to take very complicated thing, the idea that someone works in a division but does not have a supervisor in the division.

436
00:32:52,400 --> 00:32:56,090
And as before, name that.

437
00:32:56,090 --> 00:33:02,750
Well, if someone works in a division and does not have a supervisor who works in that division, that means that person is a big shot.

438
00:33:02,750 --> 00:33:21,510
So let's make a rule that somebody x is a big shot in some department if x works in the department and it's not the case that x has a supervisor who works in the department.

439
00:33:21,510 --> 00:33:22,940
So this is our means of abstraction.

440
00:33:22,940 --> 00:33:24,190
This is a rule.

441
00:33:26,220 --> 00:33:27,580
And a rule has three parts.

442
00:33:30,970 --> 00:33:33,450
The thing that says it's a rule.

443
00:33:33,450 --> 00:33:37,530
And then there's the conclusion of the rule.

444
00:33:37,530 --> 00:33:40,000
And then there's the body of the rule.

445
00:33:40,000 --> 00:33:49,470
And you can read this as a piece of logic which says, if you know that the body of the rule is true, then you can conclude that the conclusion is true.

446
00:33:49,470 --> 00:33:57,480
Or in order to deduce that x is a big shot in some department, it's enough to verify that.

447
00:33:57,480 --> 00:33:58,820
So that's what rules look like.

448
00:34:03,280 --> 00:34:08,110
Let's go back and look at that merge example that I did before the break.

449
00:34:08,110 --> 00:34:11,610
Let's look at how that would look in terms of rules.

450
00:34:11,610 --> 00:34:15,500
I'm going to take the logic I put up and just change it into a bunch of rules in this format.

451
00:34:18,739 --> 00:34:19,350
We have a rule.

452
00:34:19,350 --> 00:34:21,710
Remember, there was this thing merge-to-form.

453
00:34:21,710 --> 00:34:29,620
There is a rule that says, the empty list and y merge to form y.

454
00:34:29,620 --> 00:34:30,870
This is the rule conclusion.

455
00:34:33,210 --> 00:34:36,650
And notice this particular rule has no body.

456
00:34:36,650 --> 00:34:41,239
And in this language, a rule with no body is something that is always true.

457
00:34:41,239 --> 00:34:42,510
You can always assume that's true.

458
00:34:45,190 --> 00:34:49,460
And there was another piece of logic that said anything in the empty list merged to form the anything.

459
00:34:49,460 --> 00:34:50,900
That's this.

460
00:34:50,900 --> 00:34:55,510
A rule y and the empty list merge to form y.

461
00:34:55,510 --> 00:35:03,490
Those corresponded to the two end cases in our merge procedure, but now we're talking about logic, not about procedures.

462
00:35:03,490 --> 00:35:09,830
Then we had another rule, which said if you know how shorter things merge, you can put them together.

463
00:35:09,830 --> 00:35:48,690
So this says, if you have a list x and y and z, and if you want to deduce that a dot x-- this means constant a onto x, or a list whose first thing is a and whose rest is x-- so if you want to deduce that a dot x and b dot y merge to form b dot c--  that would say you merge these two lists a x and b y and you're going to get something that starts with b-- you can deduce that if you know that it's the case both that a dot x and y merge to form z and a is larger than b.

464
00:35:48,690 --> 00:35:57,960
So when I merge them, b will come first in the list. That's a little translation of the logic rule that I wrote in pseudo-English before.

465
00:35:57,960 --> 00:36:03,130
And then just for completeness, here's the other case.

466
00:36:03,130 --> 00:36:12,190
a dot x and b dot y merge to form a dot z if x and b dot y merged to form z and b is larger than a.

467
00:36:12,190 --> 00:36:17,416
So that's a little program that I've typed in in this language, and now let's look at it run.

468
00:36:21,900 --> 00:36:28,510
So I typed in the merge rules before, and I could use this like a procedure.

469
00:36:28,510 --> 00:36:39,590
I could say merge to form 1 and 3 and 2 and 7.

470
00:36:39,590 --> 00:36:43,330
So here I'm using it like the LISP procedure.

471
00:36:43,330 --> 00:36:48,190
Now it's going to think about that for a while and apply these rules.

472
00:36:50,780 --> 00:36:52,800
So it found an answer.

473
00:36:52,800 --> 00:36:57,810
Now it's going to see if there are any other answers but it doesn't know a priori there's only one answer.

474
00:36:57,810 --> 00:37:01,970
So it's sitting here checking all possibilities, and it says, no more.

475
00:37:01,970 --> 00:37:02,775
Done.

476
00:37:02,775 --> 00:37:05,210
So there I've used those rules like a procedure.

477
00:37:05,210 --> 00:37:10,220
Or remember the whole point is that I can ask different kinds of questions.

478
00:37:10,220 --> 00:37:24,590
I could say merge to form, let's see, how about 2 and a.

479
00:37:24,590 --> 00:37:39,510
Some list of two elements which I know starts with 2, and the other thing I don't know, and x and some other list merge to form a 1, 2, 3 and 4.

480
00:37:42,760 --> 00:37:44,590
So now it's going to think about that.

481
00:37:44,590 --> 00:37:49,095
It's got to find--  so it found one possibility.

482
00:37:49,095 --> 00:37:53,830
It said a could be 3, and x could be the list 1, 4.

483
00:37:53,830 --> 00:38:00,300
And now, again, it's got to check because it doesn't a priori know that there aren't any other possibilities going on.

484
00:38:03,680 --> 00:38:17,275
Or like I said, I could say something like merge to form, like, what and what else merge to form 1, 2, 3, 4, 5?

485
00:38:24,340 --> 00:38:25,590
Now it's going to think about that.

486
00:38:28,490 --> 00:38:30,310
And there are a lot of answers that it might get.

487
00:38:35,180 --> 00:38:39,170
And what you see is here you're really paying the price of slowness.

488
00:38:42,210 --> 00:38:43,880
And kind of for three reasons.

489
00:38:43,880 --> 00:38:47,630
One is that this language is doubly interpreted.

490
00:38:47,630 --> 00:38:52,190
Whereas in a real implementation, you would go compile this down to primitive operations.

491
00:38:52,190 --> 00:38:58,380
The other reason is that this particular algorithm for merges is doubly recursive.

492
00:38:58,380 --> 00:39:01,020
So it's going to take a very long time.

493
00:39:01,020 --> 00:39:07,130
And eventually, this is going to go through and find-- find what?

494
00:39:07,130 --> 00:39:08,730
Two to the fifth possible answers.

495
00:39:12,140 --> 00:39:20,160
And you see they come out in some fairly arbitrary order, depending on which order it's going to be trying these rules.

496
00:39:20,160 --> 00:39:24,310
In fact, what we're going to do when they edit the videotape is speed all this up.

497
00:39:24,310 --> 00:39:26,600
Don't you like taking out these weights?

498
00:39:26,600 --> 00:39:28,250
And don't you wish you could do that in your demos?

499
00:39:32,840 --> 00:39:34,260
Anyway, it's still grinding there.

500
00:39:39,220 --> 00:39:42,630
Anyway, there are 32 possibilities-- we won't wait for it to print out all of them.

501
00:39:47,850 --> 00:39:50,660
OK, so the needs of abstraction in this language are rules.

502
00:39:53,630 --> 00:40:00,350
So we take some bunch of things that are put together with logic and we name them.

503
00:40:00,350 --> 00:40:03,410
And you can think of that as naming a particular pattern of logic.

504
00:40:03,410 --> 00:40:10,660
Or you can think of that as saying, if you want to deduce some conclusion, you can apply those rules of logic.

505
00:40:10,660 --> 00:40:13,420
And those are three elements of this language.

506
00:40:13,420 --> 00:40:16,920
Let's break now, and then we'll talk about how it's actually implemented.

507
00:40:22,747 --> 00:40:31,770
STUDENT: Does using LISP value primitive or whatever interfere with your means to go both directions on a query?

508
00:40:31,770 --> 00:40:40,090
PROFESSOR: OK, that's a-- the question is, does using LISP value interfere with the ability to go both directions on the query?

509
00:40:40,090 --> 00:40:46,890
We haven't really talked about the implementation yet, but the answer is, yes, it can.

510
00:40:46,890 --> 00:41:08,700
In general, as we'll see at the end-- although I really won't to go into details-- it's fairly complicated, especially when you use either not or LISP value-- or actually, if you use anything besides only and, it becomes very complicated to say when these things will work.

511
00:41:08,700 --> 00:41:10,360
They won't work quite in all situations.

512
00:41:10,360 --> 00:41:14,300
I'll talk about that at the end of the second half today.

513
00:41:14,300 --> 00:41:24,170
But the answer to your question is, yes, by dragging in a lot more power from LISP value, you lose some of the principal power of logic programming.

514
00:41:24,170 --> 00:41:28,090
That's a trade-off that you have to make.

515
00:41:28,090 --> 00:41:30,390
OK, let's take a break.

