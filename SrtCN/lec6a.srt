1
00:00:18,550 --> 00:00:21,840
上次Gerry教授揭晓了秘密
PROFESSOR: Well, last time Gerry really let the cat out of the bag.

2
00:00:22,496 --> 00:00:24,608
他介绍了赋值的概念
He introduced the idea of assignment.

3
00:00:26,350 --> 00:00:33,616
赋值与状态
Assignment and state.

4
00:00:37,480 --> 00:00:40,032
正如我们所见
And as we started to see, the implications

5
00:00:40,720 --> 00:00:44,416
#TBD
of introducing assignment and state into the language are absolutely frightening.

6
00:00:45,088 --> 00:00:48,624
首先 代换模型不再能够描述求值过程了
First of all, the substitution model of evaluation breaks down.

7
00:00:49,136 --> 00:00:52,480
我们不得不使用更为复杂的环境模型
And we have to use this much more complicated environment model

8
00:00:52,480 --> 00:00:54,272
这种带图示的机械式的东西#TBD
this very mechanistic thing with diagrams,

9
00:00:54,288 --> 00:00:57,248
#TBD
even to say what statements in the programming language mean.

10
00:00:58,464 --> 00:01:00,128
这不仅仅是技术上的一点 #TBD
And that's not a mere technical point.

11
00:01:00,260 --> 00:01:03,280
代换模型在这里完全失效了
See, it's not that we had this particular substitution model and,

12
00:01:03,600 --> 00:01:05,680
我们得想些其它办法
well, it doesn't quite work, so we have to do something else.

13
00:01:05,712 --> 00:01:09,792
代换模型什么都做不了
It's that nothing like the substitution model can work.

14
00:01:10,730 --> 00:01:16,928
因为突然地 一个变量不再是代表着一个值了
Because suddenly, a variable is not just something that stands for a value.

15
00:01:17,952 --> 00:01:23,344
变量现在用来指定一个存放值的位置
A variable now has to somehow specify a place that holds a value.

16
00:01:23,630 --> 00:01:26,144
并且在这个位置的值是可以变的
And the value that's in that place can change.

17
00:01:30,280 --> 00:01:34,096
比如像(F X)这样的表达式
Or for instance, an expression like f of x

18
00:01:37,360 --> 00:01:39,648
就可能含有副作用
might have a side effect in it.

19
00:01:40,410 --> 00:01:42,608
如果我们执行(F X)得到某个值
So if we say f of x and it has some value,

20
00:01:43,184 --> 00:01:45,344
之后我们再次执行(F X)
and then later we say f of x again,

21
00:01:47,248 --> 00:01:49,730
可能因为求值的顺序而得到不同的值
we might get a different value depending on the order.

22
00:01:49,730 --> 00:01:52,144
所以突然间 我们不能仅仅关注于值
So suddenly, we have to think not only about values

23
00:01:52,528 --> 00:01:53,600
也要关注时间
but about time.

24
00:01:57,970 --> 00:02:02,520
序对也不仅仅只是CAR和CDR了部分
And then things like pairs are no longer just their CARs and their CDRs.

25
00:02:02,520 --> 00:02:05,616
#TBD
A pair now is not quite its CAR and its CDR.

26
00:02:05,808 --> 00:02:07,056
#TBD
It's rather its identity.

27
00:02:08,449 --> 00:02:11,650
序对具有“身份”
So a pair has identity.

28
00:02:11,650 --> 00:02:12,592
它是一个对象
It's an object.

29
00:02:21,330 --> 00:02:25,152
两个具有相同CAR和CDR部分的序对
And two pairs that have the same CAR and CDR

30
00:02:25,408 --> 00:02:27,056
可能相同也可能不同
well, might be the same or different,

31
00:02:27,872 --> 00:02:30,512
因为这之中可能存在“共享”
because suddenly we have to worry about sharing.

32
00:02:34,960 --> 00:02:39,456
一引入赋值 这些就变成要考虑的问题了
So all of these things enter as soon as we introduce assignment.

33
00:02:40,480 --> 00:02:43,984
确实 这和我们说讲代换的时候差别悬殊
See, this is a really far cry from where we started with substitution.

34
00:02:45,040 --> 00:02:48,912
技术上来看 我们思考起来更加困难了
It's a technically harder way of looking at things

35
00:02:48,940 --> 00:02:53,456
因为我们必须相加机械地思考程序语言
because we have to think more mechanistically about our programming language.

36
00:02:53,472 --> 00:02:55,344
而不能仅仅用数学的方式来思考
We can't just think about it as mathematics.

37
00:02:55,710 --> 00:02:58,608
我们也会遇到哲学问题
It's philosophically harder,

38
00:02:59,152 --> 00:03:00,656
我们会被这样的问题所困扰：
because suddenly there are all these funny issues

39
00:03:00,672 --> 00:03:02,384
事物的“改变”指的是什么？
what does it mean that something changes

40
00:03:02,384 --> 00:03:03,776
两个事物“同一”又如何判别？
or that two things are the same.

41
00:03:03,840 --> 00:03:06,832
并且 这也会给我们编程带来困扰
And also, it's programming harder, because

42
00:03:07,470 --> 00:03:08,544
正如Sussman教授上节课中讲的那样
as Gerry showed last time,

43
00:03:08,560 --> 00:03:12,200
错误的序列和别名会产生BUG
there are all these bugs having to do with bad sequencing and aliasing

44
00:03:12,224 --> 00:03:16,190
这些问题在不需要考虑“对象”的语言中 是不存在的
that just don't exist in a language where we don't worry about objects.

45
00:03:18,210 --> 00:03:21,200
我们是怎样陷入这样的困境的呢？
Well, how'd we get into this mess?

46
00:03:24,010 --> 00:03:27,200
我们这样做的原因在于
Remember what we did, the reason we got into this is

47
00:03:27,408 --> 00:03:31,472
我们想要构造模块化的系统
because we were looking to build modular systems.

48
00:03:35,152 --> 00:03:41,040
我们想把系统划分为数个自然组合的小块
We wanted to build systems that fall apart into chunks that seem natural.

49
00:03:42,760 --> 00:03:46,112
举例来说 我们构造一个随机数发生器
So for instance, we want to take a random number generator

50
00:03:46,224 --> 00:03:49,408
把该发生器的内部状态封装起来
and package up the state of that random number generator inside of it

51
00:03:50,256 --> 00:03:53,712
这样我们就可以把选取随机数
so that we can separate the idea of picking random numbers

52
00:03:54,656 --> 00:03:57,792
和用于估计的蒙特卡洛方法分离开来 #TBD
from the general Monte Carlo strategy of estimating something

53
00:03:58,650 --> 00:04:01,520
#TBD
and separate that from the particular way that you

54
00:04:01,904 --> 00:04:05,744
#TBD
work with random numbers in that formula developed by Cesaro for pi.

55
00:04:06,800 --> 00:04:07,920
相似地
And similarly,

56
00:04:09,616 --> 00:04:11,744
当我们着手构建事物的模型时
when we go off and construct some models of things,

57
00:04:12,352 --> 00:04:16,016
我们去构建现实世界中事物的模型
Ah, if we go off and model a system that we see in the real world,

58
00:04:17,310 --> 00:04:19,424
我们想把程序组织成许多自然的部分#TBD
we'd like our program to break into natural pieces,

59
00:04:19,440 --> 00:04:23,160
这些部分就是现实事物的镜像
pieces that mirror the parts of the system that we see in the real world.

60
00:04:24,900 --> 00:04:27,568
举个例子 对于一个数字电路
So for example, if we look at a digital circuit,

61
00:04:28,368 --> 00:04:29,184
我们会说
we say, gee,

62
00:04:30,440 --> 00:04:31,440
这儿有一个电路
there's a circuit

63
00:04:32,080 --> 00:04:35,160
它有一个这样的元件 有一个那样的元件
and it has a piece and it has another piece.

64
00:04:40,100 --> 00:04:43,580
这些元件都有不同的“身份”
And these different pieces sort of have identity.

65
00:04:43,580 --> 00:04:44,592
它们都有各自的状态
They have state.

66
00:04:45,550 --> 00:04:47,136
状态附着在电路上
And the state sits on these wires.

67
00:04:48,580 --> 00:04:51,936
我们认为这两个元件是不同的对象
And we think of this piece as an object that's different from that as an object.

68
00:04:52,540 --> 00:04:53,856
当我们观察到系统发生了变化
And when we watch the system change,

69
00:04:53,872 --> 00:04:55,408
信号从这里传递过来
we think about a signal coming in here

70
00:04:55,632 --> 00:04:58,416
改变了可能存放在这里的状态 并向这里继续传播
changing a state that might be here and going here

71
00:04:58,672 --> 00:05:00,752
和一个存储在这里的状态交互
and interacting with a state that might be stored there,

72
00:05:01,248 --> 00:05:02,170
依次类推
and so on and so on.

73
00:05:06,860 --> 00:05:11,248
我们想要在计算机中
So what we'd like is we'd like to build in the computer

74
00:05:12,768 --> 00:05:14,368
构建模块化的系统
systems that fall into pieces

75
00:05:14,688 --> 00:05:17,872
来反映我们对现实的看法
that fall into pieces that mirror our view of reality,

76
00:05:17,888 --> 00:05:20,912
#TBD
of the way that the actual systems we're modeling seem to fall into pieces.

77
00:05:23,200 --> 00:05:23,488
然而
Well,

78
00:05:25,744 --> 00:05:28,992
构建像这样的系统
maybe the reason that building systems like this

79
00:05:28,992 --> 00:05:31,504
看起来带来了不少技术上的麻烦
seems to introduce such technical complications

80
00:05:31,520 --> 00:05:32,752
但这不是计算机造成的
has nothing to do with computers.

81
00:05:33,610 --> 00:05:35,600
或许 我们花了那么大的功夫
See, maybe the real reason

82
00:05:36,704 --> 00:05:40,944
才让程序反映现实世界的真正原因
that we pay such a price to write programs that mirror our view of reality

83
00:05:41,520 --> 00:05:43,136
是因为我们对现实世界的认识出了错
is that we have the wrong view of reality.

84
00:05:44,550 --> 00:05:46,752
或许时间只是幻觉
See, maybe time is just an illusion,

85
00:05:47,264 --> 00:05:48,608
什么都没有改变
and nothing ever changes.

86
00:05:50,150 --> 00:05:51,712
就拿这个粉笔来说
See, for example, if I take this chalk,

87
00:05:52,448 --> 00:05:53,776
我们认为它是一个对象
and we say, gee, this is an object

88
00:05:54,016 --> 00:05:54,992
它有自己的状态
and it has a state.

89
00:05:55,820 --> 00:05:59,296
每时每刻 它都有一个位置与速度
At each moment it has a position and a velocity.

90
00:05:59,710 --> 00:06:01,488
如果我们做点什么 就可以改变它的状态
And if we do something, that state can change.

91
00:06:04,340 --> 00:06:07,376
但是你如果了解一点相对性的概念
But if you studied any relativity, for instance,

92
00:06:07,744 --> 00:06:09,712
你可能不会认为粉笔的路径
you know that you don't think of the path of that chalk

93
00:06:09,728 --> 00:06:11,340
是某种东西随着时间运动而形成的#TBD
as something that goes on instant by instant.

94
00:06:11,340 --> 00:06:15,664
把整个粉笔的存在认为是时空中的路径，这是很有洞察力的 #TBD
It's more insightful to think of that whole chalk's existence as a path in space-time.

95
00:06:16,020 --> 00:06:17,376
全部都展开了
that's all splayed out.

96
00:06:17,872 --> 00:06:19,840
没有单独的位置与速度
There aren't individual positions and velocities.

97
00:06:19,840 --> 00:06:23,808
只有在时空中不变的存在 #TBD
There's just its unchanging existence in space-time.

98
00:06:24,640 --> 00:06:26,512
相似地 如果我们来考察这个电气系统
Similarly, if we look at this electrical system,

99
00:06:27,690 --> 00:06:30,432
我们假设这个系统实现的是
if we imagine this electrical system is implementing

100
00:06:30,592 --> 00:06:33,960
某种信号处理系统
sort of signal processing system,

101
00:06:34,368 --> 00:06:36,688
#TBD
the signal processing engineer who put that thing together

102
00:06:36,750 --> 00:06:41,408
#TBD
doesn't think of it as, well, at each instance there's a voltage coming in.

103
00:06:41,490 --> 00:06:43,168
转换成了某种东西
And that translates into something.

104
00:06:43,340 --> 00:06:45,520
影响了这里的状态
And that affects the state over here,

105
00:06:45,536 --> 00:06:46,810
还改变了那里的状态
which changes the state over here.

106
00:06:46,810 --> 00:06:50,112
没有一个做信号处理的会这样想
Nobody putting together a signal processing system thinks about it like that.

107
00:06:50,420 --> 00:06:51,840
相反 你会说
Instead, you say there's this signal

108
00:06:54,048 --> 00:06:58,060
这里有一个在时间上伸展的信号
that's splayed out over time.

109
00:06:58,060 --> 00:06:59,488
如果把这个看做一个滤波器
And if this is acting as a filter,

110
00:07:00,208 --> 00:07:04,048
这个滤波器会把整个信号转化成
this whole thing transforms this whole thing

111
00:07:04,288 --> 00:07:07,040
不同的输出信号
for some sort of other output.

112
00:07:09,570 --> 00:07:13,296
你不必考虑在某个时间点上事物的状态#TBD
You don't think of it as what's happening instant by instant as the state of these things.

113
00:07:14,160 --> 00:07:17,328
我们把这个盒子看做一个整体
And somehow you think of this box as a whole thing,

114
00:07:17,328 --> 00:07:21,968
而不是在某些个特定时间的状态的集合 #TBD
not as little pieces sending messages of state to each other at particular instants.

115
00:07:28,250 --> 00:07:31,136
今天我们将介绍另一种分解系统的方法
Well, today we're going to look at another way to decompose systems

116
00:07:31,360 --> 00:07:35,456
站在信号工程师的角度去看待现实世界
that's more like the signal processing engineer's view of the world

117
00:07:35,696 --> 00:07:38,960
而不再认为对象间通过消息传递来通信
than it is like thinking about objects that communicate sending messages.

118
00:07:41,130 --> 00:07:43,744
它被称为“流处理”
That's called stream processing.

119
00:07:54,570 --> 00:07:58,960
我们打算展示
And we're going to start by showing

120
00:08:00,592 --> 00:08:04,160
如何让我们的程序变得更加统一
by showing how we can make our programs more uniform

121
00:08:05,152 --> 00:08:06,544
从中看到更多的共性
and see a lot more commonality

122
00:08:06,656 --> 00:08:09,888
如果我们跳出这些程序 #TBD
if we throw out of these programs

123
00:08:10,816 --> 00:08:12,304
我们会发现
what you might say is a

124
00:08:12,352 --> 00:08:15,120
#TBD
inordinate concern with worrying about time.

125
00:08:16,896 --> 00:08:20,224
我们先来对比两个过程
Let me start by comparing two procedures.

126
00:08:23,552 --> 00:08:25,690
第一个是这样
The first one does this.

127
00:08:25,690 --> 00:08:27,770
想像这有一个树
We imagine that there's a tree.

128
00:08:30,400 --> 00:08:32,144
一个由整数构成的树
Say there's a tree of integers.

129
00:08:33,280 --> 00:08:34,420
一个二叉树
It's a binary tree.

130
00:08:39,100 --> 00:08:40,230
看起来就像这样
So it looks like this.

131
00:08:40,230 --> 00:08:42,928
在每个节点上都有一个整数
And there's integers in each of the nodes.

132
00:08:45,184 --> 00:08:47,808
我们想计算
And what we would like to compute is

133
00:08:48,672 --> 00:08:51,568
对这个树中所有的奇数
for each odd number sitting here,

134
00:08:52,304 --> 00:08:55,104
计算它们的平方和
we'd like to find the square and then sum up all those squares.

135
00:08:57,056 --> 00:08:59,480
我们对这类问题很熟悉
Well, that should be a familiar kind of thing.

136
00:08:59,480 --> 00:09:01,952
有一种递归策略求解它
There's a recursive strategy for doing it.

137
00:09:02,930 --> 00:09:04,352
观察每个叶子节点
We look at each leaf, and either

138
00:09:04,560 --> 00:09:06,688
如果是奇数我们就求它的平方 并加和
it's going to contribute the square of the number if it's odd

139
00:09:06,704 --> 00:09:07,770
如果是偶数 就是0
or 0 if it's even.

140
00:09:08,680 --> 00:09:12,112
递归地看 对于每一颗树 我们可以说
And then recursively, we can say at each tree

141
00:09:12,656 --> 00:09:13,840
它的平方和等于
the sum of all of them is

142
00:09:13,920 --> 00:09:15,936
右子树的平方和 加上左子树的平方和
the sum coming from the right branch and the left branch,

143
00:09:16,256 --> 00:09:17,640
就这样沿着节点递归下去
and recursively down through the nodes.

144
00:09:17,640 --> 00:09:20,360
这种思考方式我们已经很熟悉了
And that's a familiar way of thinking about programming.

145
00:09:20,360 --> 00:09:22,592
我们在幻灯片上看一下这个
Let's actually look at that on the slide.

146
00:09:23,820 --> 00:09:26,752
为了计算一棵树中奇数的平方和
We say to sum the odd squares in a tree,

147
00:09:27,376 --> 00:09:29,360
我们先要判断它是否是一个叶子节点
there's a test. Either it's a leaf node,

148
00:09:29,824 --> 00:09:31,952
判断方法则是考察该节点是否为整数
and we're going to check to see if it's an integer,

149
00:09:32,880 --> 00:09:36,384
继而判断其奇偶性 以及是否应该求取平方并加和
and then either it's odd, in which we take the square, or else it's 0.

150
00:09:37,160 --> 00:09:38,992
然后 整个的解就是
And then the sum of the whole thing

151
00:09:39,216 --> 00:09:42,120
左、右子树解的总和
is the sum coming from the left branch and the right branch.

152
00:09:46,340 --> 00:09:50,560
好的 让我们再来和下面一个问题对比一下
OK, well, let me contrast that with a second problem.

153
00:09:51,560 --> 00:09:53,680
假如给你一个整数N
Suppose I give you an integer n,

154
00:09:54,736 --> 00:09:57,888
再给定一个函数 把它应用在
and then some function to compute of the first of each integer

155
00:09:57,936 --> 00:09:58,832
1到N的每一个数上
1 through n.

156
00:09:59,100 --> 00:10:01,088
我想把其中的一些值收集成一个表
And then I want to collect together in a list

157
00:10:01,280 --> 00:10:04,656
那些满足某种属性的函数值
all those function values that satisfy some property.

158
00:10:05,600 --> 00:10:06,880
这是种一般性的说法
That's a general kind of thing.

159
00:10:06,880 --> 00:10:07,984
说得更具体一点
Let's say to be specific,

160
00:10:08,624 --> 00:10:10,480
假设对于每个整数K
let's imagine that for each integer, k,

161
00:10:10,656 --> 00:10:12,512
计算第K个斐波那契数
we're going to compute the k Fibonacci number.

162
00:10:14,210 --> 00:10:16,272
然后挑出其中的奇数
And then we'll see which of those are odd

163
00:10:16,832 --> 00:10:18,400
并把它们组成一个表
and assemble those into a list.

164
00:10:19,050 --> 00:10:20,710
这个过程是这样的
So here's a procedure that does that.

165
00:10:23,730 --> 00:10:26,240
寻找前N个斐波那契数中的奇数
Find the odd Fibonacci numbers among the first n.

166
00:10:26,240 --> 00:10:28,910
这里是我们一直以来采用的循环方法
And here is a standard loop the way we've been writing it.

167
00:10:28,910 --> 00:10:29,824
用到了递归
This is a recursion.

168
00:10:30,800 --> 00:10:31,792
以K为循环变量
It's a loop on k,

169
00:10:32,032 --> 00:10:34,352
如果K大于N 返回空表
and says if k is bigger than n, it's the empty list.

170
00:10:35,136 --> 00:10:37,360
否则计算第K个斐波那契数
Otherwise we compute the k-th Fibonacci number,

171
00:10:37,440 --> 00:10:38,064
将其与变量F绑定
call that f.

172
00:10:40,370 --> 00:10:46,016
如果是奇数 我们把它与从K+1计算得到的表相连接
If it's odd, we CONS it on to the list starting with the next one.

173
00:10:47,690 --> 00:10:50,128
否则 我们只取从K+1计算得到的结果
And otherwise, we just take the next one.

174
00:10:50,736 --> 00:10:53,000
这是迭代式循环的标准写法
And this is the standard way we've been writing iterative loops.

175
00:10:53,000 --> 00:10:55,568
我们以1为初值 启动这个循环
And we start off calling that loop with 1.

176
00:10:57,584 --> 00:11:00,064
好的 就是这两个过程
OK, so there are two procedures.

177
00:11:01,600 --> 00:11:02,900
它们看起来非常不同
Those procedures look very different.

178
00:11:02,900 --> 00:11:04,208
完全不同的结构
They have very different structures.

179
00:11:04,250 --> 00:11:06,896
然而 从一个特定的角度来看
Yet from a certain point of view,

180
00:11:06,928 --> 00:11:09,616
两个过程做的事情是一样的
those procedures are really doing very much the same thing.

181
00:11:11,330 --> 00:11:14,672
如果我是一个信号处理工程师
So if I was talking like a signal processing engineer,

182
00:11:14,704 --> 00:11:16,816
我可能会说
what I might say

183
00:11:18,240 --> 00:11:26,768
第一个过程枚举了树的叶节点
the first procedure enumerates the leaves of a tree.

184
00:11:31,160 --> 00:11:34,560
可以认为是信号从一个全是叶节点的地方输出
And then we can think of a signal coming out of that, which is all the leaves.

185
00:11:35,330 --> 00:11:43,392
我们想要过滤出其中的奇数
We'll filter them to see which ones are odd,

186
00:11:43,584 --> 00:11:44,944
把它们放入某种滤波器中
put them through some kind of filter.

187
00:11:45,190 --> 00:11:47,792
然后再把它们放入某种换能器
We'll then put them through a kind of transducer.

188
00:11:49,200 --> 00:11:51,696
对每一个输出 我们对其取平方
And for each one of those things, we'll take the square.

189
00:11:54,448 --> 00:11:57,440
最后把结果累积在一起
And then we'll accumulate all of those.

190
00:11:58,290 --> 00:12:00,048
我们以0为初值
We'll accumulate them by sticking them together

191
00:12:00,352 --> 00:12:03,370
通过加法把它们累积起来
with addition starting from 0.

192
00:12:07,140 --> 00:12:08,210
这是第一个程序
That's the first program.

193
00:12:08,210 --> 00:12:09,184
对于第二个程序
The second program,

194
00:12:09,248 --> 00:12:11,216
我也可以用一种非常类似的方法来描述
I can describe in a very, very similar way.

195
00:12:11,780 --> 00:12:13,424
我们枚举
I'll say, we'll enumerate

196
00:12:15,808 --> 00:12:19,104
从1到N这个区间上的数
the numbers on this interval, for the interval 1 through n.

197
00:12:22,500 --> 00:12:24,400
对于每个数
We'll, for each one,

198
00:12:25,456 --> 00:12:26,928
计算对应的斐波那契数
compute the Fibonacci number,

199
00:12:27,792 --> 00:12:29,270
再放入一个换能器
put them through a transducer.

200
00:12:29,270 --> 00:12:30,784
对于输出的结果
We'll then take the result of that,

201
00:12:31,312 --> 00:12:34,208
再通过奇偶性进行过滤
and we'll filter it for oddness.

202
00:12:36,272 --> 00:12:39,248
最后 我们将这些放入累积器
And then we'll take those and put them into an accumulator.

203
00:12:39,350 --> 00:12:40,560
这次我们要累积出一个表
This time we'll build up a list,

204
00:12:40,784 --> 00:12:42,176
所以我们用CONS来做积累
so we'll accumulate with CONS

205
00:12:42,592 --> 00:12:43,776
以空表为初始值
starting from the empty list.

206
00:12:47,110 --> 00:12:49,808
从这个角度来看
So this way of looking at the program

207
00:12:49,856 --> 00:12:51,840
这两个程序真的是太相似了
makes the two seem very, very similar.

208
00:12:51,900 --> 00:12:52,848
问题在于
The problem is

209
00:12:53,200 --> 00:12:56,496
两个程序的写法导致
that that commonality is completely obscured

210
00:12:56,640 --> 00:12:58,050
我们看不出其中的共性
when we look at the procedures we wrote.

211
00:12:58,050 --> 00:13:01,440
再回头来看奇数平方和的问题
Let's go back and look at some odd squares again,

212
00:13:02,224 --> 00:13:04,640
问题来了 哪个是枚举器呢？
and say things like, where's the enumerator?

213
00:13:06,352 --> 00:13:08,140
程序中哪一部分有枚举的作用？
Where's the enumerator in this program?

214
00:13:08,140 --> 00:13:10,528
枚举不是仅仅在一个地方表现出来的
Well, it's not in one place.

215
00:13:11,020 --> 00:13:15,472
在叶子节点的判断处存在一部分
It's a little bit in this leaf-node test,

216
00:13:16,432 --> 00:13:17,160
#TBD
which is going to stop.

217
00:13:17,160 --> 00:13:20,064
也下面的递归结构中也有体现
It's a little bit in the recursive structure of the thing itself.

218
00:13:23,150 --> 00:13:24,120
累积器又在哪儿呢？
Where's the accumulator?

219
00:13:24,120 --> 00:13:25,680
它也不只在一个地方
The accumulator isn't in one place either.

220
00:13:25,680 --> 00:13:30,736
它在 0 和 + 这两个地方体现出来
It's partly in this 0 and partly in this plus.

221
00:13:32,000 --> 00:13:34,510
累积器的完整过程并不体在唯一一个地方
Right? It's not there as a thing that we can look at.

222
00:13:34,510 --> 00:13:39,056
相似地 我们来观察奇数斐波那契数的例子
Similarly, if we look at odd Fibs,

223
00:13:39,050 --> 00:13:42,800
某种意义上 程序中也存在枚举器与累积器
that's also, in some sense, an enumerator and an accumulator,

224
00:13:42,800 --> 00:13:44,016
但看起来非常不同
but it looks very different.

225
00:13:44,624 --> 00:13:50,096
枚举部分地表现在(> k n)的判断中
Because partly, the enumerator is here in this greater than sign in the test.

226
00:13:50,384 --> 00:13:52,848
部分地表现在下面的递归调用中
And partly it's in this whole recursive structure in the loop,

227
00:13:53,184 --> 00:13:54,240
还有就是启动循环的地方
and the way that we call it.

228
00:13:55,680 --> 00:13:56,320
同样地
And then similarly,

229
00:13:56,528 --> 00:13:58,768
其中也混杂了累积器
that's also mixed up in there with the accumulator,

230
00:13:58,912 --> 00:14:00,128
分别在这里
which is partly over there

231
00:14:00,416 --> 00:14:01,408
和那里
and partly over there.

232
00:14:03,600 --> 00:14:06,080
所以这些非常自然的部分
So these very, very natural pieces,

233
00:14:08,736 --> 00:14:12,656
我们之前画的那些方框在程序中完全看不出来
these very natural boxes here don't appear in our programs.

234
00:14:13,264 --> 00:14:14,360
因为它们混杂在一起了
Because they're kind of mixed up.

235
00:14:14,360 --> 00:14:16,290
这些程序并没有很好地对问题进行切分
The programs don't chop things up in the right way.

236
00:14:19,450 --> 00:14:22,176
回到计算机科学的基本原理上来
Going back to this fundamental principle of computer science

237
00:14:22,192 --> 00:14:23,632
为了控制某种东西
that in order to control something,

238
00:14:23,632 --> 00:14:24,960
你需要它的名字
you need the name of it,

239
00:14:25,808 --> 00:14:28,448
#TBD
we don't really have control over thinking about things this way

240
00:14:28,672 --> 00:14:31,060
#TBD
because we don't have our hands in them explicitly.

241
00:14:31,060 --> 00:14:33,808
我们没有一门好的语言来讨论它们
We don't have a good language for talking about them.

242
00:14:35,420 --> 00:14:38,864
好吧 我们来创造一门合适的语言
Well, let's invent an appropriate language

243
00:14:42,528 --> 00:14:44,048
用它来构建这些器件
in which we can build these pieces.

244
00:14:44,784 --> 00:14:47,216
这种语言的关键在于
The key to the language is these guys,

245
00:14:47,216 --> 00:14:49,712
这些叫作信号的东西到底是什么？
is what is these things I called signals?

246
00:14:50,480 --> 00:14:53,320
这些沿着箭头传递的是什么？
What are these things that are flying on the arrows between the boxes?

247
00:14:56,880 --> 00:14:57,712
这些东西
Well, those things

248
00:14:59,856 --> 00:15:03,520
是一种称作“流”的数据结构
are going to be data structures called streams.

249
00:15:03,792 --> 00:15:05,872
这也是发明这门语言的关键
That's going to be the key to inventing this language.

250
00:15:07,980 --> 00:15:08,512
“流”是什么东西呢？
What's a stream?

251
00:15:08,528 --> 00:15:11,504
和其它的东西一样 “流”是一种数据抽象
Well, a stream is, like anything else, a data abstraction.

252
00:15:12,220 --> 00:15:15,824
所以 我先说明它的选择器与构造器分别是什么
So I should tell you what its selectors and constructors are.

253
00:15:16,870 --> 00:15:19,488
对于流结构 我们有一个构造器
For a stream, we're going to have one constructor

254
00:15:19,984 --> 00:15:21,430
我们称其为CONS-STREAM
that's called CONS-stream.

255
00:15:25,690 --> 00:15:28,112
CONS-STREAM把两个事物放在一起
CONS-stream is going to put two things together

256
00:15:28,592 --> 00:15:30,220
构造出一个流
to form a thing called a stream.

257
00:15:32,040 --> 00:15:33,856
选择器叫作HEAD
And then to extract things from the stream,

258
00:15:33,984 --> 00:15:36,112
用于从流中提取数据
we're going to have a selector called the head of the stream.

259
00:15:38,010 --> 00:15:38,864
如果我有一个流
So if I have a stream,

260
00:15:39,008 --> 00:15:40,416
我可以取它的头部
I can take its head

261
00:15:41,136 --> 00:15:42,384
也可以取它的尾部
or I can take its tail.

262
00:15:44,720 --> 00:15:47,424
我把我和George的约定告诉你
And remember, I have to tell you George's contract

263
00:15:48,240 --> 00:15:52,704
让你们知道和这个相关的公理
to tell you what the axioms are that relate these.

264
00:15:53,440 --> 00:16:00,176
对于任何的X与Y
And it's going to be for any x and y,

265
00:16:03,408 --> 00:16:05,440
如果我把它们构造成一个流 并取其头部
if I form the CONS-stream and take the head,

266
00:16:05,696 --> 00:16:11,968
(HEAD (CONS-STREAM X Y))
the head of CONS-stream of x and y

267
00:16:13,296 --> 00:16:14,528
结果就是X
is going to be x

268
00:16:16,144 --> 00:16:27,456
(TAIL (CONS-STREAM X Y)) = Y
and the tail of CONS-stream of x and y is going to be y.

269
00:16:28,440 --> 00:16:34,750
一个构造函数 两个选择函数 一个公理 就是这些
So those are the constructor, two selectors for streams, and an axiom.

270
00:16:34,750 --> 00:16:35,856
这里有点可疑
There's something fishy here.

271
00:16:36,980 --> 00:16:39,008
你可能注意到了
So you might notice that these are exactly

272
00:16:40,192 --> 00:16:42,080
这些就是CONS、CAR和CDR的公理
the axioms for CONS, CAR, and CDR.

273
00:16:43,632 --> 00:16:46,560
把CONS-STREAM换成CONS
So if I said instead of writing CONS-stream I wrote CONS

274
00:16:47,104 --> 00:16:49,808
HEAD换成CAR TAIL换成CDR
and I said head was the CAR and tail was the CDR,

275
00:16:50,768 --> 00:16:52,810
这些就是序对的公理
those are exactly the axioms for pairs.

276
00:16:52,810 --> 00:16:54,320
事实上 还有另一个东西
And in fact, there's another thing here.

277
00:16:55,130 --> 00:16:56,800
我们有一个叫THE-EMPTY-STREAM（空流）的东西
We're going to have a thing called the-empty-stream

278
00:17:02,800 --> 00:17:04,048
像空表一样
which is like the-empty-list.

279
00:17:08,319 --> 00:17:10,030
为什么我要引入这个术语呢？
So why am I introducing this terminology?

280
00:17:10,030 --> 00:17:12,128
为什么我不继续使用序对与表呢？
Why don't I just keep talking about pairs and lists?

281
00:17:12,780 --> 00:17:13,792
后面我们就知道了
Well, we'll see.

282
00:17:15,510 --> 00:17:18,240
暂时地 你们可以把
For now, if you like, why don't you just pretend

283
00:17:18,304 --> 00:17:21,560
“流”当作“表”的另一种术语
that streams really are just a terminology for lists.

284
00:17:21,560 --> 00:17:22,992
一会儿我们就会知道 为什么
And we'll see in a little while why

285
00:17:23,616 --> 00:17:26,096
为什么我们需要这个额外的抽象层
why we want to keep this extra abstraction layer

286
00:17:26,832 --> 00:17:28,150
而不是继续把它叫做表
and not just call them lists.

287
00:17:32,300 --> 00:17:33,728
好的 有了流之后
OK, now that we have streams,

288
00:17:33,744 --> 00:17:35,856
我们就开始构建语言了
we can start constructing the pieces of the language

289
00:17:37,040 --> 00:17:38,176
用它来操作流
to operate on streams.

290
00:17:38,752 --> 00:17:42,120
我们可以构建出太多有用的东西了
And there are a whole bunch of very useful things that we could start making.

291
00:17:42,120 --> 00:17:42,816
举例来说
For instance,

292
00:17:44,890 --> 00:17:49,792
我们构建MAP-STREAM 它的一个参数是流S
we'll make our map box to take a stream, s,

293
00:17:54,800 --> 00:17:56,624
以及一个过程
and a procedure,

294
00:17:57,808 --> 00:17:59,216
它会生成一个新的流
and to generate a new stream

295
00:18:00,144 --> 00:18:04,880
#TBD
which has as its elements the procedure applied to all the successive elements of s.

296
00:18:05,872 --> 00:18:07,400
我们以前见过类似的
In fact, we've seen this before.

297
00:18:07,400 --> 00:18:10,240
就是以前在表上定义的MAP过程
This is the procedure map that we did with lists.

298
00:18:10,950 --> 00:18:12,608
除了判断EMPTY-STREAM的部分
And you see it's exactly map,

299
00:18:12,608 --> 00:18:14,650
完全就和MAP一样
except we're testing for empty-stream.

300
00:18:14,650 --> 00:18:15,560
哦 我忘了说了
Oh, I forgot to mention that.

301
00:18:15,560 --> 00:18:17,152
EMPTY-STREAM?就和NULL?差不多
Empty-stream is like the null test.

302
00:18:18,030 --> 00:18:20,480
如果是空的 就返回一个空的流
So if it's empty, we generate the empty stream.

303
00:18:20,510 --> 00:18:22,288
否则 就生成一个新的流
Otherwise, we form a new stream

304
00:18:23,520 --> 00:18:27,184
其第一个元素是PROC应用在流头部的结果
whose first element is the procedure applied to the head of the stream,

305
00:18:28,512 --> 00:18:29,328
剩下的是
and whose rest

306
00:18:29,600 --> 00:18:32,432
是MAP-STREAM对流尾部应用的结果
is gotten by mapping along with the procedure down the tail of the stream.

307
00:18:33,140 --> 00:18:35,904
太像我们之前讲的MAP了
So that looks exactly like the map procedure we looked at before.

308
00:18:37,030 --> 00:18:38,208
还有一个有用的函数
Here's another useful thing.

309
00:18:38,350 --> 00:18:40,460
过滤器 就是那个用来过滤的盒子
Filter, this is our filter box.

310
00:18:40,460 --> 00:18:43,890
以一个谓词和一个流作为参数
We're going to have a predicate and a stream.

311
00:18:43,890 --> 00:18:45,088
它将生成一个新的流
We're going to make a new stream

312
00:18:45,808 --> 00:18:48,176
包含了在流S中所有
consists of all the elements of the original one that satisfy the predicate.

313
00:18:48,336 --> 00:18:49,488
满足谓词PRED的元素
that satisfy the predicate.

314
00:18:50,384 --> 00:18:51,312
这是一个“按条件分析语句”
That's case analysis.

315
00:18:51,328 --> 00:18:54,224
如果流是空的 就返回一个空流
When there's nothing in the stream, we return the empty stream.

316
00:18:56,280 --> 00:18:59,184
这里 用谓词来判断流的头元素
We test the predicate on the head of the stream.

317
00:19:00,060 --> 00:19:01,040
如果为真
And if it's true,

318
00:19:01,530 --> 00:19:02,832
就把这个元素
we add the head of the stream onto the result

319
00:19:03,024 --> 00:19:06,220
和过滤流的尾元素得到的结果连接在一起
the result of filtering the tail of the stream.

320
00:19:08,220 --> 00:19:10,048
否则 如果谓词判断为假
And otherwise, if that predicate was false,

321
00:19:10,496 --> 00:19:11,984
就只返回过滤流的尾元素的结果
we just filter the tail of the stream.

322
00:19:13,500 --> 00:19:14,464
这就是过滤器的原理
Right, so there's filter.

323
00:19:16,595 --> 00:19:18,560
剩下的我快速过一遍
Let me run through a couple more rather quickly.

324
00:19:18,560 --> 00:19:20,704
这些在书上都有 你们可以自己看
They're all in the book and you can look at them.

325
00:19:20,880 --> 00:19:21,808
来马上过一遍
Let me just flash through.

326
00:19:22,110 --> 00:19:22,944
过程ACCUMULATE
Here's accumulate.

327
00:19:23,260 --> 00:19:26,928
ACCUMULATE的参数有：一个组合器
Accumulate takes a way of combining things

328
00:19:27,360 --> 00:19:29,056
一个初始值和一个流
an initial value in a stream

329
00:19:29,968 --> 00:19:31,136
将它们组合在一起
and sticks them all together.

330
00:19:31,560 --> 00:19:33,696
如果流为空 返回初始值
If the stream's empty, it's just the initial value.

331
00:19:33,970 --> 00:19:36,208
否则 我们就把流头部
Otherwise, we combine the head of the stream

332
00:19:36,320 --> 00:19:37,824
和流尾部做ACCUMLATE的结果
with the result of accumulating

333
00:19:38,016 --> 00:19:40,240
组合起来
the tail of the stream starting from the initial value.

334
00:19:40,900 --> 00:19:42,830
这就是把流中元素累积在一起的方法
So that's what I'd use to add up everything in the stream.

335
00:19:42,830 --> 00:19:43,984
我会用加法来累积
I'd accumulate with plus.

336
00:19:45,830 --> 00:19:47,568
如何枚举树上的叶节点呢？
How would I enumerate the leaves of a tree?

337
00:19:48,060 --> 00:19:52,896
如果这个树只是一个叶节点
Well, if the tree is just a leaf itself,

338
00:19:53,792 --> 00:19:55,904
我就构造一个只含有一个叶子节点的流
I make something which only has that node in it.

339
00:19:56,640 --> 00:19:59,328
否则的话 我就把
Otherwise, I append together the stuff of enumerating

340
00:19:59,616 --> 00:20:02,352
左、右子树枚举的结果合并起来
the left branch and the right branch.

341
00:20:04,340 --> 00:20:08,320
这里的APPEND-STREAM跟表上的APPEND类似
And then append here is like the ordinary append on lists.

342
00:20:13,190 --> 00:20:13,850
再来看这个
You can look at that.

343
00:20:13,850 --> 00:20:17,536
这跟和合并两个表的过程太相似了
That's analogous to the ordinary procedure for appending two lists.

344
00:20:18,912 --> 00:20:20,608
如何枚举一个区间呢？
Ah... How would I enumerate an interval?

345
00:20:21,968 --> 00:20:23,776
它有两个参数 LOW和HIGH
This will take two integers, low and high,

346
00:20:23,880 --> 00:20:27,008
生成一个包含从LOW到HIGH的所有整数的流
and generate a stream of the integers going from low to high.

347
00:20:28,320 --> 00:20:29,888
由此 我们就可以构造这一整串的元件
And we can make a whole bunch of pieces.

348
00:20:31,890 --> 00:20:34,480
这就是一门用来讨论流的小型语言
So that's a little language of talking about streams.

349
00:20:34,490 --> 00:20:35,328
当我们有了流
Once we have streams,

350
00:20:35,328 --> 00:20:37,670
就可以构建由于操作它们的过程
we can build things for manipulating them.

351
00:20:37,670 --> 00:20:39,040
请注意 我们正在构建一门语言
Again, we're making a language.

352
00:20:40,200 --> 00:20:42,224
现在 我们可以用这门语言来表达我们的想法
And now we can start expressing things in this language.

353
00:20:43,060 --> 00:20:47,310
这是累加树中奇数的平方的原始过程
Here's our original procedure for summing the odd squares in a tree.

354
00:20:47,310 --> 00:20:52,624
现在你会发现 它和那些方块图如出一辙
And you'll notice it looks exactly now like the block diagram,

355
00:20:52,640 --> 00:20:54,590
跟我们的信号处理方块图相吻合
like the signal processing block diagram.

356
00:20:54,590 --> 00:20:57,536
要计算树上奇数平方和
So to sum the odd squares in a tree,

357
00:20:58,064 --> 00:21:00,800
先枚举树上的叶子节点
we enumerate the leaves of the tree.

358
00:21:01,320 --> 00:21:03,728
过滤出奇数
We filter that for oddness.

359
00:21:04,830 --> 00:21:06,544
再用平方来做映射
We map that for squareness.

360
00:21:09,320 --> 00:21:13,344
最后用加法来累积 初始值是0
And we accumulate the result of that using addition, starting from 0.

361
00:21:14,760 --> 00:21:17,200
#TBD
So we can see the pieces that we wanted.

362
00:21:17,290 --> 00:21:19,360
类似地 斐波那契数的那个问题
Similarly, the Fibonacci one,

363
00:21:20,048 --> 00:21:21,888
我们如何获得奇斐波那契数呢？
how do we get the odd Fibs?

364
00:21:22,050 --> 00:21:24,576
从1到N枚举整数
Well, we enumerate the interval from 1 to n,

365
00:21:26,320 --> 00:21:28,640
再把FIB过程映射到上面
we map along that,

366
00:21:28,992 --> 00:21:30,704
用来求取每项斐波那契数
computing the Fibonacci of each one.

367
00:21:30,920 --> 00:21:33,792
过滤出奇数的部分
We filter the result of those for oddness.

368
00:21:34,810 --> 00:21:36,640
最后 以空表为初始值
And we accumulate all of that stuff

369
00:21:36,880 --> 00:21:39,120
用CONS将它们积累起来
using CONS starting from the empty-list.

370
00:21:43,650 --> 00:21:47,536
那么 这么做有什么优势呢？
OK, what's the advantage of this?

371
00:21:47,680 --> 00:21:48,592
首先一点
Well, for one thing,

372
00:21:48,688 --> 00:21:51,152
我们现在有可以“混合与匹配”的元件了 #TBD
we now have pieces that we can start mixing and matching.

373
00:21:51,880 --> 00:21:52,640
比如说
So for instance,

374
00:21:52,912 --> 00:21:55,088
如果我想把这里改变一下
if I wanted to change this, if I wanted to ah...

375
00:21:58,192 --> 00:22:00,320
想要计算整数的平方再进行过滤
compute the squares of the integers and then filter them,

376
00:22:00,336 --> 00:22:01,344
我只需要
all I need to do

377
00:22:01,904 --> 00:22:03,648
拿个像这里的MAP SQUARE这样的元件
is pick up a standard piece like this

378
00:22:03,680 --> 00:22:05,408
放进去就行了
it's a map square and put it in.

379
00:22:06,576 --> 00:22:07,600
又或者 如果我们想
Or if we wanted to do

380
00:22:07,690 --> 00:22:11,456
寻找树的叶节点对应的斐波那契数
this whole Fibonacci computation on the leaves of a tree

381
00:22:11,584 --> 00:22:12,360
而不是一个序列所对应的
rather than a sequence,

382
00:22:12,384 --> 00:22:13,248
我只需要
all I need to do

383
00:22:13,408 --> 00:22:15,936
用这个枚举器替换这个枚举器
is replace this enumerator with that one.

384
00:22:18,030 --> 00:22:19,824
看到了吧 流处理的优势就是
See, the advantage of this stream processing

385
00:22:20,240 --> 00:22:21,536
我们建立了 --
is that we're establishing--

386
00:22:22,368 --> 00:22:24,960
这也是本课中的一个重要主题 --
this is one of the big themes of the course--

387
00:22:25,296 --> 00:22:27,488
我们建立了一个通用的接口
we're establishing conventional interfaces

388
00:22:32,896 --> 00:22:37,152
通用接口可以让我们把事物粘合起来
conventional interfaces that allow us to glue things together.

389
00:22:38,304 --> 00:22:39,552
像MAP和FILTER这样的东西
Things like map and filter

390
00:22:39,792 --> 00:22:41,648
可以作为一组标准的组件
are a standard set of components

391
00:22:41,680 --> 00:22:44,768
我们可以拿过来随意组合去构造程序
that we can start using for pasting together programs in all sorts of ways.

392
00:22:45,750 --> 00:22:48,816
它让我们看到了程序的共性
It allows us to see the commonality of programs.

393
00:22:49,950 --> 00:22:50,928
虽然在这里
I just ought to mention,

394
00:22:51,088 --> 00:22:53,070
我只是给你们演示了两个过程而已
I've only showed you two procedures.

395
00:22:53,860 --> 00:22:55,168
但是我要告诉你
But let me emphasize

396
00:22:55,200 --> 00:22:57,776
像这种用MAP、FILTER和ACCUMULATE
that this way of putting things together

397
00:22:57,808 --> 00:23:01,008
组合起来构建程序的方式是非常非常通用的
with maps, filters, and accumulators is very, very general.

398
00:23:01,410 --> 00:23:07,280
这是一种“生成-测试”的编程范式
It's the generate and test paradigm for programs.

399
00:23:07,770 --> 00:23:09,104
举例来看
And as an example of that,

400
00:23:09,392 --> 00:23:12,940
Richarc Waters -- MIT的一名硕士生
Richard Waters, who was at MIT when he was a graduate student,

401
00:23:12,960 --> 00:23:15,264
他的学位论文的一部分调研了
as part of his thesis research went and analyzed

402
00:23:15,808 --> 00:23:19,210
IBM的科学计算程序库
a large chunk of the IBM scientific subroutine library,

403
00:23:19,824 --> 00:23:23,312
发现其中60%的程序
and discovered that about 60% of the programs in it

404
00:23:24,064 --> 00:23:28,256
都可以用这样的范式来准确的表示出来
could be expressed exactly in terms using no more than what we've put here--

405
00:23:28,864 --> 00:23:30,176
只用MAP、FILTER和ACCUMULATE
map, filter, and accumulate.

406
00:23:30,576 --> 00:23:31,504
好 让我们休息一会
All right, let's take a break.

407
00:23:36,592 --> 00:23:37,120
有问题吗？
Questions?

408
00:23:41,184 --> 00:23:42,896
学生：整件事情的本质好像只是
AUDIENCE: It seems like the essence of this whole thing

409
00:23:42,896 --> 00:23:45,968
因为你用了一个统一、简单的数据结构
is just that you have a very uniform, simple data structure

410
00:23:46,256 --> 00:23:47,664
也就是流
to work with, the stream.

411
00:23:48,380 --> 00:23:48,920
教授：对
PROFESSOR: Right.

412
00:23:48,920 --> 00:23:50,384
本质应该是
The essence is that you, again,

413
00:23:50,400 --> 00:23:53,070
#TBD
it's this sense of conventional interfaces.

414
00:23:53,710 --> 00:23:55,610
因此你可以把许多东西组合起来
So you can start putting a lot of things together.

415
00:23:56,010 --> 00:23:58,784
流只是 就像你说的
And the stream is as you say,

416
00:23:58,784 --> 00:24:00,890
只是一种可以支持那样操作的统一的数据结构而已
the uniform data structure that supports that.

417
00:24:00,890 --> 00:24:02,848
顺便说下 这非常像APL
This is very much like APL, by the way.

418
00:24:03,600 --> 00:24:05,216
APL有着非常相似的思想
APL is very much the same idea,

419
00:24:05,216 --> 00:24:06,960
只是在APL中使用的不是流
except in APL, instead of this stream,

420
00:24:07,136 --> 00:24:08,448
而是使用数组和向量
you have arrays and vectors.

421
00:24:09,560 --> 00:24:14,480
而且APL的威力就在于此
And a lot of the power of APL is exactly the same reason of the power of this.

422
00:24:19,910 --> 00:24:20,910
好吧 谢谢
OK, thank you.

423
00:24:20,910 --> 00:24:21,664
休息一下
Let's take a break.

424
00:24:57,470 --> 00:24:57,610
好的
All right.

425
00:24:57,610 --> 00:24:58,592
我们已经见识过了
We've been looking at

426
00:25:00,544 --> 00:25:03,200
如何用流来组织计算过程
at ways of organizing computations using streams.

427
00:25:03,856 --> 00:25:05,472
但是现在我想要给你们再演示两个
But what I want to do now is just show you two

428
00:25:05,936 --> 00:25:09,120
更复杂的例子
somewhat more complicated examples of that.

429
00:25:10,848 --> 00:25:14,128
我们先来考虑一下
Let's start by thinking about the following

430
00:25:14,208 --> 00:25:16,810
这样一种有用的过程
kind of utility procedure that will come in useful.

431
00:25:16,810 --> 00:25:18,096
假设我有一个流
Suppose I've got a stream.

432
00:25:19,960 --> 00:25:23,152
流中的元素本身就是一个流
And the elements of this stream are themselves streams.

433
00:25:23,984 --> 00:25:26,530
一开始是1、2、3
So the first thing might be 1, 2, 3.

434
00:25:32,720 --> 00:25:33,880
就是这样的一个流
So I've got a stream.

435
00:25:33,880 --> 00:25:40,100
流中的元素也是一个流
And each element of the stream is itself a stream.

436
00:25:40,976 --> 00:25:43,424
而我想要构建出一个流
And what I'd like to do is build a stream

437
00:25:43,648 --> 00:25:46,752
用来收集所有的元素
that sort of collects together all of the elements,

438
00:25:46,768 --> 00:25:49,248
把所有元素从子流中提取出来
pulls all of the elements out of these sub-streams

439
00:25:50,112 --> 00:25:51,824
最后把它们串接在一起
and strings them all together in one thing.

440
00:25:52,272 --> 00:25:55,616
为了凸显使用这门语言多么简单
So just to show you the use of this language, how easy it is,

441
00:25:56,112 --> 00:25:57,104
我们来定义这个FLATTEN过程
call that flatten.

442
00:25:57,950 --> 00:26:10,640
FLATTEN过程的参数是由流构成的流
And I can define to flatten this stream of streams.

443
00:26:12,896 --> 00:26:13,808
那么 具体定义是怎样的呢？
Well, what is that?

444
00:26:13,960 --> 00:26:16,240
它只是一个累积
That's just an accumulation.

445
00:26:16,320 --> 00:26:25,056
我想用APPEND来做累积
I want to accumulate using append,

446
00:26:25,072 --> 00:26:26,450
也就是不断地做APPEND
by successively appending.

447
00:26:26,736 --> 00:26:29,296
所以我用APPEND-STREAM做累积
So I accumulate using append streams,

448
00:26:35,900 --> 00:26:48,208
以THE-EMPTY-STREAM为初始值 累积这个流
starting with the-empty-stream down that stream of streams.

449
00:26:54,840 --> 00:26:55,840
这个例子告诉我们
OK, so there's an example of

450
00:26:56,928 --> 00:26:59,232
你可以使用这些高阶过程
how you can start using these higher order things

451
00:26:59,600 --> 00:27:00,830
来做一些有趣的运算
to do some interesting operations.

452
00:27:00,830 --> 00:27:05,100
事实上 我还想定义另一个实用过程
In fact, there's another useful thing that I want to do.

453
00:27:05,100 --> 00:27:07,056
定义一个过程FLAT-MAP
I want to define a procedure called flat-map,

454
00:27:17,184 --> 00:27:20,592
它以一个过程和一个流为参数
flat map of some function and a stream.

455
00:27:21,840 --> 00:27:25,720
#TBD
And what this is going to do is f will be a stream of elements.

456
00:27:25,720 --> 00:27:27,696
F是一个过程
f is going to be a function

457
00:27:27,728 --> 00:27:30,624
它作用于流中的每个元素 并产生一个新的流
for each element in the stream produces another stream.

458
00:27:31,950 --> 00:27:34,528
#TBD
And what I want to do is take all of the elements and all of those streams

459
00:27:35,008 --> 00:27:36,000
#TBD
and combine them together.

460
00:27:36,000 --> 00:27:49,136
所以对应的代码就是 (FLATTEN (MAP F S))
So that's just going to be the flatten of map f down s.

461
00:27:51,200 --> 00:27:53,040
每当我将F应用在S的某个元素上
Each time I apply f to an element of s,

462
00:27:53,056 --> 00:27:53,850
我得到了一个流
I get a stream.

463
00:27:54,290 --> 00:27:55,248
执行完这条MAP语句后
If I map it all the way down,

464
00:27:55,248 --> 00:27:56,272
我得到了一个由流构成的流
I get a stream of streams,

465
00:27:56,464 --> 00:27:57,424
再把它进行FLATTEN
and I'll flatten that.

466
00:27:58,670 --> 00:28:02,640
我想再使用这种方式
Well, I want to use that to show you a

467
00:28:03,872 --> 00:28:05,840
来解决另一个大家很熟悉的问题
a new way to do a familiar kind of problem.

468
00:28:06,512 --> 00:28:12,272
这个问题和我们以前遇到过的许多问题一样
The problem's going to be like a lot of problems you've seen,

469
00:28:12,288 --> 00:28:13,968
#TBD
although maybe not this particular one.

470
00:28:14,190 --> 00:28:15,490
给定整数N
I'm going to give you an integer, n.

471
00:28:18,680 --> 00:28:19,936
我们的问题是
And the problem is going to be

472
00:28:21,200 --> 00:28:31,536
找出所有的整数序对(I, J)
find all pairs and integers i and j,

473
00:28:32,300 --> 00:28:39,968
其中 0 < J < I <= N
between 0 and i, with j less than i, up to n,

474
00:28:42,336 --> 00:28:52,032
使得 I+J 是一个质数
such that i plus j is prime.

475
00:28:55,740 --> 00:28:57,920
如果N=6
So for example, if n equals 6,

476
00:28:59,744 --> 00:29:00,784
我在这儿画个小表格
let's make a little table here,

477
00:29:01,552 --> 00:29:06,672
表头是I、J和I+J
i and j and i plus j.

478
00:29:09,700 --> 00:29:14,912
比如说I=2 J=1 那么I+J就是3
So for, say, i equals 2 and j equals 1, I'd get 3.

479
00:29:15,520 --> 00:29:20,384
然后I=3 J=2 那么I+J就是5
And for i equals 3, I could have j equals 2, and that would be 5.

480
00:29:21,210 --> 00:29:26,512
I=4 J=1 I+J=5也是一样的 等等
And 4 and 1 would be 5 and so on,

481
00:29:26,928 --> 00:29:28,112
直到I到了6就终止了
up until i goes to 6.

482
00:29:28,400 --> 00:29:32,544
我想要这个过程产生并返回这样的一个流
And what I'd like to return is to produce a stream

483
00:29:33,200 --> 00:29:37,040
就是像 (I,J,I+J) 这样的三元组组成的流
all the triples like this, let's say i, j, and i plus j.

484
00:29:37,664 --> 00:29:39,552
对于每个整数N 我想得到一个这样流
So for each n, I want to generate this stream.

485
00:29:40,976 --> 00:29:43,680
听起来很简单
OK, well, that's easy.

486
00:29:43,680 --> 00:29:44,352
我们做做看
Let's build it up.

487
00:29:47,230 --> 00:29:48,224
先这样开始
We start like this.

488
00:29:50,150 --> 00:29:54,256
对于每一个整数 I
We're going to say for each i, for each i

489
00:29:55,248 --> 00:29:56,440
生成一个流
we're going to generate a stream.

490
00:29:57,000 --> 00:29:58,592
对于I从1取到N
For each i in the interval 1 through n,

491
00:29:58,592 --> 00:29:59,760
每个I都生成一个流
we're going to generate a stream.

492
00:30:00,660 --> 00:30:01,808
这个流将会是什么样子？
What's that stream going to be?

493
00:30:02,230 --> 00:30:04,048
我们先生成所有的序对
We're going to start by generating all the pairs.

494
00:30:04,180 --> 00:30:07,552
对于每个I 我们先生成
So for each i, we're going to generate,

495
00:30:08,432 --> 00:30:14,528
对于每个从1取到I-1的J
for each j in the interval 1 to i minus 1,

496
00:30:16,912 --> 00:30:17,984
我们先生成序对
we'll generate the pair,

497
00:30:18,352 --> 00:30:20,710
也就是只含有I和J的表
or the list with two elements i and j.

498
00:30:23,780 --> 00:30:27,104
因此我们对整个区间做映射
So we map along the interval,

499
00:30:28,608 --> 00:30:29,744
生成序对
generating the pairs.

500
00:30:31,072 --> 00:30:33,170
对于每个I 都生成一个序对流
And for each i, that generates a stream of pairs.

501
00:30:33,408 --> 00:30:34,496
最后进行FLATMAP
And we flatmap it.

502
00:30:34,590 --> 00:30:36,208
这样我们就生成了所有的(I, J)序对
Now we have all the pairs i and j,

503
00:30:36,816 --> 00:30:38,080
其中I <= J
such that i is less than j.

504
00:30:38,730 --> 00:30:39,850
就是这样
So that builds that.

505
00:30:39,850 --> 00:30:40,768
紧接着就是过滤
Now we're got to test them.

506
00:30:42,990 --> 00:30:45,840
我们对刚才FLATMAP得到的东西
Well, we take that thing we just built, the flatmap,

507
00:30:46,944 --> 00:30:51,376
进行过滤 #TBD
and we filter it to see whether the i-- see, we had an i and a j.

508
00:30:51,660 --> 00:30:54,176
I是表的第一个元素
i was the first thing in the list,

509
00:30:54,304 --> 00:30:55,600
J是第二个
j was the second thing in the list.

510
00:30:57,216 --> 00:31:00,010
我们用一个谓词来判断 表中的两个元素
So we have a predicate which says in that list of two elements

511
00:31:00,224 --> 00:31:02,000
也就是表的CAR部分与CDR部分之和 是否为质数
is the sum of the CAR and the CDR prime.

512
00:31:02,070 --> 00:31:05,520
用这个谓词对刚刚收集起来的表做过滤
And we filter that collection of pairs we just built.

513
00:31:06,540 --> 00:31:07,856
就得到了我们想要的表
So those are the pairs we want.

514
00:31:09,420 --> 00:31:10,240
然后我们继续
Now we go ahead

515
00:31:10,880 --> 00:31:13,104
把过滤得到的结果 再次进行MAP操作
Now we go ahead and we take the result of that filter

516
00:31:13,264 --> 00:31:19,056
用来生成 I、J 和 I+J 构成的表
we map along it, generating the list i and j and i plus j.

517
00:31:19,610 --> 00:31:21,392
这就是过程 PRIME-SUM-PAIRS
And that's our procedure prime-sum-pairs.

518
00:31:22,570 --> 00:31:24,768
最后只需要过一遍 这就是整个过程
Ok, and then just to flash it up, here's the whole procedure.

519
00:31:28,080 --> 00:31:30,976
一个MAP、一个FILTER 以及一个FLATMAP
A map, a filter, a flatmap.

520
00:31:34,850 --> 00:31:35,664
所有的东西都在这里了
There's the whole thing,

521
00:31:35,664 --> 00:31:37,120
尽管可读性不是那么好
even though this isn't particularly readable.

522
00:31:37,424 --> 00:31:38,944
我们只是把中间过程展开了
It's just expanding that flatmap.

523
00:31:39,840 --> 00:31:40,880
这个例子
So there's an example

524
00:31:43,280 --> 00:31:45,008
向我们展示了
which illustrates the general point

525
00:31:45,120 --> 00:31:46,304
嵌套循环
that nested loops

526
00:31:47,660 --> 00:31:50,096
在这个过程中 它看起来就像
in this procedure start looking like compositions of

527
00:31:50,112 --> 00:31:52,810
各种嵌套的MAP和FLATMAP的组合
flatmaps of flatmaps of flatmaps of maps and things.

528
00:31:54,272 --> 00:31:57,616
所以我们不仅仅可以枚举单个个体
So not only can we enumerate individual things,

529
00:31:57,616 --> 00:31:58,816
通过使用FLATMAP
but by using flatmaps,

530
00:31:59,120 --> 00:32:02,240
我们可以实现其它语言中的嵌套循环
we can do what would correspond to nested loops in most other languages.

531
00:32:03,230 --> 00:32:03,760
当然
Of course,

532
00:32:04,912 --> 00:32:08,032
重复写这些FLATMAP很烦人
it's pretty awful to keep writing these flatmaps of flatmaps of flatmaps.

533
00:32:08,410 --> 00:32:13,008
尽管PRIME-SUM-PAIRS其中单独的部分很容易
Prime-sum-pairs you saw looked fairly complicated,

534
00:32:13,568 --> 00:32:15,280
但整体看起来还是十分复杂
even though the individual pieces were easy.

535
00:32:15,480 --> 00:32:17,136
如果你愿意的话 可以
So what you can do, if you like,

536
00:32:17,152 --> 00:32:20,128
引进一个叫COLLECT的语法糖衣
is introduced some syntactic sugar that's called collect.

537
00:32:21,040 --> 00:32:22,688
COLLECT只是一个缩写
And collect is just an abbreviation

538
00:32:22,912 --> 00:32:26,160
用来代表特定顺序的FLATMAP和FILTER操作
for that nest of flatmaps and filters arranged in that particular way.

539
00:32:26,160 --> 00:32:28,608
这里我们用COLLECT把PRIME-SUM-PAIRS写一遍
Here's prime-sum-pairs again, written using collect.

540
00:32:29,450 --> 00:32:36,272
PRIME-SUM-PAIRS过程需要收集这样一个东西
It says to find all those pairs, I'm going to collect together a result,

541
00:32:36,528 --> 00:32:39,200
它的元素是形如(I, J, I+J)这样的表
which is the list i, j, and i plus j,

542
00:32:40,848 --> 00:32:45,392
而这将通过I从1取到N
that's going to be generated as i runs through the interval from 1 to n

543
00:32:47,440 --> 00:32:52,320
同时J要从1取到I-1来产生
and as j runs through the interval from 1 to i minus 1

544
00:32:54,160 --> 00:32:56,544
并且要满足I+J是质数
such that i plus j is prime.

545
00:32:58,040 --> 00:33:00,320
课堂上我就不讲解如何定义COLLECT了
So I'm not going to say what collect does in general.

546
00:33:00,690 --> 00:33:02,752
书上面有
You can look at that by looking at it in the book.

547
00:33:03,420 --> 00:33:05,456
#TBD
But pretty much, you can see that the pieces of this

548
00:33:05,840 --> 00:33:08,608
#TBD
are the pieces of that original procedure I wrote.

549
00:33:08,820 --> 00:33:11,408
COLLECT过程只是一个语法糖衣
And this collect is just some syntactic sugar

550
00:33:11,440 --> 00:33:14,800
用来自动生成嵌套FLATMAP
for automatically generating that nest of flatmaps and flatmaps.

551
00:33:16,310 --> 00:33:20,336
好的 我们再来看另一个例子
OK, well, let me do one more example

552
00:33:20,672 --> 00:33:22,000
#TBD
that shows you the same kind of thing.

553
00:33:22,120 --> 00:33:23,536
这是一个非常著名的问题
Here's a very famous problem

554
00:33:24,704 --> 00:33:28,752
经常用来演示所谓的“回溯”算法
that's used to illustrate a lot of so-called backtracking computer algorithms

555
00:33:28,768 --> 00:33:30,200
这就是“八皇后问题”
This is the eight queens problem.

556
00:33:30,200 --> 00:33:31,088
这是一个棋盘
This is a chess board.

557
00:33:32,370 --> 00:33:33,648
八皇后问题要求我们
And the eight queens problem says,

558
00:33:33,648 --> 00:33:35,856
找到一种将八个皇后放到棋盘上的摆法
find a way to put down eight queens on a chess board

559
00:33:36,448 --> 00:33:38,000
使得任意的两个皇后不会相互攻击
so that no two are attacking each other.

560
00:33:38,000 --> 00:33:40,608
这里给出了一个解法
And here's a particular solution to the eight queens problem.

561
00:33:41,210 --> 00:33:43,680
我需要保证摆放好后
So I have to make sure to put down queens

562
00:33:43,712 --> 00:33:46,800
任意两个皇后不在同一行或同一列上
no two are in the same row or the same column

563
00:33:47,728 --> 00:33:49,472
也不在同一对角线上
or sit along the same diagonal.

564
00:33:51,410 --> 00:33:56,400
有一个解决这个问题的标准解法
Now, there's sort of a standard way of doing that.

565
00:33:59,740 --> 00:34:01,488
首先我们要做是
Well, first we need to do is

566
00:34:02,544 --> 00:34:04,624
站在George的层面 #TBD
below the surface, at George's level.

567
00:34:04,940 --> 00:34:08,095
找到一种表示棋盘与位置的方式
We have to find some way to represent a board, and represent positions.

568
00:34:08,090 --> 00:34:09,520
这个并不需要太担心 #TBD
And we'll not worry about that.

569
00:34:09,800 --> 00:34:12,784
假设我们有一个谓词SAFE?
But let's assume that there's a predicate called safe.

570
00:34:16,144 --> 00:34:17,552
SAFE?判断的是
And what safe is going to do

571
00:34:17,968 --> 00:34:20,848
假如一些皇后已经放在棋盘上
is going to say given that I have a bunch of queens down on the chess board,

572
00:34:21,360 --> 00:34:24,544
在这个点再放置一个皇后是否是安全？
is it OK to put a queen in this particular spot?

573
00:34:25,400 --> 00:34:31,264
所以SAFE?的参数分别为ROW和COLUMN
So safe is going to take a row and a column.

574
00:34:32,768 --> 00:34:35,472
我将尝试把下一个皇后放在那个地方
That's going to be a place where I'm going to try and put down the next queen,

575
00:34:36,064 --> 00:34:42,768
另外一个参数是剩下的位置
and the rest of positions.

576
00:34:45,584 --> 00:34:46,752
SAFE?要判断的是
And what safe will say

577
00:34:46,864 --> 00:34:51,680
在这些位置已经放置了皇后的情况下
is given that I already have queens down in these positions,

578
00:34:53,024 --> 00:34:54,768
在这行这列放置皇后
is it safe to put another queen down

579
00:34:55,104 --> 00:34:57,200
是否安全
in that row and that column?

580
00:34:58,300 --> 00:34:59,360
不用过分深究这个
And let's not worry about that.

581
00:34:59,360 --> 00:35:01,380
那是George的问题 也不难写出来
That's George's problem. and it's not hard to write.

582
00:35:01,380 --> 00:35:06,272
只需要检测该行、该列
You just have to check whether this thing contains any things

583
00:35:06,304 --> 00:35:08,528
以及对角线上是否有东西即可
on that row or that column or in that diagonal.

584
00:35:10,530 --> 00:35:13,120
那么 有了这个过程后 我们的程序该如何组织呢？
Now, how would you organize the program given that?

585
00:35:13,840 --> 00:35:17,216
有一种传统的方式
And there's sort of a traditional way to organize it

586
00:35:17,936 --> 00:35:18,976
我们称为“回溯”
called backtracking.

587
00:35:20,528 --> 00:35:23,216
首先让我们来考虑
And it says, well, let's start of

588
00:35:25,130 --> 00:35:28,880
把第一个皇后放在第一列的
let's think about all the ways of putting the first queen down

589
00:35:30,048 --> 00:35:31,344
所有方式
in the first column.

590
00:35:31,456 --> 00:35:32,240
有8种
There are eight ways.

591
00:35:32,580 --> 00:35:35,008
先试下第一列
Well, let's say try the first column.

592
00:35:35,880 --> 00:35:37,300
第一行第一列
Try column 1, row 1.

593
00:35:37,300 --> 00:35:38,704
每个分支都代表了
These branches are going to represent

594
00:35:40,176 --> 00:35:41,888
在每一个层次的可能解
the possibilities at each level.

595
00:35:43,360 --> 00:35:45,536
我试着把皇后放在第一列
So I'll try and put a queen down in the first column.

596
00:35:46,140 --> 00:35:47,744
现在 我在第一列放置好一个皇后以后
And now given that it's in the first column,

597
00:35:47,776 --> 00:35:49,980
我又尝试在第一列放置下一个皇后
I'll try and put the next queen down in the first column.

598
00:35:50,608 --> 00:35:52,176
并不成功 它们都……
That's no good, they're both...

599
00:35:53,310 --> 00:35:54,608
我尝试把第一个皇后
I'll try and put the first queen,

600
00:35:54,860 --> 00:35:56,800
把在第一列上的那个皇后 放在第一行
the one in the first column, down in the first row.

601
00:35:56,920 --> 00:35:57,472
不好意思
I'm sorry.

602
00:35:59,050 --> 00:36:01,390
放好后 我们再把下一个皇后放在第一行
And then given that, we'll put the next queen down in the first row.

603
00:36:01,390 --> 00:36:02,090
这不行
And that's no good.

604
00:36:02,090 --> 00:36:03,184
所以又回到这里
So I'll back up to here.

605
00:36:04,200 --> 00:36:04,720
然后再考虑
And I'll say,

606
00:36:04,832 --> 00:36:06,860
我们把这个皇后放在第二行吗？
oh, can I put the first queen down in the second row?

607
00:36:07,328 --> 00:36:08,384
然而也不行
Well, that's no good.

608
00:36:08,550 --> 00:36:09,760
那么放在第三行呢？
Oh, can I put it down in the third row?

609
00:36:09,760 --> 00:36:10,528
这样可以
Well, that's good.

610
00:36:12,790 --> 00:36:15,136
下一个皇后可以放在第一列吗？
Well, now can I put the next queen down in the first column?

611
00:36:15,380 --> 00:36:17,824
我不能再画更多的棋盘了
Well, I can't visualize this chess board anymore,

612
00:36:17,824 --> 00:36:18,864
但我先假设这个可行
but I think that's right.

613
00:36:19,195 --> 00:36:20,450
我尝试下一个
And I try the next one.

614
00:36:20,450 --> 00:36:24,170
在每一个地方 尽可能的沿着树往下
And at each place, I go as far down this tree as I can.

615
00:36:24,544 --> 00:36:25,640
然后回退
And I back up.

616
00:36:25,640 --> 00:36:28,976
如果我从这里往下走 发现下面不可能有解
If I get down to here and find no possibilities below there,

617
00:36:29,008 --> 00:36:30,120
我就回溯到这里来
I back all the way up to here,

618
00:36:30,288 --> 00:36:32,448
然后开始生成这个子树
and now start again generating this sub-tree.

619
00:36:33,260 --> 00:36:34,320
我就像这样遍历
And I sort of walk around.

620
00:36:35,050 --> 00:36:37,264
最后 一路求解下来
And finally, if I ever manage to get all the way down,

621
00:36:37,728 --> 00:36:38,592
就会得到答案
I've found a solution.

622
00:36:39,820 --> 00:36:41,984
这种典型的范式
So that's a typical sort of

623
00:36:43,120 --> 00:36:45,930
之前被广泛地使用在人工智能编程中
paradigm that's used a lot in AI programming.

624
00:36:45,930 --> 00:36:47,300
术语叫做 “回溯搜索”
It's called backtracking search.

625
00:36:57,470 --> 00:37:03,040
这真的没有必要
And it's really unnecessary.

626
00:37:03,860 --> 00:37:06,550
你们也发现了 我在可视化这个过程时也犯了迷糊
You saw me get confused when I was visualizing this thing.

627
00:37:06,816 --> 00:37:08,256
你们也发现了 这很复杂
And you sort of see the complication.

628
00:37:08,550 --> 00:37:10,760
而且这种复杂还很难描述
This is a complicated thing to say.

629
00:37:10,760 --> 00:37:11,824
为什么会这样？
Why is it complicated?

630
00:37:12,390 --> 00:37:13,296
这是因为
Its because somehow

631
00:37:13,530 --> 00:37:17,392
这是因为这程序过分地关注于时间了
this program is too inordinately concerned with time.

632
00:37:18,580 --> 00:37:20,432
这之中太多 -- 先试试这个 再试试这个
It's too much-- I try this one, and I try this one,

633
00:37:20,496 --> 00:37:22,380
再回到上一个可行的地方 -- 这种操作太多了
and I go back to the last possibility.

634
00:37:22,896 --> 00:37:24,340
这很复杂
And that's a complicated thing.

635
00:37:24,340 --> 00:37:26,368
如果我们不再如此关注时间
If I stop worrying about time so much,

636
00:37:28,048 --> 00:37:29,760
就有一个更简单的方式来描述
then there's a much simpler way to describe this.

637
00:37:31,200 --> 00:37:32,368
让我们来想象一下
It says, let's imagine

638
00:37:33,312 --> 00:37:36,576
现在我有
that I have in my hands

639
00:37:38,320 --> 00:37:42,160
有一个高达K-1层的树
the tree down to k minus 1 levels.

640
00:37:43,400 --> 00:37:46,320
假设我已经有了
See, suppose I had in my hands all possible ways

641
00:37:48,096 --> 00:37:52,192
把皇后放在前K列的所有解法
to solve... to put down queens in the first k columns.

642
00:37:53,560 --> 00:37:54,610
假设是这样
Suppose I just had that.

643
00:37:54,610 --> 00:37:55,792
不要担心我是怎么得到的
Let's not worry about how we get it.

644
00:37:57,070 --> 00:37:59,200
现在 如何扩充下去呢？
Well, then, how do I extend that?

645
00:37:59,200 --> 00:38:02,160
怎样找到在下一列中放皇后的所有可行方法？
How do I find all possible ways to put down queens in the next column?

646
00:38:02,480 --> 00:38:03,136
很简单
It's really easy.

647
00:38:03,620 --> 00:38:06,416
对于已有的位置
For each of these positions I have,

648
00:38:07,820 --> 00:38:13,968
我考虑把下一个皇后放在每一行上
I enjoin, I think about putting down a queen in each row

649
00:38:15,088 --> 00:38:16,160
来构建出下一步的棋局
to make the next thing.

650
00:38:16,160 --> 00:38:17,296
然后 把所有放置的位置
And then for each one I put down,

651
00:38:17,440 --> 00:38:19,712
用SAFE?进行过滤
I filter those by the ones that are safe.

652
00:38:21,800 --> 00:38:22,992
不像之前那样
So instead of thinking about

653
00:38:22,992 --> 00:38:24,670
把这个树看做是逐步生成的
this tree as generated step by step,

654
00:38:24,944 --> 00:38:26,860
我们假设所有的东西都生成好了
I say, suppose I had it all there.

655
00:38:29,680 --> 00:38:32,416
为了从K-1层扩展到K层
And to extend it from level k minus 1 to level k,

656
00:38:32,640 --> 00:38:36,240
我只需要扩展所有可能的放置方法
I just need to extend each thing in all possible ways

657
00:38:36,480 --> 00:38:37,800
最后保留安全的排列
and only keep the ones that are safe.

658
00:38:37,800 --> 00:38:39,232
就得到一个K层树的结果
And that will give me the tree to level k.

659
00:38:39,300 --> 00:38:40,672
这是解决八皇后问题
And that's a recursive strategy

660
00:38:40,896 --> 00:38:42,176
的一个递归策略
for solving the eight queens problem.

661
00:38:44,530 --> 00:38:45,344
好的 我们来看看
All right, well, let's look at it.

662
00:38:50,336 --> 00:38:52,688
我们编写子过程FILL-COLS
To solve the eight queens problem

663
00:38:53,008 --> 00:38:55,536
来解决在一个特定大小棋盘上的
on a board of some specified size,

664
00:38:58,928 --> 00:39:01,030
八皇后问题
we write a sub-procedure called fill-columns.

665
00:39:01,136 --> 00:39:04,864
这个过程会把皇后放置到K个列中
Fill-columns is going to put down queens up through column k.

666
00:39:06,352 --> 00:39:07,700
这是递归的模式
And here's the pattern of the recursion.

667
00:39:07,700 --> 00:39:10,928
最后会以棋盘的大小为参数 调用FILL-COLS
I'm going to call fill-columns with the size eventually.

668
00:39:12,990 --> 00:39:15,280
FILL-COLS是用来说明
So fill-columns says how to put down queens safely

669
00:39:15,296 --> 00:39:17,168
如何安全地把皇后放置在
safely in the first k columns of this chess board

670
00:39:17,200 --> 00:39:19,584
具有SIZE行的棋盘的前K列
with a size number of rows in it.

671
00:39:20,360 --> 00:39:21,648
如果K是0
If k is equal to 0,

672
00:39:22,272 --> 00:39:23,600
就不用做什么
well, then I don't have to put anything down.

673
00:39:23,940 --> 00:39:25,936
结果是一个空棋盘
So my solution is just an empty chess board.

674
00:39:26,710 --> 00:39:28,070
否则就做点别的
Otherwise, I'm going to do some stuff.

675
00:39:28,352 --> 00:39:29,440
这里将要使用COLLECT
And I'm going to use collect.

676
00:39:30,816 --> 00:39:31,770
完整的代码在这里
And here's the collect.

677
00:39:34,336 --> 00:39:41,910
我找到了所有在前K-1列中放皇后的方法
I find all ways to put down queens in the first k minus 1 columns.

678
00:39:42,192 --> 00:39:43,320
这是我所假设的 #TBD
And this was just what I set for.

679
00:39:43,320 --> 00:39:46,368
想像这棵树下降到K-1层
Imagine I have this tree down to k minus 1 levels.

680
00:39:48,880 --> 00:39:52,112
然后我尝试每一行
And then I find all ways of trying a row,

681
00:39:52,528 --> 00:39:54,130
#TBD
that's just each of the possible rows.

682
00:39:54,130 --> 00:39:55,040
总共SIZE行
They're size rows,

683
00:39:55,312 --> 00:39:56,496
这里枚举了所有行数
so that's enumerate interval.

684
00:39:58,040 --> 00:39:59,792
现在要做的是
And now what I do is I collect together

685
00:40:03,152 --> 00:40:05,824
把我将要尝试的新行和第K列
the new row I'm going to try and column k

686
00:40:07,952 --> 00:40:08,950
收集起来
with the rest of the queens.

687
00:40:08,950 --> 00:40:10,096
我邻接一个位置
I adjoin a position.

688
00:40:10,200 --> 00:40:11,290
这是George的问题了
This is George's problem.

689
00:40:11,290 --> 00:40:12,752
实现ADJOIN-POSITION和SAFE?都是George的工作
An adjoined position is like safe.

690
00:40:13,640 --> 00:40:15,280
这个过程需要的参数有
It's a thing that takes a row

691
00:40:15,504 --> 00:40:17,040
ROW、COL以及REST-OF-POS
and a column and the rest of the positions

692
00:40:17,072 --> 00:40:19,024
然后返回位置的集合
and makes a new position collection.

693
00:40:19,660 --> 00:40:25,776
我把新的行和列
So I adjoin a position of a new row and a new column

694
00:40:26,064 --> 00:40:27,680
和剩下的皇后邻接起来
to the rest of the queens,

695
00:40:28,576 --> 00:40:29,760
那些剩下的皇后
where the rest of the queens

696
00:40:29,920 --> 00:40:31,456
会尝试所有的
runs through all possible ways

697
00:40:31,872 --> 00:40:34,160
放置在K-1列中的可行解
of solving the problem in k minus 1 columns.

698
00:40:34,620 --> 00:40:37,040
新的行遍历了所有的可能性
And the new row runs through all possible rows

699
00:40:37,856 --> 00:40:40,768
过滤出安全的位置
such that it was safe to put one there.

700
00:40:43,240 --> 00:40:44,704
这就是整个程序了
And that's the whole program.

701
00:40:46,336 --> 00:40:47,312
整个过程
There's the whole procedure.

702
00:40:49,840 --> 00:40:52,432
它不仅找到了八皇后的问题的解
Not only that, that doesn't just solve the eight queens problem,

703
00:40:53,424 --> 00:40:56,680
它还给出了所有的解
Right? It gives you all solutions to the eight queens problem.

704
00:40:56,680 --> 00:40:58,480
运行结束之后 就得到一个流
When you're done, you have a stream.

705
00:40:58,480 --> 00:41:01,900
流中的元素是所有的解
And the elements of that stream are all possible ways of solving that problem.

706
00:41:05,310 --> 00:41:06,260
为什么这个更简单一点呢？
Why is that simpler?

707
00:41:06,260 --> 00:41:08,544
我们完全没有把这个当做
Well, we threw away the whole idea that

708
00:41:08,880 --> 00:41:11,520
按时间发生的、具有状态的过程
is some process that happens in time with state.

709
00:41:12,720 --> 00:41:14,420
我们只说 这是一些东西的集合
And we just said it's a whole collection of stuff.

710
00:41:14,944 --> 00:41:16,000
这是它更加简单的原因
And that's why it's simpler.

711
00:41:18,000 --> 00:41:20,110
我们已经转变了观念
Right? We've changed our view.

712
00:41:20,110 --> 00:41:22,592
还记得吗？这节课开始我们就讲过
Remember, that's where we started today.

713
00:41:22,820 --> 00:41:26,230
我们转变了建模的观念
We've changed our view of what it is we're trying to model.

714
00:41:26,230 --> 00:41:29,200
我们不再把事物看做按时间演进
we stop modeling things that evolve in time

715
00:41:29,376 --> 00:41:31,312
也不再具有不同的阶段与状态
have steps and have state.

716
00:41:31,750 --> 00:41:33,792
取而代之的是 我们对全局进行建模
And instead, we're trying to model this global thing

717
00:41:33,808 --> 00:41:35,936
我们关注粉笔的整个飞行过程
like the whole flight of the chalk,

718
00:41:36,288 --> 00:41:38,880
而不是专注于每个瞬时状态
rather than its state at each instant.

719
00:41:40,750 --> 00:41:41,440
有什么问题吗？
Any questions?

720
00:41:44,080 --> 00:41:46,208
学生：在我看来回溯会
AUDIENCE: It looks to me like backtracking would be

721
00:41:46,224 --> 00:41:48,960
搜索到它所能找到的第一个解
searching for the first solution it can find,

722
00:41:49,310 --> 00:41:51,488
而这个递归搜索
whereas this recursive search

723
00:41:51,488 --> 00:41:53,260
会去寻找所有的解
would be looking for all solutions.

724
00:41:53,328 --> 00:41:53,600
教授：是这样的
PROFESSOR: Right.

725
00:41:54,030 --> 00:41:55,264
学生：但问题是
AUDIENCE: And it seems that

726
00:41:55,264 --> 00:41:57,920
如果需要搜索的空间足够的大
if you have a large enough area to search,

727
00:41:57,920 --> 00:42:00,928
第二种搜索方式就会变得不现实
that the second is going to become impossible.

728
00:42:01,360 --> 00:42:05,936
教授：呃 这个问题其实是
PROFESSOR: OK, the answer to that question

729
00:42:07,136 --> 00:42:08,448
这一节课剩下的内容
is the whole rest of this lecture.

730
00:42:08,570 --> 00:42:10,540
这个问题很好
It's exactly the right question.

731
00:42:13,872 --> 00:42:15,744
先不要尝试去预知后面的课
And without trying to anticipate the lecture too much,

732
00:42:15,968 --> 00:42:19,232
只是在现在 你们要保持谨慎
you should start being suspicious at this point,

733
00:42:19,840 --> 00:42:21,840
这里确实有点奇怪 难道不是么？
and exactly those kinds of suspicions. Isn't it?

734
00:42:22,220 --> 00:42:24,512
尽管这个看起来不错 但是难道它不低效吗？
It's wonderful, but isn't it so terribly inefficient?

735
00:42:24,830 --> 00:42:26,032
这是我们待会儿要解决的问题
That's where we're going.

736
00:42:28,100 --> 00:42:30,020
就让我们稍后来揭晓秘密吧
So I won't answer now, but I'll answer later.

737
00:42:33,350 --> 00:42:34,600
好吧 休息一下
OK, let's take a break.

738
00:43:29,650 --> 00:43:33,760
现在你应该也开始怀疑了
Well, by now you should be starting to get suspicious.

739
00:43:35,600 --> 00:43:39,264
我已经展示了这种简单而优雅的
See, I've showed your this simple, elegant

740
00:43:40,512 --> 00:43:42,288
组合程序的方法
of putting programs together,

741
00:43:42,864 --> 00:43:46,912
这跟那些传统程序非常不同
very unlike these other traditional programs

742
00:43:46,920 --> 00:43:48,192
那些求奇数的平方和
that sum the odd squares

743
00:43:48,720 --> 00:43:51,320
或者求奇数项斐波那契数之类的程序
or compute the odd Fibonacci numbers.

744
00:43:53,740 --> 00:43:55,488
也不想那些混合了
Very unlike these programs that mix up

745
00:43:55,856 --> 00:43:58,848
枚举器、过滤器和累积器的程序
the enumerator and the filter and the accumulator.

746
00:44:00,440 --> 00:44:01,824
#TBD
And by mixing it up,

747
00:44:02,200 --> 00:44:04,592
#TBD
we don't have all of these wonderful

748
00:44:04,624 --> 00:44:07,344
#TBD
conceptual advantages of these streams pieces,

749
00:44:07,824 --> 00:44:09,536
#TBD
these wonderful mix and match components

750
00:44:09,552 --> 00:44:11,776
#TBD
for putting together lots and lots of programs.

751
00:44:13,800 --> 00:44:14,256
另一方面
On the other hand,

752
00:44:14,288 --> 00:44:16,880
#TBD
most of the programs you've seen look like these ugly ones.

753
00:44:18,340 --> 00:44:18,944
为什么会这样？
Why's that?

754
00:44:19,200 --> 00:44:20,592
#TBD
Can it possibly be

755
00:44:21,168 --> 00:44:24,304
#TBD
that computer scientists are so obtuse

756
00:44:25,420 --> 00:44:26,448
#TBD
that they don't notice

757
00:44:27,072 --> 00:44:28,752
#TBD
that if you'd merely did this thing,

758
00:44:29,632 --> 00:44:31,936
#TBD
then you can get this great programming elegance?

759
00:44:33,620 --> 00:44:34,784
肯定有什么窍门#TBD
There's got to be a catch.

760
00:44:36,760 --> 00:44:39,056
事实上这一窍门也很容易发现
And it's actually pretty easy to see what the catch is.

761
00:44:39,510 --> 00:44:41,744
我们来看看接下来的这个问题
Let's think about the following problem.

762
00:44:42,030 --> 00:44:45,472
假设我让你去找
Suppose I tell you to find the second prime

763
00:44:46,160 --> 00:44:48,160
1,000到1,000,000之间的第二个素数
between 10,000 and 1 million,

764
00:44:49,120 --> 00:44:50,560
如果你的计算机性能更强劲的话
or if your computer's larger,

765
00:44:50,592 --> 00:44:53,056
或者可以去找10,000到100,000,000之间的
say between 10,000 and 100 billion, or something.

766
00:44:54,320 --> 00:44:55,456
你可能觉得这很容易
And you say, oh, that's easy.

767
00:44:55,472 --> 00:44:56,656
我可以用流来解决
I can do that with a stream.

768
00:44:57,080 --> 00:44:59,872
我需要做的就是
All I do is I enumerate

769
00:45:00,576 --> 00:45:02,896
从10,000枚举到1,000,000
the interval from 10,000 to 1 million.

770
00:45:04,160 --> 00:45:06,512
我就获得了从10,000到1,000,000的所有整数
So I get all those integers from 10,000 to 1 million.

771
00:45:06,800 --> 00:45:08,640
我过滤出所有的质数
I filter them for prime-ness,

772
00:45:09,392 --> 00:45:11,104
也就是对这些数做素性检测
so test all of them and see if they're prime.

773
00:45:11,760 --> 00:45:12,832
然后从中取出第二个元素
And I take the second element.

774
00:45:12,848 --> 00:45:14,048
也就是 TAIL的HEAD部分
Right? That's the head of the tail.

775
00:45:15,792 --> 00:45:17,380
这显然是非常荒谬的
OK? Well, that's clearly pretty ridiculous.

776
00:45:21,660 --> 00:45:23,200
我们的机器没有这么大的空间
We'd not even have room in the machine

777
00:45:23,584 --> 00:45:25,248
来存放这些整数
Right? To store the integers in the first place,

778
00:45:25,280 --> 00:45:26,352
更别说来测试它们了
much less to test them.

779
00:45:27,040 --> 00:45:28,640
而且我也只是取第二个数而已
And then I only want the second one.

780
00:45:29,810 --> 00:45:34,944
这种传统程序设计风格的威力
See, the power of this traditional programming style

781
00:45:36,432 --> 00:45:37,680
也正是其弱点
is exactly its weakness,

782
00:45:37,960 --> 00:45:38,944
这种程序设计风格
that we're mixing up

783
00:45:39,616 --> 00:45:43,500
混合了枚举、测试以及累积
the enumerating and the testing and the accumulating.

784
00:45:44,880 --> 00:45:46,464
所以关键在于 我们不需要做所有的事#TBD
Right? We sort of don't do it all.

785
00:45:46,670 --> 00:45:49,184
所以说 实际上这是这种
So by the actual... so the very thing

786
00:45:49,456 --> 00:45:51,744
概念上丑陋的风格
makes it conceptually ugly

787
00:45:52,208 --> 00:45:53,808
正是让它运行起来高效
is the very thing that makes it efficient.

788
00:45:54,912 --> 00:45:55,840
就是像这样来混合
Right? It's this mixing up.

789
00:45:57,800 --> 00:45:59,344
我今天一早上所做的好像都是在
So it seems that all I've done this morning so far

790
00:45:59,344 --> 00:46:00,420
把你们搞糊涂一样
is just confuse you.

791
00:46:00,420 --> 00:46:03,104
#TBD
I showed you this wonderful way that programming might work,

792
00:46:03,104 --> 00:46:03,968
#TBD
except that it doesn't.

793
00:46:05,840 --> 00:46:08,320
但是 接下来就是见证奇迹的时刻
Well, here's where the wonderful thing happens.

794
00:46:09,040 --> 00:46:10,576
结果却是 这个游戏里
It turns out in this game

795
00:46:11,216 --> 00:46:13,840
我们真的可以得到蛋糕并吃掉它
that we really can have our cake and eat it too.

796
00:46:14,870 --> 00:46:16,112
我的意思是
And what I mean by that

797
00:46:18,096 --> 00:46:21,152
我们完全可以用流来组织程序
is that we really can write stream programs

798
00:46:21,168 --> 00:46:22,480
就像我之前编写的那样
exactly like the ones I wrote

799
00:46:23,552 --> 00:46:27,744
以至于当机器真正运行的时候
and arrange things so that when the machine actually runs,

800
00:46:28,336 --> 00:46:31,520
它可以和传统风格的程序一样高效
it's as efficient as running this traditional programming style

801
00:46:31,712 --> 00:46:34,288
那些混合了生成与测试的程序
that mixes up the generation and the test.

802
00:46:36,160 --> 00:46:38,800
听起来不可思议
Well, that sounds pretty magic.

803
00:46:40,770 --> 00:46:41,824
关键在就于
The key to this

804
00:46:42,000 --> 00:46:43,690
流不是表
is that streams are not lists.

805
00:46:48,090 --> 00:46:49,792
一会儿我们就会看到 但是现在
We'll see this carefully in a second, but for now,

806
00:46:49,808 --> 00:46:51,776
先让我们来看看幻灯片
let's take a look at that slide again.

807
00:46:52,240 --> 00:46:53,808
你们对这个
The image you should have here

808
00:46:53,840 --> 00:46:55,584
信号处理系统的印象是
of this signal processing system

809
00:46:57,264 --> 00:46:58,720
你们认为要发生的是
is that what's going to happen

810
00:46:59,136 --> 00:47:00,928
在这类盒子中
is there's sort of this box

811
00:47:01,184 --> 00:47:03,584
事先产生好了整数
that has the integers sitting in it.

812
00:47:05,360 --> 00:47:06,400
这里有个过滤器
And there's this filter

813
00:47:07,456 --> 00:47:09,376
它和那个盒子相连 并从中拉取东西
that's connected to it and it's tugging on them.

814
00:47:10,940 --> 00:47:13,152
这里还有人从这整个系统中
And then there's someone who's tugging on this stuff

815
00:47:13,312 --> 00:47:14,912
拉取东西
saying what comes out of the filter.

816
00:47:16,790 --> 00:47:18,704
你们应该这么来理解：
And the image you should have is that

817
00:47:18,992 --> 00:47:20,720
有人想要得到第一个质数
someone says, well, what's the first prime,

818
00:47:22,672 --> 00:47:24,144
他从这个过滤器这儿拉取
and tugs on this filter.

819
00:47:24,590 --> 00:47:26,128
FILTER从枚举器中去拉取
And the filter tugs on the integers.

820
00:47:28,020 --> 00:47:29,152
#TBD
And you look only at that much,

821
00:47:29,168 --> 00:47:30,930
#TBD
and then say, oh, I really wanted the second one.

822
00:47:30,930 --> 00:47:31,952
第二个质数是多少？
What's the second prime?

823
00:47:33,710 --> 00:47:35,376
没有额外的计算
And that no other computation

824
00:47:35,376 --> 00:47:36,640
只要你不去拉取东西
no computation gets done

825
00:47:36,640 --> 00:47:38,320
就不会产生进行额外计算
except when you tug on these things.

826
00:47:40,500 --> 00:47:41,410
我来用实物演示一下
Let me try that again.

827
00:47:41,410 --> 00:47:43,888
这个小设备
This is a little device.

828
00:47:43,900 --> 00:47:44,976
这是个小型的流机器
This is a little stream machine

829
00:47:45,504 --> 00:47:46,832
这是Eric Grimson发明的
invented by Eric Grimson

830
00:47:47,600 --> 00:47:49,248
他也在MIT教这门课
who's been teaching this course at MIT.

831
00:47:49,830 --> 00:47:52,512
实际的流程是 -- 这里有某种流
And the image is ... here's a stream of stuff,

832
00:47:52,544 --> 00:47:53,824
就像一串整数一样
like a whole bunch of the integers.

833
00:47:54,780 --> 00:47:56,336
这些是一些处理单元
And here's some processing elements.

834
00:47:58,700 --> 00:48:02,600
就像是FILTER、MAP之类的东西
And if, say, it's filter of filter of map, or something.

835
00:48:03,984 --> 00:48:09,184
如果我把流实现为表 来进行处理
And if I really tried to implement that with streams as lists,

836
00:48:09,248 --> 00:48:11,264
我拥有的是一个表
what I'd say is, well, I've got this list of things,

837
00:48:11,472 --> 00:48:12,670
现在 我先执行第一个过滤器
and now I do the first filter.

838
00:48:12,670 --> 00:48:14,070
我像这样完全处理
So I sort of do all this processing.

839
00:48:14,880 --> 00:48:15,776
针对这个流
And I take this

840
00:48:16,320 --> 00:48:19,216
不断地处理、处理、处理、处理
and I process and I process and I process and I process.

841
00:48:19,610 --> 00:48:21,056
然后得到一个新的流
And now I'm got this new stream.

842
00:48:21,632 --> 00:48:24,070
现在 我把得到的结果拿在我手中
Right? Now I take that result in my hand someplace.

843
00:48:24,070 --> 00:48:25,260
然后把它放进第二个
And I put that through the second one.

844
00:48:25,568 --> 00:48:26,944
又处理了全部的流
And I process the whole thing.

845
00:48:28,272 --> 00:48:29,510
得到一个新流
And there's this new stream.

846
00:48:32,130 --> 00:48:33,360
然后我再把结果
And then I take the result

847
00:48:34,288 --> 00:48:36,360
用相同的方式再次处理
and I put it all the way through this one the same way.

848
00:48:36,360 --> 00:48:40,992
如果仅仅把流当做表的话
That's what would happen to these stream programs

849
00:48:41,696 --> 00:48:42,976
计算的过程就是这样的
if streams were just lists.

850
00:48:43,860 --> 00:48:45,648
但是事实上 流不是表 流就是流
But in fact, streams aren't lists, they're streams.

851
00:48:45,824 --> 00:48:48,112
而你们应该这样来想像
And the image you should have is something a little bit more like this.

852
00:48:50,230 --> 00:48:52,528
我把这些小玩意连接起来
I've got these gadgets connected up

853
00:48:55,264 --> 00:48:56,768
数据在其中流动
by this data that's flowing out of them. #LAST

854
00:48:59,960 --> 00:49:05,980
这里是流的来源，开始生成整数
And here's my original source of the streams. It might be starting to generate the integers.

855
00:49:05,980 --> 00:49:07,580
如果我想要一个整数，会发生什么？
And now, what happens if I want a result?

856
00:49:07,580 --> 00:49:10,200
我揪住最后的这里
I tug on the end here.

857
00:49:10,200 --> 00:49:13,090
这个元素可能会说，哥们，我需要更多的数据
And this element says, gee, I need some more data.

858
00:49:13,090 --> 00:49:15,830
所以，这个到这里，又开始揪住那个
So this one comes here and tugs on that one.

859
00:49:15,830 --> 00:49:17,890
同样说，哥们，给我来点数据
And it says, gee, I need some more data.

860
00:49:17,890 --> 00:49:21,640
然后这个又揪住了下一个东西，可能是一个fiiler，哥们，来点数据啊
And this one tugs on this thing, which might be a filter, and says, gee, I need some more data.

861
00:49:21,640 --> 00:49:25,780
最后的这一点东西，只有在去揪它的时候才会生成
And only as much of this thing at the end here gets generated as I tugged.

862
00:49:25,780 --> 00:49:30,760
只有我去揪住末尾这里的时候，才会有数据通过这些元件得到处理
And only as much of this stuff goes through the processing units as I'm pulling on the end I need.

863
00:49:30,760 --> 00:49:37,830
把流当作流和把流当作列表，就是这样的区别
That's the image you should have of the difference between implementing what we're actually going to do and if streams were lists.

864
00:49:40,600 --> 00:49:42,430
说了这么多，到底怎么来实现呢？
Well, how do we make this thing?

865
00:49:42,430 --> 00:49:43,400
我希望你们这样来想
I hope you have the image.

866
00:49:43,400 --> 00:49:44,947
窍门在于如何构造流
The trick is how to make it.

867
00:49:47,930 --> 00:49:56,920
我们想要把流组织成一种有需要时才会逐渐计算得到自身元素的数据结构
We want to arrange for a stream to be a data structure that computes itself incrementally, an on-demand data structure.

868
00:49:59,220 --> 00:50:04,490
基本思想在于，再次强调，这种思想贯穿整个课程
And the basic idea is, again, one of the very basic ideas that we're seeing throughout the whole course.

869
00:50:04,490 --> 00:50:09,240
那就是，数据与过程之间并没有绝对的界限
And that is that there's not a firm distinction between programs and data.

870
00:50:09,240 --> 00:50:16,810
流会是这样的一种结构，你可以想象树的叶子的流
So what a stream is going to be is simultaneously this data structure that you think of, like the stream of the leaves of this tree.

871
00:50:16,810 --> 00:50:23,550
但是不得不说，其中包含着计算方法的过程着实很精妙
But at the same time, it's going to be a very clever procedure that has the method of computing in it.

872
00:50:23,550 --> 00:50:25,930
好吧，实际来看一下
Well, let me try this.

873
00:50:25,930 --> 00:50:28,460
事实上我们不需要其它高深的原理
It's going to turn out that we don't need any more mechanism.

874
00:50:28,460 --> 00:50:35,460
这个事实已经有了我们所需要的一切东西，那就是了解如何把过程作为一级对象来处理
We already have everything we need simply from the fact that we know how to handle procedures as first-class objects.

875
00:50:35,460 --> 00:50:36,880
来看看这个关键之处
Well, let's go back to the key.

876
00:50:36,880 --> 00:50:39,030
关键是，记住，我们有实际的操作方法
The key is, remember, we had these operations.

877
00:50:39,030 --> 00:50:48,080
CONS-STREAM HEAD TAIL
CONS-stream and head and tail.

878
00:50:48,080 --> 00:50:55,080
一开始，你可以把这个想像成CONS，这个是CAR，这个是CDR，事实上没这么简单
When I started, I said you can think about this as CONS and think about this as CAR and think about that as CDR, but it's not.

879
00:50:55,080 --> 00:50:57,550
现在我们来具体看看它们到底是什么
Now, let's look at what they really are.

880
00:50:57,550 --> 00:51:19,540
(CONS-STREAM X Y) 是这个东西的缩写形式
Well, CONS-stream of x and y is going to be an abbreviation for the following thing.

881
00:51:19,540 --> 00:51:28,000
(CONS X (DELAY Y))
CONS form a pair, ordinary CONS, of x to a thing called delay of y.

882
00:51:31,188 --> 00:51:39,790
在我具体解释清楚之前，先把剩下的写完，(HEAD S) 就是 (CAR S)
And before I explain that, let me go and write the rest. The head of a stream is going to be just the CAR.

883
00:51:42,380 --> 00:51:56,120
(TAIL S) 是 (FORCE (CDR S))
And the tail of a stream is going to be a thing called force the CDR of the stream.

884
00:51:56,120 --> 00:51:58,060
我来具体解释一下
Now let me explain this.

885
00:51:58,060 --> 00:52:01,420
DELAY看起来很神奇
Delay is going to be a special magic thing.

886
00:52:01,420 --> 00:52:10,600
DELAY所做是取一个表达式，然后做了一个约定，有需要的时候再来计算我
What delay does is take an expression and produce a promise to compute that expression when you ask for it.

887
00:52:10,600 --> 00:52:11,980
这里并没有做实际的计算
It doesn't do any computation here.

888
00:52:11,980 --> 00:52:14,820
只是一个延期的约定
It just gives you a rain check.

889
00:52:14,820 --> 00:52:17,110
承诺要做这样的事
It produces a promise.

890
00:52:17,110 --> 00:52:25,360
CONS-STREAM所做的就是把X和一个计算Y的约定相组合
And CONS-stream says I'm going to put together in a pair x and a promise to compute y.

891
00:52:28,230 --> 00:52:31,840
如果你想取头，就是序对的CAR
Now, if I want the head, that's just the CAR that I put in the pair.

892
00:52:31,840 --> 00:52:39,110
关键在于尾操作，对承诺进行FORCE调用
And the key is that the tail is going to be-- force calls in that promise.

893
00:52:39,110 --> 00:52:44,610
TAIL会说，好吧，遵守承诺进行计算
Tail says, well, take that promise and now call in that promise.

894
00:52:44,610 --> 00:52:47,430
这才开始实际的计算
And then we compute that thing.

895
00:52:47,430 --> 00:52:48,740
这就是它的实际工作方式
That's how this is going to work.

896
00:52:48,740 --> 00:52:51,550
这就是CONS-STREAM，HEAD，TAIL的真实面目了
That's what CONS-stream, head, and tail really are.

897
00:52:54,196 --> 00:52:55,570
具体演示一下
Now, let's see how this works.

898
00:52:55,570 --> 00:52:58,410
我会非常小心的过一遍
And we'll go through this fairly carefully.

899
00:52:58,410 --> 00:53:08,650
现在从计算10,000到1,000,1000中的第二个质数这个实例来看，那具体是怎么运行的
We're going to see how this works in this example of computing the second prime between 10,000 and a million.

900
00:53:08,650 --> 00:53:11,610
好的，我们从这个表达式开始
OK, so we start off and we have this expression.

901
00:53:15,820 --> 00:53:26,710
第二个质数 -- 就是(HEAD (TAIL (FILTER (PRIME? (E-I 10000 1000000)))))
The second prime-- the head of the tail of the result of filtering for primality the integers between 10,000 and 1 million.

902
00:53:26,710 --> 00:53:28,400
这究竟是什么？
Now, what is that?

903
00:53:28,400 --> 00:53:40,250
就是10,000至1,000,000之间到底是什么？好，如果你开始枚举之间的整数，就构造了一个流
What that is, that interval between 10,000 and 1 million, well, if you trace through enumerate interval, there builds a CONS-stream.

904
00:53:40,250 --> 00:53:54,480
CONS-STREAM实际代换过来是(CONS 10000 (DELAY (E-I 10001 1000000)))
And the CONS-stream is the CONS of 10,000 to a promise to compute the integers between 10,001 and 1 million.

905
00:53:54,480 --> 00:53:55,750
这也就是上面这个表达式
So that's what this expression is.

906
00:53:55,750 --> 00:53:57,640
现在我使用代换模型
Here I'm using the substitution model.

907
00:53:57,640 --> 00:54:01,010
我们可以用代换模型的原因是这里并没有涉及时间与状态的副作用
And we can use the substitution model because we don't have side effects and state.

908
00:54:04,270 --> 00:54:08,380
这里还有一个计算10001至1000000的承诺
So I have CONS of 10,000 to a promise to compute the rest of the integers.

909
00:54:08,380 --> 00:54:09,850
所以到现在为止，只有一个整数被枚举了出来
So only one integer, so far, got enumerated.

910
00:54:14,380 --> 00:54:16,580
然后用filter去过滤
Well, I'm going to filter that thing for primality.

911
00:54:19,900 --> 00:54:22,360
我们再来细看filter这个东西
Again, you go back and look at the filter code.

912
00:54:22,360 --> 00:54:25,460
filter首先测试 (HEAD S)
What the filter will first do is test the head.

913
00:54:25,460 --> 00:54:33,500
这里，测试到的是10,000，不是素数
So in this case, the filter will test 10,000 and say, oh, 10,000's not prime.

914
00:54:33,500 --> 00:54:39,220
然后就开始递归的过滤TAIL的部分
Therefore, what I have to do recursively is filter the tail.

915
00:54:39,220 --> 00:54:46,340
TAIL是什么呢？就是那个继续计算的承诺
And what's the tail of it, well, that's the tail of this pair with a promise in it.

916
00:54:46,340 --> 00:54:49,680
开始计算尾了，尾说，好，我履行承诺继续计算
Tail now comes in and says, well, I'm going to force that.

917
00:54:49,680 --> 00:55:00,880
履行承诺的意思是继续枚举10,001到1,000,000之间的整数
I'm going to force that promise, which means now I'm going to compute the integers between 10,001 and 1 million.

918
00:55:00,880 --> 00:55:02,970
现在看起来像是这样
OK, so this filter now is looking at that.

919
00:55:07,810 --> 00:55:11,960
现在，就又回到了最开始枚举的部分
That enumerate itself, well, now we're back in the original enumerate situation.

920
00:55:11,960 --> 00:55:19,740
(CONS 10001 (DELAY (E-I 10002 1000000))))
The enumerate is the CONS of the first thing, 10,001, onto a promise to compute the rest.

921
00:55:19,740 --> 00:55:23,060
现在filter又开始针对10,001进行过滤了
So now the primality filter is going to go look at 10,001.

922
00:55:23,060 --> 00:55:25,120
又要开始判断是不是质数
It's going to decide if it likes that or not.

923
00:55:25,120 --> 00:55:27,550
结果不是
It turns out 10,001 isn't prime.

924
00:55:27,550 --> 00:55:29,610
然后再继续履行承诺计算下去
So it'll force it again and again and again.

925
00:55:32,920 --> 00:55:37,100
然后，我觉得第一个质数可能是10,009
And finally, I think the first prime it hits is 10,009.

926
00:55:37,100 --> 00:55:40,465
在这个点才停下来
And at that point, it'll stop.

927
00:55:40,465 --> 00:55:45,240
这只是第一个质数，我们需要的是第二个
And that will be the first prime, and then eventually, it'll need the second prime.

928
00:55:45,240 --> 00:55:47,030
所以，又开始了
So at that point, it will go again.

929
00:55:47,030 --> 00:55:53,130
你会发现，你需要多少，它才生成多少，不多不少
So you see what happens is that no more gets generated than you actually need.

930
00:55:56,690 --> 00:56:04,930
enumerator不会生成比filter的要求更多的数要它去过滤
That enumerator is not going to generate any more integers than the filter asks it for as it's pulling in things to check for primality.

931
00:56:04,930 --> 00:56:11,255
filter也不会生成比你的要求更多的东西
And the filter is not going to generate any more stuff than you ask it for, which is the head of the tail.

932
00:56:11,255 --> 00:56:28,160
看吧，这样的程序实际运行起来就像是传统的那种程序一样，尽管外表看起来不像
You see, what's happened is we've put that mixing of generation and test into what actually happens in the computer, even though that's not apparently what's happening from looking at our programs.

933
00:56:28,160 --> 00:56:30,230
一切都很简单
OK, well, that seemed easy.

934
00:56:30,230 --> 00:56:33,326
这种机制的所有神奇之处在于DELAY
All of this mechanism got put into this magic delay.

935
00:56:33,326 --> 00:56:36,900
所以你会想，啊，这肯定是最难以理解的地方
So you're saying, gee, that must be where the magic is.

936
00:56:36,900 --> 00:56:39,070
但是并不是
But see there's no magic there either.

937
00:56:39,070 --> 00:56:40,610
其实你应该知道DELAY是什么
You know what delay is.

938
00:56:40,610 --> 00:56:56,490
表达式的DELAY只是一个缩略词，那么，这个要履行计算的承诺到底是什么？
Delay on some expression is just an abbreviation for--  well, what's a promise to compute an expression?

939
00:56:56,490 --> 00:57:03,000
(lambda () <exp>)，就这么简单
Lambda of nil, procedure of no arguments, which is that expression.

940
00:57:03,000 --> 00:57:03,930
这就是整个过程
That's what a procedure is.

941
00:57:03,930 --> 00:57:06,050
它的意思是，这个表达式将会被计算
It says I'm going to compute an expression.

942
00:57:06,050 --> 00:57:07,460
FORCE又是什么？
What's force?

943
00:57:07,460 --> 00:57:10,800
如何履行承诺？
How do I take up a promise?

944
00:57:10,800 --> 00:57:15,890
FORCE一些过程，只是简单地运行它们
Well, force of some procedure, a promise, is just run it.

945
00:57:18,710 --> 00:57:20,120
结束了，就是这样
Done.

946
00:57:20,120 --> 00:57:23,580
并没有什么离奇
So there's no magic there at all.

947
00:57:23,580 --> 00:57:26,440
总结一下，我们都做了点什么？
Well, what have we done?

948
00:57:26,440 --> 00:57:30,960
我们说，传统的编程方式更有效
We said the old style, traditional style of programming is more efficient.

949
00:57:30,960 --> 00:57:35,260
使用流来编程，程序更为明晰
And the stream thing is more perspicuous.

950
00:57:35,260 --> 00:57:43,350
我们设法用DELAY，使流获得了和其它过程一样的运行效果
And we managed to make the stream procedures run like the other procedures by using delay.

951
00:57:43,350 --> 00:57:54,440
DELAY所做的就是，把我们程序中的事件顺序与实际发生在机器中的事件顺序分离开来
And the thing that delay did for us was to de-couple the apparent order of events in our programs from the actual order of events that happened in the machine.

952
00:57:54,440 --> 00:57:56,540
这就是DELAY的作用
That's really what delay is doing.

953
00:57:56,540 --> 00:57:58,290
也是全部的重点
That's exactly the whole point.

954
00:57:58,290 --> 00:58:09,182
我们放弃了这种想法，即过程结构与实际运行映射出清晰的时间性
We've given up the idea that our procedures, as they run, or as we look at them, mirror some clear notion of time.

955
00:58:09,182 --> 00:58:16,690
放弃这种想法，我们给予DELAY以改变计算顺序的自由
And by giving that up, we give delay the freedom to arrange the order of events in the computation the way it likes.

956
00:58:16,690 --> 00:58:17,610
整个思想就是这样
That's the whole idea.

957
00:58:17,610 --> 00:58:24,200
我们分离了程序表面上的顺序与实际运行的顺序
We de-couple the apparent order of events in our programs from the actual order of events in the computer.

958
00:58:24,200 --> 00:58:25,770
对了，还有一个细节
OK, well there's one more detail.

959
00:58:25,770 --> 00:58:29,730
一个技术性的细节，但是也非常重要
It's just a technical detail, but it's actually an important one.

960
00:58:29,730 --> 00:58:39,320
当你运行一些递归的过程时，就像(TAIL (TAIL (TAIL ... 这样
As you run through these recursive programs unwinding, you'll see a lot of things that look like tail of the tail of the tail.

961
00:58:39,320 --> 00:58:43,860
它就会不断在流中通过CONS来计算构造新元素
That's the kind of thing that would happen as I go CONSing down a stream all the way.

962
00:58:43,860 --> 00:59:05,290
每次我这样做，计算TAIL，都要执行过程计算出新元素，每次执行TAIL，都要再次计算，看起来这效率非常低，还不如列表，因为我进行了多余的重复
And if each time I'm doing that, each time to compute a tail, I evaluate a procedure which then has to go re-compute its tail, and re-compute its tail and recompute its tail each time, you can see that's very inefficient compared to just having a list where the elements are all there, and I don't have to re-compute each tail every time I get the next tail.

963
00:59:05,290 --> 00:59:20,390
我们把DELAY稍微改写一下，就可以让整件事变得 -- 我先写一下
So there's one little hack to slightly change what delay is, and make it a thing which is-- I'll write it this way.

964
00:59:20,390 --> 00:59:31,000
(DELAY <exp>)的具体内容是(MEMO-PROC (lambda () <exp>))
The actual implementation, delay is an abbreviation for this thing, memo-proc of a procedure.

965
00:59:31,000 --> 00:59:35,150
MEMO-PROC改变一个过程
Memo-proc is a special thing that transforms a procedure.

966
00:59:35,150 --> 00:59:44,806
取一个没有参数的过程，转变其为只需要执行一次计算的过程
What it does is it takes a procedure of no arguments and it transforms it into a procedure that'll only have to do its computation once.

967
00:59:44,806 --> 00:59:48,700
我们意思是，你给它一个过程
And what I mean by that is, you give it a procedure.

968
00:59:48,700 --> 01:00:02,360
MEMO-PROC的结果是一个新的过程，第一次运行的时候，它计算<exp>，记下来它的结果，从那之后，每次你再运行这个过程，就不用再计算了
The result of memo-proc will be a new procedure, which the first time you call it, will run the original procedure, remember what result it got, and then from ever on after, when you call it, it just won't have to do the computation.

969
01:00:02,360 --> 01:00:05,200
它会把结果存储在一个地方
It will have cached that result someplace.

970
01:00:05,200 --> 01:00:06,550
可以这样来实现MEMO-PROC
And here's an implementation of memo-proc.

971
01:00:11,210 --> 01:00:12,710
一旦你了解怎么做，实现就很容易了
Once you have the idea, it's easy to implement.

972
01:00:12,710 --> 01:00:17,390
MEMO-PROC中，有两个标记变量
Memo-proc is this little thing that has two little flags in there.

973
01:00:17,390 --> 01:00:20,320
一个是，记录是否运行过
It says, have I already been run?

974
01:00:20,320 --> 01:00:23,620
初始值是NO，还没运行过
And initially it says, no, I haven't already been run.

975
01:00:23,620 --> 01:00:29,070
上一次运行后，它的结果是什么？
And what was the result I got the last time I was run?

976
01:00:29,070 --> 01:00:34,360
MEMO-PROC取一个参数为PROC，返回一个没有参数的过程
So memo-proc takes a procedure called proc, and it returns a new procedure of no arguments.

977
01:00:34,360 --> 01:00:38,610
PROC也是一个没有参数的过程
Proc is supposed to be a procedure of no arguments.

978
01:00:38,610 --> 01:00:44,430
如果没有运行过，就做下面的事情
And it says, oh, if I'm not already run, then I'm going to do a sequence of things.

979
01:00:44,430 --> 01:00:48,450
计算PROC，存储它的值
I'm going to compute proc, I'm going to save that.

980
01:00:48,450 --> 01:00:51,140
存储在变量RESULT中
I'm going to stash that in the variable result.

981
01:00:51,140 --> 01:00:56,610
然后对already-run?赋值，提醒自己已经运行过了，最后返回result
I'm going to make a note to myself that I've already been run, and then I'll return the result.

982
01:00:56,610 --> 01:00:59,010
所以整件事即如果你没有运行过，就计算一次
So that's if you compute it if it's not already run.

983
01:00:59,010 --> 01:01:03,420
如果已经运行过，直接返回结果就好了
If you call it and it's already been run, it just returns the result.

984
01:01:03,420 --> 01:01:08,400
这是一种叫“记忆化”的小技巧
So that's a little clever hack called memorization.

985
01:01:08,400 --> 01:01:15,270
这样的话，这一串东西就不会来反复的计算TAIL了
And in this case, it short circuits having to re-compute the tail of the tail of the tail of the tail of the tail.

986
01:01:15,270 --> 01:01:17,810
不再那样的没效率了
So there isn't even that kind of inefficiency.

987
01:01:17,810 --> 01:01:24,210
事实上，这样做甚至和传统的那种程序效率是一样的
And in fact, the streams will run with pretty much the same efficiency as the other programs precisely.

988
01:01:24,210 --> 01:01:33,610
记住，再次提醒，整个的思想在于，过程与数据之间没有一个明确的分界线
And remember, again, the whole idea of this is that we've used the fact that there's no really good dividing line between procedures and data.

989
01:01:33,610 --> 01:01:38,760
这个数据结构看起来，有点像一个过程
We've written data structures that, in fact, are sort of like procedures.

990
01:01:38,760 --> 01:01:49,620
它使我们可以在这里放置一个结构，不断的迭代计算自身
And what that's allowed us to do is take an example of a common control structure, in this place iteration.

991
01:01:49,620 --> 01:01:55,496
我们构造的这个数据结构，其中有一个过程，这个过程可以通过迭代，产生新的结构
And we've built a data structure which, since itself is a procedure, kind of has this iteration control structure in it.

992
01:01:55,496 --> 01:01:58,650
这就是流的实质
And that's really what streams are.

993
01:01:58,650 --> 01:01:59,900
好的，大家有什么问题吗？
OK, questions?

994
01:02:03,950 --> 01:02:13,052
我是这样理解的，你刚才说(TAIL (TAIL (TAIL ...，没有没有MEMO-PROC的话，FORCE仅仅只是执行了一次过程而已
AUDIENCE: Your description of tail-tail-tail, if I understand it correctly, force is actually execution of a procedure, if it's done without this memo-proc thing.

995
01:02:13,052 --> 01:02:16,380
你说使用那个MEMO-PROC就不会有那样的问题
And you implied that memo-proc gets around that problem.

996
01:02:16,380 --> 01:02:23,910
难道(TAIL (TAIL (TAIL ... 不是每次都在进行计算吗？ -- [教授]哦，对的
Doesn't it only get around it if tail-tail-tail is always executing exactly the same-- PROFESSOR: Oh, that's-- sure.

997
01:02:23,910 --> 01:02:26,050
我忘记说了
PROFESSOR: I guess I missed that point.

998
01:02:26,050 --> 01:02:26,540
你是对的
PROFESSOR: Oh, sure.

999
01:02:26,540 --> 01:02:31,290
不小心漏掉了这点
I mean the point is--  yeah.

1000
01:02:31,290 --> 01:02:34,160
我的意思是，不用重复计算也可以得到结果
I mean I have to do a computation to get the answer.

1001
01:02:34,160 --> 01:02:42,980
关键在于，一旦你计算过(TAIL STREAM)，当你计算(TAIL (TAIL STREAM))的时候，就不用再计算第一个TAIL了
But the point is, once I've found the tail of the stream, to get the tail of the tail, I shouldn't have had to re-compute the first tail.

1002
01:02:42,980 --> 01:02:46,460
明白了吧，如果我没有用MEMO-PROC，还要再计算一遍(TAIL STREAM)
See, and if I didn't use memo-proc, that re-computation would have been done.

1003
01:02:46,460 --> 01:02:47,710
明白了
AUDIENCE: I understand now.

1004
01:02:50,830 --> 01:02:56,830
之前的例子中你提到过，我们可以使用代换模型因为这里没有副作用
AUDIENCE: In one of your examples, you mentioned that we were able to use the substitution model because there are no side effects.

1005
01:02:56,830 --> 01:03:03,620
如果流通过的一个处理单元 -- 如果有副作用呢？如果有了状态？
What if we had a single processing unit-- if we had a side effect, if we had a state?

1006
01:03:03,620 --> 01:03:09,120
我们还可以用这种流的结构吗？
Could we still practically build the stream model?

1007
01:03:09,120 --> 01:03:09,530
可能吧
PROFESSOR: Maybe.

1008
01:03:09,530 --> 01:03:10,540
很难说
That's a hard question.

1009
01:03:10,540 --> 01:03:18,960
我可能会花很长时间来探讨代换模型和副作用无法共存
I'm going to talk a little bit later about the places where substitution and side effects don't really mix very well.

1010
01:03:18,960 --> 01:03:25,170
通常情况下，除非你非常小心，否则副作用会把一切弄的很糟糕
But in general, I think the answer is unless you're very careful, any amount of side effect is going to mess up everything.

1011
01:03:35,490 --> 01:03:39,410
我不是很理解MEMO-PROC这个过程
AUDIENCE: Sorry, I didn't quite understand the memo-proc operation.

1012
01:03:39,410 --> 01:03:41,990
当你执行lambda的时候
When do you execute the lambda?

1013
01:03:41,990 --> 01:03:47,600
换句话说，当MEMO-PROC执行的时候，只生成了lambda表达式
In other words, when memo-proc is executed, just this lambda expression is being generated.

1014
01:03:47,600 --> 01:03:50,390
但是我不太清楚是什么时候执行的
But it's not clear to me when it's executed.

1015
01:03:50,390 --> 01:03:51,350
好的
PROFESSOR: Right.

1016
01:03:51,350 --> 01:03:57,930
MEMO-PROC所做的 -- 作为MEMO-PROC参数是PROC，一个没有参数的过程
What memo-proc does-- remember, the thing that's going into memo-proc, the thing proc, is a procedure of no arguments.

1017
01:03:57,930 --> 01:04:00,390
某个时刻，你会调用到它
And someday, you're going to call it.

1018
01:04:00,390 --> 01:04:06,620
MEMO-PROC把一个过程转化为另一个过程，某个时刻你会调用到它
Memo-proc translates that procedure into another procedure of no arguments, which someday you're going to call.

1019
01:04:06,620 --> 01:04:09,890
就是这个lambda
That's that lambda.

1020
01:04:09,890 --> 01:04:24,100
这里，当这一部分构造成为流的TAIL的时候，这个没有参数的过程，会在之后的某个时刻被调用到
So here, where I initially built as my tail of the stream, say, this procedure of no arguments, which someday I'll call.

1021
01:04:24,100 --> 01:04:30,650
相对应的，我把这一部分理解为是MEMO-PROC，某个时刻会被调用到的
Instead, I'm going to have the tail of the stream be memo-proc of it, which someday I'll call.

1022
01:04:30,650 --> 01:04:47,642
所以这个lambda，会在你调用MEMO-PROC得到结果的时候被调用，正如你之前设置过的一样
So that lambda of nil, that gets called when you call the memo-proc, when you call the result of that memo-proc, which would be ordinarily when you would have called the original thing that you set it.

1023
01:04:47,642 --> 01:04:52,610
我的意思是，你调用MEMO-PROC的时候，你只是返回了一个lambda
AUDIENCE: OK, the reason I ask is I had a feeling that when you call memo-proc, you just return this lambda.

1024
01:04:52,610 --> 01:04:53,770
对啊
PROFESSOR: That's right.

1025
01:04:53,770 --> 01:04:58,100
你调用MEMO-PROC的时候，返回了一个lambda
When you call memo-proc, you return the lambda.

1026
01:04:58,100 --> 01:05:02,270
你也没有执行<exp>，直到你第一次需要执行它的时候
You never evaluate the expression at all, until the first time that you would have evaluated it.

1027
01:05:07,590 --> 01:05:14,240
我这样理解对吗？你构造了一个列表，其中的元素还没有被计算
AUDIENCE: Do I understand it right that you actually have to build the list up, but the elements of the list don't get evaluated?

1028
01:05:14,240 --> 01:05:15,630
表达式没有被计算？
The expressions don't get evaluated?

1029
01:05:15,630 --> 01:05:18,540
但在在每一个阶段，你还是构造了列表
But at each stage, you actually are building a list.

1030
01:05:18,540 --> 01:05:20,700
嗯，我应该这样说
PROFESSOR: That's-- I really should have said this.

1031
01:05:20,700 --> 01:05:22,270
这个问题不错
That's a really good point.

1032
01:05:22,270 --> 01:05:23,660
但是，也不全对
No, it's not quite right.

1033
01:05:23,660 --> 01:05:25,080
因为实际发生的事情是这样的
Because what happens is this.

1034
01:05:25,080 --> 01:05:26,890
我先把这个画成序对
Let me draw this as pairs.

1035
01:05:26,890 --> 01:05:32,740
假设我要构造一个特别大的流，比如枚举整数，从1到1,000,000,000
Suppose I'm going to make a big stream, like enumerate interval, 1 through 1 billion.

1036
01:05:32,740 --> 01:05:43,045
就是1，和一个计算的约定
What that is, is a pair with a 1 and a promise.

1037
01:05:46,520 --> 01:05:47,890
就是这样
That's exactly what it is.

1038
01:05:47,890 --> 01:05:49,140
什么都没有构造
Nothing got built up.

1039
01:05:51,600 --> 01:05:56,370
当我继续的时候，FORCE这一部分，会发生什么？
When I go and force this, and say, what happens?

1040
01:05:56,370 --> 01:06:00,530
这个东西递归的产生了CONS
Well, this thing is now also recursively a CONS.

1041
01:06:00,530 --> 01:06:11,350
这个约定生成了下一个东西，就是2和一个约定
So that this promise now is the next thing, which is a 2 and a promise to do more.

1042
01:06:11,350 --> 01:06:14,470
一直这样下去
And so on and so on and so on.

1043
01:06:14,470 --> 01:06:18,200
所以你沿着流这样下来，并没有构造什么
So nothing gets built up until you walk down the stream.

1044
01:06:18,200 --> 01:06:25,500
因为这个东西不是列表，只是一个生成列表的约定，技术上来说，是一个过程
Because what's sitting here is not the list, but a promise to generate the list. And by promise, technically I mean procedure.

1045
01:06:28,050 --> 01:06:30,485
因此并没有构造列表
So it doesn't get built up.

1046
01:06:30,485 --> 01:06:34,280
我应该早点说的
Yeah, I should have said that before this point.

1047
01:06:34,280 --> 01:06:34,490
好吧
OK.

1048
01:06:34,490 --> 01:06:34,790
就到这里
Thank you.

1049
01:06:34,790 --> 01:06:36,340
大家休息一下吧
Let's take a break.

