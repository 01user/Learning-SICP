1
00:00:18,550 --> 00:00:21,840
上次Gerry教授揭晓了秘密
PROFESSOR: Well, last time Gerry really let the cat out of the bag.

2
00:00:22,496 --> 00:00:24,608
他介绍了赋值的概念
He introduced the idea of assignment.

3
00:00:26,350 --> 00:00:33,616
赋值与状态
Assignment and state.

4
00:00:37,480 --> 00:00:40,032
正如我们所见
And as we started to see, the implications

5
00:00:40,720 --> 00:00:44,416
#TBD
of introducing assignment and state into the language are absolutely frightening.

6
00:00:45,088 --> 00:00:48,624
首先 代换模型不再能够描述求值过程了
First of all, the substitution model of evaluation breaks down.

7
00:00:49,136 --> 00:00:52,480
我们不得不使用更为复杂的环境模型
And we have to use this much more complicated environment model

8
00:00:52,480 --> 00:00:54,272
这种带图示的机械式的东西#TBD
this very mechanistic thing with diagrams,

9
00:00:54,288 --> 00:00:57,248
#TBD
even to say what statements in the programming language mean.

10
00:00:58,464 --> 00:01:00,128
这不仅仅是技术上的一点 #TBD
And that's not a mere technical point.

11
00:01:00,260 --> 00:01:03,280
代换模型在这里完全失效了
See, it's not that we had this particular substitution model and,

12
00:01:03,600 --> 00:01:05,680
我们得想些其它办法
well, it doesn't quite work, so we have to do something else.

13
00:01:05,712 --> 00:01:09,792
代换模型什么都做不了
It's that nothing like the substitution model can work.

14
00:01:10,730 --> 00:01:16,928
因为突然地 一个变量不再是代表着一个值了
Because suddenly, a variable is not just something that stands for a value.

15
00:01:17,952 --> 00:01:23,344
变量现在用来指定一个存放值的位置
A variable now has to somehow specify a place that holds a value.

16
00:01:23,630 --> 00:01:26,144
并且在这个位置的值是可以变的
And the value that's in that place can change.

17
00:01:30,280 --> 00:01:34,096
比如像(F X)这样的表达式
Or for instance, an expression like f of x

18
00:01:37,360 --> 00:01:39,648
就可能含有副作用
might have a side effect in it.

19
00:01:40,410 --> 00:01:42,608
如果我们执行(F X)得到某个值
So if we say f of x and it has some value,

20
00:01:43,184 --> 00:01:45,344
之后我们再次执行(F X)
and then later we say f of x again,

21
00:01:47,248 --> 00:01:49,730
可能因为求值的顺序而得到不同的值
we might get a different value depending on the order.

22
00:01:49,730 --> 00:01:52,144
所以突然间 我们不能仅仅关注于值
So suddenly, we have to think not only about values

23
00:01:52,528 --> 00:01:53,600
也要关注时间
but about time.

24
00:01:57,970 --> 00:02:02,520
序对也不仅仅只是CAR和CDR了部分
And then things like pairs are no longer just their CARs and their CDRs.

25
00:02:02,520 --> 00:02:05,616
#TBD
A pair now is not quite its CAR and its CDR.

26
00:02:05,808 --> 00:02:07,056
#TBD
It's rather its identity.

27
00:02:08,449 --> 00:02:11,650
序对具有“身份”
So a pair has identity.

28
00:02:11,650 --> 00:02:12,592
它是一个对象
It's an object.

29
00:02:21,330 --> 00:02:25,152
两个具有相同CAR和CDR部分的序对
And two pairs that have the same CAR and CDR

30
00:02:25,408 --> 00:02:27,056
可能相同也可能不同
well, might be the same or different,

31
00:02:27,872 --> 00:02:30,512
因为这之中可能存在“共享”
because suddenly we have to worry about sharing.

32
00:02:34,960 --> 00:02:39,456
一引入赋值 这些就变成要考虑的问题了
So all of these things enter as soon as we introduce assignment.

33
00:02:40,480 --> 00:02:43,984
确实 这和我们说讲代换的时候差别悬殊
See, this is a really far cry from where we started with substitution.

34
00:02:45,040 --> 00:02:48,912
技术上来看 我们思考起来更加困难了
It's a technically harder way of looking at things

35
00:02:48,940 --> 00:02:53,456
因为我们必须相加机械地思考程序语言
because we have to think more mechanistically about our programming language.

36
00:02:53,472 --> 00:02:55,344
而不能仅仅用数学的方式来思考
We can't just think about it as mathematics.

37
00:02:55,710 --> 00:02:58,608
我们也会遇到哲学问题
It's philosophically harder,

38
00:02:59,152 --> 00:03:00,656
我们会被这样的问题所困扰：
because suddenly there are all these funny issues

39
00:03:00,672 --> 00:03:02,384
事物的“改变”指的是什么？
what does it mean that something changes

40
00:03:02,384 --> 00:03:03,776
两个事物“同一”又如何判别？
or that two things are the same.

41
00:03:03,840 --> 00:03:06,832
并且 这也会给我们编程带来困扰
And also, it's programming harder, because

42
00:03:07,470 --> 00:03:08,544
正如Sussman教授上节课中讲的那样
as Gerry showed last time,

43
00:03:08,560 --> 00:03:12,200
错误的序列和别名会产生BUG
there are all these bugs having to do with bad sequencing and aliasing

44
00:03:12,224 --> 00:03:16,190
这些问题在不需要考虑“对象”的语言中 是不存在的
that just don't exist in a language where we don't worry about objects.

45
00:03:18,210 --> 00:03:21,200
我们是怎样陷入这样的困境的呢？
Well, how'd we get into this mess?

46
00:03:24,010 --> 00:03:27,200
我们这样做的原因在于
Remember what we did, the reason we got into this is

47
00:03:27,408 --> 00:03:31,472
我们想要构造模块化的系统
because we were looking to build modular systems.

48
00:03:35,152 --> 00:03:41,040
我们想把系统划分为数个自然组合的小块
We wanted to build systems that fall apart into chunks that seem natural.

49
00:03:42,760 --> 00:03:46,112
举例来说 我们构造一个随机数发生器
So for instance, we want to take a random number generator

50
00:03:46,224 --> 00:03:49,408
把该发生器的内部状态封装起来
and package up the state of that random number generator inside of it

51
00:03:50,256 --> 00:03:53,712
这样我们就可以把选取随机数
so that we can separate the idea of picking random numbers

52
00:03:54,656 --> 00:03:57,792
和用于估计的蒙特卡洛方法分离开来 #TBD
from the general Monte Carlo strategy of estimating something

53
00:03:58,650 --> 00:04:01,520
#TBD
and separate that from the particular way that you

54
00:04:01,904 --> 00:04:05,744
#TBD
work with random numbers in that formula developed by Cesaro for pi.

55
00:04:06,800 --> 00:04:07,920
相似地
And similarly,

56
00:04:09,616 --> 00:04:11,744
当我们着手构建事物的模型时
when we go off and construct some models of things,

57
00:04:12,352 --> 00:04:16,016
我们去构建现实世界中事物的模型
Ah, if we go off and model a system that we see in the real world,

58
00:04:17,310 --> 00:04:19,424
我们想把程序组织成许多自然的部分#TBD
we'd like our program to break into natural pieces,

59
00:04:19,440 --> 00:04:23,160
这些部分就是现实事物的镜像
pieces that mirror the parts of the system that we see in the real world.

60
00:04:24,900 --> 00:04:27,568
举个例子 对于一个数字电路
So for example, if we look at a digital circuit,

61
00:04:28,368 --> 00:04:29,184
我们会说
we say, gee,

62
00:04:30,440 --> 00:04:31,440
这儿有一个电路
there's a circuit

63
00:04:32,080 --> 00:04:35,160
它有一个这样的元件 有一个那样的元件
and it has a piece and it has another piece.

64
00:04:40,100 --> 00:04:43,580
这些元件都有不同的“身份”
And these different pieces sort of have identity.

65
00:04:43,580 --> 00:04:44,592
它们都有各自的状态
They have state.

66
00:04:45,550 --> 00:04:47,136
状态附着在电路上
And the state sits on these wires.

67
00:04:48,580 --> 00:04:51,936
我们认为这两个元件是不同的对象
And we think of this piece as an object that's different from that as an object.

68
00:04:52,540 --> 00:04:53,856
当我们观察到系统发生了变化
And when we watch the system change,

69
00:04:53,872 --> 00:04:55,408
信号从这里传递过来
we think about a signal coming in here

70
00:04:55,632 --> 00:04:58,416
改变了可能存放在这里的状态 并向这里继续传播
changing a state that might be here and going here

71
00:04:58,672 --> 00:05:00,752
和一个存储在这里的状态交互
and interacting with a state that might be stored there,

72
00:05:01,248 --> 00:05:02,170
依次类推
and so on and so on.

73
00:05:06,860 --> 00:05:11,248
我们想要在计算机中
So what we'd like is we'd like to build in the computer

74
00:05:12,768 --> 00:05:14,368
构建模块化的系统
systems that fall into pieces

75
00:05:14,688 --> 00:05:17,872
来反映我们对现实的看法
that fall into pieces that mirror our view of reality,

76
00:05:17,888 --> 00:05:20,912
#TBD
of the way that the actual systems we're modeling seem to fall into pieces.

77
00:05:23,200 --> 00:05:23,488
然而
Well,

78
00:05:25,744 --> 00:05:28,992
构建像这样的系统
maybe the reason that building systems like this

79
00:05:28,992 --> 00:05:31,504
看起来带来了不少技术上的麻烦
seems to introduce such technical complications

80
00:05:31,520 --> 00:05:32,752
但这不是计算机造成的
has nothing to do with computers.

81
00:05:33,610 --> 00:05:35,600
或许 我们花了那么大的功夫
See, maybe the real reason

82
00:05:36,704 --> 00:05:40,944
才让程序反映现实世界的真正原因
that we pay such a price to write programs that mirror our view of reality

83
00:05:41,520 --> 00:05:43,136
是因为我们对现实世界的认识出了错
is that we have the wrong view of reality.

84
00:05:44,550 --> 00:05:46,752
或许时间只是幻觉
See, maybe time is just an illusion,

85
00:05:47,264 --> 00:05:48,608
什么都没有改变
and nothing ever changes.

86
00:05:50,150 --> 00:05:51,712
就拿这个粉笔来说
See, for example, if I take this chalk,

87
00:05:52,448 --> 00:05:53,776
我们认为它是一个对象
and we say, gee, this is an object

88
00:05:54,016 --> 00:05:54,992
它有自己的状态
and it has a state.

89
00:05:55,820 --> 00:05:59,296
每时每刻 它都有一个位置与速度
At each moment it has a position and a velocity.

90
00:05:59,710 --> 00:06:01,488
如果我们做点什么 就可以改变它的状态
And if we do something, that state can change.

91
00:06:04,340 --> 00:06:07,376
但是你如果了解一点相对性的概念
But if you studied any relativity, for instance,

92
00:06:07,744 --> 00:06:09,712
你可能不会认为粉笔的路径
you know that you don't think of the path of that chalk

93
00:06:09,728 --> 00:06:11,340
是某种东西随着时间运动而形成的#TBD
as something that goes on instant by instant.

94
00:06:11,340 --> 00:06:15,664
把整个粉笔的存在认为是时空中的路径，这是很有洞察力的 #TBD
It's more insightful to think of that whole chalk's existence as a path in space-time.

95
00:06:16,020 --> 00:06:17,376
全部都展开了
that's all splayed out.

96
00:06:17,872 --> 00:06:19,840
没有单独的位置与速度
There aren't individual positions and velocities.

97
00:06:19,840 --> 00:06:23,808
只有在时空中不变的存在 #TBD
There's just its unchanging existence in space-time.

98
00:06:24,640 --> 00:06:26,512
相似地 如果我们来考察这个电气系统
Similarly, if we look at this electrical system,

99
00:06:27,690 --> 00:06:30,432
我们假设这个系统实现的是
if we imagine this electrical system is implementing

100
00:06:30,592 --> 00:06:33,960
某种信号处理系统
sort of signal processing system,

101
00:06:34,368 --> 00:06:36,688
#TBD
the signal processing engineer who put that thing together

102
00:06:36,750 --> 00:06:41,408
#TBD
doesn't think of it as, well, at each instance there's a voltage coming in.

103
00:06:41,490 --> 00:06:43,168
转换成了某种东西
And that translates into something.

104
00:06:43,340 --> 00:06:45,520
影响了这里的状态
And that affects the state over here,

105
00:06:45,536 --> 00:06:46,810
还改变了那里的状态
which changes the state over here.

106
00:06:46,810 --> 00:06:50,112
没有一个做信号处理的会这样想
Nobody putting together a signal processing system thinks about it like that.

107
00:06:50,420 --> 00:06:51,840
相反 你会说
Instead, you say there's this signal

108
00:06:54,048 --> 00:06:58,060
这里有一个在时间上伸展的信号
that's splayed out over time.

109
00:06:58,060 --> 00:06:59,488
如果把这个看做一个滤波器
And if this is acting as a filter,

110
00:07:00,208 --> 00:07:04,048
这个滤波器会把整个信号转化成
this whole thing transforms this whole thing

111
00:07:04,288 --> 00:07:07,040
不同的输出信号
for some sort of other output.

112
00:07:09,570 --> 00:07:13,296
你不必考虑在某个时间点上事物的状态#TBD
You don't think of it as what's happening instant by instant as the state of these things.

113
00:07:14,160 --> 00:07:17,328
我们把这个盒子看做一个整体
And somehow you think of this box as a whole thing,

114
00:07:17,328 --> 00:07:21,968
而不是在某些个特定时间的状态的集合 #TBD
not as little pieces sending messages of state to each other at particular instants.

115
00:07:28,250 --> 00:07:31,136
今天我们将介绍另一种分解系统的方法
Well, today we're going to look at another way to decompose systems

116
00:07:31,360 --> 00:07:35,456
站在信号工程师的角度去看待现实世界
that's more like the signal processing engineer's view of the world

117
00:07:35,696 --> 00:07:38,960
而不再认为对象间通过消息传递来通信
than it is like thinking about objects that communicate sending messages.

118
00:07:41,130 --> 00:07:43,744
它被称为“流处理”
That's called stream processing.

119
00:07:54,570 --> 00:07:58,960
我们打算展示
And we're going to start by showing

120
00:08:00,592 --> 00:08:04,160
如何让我们的程序变得更加统一
by showing how we can make our programs more uniform

121
00:08:05,152 --> 00:08:06,544
从中看到更多的共性
and see a lot more commonality

122
00:08:06,656 --> 00:08:09,888
如果我们跳出这些程序 #TBD
if we throw out of these programs

123
00:08:10,816 --> 00:08:12,304
我们会发现
what you might say is a

124
00:08:12,352 --> 00:08:15,120
#TBD
inordinate concern with worrying about time.

125
00:08:16,896 --> 00:08:20,224
我们先来对比两个过程
Let me start by comparing two procedures.

126
00:08:23,552 --> 00:08:25,690
第一个是这样
The first one does this.

127
00:08:25,690 --> 00:08:27,770
想像这有一个树
We imagine that there's a tree.

128
00:08:30,400 --> 00:08:32,144
一个由整数构成的树
Say there's a tree of integers.

129
00:08:33,280 --> 00:08:34,420
一个二叉树
It's a binary tree.

130
00:08:39,100 --> 00:08:40,230
看起来就像这样
So it looks like this.

131
00:08:40,230 --> 00:08:42,928
在每个节点上都有一个整数
And there's integers in each of the nodes.

132
00:08:45,184 --> 00:08:47,808
我们想计算
And what we would like to compute is

133
00:08:48,672 --> 00:08:51,568
对这个树中所有的奇数
for each odd number sitting here,

134
00:08:52,304 --> 00:08:55,104
计算它们的平方和
we'd like to find the square and then sum up all those squares.

135
00:08:57,056 --> 00:08:59,480
我们对这类问题很熟悉
Well, that should be a familiar kind of thing.

136
00:08:59,480 --> 00:09:01,952
有一种递归策略求解它
There's a recursive strategy for doing it.

137
00:09:02,930 --> 00:09:04,352
观察每个叶子节点
We look at each leaf, and either

138
00:09:04,560 --> 00:09:06,688
如果是奇数我们就求它的平方 并加和
it's going to contribute the square of the number if it's odd

139
00:09:06,704 --> 00:09:07,770
如果是偶数 就是0
or 0 if it's even.

140
00:09:08,680 --> 00:09:12,112
递归地看 对于每一颗树 我们可以说
And then recursively, we can say at each tree

141
00:09:12,656 --> 00:09:13,840
它的平方和等于
the sum of all of them is

142
00:09:13,920 --> 00:09:15,936
右子树的平方和 加上左子树的平方和
the sum coming from the right branch and the left branch,

143
00:09:16,256 --> 00:09:17,640
就这样沿着节点递归下去
and recursively down through the nodes.

144
00:09:17,640 --> 00:09:20,360
这种思考方式我们已经很熟悉了
And that's a familiar way of thinking about programming.

145
00:09:20,360 --> 00:09:22,592
我们在幻灯片上看一下这个
Let's actually look at that on the slide.

146
00:09:23,820 --> 00:09:26,752
为了计算一棵树中奇数的平方和
We say to sum the odd squares in a tree,

147
00:09:27,376 --> 00:09:29,360
我们先要判断它是否是一个叶子节点
there's a test. Either it's a leaf node,

148
00:09:29,824 --> 00:09:31,952
判断方法则是考察该节点是否为整数
and we're going to check to see if it's an integer,

149
00:09:32,880 --> 00:09:36,384
继而判断其奇偶性 以及是否应该求取平方并加和
and then either it's odd, in which we take the square, or else it's 0.

150
00:09:37,160 --> 00:09:38,992
然后 整个的解就是
And then the sum of the whole thing

151
00:09:39,216 --> 00:09:42,120
左、右子树解的总和
is the sum coming from the left branch and the right branch.

152
00:09:46,340 --> 00:09:50,560
好的 让我们再来和下面一个问题对比一下
OK, well, let me contrast that with a second problem.

153
00:09:51,560 --> 00:09:53,680
假如给你一个整数N
Suppose I give you an integer n,

154
00:09:54,736 --> 00:09:57,888
再给定一个函数 把它应用在
and then some function to compute of the first of each integer

155
00:09:57,936 --> 00:09:58,832
1到N的每一个数上
1 through n.

156
00:09:59,100 --> 00:10:01,088
我想把其中的一些值收集成一个表
And then I want to collect together in a list

157
00:10:01,280 --> 00:10:04,656
那些满足某种属性的函数值
all those function values that satisfy some property.

158
00:10:05,600 --> 00:10:06,880
这是种一般性的说法
That's a general kind of thing.

159
00:10:06,880 --> 00:10:07,984
说得更具体一点
Let's say to be specific,

160
00:10:08,624 --> 00:10:10,480
假设对于每个整数K
let's imagine that for each integer, k,

161
00:10:10,656 --> 00:10:12,512
计算第K个斐波那契数
we're going to compute the k Fibonacci number.

162
00:10:14,210 --> 00:10:16,272
然后挑出其中的奇数
And then we'll see which of those are odd

163
00:10:16,832 --> 00:10:18,400
并把它们组成一个表
and assemble those into a list.

164
00:10:19,050 --> 00:10:20,710
这个过程是这样的
So here's a procedure that does that.

165
00:10:23,730 --> 00:10:26,240
寻找前N个斐波那契数中的奇数
Find the odd Fibonacci numbers among the first n.

166
00:10:26,240 --> 00:10:28,910
这里是我们一直以来采用的循环方法
And here is a standard loop the way we've been writing it.

167
00:10:28,910 --> 00:10:29,824
用到了递归
This is a recursion.

168
00:10:30,800 --> 00:10:31,792
以K为循环变量
It's a loop on k,

169
00:10:32,032 --> 00:10:34,352
如果K大于N 返回空表
and says if k is bigger than n, it's the empty list.

170
00:10:35,136 --> 00:10:37,360
否则计算第K个斐波那契数
Otherwise we compute the k-th Fibonacci number,

171
00:10:37,440 --> 00:10:38,064
将其与变量F绑定
call that f.

172
00:10:40,370 --> 00:10:46,016
如果是奇数 我们把它与从K+1计算得到的表相连接
If it's odd, we CONS it on to the list starting with the next one.

173
00:10:47,690 --> 00:10:50,128
否则 我们只取从K+1计算得到的结果
And otherwise, we just take the next one.

174
00:10:50,736 --> 00:10:53,000
这是迭代式循环的标准写法
And this is the standard way we've been writing iterative loops.

175
00:10:53,000 --> 00:10:55,568
我们以1为初值 启动这个循环
And we start off calling that loop with 1.

176
00:10:57,584 --> 00:11:00,064
好的 就是这两个过程
OK, so there are two procedures.

177
00:11:01,600 --> 00:11:02,900
它们看起来非常不同
Those procedures look very different.

178
00:11:02,900 --> 00:11:04,208
完全不同的结构
They have very different structures.

179
00:11:04,250 --> 00:11:06,896
然而 从一个特定的角度来看
Yet from a certain point of view,

180
00:11:06,928 --> 00:11:09,616
两个过程做的事情是一样的
those procedures are really doing very much the same thing.

181
00:11:11,330 --> 00:11:14,672
如果我是一个信号处理工程师
So if I was talking like a signal processing engineer,

182
00:11:14,704 --> 00:11:16,816
我可能会说
what I might say

183
00:11:18,240 --> 00:11:26,768
第一个过程枚举了树的叶节点
the first procedure enumerates the leaves of a tree.

184
00:11:31,160 --> 00:11:34,560
可以认为是信号从一个全是叶节点的地方输出
And then we can think of a signal coming out of that, which is all the leaves.

185
00:11:35,330 --> 00:11:43,392
我们想要过滤出其中的奇数
We'll filter them to see which ones are odd,

186
00:11:43,584 --> 00:11:44,944
把它们放入某种滤波器中
put them through some kind of filter.

187
00:11:45,190 --> 00:11:47,792
然后再把它们放入某种换能器
We'll then put them through a kind of transducer.

188
00:11:49,200 --> 00:11:51,696
对每一个输出 我们对其取平方
And for each one of those things, we'll take the square.

189
00:11:54,448 --> 00:11:57,440
最后把结果累积在一起
And then we'll accumulate all of those.

190
00:11:58,290 --> 00:12:00,048
我们以0为初值
We'll accumulate them by sticking them together

191
00:12:00,352 --> 00:12:03,370
通过加法把它们积累起来
with addition starting from 0.

192
00:12:07,140 --> 00:12:08,210
这是第一个程序
That's the first program.

193
00:12:08,210 --> 00:12:09,184
对于第二个程序
The second program,

194
00:12:09,248 --> 00:12:11,216
我也可以用一种非常类似的方法来描述
I can describe in a very, very similar way.

195
00:12:11,780 --> 00:12:13,424
我们枚举
I'll say, we'll enumerate

196
00:12:15,808 --> 00:12:19,104
从1到N这个区间上的数
the numbers on this interval, for the interval 1 through n.

197
00:12:22,500 --> 00:12:24,400
对于每个数
We'll, for each one,

198
00:12:25,456 --> 00:12:26,928
计算对应的斐波那契数
compute the Fibonacci number,

199
00:12:27,792 --> 00:12:29,270
再放入一个换能器
put them through a transducer.

200
00:12:29,270 --> 00:12:30,784
对于输出的结果
We'll then take the result of that,

201
00:12:31,312 --> 00:12:34,208
再通过奇偶性进行过滤
and we'll filter it for oddness.

202
00:12:35,976 --> 00:12:39,350
最后，我们将这些放入累积器
And then we'll take those and put them into an accumulator. #LAST

203
00:12:39,350 --> 00:12:47,110
这里我们累积出一个列表，传递CONS方法，与空列表作为参数
This time we'll build up a list, so we'll accumulate with CONS starting from the empty list.

204
00:12:47,110 --> 00:12:51,900
从这个角度来看，这两个程序真的是太相似了
So this way of looking at the program makes the two seem very, very similar.

205
00:12:51,900 --> 00:12:58,050
问题在于两个程序的写法导致我们看不出其中的共性
The problem is that that commonality is completely obscured when we look at the procedures we wrote.

206
00:12:58,050 --> 00:13:06,300
我们回头再来看第一个奇数平方和的问题，问题来了，枚举器是什么？
Let's go back and look at some odd squares again, and say things like, where's the enumerator?

207
00:13:06,300 --> 00:13:08,140
程序中哪一部分有枚举的作用？
Where's the enumerator in this program?

208
00:13:08,140 --> 00:13:11,230
枚举不是仅仅在一个地方表现出来的
Well, it's not in one place.

209
00:13:11,230 --> 00:13:17,160
在叶子节点的判断处存在一部分
It's a little bit in this leaf-node test, which is going to stop.

210
00:13:17,160 --> 00:13:20,630
也下面的递归结构中也有体现
It's a little bit in the recursive structure of the thing itself.

211
00:13:23,150 --> 00:13:24,120
累积器又在哪儿呢？
Where's the accumulator?

212
00:13:24,120 --> 00:13:25,680
和枚举器类似，也不是在一个地方
The accumulator isn't in one place either.

213
00:13:25,680 --> 00:13:32,180
它由 0 和 + 这两个地方体现出来
It's partly in this 0 and partly in this plus.

214
00:13:32,180 --> 00:13:34,510
累积器的完整过程并不体在唯一一个地方
It's not there as a thing that we can look at.

215
00:13:34,510 --> 00:13:44,470
相似地，我们来观察奇数斐波那契数的例子，程序中也存在枚举器与累积器的含义，但是有些不同
Similarly, if we look at odd Fibs, that's also, in some sense, an enumerator and an accumulator, but it looks very different.

216
00:13:44,470 --> 00:13:55,680
枚举的含义部分的表现在 ( > k n) 的判断中，部分的表现在下面的递归调用中
Because partly, the enumerator is here in this greater than sign in the test. And partly it's in this whole recursive structure in the loop, and the way that we call it.

217
00:13:55,680 --> 00:14:03,600
同样地，累积的含义也被混杂在其中，比如在这里和那里
And then similarly, that's also mixed up in there with the accumulator, which is partly over there and partly over there.

218
00:14:03,600 --> 00:14:14,360
我们之前所画出的盒子在我们的程序中完全看不出来，因为它们混杂在一起了
So these very, very natural pieces, these very natural boxes here don't appear in our programs. Because they're kind of mixed up.

219
00:14:14,360 --> 00:14:16,290
因此，这些程序并没有很好的对问题进行划分
The programs don't chop things up in the right way.

220
00:14:19,450 --> 00:14:31,060
回到计算机科学的基本原理上来，为了控制某种东西，你需要给它命名，即使我们如此思考，我们也并没有完全地控制住它，因为我们没有明确地深入它的内部
Going back to this fundamental principle of computer science that in order to control something, you need the name of it, we don't really have control over thinking about things this way because we don't have our hands in them explicitly.

221
00:14:31,060 --> 00:14:35,510
我们没有一个好的语言来说明
We don't have a good language for talking about them.

222
00:14:35,510 --> 00:14:44,515
好吧，我们来发明合适的语言来构造这些部分
Well, let's invent an appropriate language in which we can build these pieces.

223
00:14:44,515 --> 00:14:50,480
这种语言的关键在于 这些叫作信号的东西到底是什么？
The key to the language is these guys, is what is these things I called signals?

224
00:14:50,480 --> 00:14:53,320
这些沿着箭头传递的又是什么？
What are these things that are flying on the arrows between the boxes?

225
00:14:56,880 --> 00:15:07,980
直接说明吧，这些东西将变成一种叫做流的数据结构，也是发明这个语言的关键
Well, those things are going to be data structures called streams. That's going to be the key to inventing this language.

226
00:15:07,980 --> 00:15:08,600
什么是流呢？
What's a stream?

227
00:15:08,600 --> 00:15:12,220
流，和其它的相似，是一种数据抽象
Well, a stream is, like anything else, a data abstraction.

228
00:15:12,220 --> 00:15:16,870
所以，我先说明它的选择器与构造器分别是什么
So I should tell you what its selectors and constructors are.

229
00:15:16,870 --> 00:15:21,435
构造器我们称其为CONS-stream
For a stream, we're going to have one constructor that's called CONS-stream.

230
00:15:25,690 --> 00:15:32,040
CONS-stream把两个事物放在一起构造出一个流
CONS-stream is going to put two things together to form a thing called a stream.

231
00:15:32,040 --> 00:15:38,010
选择器叫作HEAD，用于从流中提取数据
And then to extract things from the stream, we're going to have a selector called the head of the stream.

232
00:15:38,010 --> 00:15:44,720
可以提取head，也要可以提取tail
So if I have a stream, I can take its head or I can take its tail.

233
00:15:44,720 --> 00:15:53,160
我把我和George的约定告诉你，是想让你明确到底是什么相关的法则
And remember, I have to tell you George's contract here to tell you what the axioms are that relate these.

234
00:15:53,160 --> 00:16:28,440
对于任何的x与y，(HEAD (CONS-STREAM x y)) => x，(TAIL (CONS-STREAM)) => y
And it's going to be for any x and y, if I form the CONS-stream and take the head, the head of CONS-stream of x and y is going to be x and the tail of CONS-stream of x and y is going to be y.

235
00:16:28,440 --> 00:16:34,750
一个构造函数，两个选择函数，一个法则，就是这些
So those are the constructor, two selectors for streams, and an axiom.

236
00:16:34,750 --> 00:16:36,980
这里有点可疑
There's something fishy here.

237
00:16:36,980 --> 00:16:52,810
你可能注意到了这完全和CONS，CAR，CDR序对相关的法则完全一样啊，把CONS-STREAM换成CONS，HEAD换成CAR，TAIL换成CDR，就完全一样了
So you might notice that these are exactly the axioms for CONS, CAR, and CDR. If instead of writing CONS-stream I wrote CONS and I said head was the CAR and tail was the CDR, those are exactly the axioms for pairs.

238
00:16:52,810 --> 00:16:55,130
事实上，还有另一个东西
And in fact, there's another thing here.

239
00:16:55,130 --> 00:17:08,319
我们有一个叫空流的东西，像空列表
We're going to have a thing called the-empty-stream, which is like the-empty-list.

240
00:17:08,319 --> 00:17:10,030
为什么我要介绍这个术语呢？
So why am I introducing this terminology?

241
00:17:10,030 --> 00:17:12,780
为什么我不直接说序对与列表呢？
Why don't I just keep talking about pairs and lists?

242
00:17:12,780 --> 00:17:15,510
好吧，我们将会看到
Well, we'll see.

243
00:17:15,510 --> 00:17:21,560
暂时地，如果你喜欢，为什么不把流假装作列表的另一种术语
For now, if you like, why don't you just pretend that streams really are just a terminology for lists.

244
00:17:21,560 --> 00:17:28,150
一会儿我们就知道了为什么我们需要这样的抽象而不是仅仅把它叫做列表
And we'll see in a little while why we want to keep this extra abstraction layer and not just call them lists.

245
00:17:32,300 --> 00:17:42,120
好的，有了流之后，我们开始构建操作流的语言，有太多有用的东西了
OK, now that we have streams, we can start constructing the pieces of the language to operate on streams. And there are a whole bunch of very useful things that we could start making.

246
00:17:42,120 --> 00:18:05,666
举例来说，我们构建自己的map-stream，以一个流s和一个过程作为参数，生成一个新的流，其中这个过程应用于所有s的后继节点
For instance, we'll make our map box to take a stream, s, and a procedure, and to generate a new stream which has as its elements the procedure applied to all the successive elements of s.

247
00:18:05,666 --> 00:18:07,400
我们以前见过类似的
In fact, we've seen this before.

248
00:18:07,400 --> 00:18:10,950
就是我们以前操作列表的map
This is the procedure map that we did with lists.

249
00:18:10,950 --> 00:18:14,650
除了判断empty-stream的部分，完全就和map一样
And you see it's exactly map, except we're testing for empty-stream.

250
00:18:14,650 --> 00:18:15,560
哦，我忘了说了
Oh, I forgot to mention that.

251
00:18:15,560 --> 00:18:20,510
empty-stream?就和null?差不多，如果是空的，就生成一个空的流
Empty-stream is like the null test. So if it's empty, we generate the empty stream.

252
00:18:20,510 --> 00:18:33,140
否则，就生成一个新的流，第一个元素是过程作用于流的HEAD的值，剩下的是map-stream对流的TAIL作用的结果
Otherwise, we form a new stream whose first element is the procedure applied to the head of the stream, and whose rest is gotten by mapping along with the procedure down the tail of the stream.

253
00:18:33,140 --> 00:18:37,030
看起来着实太像我们之前所讲的map了
So that looks exactly like the map procedure we looked at before.

254
00:18:37,030 --> 00:18:38,350
还有另一件事
Here's another useful thing.

255
00:18:38,350 --> 00:18:40,460
过滤器，就是那个用来过滤的盒子
Filter, this is our filter box.

256
00:18:40,460 --> 00:18:43,890
以一个谓词和一个流作为参数
We're going to have a predicate and a stream.

257
00:18:43,890 --> 00:18:50,160
生成一个新的流，包含了所有在流s中满足谓词pred的元素
We're going to make a new stream that consists of all the elements of the original one that satisfy the predicate.

258
00:18:50,160 --> 00:18:51,270
分条件来看
That's case analysis.

259
00:18:51,270 --> 00:18:56,280
当流s是空的，就返回一个空流
When there's nothing in the stream, we return the empty stream.

260
00:18:56,280 --> 00:19:00,060
这里，用谓词来判断流的头元素
We test the predicate on the head of the stream.

261
00:19:00,060 --> 00:19:08,220
如果为真，就把这个元素和过滤流的尾元素得到的结果连接在一起
And if it's true, we add the head of the stream onto the result of filtering the tail of the stream.

262
00:19:08,220 --> 00:19:13,500
否则，如果谓词判断为假，就只返回过滤流的尾元素的结果
And otherwise, if that predicate was false, we just filter the tail of the stream.

263
00:19:13,500 --> 00:19:16,595
这就是过滤器的原理
Right, so there's filter.

264
00:19:16,595 --> 00:19:18,560
剩下的我快速过一遍
Let me run through a couple more rather quickly.

265
00:19:18,560 --> 00:19:20,880
这些在书上都有，下去可以自己看
They're all in the book and you can look at them.

266
00:19:20,880 --> 00:19:22,110
来马上过一遍
Let me just flash through.

267
00:19:22,110 --> 00:19:23,260
过程accumulate
Here's accumulate.

268
00:19:23,260 --> 00:19:31,560
accumulate以一种连接事物的方式，将初始值和流粘合在一起
Accumulate takes a way of combining things and an initial value in a stream and sticks them all together.

269
00:19:31,560 --> 00:19:33,970
如果流为空，返回初始值
If the stream's empty, it's just the initial value.

270
00:19:33,970 --> 00:19:40,900
否则，就连接流的头和accumulate流的尾的结果
Otherwise, we combine the head of the stream with the result of accumulating the tail of the stream starting from the initial value.

271
00:19:40,900 --> 00:19:42,830
这就是我把事物累积在一起的方法
So that's what I'd use to add up everything in the stream.

272
00:19:42,830 --> 00:19:45,830
用加法来累积
I'd accumulate with plus.

273
00:19:45,830 --> 00:19:48,060
如何枚举树上的叶子节点呢？
How would I enumerate the leaves of a tree?

274
00:19:48,060 --> 00:19:56,640
如果这个树只是一个叶子节点，我就构造一个只是一个叶子节点的树
Well, if the tree is just a leaf itself, I make something which only has that node in it.

275
00:19:56,640 --> 00:20:04,340
否则，就把左、右子树枚举的结果合并起来
Otherwise, I append together the stuff of enumerating the left branch and the right branch.

276
00:20:04,340 --> 00:20:08,130
就像之前对列表的操作一样
And then append here is like the ordinary append on lists.

277
00:20:13,190 --> 00:20:13,850
再来看这个
You can look at that.

278
00:20:13,850 --> 00:20:19,150
和合并两个列表的操作太相似了
That's analogous to the ordinary procedure for appending two lists.

279
00:20:19,150 --> 00:20:21,810
如何枚举整数呢？
How would I enumerate an interval?

280
00:20:21,810 --> 00:20:28,106
两个参数，一个小的一个大的，生成一个包含从小到大所有整数的流
This will take two integers, low and high, and generate a stream of the integers going from low to high.

281
00:20:28,106 --> 00:20:31,890
由此，我们就可以构造这一整串的元件
And we can make a whole bunch of pieces.

282
00:20:31,890 --> 00:20:37,670
这就是我们说的用来操作流的语言，当我们有了流，就可以用操纵它们来做点事情
So that's a little language of talking about streams. Once we have streams, we can build things for manipulating them.

283
00:20:37,670 --> 00:20:40,200
又一次地，我们构建了新的语言
Again, we're making a language.

284
00:20:40,200 --> 00:20:43,060
现在，就用这种语言来描述上面的东西
And now we can start expressing things in this language.

285
00:20:43,060 --> 00:20:47,310
这是累加奇数平方的过程
Here's our original procedure for summing the odd squares in a tree.

286
00:20:47,310 --> 00:20:54,590
你会发现，看起来完全和用信号处理画出的块状图相吻合
And you'll notice it looks exactly now like the block diagram, like the signal processing block diagram.

287
00:20:54,590 --> 00:21:01,320
要计算树上奇数平方和，先枚举树上的叶子节点
So to sum the odd squares in a tree, we enumerate the leaves of the tree.

288
00:21:01,320 --> 00:21:04,830
过滤出奇数
We filter that for oddness.

289
00:21:04,830 --> 00:21:06,220
用平方来映射
We map that for squareness.

290
00:21:09,320 --> 00:21:14,760
最后用加法来累积，初始值是0
And we accumulate the result of that using addition, starting from 0.

291
00:21:14,760 --> 00:21:17,290
这就是我们想要的
So we can see the pieces that we wanted.

292
00:21:17,290 --> 00:21:22,050
求奇数婓波那契数，和这个是相似地
Similarly, the Fibonacci one, how do we get the odd Fibs?

293
00:21:22,050 --> 00:21:30,920
从1到n枚举整数，用计算婓波那契数的过程作映射
Well, we enumerate the interval from 1 to n, we map along that, computing the Fibonacci of each one.

294
00:21:30,920 --> 00:21:34,810
过滤出奇数的部分
We filter the result of those for oddness.

295
00:21:34,810 --> 00:21:43,650
最后用CONS连接起来，初始值是空列表
And we accumulate all of that stuff using CONS starting from the empty-list.

296
00:21:43,650 --> 00:21:47,680
大功告成，这么做有什么优势呢？
OK, what's the advantage of this?

297
00:21:47,680 --> 00:21:51,880
先是，这些构造出的元件可以随意的混合搭配
Well, for one thing, we now have pieces that we can start mixing and matching.

298
00:21:51,880 --> 00:22:06,210
举个例子，如果我把这里改变一下，想要计算整数的平方再进行过滤，我只需要简单的拿一个像square的元件放在这里就行
So for instance, if I wanted to change this, if I wanted to compute the squares of the integers and then filter them, all I need to do is pick up a standard piece like this in that square and put it in.

299
00:22:06,210 --> 00:22:18,030
或者，我想计算整个树上的婓波那契数而不是树叶节点的序列，只需要替换这个枚举器
Or if we wanted to do this whole Fibonacci computation on the leaves of a tree rather than a sequence, all I need to do is replace this enumerator with that one.

300
00:22:18,030 --> 00:22:38,130
看，流处理的优势是，我们建立了 -- 这是课程中一个相对大一些的课题 -- 我们构造了合理的接口，还可以随意粘合起来
See, the advantage of this stream processing is that we're establishing-- this is one of the big themes of the course-- we're establishing conventional interfaces that allow us to glue things together.

301
00:22:38,130 --> 00:22:45,750
像这样如map和filter的标准组件，我们可以拿过来随意组合去构造程序
Things like map and filter are a standard set of components that we can start using for pasting together programs in all sorts of ways.

302
00:22:45,750 --> 00:22:50,090
还可以看到程序的共性
It allows us to see the commonality of programs.

303
00:22:50,090 --> 00:22:53,860
我应该说一下，现在仅仅展示了两个过程而已
I just ought to mention, I've only showed you two procedures.

304
00:22:53,860 --> 00:23:01,410
强调一下，像这种把map，filter，accumulate组合起来构建程序的方式是非常非常通用的
But let me emphasize that this way of putting things together with maps, filters, and accumulators is very, very general.

305
00:23:01,410 --> 00:23:30,710
这是生成和测试程序的范式。举例来看，Richarc Waters，MIT的毕业生，开展过一项研究，他分析了IBM的科学计算程序库，发现其中60%的部分都可以用这样的范式来准确的表示出来，而且只用map，filter，accumulate这三个东西
It's the generate and test paradigm for programs. And as an example of that, Richard Waters, who was at MIT when he was a graduate student, as part of his thesis research went and analyzed a large chunk of the IBM scientific subroutine library, and discovered that about 60% of the programs in it could be expressed exactly in terms using no more than what we've put here-- map, filter, and accumulate.

306
00:23:30,710 --> 00:23:31,960
好，让我们休息一会
All right, let's take a break.

307
00:23:36,620 --> 00:23:37,870
有问题吗？
Questions?

308
00:23:40,470 --> 00:23:48,380
整件事情的本质好像只是因为你用了一个统一、简单的数据结构 -- 流
AUDIENCE: It seems like the essence of this whole thing is just that you have a very uniform, simple data structure to work with, the stream.

309
00:23:48,380 --> 00:23:48,920
嗯啊
PROFESSOR: Right.

310
00:23:48,920 --> 00:23:53,710
本质应该是，那些约定接口的定义
The essence is that you, again, it's this sense of conventional interfaces.

311
00:23:53,710 --> 00:23:55,610
然后才可以把东西组合起来
So you can start putting a lot of things together.

312
00:23:55,610 --> 00:24:00,890
流只是，就像你说的，只是一种可以支持那样统一操作的数据结构而已
And the stream is as you say, the uniform data structure that supports that.

313
00:24:00,890 --> 00:24:03,600
从某种程度来看，这非常像APL
This is very much like APL, by the way.

314
00:24:03,600 --> 00:24:09,560
APL有着相似的思想，除了在APL中，你可以不用流，用数组和向量也是可以的
APL is very much the same idea, except in APL, instead of this stream, you have arrays and vectors.

315
00:24:09,560 --> 00:24:14,815
而且APL的威力就在于此
And a lot of the power of APL is exactly the same reason of the power of this.

316
00:24:19,910 --> 00:24:20,910
明白了，谢谢
OK, thank you.

317
00:24:20,910 --> 00:24:22,160
休息一下
Let's take a break.

318
00:24:57,470 --> 00:24:57,610
好的
All right.

319
00:24:57,610 --> 00:25:10,810
我们已经见识过了如何用流来组织计算过程。下面我再举一些更复杂的例子
We've been looking at ways of organizing computations using streams. What I want to do now is just show you two somewhat more complicated examples of that.

320
00:25:10,810 --> 00:25:16,810
我们来思考一下这样一种有用的过程
Let's start by thinking about the following kind of utility procedure that will come in useful.

321
00:25:16,810 --> 00:25:19,960
假如我有一个流
Suppose I've got a stream.

322
00:25:19,960 --> 00:25:23,730
流中的元素本身就是一个流
And the elements of this stream are themselves streams.

323
00:25:23,730 --> 00:25:26,530
一开始是1，2，3
So the first thing might be 1, 2, 3.

324
00:25:32,600 --> 00:25:33,880
就是这个流
So I've got a stream.

325
00:25:33,880 --> 00:25:40,100
流中的元素也是一个流
And each element of the stream is itself a stream.

326
00:25:40,100 --> 00:25:52,080
现在我想用一个流把其中的所有元素都聚集在一起，即把所有元素从子流中提取出来最后放在一起
And what I'd like to do is build a stream that collects together all of the elements, pulls all of the elements out of these sub-streams and strings them all together in one thing.

327
00:25:52,080 --> 00:25:56,960
只是想给你们展示一下这个语言其它的使用方式，很简单，把这个过程叫做flatten
So just to show you the use of this language, how easy it is, call that flatten.

328
00:25:56,960 --> 00:26:13,960
现在来定义这个过程，去flatten流中的子流，这是到底是什么？
And I can define to flatten this stream of streams. Well, what is that?

329
00:26:13,960 --> 00:26:16,240
也就是一个累积的过程
That's just an accumulation.

330
00:26:16,240 --> 00:26:26,450
我想用append来做累积，连接地累积
I want to accumulate using append, by successively appending.

331
00:26:26,450 --> 00:26:54,370
APPEND-STREAM作为组合过程，THE-EMPTY-STREAM为初始值，累积这个流
So I accumulate using append streams, starting with the-empty-stream down that stream of streams.

332
00:26:54,370 --> 00:27:00,830
这就是一个明显的例子，你可以用高阶的东西去做更有趣的事情
OK, so there's an example of how you can start using these higher order things to do some interesting operations.

333
00:27:00,830 --> 00:27:05,100
事实上，还有另外有用的东西
In fact, there's another useful thing that I want to do.

334
00:27:05,100 --> 00:27:21,840
定义一个过程flat-map，以一个过程和一个流作为参数
I want to define a procedure called flat-map, flat map of some function and a stream.

335
00:27:21,840 --> 00:27:25,720
And what this is going to do is f will be a stream of elements.
And what this is going to do is f will be a stream of elements.

336
00:27:25,720 --> 00:27:31,950
f是一个过程，它操作一个流，生成另一个流
f is going to be a function that for each element in the stream produces another stream.

337
00:27:31,950 --> 00:27:36,000
我要做的是把所有的元素和所有的流合并起来
And what I want to do is take all of the elements and all of those streams and combine them together.

338
00:27:36,000 --> 00:27:51,350
所以就是 (FLATTEN (MAP F S))
So that's just going to be the flatten of map f down s.

339
00:27:51,350 --> 00:27:54,290
每次我调用F，就得到另一个流
Each time I apply f to an element of s, I get a stream.

340
00:27:54,290 --> 00:27:58,385
如果用F来映射S中的子流，我就得到另一个“流的流”，然后再进行flatten
If I map it all the way down, I get a stream of streams, and I'll flatten that.

341
00:27:58,385 --> 00:28:06,360
好的，我想再使用这种方式来解决另一个大家很熟悉的问题
Well, I want to use that to show you a new way to do a familiar kind of problem.

342
00:28:06,360 --> 00:28:14,190
这个问题和你以前看到过的许多问题一样，尽管不是很特别
The problem's going to be like a lot of problems you've seen, although maybe not this particular one.

343
00:28:14,190 --> 00:28:15,490
一个整数n
I'm going to give you an integer, n.

344
00:28:18,480 --> 00:28:51,910
找出所有的序对 ( i j )，0 < j < i <= n，并且 i + j 是一个质数
And the problem is going to be find all pairs and integers i and j, between 0 and i, with j less than i, up to n, such that i plus j is prime.

345
00:28:55,740 --> 00:29:06,640
如果 n = 6，画一个小表格，这里 i，j，i + j
So for example, if n equals 6, let's make a little table here, i and j and i plus j.

346
00:29:09,700 --> 00:29:15,520
I = 2，J = 1，I + J就是3
So for, say, i equals 2 and j equals 1, I'd get 3.

347
00:29:15,520 --> 00:29:21,210
然后 I = 3，J = 2，I + J就是5
And for i equals 3, I could have j equals 2, and that would be 5.

348
00:29:21,210 --> 00:29:28,400
4，1，5也是一样的，等等，直到 I 到了6
And 4 and 1 would be 5 and so on, up until i goes to 6.

349
00:29:28,400 --> 00:29:37,350
我想要这个过程返回的是由这样的 I J I+J 三元组组成的流
And what I'd like to return is to produce a stream of all the triples like this, let's say i, j, and i plus j.

350
00:29:37,350 --> 00:29:41,530
对于整数n，我想得到一个这样流
So for each n, I want to generate this stream.

351
00:29:41,530 --> 00:29:43,680
好的，听起来很简单
OK, well, that's easy.

352
00:29:43,680 --> 00:29:47,230
开始做做看
Let's build it up.

353
00:29:47,230 --> 00:29:50,150
先这样开始
We start like this.

354
00:29:50,150 --> 00:29:56,440
对于每一个整数 I，生成一个流
We're going to say for each i, we're going to generate a stream.

355
00:29:56,440 --> 00:30:00,660
i 从 1 取到 n，每个 i 都生成一个流
For each i in the interval 1 through n, we're going to generate a stream.

356
00:30:00,660 --> 00:30:02,230
这个流将会是什么样子？
What's that stream going to be?

357
00:30:02,230 --> 00:30:04,180
先从生成所有的开始
We're going to start by generating all the pairs.

358
00:30:04,180 --> 00:30:20,710
对于每个 i 来说，生成的结果是这样的：对于整数 j，1 <= j <= i - 1，生成 (i j) 的序对
So for each i, we're going to generate, for each j in the interval 1 to i minus 1, we'll generate the pair, or the list with two elements i and j.

359
00:30:23,780 --> 00:30:30,712
对于 j 的每个取值，都生成一个序对
So we map along the interval, generating the pairs.

360
00:30:30,712 --> 00:30:33,170
对于每个 i，都生成一个序对的流
And for each i, that generates a stream of pairs.

361
00:30:33,170 --> 00:30:34,590
最后进行flatmap
And we flatmap it.

362
00:30:34,590 --> 00:30:38,730
现在，我们就得到了所有满足要求的序对了
Now we have all the pairs i and j, such that i is less than j.

363
00:30:38,730 --> 00:30:39,850
就是这样
So that builds that.

364
00:30:39,850 --> 00:30:42,990
来测试一下
Now we're got to test them.

365
00:30:42,990 --> 00:30:51,660
刚才flatmap得到的结果，进行过滤
Well, we take that thing we just built, the flatmap, and we filter it to see whether the i-- see, we had an i and a j.

366
00:30:51,660 --> 00:31:02,070
i 是列表第一个元素，j 是第二个，这里的谓词用来检测 i + j 的值是否是质数
i was the first thing in the list, j was the second thing in the list. So we have a predicate which says in that list of two elements is the sum of the CAR and the CDR prime.

367
00:31:02,070 --> 00:31:06,540
用这个lambda对所有的序对进行过滤
And we filter that collection of pairs we just built.

368
00:31:06,540 --> 00:31:09,420
剩下的就是我们想要的
So those are the pairs we want.

369
00:31:09,420 --> 00:31:19,610
然后我们继续，把过滤得到的结果再次进行map操作，得到 i j i+j 的三元组
Now we go ahead and we take the result of that filter and we map along it, generating the list i and j and i plus j.

370
00:31:19,610 --> 00:31:22,910
这就是过程 prime-sum-pairs
And that's our procedure prime-sum-pairs.

371
00:31:22,910 --> 00:31:24,480
最后只需要过一遍，这就是整个过程
And then just to flash it up, here's the whole procedure.

372
00:31:27,945 --> 00:31:30,750
一个map，一个filter，一个flatmap
A map, a filter, a flatmap.

373
00:31:34,850 --> 00:31:37,120
所有的东西都在这里了，尽管看起来可读性不是那么好
There's the whole thing, even though this isn't particularly readable.

374
00:31:37,120 --> 00:31:40,000
这只是flatmap的一个延伸
It's just expanding that flatmap.

375
00:31:40,000 --> 00:31:54,200
这个例子很好的体现了嵌套循环的要点。看起来就像map的flatmap的flatmap的flatmap
So there's an example which illustrates the general point that nested loops in this procedure start looking like compositions of flatmaps of flatmaps of flatmaps of maps and things.

376
00:31:54,200 --> 00:32:03,230
所以我们不仅仅枚举单个个体，还要通过使用flatmap，达到像其它语言中嵌套循环的效果
So not only can we enumerate individual things, but by using flatmaps, we can do what would correspond to nested loops in most other languages.

377
00:32:03,230 --> 00:32:08,410
当然，一直写这些flatmap很烦人
Of course, it's pretty awful to keep writing these flatmaps of flatmaps of flatmaps.

378
00:32:08,410 --> 00:32:15,480
尽管prime-sum-pairs其中单独的部分很容易，但整体看起来还是十分复杂
Prime-sum-pairs you saw looked fairly complicated, even though the individual pieces were easy.

379
00:32:15,480 --> 00:32:21,040
如果你喜欢，可以引进一个叫collect的语法糖
So what you can do, if you like, is introduced some syntactic sugar that's called collect.

380
00:32:21,040 --> 00:32:26,160
collect只是一个对嵌套flatmap的缩写
And collect is just an abbreviation for that nest of flatmaps and filters arranged in that particular way.

381
00:32:26,160 --> 00:32:29,620
这里我们用collect把prime-sum-pairs写一遍
Here's prime-sum-pairs again, written using collect.

382
00:32:29,620 --> 00:32:58,040
它的意思是这样，我想collect这样的结果，元素以 i j i+j 三元组的形式，i 从1到n，j 从1到i-1，还要满足 i+j 是质数
It says to find all those pairs, I'm going to collect together a result, which is the list i, j, and i plus j, that's going to be generated as i runs through the interval from 1 to n and as j runs through the interval from 1 to i minus 1, such that i plus j is prime.

383
00:32:58,040 --> 00:33:00,690
我可以认为这个collect过程是通用的
So I'm not going to say what collect does in general.

384
00:33:00,690 --> 00:33:03,420
你可以在书上找到它的详细定义
You can look at that by looking at it in the book.

385
00:33:03,420 --> 00:33:08,820
当然，你可以把这个元件看作和以前的元件一样
But pretty much, you can see that the pieces of this are the pieces of that original procedure I wrote.

386
00:33:08,820 --> 00:33:16,310
collect这个过程不过是一个可以自动生成嵌套flatmap的语法糖罢了
And this collect is just some syntactic sugar for automatically generating that nest of flatmaps and flatmaps.

387
00:33:16,310 --> 00:33:22,120
好的，我们再来看另一个例子
OK, well, let me do one more example that shows you the same kind of thing.

388
00:33:22,120 --> 00:33:30,200
这是一个十分出名的例子，经常用来演示回溯算法，就是“八皇后问题”
Here's a very famous problem that's used to illustrate a lot of so-called backtracking computer algorithms. This is the eight queens problem.

389
00:33:30,200 --> 00:33:32,370
这是一个棋盘
This is a chess board.

390
00:33:32,370 --> 00:33:38,000
八皇后问题是说，找到一种放置皇后的方式，使得任意的两个皇后不会相互攻击
And the eight queens problem says, find a way to put down eight queens on a chess board so that no two are attacking each other.

391
00:33:38,000 --> 00:33:41,430
这是一个解
And here's a particular solution to the eight queens problem.

392
00:33:41,430 --> 00:33:51,410
使得任意两个皇后不在同一行，同一列而且不在同一对角线上
So I have to make sure to put down queens so that no two are in the same row or the same column or sit along the same diagonal.

393
00:33:51,410 --> 00:33:56,400
有一个解决这个问题的标准解法
Now, there's sort of a standard way of doing that.

394
00:33:59,740 --> 00:34:04,940
首先我们要做是，站在George的层面
Well, first we need to do is below the surface, at George's level.

395
00:34:04,940 --> 00:34:08,095
找到一种表示棋盘与位置的方式
We have to find some way to represent a board, and represent positions.

396
00:34:08,095 --> 00:34:09,800
这个并不需要太担心
And we'll not worry about that.

397
00:34:09,800 --> 00:34:12,540
假设我们有一个谓词safe
But let's assume that there's a predicate called safe.

398
00:34:16,040 --> 00:34:25,400
safe要做的是，假如一些皇后已经放在棋盘上，判断在另一个点再放置一个皇后是否是安全的？
And what safe is going to do is going to say given that I have a bunch of queens down on the chess board, is it OK to put a queen in this particular spot?

399
00:34:25,400 --> 00:34:32,889
safe的参数，一个row，一个column
So safe is going to take a row and a column.

400
00:34:32,889 --> 00:34:42,370
那将是我尝试放下一个皇后的地方和剩下的位置
That's going to be a place where I'm going to try and put down the next queen, and the rest of positions.

401
00:34:45,420 --> 00:34:58,300
safe要判断的是在剩下的皇后已经放置的情况下，再放置一个皇后是否是安全的
And what safe will say is given that I already have queens down in these positions, is it safe to put another queen down in that row and that column?

402
00:34:58,300 --> 00:34:59,360
不用过分深究这个
And let's not worry about that.

403
00:34:59,360 --> 00:35:01,380
那是George的问题，也不难写出来
That's George's problem. and it's not hard to write.

404
00:35:01,380 --> 00:35:10,530
只需要检测行，列，对角线而已
You just have to check whether this thing contains any things on that row or that column or in that diagonal.

405
00:35:10,530 --> 00:35:13,590
嗯，那这个程序要怎么组织呢？
Now, how would you organize the program given that?

406
00:35:13,590 --> 00:35:20,116
有一种经典的方式，我们称为“回溯”
And there's sort of a traditional way to organize it called backtracking.

407
00:35:20,116 --> 00:35:31,290
它说的是这个，考虑把第一个皇后放在第一列的方式
And it says, well, let's think about all the ways of putting the first queen down in the first column.

408
00:35:31,290 --> 00:35:32,580
有8种
There are eight ways.

409
00:35:32,580 --> 00:35:35,880
试一下第一个
Well, let's say try the first column.

410
00:35:35,880 --> 00:35:37,300
第一行第一列
Try column 1, row 1.

411
00:35:37,300 --> 00:35:43,360
分支表示了每一层所有的可能性
These branches are going to represent the possibilities at each level.

412
00:35:43,360 --> 00:35:45,875
我试着把皇后放在第一列
So I'll try and put a queen down in the first column.

413
00:35:45,875 --> 00:35:49,980
好的，已经放下了，现在就在这个基础上放置第二列的皇后
And now given that it's in the first column, I'll try and put the next queen down in the first column.

414
00:35:53,035 --> 00:35:56,920
我试试把第一个皇后，在第一列上的那个皇后，放在第一行
I'll try and put the first queen, the one in the first column, down in the first row.

415
00:35:56,920 --> 00:35:59,050
不好意思
I'm sorry.

416
00:35:59,050 --> 00:36:01,390
然后，把第二个皇后也放在第一行
And then given that, we'll put the next queen down in the first row.

417
00:36:01,390 --> 00:36:02,090
这不行
And that's no good.

418
00:36:02,090 --> 00:36:04,200
所以又回到这里
So I'll back up to here.

419
00:36:04,200 --> 00:36:07,510
然后，我们把这个皇后放在第二行吗？
And I'll say, oh, can I put the first queen down in the second row?

420
00:36:07,510 --> 00:36:08,550
对角线冲突了，也不好
Well, that's no good.

421
00:36:08,550 --> 00:36:09,760
第三行怎么样？
Oh, can I put it down in the third row?

422
00:36:09,760 --> 00:36:12,790
这样可以
Well, that's good.

423
00:36:12,790 --> 00:36:15,380
下一个皇后可以放在第一行吗？
Well, now can I put the next queen down in the first column?

424
00:36:15,380 --> 00:36:19,195
我不再想像更多的棋盘，假设这是对的
Well, I can't visualize this chess board anymore, but I think that's right.

425
00:36:19,195 --> 00:36:20,450
我就尝试下一个
And I try the next one.

426
00:36:20,450 --> 00:36:24,170
在每一个地方，尽可能的沿着树往下
And at each place, I go as far down this tree as I can.

427
00:36:24,170 --> 00:36:25,640
然后倒退
And I back up.

428
00:36:25,640 --> 00:36:33,260
如果到了这里，不能再往下了，就回到这里，生成这个子树
If I get down to here and find no possibilities below there, I back all the way up to here, and now start again generating this sub-tree.

429
00:36:33,260 --> 00:36:35,050
绕来绕去
And I sort of walk around.

430
00:36:35,050 --> 00:36:40,090
最后，一路求解下来，就会得到答案
And finally, if I ever manage to get all the way down, I've found a solution.

431
00:36:40,090 --> 00:36:45,930
这是以前人工智能编程的经典范式
So that's a typical sort of paradigm that's used a lot in AI programming.

432
00:36:45,930 --> 00:36:47,300
回溯查找
It's called backtracking search.

433
00:36:57,470 --> 00:37:03,860
这真的没有必要
And it's really unnecessary.

434
00:37:03,860 --> 00:37:06,550
当我想像这个东西时感到很疑惑
You saw me get confused when I was visualizing this thing.

435
00:37:06,550 --> 00:37:08,550
你也看到了，这很复杂
And you see the complication.

436
00:37:08,550 --> 00:37:10,760
而且这种复杂还很难描述
This is a complicated thing to say.

437
00:37:10,760 --> 00:37:12,390
为什么会这样？
Why is it complicated?

438
00:37:12,390 --> 00:37:18,580
程序太费时间了
Its because somehow this program is too inordinately concerned with time.

439
00:37:18,580 --> 00:37:22,320
耗时太长了，试试那个，试试这个，又回来，直到没有其它可能性
It's too much-- I try this one, and I try this one, and I go back to the last possibility.

440
00:37:22,320 --> 00:37:24,340
很复杂
And that's a complicated thing.

441
00:37:24,340 --> 00:37:31,200
如果我不担心时间，就有一个更简单的方式来描述
If I stop worrying about time so much, then there's a much simpler way to describe this.

442
00:37:31,200 --> 00:37:43,400
假设我有一个k-1层的树
It says, let's imagine that I have in my hands the tree down to k minus 1 levels.

443
00:37:43,400 --> 00:37:53,560
现在，我需要去找到在第k列放置皇后的所有方式
See, suppose I had in my hands all possible ways to put down queens in the first k columns.

444
00:37:53,560 --> 00:37:54,610
假设是这样
Suppose I just had that.

445
00:37:54,610 --> 00:37:57,070
不要担心我是怎么得到的
Let's not worry about how we get it.

446
00:37:57,070 --> 00:37:59,200
现在，如果扩充下去呢？
Well, then, how do I extend that?

447
00:37:59,200 --> 00:38:02,480
怎样找到所有在下一列中放皇后的可能性呢？
How do I find all possible ways to put down queens in the next column?

448
00:38:02,480 --> 00:38:03,620
很简单
It's really easy.

449
00:38:03,620 --> 00:38:16,160
对于已有的位置，把下个皇后放在每一行上
For each of these positions I have, I think about putting down a queen in each row to make the next thing.

450
00:38:16,160 --> 00:38:22,080
然后，把所有放置的位置，用safe进行过滤
And then for each one I put down, I filter those by the ones that are safe.

451
00:38:22,080 --> 00:38:26,860
不像之前那样，把树的生成一步一步想的那么清楚，假设树已经生成了
So instead of thinking about this tree as generated step by step, suppose I had it all there.

452
00:38:29,680 --> 00:38:37,800
为了从k-1层扩展到k层，需要尝试所有可能性最后保留安全的排列
And to extend it from level k minus 1 to level k, I just need to extend each thing in all possible ways and only keep the ones that are safe.

453
00:38:37,800 --> 00:38:39,300
就得到一个k层树的结果
And that will give me the tree to level k.

454
00:38:39,300 --> 00:38:44,530
这是一个解决八皇后的递归策略
And that's a recursive strategy for solving the eight queens problem.

455
00:38:44,530 --> 00:38:45,780
好的，我们来看看
All right, well, let's look at it.

456
00:38:50,280 --> 00:39:01,030
在特定大小的棋盘解决八皇后问题，我们写一个子过程 fill-columns
To solve the eight queens problem on a board of some specified size, we write a sub-procedure called fill-columns.

457
00:39:01,030 --> 00:39:06,086
这个过程把皇后一直放置到列k
Fill-columns is going to put down queens up through column k.

458
00:39:06,086 --> 00:39:07,700
这是一个递归的模式
And here's the pattern of the recursion.

459
00:39:07,700 --> 00:39:12,990
最后用棋盘具体的大小作为参数来调用fill-columns
I'm going to call fill-columns with the size eventually.

460
00:39:12,990 --> 00:39:20,360
fill-columns是用来说明如何在 k 列 size 行的棋盘上放置皇后
So fill-columns says how to put down queens safely in the first k columns of this chess board with a size number of rows in it.

461
00:39:20,360 --> 00:39:23,940
如果k是0，就不用做什么
If k is equal to 0, well, then I don't have to put anything down.

462
00:39:23,940 --> 00:39:26,710
结果是一个空的棋盘
So my solution is just an empty chess board.

463
00:39:26,710 --> 00:39:28,070
否则就做点别的
Otherwise, I'm going to do some stuff.

464
00:39:28,070 --> 00:39:30,522
这里将要使用collect
And I'm going to use collect.

465
00:39:30,522 --> 00:39:31,772
这是collect
And here's the collect.

466
00:39:34,530 --> 00:39:41,910
我找到了所有在前k-1列中放皇后的方法
I find all ways to put down queens in the first k minus 1 columns.

467
00:39:41,910 --> 00:39:43,320
这是我设置的
And this was just what I set for.

468
00:39:43,320 --> 00:39:48,880
想像这棵树下降直到k-1层
Imagine I have this tree down to k minus 1 levels.

469
00:39:48,880 --> 00:39:54,130
然后我尝试每一行
And then I find all ways of trying a row, that's just each of the possible rows.

470
00:39:54,130 --> 00:39:58,040
总行数就是size，枚举了所有行数
They're size rows, so that's enumerate interval.

471
00:39:58,040 --> 00:40:08,950
现在要做的是，将第k列上所有的可能性与已经放置的皇后整合
And now what I do is I collect together the new row I'm going to try and column k with the rest of the queens.

472
00:40:08,950 --> 00:40:10,200
整合在一起
I adjoin a position.

473
00:40:10,200 --> 00:40:11,290
这是George的问题了
This is George's problem.

474
00:40:11,290 --> 00:40:13,640
像safe一样
An adjoined position is like safe.

475
00:40:13,640 --> 00:40:19,660
我们要做的就是，拿一行，一列和剩下的位置，然后做一个新的位置集合
It's a thing that takes a row and a column and the rest of the positions and makes a new position collection.

476
00:40:19,660 --> 00:40:34,620
我把第k列可放置的行的位置和剩下的皇后结合起来，而剩下的皇后都已经摆放好了
So I adjoin a position of a new row and a new column to the rest of the queens, where the rest of the queens runs through all possible ways of solving the problem in k minus 1 columns.

477
00:40:34,620 --> 00:40:43,240
新的行遍历了所有的可能性，过滤出安全的位置
And the new row runs through all possible rows such that it was safe to put one there.

478
00:40:43,240 --> 00:40:46,500
这就是整个程序了
And that's the whole program.

479
00:40:46,500 --> 00:40:49,840
整个过程
There's the whole procedure.

480
00:40:49,840 --> 00:40:56,680
不只这样，不仅解决了八皇后问题，还顺便给出了所有的解
Not only that, that doesn't just solve the eight queens problem, it gives you all solutions to the eight queens problem.

481
00:40:56,680 --> 00:40:58,480
运行结束之后，就得到一个流
When you're done, you have a stream.

482
00:40:58,480 --> 00:41:01,900
流中的元素是所有的解
And the elements of that stream are all possible ways of solving that problem.

483
00:41:05,310 --> 00:41:06,260
为什么这个更简单一点呢？
Why is that simpler?

484
00:41:06,260 --> 00:41:12,720
我们已经描述了整个想法，它是一些在时间中发生，有状态的过程
Well, we threw away the whole idea that this is some process that happens in time with state.

485
00:41:12,720 --> 00:41:14,420
我们只说，这是这个东西的整个集合
And we just said it's a whole collection of stuff.

486
00:41:14,420 --> 00:41:18,260
这就是更加简单的原因
And that's why it's simpler.

487
00:41:18,260 --> 00:41:20,110
我们已经转变了观念
We've changed our view.

488
00:41:20,110 --> 00:41:22,820
记住，这就是我们的开始
Remember, that's where we started today.

489
00:41:22,820 --> 00:41:26,230
我们转变了建模的观念
We've changed our view of what it is we're trying to model.

490
00:41:26,230 --> 00:41:31,750
我们停止对那些随着时间变化的，有过程与状态的东西进行建模
we stop modeling things that evolve in time and have steps and have state.

491
00:41:31,750 --> 00:41:40,750
代为替代，我们对全局进行建模，就像粉笔飞行那样而不时关注其每一时刻的状态
And instead, we're trying to model this global thing like the whole flight of the chalk, rather than its state at each instant.

492
00:41:40,750 --> 00:41:42,000
有什么问题吗？
Any questions?

493
00:41:43,810 --> 00:41:54,030
在我看来回溯会搜索到第一个解，而这个递归搜索却找到了所有的解
AUDIENCE: It looks to me like backtracking would be searching for the first solution it can find, whereas this recursive search would be looking for all solutions.

494
00:41:54,030 --> 00:42:01,360
如果搜索的空间足够的大，这样来搜索好像不太可能吧
And it seems that if you have a large enough area to search, that the second is going to become impossible.

495
00:42:01,360 --> 00:42:08,570
嗯，这个问题的答案是剩下的课要讲的内容
PROFESSOR: OK, the answer to that question is the whole rest of this lecture.

496
00:42:08,570 --> 00:42:10,540
很好的问题
It's exactly the right question.

497
00:42:13,522 --> 00:42:22,220
先不要尝试去预见后面的课，你应该对这个要点产生怀疑，这的确十分让人起疑
And without trying to anticipate the lecture too much, you should start being suspicious at this point, and exactly those kinds of suspicions.

498
00:42:22,220 --> 00:42:24,830
尽管这个看起来不错，难道不低效吗？
It's wonderful, but isn't it so terribly inefficient?

499
00:42:24,830 --> 00:42:28,100
这就是用尝试另一种方式的原因
That's where we're going.

500
00:42:28,100 --> 00:42:30,020
因此这个问题之后我再回答
So I won't answer now, but I'll answer later.

501
00:42:33,350 --> 00:42:34,600
好的，休息时间
OK, let's take a break.

502
00:43:29,650 --> 00:43:35,600
现在你应该也开始怀疑了
Well, by now you should be starting to get suspicious.

503
00:43:35,600 --> 00:43:53,740
我已经展示了这种简单优雅的组合程序的方法，不像那些传统的累积奇数或者计算奇数的斐波那契数
See, I've showed your this simple, elegant way of putting programs together, very unlike these other traditional programs that sum the odd squares or compute the odd Fibonacci numbers.

504
00:43:53,740 --> 00:44:00,440
也不像这些混合enumerator filter和accumulator的方法
Very unlike these programs that mix up the enumerator and the filter and the accumulator.

505
00:44:00,440 --> 00:44:13,800
使用这种混合的方式来构建程序，我们并没有完全发挥流的这种概念性的优势
And by mixing it up, we don't have all of these wonderful conceptual advantages of these streams pieces, these wonderful mix and match components for putting together lots and lots of programs.

506
00:44:13,800 --> 00:44:18,340
另一方面，不这样来组合的其它的程序都很丑陋
On the other hand, most of the programs you've seen look like these ugly ones.

507
00:44:18,340 --> 00:44:19,460
为什么会这样？
Why's that?

508
00:44:19,460 --> 00:44:33,620
可能是计算机科学家没有注意到 你只做了这件事就在编程上获得了难得的优雅性？
Can it possibly be that computer scientists are so obtuse that they don't notice that if you'd merely did this thing, then you can get this great programming elegance?

509
00:44:33,620 --> 00:44:36,760
肯定有什么窍门
There's got to be a catch.

510
00:44:36,760 --> 00:44:39,510
事实上这一窍门也很容易发现
And it's actually pretty easy to see what the catch is.

511
00:44:39,510 --> 00:44:42,030
我们来看看接下来的这个问题
Let's think about the following problem.

512
00:44:42,030 --> 00:44:54,105
假设我让你找到1,000到1,000,000这间的第二个素数，或者10,000到100,000,000的第二个素数或者什么之类的
Suppose I tell you to find the second prime between 10,000 and 1 million, or if your computer's larger, say between 10,000 and 100 billion, or something.

513
00:44:54,105 --> 00:44:55,550
可能你想，这很容易
And you say, oh, that's easy.

514
00:44:55,550 --> 00:44:57,080
我可以用流来解决
I can do that with a stream.

515
00:44:57,080 --> 00:45:04,160
我需要做的就是从10,000枚举到1,000,000
All I do is I enumerate the interval from 10,000 to 1 million.

516
00:45:04,160 --> 00:45:06,800
从中挑出每一个数字
So I get all those integers from 10,000 to 1 million.

517
00:45:06,800 --> 00:45:11,762
用检测素数性的谓词来过滤全部的数
I filter them for prime-ness, so test all of them and see if they're prime.

518
00:45:11,762 --> 00:45:13,170
取出其中的第二个，就是我们想要的
And I take the second element.

519
00:45:13,170 --> 00:45:16,130
正是TAIL的HEAD
That's the head of the tail.

520
00:45:16,130 --> 00:45:17,380
这看起来非常的荒谬
Well, that's clearly pretty ridiculous.

521
00:45:21,660 --> 00:45:27,040
我们的机器都没有这么大的空间来存放这些整数，更别说来检测它们了
We'd not even have room in the machine to store the integers in the first place, much less to test them.

522
00:45:27,040 --> 00:45:29,810
然后我只取其中的第二个
And then I only want the second one.

523
00:45:29,810 --> 00:45:45,090
看吧，这种组合enumerate，accumulate的编程方式很有威力，但也有弱点
See, the power of this traditional programming style is exactly its weakness, that we're mixing up the enumerating and the testing and the accumulating.

524
00:45:45,090 --> 00:45:46,670
所以关键在于，我们不需要做所有的事
So we don't do it all.

525
00:45:46,670 --> 00:45:55,210
这个在概念上更加丑陋的东西使它更高效了
So the very thing that makes it conceptually ugly is the very thing that makes it efficient.

526
00:45:55,210 --> 00:45:57,800
是这样来混合的
It's this mixing up.

527
00:45:57,800 --> 00:46:00,420
我今天一早上所做的好像都是在迷惑你们一样
So it seems that all I've done this morning so far is just confuse you.

528
00:46:00,420 --> 00:46:05,840
我给你们展示了这种优雅的编程方式，除了这个不行
I showed you this wonderful way that programming might work, except that it doesn't.

529
00:46:05,840 --> 00:46:09,040
不卖关子了，接下来，见证奇迹的时刻
Well, here's where the wonderful thing happens.

530
00:46:09,040 --> 00:46:14,870
这个游戏里，我们有蛋糕，并且还可以吃它
It turns out in this game that we really can have our cake and eat it too.

531
00:46:14,870 --> 00:46:36,310
我的意思是，我们完全可以用流来这样的组织程序，当机器真正运行的时候，和那种生成与检测混合在一起的程序一样高效
And what I mean by that is that we really can write stream programs exactly like the ones I wrote and arrange things so that when the machine actually runs, it's as efficient as running this traditional programming style that mixes up the generation and the test.

532
00:46:36,310 --> 00:46:40,770
听起来不可思议
Well, that sounds pretty magic.

533
00:46:40,770 --> 00:46:43,690
关键在于，流不是列表
The key to this is that streams are not lists.

534
00:46:48,090 --> 00:46:52,115
一会儿我们就会看到，现在，先来看看幻灯片
We'll see this carefully in a second, but for now, let's take a look at that slide again.

535
00:46:52,115 --> 00:47:05,360
类比于信号处理系统，这个例子里是一些整数
The image you should have here of this signal processing system is that what's going to happen is there's this box that has the integers sitting in it.

536
00:47:05,360 --> 00:47:10,940
这里的filter和它连接在一起并且揪住了它们
And there's this filter that's connected to it and it's tugging on them.

537
00:47:10,940 --> 00:47:16,790
这里可以放置另外的东西来揪住filter的输出
And then there's someone who's tugging on this stuff saying what comes out of the filter.

538
00:47:16,790 --> 00:47:24,590
想像这样的图景，有人想要得到第一个质数，从filter中揪出来
And the image you should have is that someone says, well, what's the first prime, and tugs on this filter.

539
00:47:24,590 --> 00:47:28,020
filter相继地去揪出一个整数来计算
And the filter tugs on the integers.

540
00:47:28,020 --> 00:47:30,930
看完这些之后，然后想，哦，想要第二个质数
And you look only at that much, and then say, oh, I really wanted the second one.

541
00:47:30,930 --> 00:47:33,710
第二个是什么？
What's the second prime?

542
00:47:33,710 --> 00:47:40,500
当你不去尝试揪出东西时，就不会有计算发生
And that no computation gets done except when you tug on these things.

543
00:47:40,500 --> 00:47:41,410
我们再来试试
Let me try that again.

544
00:47:41,410 --> 00:47:43,815
这是一个小设备
This is a little device.

545
00:47:43,815 --> 00:47:49,830
Eric Grimson发明的，他曾经也在MIT教这门课
This is a little stream machine invented by Eric Grimson who's been teaching this course at MIT.

546
00:47:49,830 --> 00:47:54,780
把这个比作流，就像一串整数一样
And the image is here's a stream of stuff, like a whole bunch of the integers.

547
00:47:54,780 --> 00:47:58,700
这些是一些处理工序
And here's some processing elements.

548
00:47:58,700 --> 00:48:02,600
就像是map，filter之类的东西
And if, say, it's filter of filter of map, or something.

549
00:48:05,570 --> 00:48:12,670
如果我把流当作列表来演示这个过程，来看看，先进行第一个filter
And if I really tried to implement that with streams as lists, what I'd say is, well, I've got this list of things, and now I do the first filter.

550
00:48:12,670 --> 00:48:14,070
这些全都要处理
So do all this processing.

551
00:48:14,070 --> 00:48:19,610
针对这个流，不断的处理，处理
And I take this and I process and I process and I process and I process.

552
00:48:19,610 --> 00:48:21,910
然后得到一个新的流
And now I'm got this new stream.

553
00:48:21,910 --> 00:48:24,070
结果现在在我的手上
Now I take that result in my hand someplace.

554
00:48:24,070 --> 00:48:25,260
然后和第二个接通
And I put that through the second one.

555
00:48:25,260 --> 00:48:28,110
又处理了全部的流
And I process the whole thing.

556
00:48:28,110 --> 00:48:29,510
得到一个新流
And there's this new stream.

557
00:48:32,130 --> 00:48:36,360
然后类似地，取这个结果，用相同的方式再次处理
And then I take the result and I put it all the way through this one the same way.

558
00:48:36,360 --> 00:48:43,860
如果把流仅仅当做列表的话，计算的过程就是这样的
That's what would happen to these stream programs if streams were just lists.

559
00:48:43,860 --> 00:48:50,230
但是事实上，流不是列表，流就是流。你应该这样来想像
But in fact, streams aren't lists, they're streams. And the image you should have is something a little bit more like this.

560
00:48:50,230 --> 00:48:57,130
我把这些小玩意连接起来，数据在其中流动
I've got these gadgets connected up by this data that's flowing out of them.

561
00:48:59,960 --> 00:49:05,980
这里是流的来源，开始生成整数
And here's my original source of the streams. It might be starting to generate the integers.

562
00:49:05,980 --> 00:49:07,580
如果我想要一个整数，会发生什么？
And now, what happens if I want a result?

563
00:49:07,580 --> 00:49:10,200
我揪住最后的这里
I tug on the end here.

564
00:49:10,200 --> 00:49:13,090
这个元素可能会说，哥们，我需要更多的数据
And this element says, gee, I need some more data.

565
00:49:13,090 --> 00:49:15,830
所以，这个到这里，又开始揪住那个
So this one comes here and tugs on that one.

566
00:49:15,830 --> 00:49:17,890
同样说，哥们，给我来点数据
And it says, gee, I need some more data.

567
00:49:17,890 --> 00:49:21,640
然后这个又揪住了下一个东西，可能是一个fiiler，哥们，来点数据啊
And this one tugs on this thing, which might be a filter, and says, gee, I need some more data.

568
00:49:21,640 --> 00:49:25,780
最后的这一点东西，只有在去揪它的时候才会生成
And only as much of this thing at the end here gets generated as I tugged.

569
00:49:25,780 --> 00:49:30,760
只有我去揪住末尾这里的时候，才会有数据通过这些元件得到处理
And only as much of this stuff goes through the processing units as I'm pulling on the end I need.

570
00:49:30,760 --> 00:49:37,830
把流当作流和把流当作列表，就是这样的区别
That's the image you should have of the difference between implementing what we're actually going to do and if streams were lists.

571
00:49:40,600 --> 00:49:42,430
说了这么多，到底怎么来实现呢？
Well, how do we make this thing?

572
00:49:42,430 --> 00:49:43,400
我希望你们这样来想
I hope you have the image.

573
00:49:43,400 --> 00:49:44,947
窍门在于如何构造流
The trick is how to make it.

574
00:49:47,930 --> 00:49:56,920
我们想要把流组织成一种有需要时才会逐渐计算得到自身元素的数据结构
We want to arrange for a stream to be a data structure that computes itself incrementally, an on-demand data structure.

575
00:49:59,220 --> 00:50:04,490
基本思想在于，再次强调，这种思想贯穿整个课程
And the basic idea is, again, one of the very basic ideas that we're seeing throughout the whole course.

576
00:50:04,490 --> 00:50:09,240
那就是，数据与过程之间并没有绝对的界限
And that is that there's not a firm distinction between programs and data.

577
00:50:09,240 --> 00:50:16,810
流会是这样的一种结构，你可以想象树的叶子的流
So what a stream is going to be is simultaneously this data structure that you think of, like the stream of the leaves of this tree.

578
00:50:16,810 --> 00:50:23,550
但是不得不说，其中包含着计算方法的过程着实很精妙
But at the same time, it's going to be a very clever procedure that has the method of computing in it.

579
00:50:23,550 --> 00:50:25,930
好吧，实际来看一下
Well, let me try this.

580
00:50:25,930 --> 00:50:28,460
事实上我们不需要其它高深的原理
It's going to turn out that we don't need any more mechanism.

581
00:50:28,460 --> 00:50:35,460
这个事实已经有了我们所需要的一切东西，那就是了解如何把过程作为一级对象来处理
We already have everything we need simply from the fact that we know how to handle procedures as first-class objects.

582
00:50:35,460 --> 00:50:36,880
来看看这个关键之处
Well, let's go back to the key.

583
00:50:36,880 --> 00:50:39,030
关键是，记住，我们有实际的操作方法
The key is, remember, we had these operations.

584
00:50:39,030 --> 00:50:48,080
CONS-STREAM HEAD TAIL
CONS-stream and head and tail.

585
00:50:48,080 --> 00:50:55,080
一开始，你可以把这个想像成CONS，这个是CAR，这个是CDR，事实上没这么简单
When I started, I said you can think about this as CONS and think about this as CAR and think about that as CDR, but it's not.

586
00:50:55,080 --> 00:50:57,550
现在我们来具体看看它们到底是什么
Now, let's look at what they really are.

587
00:50:57,550 --> 00:51:19,540
(CONS-STREAM X Y) 是这个东西的缩写形式
Well, CONS-stream of x and y is going to be an abbreviation for the following thing.

588
00:51:19,540 --> 00:51:28,000
(CONS X (DELAY Y))
CONS form a pair, ordinary CONS, of x to a thing called delay of y.

589
00:51:31,188 --> 00:51:39,790
在我具体解释清楚之前，先把剩下的写完，(HEAD S) 就是 (CAR S)
And before I explain that, let me go and write the rest. The head of a stream is going to be just the CAR.

590
00:51:42,380 --> 00:51:56,120
(TAIL S) 是 (FORCE (CDR S))
And the tail of a stream is going to be a thing called force the CDR of the stream.

591
00:51:56,120 --> 00:51:58,060
我来具体解释一下
Now let me explain this.

592
00:51:58,060 --> 00:52:01,420
DELAY看起来很神奇
Delay is going to be a special magic thing.

593
00:52:01,420 --> 00:52:10,600
DELAY所做是取一个表达式，然后做了一个约定，有需要的时候再来计算我
What delay does is take an expression and produce a promise to compute that expression when you ask for it.

594
00:52:10,600 --> 00:52:11,980
这里并没有做实际的计算
It doesn't do any computation here.

595
00:52:11,980 --> 00:52:14,820
只是一个延期的约定
It just gives you a rain check.

596
00:52:14,820 --> 00:52:17,110
承诺要做这样的事
It produces a promise.

597
00:52:17,110 --> 00:52:25,360
CONS-STREAM所做的就是把X和一个计算Y的约定相组合
And CONS-stream says I'm going to put together in a pair x and a promise to compute y.

598
00:52:28,230 --> 00:52:31,840
如果你想取头，就是序对的CAR
Now, if I want the head, that's just the CAR that I put in the pair.

599
00:52:31,840 --> 00:52:39,110
关键在于尾操作，对承诺进行FORCE调用
And the key is that the tail is going to be-- force calls in that promise.

600
00:52:39,110 --> 00:52:44,610
TAIL会说，好吧，遵守承诺进行计算
Tail says, well, take that promise and now call in that promise.

601
00:52:44,610 --> 00:52:47,430
这才开始实际的计算
And then we compute that thing.

602
00:52:47,430 --> 00:52:48,740
这就是它的实际工作方式
That's how this is going to work.

603
00:52:48,740 --> 00:52:51,550
这就是CONS-STREAM，HEAD，TAIL的真实面目了
That's what CONS-stream, head, and tail really are.

604
00:52:54,196 --> 00:52:55,570
具体演示一下
Now, let's see how this works.

605
00:52:55,570 --> 00:52:58,410
我会非常小心的过一遍
And we'll go through this fairly carefully.

606
00:52:58,410 --> 00:53:08,650
现在从计算10,000到1,000,1000中的第二个质数这个实例来看，那具体是怎么运行的
We're going to see how this works in this example of computing the second prime between 10,000 and a million.

607
00:53:08,650 --> 00:53:11,610
好的，我们从这个表达式开始
OK, so we start off and we have this expression.

608
00:53:15,820 --> 00:53:26,710
第二个质数 -- 就是(HEAD (TAIL (FILTER (PRIME? (E-I 10000 1000000)))))
The second prime-- the head of the tail of the result of filtering for primality the integers between 10,000 and 1 million.

609
00:53:26,710 --> 00:53:28,400
这究竟是什么？
Now, what is that?

610
00:53:28,400 --> 00:53:40,250
就是10,000至1,000,000之间到底是什么？好，如果你开始枚举之间的整数，就构造了一个流
What that is, that interval between 10,000 and 1 million, well, if you trace through enumerate interval, there builds a CONS-stream.

611
00:53:40,250 --> 00:53:54,480
CONS-STREAM实际代换过来是(CONS 10000 (DELAY (E-I 10001 1000000)))
And the CONS-stream is the CONS of 10,000 to a promise to compute the integers between 10,001 and 1 million.

612
00:53:54,480 --> 00:53:55,750
这也就是上面这个表达式
So that's what this expression is.

613
00:53:55,750 --> 00:53:57,640
现在我使用代换模型
Here I'm using the substitution model.

614
00:53:57,640 --> 00:54:01,010
我们可以用代换模型的原因是这里并没有涉及时间与状态的副作用
And we can use the substitution model because we don't have side effects and state.

615
00:54:04,270 --> 00:54:08,380
这里还有一个计算10001至1000000的承诺
So I have CONS of 10,000 to a promise to compute the rest of the integers.

616
00:54:08,380 --> 00:54:09,850
所以到现在为止，只有一个整数被枚举了出来
So only one integer, so far, got enumerated.

617
00:54:14,380 --> 00:54:16,580
然后用filter去过滤
Well, I'm going to filter that thing for primality.

618
00:54:19,900 --> 00:54:22,360
我们再来细看filter这个东西
Again, you go back and look at the filter code.

619
00:54:22,360 --> 00:54:25,460
filter首先测试 (HEAD S)
What the filter will first do is test the head.

620
00:54:25,460 --> 00:54:33,500
这里，测试到的是10,000，不是素数
So in this case, the filter will test 10,000 and say, oh, 10,000's not prime.

621
00:54:33,500 --> 00:54:39,220
然后就开始递归的过滤TAIL的部分
Therefore, what I have to do recursively is filter the tail.

622
00:54:39,220 --> 00:54:46,340
TAIL是什么呢？就是那个继续计算的承诺
And what's the tail of it, well, that's the tail of this pair with a promise in it.

623
00:54:46,340 --> 00:54:49,680
开始计算尾了，尾说，好，我履行承诺继续计算
Tail now comes in and says, well, I'm going to force that.

624
00:54:49,680 --> 00:55:00,880
履行承诺的意思是继续枚举10,001到1,000,000之间的整数
I'm going to force that promise, which means now I'm going to compute the integers between 10,001 and 1 million.

625
00:55:00,880 --> 00:55:02,970
现在看起来像是这样
OK, so this filter now is looking at that.

626
00:55:07,810 --> 00:55:11,960
现在，就又回到了最开始枚举的部分
That enumerate itself, well, now we're back in the original enumerate situation.

627
00:55:11,960 --> 00:55:19,740
(CONS 10001 (DELAY (E-I 10002 1000000))))
The enumerate is the CONS of the first thing, 10,001, onto a promise to compute the rest.

628
00:55:19,740 --> 00:55:23,060
现在filter又开始针对10,001进行过滤了
So now the primality filter is going to go look at 10,001.

629
00:55:23,060 --> 00:55:25,120
又要开始判断是不是质数
It's going to decide if it likes that or not.

630
00:55:25,120 --> 00:55:27,550
结果不是
It turns out 10,001 isn't prime.

631
00:55:27,550 --> 00:55:29,610
然后再继续履行承诺计算下去
So it'll force it again and again and again.

632
00:55:32,920 --> 00:55:37,100
然后，我觉得第一个质数可能是10,009
And finally, I think the first prime it hits is 10,009.

633
00:55:37,100 --> 00:55:40,465
在这个点才停下来
And at that point, it'll stop.

634
00:55:40,465 --> 00:55:45,240
这只是第一个质数，我们需要的是第二个
And that will be the first prime, and then eventually, it'll need the second prime.

635
00:55:45,240 --> 00:55:47,030
所以，又开始了
So at that point, it will go again.

636
00:55:47,030 --> 00:55:53,130
你会发现，你需要多少，它才生成多少，不多不少
So you see what happens is that no more gets generated than you actually need.

637
00:55:56,690 --> 00:56:04,930
enumerator不会生成比filter的要求更多的数要它去过滤
That enumerator is not going to generate any more integers than the filter asks it for as it's pulling in things to check for primality.

638
00:56:04,930 --> 00:56:11,255
filter也不会生成比你的要求更多的东西
And the filter is not going to generate any more stuff than you ask it for, which is the head of the tail.

639
00:56:11,255 --> 00:56:28,160
看吧，这样的程序实际运行起来就像是传统的那种程序一样，尽管外表看起来不像
You see, what's happened is we've put that mixing of generation and test into what actually happens in the computer, even though that's not apparently what's happening from looking at our programs.

640
00:56:28,160 --> 00:56:30,230
一切都很简单
OK, well, that seemed easy.

641
00:56:30,230 --> 00:56:33,326
这种机制的所有神奇之处在于DELAY
All of this mechanism got put into this magic delay.

642
00:56:33,326 --> 00:56:36,900
所以你会想，啊，这肯定是最难以理解的地方
So you're saying, gee, that must be where the magic is.

643
00:56:36,900 --> 00:56:39,070
但是并不是
But see there's no magic there either.

644
00:56:39,070 --> 00:56:40,610
其实你应该知道DELAY是什么
You know what delay is.

645
00:56:40,610 --> 00:56:56,490
表达式的DELAY只是一个缩略词，那么，这个要履行计算的承诺到底是什么？
Delay on some expression is just an abbreviation for--  well, what's a promise to compute an expression?

646
00:56:56,490 --> 00:57:03,000
(lambda () <exp>)，就这么简单
Lambda of nil, procedure of no arguments, which is that expression.

647
00:57:03,000 --> 00:57:03,930
这就是整个过程
That's what a procedure is.

648
00:57:03,930 --> 00:57:06,050
它的意思是，这个表达式将会被计算
It says I'm going to compute an expression.

649
00:57:06,050 --> 00:57:07,460
FORCE又是什么？
What's force?

650
00:57:07,460 --> 00:57:10,800
如何履行承诺？
How do I take up a promise?

651
00:57:10,800 --> 00:57:15,890
FORCE一些过程，只是简单地运行它们
Well, force of some procedure, a promise, is just run it.

652
00:57:18,710 --> 00:57:20,120
结束了，就是这样
Done.

653
00:57:20,120 --> 00:57:23,580
并没有什么离奇
So there's no magic there at all.

654
00:57:23,580 --> 00:57:26,440
总结一下，我们都做了点什么？
Well, what have we done?

655
00:57:26,440 --> 00:57:30,960
我们说，传统的编程方式更有效
We said the old style, traditional style of programming is more efficient.

656
00:57:30,960 --> 00:57:35,260
使用流来编程，程序更为明晰
And the stream thing is more perspicuous.

657
00:57:35,260 --> 00:57:43,350
我们设法用DELAY，使流获得了和其它过程一样的运行效果
And we managed to make the stream procedures run like the other procedures by using delay.

658
00:57:43,350 --> 00:57:54,440
DELAY所做的就是，把我们程序中的事件顺序与实际发生在机器中的事件顺序分离开来
And the thing that delay did for us was to de-couple the apparent order of events in our programs from the actual order of events that happened in the machine.

659
00:57:54,440 --> 00:57:56,540
这就是DELAY的作用
That's really what delay is doing.

660
00:57:56,540 --> 00:57:58,290
也是全部的重点
That's exactly the whole point.

661
00:57:58,290 --> 00:58:09,182
我们放弃了这种想法，即过程结构与实际运行映射出清晰的时间性
We've given up the idea that our procedures, as they run, or as we look at them, mirror some clear notion of time.

662
00:58:09,182 --> 00:58:16,690
放弃这种想法，我们给予DELAY以改变计算顺序的自由
And by giving that up, we give delay the freedom to arrange the order of events in the computation the way it likes.

663
00:58:16,690 --> 00:58:17,610
整个思想就是这样
That's the whole idea.

664
00:58:17,610 --> 00:58:24,200
我们分离了程序表面上的顺序与实际运行的顺序
We de-couple the apparent order of events in our programs from the actual order of events in the computer.

665
00:58:24,200 --> 00:58:25,770
对了，还有一个细节
OK, well there's one more detail.

666
00:58:25,770 --> 00:58:29,730
一个技术性的细节，但是也非常重要
It's just a technical detail, but it's actually an important one.

667
00:58:29,730 --> 00:58:39,320
当你运行一些递归的过程时，就像(TAIL (TAIL (TAIL ... 这样
As you run through these recursive programs unwinding, you'll see a lot of things that look like tail of the tail of the tail.

668
00:58:39,320 --> 00:58:43,860
它就会不断在流中通过CONS来计算构造新元素
That's the kind of thing that would happen as I go CONSing down a stream all the way.

669
00:58:43,860 --> 00:59:05,290
每次我这样做，计算TAIL，都要执行过程计算出新元素，每次执行TAIL，都要再次计算，看起来这效率非常低，还不如列表，因为我进行了多余的重复
And if each time I'm doing that, each time to compute a tail, I evaluate a procedure which then has to go re-compute its tail, and re-compute its tail and recompute its tail each time, you can see that's very inefficient compared to just having a list where the elements are all there, and I don't have to re-compute each tail every time I get the next tail.

670
00:59:05,290 --> 00:59:20,390
我们把DELAY稍微改写一下，就可以让整件事变得 -- 我先写一下
So there's one little hack to slightly change what delay is, and make it a thing which is-- I'll write it this way.

671
00:59:20,390 --> 00:59:31,000
(DELAY <exp>)的具体内容是(MEMO-PROC (lambda () <exp>))
The actual implementation, delay is an abbreviation for this thing, memo-proc of a procedure.

672
00:59:31,000 --> 00:59:35,150
MEMO-PROC改变一个过程
Memo-proc is a special thing that transforms a procedure.

673
00:59:35,150 --> 00:59:44,806
取一个没有参数的过程，转变其为只需要执行一次计算的过程
What it does is it takes a procedure of no arguments and it transforms it into a procedure that'll only have to do its computation once.

674
00:59:44,806 --> 00:59:48,700
我们意思是，你给它一个过程
And what I mean by that is, you give it a procedure.

675
00:59:48,700 --> 01:00:02,360
MEMO-PROC的结果是一个新的过程，第一次运行的时候，它计算<exp>，记下来它的结果，从那之后，每次你再运行这个过程，就不用再计算了
The result of memo-proc will be a new procedure, which the first time you call it, will run the original procedure, remember what result it got, and then from ever on after, when you call it, it just won't have to do the computation.

676
01:00:02,360 --> 01:00:05,200
它会把结果存储在一个地方
It will have cached that result someplace.

677
01:00:05,200 --> 01:00:06,550
可以这样来实现MEMO-PROC
And here's an implementation of memo-proc.

678
01:00:11,210 --> 01:00:12,710
一旦你了解怎么做，实现就很容易了
Once you have the idea, it's easy to implement.

679
01:00:12,710 --> 01:00:17,390
MEMO-PROC中，有两个标记变量
Memo-proc is this little thing that has two little flags in there.

680
01:00:17,390 --> 01:00:20,320
一个是，记录是否运行过
It says, have I already been run?

681
01:00:20,320 --> 01:00:23,620
初始值是NO，还没运行过
And initially it says, no, I haven't already been run.

682
01:00:23,620 --> 01:00:29,070
上一次运行后，它的结果是什么？
And what was the result I got the last time I was run?

683
01:00:29,070 --> 01:00:34,360
MEMO-PROC取一个参数为PROC，返回一个没有参数的过程
So memo-proc takes a procedure called proc, and it returns a new procedure of no arguments.

684
01:00:34,360 --> 01:00:38,610
PROC也是一个没有参数的过程
Proc is supposed to be a procedure of no arguments.

685
01:00:38,610 --> 01:00:44,430
如果没有运行过，就做下面的事情
And it says, oh, if I'm not already run, then I'm going to do a sequence of things.

686
01:00:44,430 --> 01:00:48,450
计算PROC，存储它的值
I'm going to compute proc, I'm going to save that.

687
01:00:48,450 --> 01:00:51,140
存储在变量RESULT中
I'm going to stash that in the variable result.

688
01:00:51,140 --> 01:00:56,610
然后对already-run?赋值，提醒自己已经运行过了，最后返回result
I'm going to make a note to myself that I've already been run, and then I'll return the result.

689
01:00:56,610 --> 01:00:59,010
所以整件事即如果你没有运行过，就计算一次
So that's if you compute it if it's not already run.

690
01:00:59,010 --> 01:01:03,420
如果已经运行过，直接返回结果就好了
If you call it and it's already been run, it just returns the result.

691
01:01:03,420 --> 01:01:08,400
这是一种叫“记忆化”的小技巧
So that's a little clever hack called memorization.

692
01:01:08,400 --> 01:01:15,270
这样的话，这一串东西就不会来反复的计算TAIL了
And in this case, it short circuits having to re-compute the tail of the tail of the tail of the tail of the tail.

693
01:01:15,270 --> 01:01:17,810
不再那样的没效率了
So there isn't even that kind of inefficiency.

694
01:01:17,810 --> 01:01:24,210
事实上，这样做甚至和传统的那种程序效率是一样的
And in fact, the streams will run with pretty much the same efficiency as the other programs precisely.

695
01:01:24,210 --> 01:01:33,610
记住，再次提醒，整个的思想在于，过程与数据之间没有一个明确的分界线
And remember, again, the whole idea of this is that we've used the fact that there's no really good dividing line between procedures and data.

696
01:01:33,610 --> 01:01:38,760
这个数据结构看起来，有点像一个过程
We've written data structures that, in fact, are sort of like procedures.

697
01:01:38,760 --> 01:01:49,620
它使我们可以在这里放置一个结构，不断的迭代计算自身
And what that's allowed us to do is take an example of a common control structure, in this place iteration.

698
01:01:49,620 --> 01:01:55,496
我们构造的这个数据结构，其中有一个过程，这个过程可以通过迭代，产生新的结构
And we've built a data structure which, since itself is a procedure, kind of has this iteration control structure in it.

699
01:01:55,496 --> 01:01:58,650
这就是流的实质
And that's really what streams are.

700
01:01:58,650 --> 01:01:59,900
好的，大家有什么问题吗？
OK, questions?

701
01:02:03,950 --> 01:02:13,052
我是这样理解的，你刚才说(TAIL (TAIL (TAIL ...，没有没有MEMO-PROC的话，FORCE仅仅只是执行了一次过程而已
AUDIENCE: Your description of tail-tail-tail, if I understand it correctly, force is actually execution of a procedure, if it's done without this memo-proc thing.

702
01:02:13,052 --> 01:02:16,380
你说使用那个MEMO-PROC就不会有那样的问题
And you implied that memo-proc gets around that problem.

703
01:02:16,380 --> 01:02:23,910
难道(TAIL (TAIL (TAIL ... 不是每次都在进行计算吗？ -- [教授]哦，对的
Doesn't it only get around it if tail-tail-tail is always executing exactly the same-- PROFESSOR: Oh, that's-- sure.

704
01:02:23,910 --> 01:02:26,050
我忘记说了
PROFESSOR: I guess I missed that point.

705
01:02:26,050 --> 01:02:26,540
你是对的
PROFESSOR: Oh, sure.

706
01:02:26,540 --> 01:02:31,290
不小心漏掉了这点
I mean the point is--  yeah.

707
01:02:31,290 --> 01:02:34,160
我的意思是，不用重复计算也可以得到结果
I mean I have to do a computation to get the answer.

708
01:02:34,160 --> 01:02:42,980
关键在于，一旦你计算过(TAIL STREAM)，当你计算(TAIL (TAIL STREAM))的时候，就不用再计算第一个TAIL了
But the point is, once I've found the tail of the stream, to get the tail of the tail, I shouldn't have had to re-compute the first tail.

709
01:02:42,980 --> 01:02:46,460
明白了吧，如果我没有用MEMO-PROC，还要再计算一遍(TAIL STREAM)
See, and if I didn't use memo-proc, that re-computation would have been done.

710
01:02:46,460 --> 01:02:47,710
明白了
AUDIENCE: I understand now.

711
01:02:50,830 --> 01:02:56,830
之前的例子中你提到过，我们可以使用代换模型因为这里没有副作用
AUDIENCE: In one of your examples, you mentioned that we were able to use the substitution model because there are no side effects.

712
01:02:56,830 --> 01:03:03,620
如果流通过的一个处理单元 -- 如果有副作用呢？如果有了状态？
What if we had a single processing unit-- if we had a side effect, if we had a state?

713
01:03:03,620 --> 01:03:09,120
我们还可以用这种流的结构吗？
Could we still practically build the stream model?

714
01:03:09,120 --> 01:03:09,530
可能吧
PROFESSOR: Maybe.

715
01:03:09,530 --> 01:03:10,540
很难说
That's a hard question.

716
01:03:10,540 --> 01:03:18,960
我可能会花很长时间来探讨代换模型和副作用无法共存
I'm going to talk a little bit later about the places where substitution and side effects don't really mix very well.

717
01:03:18,960 --> 01:03:25,170
通常情况下，除非你非常小心，否则副作用会把一切弄的很糟糕
But in general, I think the answer is unless you're very careful, any amount of side effect is going to mess up everything.

718
01:03:35,490 --> 01:03:39,410
我不是很理解MEMO-PROC这个过程
AUDIENCE: Sorry, I didn't quite understand the memo-proc operation.

719
01:03:39,410 --> 01:03:41,990
当你执行lambda的时候
When do you execute the lambda?

720
01:03:41,990 --> 01:03:47,600
换句话说，当MEMO-PROC执行的时候，只生成了lambda表达式
In other words, when memo-proc is executed, just this lambda expression is being generated.

721
01:03:47,600 --> 01:03:50,390
但是我不太清楚是什么时候执行的
But it's not clear to me when it's executed.

722
01:03:50,390 --> 01:03:51,350
好的
PROFESSOR: Right.

723
01:03:51,350 --> 01:03:57,930
MEMO-PROC所做的 -- 作为MEMO-PROC参数是PROC，一个没有参数的过程
What memo-proc does-- remember, the thing that's going into memo-proc, the thing proc, is a procedure of no arguments.

724
01:03:57,930 --> 01:04:00,390
某个时刻，你会调用到它
And someday, you're going to call it.

725
01:04:00,390 --> 01:04:06,620
MEMO-PROC把一个过程转化为另一个过程，某个时刻你会调用到它
Memo-proc translates that procedure into another procedure of no arguments, which someday you're going to call.

726
01:04:06,620 --> 01:04:09,890
就是这个lambda
That's that lambda.

727
01:04:09,890 --> 01:04:24,100
这里，当这一部分构造成为流的TAIL的时候，这个没有参数的过程，会在之后的某个时刻被调用到
So here, where I initially built as my tail of the stream, say, this procedure of no arguments, which someday I'll call.

728
01:04:24,100 --> 01:04:30,650
相对应的，我把这一部分理解为是MEMO-PROC，某个时刻会被调用到的
Instead, I'm going to have the tail of the stream be memo-proc of it, which someday I'll call.

729
01:04:30,650 --> 01:04:47,642
所以这个lambda，会在你调用MEMO-PROC得到结果的时候被调用，正如你之前设置过的一样
So that lambda of nil, that gets called when you call the memo-proc, when you call the result of that memo-proc, which would be ordinarily when you would have called the original thing that you set it.

730
01:04:47,642 --> 01:04:52,610
我的意思是，你调用MEMO-PROC的时候，你只是返回了一个lambda
AUDIENCE: OK, the reason I ask is I had a feeling that when you call memo-proc, you just return this lambda.

731
01:04:52,610 --> 01:04:53,770
对啊
PROFESSOR: That's right.

732
01:04:53,770 --> 01:04:58,100
你调用MEMO-PROC的时候，返回了一个lambda
When you call memo-proc, you return the lambda.

733
01:04:58,100 --> 01:05:02,270
你也没有执行<exp>，直到你第一次需要执行它的时候
You never evaluate the expression at all, until the first time that you would have evaluated it.

734
01:05:07,590 --> 01:05:14,240
我这样理解对吗？你构造了一个列表，其中的元素还没有被计算
AUDIENCE: Do I understand it right that you actually have to build the list up, but the elements of the list don't get evaluated?

735
01:05:14,240 --> 01:05:15,630
表达式没有被计算？
The expressions don't get evaluated?

736
01:05:15,630 --> 01:05:18,540
但在在每一个阶段，你还是构造了列表
But at each stage, you actually are building a list.

737
01:05:18,540 --> 01:05:20,700
嗯，我应该这样说
PROFESSOR: That's-- I really should have said this.

738
01:05:20,700 --> 01:05:22,270
这个问题不错
That's a really good point.

739
01:05:22,270 --> 01:05:23,660
但是，也不全对
No, it's not quite right.

740
01:05:23,660 --> 01:05:25,080
因为实际发生的事情是这样的
Because what happens is this.

741
01:05:25,080 --> 01:05:26,890
我先把这个画成序对
Let me draw this as pairs.

742
01:05:26,890 --> 01:05:32,740
假设我要构造一个特别大的流，比如枚举整数，从1到1,000,000,000
Suppose I'm going to make a big stream, like enumerate interval, 1 through 1 billion.

743
01:05:32,740 --> 01:05:43,045
就是1，和一个计算的约定
What that is, is a pair with a 1 and a promise.

744
01:05:46,520 --> 01:05:47,890
就是这样
That's exactly what it is.

745
01:05:47,890 --> 01:05:49,140
什么都没有构造
Nothing got built up.

746
01:05:51,600 --> 01:05:56,370
当我继续的时候，FORCE这一部分，会发生什么？
When I go and force this, and say, what happens?

747
01:05:56,370 --> 01:06:00,530
这个东西递归的产生了CONS
Well, this thing is now also recursively a CONS.

748
01:06:00,530 --> 01:06:11,350
这个约定生成了下一个东西，就是2和一个约定
So that this promise now is the next thing, which is a 2 and a promise to do more.

749
01:06:11,350 --> 01:06:14,470
一直这样下去
And so on and so on and so on.

750
01:06:14,470 --> 01:06:18,200
所以你沿着流这样下来，并没有构造什么
So nothing gets built up until you walk down the stream.

751
01:06:18,200 --> 01:06:25,500
因为这个东西不是列表，只是一个生成列表的约定，技术上来说，是一个过程
Because what's sitting here is not the list, but a promise to generate the list. And by promise, technically I mean procedure.

752
01:06:28,050 --> 01:06:30,485
因此并没有构造列表
So it doesn't get built up.

753
01:06:30,485 --> 01:06:34,280
我应该早点说的
Yeah, I should have said that before this point.

754
01:06:34,280 --> 01:06:34,490
好吧
OK.

755
01:06:34,490 --> 01:06:34,790
就到这里
Thank you.

756
01:06:34,790 --> 01:06:36,340
大家休息一下吧
Let's take a break.

