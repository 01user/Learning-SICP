1
00:00:18,910 --> 00:00:21,792
我们已经了解了查询语言的使用方式
PROFESSOR: All right, well, we've seen how the query language works.

2
00:00:22,640 --> 00:00:25,072
现在该来讨论如何实现了
Now, let's talk about how it's implemented.

3
00:00:26,280 --> 00:00:27,984
你们也应该能够想象到
You already pretty much can guess

4
00:00:28,592 --> 00:00:29,470
它其中的原理
what's going on there.

5
00:00:29,470 --> 00:00:31,648
它的最底层是一个模式匹配器
At the bottom of it, there's a pattern matcher.

6
00:00:32,810 --> 00:00:34,256
我们在《基于规则的控制语言》一课中
And we looked at a pattern matcher

7
00:00:34,672 --> 00:00:36,944
已经介绍过模式匹配器了
when we did the rule-based control language.

8
00:00:38,110 --> 00:00:40,592
为了让你们回想起来 我举个例子
Just to remind you, here are some sample patterns.

9
00:00:41,520 --> 00:00:43,680
这个模式会匹配
This is a pattern that will match

10
00:00:43,808 --> 00:00:44,928
一个含有三个元素的表
any list of three things

11
00:00:44,960 --> 00:00:47,104
其中 首元素为'A
which the first is a

12
00:00:47,168 --> 00:00:48,336
其次是'C
the second is c

13
00:00:48,480 --> 00:00:50,192
而中间可以为任意元素
and the middle one can be anything.

14
00:00:50,650 --> 00:00:52,272
所以在这个小型的模式匹配语言中
So in this little pattern-matching syntax,

15
00:00:52,304 --> 00:00:54,050
你只能区分一种类型
there's only one distinction you make.

16
00:00:54,050 --> 00:00:57,200
也就是区分字面量或者变量
There's either literal things or variables,

17
00:00:57,232 --> 00:00:58,864
以问号开头的就是变量
and variables begin with question mark.

18
00:01:01,370 --> 00:01:03,648
因此这个模式会匹配任意的三元表
So this matches any list of three things

19
00:01:04,448 --> 00:01:06,500
只要它的首元素为'A 而第三个元素为'C
of which the first is a and the second is c.

20
00:01:06,500 --> 00:01:09,008
而这个模式匹配的三元表
This one matches any list of three things

21
00:01:10,432 --> 00:01:12,530
它的首元素必须是符号'JOB
of which the first is the symbol job.

22
00:01:12,530 --> 00:01:13,904
第二个元素为任意值
The second can be anything.

23
00:01:14,210 --> 00:01:15,904
第三个元素必须是一个二元表
And the third is a list of two things

24
00:01:15,952 --> 00:01:17,728
二元表的首元素为符号'COMPUTER
of which the first is the symbol computer

25
00:01:17,888 --> 00:01:19,424
第二个元素可以为任意值
and the second can be anything.

26
00:01:20,480 --> 00:01:25,552
而下一条模式所匹配的三元表
And this one, this next one matches any list of three things,

27
00:01:25,872 --> 00:01:26,992
区别就在于
and the only difference is,

28
00:01:28,400 --> 00:01:31,320
在于第三个元素的首元素必须为符号'COMPUTER
here, the third list, the first is the symbol computer,

29
00:01:31,760 --> 00:01:33,296
表剩余部分可以是任意值
and then there's some rest of the list.

30
00:01:35,040 --> 00:01:37,536
也就是说 上面是二元表 而下面没有限定数目
So this means two elements and this means arbitrary number.

31
00:01:37,860 --> 00:01:39,744
然而我们的语言实现
And our language implementation isn't

32
00:01:39,856 --> 00:01:42,064
根本不用操心如何去实现这个点号
isn't even going to have to worry about implementing this dot

33
00:01:42,112 --> 00:01:44,176
因为这个由Lisp读取器自动地完成
because that's automatically done by Lisp's reader.

34
00:01:48,340 --> 00:01:50,310
要注意 匹配器还要保持一致性
Remember matchers also have some consistency in them.

35
00:01:50,310 --> 00:01:52,320
这个模式匹配一个三元表
This match is a list of three things

36
00:01:52,592 --> 00:01:53,984
表的首元素是'A
of which the first is a.

37
00:01:54,430 --> 00:01:55,792
而第二个元素和第三个元素可以是任意值
And the second and third can be anything,

38
00:01:55,808 --> 00:01:57,088
但它们必须是相同的
but they have to be the same thing.

39
00:01:57,940 --> 00:01:58,848
它们都是?X
They're both called x.

40
00:01:59,600 --> 00:02:01,552
而这个模式匹配一个四元表
And this matches a list of four things

41
00:02:01,968 --> 00:02:03,264
其中第一个元素与第四个元素相同
of which the first is the fourth

42
00:02:03,664 --> 00:02:05,152
而第二个元素与第三个元素相同
and the second is the same as the third.

43
00:02:05,590 --> 00:02:08,608
最后一个模式匹配以'A开头的任意表
And this last one matches any list that begins with a.

44
00:02:09,680 --> 00:02:11,056
以'A开头
The first thing is a,

45
00:02:11,232 --> 00:02:12,560
余下的可以是任意值
and the rest can be anything.

46
00:02:14,040 --> 00:02:16,608
这是对我们已经学习过的模式匹配语言
So that's just a review of pattern matcher syntax

47
00:02:16,624 --> 00:02:17,872
的一个回顾
that you've already seen.

48
00:02:18,780 --> 00:02:19,648
还记得吗
And remember,

49
00:02:19,792 --> 00:02:22,288
这是由一个叫做MATCH的过程实现的
that's implemented by some procedure called match.

50
00:02:24,870 --> 00:02:36,064
MATCH有三个参数：PATTERN、DATA以及DICTIONARY
And match takes a pattern and some data and a dictionary.

51
00:02:43,200 --> 00:02:47,120
MATCH考虑的是
And match asks the question

52
00:02:47,790 --> 00:02:52,640
利用给定DICTIONAY中的绑定
is there any way to match this pattern against this data object

53
00:02:53,552 --> 00:02:56,736
能够找到一种方法把模式与数据对象匹配起来吗？
subject to the bindings that are already in this dictionary?

54
00:02:58,160 --> 00:02:59,216
比如说
So, for instance,

55
00:02:59,568 --> 00:03:06,432
如果我们想要把模式(?X ?Y ?Y ?X)
if we're going to match the pattern x, y, y, x

56
00:03:07,712 --> 00:03:13,840
与数据对象(A B B A)相匹配
against the data a, b, b, a

57
00:03:15,120 --> 00:03:20,528
又给定了一个字典 X=A
subject to a dictionary, that says x equals a.

58
00:03:22,010 --> 00:03:25,232
MATCH就会说：“它们是一致的”
Then the matcher would say, yes, that's consistent.

59
00:03:25,260 --> 00:03:27,168
再给定的字典说 X=A 的情况下
These match, and it's consistent

60
00:03:27,808 --> 00:03:30,208
模式与数据相匹配
with what's in the dictionary to say that x equals a.

61
00:03:30,320 --> 00:03:31,600
而匹配的结果则是
And the result of the match

62
00:03:32,256 --> 00:03:34,304
一个扩展了的词典
is the extended dictionary

63
00:03:34,464 --> 00:03:37,600
其中包含 X=A Y=B
that says x equals a and y equals b.

64
00:03:39,490 --> 00:03:42,240
MATCH接收PAT、DATA和DICTIONAY
So a matcher takes in pattern data dictionary,

65
00:03:42,384 --> 00:03:44,544
如果成功匹配就输出一个扩展后的词典
puts out an extended dictionary if it matches,

66
00:03:44,976 --> 00:03:46,840
否则就报错
or if it doesn't match, says that it fails.

67
00:03:46,840 --> 00:03:47,712
因此 比如说
So, for example,

68
00:03:47,888 --> 00:03:50,384
如果我在这里使用同样的模式
if I use the same pattern here,

69
00:03:50,976 --> 00:03:55,120
如果我用模式(?X ?Y ?Y ?X)
if I say this x, y, y, x

70
00:03:55,660 --> 00:03:58,496
去匹配(A B B A)
match a, b, b, a

71
00:03:59,470 --> 00:04:02,840
并给定词典 Y=A
with the dictionary y equals a,

72
00:04:05,152 --> 00:04:06,816
那么MATCH就会输出FAIL
then the matcher would put out fail.

73
00:04:12,528 --> 00:04:14,656
由于我们已经降解过模式匹配器的代码了
Well, you've already seen the code for a pattern matcher

74
00:04:15,008 --> 00:04:16,176
我就不会再去细讲
so I'm not going to go over it,

75
00:04:16,640 --> 00:04:19,776
这跟我们以前做的类似
but it's the same thing we've been doing before.

76
00:04:21,190 --> 00:04:23,220
我们在《基于规则的系统》中已经见过了
You saw that in the system on rule-based control.

77
00:04:23,220 --> 00:04:24,560
基本上是同样的匹配器
It's essentially the same matcher.

78
00:04:24,950 --> 00:04:27,664
实际上 我认为这里的语法还更简单一点
In fact, I think the syntax is a little bit simpler

79
00:04:28,160 --> 00:04:29,312
因为我们不用去关心
because we're not worrying about

80
00:04:29,408 --> 00:04:31,400
任意变量、任意表达式之类的东西
arbitrary constants and expressions and things.

81
00:04:31,400 --> 00:04:32,880
这里面只区分变量和常量
There's just variables and constants.

82
00:04:35,790 --> 00:04:37,328
那么 有了模式匹配器以后
OK, well, given that,

83
00:04:38,464 --> 00:04:39,610
基本查询又是怎么样的呢？
what's a primitive query?

84
00:04:42,970 --> 00:04:45,344
基本查询将会是一个相当复杂的东西
Primitive query is going to be a rather complicated thing.

85
00:04:46,672 --> 00:05:03,580
就拿查询(JOB ?X (?D . y))来说
It's going to be-- let's think about the query job of x is d dot y.

86
00:05:07,040 --> 00:05:08,736
我们可能会输入这样的查询
That's a query we might type in.

87
00:05:09,400 --> 00:05:11,392
这又将如何在系统内实现呢？
That's going to be implemented in the system.

88
00:05:14,144 --> 00:05:15,664
我们可以把它想做这个小盒子
We'll think of it as this little box.

89
00:05:15,700 --> 00:05:16,800
这是一条基本查询
Here's the primitive query.

90
00:05:18,880 --> 00:05:20,304
这个小盒子将会
What this little box is going to do

91
00:05:22,240 --> 00:05:27,280
以两条流作为输入
is take in two streams and put out a stream.

92
00:05:31,968 --> 00:05:33,200
并输出一条流
and put out a stream.

93
00:05:34,030 --> 00:05:36,192
因此一条基本查询的形状
So the shape of a primitive query

94
00:05:36,512 --> 00:05:38,464
就将是有两条输入流
is that it's a thing where two streams come in

95
00:05:38,672 --> 00:05:39,968
和一条输出流
and one stream goes out.

96
00:05:41,120 --> 00:05:46,208
而这些流 来自于这里的数据库
What these streams are going to be is down here is the database.

97
00:05:51,952 --> 00:05:53,936
因此我们把数据库中的所有数据
So we imagine all the things in the database

98
00:05:55,930 --> 00:05:57,200
想象成一条流
sort of sitting there in a stream

99
00:05:57,310 --> 00:05:58,400
而这个盒子不断地吸取
and this thing sucks on them.

100
00:06:00,368 --> 00:06:02,432
那么 数据库中有什么呢？
So what are some things that might be in the database?

101
00:06:08,432 --> 00:06:20,320
首先是(JOB (ALYSSA ...))
Oh, job of Alyssa is something

102
00:06:21,968 --> 00:06:23,712
以及还有其它的JOB数据
and some other job is something.

103
00:06:25,770 --> 00:06:30,416
想象一下 数据库中的所有事实都在这条流中
So imagine all of the facts in the database sitting there in the stream.

104
00:06:32,040 --> 00:06:33,104
都到了这里
That's what comes in here.

105
00:06:33,360 --> 00:06:36,528
而这条流送来的 是一些字典
What comes in here is a stream of dictionaries.

106
00:06:38,510 --> 00:06:41,408
其中一个就可能是
So one particular dictionary might say

107
00:06:46,704 --> 00:06:49,312
Y=PROG
might say y equals programmer.

108
00:06:55,470 --> 00:06:56,640
现在 查询工作就是要
Now, what the query does

109
00:06:57,072 --> 00:06:59,808
当它从这条流中取得一个字典后
when it gets in a dictionary from this stream,

110
00:07:02,010 --> 00:07:06,672
它会搜寻数据库中的东西
it finds all possible ways of matching the query

111
00:07:07,456 --> 00:07:10,240
尽可能产生所有匹配结果
against whatever is coming in from the database.

112
00:07:11,390 --> 00:07:12,896
它把查询视作一种模式
It looks at the query as a pattern,

113
00:07:13,152 --> 00:07:16,720
并将它们与数据库中的事实匹配起来
matches it against any fact from the database

114
00:07:16,960 --> 00:07:21,984
结合着相应的字典中的数据
or all possible ways of finding and matching the database

115
00:07:22,944 --> 00:07:25,680
找到数据库中所有匹配的结果
with respect to this dictionary that's coming in.

116
00:07:27,550 --> 00:07:29,696
所以针对数据库中的每条事实
So for each fact in the database,

117
00:07:29,728 --> 00:07:34,350
它都会调用(MATCH PAT FACT DICTIONAY)来检查
it calls the matcher using the pattern, fact, and dictionary.

118
00:07:35,110 --> 00:07:37,680
如果成功匹配
And every time it gets a good match,

119
00:07:38,192 --> 00:07:39,936
它就输出一个扩展了的字典
it puts out the extended dictionary.

120
00:07:40,672 --> 00:07:42,320
比如说 这里进来了一本字典
So, for example, if this one comes in

121
00:07:43,008 --> 00:07:44,096
并且成功匹配
and it finds a match,

122
00:07:44,512 --> 00:07:45,872
那么就会输出一本字典
out will come a dictionary

123
00:07:46,816 --> 00:07:49,792
本例中就是Y=PROGRAMER
that in this case will have y equals programmer

124
00:07:51,520 --> 00:07:52,970
X=...
nd x equals something.

125
00:07:56,544 --> 00:07:58,752
Y=PROGRAMMER X=...
y is programmer, x is something,

126
00:07:58,960 --> 00:08:00,544
D又是一个新的项
and d is whatever it found.

127
00:08:01,728 --> 00:08:02,272
像这样扩展
And that's all.

128
00:08:03,520 --> 00:08:07,824
当然 它会针对数据库中的所有事实做同样的尝试
And, of course, it's going to try this for every fact in the dictionary.

129
00:08:07,980 --> 00:08:09,250
所以就可能有很多的结果
So it might find lots of them.

130
00:08:09,568 --> 00:08:10,592
可能会产生另一本字典
It might find another one

131
00:08:11,280 --> 00:08:17,120
其中 Y=PROGRAMMER X=... D=...
that says y equals programmer and x equals, and d equals.

132
00:08:19,184 --> 00:08:21,550
因此 对于每个输入的框架
So thats, So for one frame coming in,

133
00:08:21,760 --> 00:08:23,696
对于每输入一本字典
it might put out-- for one dictionary coming in,

134
00:08:23,728 --> 00:08:25,240
它可能输出很多本字典
it might put out a lot of dictionaries,

135
00:08:26,544 --> 00:08:28,672
或者什么也不输出
or it might put out none.

136
00:08:30,470 --> 00:08:38,480
可能会有一些不匹配的情况 比如X=FOO
It might have something that wouldn't match like x equals FOO.

137
00:08:39,024 --> 00:08:40,896
这个条目不会匹配任何东西
This one might not match anything

138
00:08:41,520 --> 00:08:45,120
就这个框架来说 不会向输出流中输出东西
in which case nothing will go into this stream corresponding to this frame.

139
00:08:47,510 --> 00:08:51,280
或者你也可以输入一个空框架
Or what you might do is put in an empty frame,

140
00:08:52,910 --> 00:08:56,240
空框架是用来
and an empty frame says try matching all ways--

141
00:08:59,872 --> 00:09:02,336
在没有任何约束的情况下
find all possible ways of matching the query

142
00:09:02,576 --> 00:09:06,144
匹配数据库中所有可能的结果
against something in the database subject to no previous restrictions.

143
00:09:07,570 --> 00:09:09,168
这仅仅代表着
And if you think about what that means, that's just

144
00:09:10,320 --> 00:09:13,872
处理你输入的查询 最初所进行的计算
the computation that's done when you type in a query right off.

145
00:09:14,208 --> 00:09:15,568
它试图找出所有的匹配
It tries to find all matches.

146
00:09:16,650 --> 00:09:18,832
基本查询建立了这种机制
So a primitive query sets up this mechanism.

147
00:09:19,370 --> 00:09:20,576
而语言要做的是
And what the language does,

148
00:09:22,752 --> 00:09:24,672
当你在顶层输入这条查询时
when you type in the query at the top level,

149
00:09:24,848 --> 00:09:26,144
它基于这种机制
it takes this mechanism,

150
00:09:26,160 --> 00:09:28,352
它会输入一本空的字典
feeds in one single empty dictionary,

151
00:09:30,864 --> 00:09:32,560
而对于输出的每个东西
and then for each thing that comes out

152
00:09:33,088 --> 00:09:35,888
然后把最初的查询
takes the original query

153
00:09:36,560 --> 00:09:40,448
用不用的字典来实例化
and instantiates the result with all the different dictionaries,

154
00:09:40,816 --> 00:09:44,368
于是实例化后的模式就形成了一条新的流
producing a new stream of instantiated patterns here.

155
00:09:44,990 --> 00:09:46,512
这就是在终端上打印出来的内容
And that's what gets printed on the terminal.

156
00:09:48,170 --> 00:09:51,248
这也就是其中的基本原理
That's the basic mechanism going on there.

157
00:09:53,510 --> 00:09:55,488
那么 这又为什么复杂呢？
Well, why is that so complicated?

158
00:09:57,712 --> 00:10:01,008
当让 除了用这种遍布四处的基于流的方法
You probably can think of a lot simpler ways to arrange this match for

159
00:10:01,376 --> 00:10:04,256
你们可以想出很多更简单的方法来组织基本查询
a primitive query rather than having all of these streams floating around.

160
00:10:05,184 --> 00:10:06,096
而答案就在于
And the answer is--

161
00:10:07,152 --> 00:10:08,512
你们可能已经在想了
you probably guess already.

162
00:10:10,860 --> 00:10:14,096
答案就是 这种方法能够优雅地
The answer is this thing extends elegantly

163
00:10:14,560 --> 00:10:16,768
实现组合的方法
to implement the means of combination.

164
00:10:17,790 --> 00:10:18,800
比如说
So, for instance,

165
00:10:20,656 --> 00:10:22,470
假设我还想实现其它的效果
suppose I don't only want to do this.

166
00:10:22,470 --> 00:10:26,960
我不只是想查询所有人的工作信心
I don't want to say who to be everybody's job description.

167
00:10:27,230 --> 00:10:28,352
假设我还想查询
Suppose I want to say

168
00:10:29,472 --> 00:10:35,920
(AND (JOB ?X (?D . ?Y))
to say AND the job of x is d dot y

169
00:10:36,800 --> 00:10:47,040
(SUPERVIOSR ?X ?Z))
and the supervisor of x is z.

170
00:10:48,800 --> 00:10:50,672
(SUPERVISOR ?X ?Z)这条查询
Now, supervisor of x is z

171
00:10:51,392 --> 00:10:52,960
是另外的一条基本查询
is going to be another primitive query

172
00:10:53,712 --> 00:10:58,432
它也有类似的形状——接收一条数据对象流
that has the same shape to take in a stream of data objects,

173
00:10:59,184 --> 00:11:01,648
一条初始字典流
a stream of initial dictionaries,

174
00:11:01,680 --> 00:11:05,520
字典是你在进行匹配时 需要遵循的约束
which are the restrictions to try and use when you match,

175
00:11:05,536 --> 00:11:07,440
然后它会输出一条字典流
and it's going to put out a stream of dictionaries.

176
00:11:08,700 --> 00:11:10,800
这就是这条基本查询的形状
So that's what this primitive query looks like.

177
00:11:11,504 --> 00:11:12,910
我又该如何实现AND呢？
And how do I implement the AND?

178
00:11:12,910 --> 00:11:13,450
其实很简单
Well, it's simple.

179
00:11:13,450 --> 00:11:14,448
把它们连接起来就好了
I just hook them together.

180
00:11:14,880 --> 00:11:16,288
我把这条查询的输出
I take the output of this one,

181
00:11:16,960 --> 00:11:18,816
连接在这条查询的输入上
and I put that to the input of that one.

182
00:11:19,830 --> 00:11:21,840
然后把这里的字典扇出开来
And I take the dictionary here and I fan it out.

183
00:11:26,570 --> 00:11:27,968
你们就能发现它是如何工作的了
And then you see how that's going to work,

184
00:11:29,050 --> 00:11:32,448
这里会输出一个框架
because what's going to happen is a frame will now come in here,

185
00:11:32,512 --> 00:11:36,848
其中有X、Y和D的绑定
which has a binding for x, y, and d.

186
00:11:37,920 --> 00:11:39,280
当后面的查询接收到结果后
And then when this one gets it, it'll say,

187
00:11:39,296 --> 00:11:41,600
当它了解了这些约束后
oh, gee, subject to these restrictions,

188
00:11:42,176 --> 00:11:49,248
字典中的是Y、X和D的值
which now already have values in the dictionary for y and x and d,

189
00:11:51,808 --> 00:11:53,088
它会搜寻数据库
it looks in the database and says,

190
00:11:53,120 --> 00:11:54,928
试图找到有关SUPERVISOR关系的事实
gee, can I find any supervisor facts?

191
00:11:56,048 --> 00:11:58,510
如果找到了的话 它就会输出一些词典
And if it finds any, out will come dictionaries

192
00:11:59,584 --> 00:12:09,340
其中有Y、X、D以及Z的绑定
which have bindings for y and x and d and z now.

193
00:12:12,070 --> 00:12:14,096
不过要注意
And then notice that the match---

194
00:12:14,192 --> 00:12:17,248
因为这里输入的框架建立了约束
because the frames coming in here have these restrictions,

195
00:12:17,610 --> 00:12:20,288
它保证了当你执行AND运算时
that's the thing that assures when you do the AND,

196
00:12:20,496 --> 00:12:24,624
这两个X是相同的
this x will mean the same thing as that x.

197
00:12:26,470 --> 00:12:28,960
这是因为通过这条流输出时
Because by the time something comes floating in here,

198
00:12:29,968 --> 00:12:32,656
X已经有值了 你要确保匹配的一致性
x has a value that you have to match against consistently.

199
00:12:34,460 --> 00:12:36,176
然后我们想起在MATCH的代码中
And then you remember from the code from the matcher,

200
00:12:36,190 --> 00:12:38,176
有一种操作字典的特殊组织方法
there was something in the way the matcher did dictionaries

201
00:12:38,208 --> 00:12:39,820
确保了匹配的一致性
that arrange consistent matches.

202
00:12:40,928 --> 00:12:41,776
这就是AND的实现
So there's AND.

203
00:12:44,080 --> 00:12:46,944
关键是要注意它的一般性形状
The important point to notice is the general shape.

204
00:12:48,496 --> 00:12:51,550
我们来看看(AND P Q)
Look at what happened: the AND of two queries, say, P and Q.

205
00:12:52,880 --> 00:12:55,616
这里是P和Q
Here's P and Q.

206
00:12:57,296 --> 00:12:58,608
两条查询的AND
The AND of two queries,

207
00:13:00,272 --> 00:13:01,190
看起来像是这样
well, it looks like this.

208
00:13:01,190 --> 00:13:04,448
每一条查询都通过一条流连接数据库
Each query takes in a stream from the database,

209
00:13:04,544 --> 00:13:05,712
一条输入流
a stream of inputs,

210
00:13:06,336 --> 00:13:08,176
并输出一条输出流
and puts out a stream of outputs.

211
00:13:10,230 --> 00:13:11,728
关键是要注意
And the important point to notice

212
00:13:12,208 --> 00:13:15,024
如果我在它们周围画一个盒子
is that if I draw a box around this thing

213
00:13:19,264 --> 00:13:23,648
这就是(AND P Q)
and say this is AND of P and Q,

214
00:13:25,664 --> 00:13:30,384
那么这个盒子也有同样的形状
then that box has exactly the same overall shape.

215
00:13:32,048 --> 00:13:34,200
它也有一条连接数据库的流
It's something that takes in a stream from the database.

216
00:13:34,200 --> 00:13:35,744
但是在内部会扇出开来
Here it's going to get fanned out inside,

217
00:13:36,608 --> 00:13:37,936
但是在外部你看不到
but from the outside you don't see that.

218
00:13:38,160 --> 00:13:40,640
它接收一个流 并输出一个流
It takes an input stream and puts out an output stream.

219
00:13:42,064 --> 00:13:43,168
这就是AND
So this is AND.

220
00:13:43,570 --> 00:13:45,728
类似地 OR可能看起像这样
And then similarly, OR would look like this.

221
00:13:46,020 --> 00:13:49,584
虽然我没给你们演示过OR的用法
OR would-- although I didn't show you examples of OR.

222
00:13:49,840 --> 00:13:54,704
OR会尝试找出P或Q所有匹配的事实
OR would say can I find all ways of matching P or Q.

223
00:13:55,808 --> 00:13:58,070
P、Q两条查询都有各自的形状
So I have P and Q. Each will have their shape.

224
00:14:04,460 --> 00:14:06,688
OR的实现则是
And the way OR is implemented is

225
00:14:08,544 --> 00:14:10,912
我把来自于数据库的流
I'll take my database stream.

226
00:14:12,500 --> 00:14:13,490
扇出开来
I'll fan it out.

227
00:14:13,490 --> 00:14:16,048
把它们分别送给P和Q
I'll put one into P and one into Q.

228
00:14:17,440 --> 00:14:21,980
我把最初的查询流也给扇出开来
I'll take my initial query stream coming in and fan it out.

229
00:14:26,750 --> 00:14:29,168
这样我不但能够得到P的所有结果
So I'll look at all the answers I might get from P

230
00:14:29,296 --> 00:14:31,088
也能得到Q的所有结果
and all the answers I might get from Q,

231
00:14:31,616 --> 00:14:34,560
把这些输出送入某种“附加器”中
and I'll put them through some sort of thing that appends them

232
00:14:34,624 --> 00:14:37,488
或者把它们“合并”到一条流中
or merges the result into one stream,

233
00:14:39,648 --> 00:14:40,880
然后得到输出
and that's what will come out.

234
00:14:41,080 --> 00:14:48,240
而从外部来看 这整个东西就是OR
And this whole thing from the outside is OR.

235
00:14:52,350 --> 00:14:54,896
同样的 当你们从外部观察它时
And again, you see it has the same overall shape

236
00:14:55,072 --> 00:14:56,544
你会发现它具有相同的形状
And again, you see it has the same overall shape

237
00:15:01,000 --> 00:15:01,616
NOT又如何实现呢？
What's NOT?

238
00:15:02,020 --> 00:15:03,456
NOT的原理有些类似
NOT works kind of the same way.

239
00:15:04,310 --> 00:15:05,952
如果我有一条查询P
If I have some query P,

240
00:15:06,864 --> 00:15:13,504
这是一条基本查询P
If I have P, I take the primitive query for P.

241
00:15:14,690 --> 00:15:16,320
现在我要实现(NOT P)
Here, I'm going to implement NOT P.

242
00:15:18,688 --> 00:15:20,544
NOT的作用像是一个过滤器
And NOT's just going to act as a filter.

243
00:15:20,720 --> 00:15:21,952
这里连接数据库
I'll take in the database

244
00:15:23,840 --> 00:15:28,288
这里是输入的字典流
and my original stream of dictionaries coming in,

245
00:15:28,780 --> 00:15:31,536
(NOT P)要做的就是
and what NOT P will do is

246
00:15:31,888 --> 00:15:37,400
对这些东西做过滤
it will filter these guys.

247
00:15:39,020 --> 00:15:40,096
过滤的方法则是
And the way it will filter it,

248
00:15:40,192 --> 00:15:42,704
如果我在这里获得了一本字典
it will say when I get in a dictionary here,

249
00:15:43,424 --> 00:15:44,656
那么我就去找所有的匹配
I'll find all the matches,

250
00:15:44,832 --> 00:15:46,480
然后丢弃找到的结果
and if I find any, I'll throw it away.

251
00:15:47,460 --> 00:15:49,936
如果我没有在这里找到匹配
And if I don't find any matches to something coming in here,

252
00:15:50,128 --> 00:15:51,376
我就把它传递过去
I'll just pass that through,

253
00:15:52,400 --> 00:15:53,552
NOT就是一个纯粹的过滤器
so NOT is a pure filter.

254
00:15:55,344 --> 00:15:59,980
因此AND就类似于一个电阻
So AND is-- think of these sort of electoral resistors or something.

255
00:15:59,980 --> 00:16:01,856
AND是串行的组合
AND is series combination

256
00:16:02,496 --> 00:16:04,140
OR是并行组合
and OR is parallel combination.

257
00:16:04,960 --> 00:16:07,460
然而NOT并不会对字典做任何扩展
And then NOT is not going to extend any dictionaries at all.

258
00:16:07,460 --> 00:16:08,400
它只会做过滤
It's just going to filter it.

259
00:16:08,750 --> 00:16:11,792
它会丢弃那些能够匹配的结果
It's going to throw away the ones for which it finds a way to match.

260
00:16:12,640 --> 00:16:14,192
LISP-VALUE的原理类似
And lisp-value is sort of the same way.

261
00:16:14,848 --> 00:16:16,600
它的过滤器会复杂点
The filter's a little more complicated.

262
00:16:16,600 --> 00:16:17,376
因为要应用到谓词上
It applies to predicate.

263
00:16:19,936 --> 00:16:21,648
这里需要注意的关键点是
The major point to notice here,

264
00:16:21,920 --> 00:16:23,552
我们之前也强调过了
and it's a major point we've looked at before,

265
00:16:23,648 --> 00:16:25,296
就是关于“闭包性质”的思想
is this idea of closure.

266
00:16:28,220 --> 00:16:31,808
我们通过组合手段构建的东西
The things that we build as a means of combination

267
00:16:31,952 --> 00:16:34,512
跟所使用的基本物件
have the same overall structure

268
00:16:35,696 --> 00:16:37,584
有同样的结构
as the primitive things that we're combining.

269
00:16:39,750 --> 00:16:41,680
所以从外面看
So the AND of two things

270
00:16:41,712 --> 00:16:43,720
查询的AND与基本查询结构相同
looked at from the outside has the same shape.

271
00:16:44,630 --> 00:16:46,144
这就意味着
And what that means is that

272
00:16:46,940 --> 00:16:50,288
这里的盒子可以是AND、OR、NOT或者其它的
this box here could be an AND or an OR or a NOT or something

273
00:16:50,304 --> 00:16:54,220
因为它具有相同的形状来连接更大的东西
because it has the same shape to interface to the larger things.

274
00:16:54,950 --> 00:16:56,688
这种思想能够让我们获得
It's the same thing that allowed us to get

275
00:16:56,928 --> 00:16:58,960
Escher绘图语言中的那种复杂度
complexity in the Escher picture language

276
00:16:59,550 --> 00:17:01,312
让你能够仅仅使用序对
or allows you to immediately build up these

277
00:17:01,344 --> 00:17:03,260
构建出这些复杂结构
complicated structures just out of pairs.

278
00:17:03,936 --> 00:17:04,784
这就是“闭包性质”
It's closure.

279
00:17:06,280 --> 00:17:08,064
这种性质
And that's the thing that

280
00:17:09,648 --> 00:17:11,728
能够让我完成你们现在觉得理所当然的事儿
allowed me to do what by now you took for granted

281
00:17:11,760 --> 00:17:14,912
比如我可以查询(AND JOB SALARY)
I said, gee, there's a query which is AND of job and salary,

282
00:17:14,912 --> 00:17:18,800
当然我也可以查询(AND JOB (NOT ...))等等
and I said, oh, there's another one, which is AND of job, a NOT of something.

283
00:17:19,260 --> 00:17:20,928
这种便利是由
The fact that I can do that is

284
00:17:20,944 --> 00:17:22,910
这种“闭包原则”直接带给我们的
a direct consequence of this closure principle.

285
00:17:25,184 --> 00:17:27,080
好吧 提问时间
OK, let's break and then we'll go on.

286
00:17:29,328 --> 00:17:30,896
学生：字典是从哪里来的？
AUDIENCE: Where does the dictionary come from?

287
00:17:30,990 --> 00:17:36,032
教授：字典最初来自于你的输入
PROFESSOR: The dictionary comes initially from what you type in.

288
00:17:36,096 --> 00:17:37,328
因此当你最初进行查询时
So when you start this up,

289
00:17:39,168 --> 00:17:41,090
它首先会建立起这整个结构
the first thing it does is set up this whole structure.

290
00:17:41,090 --> 00:17:42,640
它先输入一个空字典
It puts in one empty dictionary.

291
00:17:45,000 --> 00:17:47,248
如果你只有一条基本查询的话
And if all you have is one primitive query,

292
00:17:48,240 --> 00:17:51,104
那么它就会输出一系列具有内容的字典
then what will come out is a bunch of dictionaries with things filled in.

293
00:17:52,310 --> 00:17:54,336
这里演示的一般性情况是
The general situation that I have here

294
00:17:54,512 --> 00:17:59,710
某个嵌套组合查询的中间过程
is when this is in the middle of some nest of combined things.

295
00:18:01,552 --> 00:18:02,304
所以在那时
So by the time.

296
00:18:02,380 --> 00:18:03,790
让我们来看看这里
Let's look at the picture over here.

297
00:18:04,384 --> 00:18:06,730
这条SUPERVISOR查询得到了某本字典
This supervisor query gets in some dictionary.

298
00:18:06,730 --> 00:18:08,032
这本字典来自于哪里呢？
Where did this one come from?

299
00:18:08,730 --> 00:18:11,152
它来自于
This dictionary came from the fact that

300
00:18:12,848 --> 00:18:14,896
这条基本查询的输出
I'm looking at the output of this primitive query.

301
00:18:16,260 --> 00:18:17,888
说得更具体一点
So maybe to be very specific,

302
00:18:18,352 --> 00:18:21,728
如果我最初在顶层只输入了这条查询
if I literally typed in just this query at the top level,

303
00:18:22,272 --> 00:18:22,928
这整条AND查询
this AND,

304
00:18:23,072 --> 00:18:25,280
它实际上会构建这种结构
what would actually happen is it would build this structure

305
00:18:25,500 --> 00:18:30,240
并使用一本空字典来启动整个过程
and start up this whole thing with one empty dictionary.

306
00:18:31,770 --> 00:18:34,336
处理过程开始后 会产生一系列的字典
And now this one would process, and a whole bunch of dictionaries

307
00:18:34,368 --> 00:18:37,360
其中就有X、Y以及D
would come out with x, y's and d's in them.

308
00:18:38,640 --> 00:18:39,584
向这边传递
Run it through this one.

309
00:18:40,190 --> 00:18:42,160
这就是这条查询的输入
So now that's the input to this one.

310
00:18:42,160 --> 00:18:43,728
这条查询也会生成其它的东西
This one would now put out some other stuff.

311
00:18:45,040 --> 00:18:48,224
如果这整个查询是构建在一个更大的查询中的话
And if this itself were buried in some larger thing,

312
00:18:49,312 --> 00:18:51,008
比如说一条OR查询
like an OR of something,

313
00:18:53,424 --> 00:18:55,712
那么它将输出到下一个查询中
then that would go feed into the next one.

314
00:18:58,560 --> 00:19:01,280
因此最初开始处理时 只有一本空字典
So you initially get only one empty dictionary when you start it,

315
00:19:01,680 --> 00:19:04,080
但是在处理这些复合查询的过程中
but as you're in the middle of processing these compounds things,

316
00:19:04,112 --> 00:19:06,656
会生成各种不同的字典
that's where these cascades of dictionaries start getting generated.

317
00:19:07,660 --> 00:19:12,280
学生：字典都是查询的结果吗？
AUDIENCE: Dictionaries only come about as a result of using the queries?

318
00:19:15,120 --> 00:19:17,696
它们会变成
Or do they stays, do they become--

319
00:19:18,848 --> 00:19:22,816
它们存储在数据库中吗？
do they stay someplace in space like the database does?

320
00:19:23,680 --> 00:19:24,980
它们是临时数据吗？
Are these temporary items?

321
00:19:24,980 --> 00:19:27,184
它们是在匹配过程中临时创建的
PROFESSOR: They're created temporarily in the matcher.

322
00:19:28,030 --> 00:19:29,880
但它们实际存放在内存中
Really, they're someplace in storage.

323
00:19:29,880 --> 00:19:33,024
最初 某人创建了一本THE-EMPTY-DICT字典
Initially, someone creates a thing called the empty dictionary

324
00:19:34,224 --> 00:19:36,800
送入这个匹配过程
that gets initially fed to this match procedure,

325
00:19:36,810 --> 00:19:39,056
MATCH过程据此构建新字典
and then the match procedure builds some dictionaries,

326
00:19:39,070 --> 00:19:40,272
并把它们传递下去
and they get passed on and on.

327
00:19:40,768 --> 00:19:42,480
学生：因此匹配完成后它们就被丢弃了？
AUDIENCE: OK, so they'll go way after the match?

328
00:19:43,640 --> 00:19:46,256
教授：实际上 当没人需要它们后就被废料回收了
PROFESSOR: They'll go away when no one needs them again, yeah.

329
00:19:51,900 --> 00:19:55,376
学生：似乎AND查询对数据库进行了冗余操作
AUDIENCE: It appears that the AND performs some redundant searches of the database.

330
00:19:55,960 --> 00:19:57,488
如果第一条子句扫描过了
If the first clause matched,

331
00:19:57,504 --> 00:19:59,900
比如说前两个元素没有匹配 而第三个元素匹配了
let's say, the third element and not on the first two elements,

332
00:20:00,256 --> 00:20:03,648
然而第二条子句又会检查这两个元素
the second clause is going to look at those first two elements again,

333
00:20:04,320 --> 00:20:06,592
然后又一次丢弃这些不匹配的元素
discarding them because they don't match.

334
00:20:06,640 --> 00:20:08,720
而字典中已经有匹配的项了
The match is already in the dictionary.

335
00:20:10,000 --> 00:20:12,560
如果我们把数据库中的数据
Would it makes sense to carry the data element

336
00:20:12,576 --> 00:20:14,432
也放到字典中 这样可行么？
from the database along with the dictionary?

337
00:20:15,690 --> 00:20:17,600
教授：实际上 通常来说
PROFESSOR: Yeah, there're... Well, in general,

338
00:20:17,632 --> 00:20:19,480
我们能够以其它方式来安排这些搜索
there are other ways to arrange this search,

339
00:20:20,128 --> 00:20:21,740
你也可以做一些分析
and there's some analysis that you can do.

340
00:20:21,740 --> 00:20:23,168
我记得书里面就有这样的习题
I think there's a problem in the book,

341
00:20:23,872 --> 00:20:26,656
是考察通过安排AND子句的顺序
which talks about a different way that you can cascade AND

342
00:20:27,008 --> 00:20:29,200
来消除不同类型的冗余
to eliminate various kinds of redundancies.

343
00:20:29,850 --> 00:20:30,720
而这里只是为了
This one is meant to be--

344
00:20:31,328 --> 00:20:34,544
用非常简单的情况来向你们展示它们是如何配合的
was mainly meant to be very simple so you can see how they fit together.

345
00:20:34,704 --> 00:20:35,380
但是你说得非常对
But you're quite right.

346
00:20:35,380 --> 00:20:37,328
这些冗余是可以避免的
There are redundancies here that you can get rid of.

347
00:20:38,370 --> 00:20:40,800
这也是这门语言缓慢的原因之一
That's another reason why this language is somewhat slow.

348
00:20:41,190 --> 00:20:42,704
你们可以让它变得更聪明
There are a lot smarter things you can do.

349
00:20:42,930 --> 00:20:46,224
我只是为了向你们演示非常简单的、原理性的实现
We're just trying to show you a very simple, in principle, implementation.

350
00:20:51,220 --> 00:20:53,232
学生：您是根据Prolog来建模这门语言的
AUDIENCE: Did you model this language on Prolog,

351
00:20:53,248 --> 00:20:55,136
还是说它只是偶然地像Prolog？
or did it just come out looking like Prolog?

352
00:21:04,960 --> 00:21:07,088
教授：Gerry教授昨天羞辱了一大堆人
PROFESSOR: Well, Gerry insulted a whole bunch of people yesterday,

353
00:21:07,248 --> 00:21:09,920
我想说真实的情况是
so I might as well say that the MIT attitude towards Prolog is

354
00:21:10,190 --> 00:21:12,608
MIT的研究人员在1971年做了类似的事
is something that people did in about 1971

355
00:21:12,640 --> 00:21:15,600
但是发现这个方向并不正确 并停止了研究
and decided that it wasn't really the right thing and stopped.

356
00:21:16,120 --> 00:21:22,800
因此我们是根据查询处理的基本原理建模的
So we modeled this on the sort of natural way that this thing was done

357
00:21:22,848 --> 00:21:24,730
大概在1971年左右
in about 1971,

358
00:21:25,136 --> 00:21:27,248
只是说 那时候我们还没有用流来实现
except at that point, we didn't do it with streams.

359
00:21:28,272 --> 00:21:33,040
然后我们 -- 但我们使用了它差不多六个月后
And then we... After we were using it for about six months,

360
00:21:33,080 --> 00:21:34,912
发现它存在各种各样的问题
we discovered that it had all these problems,

361
00:21:34,944 --> 00:21:36,300
稍后我会解释
some of which I'll talk about later.

362
00:21:37,330 --> 00:21:38,192
然后我们就想
And we said,

363
00:21:38,448 --> 00:21:39,920
Prolog一定解决了这些问题
gee, Prolog must have fixed those,

364
00:21:39,930 --> 00:21:41,216
但却发现它并没有
and then we found out that it didn't.

365
00:21:41,250 --> 00:21:43,024
从这种意义上来说 它确实跟Prolog一样
So this does about the same thing as Prolog.

366
00:21:43,600 --> 00:21:44,950
学生：Prolog基于流么？
AUDIENCE: Does Prolog use streams?

367
00:21:44,950 --> 00:21:46,200
教授：不 Prolog基于的是
PROFESSOR: No. Prolog --

368
00:21:46,784 --> 00:21:51,040
就行为上来说 我们的语言很像Prolog
In how it behaves, it behaves a lot like Prolog.

369
00:21:51,040 --> 00:21:52,960
Prolog使用回溯策略
Prolog uses a backtracking strategy.

370
00:21:53,800 --> 00:21:55,712
但是Prolog有一个优点非常好
But the other thing that's really good about Prolog

371
00:21:55,728 --> 00:21:57,984
也使得它变得实用
that makes it a usable thing

372
00:21:58,280 --> 00:22:01,504
你知道吗
is that there's a really very, very

373
00:22:01,680 --> 00:22:04,090
它们精心设计了Prolog的编译器
there's a really very, very well-engineered compiler technology

374
00:22:04,112 --> 00:22:05,328
使得它能够高速运行
that makes it run fast.

375
00:22:06,656 --> 00:22:10,816
因此 虽然我们这门语言非常缓慢地输出答案
So although you saw the merge spitting out these answers very, very slowly,

376
00:22:11,664 --> 00:22:13,616
真正的Prolog程序却运行得非常快
a real Prolog will run very, very fast.

377
00:22:14,704 --> 00:22:16,480
这是因为 尽管搜索过程十分低效
Because even though it's sort of doing this,

378
00:22:16,670 --> 00:22:20,816
Prolog卓越的编译器也会高校地完成工作
the real work that went into Prolog is a very, very excellent compiler effort.

379
00:22:24,304 --> 00:22:25,216
休息一下吧
Let's take a break.

380
00:23:16,650 --> 00:23:18,832
我们已经考察过了基本查询
We've looked at the primitive queries

381
00:23:19,216 --> 00:23:23,520
以及如何使用流来实现组合的手段
and the ways that streams are used to implement the means of combination:

382
00:23:23,792 --> 00:23:25,728
AND、OR以及NOT
AND and OR and NOT.

383
00:23:26,950 --> 00:23:28,432
现在 该讨论抽象的手段了
Now, let go on to the means of abstraction.

384
00:23:29,580 --> 00:23:32,800
回想一下 我们这门语言的抽象手段是RULE
Remember, the means of abstraction in this language are rules.

385
00:23:35,150 --> 00:23:37,792
(BOSS ?Z ?D)描述的是
So z is a boss in division d

386
00:23:39,184 --> 00:23:43,776
如果某人在D部门工作
if there's some x who has a job in division d

387
00:23:45,680 --> 00:23:47,472
并且Z是X的上司
and z is the supervisor of x.

388
00:23:48,900 --> 00:23:50,608
这就是所谓的“BOSS”
That's what it means for someone to be a boss.

389
00:23:52,260 --> 00:23:53,152
并且 实际上
So, and in effect,

390
00:23:53,344 --> 00:23:55,616
如果我们考察一下编写的规则与这边的关系
if you think about what we're doing with relation to this,

391
00:23:56,800 --> 00:23:57,904
这是我们编写的查询
there's the query we wrote--

392
00:23:57,936 --> 00:24:01,900
这个是(JOB ?X ?D) 而这个是(SUPERVISOR ?X ?Z)
the job of x is in d and the supervisor of x is z--

393
00:24:02,192 --> 00:24:04,288
我们实际想要把这一大堆东西
what we in effect want to do is take this whole mess

394
00:24:05,072 --> 00:24:06,576
用一个盒子封装起来
and draw a box around it

395
00:24:19,080 --> 00:24:24,544
然后把这个盒子里的所有东西
and say this whole thing inside the box

396
00:24:25,152 --> 00:24:32,480
认为是(BOSS ?Z ?D)
is boss of z in division d.

397
00:24:33,900 --> 00:24:35,250
这是我们想要达到的效果
That's in effect what we want to do.

398
00:24:38,720 --> 00:24:39,728
因此 比如说
So, for instance,

399
00:24:43,184 --> 00:24:44,080
我们这样做了过后
if we've done that,

400
00:24:45,008 --> 00:24:47,840
我们想要检查
and we want to check whether or not it's true

401
00:24:47,952 --> 00:24:50,512
Ben Bitdiddle是否为计算机分部的BOSS
that Ben Bitdiddle is a boss in the computer division,

402
00:24:51,104 --> 00:25:02,864
如果我想查询 (BOSS (BITDIDDLE BEN) COMPUTER)
so if I want to say boss of Ben Bitdiddle in the computer division,

403
00:25:04,784 --> 00:25:07,088
想象一下把这条查询输入系统
imagine typing that in as query to the system,

404
00:25:07,120 --> 00:25:09,168
实际上发生的是
in effect what we want to do

405
00:25:10,672 --> 00:25:12,928
在这里先构建一本字典
is set up a dictionary here,

406
00:25:15,820 --> 00:25:23,632
其中 Z=BITDIDDLE
which has z to Ben Bitdiddle

407
00:25:28,880 --> 00:25:33,310
D=COMPUTER
and d to computer.

408
00:25:37,088 --> 00:25:38,624
这个字典又是来自于哪里呢？
Where did that dictionary come from?

409
00:25:38,688 --> 00:25:40,710
我们来看下幻灯片
Let's look at the slide for one second.

410
00:25:40,710 --> 00:25:43,712
这本字典是通过把
That dictionary came from matching the query

411
00:25:44,304 --> 00:25:46,336
查询(BOSS (BITDIDDLE BEN) COMPUTER)
that said boss of Ben Bitdiddle and computer

412
00:25:46,512 --> 00:25:49,632
与规则的结论(BOSS ?Z ?D)相匹配得到
onto the conclusion of the rule: boss of z and d.

413
00:25:51,650 --> 00:25:54,112
所以我们把规则的结论和查询匹配了起来
So we match the query to the conclusion of the rule.

414
00:25:54,190 --> 00:25:55,536
这样我们就获得了一本字典
That gives us a dictionary,

415
00:25:58,992 --> 00:26:02,544
现在我们就要把这本字典输入到这整个结构中
and that's the thing that we would now like to put into this whole big thing

416
00:26:02,928 --> 00:26:05,568
进行处理 并观察是否有输出
and process and see if anything comes out the other side.

417
00:26:06,670 --> 00:26:09,888
如果输出了结果 那么查询就为真
If anything comes out, it'll be true.

418
00:26:11,330 --> 00:26:12,370
这是基本的思想
That's the basic idea.

419
00:26:12,370 --> 00:26:13,248
因此 通常来说
So in general,

420
00:26:14,032 --> 00:26:15,408
我们实现规则的方法就是
the way we implement a rule

421
00:26:15,856 --> 00:26:18,896
用规则的结论去匹配
is we match the conclusion of the rule

422
00:26:20,864 --> 00:26:22,960
假设为真的查询
against something we might want to check it's true.

423
00:26:23,580 --> 00:26:25,120
这个过程会产生一本字典
That match gives us a dictionary,

424
00:26:25,296 --> 00:26:28,224
在有了相关字典后
and with respect to that dictionary,

425
00:26:30,352 --> 00:26:34,512
我们来处理规则的体
we process the body of the rule.

426
00:26:36,336 --> 00:26:37,680
基本上就是这样了
Well, that's really all there is,

427
00:26:38,640 --> 00:26:41,440
但还有两个技术点
except for two technical points.

428
00:26:43,040 --> 00:26:44,320
首先就是
The first technical point is that

429
00:26:45,744 --> 00:26:47,264
我也可能有其它的问法
I might have said something else.

430
00:26:47,510 --> 00:26:48,416
比如说
I might have said

431
00:26:50,544 --> 00:26:52,368
查询计算机分部的BOSS
who's the boss in the computer division?

432
00:26:52,544 --> 00:26:56,320
就可以查询 (BOSS ?WHO COMPUTER)
So I might say boss of who in computer division.

433
00:27:00,784 --> 00:27:01,632
这样做了以后
And if I did that,

434
00:27:02,576 --> 00:27:04,624
我真正想要做的
what I would really like to do in effect is not

435
00:27:05,040 --> 00:27:06,496
就是先建立一本字典
is start up this dictionary

436
00:27:08,352 --> 00:27:09,888
其中有一些约束
with a match that sort of says,

437
00:27:09,936 --> 00:27:11,200
比如 D=COMPUTER
well, d is computer

438
00:27:14,352 --> 00:27:18,480
而?Z是任意值
and z is whatever who is.

439
00:27:21,700 --> 00:27:23,220
我们的匹配器不会那么做
And our matcher won't quite do that.

440
00:27:23,220 --> 00:27:27,008
这不是模式和数据的匹配方式
That's not quite matching a pattern against data.

441
00:27:28,580 --> 00:27:29,728
这是在匹配两个模式
It's matching two patterns

442
00:27:29,744 --> 00:27:31,584
并判断它们是否一致
sort of saying are they consistent or not

443
00:27:31,904 --> 00:27:33,480
又是什么使它们不一致
or what ways make them consistent.

444
00:27:33,480 --> 00:27:36,432
换句话说 我们需要的不是一个模式匹配器
In other words, what we need is not quite a pattern matcher,

445
00:27:36,960 --> 00:27:38,912
而是一种更一般性的东西
but something a little bit more general

446
00:27:39,136 --> 00:27:40,112
就是“合一”算法
called a unifier.

447
00:27:44,420 --> 00:27:48,064
“合一”是更为一般化的模式匹配算法
And a unifier is a slight generalization of a pattern matcher.

448
00:27:49,530 --> 00:27:52,176
合一算法接收两条模式
What a unifier does is take two patterns

449
00:27:53,232 --> 00:27:57,536
它考虑的是：可以找到哪些一般性的元素
and say what's the most general thing you can substitute

450
00:27:58,208 --> 00:28:00,016
用来代换模式中的变量
for the variables in those two patterns

451
00:28:02,688 --> 00:28:05,088
使得它俩能够同时满足
to make them satisfy the pattern simultaneously?

452
00:28:05,680 --> 00:28:06,608
让我来举个例子
Let me give you an example.

453
00:28:08,864 --> 00:28:14,490
我有一个含有两个元素的模式：(?X ?X)
If I have the pattern two-element list, which is x and x,

454
00:28:15,760 --> 00:28:17,152
它描述的是一个二元表
so this is I have a two-element list

455
00:28:17,320 --> 00:28:18,640
不管元素具体是什么
where both elements are the same

456
00:28:18,672 --> 00:28:20,040
但两个元素是相同的
and otherwise I don't care what they are,

457
00:28:20,400 --> 00:28:22,832
我把它与另一个模式进行“合一”
and I unify that against the pattern

458
00:28:22,920 --> 00:28:24,624
后者描述的是一个二元表
that says there's a two-element list,

459
00:28:24,656 --> 00:28:27,616
首元素一张由'A、任意值、C构成的表
and the first one is a and something and c

460
00:28:28,000 --> 00:28:30,144
而第二个元素是由'A、'B、任意值构成的表
and the second one is a and b and z,

461
00:28:33,070 --> 00:28:34,880
那么 合一算法能够告诉我
then what the unifier should tell me is,

462
00:28:34,896 --> 00:28:36,176
在生成的字典中
oh yeah, in that dictionary,

463
00:28:36,352 --> 00:28:37,968
?X必须是(A B C)
x has to be a, b, c,

464
00:28:39,344 --> 00:28:41,920
?Y必须为B ?Z必须为C
and y has to be d and z has to be c.

465
00:28:43,440 --> 00:28:46,288
这些是我必须对X、Y以及Z施加的约束
Those are the restrictions I'd have to put on the values of x, y, and z

466
00:28:46,336 --> 00:28:47,580
以便让两个模式合一
to make these two unify,

467
00:28:48,120 --> 00:28:50,848
或者换句话来说 让它匹配这个?X
or in other words, to make this match x

468
00:28:51,152 --> 00:28:53,370
让它匹配这个?X
and make this match x.

469
00:28:55,280 --> 00:28:57,760
合一算法需要能够推断出这些
The unifier should be able to deduce that.

470
00:28:58,540 --> 00:29:01,080
但是合一算法也会遇到复杂的情况
But the unifier may-- there are more complicated things.

471
00:29:01,080 --> 00:29:03,072
我可能会询问一些复杂的查询
I might have said something a little bit more complicated.

472
00:29:03,488 --> 00:29:05,744
比如这是一个二元表
I might have said there's a list with two elements,

473
00:29:07,008 --> 00:29:08,288
其中的元素都是相同的
and they're both the same,

474
00:29:08,864 --> 00:29:11,152
它要与这个模式进行合一
and they should unify against something of this form.

475
00:29:12,650 --> 00:29:15,360
合一算法也要能够从中推断出
And the unifier should be able to deduce from that.

476
00:29:16,890 --> 00:29:19,570
?Y必须为B
Like that y would have to be b. y would have to be b.

477
00:29:19,570 --> 00:29:22,128
因为这两个是一样的
Because these two are the same,

478
00:29:22,224 --> 00:29:23,520
因此?Y就是B
so y's got to be b.

479
00:29:24,340 --> 00:29:27,536
这里 ?V应该为A
And v here would have to be a.

480
00:29:28,940 --> 00:29:30,992
只要?Z和?W取值相同
And z and w can be anything,

481
00:29:31,008 --> 00:29:32,432
它们就可以是任意值
but they have to be the same thing.

482
00:29:35,710 --> 00:29:41,760
?X就应该是(B A ?W) 其中?W为任意值
And x would have to be b, followed by a, followed by whatever w

483
00:29:42,832 --> 00:29:44,680
或者是?Z -- 因为?Z和?W是一致的
or whatever z is, which is the same.

484
00:29:44,704 --> 00:29:49,420
发现了么？ 合一算法需要从这些模式中推断出信息
So you see, the unifier somehow has to deduce things to unify these patterns.

485
00:29:50,880 --> 00:29:53,520
所以你们可能认为 这其中有某种魔法般的推理
So you might think there's some kind of magic deduction going on,

486
00:29:54,272 --> 00:29:55,232
但其实并不是
but there's not.

487
00:29:55,850 --> 00:29:59,888
合一算法基本上只是对模式匹配的小小修改
A unifier is basically a very simple modification of a pattern matcher.

488
00:30:00,150 --> 00:30:01,856
如果你们翻阅教材 就会发现
And if you look in the book, you'll see something like

489
00:30:02,256 --> 00:30:06,160
在模式匹配算法中加入了三到四行代码
like three or four lines of code added to the pattern matcher you just saw

490
00:30:06,496 --> 00:30:08,176
来处理对称的情况
to handle the symmetric case.

491
00:30:08,280 --> 00:30:10,816
还记得吗？模式匹配中有一处代码判断
Remember, the pattern matcher has a place where it says

492
00:30:11,664 --> 00:30:14,288
这个变量匹配一个常量吗？
is this variable matching a constant.

493
00:30:14,980 --> 00:30:16,420
如果是的话 就在字典中进行检查
And if so, it checks in the dictionary.

494
00:30:16,420 --> 00:30:18,256
在合一算法中只有另一条子句
There's only one other clause in the unifier,

495
00:30:18,496 --> 00:30:20,752
它判断两个变量是否相匹配
which says is this variable matching a variable,

496
00:30:22,000 --> 00:30:23,424
这种情况下你去查询字典
in which case you go look in the dictionary

497
00:30:23,456 --> 00:30:25,680
看它们在字典的约束下是否一致
and see if that's consistent with what's in the dictionary.

498
00:30:27,030 --> 00:30:31,136
因此 这门语言中的所有“推断”
So all the, quote, deduction that's in this language,

499
00:30:31,280 --> 00:30:34,590
你会发现它蕴含在规则应用中
if you sort of look at it, sort of sits in the rule applications,

500
00:30:34,992 --> 00:30:37,888
更进一步地考察 你会发现在合一算法中
which, if you look at that, sits in the unifier,

501
00:30:38,368 --> 00:30:40,320
如果更进一步地用“显微镜”观察
which, if you look at that under a microscope,

502
00:30:40,560 --> 00:30:43,968
基本上就在模式匹配算法中
sits essentially in the pattern matcher.

503
00:30:44,944 --> 00:30:47,072
这其中并没有什么魔法
There's no magic at all going on in there.

504
00:30:47,410 --> 00:30:50,256
而你们所见到的“推断”
And the, quote, deduction that you see

505
00:30:50,944 --> 00:30:52,896
只是因为其中的递归
is just the fact that there's this recursion,

506
00:30:52,928 --> 00:30:55,696
它一点一点地回绕MATCH过程
which is unwinding the matches bit by bit.

507
00:30:56,030 --> 00:30:58,032
它让这个过程看起来很聪明
So it looks like this thing is being very clever,

508
00:30:58,448 --> 00:31:00,368
但它实际上并不是那么聪明
but in fact, it's not being very clever at all.

509
00:31:02,140 --> 00:31:04,416
当然 合一算法需要聪明地识别出一些情况
There are cases where a unifier might have to be clever.

510
00:31:04,880 --> 00:31:05,872
我来举个例子吧
Let me show you one more.

511
00:31:11,070 --> 00:31:13,360
假设我想要用一个二元表进行合一
Suppose I want to unify a list of two elements,

512
00:31:13,488 --> 00:31:14,816
(?X ?X)
x and x,

513
00:31:17,240 --> 00:31:22,144
另一个模式则是 (?Y (a . ?Y))
with a thing that says it's y followed by a dot y.

514
00:31:24,370 --> 00:31:26,128
现在 如果你想一想它所表达的意思
Now, if you think of what that would have to mean,

515
00:31:26,864 --> 00:31:29,712
它表示了?X应该跟?Y一致
it would have to mean that x had better be the same as y,

516
00:31:30,928 --> 00:31:31,664
同时呢
but also

517
00:31:31,824 --> 00:31:36,160
?X又应该跟(A . ?Y)相同
x had better be the same as a list whose first element is a and whose rest is y.

518
00:31:37,330 --> 00:31:39,456
如果你自习思考它成立的条件
And if you think about what that would have to mean,

519
00:31:42,272 --> 00:31:44,710
你会发现 ?Y必须是一个由A构成的无穷表
it would have to mean that y is the infinite list of a's.

520
00:31:47,500 --> 00:31:48,352
从某种角度来说
In some sense,

521
00:31:49,216 --> 00:31:52,400
为了完成这样的合一
in order to do that unification,

522
00:31:52,608 --> 00:31:54,848
我需要求解一个不动点方程
I have to solve the fixed-point equation

523
00:31:55,056 --> 00:32:01,840
(CONS 'A Y)=Y
cons of a to y is equal to y.

524
00:32:04,570 --> 00:32:06,960
通常来说 --- 我这个例子很简单
And in general, I wrote a very simple one.

525
00:32:07,290 --> 00:32:08,672
但实际进行合一时
Really doing unification

526
00:32:08,976 --> 00:32:11,984
我们可能要求解一个任意的不动点方程
might have to solve an arbitrary fixed-point equation:

527
00:32:12,016 --> 00:32:13,424
(F Y)=Y
f of y equals y.

528
00:32:15,530 --> 00:32:17,088
你基本上不能保证
And basically, you can't do that

529
00:32:17,104 --> 00:32:19,472
总能够找到有限的解
and make the thing finite all the time.

530
00:32:20,570 --> 00:32:23,600
我们的逻辑语言又该如何处理这类情况呢？
So how does the logic language handle that?

531
00:32:24,896 --> 00:32:26,480
答案就是：“不处理”
The answer is it doesn't.

532
00:32:27,168 --> 00:32:28,048
#TBD
It just punts.

533
00:32:28,730 --> 00:32:31,072
合一算法中有一处小检查
And there's a little check in the unifier,

534
00:32:31,312 --> 00:32:33,824
用来判断是否为困难的情况
which says, oh, is this one of the hard cases

535
00:32:34,448 --> 00:32:38,000
也就是 匹配这些东西需要求解不动点方程
which when I go to match things would involve solving a fixed-point equation?

536
00:32:38,650 --> 00:32:40,816
遇到这类情况 我就撒手不干
And in this case, I will throw up my hands.

537
00:32:42,840 --> 00:32:44,656
如果不进行这样的检查
And if that check were not in there,

538
00:32:45,008 --> 00:32:45,888
会发生什么情况？
what would happen?

539
00:32:47,990 --> 00:32:49,104
大多数情况就是
In most cases is

540
00:32:49,136 --> 00:32:51,312
合一算法会陷入无穷循环
that the unifier would just go into an infinite loop.

541
00:32:53,740 --> 00:32:56,544
其它的逻辑语言有类似的工作原理
And other logic programming languages work like that.

542
00:32:56,800 --> 00:32:58,144
因此这其中没有什么魔法
So there's really no magic.

543
00:32:58,220 --> 00:32:59,936
简单的情况由匹配器完成
The easy case is done in a matcher.

544
00:33:00,100 --> 00:33:01,584
困难的情况根本不去处理
The hard case is not done at all.

545
00:33:02,960 --> 00:33:05,472
这就是这种技术的现状
And that's about the state of this technology.

546
00:33:11,888 --> 00:33:14,240
现在 我来形式化地描述一下
OK, Let me just say again formally

547
00:33:14,272 --> 00:33:16,384
规则系统的运行原理 -- 也就是合一算法
how rules work now that I talked about unifiers.

548
00:33:17,390 --> 00:33:18,752
因此 正式的定义就是
So the official definition

549
00:33:19,200 --> 00:33:20,960
应用一条规则
is that to apply a rule,

550
00:33:24,176 --> 00:33:27,136
我们需要使用一些之前的术语
we-- well, let's start using some words we've used before.

551
00:33:28,270 --> 00:33:32,016
#TBD
Let's talk about sticking dictionaries into

552
00:33:32,880 --> 00:33:34,784
#TBD
these big boxes of query things

553
00:33:34,816 --> 00:33:38,544
#TBD
as evaluating these large queries

554
00:33:39,952 --> 00:33:43,850
#TBD
relative to an environment or a frame.

555
00:33:43,850 --> 00:33:45,040
因此 当我们谈及“字典”的时候
So when you think of that dictionary,

556
00:33:45,072 --> 00:33:46,280
“字典”究竟是什么？
what's the dictionary after all?

557
00:33:46,720 --> 00:33:48,180
它是符号的一系列语义
It's a bunch of meanings for symbols.

558
00:33:48,180 --> 00:33:50,224
我们把它叫做“框架”或者“环境”
That's what we've been calling frames or environments.

559
00:33:51,800 --> 00:33:55,970
根据环境进行操作 又是什么？
What does it mean to do some processing relevant to an environment?

560
00:33:55,970 --> 00:33:57,424
我们把这个叫做“求值”
That's what we've been calling evaluation.

561
00:33:58,336 --> 00:34:01,560
因此我们就说 应用一条规则的方法是
So we can say the way that you apply a rule

562
00:34:01,920 --> 00:34:06,160
先通过将给定的查询与规则的结论合一 得到环境
is to evaluate the rule body relative to an environment

563
00:34:06,672 --> 00:34:11,580
在再该环境中求值相应规则的体
that's formed by unifying the rule conclusion with the given query.

564
00:34:13,230 --> 00:34:14,512
我想要让你们注意的是
And the thing I want you to notice

565
00:34:14,800 --> 00:34:17,088
这非常像是
is the complete formal similarity

566
00:34:18,160 --> 00:34:21,504
元循环求值器以及代换模型
to the net of circular evaluator or the substitution model.

567
00:34:21,630 --> 00:34:22,736
规则的应用就是
To apply a procedure,

568
00:34:22,860 --> 00:34:28,368
在一个环境中求值规则的体
we evaluate the procedure body relative to an environment 

569
00:34:28,544 --> 00:34:33,136
环境是通过将实际参数与形式参数绑定起来得到的
that's formed by blinding the procedure parameters to the arguments.

570
00:34:34,560 --> 00:34:36,416
规则、规则的应用、过程的应用
There's a complete formal similarity there

571
00:34:36,440 --> 00:34:40,416
它们在形式上完全相似
between the rules, rule application, and procedure application

572
00:34:40,576 --> 00:34:42,304
尽管它们又非常不同
even though these things are very, very different.

573
00:34:43,650 --> 00:34:45,616
再一次地出现了EVAL-APPLY循环
And again, you have the EVAL APPLY loop.

574
00:34:47,290 --> 00:34:49,520
EVAL-APPLY
EVAL and APPLY.

575
00:34:53,392 --> 00:34:57,390
因此通常来说 我们可能会处理一些复合表达式
So in general, I might be processing some combined expression

576
00:34:57,424 --> 00:34:59,136
它们会变成规则的应用
that will turn into a rule application,

577
00:35:00,704 --> 00:35:03,280
进一步又会产生字典、框架或者环境
which will generate some dictionaries or frames or environments--

578
00:35:03,312 --> 00:35:04,720
不管你要怎么叫它
whatever you want to call them-- from match,

579
00:35:05,024 --> 00:35:08,432
它们随后又会作为某个大的复合对象的输入
which will then be the input to some big compound thing like this.

580
00:35:08,660 --> 00:35:11,776
这有它的一部分 并可能有其它规则的应用
This has pieces of it and may have other rule applications.

581
00:35:13,580 --> 00:35:15,680
这基本上就是相同的循环
And you have essentially the same cycle

582
00:35:15,720 --> 00:35:18,688
尽管这里没有什么东西看起来像过程
even though there's nothing here at all that looks like procedures.

583
00:35:19,680 --> 00:35:21,872
这是因为我们创建的语言
It really has to do with the fact you've built a language

584
00:35:22,080 --> 00:35:25,490
它们的组合手段和抽象手段以某种方式展开
whose means of combination and abstraction unwind in certain ways.

585
00:35:28,770 --> 00:35:29,520
通常来说
And then in general,

586
00:35:29,776 --> 00:35:31,392
最顶层所发生的是
what happens at the very top level,

587
00:35:33,792 --> 00:35:35,968
数据库中也有一些规则
you might have rules in your database also,

588
00:35:36,656 --> 00:35:38,704
数据库中的数据也可能是规则
so things in this database might be rules.

589
00:35:40,460 --> 00:35:42,064
它们用来检查对象是否为真
There are ways to check that things are true.

590
00:35:42,920 --> 00:35:44,896
所以这里可能会有规则检查
So it might come in here and have to do a rule check.

591
00:35:46,750 --> 00:35:48,160
然后就会有一些控制结构
And then there's some control structure

592
00:35:48,192 --> 00:35:50,480
用来判断你访问的是规则
which says, well, you look at some rules, and you look at some data elements,

593
00:35:50,512 --> 00:35:51,808
还是数据元素
and you look at some rules and data elements,

594
00:35:51,840 --> 00:35:53,120
然后不断地把它们扇出来开
and these fan out and out and out.

595
00:35:53,350 --> 00:35:55,488
所以基本上不可能说清楚
So it becomes essentially impossible

596
00:35:55,680 --> 00:35:57,696
是用什么样的顺序来查询这些东西的
to say what order it's looking at these things in,

597
00:35:58,208 --> 00:36:00,272
是广度优先还是深度优先
whether it's breadth first or depth first or anything.

598
00:36:00,280 --> 00:36:01,648
另外一个原因是
And it's even more impossible

599
00:36:01,664 --> 00:36:05,584
我们通过惰性流隐藏了实际执行顺序
because the actual order is somehow buried in the delays of the streams.

600
00:36:07,696 --> 00:36:11,168
因此很难说清楚它的扫描顺序
So what's very hard to tell from this is the order in which it's scanned.

601
00:36:11,270 --> 00:36:12,160
But what's true, because you're looking at the stream view, is that all of them eventually get looked at.

602
00:36:12,192 --> 00:36:13,648
But what's true, because you're looking at the stream view, is that all of them eventually get looked at.

603
00:36:13,904 --> 00:36:15,820
But what's true, because you're looking at the stream view, is that all of them eventually get looked at.

604
00:36:24,980 --> 00:36:28,150
Let me just mention one tiny technical problem.

605
00:36:37,530 --> 00:36:41,008
Suppose I tried saying boss of y is computer, then a funny thing would happen.

606
00:36:44,224 --> 00:36:45,780
Suppose I tried saying boss of y is computer, then a funny thing would happen.

607
00:36:45,780 --> 00:36:50,256
As I stuck a dictionary with y in here, I might get-- this y is not the same as that y, which was the other piece of somebody's job description.

608
00:36:52,736 --> 00:36:57,376
As I stuck a dictionary with y in here, I might get-- this y is not the same as that y, which was the other piece of somebody's job description.

609
00:36:57,424 --> 00:37:00,624
As I stuck a dictionary with y in here, I might get-- this y is not the same as that y, which was the other piece of somebody's job description.

610
00:37:01,580 --> 00:37:03,808
So if I really only did literally what I said, we'd get some variable conflict problems. So I lied to you a little bit.

611
00:37:04,224 --> 00:37:06,448
So if I really only did literally what I said, we'd get some variable conflict problems. So I lied to you a little bit.

612
00:37:09,280 --> 00:37:10,480
So if I really only did literally what I said, we'd get some variable conflict problems. So I lied to you a little bit.

613
00:37:10,930 --> 00:37:13,840
Notice that problem is exactly a problem we've run into before.

614
00:37:14,360 --> 00:37:15,600
It is precisely the need for local variables in a language.

615
00:37:15,984 --> 00:37:18,368
It is precisely the need for local variables in a language.

616
00:37:19,240 --> 00:37:23,392
When I have the sum of squares, that x had better not be that x.

617
00:37:24,960 --> 00:37:26,320
That's exactly the same as this y had better not be that y.

618
00:37:27,392 --> 00:37:29,776
That's exactly the same as this y had better not be that y.

619
00:37:31,800 --> 00:37:33,100
And we know how to solve that.

620
00:37:33,100 --> 00:37:34,496
That was this whole environment model, and we built chains of frames and all sorts of things like that.

621
00:37:34,512 --> 00:37:37,040
That was this whole environment model, and we built chains of frames and all sorts of things like that.

622
00:37:37,710 --> 00:37:39,104
There's a much more brutal way to solve it.

623
00:37:39,104 --> 00:37:41,730
In the query language, we didn't even do that.

624
00:37:41,730 --> 00:37:43,184
We did something completely brutal.

625
00:37:43,540 --> 00:37:45,936
We said every time you apply a rule, rename consistently all the variables in the rule to some new unique names that won't conflict with anything.

626
00:37:47,264 --> 00:37:49,632
We said every time you apply a rule, rename consistently all the variables in the rule to some new unique names that won't conflict with anything.

627
00:37:49,776 --> 00:37:53,504
We said every time you apply a rule, rename consistently all the variables in the rule to some new unique names that won't conflict with anything.

628
00:37:54,048 --> 00:37:59,248
That's conceptually simpler, but really brutal and not particularly efficient.

629
00:37:59,970 --> 00:38:01,152
But notice, we could have gotten rid of all of our environment structures if we defined for procedures in Lisp the same thing.

630
00:38:01,392 --> 00:38:04,688
But notice, we could have gotten rid of all of our environment structures if we defined for procedures in Lisp the same thing.

631
00:38:05,504 --> 00:38:08,896
But notice, we could have gotten rid of all of our environment structures if we defined for procedures in Lisp the same thing.

632
00:38:08,920 --> 00:38:11,568
If every time we applied a procedure and did the substitution model we renamed all the variables in the procedure, then we never would have had to worry about local variables because they would never arise.

633
00:38:11,872 --> 00:38:13,904
If every time we applied a procedure and did the substitution model we renamed all the variables in the procedure, then we never would have had to worry about local variables because they would never arise.

634
00:38:14,192 --> 00:38:16,288
If every time we applied a procedure and did the substitution model we renamed all the variables in the procedure, then we never would have had to worry about local variables because they would never arise.

635
00:38:16,336 --> 00:38:17,392
If every time we applied a procedure and did the substitution model we renamed all the variables in the procedure, then we never would have had to worry about local variables because they would never arise.

636
00:38:19,040 --> 00:38:20,416
OK, well, that would be inefficient, and it's inefficient here in the query language, too, but we did it to keep it simple.

637
00:38:20,912 --> 00:38:23,040
OK, well, that would be inefficient, and it's inefficient here in the query language, too, but we did it to keep it simple.

638
00:38:23,296 --> 00:38:24,592
OK, well, that would be inefficient, and it's inefficient here in the query language, too, but we did it to keep it simple.

639
00:38:25,610 --> 00:38:26,672
Let's break for questions.

640
00:38:30,880 --> 00:38:33,344
AUDIENCE: When you started this section, you emphasized how powerful our APPLY EVAL model was that we could use it for any language.

641
00:38:33,408 --> 00:38:39,600
AUDIENCE: When you started this section, you emphasized how powerful our APPLY EVAL model was that we could use it for any language.

642
00:38:39,632 --> 00:38:41,170
AUDIENCE: When you started this section, you emphasized how powerful our APPLY EVAL model was that we could use it for any language.

643
00:38:41,170 --> 00:38:43,392
And then you say we're going to have this language which is so different.

644
00:38:43,950 --> 00:38:45,136
It turns out that this language, as you just pointed out, is very much the same.

645
00:38:45,584 --> 00:38:47,880
It turns out that this language, as you just pointed out, is very much the same.

646
00:38:47,880 --> 00:38:49,856
I'm wondering if you're arguing that all languages end up coming down to this you can apply a rule or apply a procedure or some kind of apply?

647
00:38:50,480 --> 00:38:54,576
I'm wondering if you're arguing that all languages end up coming down to this you can apply a rule or apply a procedure or some kind of apply?

648
00:38:55,120 --> 00:38:55,984
I'm wondering if you're arguing that all languages end up coming down to this you can apply a rule or apply a procedure or some kind of apply?

649
00:38:57,072 --> 00:38:58,880
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

650
00:38:58,928 --> 00:39:00,304
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

651
00:39:00,928 --> 00:39:04,400
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

652
00:39:04,704 --> 00:39:06,864
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

653
00:39:07,790 --> 00:39:09,900
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

654
00:39:09,984 --> 00:39:11,408
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

655
00:39:12,032 --> 00:39:14,208
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

656
00:39:14,880 --> 00:39:15,888
If that's got to have parts, you have to unwind those parts.

657
00:39:15,904 --> 00:39:17,248
If that's got to have parts, you have to unwind those parts.

658
00:39:18,020 --> 00:39:20,192
You have to have some kind of organization which says when I look at the abstract variables or tags or whatever you want to call them that might stand for particular things, you have to keep track of that, and that's going to be something like an environment.

659
00:39:20,576 --> 00:39:24,944
You have to have some kind of organization which says when I look at the abstract variables or tags or whatever you want to call them that might stand for particular things, you have to keep track of that, and that's going to be something like an environment.

660
00:39:25,088 --> 00:39:27,104
You have to have some kind of organization which says when I look at the abstract variables or tags or whatever you want to call them that might stand for particular things, you have to keep track of that, and that's going to be something like an environment.

661
00:39:28,336 --> 00:39:29,344
You have to have some kind of organization which says when I look at the abstract variables or tags or whatever you want to call them that might stand for particular things, you have to keep track of that, and that's going to be something like an environment.

662
00:39:29,392 --> 00:39:30,912
You have to have some kind of organization which says when I look at the abstract variables or tags or whatever you want to call them that might stand for particular things, you have to keep track of that, and that's going to be something like an environment.

663
00:39:31,720 --> 00:39:32,544
And then if you say this part can have parts which I have to unwind, you've got to have something like this cycle.

664
00:39:32,704 --> 00:39:35,264
And then if you say this part can have parts which I have to unwind, you've got to have something like this cycle.

665
00:39:35,808 --> 00:39:37,440
And then if you say this part can have parts which I have to unwind, you've got to have something like this cycle.

666
00:39:39,970 --> 00:39:43,200
And lots and lots of languages have that character when they sort of get put together in this way.

667
00:39:43,360 --> 00:39:45,408
And lots and lots of languages have that character when they sort of get put together in this way.

668
00:39:45,590 --> 00:39:47,200
This language again really is different because there's nothing like procedures on the outside.

669
00:39:47,216 --> 00:39:49,504
This language again really is different because there's nothing like procedures on the outside.

670
00:39:50,690 --> 00:39:52,688
When you go below the surface and you see the implementation, of course, it starts looking the same.

671
00:39:52,704 --> 00:39:54,240
When you go below the surface and you see the implementation, of course, it starts looking the same.

672
00:39:54,870 --> 00:39:56,950
But from the outside, it's a very different world view.

673
00:39:56,950 --> 00:39:58,544
You're not computing functions of inputs.

674
00:40:03,970 --> 00:40:05,712
AUDIENCE: You mentioned earlier that when you build all of these rules in pattern matcher and with the delayed action of streams, you really have no way to know in what order things are evaluated.

675
00:40:06,608 --> 00:40:09,552
AUDIENCE: You mentioned earlier that when you build all of these rules in pattern matcher and with the delayed action of streams, you really have no way to know in what order things are evaluated.

676
00:40:10,016 --> 00:40:12,720
AUDIENCE: You mentioned earlier that when you build all of these rules in pattern matcher and with the delayed action of streams, you really have no way to know in what order things are evaluated.

677
00:40:13,376 --> 00:40:15,360
AUDIENCE: You mentioned earlier that when you build all of these rules in pattern matcher and with the delayed action of streams, you really have no way to know in what order things are evaluated.

678
00:40:15,584 --> 00:40:15,940
PROFESSOR: Right.

679
00:40:15,940 --> 00:40:18,288
AUDIENCE: And that would indicate then that you should only express declarative knowledge that's true for all-time, no-time sequence built into it.

680
00:40:18,944 --> 00:40:23,792
AUDIENCE: And that would indicate then that you should only express declarative knowledge that's true for all-time, no-time sequence built into it.

681
00:40:23,950 --> 00:40:25,472
Otherwise, these things get all-- PROFESSOR: Yes.

682
00:40:27,392 --> 00:40:27,824
Otherwise, these things get all-- PROFESSOR: Yes.

683
00:40:28,490 --> 00:40:28,820
Yes.

684
00:40:28,820 --> 00:40:29,488
The question is this really is set up for doing declarative knowledge, and as I presented it-- and I'll show you some of the ugly warts under this after the break.

685
00:40:30,064 --> 00:40:32,608
The question is this really is set up for doing declarative knowledge, and as I presented it-- and I'll show you some of the ugly warts under this after the break.

686
00:40:33,264 --> 00:40:34,816
The question is this really is set up for doing declarative knowledge, and as I presented it-- and I'll show you some of the ugly warts under this after the break.

687
00:40:35,712 --> 00:40:39,568
The question is this really is set up for doing declarative knowledge, and as I presented it-- and I'll show you some of the ugly warts under this after the break.

688
00:40:40,830 --> 00:40:42,608
As I presented it, it's just doing logic.

689
00:40:43,070 --> 00:40:46,816
And in principle, if it were logic, it wouldn't matter what order it's getting done.

690
00:40:48,840 --> 00:40:51,552
And it's quite true when you start doing things where you have side effects like adding things to the database and taking things out, and we'll see some others, you use that kind of control.

691
00:40:51,600 --> 00:40:53,616
And it's quite true when you start doing things where you have side effects like adding things to the database and taking things out, and we'll see some others, you use that kind of control.

692
00:40:53,680 --> 00:40:56,304
And it's quite true when you start doing things where you have side effects like adding things to the database and taking things out, and we'll see some others, you use that kind of control.

693
00:40:57,320 --> 00:40:58,144
And it's quite true when you start doing things where you have side effects like adding things to the database and taking things out, and we'll see some others, you use that kind of control.

694
00:40:58,752 --> 00:41:00,832
And it's quite true when you start doing things where you have side effects like adding things to the database and taking things out, and we'll see some others, you use that kind of control.

695
00:41:01,290 --> 00:41:02,940
So, for example, contrasting with Prolog.

696
00:41:02,940 --> 00:41:05,152
Say Prolog has various features where you really exploit the order of evaluation.

697
00:41:05,168 --> 00:41:07,792
Say Prolog has various features where you really exploit the order of evaluation.

698
00:41:09,640 --> 00:41:11,770
And people write Prolog programs that way.

699
00:41:11,770 --> 00:41:14,048
That turns out to be very complicated in Prolog, although if you're an expert Prolog programmer, you can do it.

700
00:41:14,320 --> 00:41:17,552
That turns out to be very complicated in Prolog, although if you're an expert Prolog programmer, you can do it.

701
00:41:18,590 --> 00:41:20,210
However, here I don't think you can do it at all.

702
00:41:20,210 --> 00:41:21,248
It's very complicated because you really are giving up control over any prearranged order of trying things.

703
00:41:21,728 --> 00:41:23,648
It's very complicated because you really are giving up control over any prearranged order of trying things.

704
00:41:23,776 --> 00:41:25,728
It's very complicated because you really are giving up control over any prearranged order of trying things.

705
00:41:27,150 --> 00:41:30,160
AUDIENCE: Now, that would indicate then that you have a functional mapping.

706
00:41:30,670 --> 00:41:32,512
And when you started out this lecture, you said that we express the declarative knowledge which is a relation, and we don't talk about the inputs and the outputs.

707
00:41:32,992 --> 00:41:34,080
And when you started out this lecture, you said that we express the declarative knowledge which is a relation, and we don't talk about the inputs and the outputs.

708
00:41:34,672 --> 00:41:36,704
And when you started out this lecture, you said that we express the declarative knowledge which is a relation, and we don't talk about the inputs and the outputs.

709
00:41:37,152 --> 00:41:38,810
And when you started out this lecture, you said that we express the declarative knowledge which is a relation, and we don't talk about the inputs and the outputs.

710
00:41:41,216 --> 00:41:43,370
PROFESSOR: Well, there's a pun on functional, right?

711
00:41:43,370 --> 00:41:45,792
There's function in the sense of no side effects and not depending on what order is going on.

712
00:41:46,208 --> 00:41:48,160
There's function in the sense of no side effects and not depending on what order is going on.

713
00:41:48,700 --> 00:41:51,040
And then there's functional in the sense of mathematical function, which means input and output.

714
00:41:51,072 --> 00:41:52,220
And then there's functional in the sense of mathematical function, which means input and output.

715
00:41:52,592 --> 00:41:54,368
And it's just that pun that you're making, I think.

716
00:41:56,510 --> 00:41:58,512
AUDIENCE: I'm a little unclear on what you're doing with these two statements, the two boss statements.

717
00:41:58,816 --> 00:42:00,704
AUDIENCE: I'm a little unclear on what you're doing with these two statements, the two boss statements.

718
00:42:01,270 --> 00:42:05,744
Is the first one building up the database and the second one a query or-- PROFESSOR: OK, I'm sorry.

719
00:42:05,760 --> 00:42:08,080
Is the first one building up the database and the second one a query or-- PROFESSOR: OK, I'm sorry.

720
00:42:09,072 --> 00:42:10,128
Is the first one building up the database and the second one a query or-- PROFESSOR: OK, I'm sorry.

721
00:42:12,440 --> 00:42:15,168
What I meant here, if I type something like this in as a query-- I should have given an example way at the very beginning.

722
00:42:16,128 --> 00:42:18,448
What I meant here, if I type something like this in as a query-- I should have given an example way at the very beginning.

723
00:42:19,470 --> 00:42:23,520
If I type in job, Ben Bitdiddle, computer wizard, what the processing will do is if it finds a match, it'll find a match to that exact thing, and it'll type out a job, Ben Bitdiddle, computer wizard.

724
00:42:25,072 --> 00:42:26,384
If I type in job, Ben Bitdiddle, computer wizard, what the processing will do is if it finds a match, it'll find a match to that exact thing, and it'll type out a job, Ben Bitdiddle, computer wizard.

725
00:42:26,496 --> 00:42:27,776
If I type in job, Ben Bitdiddle, computer wizard, what the processing will do is if it finds a match, it'll find a match to that exact thing, and it'll type out a job, Ben Bitdiddle, computer wizard.

726
00:42:28,304 --> 00:42:30,288
If I type in job, Ben Bitdiddle, computer wizard, what the processing will do is if it finds a match, it'll find a match to that exact thing, and it'll type out a job, Ben Bitdiddle, computer wizard.

727
00:42:30,864 --> 00:42:33,280
If I type in job, Ben Bitdiddle, computer wizard, what the processing will do is if it finds a match, it'll find a match to that exact thing, and it'll type out a job, Ben Bitdiddle, computer wizard.

728
00:42:34,220 --> 00:42:35,600
If it doesn't find a match, it won't find anything.

729
00:42:35,696 --> 00:42:36,752
If it doesn't find a match, it won't find anything.

730
00:42:37,400 --> 00:42:39,136
So what I should have said is the way you use the query language to check whether something is true, remember, that's one of the things you want to do in logic programming, is you type in your query and either that comes out or it doesn't.

731
00:42:39,152 --> 00:42:42,208
So what I should have said is the way you use the query language to check whether something is true, remember, that's one of the things you want to do in logic programming, is you type in your query and either that comes out or it doesn't.

732
00:42:43,408 --> 00:42:45,776
So what I should have said is the way you use the query language to check whether something is true, remember, that's one of the things you want to do in logic programming, is you type in your query and either that comes out or it doesn't.

733
00:42:46,416 --> 00:42:49,344
So what I should have said is the way you use the query language to check whether something is true, remember, that's one of the things you want to do in logic programming, is you type in your query and either that comes out or it doesn't.

734
00:42:50,680 --> 00:42:52,384
So what I was trying to illustrate here, I wanted to start with a very simple example before talking about unifiers.

735
00:42:52,416 --> 00:42:54,800
So what I was trying to illustrate here, I wanted to start with a very simple example before talking about unifiers.

736
00:42:54,832 --> 00:42:56,624
So what I was trying to illustrate here, I wanted to start with a very simple example before talking about unifiers.

737
00:42:57,480 --> 00:42:58,112
So what I should have said, if I just wanted to check whether this is true, I could type that in and see if anything came out AUDIENCE: And then the second one-- PROFESSOR: The second one would be a real query.

738
00:42:58,144 --> 00:43:00,960
So what I should have said, if I just wanted to check whether this is true, I could type that in and see if anything came out AUDIENCE: And then the second one-- PROFESSOR: The second one would be a real query.

739
00:43:01,184 --> 00:43:03,280
So what I should have said, if I just wanted to check whether this is true, I could type that in and see if anything came out AUDIENCE: And then the second one-- PROFESSOR: The second one would be a real query.

740
00:43:05,168 --> 00:43:06,272
So what I should have said, if I just wanted to check whether this is true, I could type that in and see if anything came out AUDIENCE: And then the second one-- PROFESSOR: The second one would be a real query.

741
00:43:06,288 --> 00:43:07,840
So what I should have said, if I just wanted to check whether this is true, I could type that in and see if anything came out AUDIENCE: And then the second one-- PROFESSOR: The second one would be a real query.

742
00:43:08,240 --> 00:43:09,760
AUDIENCE: A real query, yeah.

743
00:43:10,770 --> 00:43:13,104
PROFESSOR: What would come out, see, it would go in here say with FOO, and in would go frame that says z is bound to who and d is bound to computer.

744
00:43:13,904 --> 00:43:15,744
PROFESSOR: What would come out, see, it would go in here say with FOO, and in would go frame that says z is bound to who and d is bound to computer.

745
00:43:16,624 --> 00:43:18,816
PROFESSOR: What would come out, see, it would go in here say with FOO, and in would go frame that says z is bound to who and d is bound to computer.

746
00:43:19,560 --> 00:43:20,496
And this will pass through, and then by the time it got out of here, who would pick up a binding.

747
00:43:20,512 --> 00:43:21,952
And this will pass through, and then by the time it got out of here, who would pick up a binding.

748
00:43:22,016 --> 00:43:23,250
And this will pass through, and then by the time it got out of here, who would pick up a binding.

749
00:43:26,950 --> 00:43:28,768
AUDIENCE: On the unifying thing there, I still am not sure what happens with who and z.

750
00:43:29,184 --> 00:43:32,912
AUDIENCE: On the unifying thing there, I still am not sure what happens with who and z.

751
00:43:32,928 --> 00:43:35,904
AUDIENCE: On the unifying thing there, I still am not sure what happens with who and z.

752
00:43:36,460 --> 00:43:39,584
If the unifying-- the rule here says--  OK, so you say that you can't make question mark equal to question mark who.

753
00:43:42,032 --> 00:43:46,224
If the unifying-- the rule here says--  OK, so you say that you can't make question mark equal to question mark who.

754
00:43:46,260 --> 00:43:46,410
PROFESSOR: Right.

755
00:43:46,410 --> 00:43:48,032
That's what the matcher can't do.

756
00:43:48,360 --> 00:43:50,832
But what this will mean to a unifier is that there's an environment with three variables.

757
00:43:51,920 --> 00:43:54,016
But what this will mean to a unifier is that there's an environment with three variables.

758
00:43:56,690 --> 00:43:57,904
d here is computer.

759
00:43:58,520 --> 00:44:00,192
z is whatever who is.

760
00:44:01,830 --> 00:44:05,264
So if later on in the matcher routine it said, for example, who has to be 3, then when I looked up in the dictionary, it will say, oh, z is 3 because it's the same as who.

761
00:44:07,200 --> 00:44:10,384
So if later on in the matcher routine it said, for example, who has to be 3, then when I looked up in the dictionary, it will say, oh, z is 3 because it's the same as who.

762
00:44:12,064 --> 00:44:13,664
So if later on in the matcher routine it said, for example, who has to be 3, then when I looked up in the dictionary, it will say, oh, z is 3 because it's the same as who.

763
00:44:14,000 --> 00:44:16,400
So if later on in the matcher routine it said, for example, who has to be 3, then when I looked up in the dictionary, it will say, oh, z is 3 because it's the same as who.

764
00:44:18,360 --> 00:44:20,448
And that's in some sense the only thing you need to do to extend the unifier to a matcher.

765
00:44:20,464 --> 00:44:21,984
And that's in some sense the only thing you need to do to extend the unifier to a matcher.

766
00:44:22,880 --> 00:44:24,896
AUDIENCE: OK, because it looked like when you were telling how to unify it, it looked like you would put the things together in such a way that you'd actually solve and have a value for both of them.

767
00:44:24,912 --> 00:44:27,584
AUDIENCE: OK, because it looked like when you were telling how to unify it, it looked like you would put the things together in such a way that you'd actually solve and have a value for both of them.

768
00:44:27,616 --> 00:44:29,392
AUDIENCE: OK, because it looked like when you were telling how to unify it, it looked like you would put the things together in such a way that you'd actually solve and have a value for both of them.

769
00:44:29,770 --> 00:44:31,248
And what it looks like now is that you're actually pass a dictionary with two variables and the variables are linked.

770
00:44:31,280 --> 00:44:33,072
And what it looks like now is that you're actually pass a dictionary with two variables and the variables are linked.

771
00:44:33,264 --> 00:44:34,860
And what it looks like now is that you're actually pass a dictionary with two variables and the variables are linked.

772
00:44:34,860 --> 00:44:35,130
PROFESSOR: Right.

773
00:44:35,130 --> 00:44:37,232
It only looks like you're solving for both of them because you're sort of looking at the whole solution at once.

774
00:44:37,520 --> 00:44:39,744
It only looks like you're solving for both of them because you're sort of looking at the whole solution at once.

775
00:44:40,540 --> 00:44:42,880
If you sort of watch the thing getting built up recursively, it's merely this.

776
00:44:42,928 --> 00:44:43,696
If you sort of watch the thing getting built up recursively, it's merely this.

777
00:44:44,980 --> 00:44:48,400
AUDIENCE: OK, so you do pass off that dictionary with two variables?

778
00:44:48,400 --> 00:44:49,110
PROFESSOR: That's right.

779
00:44:49,110 --> 00:44:49,680
AUDIENCE: And link?

780
00:44:50,384 --> 00:44:52,912
PROFESSOR: Right. It just looks like an ordinary dictionary.

781
00:44:54,352 --> 00:44:56,064
AUDIENCE: When you're talking about the unifier, is it that there are some cases or some points that you are not able to use by them?

782
00:44:56,096 --> 00:45:00,192
AUDIENCE: When you're talking about the unifier, is it that there are some cases or some points that you are not able to use by them?

783
00:45:00,752 --> 00:45:03,984
AUDIENCE: When you're talking about the unifier, is it that there are some cases or some points that you are not able to use by them?

784
00:45:04,032 --> 00:45:04,304
PROFESSOR: Right.

785
00:45:04,970 --> 00:45:08,464
AUDIENCE: Can you just by building the rules or writing the forms know in advance if you are going to be able to solve to get the unification or not?

786
00:45:09,168 --> 00:45:13,168
AUDIENCE: Can you just by building the rules or writing the forms know in advance if you are going to be able to solve to get the unification or not?

787
00:45:13,232 --> 00:45:15,856
AUDIENCE: Can you just by building the rules or writing the forms know in advance if you are going to be able to solve to get the unification or not?

788
00:45:16,480 --> 00:45:18,540
AUDIENCE: Can you just by building the rules or writing the forms know in advance if you are going to be able to solve to get the unification or not?

789
00:45:18,768 --> 00:45:22,944
Can you add some properties either to the rules itself or to the formula that you're writing so that you avoid the problem of not finding unification?

790
00:45:23,184 --> 00:45:25,456
Can you add some properties either to the rules itself or to the formula that you're writing so that you avoid the problem of not finding unification?

791
00:45:25,824 --> 00:45:29,040
Can you add some properties either to the rules itself or to the formula that you're writing so that you avoid the problem of not finding unification?

792
00:45:29,180 --> 00:45:31,152
PROFESSOR: I mean, you can agree, I think, to write in a fairly restricted way where you won't run into it.

793
00:45:31,472 --> 00:45:35,264
PROFESSOR: I mean, you can agree, I think, to write in a fairly restricted way where you won't run into it.

794
00:45:35,600 --> 00:45:36,672
See, because what you're getting-- see, the place where you get into problems is when you-- well, again, you're trying to match things like that against things where these have structure, where a, y, b, y something.

795
00:45:36,880 --> 00:45:39,120
See, because what you're getting-- see, the place where you get into problems is when you-- well, again, you're trying to match things like that against things where these have structure, where a, y, b, y something.

796
00:45:39,680 --> 00:45:44,256
See, because what you're getting-- see, the place where you get into problems is when you-- well, again, you're trying to match things like that against things where these have structure, where a, y, b, y something.

797
00:45:44,592 --> 00:45:47,200
See, because what you're getting-- see, the place where you get into problems is when you-- well, again, you're trying to match things like that against things where these have structure, where a, y, b, y something.

798
00:45:47,552 --> 00:45:55,300
See, because what you're getting-- see, the place where you get into problems is when you-- well, again, you're trying to match things like that against things where these have structure, where a, y, b, y something.

799
00:45:58,980 --> 00:46:01,488
So this is the kind of place where you're going to get into trouble.

800
00:46:03,070 --> 00:46:05,808
AUDIENCE: So you can do that syntactically?

801
00:46:06,144 --> 00:46:08,832
PROFESSOR: So you can kind of watch your rules in the kinds of things that your writing.

802
00:46:08,848 --> 00:46:10,496
PROFESSOR: So you can kind of watch your rules in the kinds of things that your writing.

803
00:46:11,904 --> 00:46:14,080
AUDIENCE: So that's the problem that the builder of the database has to be concerned?

804
00:46:14,112 --> 00:46:16,272
AUDIENCE: So that's the problem that the builder of the database has to be concerned?

805
00:46:16,576 --> 00:46:17,808
PROFESSOR: That's a problem.

806
00:46:19,930 --> 00:46:22,016
It's a problem either-- not quite the builder of the database, the person who is expressing the rules, or the builder of the database.

807
00:46:22,048 --> 00:46:23,616
It's a problem either-- not quite the builder of the database, the person who is expressing the rules, or the builder of the database.

808
00:46:24,016 --> 00:46:25,312
It's a problem either-- not quite the builder of the database, the person who is expressing the rules, or the builder of the database.

809
00:46:25,800 --> 00:46:28,224
What the unifier actually does is you can check at the next level down when you actually get to the unifier and you'll see in the code where it looks up in the dictionary.

810
00:46:28,240 --> 00:46:29,856
What the unifier actually does is you can check at the next level down when you actually get to the unifier and you'll see in the code where it looks up in the dictionary.

811
00:46:29,920 --> 00:46:31,872
What the unifier actually does is you can check at the next level down when you actually get to the unifier and you'll see in the code where it looks up in the dictionary.

812
00:46:32,416 --> 00:46:34,768
What the unifier actually does is you can check at the next level down when you actually get to the unifier and you'll see in the code where it looks up in the dictionary.

813
00:46:34,940 --> 00:46:36,832
If it sort of says what does y have to be?

814
00:46:37,260 --> 00:46:38,928
Oh, does y have to be something that contains a y as its expression?

815
00:46:39,504 --> 00:46:41,424
Oh, does y have to be something that contains a y as its expression?

816
00:46:41,960 --> 00:46:43,264
At that point, the unifier and say, oh my God, I'm trying to solve a fixed-point equation.

817
00:46:43,280 --> 00:46:46,240
At that point, the unifier and say, oh my God, I'm trying to solve a fixed-point equation.

818
00:46:46,240 --> 00:46:46,992
I'll give it up here.

819
00:46:48,592 --> 00:46:51,910
AUDIENCE: You make the distinction between the rules in the database.

820
00:46:51,910 --> 00:46:56,480
Are the rules added to the database?

821
00:46:56,950 --> 00:46:57,360
PROFESSOR: Yes.

822
00:46:57,870 --> 00:46:58,870
Yes, I should have said that.

823
00:46:58,870 --> 00:47:00,336
One way to think about rules is that they're just other things in the database.

824
00:47:00,608 --> 00:47:02,656
One way to think about rules is that they're just other things in the database.

825
00:47:03,760 --> 00:47:04,944
So if you want to check the things that have to be checked in the database, they're kind of virtual facts that are in the database.

826
00:47:04,976 --> 00:47:06,816
So if you want to check the things that have to be checked in the database, they're kind of virtual facts that are in the database.

827
00:47:06,832 --> 00:47:09,440
So if you want to check the things that have to be checked in the database, they're kind of virtual facts that are in the database.

828
00:47:09,440 --> 00:47:12,320
AUDIENCE: But in that explanation, you made the differentiation between database and the rules itself.

829
00:47:12,432 --> 00:47:17,264
AUDIENCE: But in that explanation, you made the differentiation between database and the rules itself.

830
00:47:18,230 --> 00:47:19,904
PROFESSOR: Yeah, I probably should not have done that.

831
00:47:20,490 --> 00:47:23,312
The only reason to do that is in terms of the implementation.

832
00:47:23,540 --> 00:47:25,808
When you look at the implementation, there's a part which says check either primitive assertions in the database or check rules.

833
00:47:26,350 --> 00:47:28,720
When you look at the implementation, there's a part which says check either primitive assertions in the database or check rules.

834
00:47:28,928 --> 00:47:29,856
When you look at the implementation, there's a part which says check either primitive assertions in the database or check rules.

835
00:47:30,470 --> 00:47:32,720
And then the real reason why you can't tell what order things are going to come out in and is that the rules database and the data database sort of get merged in a kind of delayed evaluation way.

836
00:47:32,780 --> 00:47:34,560
And then the real reason why you can't tell what order things are going to come out in and is that the rules database and the data database sort of get merged in a kind of delayed evaluation way.

837
00:47:34,970 --> 00:47:40,464
And then the real reason why you can't tell what order things are going to come out in and is that the rules database and the data database sort of get merged in a kind of delayed evaluation way.

838
00:47:40,480 --> 00:47:43,680
And then the real reason why you can't tell what order things are going to come out in and is that the rules database and the data database sort of get merged in a kind of delayed evaluation way.

839
00:47:44,600 --> 00:47:46,800
And so that's what makes the order very complicated.

840
00:47:55,440 --> 00:47:56,096
OK, let's break.

841
00:48:33,160 --> 00:48:35,376
We've just seen how the logic language works and how rules work.

842
00:48:35,392 --> 00:48:36,416
We've just seen how the logic language works and how rules work.

843
00:48:37,230 --> 00:48:39,376
Now, let's turn to a more profound question.

844
00:48:40,120 --> 00:48:41,280
What do these things mean?

845
00:48:43,180 --> 00:48:46,864
That brings us to the subtlest, most devious part of this whole query language business, and that is that it's not quite what it seems to be.

846
00:48:46,992 --> 00:48:48,672
That brings us to the subtlest, most devious part of this whole query language business, and that is that it's not quite what it seems to be.

847
00:48:49,248 --> 00:48:50,112
That brings us to the subtlest, most devious part of this whole query language business, and that is that it's not quite what it seems to be.

848
00:48:51,360 --> 00:48:53,072
That brings us to the subtlest, most devious part of this whole query language business, and that is that it's not quite what it seems to be.

849
00:48:53,570 --> 00:48:56,224
AND and OR and NOT and the logical implication of rules are not really the AND and OR and NOT and logical implication of logic.

850
00:48:57,024 --> 00:48:58,880
AND and OR and NOT and the logical implication of rules are not really the AND and OR and NOT and logical implication of logic.

851
00:48:59,680 --> 00:49:01,280
AND and OR and NOT and the logical implication of rules are not really the AND and OR and NOT and logical implication of logic.

852
00:49:01,968 --> 00:49:06,640
AND and OR and NOT and the logical implication of rules are not really the AND and OR and NOT and logical implication of logic.

853
00:49:07,690 --> 00:49:09,712
Let me give you an example of that.

854
00:49:09,910 --> 00:49:12,224
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

855
00:49:12,448 --> 00:49:14,992
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

856
00:49:16,752 --> 00:49:19,440
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

857
00:49:20,000 --> 00:49:22,592
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

858
00:49:23,100 --> 00:49:24,510
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

859
00:49:24,780 --> 00:49:26,510
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

860
00:49:28,672 --> 00:49:30,096
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

861
00:49:30,100 --> 00:49:32,016
Here's an example.

862
00:49:32,180 --> 00:49:36,160
Let's talk about somebody outranking somebody else in our little database organization.

863
00:49:36,288 --> 00:49:40,140
Let's talk about somebody outranking somebody else in our little database organization.

864
00:49:40,140 --> 00:49:42,896
We'll say s is outranked by b or if either the supervisor of this is b or there's some middle manager here, that supervisor of s is m, and m is outranked by b.

865
00:49:44,640 --> 00:49:46,080
We'll say s is outranked by b or if either the supervisor of this is b or there's some middle manager here, that supervisor of s is m, and m is outranked by b.

866
00:49:46,912 --> 00:49:48,688
We'll say s is outranked by b or if either the supervisor of this is b or there's some middle manager here, that supervisor of s is m, and m is outranked by b.

867
00:49:49,630 --> 00:49:52,750
We'll say s is outranked by b or if either the supervisor of this is b or there's some middle manager here, that supervisor of s is m, and m is outranked by b.

868
00:49:53,680 --> 00:49:55,824
We'll say s is outranked by b or if either the supervisor of this is b or there's some middle manager here, that supervisor of s is m, and m is outranked by b.

869
00:49:59,648 --> 00:50:02,310
So there's one way to define rule outranked by.

870
00:50:02,310 --> 00:50:04,160
Or we can write exactly the same thing, except at the bottom here, we reversed the order of these two clauses.

871
00:50:05,088 --> 00:50:06,912
Or we can write exactly the same thing, except at the bottom here, we reversed the order of these two clauses.

872
00:50:07,216 --> 00:50:09,888
Or we can write exactly the same thing, except at the bottom here, we reversed the order of these two clauses.

873
00:50:11,630 --> 00:50:12,992
And certainly if this were logic, those ought to mean the same thing.

874
00:50:13,008 --> 00:50:14,880
And certainly if this were logic, those ought to mean the same thing.

875
00:50:16,690 --> 00:50:17,312
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

876
00:50:17,712 --> 00:50:19,616
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

877
00:50:19,648 --> 00:50:22,880
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

878
00:50:23,488 --> 00:50:25,360
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

879
00:50:26,768 --> 00:50:28,720
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

880
00:50:30,048 --> 00:50:31,984
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

881
00:50:34,110 --> 00:50:36,272
And the reason for that is that this will come in and say, oh, who's outranked by Ben Bitdiddle?

882
00:50:36,336 --> 00:50:40,336
And the reason for that is that this will come in and say, oh, who's outranked by Ben Bitdiddle?

883
00:50:41,920 --> 00:50:43,536
Find an s which is outranked by b, where b is Ben Bitdiddle, which is going to happen in it a subproblem.

884
00:50:43,888 --> 00:50:46,224
Find an s which is outranked by b, where b is Ben Bitdiddle, which is going to happen in it a subproblem.

885
00:50:47,504 --> 00:50:49,632
Find an s which is outranked by b, where b is Ben Bitdiddle, which is going to happen in it a subproblem.

886
00:50:50,330 --> 00:50:51,984
Oh gee, find an m such as m is outranked by Ben Bitdiddle with no restrictions on m.

887
00:50:52,240 --> 00:50:54,576
Oh gee, find an m such as m is outranked by Ben Bitdiddle with no restrictions on m.

888
00:50:55,616 --> 00:50:57,360
Oh gee, find an m such as m is outranked by Ben Bitdiddle with no restrictions on m.

889
00:50:58,560 --> 00:51:00,400
So this will say in order to solve this problem, I solve exactly the same problem.

890
00:51:01,424 --> 00:51:03,296
So this will say in order to solve this problem, I solve exactly the same problem.

891
00:51:04,570 --> 00:51:07,232
And then after I've solved that, I'll check for a supervisory relationship.

892
00:51:08,000 --> 00:51:12,352
Whereas this one won't get into that, because before it tries to find this outranked by, it'll already have had a restriction on m here.

893
00:51:12,944 --> 00:51:15,260
Whereas this one won't get into that, because before it tries to find this outranked by, it'll already have had a restriction on m here.

894
00:51:18,384 --> 00:51:20,944
So these two things which ought to mean the same, in fact, one goes into an infinite loop.

895
00:51:20,992 --> 00:51:22,672
So these two things which ought to mean the same, in fact, one goes into an infinite loop.

896
00:51:22,860 --> 00:51:25,040
One does not.

897
00:51:26,720 --> 00:51:29,776
That's a very extreme case of a general thing that you'll find in logic programming that if you start changing the order of the things in the ANDs or ORs, you'll find tremendous differences in efficiency.

898
00:51:29,790 --> 00:51:32,656
That's a very extreme case of a general thing that you'll find in logic programming that if you start changing the order of the things in the ANDs or ORs, you'll find tremendous differences in efficiency.

899
00:51:34,288 --> 00:51:38,704
That's a very extreme case of a general thing that you'll find in logic programming that if you start changing the order of the things in the ANDs or ORs, you'll find tremendous differences in efficiency.

900
00:51:39,344 --> 00:51:41,584
That's a very extreme case of a general thing that you'll find in logic programming that if you start changing the order of the things in the ANDs or ORs, you'll find tremendous differences in efficiency.

901
00:51:42,240 --> 00:51:43,216
And we just saw an infinitely big difference in efficiency and an infinite loop.

902
00:51:43,552 --> 00:51:46,544
And we just saw an infinitely big difference in efficiency and an infinite loop.

903
00:51:49,190 --> 00:51:51,744
And there are similar things having to do with the order in which you enter rules.

904
00:51:52,000 --> 00:51:53,312
And there are similar things having to do with the order in which you enter rules.

905
00:51:54,070 --> 00:51:56,480
The order in which it happens to look at rules in the database may vastly change the efficiency with which it gets out answers or, in fact, send it into an infinite loop for some orderings.

906
00:51:56,704 --> 00:52:00,240
The order in which it happens to look at rules in the database may vastly change the efficiency with which it gets out answers or, in fact, send it into an infinite loop for some orderings.

907
00:52:00,464 --> 00:52:02,608
The order in which it happens to look at rules in the database may vastly change the efficiency with which it gets out answers or, in fact, send it into an infinite loop for some orderings.

908
00:52:03,840 --> 00:52:07,296
And this whole thing has to do with the fact that you're checking these rules in some order.

909
00:52:07,632 --> 00:52:10,048
And this whole thing has to do with the fact that you're checking these rules in some order.

910
00:52:10,950 --> 00:52:14,416
And some rules may lead to really long paths of implication.

911
00:52:14,448 --> 00:52:16,064
Others might not.

912
00:52:16,440 --> 00:52:17,680
And you don't know a priori which ones are good and which ones are bad.

913
00:52:17,728 --> 00:52:19,168
And you don't know a priori which ones are good and which ones are bad.

914
00:52:19,300 --> 00:52:21,488
And there's a whole bunch of research having to do with that, mostly having to do with thinking about making parallel implementations of logic programming languages.

915
00:52:22,160 --> 00:52:23,760
And there's a whole bunch of research having to do with that, mostly having to do with thinking about making parallel implementations of logic programming languages.

916
00:52:23,952 --> 00:52:26,970
And there's a whole bunch of research having to do with that, mostly having to do with thinking about making parallel implementations of logic programming languages.

917
00:52:27,328 --> 00:52:28,640
And in some sense, what you'd like to do is check all rules in parallel and whichever ones get answers, you bubble them up.

918
00:52:28,672 --> 00:52:29,968
And in some sense, what you'd like to do is check all rules in parallel and whichever ones get answers, you bubble them up.

919
00:52:30,360 --> 00:52:32,528
And in some sense, what you'd like to do is check all rules in parallel and whichever ones get answers, you bubble them up.

920
00:52:32,560 --> 00:52:35,580
And if some go down infinite deductive changed, well, you just-- you know, memory is cheap and processors are cheap, and you just let them buzz for as for as long as you want.

921
00:52:36,128 --> 00:52:38,208
And if some go down infinite deductive changed, well, you just-- you know, memory is cheap and processors are cheap, and you just let them buzz for as for as long as you want.

922
00:52:38,240 --> 00:52:40,496
And if some go down infinite deductive changed, well, you just-- you know, memory is cheap and processors are cheap, and you just let them buzz for as for as long as you want.

923
00:52:43,472 --> 00:52:44,832
There's a deeper problem, though, in comparing this logic language to real logic.

924
00:52:45,184 --> 00:52:50,496
There's a deeper problem, though, in comparing this logic language to real logic.

925
00:52:50,688 --> 00:52:52,528
The example I just showed you, it went into an infinite loop maybe, but at least it didn't give the wrong answer.

926
00:52:52,976 --> 00:52:54,800
The example I just showed you, it went into an infinite loop maybe, but at least it didn't give the wrong answer.

927
00:52:55,376 --> 00:52:56,992
The example I just showed you, it went into an infinite loop maybe, but at least it didn't give the wrong answer.

928
00:52:58,370 --> 00:53:01,552
There's an actual deeper problem when we start comparing, seriously comparing this logic language with real classical logic.

929
00:53:02,224 --> 00:53:05,248
There's an actual deeper problem when we start comparing, seriously comparing this logic language with real classical logic.

930
00:53:05,712 --> 00:53:08,464
There's an actual deeper problem when we start comparing, seriously comparing this logic language with real classical logic.

931
00:53:09,490 --> 00:53:12,432
So let's sort of review real classical logic.

932
00:53:13,712 --> 00:53:21,040
All humans are mortal.

933
00:53:22,352 --> 00:53:23,456
That's pretty classical logic.

934
00:53:24,390 --> 00:53:28,672
Then maybe we'll continue in the very best classical tradition.

935
00:53:29,248 --> 00:53:32,464
We'll say all-- let's make it really classical.

936
00:53:32,670 --> 00:53:37,168
All Greeks are human, which has the syllogism that Socrates is a Greek.

937
00:53:40,496 --> 00:53:46,064
All Greeks are human, which has the syllogism that Socrates is a Greek.

938
00:53:48,176 --> 00:53:49,210
And then what do you write here?

939
00:53:49,210 --> 00:53:51,890
I think three dots, classical logic.

940
00:53:51,890 --> 00:53:54,336
Therefore, then the syllogism, Socrates is mortal.

941
00:53:54,640 --> 00:53:59,552
Therefore, then the syllogism, Socrates is mortal.

942
00:54:01,360 --> 00:54:04,912
So there's some real honest classical logic.

943
00:54:05,880 --> 00:54:11,056
Let's compare that with our classical logic database.

944
00:54:12,400 --> 00:54:14,464
So here's a classical logic database.

945
00:54:16,270 --> 00:54:17,488
Socrates is a Greek.

946
00:54:18,030 --> 00:54:18,848
Plato is a Greek.

947
00:54:19,600 --> 00:54:20,400
Zeus is a Greek, and Zeus is a god.

948
00:54:20,848 --> 00:54:21,984
Zeus is a Greek, and Zeus is a god.

949
00:54:24,120 --> 00:54:29,968
And all humans are mortal.

950
00:54:30,540 --> 00:54:32,128
To show that something is mortal, it's enough to show that it's human.

951
00:54:32,160 --> 00:54:33,600
To show that something is mortal, it's enough to show that it's human.

952
00:54:34,650 --> 00:54:35,900
All humans are fallible.

953
00:54:38,900 --> 00:54:40,980
And all Greeks are humans is not quite right.

954
00:54:40,980 --> 00:54:44,416
This says that all Greeks who are not gods are human.

955
00:54:45,710 --> 00:54:47,040
So to show something's human, it's enough to show it's a Greek and not a god.

956
00:54:47,072 --> 00:54:48,896
So to show something's human, it's enough to show it's a Greek and not a god.

957
00:54:49,320 --> 00:54:52,880
And the address of any Greek god is Mount Olympus.

958
00:54:54,320 --> 00:54:57,168
So there's a little classical logic database.

959
00:54:57,390 --> 00:54:59,328
And indeed, that would work fairly well.

960
00:54:59,490 --> 00:55:02,096
If we type that in and say is Socrates mortal or Socrates fallible or mortal?

961
00:55:03,472 --> 00:55:06,576
If we type that in and say is Socrates mortal or Socrates fallible or mortal?

962
00:55:06,910 --> 00:55:07,690
It'll say yes.

963
00:55:07,776 --> 00:55:09,710
Is Plato mortal and fallible.

964
00:55:09,710 --> 00:55:10,240
It'll say yes.

965
00:55:10,680 --> 00:55:12,210
If we say is Zeus mortal?

966
00:55:12,210 --> 00:55:13,232
It won't find anything.

967
00:55:14,900 --> 00:55:15,968
And it'll work perfectly well.

968
00:55:16,544 --> 00:55:20,120
However, suppose we want to extend this.

969
00:55:20,120 --> 00:55:23,056
Let's define what it means for someone to be a perfect being.

970
00:55:23,824 --> 00:55:27,216
Let's say rule: a perfect being.

971
00:55:34,050 --> 00:55:35,480
And I think this is right.

972
00:55:35,480 --> 00:55:38,144
If you're up on your medieval scholastic philosophy, I believe that perfect beings are ones who were neither mortal nor fallible.

973
00:55:38,448 --> 00:55:40,176
If you're up on your medieval scholastic philosophy, I believe that perfect beings are ones who were neither mortal nor fallible.

974
00:55:40,688 --> 00:55:42,656
If you're up on your medieval scholastic philosophy, I believe that perfect beings are ones who were neither mortal nor fallible.

975
00:55:44,100 --> 00:55:56,848
AND NOT mortal x, NOT fallible x.

976
00:55:59,300 --> 00:56:00,896
So we'll define this system to teach it what a perfect being is.

977
00:56:02,672 --> 00:56:04,368
So we'll define this system to teach it what a perfect being is.

978
00:56:05,790 --> 00:56:07,696
And now what we're going to do is he ask for the address of all the perfect beings.

979
00:56:08,064 --> 00:56:10,176
And now what we're going to do is he ask for the address of all the perfect beings.

980
00:56:11,488 --> 00:56:22,304
AND the address of x is y and x is perfect.

981
00:56:23,488 --> 00:56:24,976
And so what we're generating here is the world's most exclusive mailing list. For the address of all the perfect things, we might have typed this in.

982
00:56:24,992 --> 00:56:27,808
And so what we're generating here is the world's most exclusive mailing list. For the address of all the perfect things, we might have typed this in.

983
00:56:30,160 --> 00:56:32,200
And so what we're generating here is the world's most exclusive mailing list. For the address of all the perfect things, we might have typed this in.

984
00:56:32,240 --> 00:56:33,472
And so what we're generating here is the world's most exclusive mailing list. For the address of all the perfect things, we might have typed this in.

985
00:56:33,830 --> 00:56:35,440
Or we might type in this.

986
00:56:36,240 --> 00:56:50,576
We'll say AND perfect of x and the address of x is y.

987
00:56:52,140 --> 00:56:53,328
Well, suppose we type all that in and we try this query.

988
00:56:53,728 --> 00:56:54,848
Well, suppose we type all that in and we try this query.

989
00:56:55,190 --> 00:56:56,768
This query is going to give us an answer.

990
00:56:57,650 --> 00:57:00,000
This query will say, yeah, Mount Olympus.

991
00:57:04,230 --> 00:57:06,576
This query, in fact, is going to give us nothing.

992
00:57:06,740 --> 00:57:09,584
It will say no addresses of perfect beings.

993
00:57:11,640 --> 00:57:12,510
Now, why is that?

994
00:57:12,510 --> 00:57:13,440
Why is there a difference?

995
00:57:14,230 --> 00:57:15,690
This is not an infinite loop question.

996
00:57:15,690 --> 00:57:17,088
This is a different answer question.

997
00:57:19,488 --> 00:57:20,096
The reason is that if you remember the implementation of NOT, NOT acted as a filter.

998
00:57:20,380 --> 00:57:22,320
The reason is that if you remember the implementation of NOT, NOT acted as a filter.

999
00:57:23,504 --> 00:57:24,848
The reason is that if you remember the implementation of NOT, NOT acted as a filter.

1000
00:57:25,880 --> 00:57:29,008
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1001
00:57:29,056 --> 00:57:30,144
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1002
00:57:30,400 --> 00:57:31,568
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1003
00:57:31,792 --> 00:57:33,168
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1004
00:57:33,290 --> 00:57:34,940
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1005
00:57:34,976 --> 00:57:36,112
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1006
00:57:36,928 --> 00:57:38,432
If you think about what's going on here, I'll build this query box where the output of an address piece gets fed into a perfect piece.

1007
00:57:40,112 --> 00:57:42,656
If you think about what's going on here, I'll build this query box where the output of an address piece gets fed into a perfect piece.

1008
00:57:43,328 --> 00:57:45,648
If you think about what's going on here, I'll build this query box where the output of an address piece gets fed into a perfect piece.

1009
00:57:46,064 --> 00:57:47,328
If you think about what's going on here, I'll build this query box where the output of an address piece gets fed into a perfect piece.

1010
00:57:50,290 --> 00:57:51,008
What will happen is the address piece will set up some things of everyone whose address I know.

1011
00:57:51,328 --> 00:57:53,264
What will happen is the address piece will set up some things of everyone whose address I know.

1012
00:57:53,328 --> 00:57:54,832
What will happen is the address piece will set up some things of everyone whose address I know.

1013
00:57:55,290 --> 00:57:57,648
Those will get filtered by the NOTs inside perfect here.

1014
00:57:59,880 --> 00:58:01,904
So it will throw out the ones which happened to be either mortal or fallible.

1015
00:58:02,160 --> 00:58:04,112
So it will throw out the ones which happened to be either mortal or fallible.

1016
00:58:04,910 --> 00:58:06,384
In the other order what happens is I set this up, started up with an empty frame.

1017
00:58:06,736 --> 00:58:09,120
In the other order what happens is I set this up, started up with an empty frame.

1018
00:58:09,520 --> 00:58:12,352
The perfect in here doesn't find anything for the NOTs to filter, so nothing comes out here at all.

1019
00:58:12,384 --> 00:58:13,984
The perfect in here doesn't find anything for the NOTs to filter, so nothing comes out here at all.

1020
00:58:18,830 --> 00:58:21,504
And there's sort of nothing there that gets fed into the address thing.

1021
00:58:21,940 --> 00:58:23,152
So here, I don't get an answer.

1022
00:58:23,936 --> 00:58:27,040
And again, the reason for that is NOT isn't generating anything.

1023
00:58:27,440 --> 00:58:28,800
NOT's only throwing out things.

1024
00:58:29,080 --> 00:58:30,512
And if I never started up with anything, there's nothing for it to throw out.

1025
00:58:30,528 --> 00:58:31,744
And if I never started up with anything, there's nothing for it to throw out.

1026
00:58:32,020 --> 00:58:33,770
So out of this thing, I get the wrong answer.

1027
00:58:37,200 --> 00:58:37,970
How can you fix that?

1028
00:58:37,970 --> 00:58:39,070
Well, there are ways to fix that.

1029
00:58:39,360 --> 00:58:40,912
So you might say, well, that's sort of stupid.

1030
00:58:41,410 --> 00:58:44,900
Why are you just doing all your NOT stuff at the beginning?

1031
00:58:44,900 --> 00:58:46,144
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1032
00:58:46,432 --> 00:58:47,392
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1033
00:58:47,840 --> 00:58:50,080
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1034
00:58:50,336 --> 00:58:52,096
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1035
00:58:52,800 --> 00:58:54,976
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1036
00:58:55,520 --> 00:58:57,856
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1037
00:58:58,560 --> 00:59:02,016
And there are implementations of logic languages that work like that that solve this particular problem.

1038
00:59:02,416 --> 00:59:04,050
And there are implementations of logic languages that work like that that solve this particular problem.

1039
00:59:06,800 --> 00:59:08,976
However, there's a more profound problem, which is which one of these is the right answer?

1040
00:59:09,600 --> 00:59:11,536
However, there's a more profound problem, which is which one of these is the right answer?

1041
00:59:12,530 --> 00:59:14,240
Is it Mount Olympus or is it nothing?

1042
00:59:15,320 --> 00:59:16,224
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1043
00:59:17,520 --> 00:59:18,736
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1044
00:59:18,760 --> 00:59:20,730
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1045
00:59:22,528 --> 00:59:25,104
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1046
00:59:29,550 --> 00:59:32,448
So you might say Zeus wants to satisfy NOT mortal Zeus or NOT fallible Zeus.

1047
00:59:34,304 --> 00:59:44,032
So you might say Zeus wants to satisfy NOT mortal Zeus or NOT fallible Zeus.

1048
00:59:44,120 --> 00:59:45,856
But let's actually look at that database.

1049
00:59:47,920 --> 00:59:48,464
Let's look at it.

1050
00:59:49,320 --> 00:59:50,208
There's no way-- how does it know that Zeus is not fallible?

1051
00:59:51,472 --> 00:59:53,248
There's no way-- how does it know that Zeus is not fallible?

1052
00:59:54,810 --> 00:59:56,112
There's nothing in there about that.

1053
00:59:57,930 --> 00:59:59,664
What's in there is that humans are fallible.

1054
01:00:02,160 --> 01:00:04,128
How does it know that Zeus is not mortal?

1055
01:00:04,480 --> 01:00:05,936
There's nothing in there about that.

1056
01:00:07,980 --> 01:00:11,008
It just said I don't have any rule, which-- the only way I can deduce something's mortal is if it's human, and that's all it really knows about mortal.

1057
01:00:11,680 --> 01:00:13,504
It just said I don't have any rule, which-- the only way I can deduce something's mortal is if it's human, and that's all it really knows about mortal.

1058
01:00:13,520 --> 01:00:15,680
It just said I don't have any rule, which-- the only way I can deduce something's mortal is if it's human, and that's all it really knows about mortal.

1059
01:00:16,690 --> 01:00:19,856
And in fact, if you remember your classical mythology, you know that the Greek gods were not mortal but fallible.

1060
01:00:19,872 --> 01:00:23,488
And in fact, if you remember your classical mythology, you know that the Greek gods were not mortal but fallible.

1061
01:00:25,056 --> 01:00:28,656
So the answer is not in the rules there.

1062
01:00:30,850 --> 01:00:32,100
See, why does it deduce that?

1063
01:00:34,496 --> 01:00:38,320
See, Socrates would certainly not have made this error of logic.

1064
01:00:40,080 --> 01:00:42,672
What NOT needs in this language is not NOT.

1065
01:00:43,370 --> 01:00:44,320
It's not the NOT of logic.

1066
01:00:44,930 --> 01:00:46,400
What NOT needs in this language is not deducible from things in the database as opposed to not true.

1067
01:00:47,160 --> 01:00:49,960
What NOT needs in this language is not deducible from things in the database as opposed to not true.

1068
01:00:50,752 --> 01:00:53,344
What NOT needs in this language is not deducible from things in the database as opposed to not true.

1069
01:00:55,312 --> 01:00:56,384
That's a very big difference.

1070
01:00:57,300 --> 01:00:58,640
Subtle, but big.

1071
01:00:59,250 --> 01:01:00,272
So, in fact, this is perfectly happy to say not anything that it doesn't know about.

1072
01:01:00,768 --> 01:01:03,920
So, in fact, this is perfectly happy to say not anything that it doesn't know about.

1073
01:01:04,610 --> 01:01:05,488
So if you ask it is it not true that Zeus likes chocolate ice cream?

1074
01:01:05,504 --> 01:01:07,830
So if you ask it is it not true that Zeus likes chocolate ice cream?

1075
01:01:07,856 --> 01:01:09,120
It will say sure, it's not true.

1076
01:01:10,640 --> 01:01:12,512
Or anything else or anything it doesn't know about.

1077
01:01:12,592 --> 01:01:17,344
NOT means not deducible from the things you've told me.

1078
01:01:18,280 --> 01:01:22,448
In a world where you're identifying not deducible with, in fact, not true, this is called the closed world assumption.

1079
01:01:22,656 --> 01:01:24,000
In a world where you're identifying not deducible with, in fact, not true, this is called the closed world assumption.

1080
01:01:24,416 --> 01:01:26,304
In a world where you're identifying not deducible with, in fact, not true, this is called the closed world assumption.

1081
01:01:37,376 --> 01:01:38,176
The closed world assumption.

1082
01:01:38,200 --> 01:01:42,384
Anything that I cannot deduce from what I know is not true, right?

1083
01:01:43,504 --> 01:01:44,270
Anything that I cannot deduce from what I know is not true, right?

1084
01:01:46,240 --> 01:01:48,010
If I don't know anything about x, the x isn't true.

1085
01:01:48,224 --> 01:01:49,216
If I don't know anything about x, the x isn't true.

1086
01:01:49,290 --> 01:01:50,336
That's very dangerous.

1087
01:01:51,296 --> 01:01:52,448
From a logical point of view, first of all, it doesn't really makes sense.

1088
01:01:52,464 --> 01:01:53,760
From a logical point of view, first of all, it doesn't really makes sense.

1089
01:01:54,480 --> 01:01:56,336
Because if I don't know anything about x, I'm willing to say not x.

1090
01:01:58,384 --> 01:01:59,696
Because if I don't know anything about x, I'm willing to say not x.

1091
01:02:00,240 --> 01:02:03,328
But am I willing to say not not x?

1092
01:02:03,850 --> 01:02:05,664
Well, sure, I don't know anything about that either maybe.

1093
01:02:06,470 --> 01:02:08,656
So not not x is not necessarily the same as x and so on and so on and so on, so there's some sort of funny bias in there.

1094
01:02:09,248 --> 01:02:10,944
So not not x is not necessarily the same as x and so on and so on and so on, so there's some sort of funny bias in there.

1095
01:02:11,712 --> 01:02:13,936
So not not x is not necessarily the same as x and so on and so on and so on, so there's some sort of funny bias in there.

1096
01:02:15,970 --> 01:02:17,290
So that's sort of funny.

1097
01:02:17,290 --> 01:02:18,096
The second thing, if you start building up real reasoning programs based on this, think how dangerous that is.

1098
01:02:20,144 --> 01:02:24,128
The second thing, if you start building up real reasoning programs based on this, think how dangerous that is.

1099
01:02:24,704 --> 01:02:26,112
The second thing, if you start building up real reasoning programs based on this, think how dangerous that is.

1100
01:02:27,000 --> 01:02:27,856
You're saying I know I'm in a position to deduce everything true that's relevant to this problem.

1101
01:02:29,616 --> 01:02:33,888
You're saying I know I'm in a position to deduce everything true that's relevant to this problem.

1102
01:02:34,160 --> 01:02:36,224
You're saying I know I'm in a position to deduce everything true that's relevant to this problem.

1103
01:02:37,480 --> 01:02:38,560
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1104
01:02:38,896 --> 01:02:42,256
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1105
01:02:42,368 --> 01:02:44,208
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1106
01:02:44,240 --> 01:02:46,272
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1107
01:02:48,448 --> 01:02:53,040
There are a lot of big organizations that work like that, right?

1108
01:02:53,168 --> 01:02:56,830
Most corporate marketing divisions work like that.

1109
01:02:56,830 --> 01:02:59,120
You know the consequences to that.

1110
01:03:00,336 --> 01:03:01,680
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1111
01:03:02,272 --> 01:03:06,256
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1112
01:03:07,056 --> 01:03:09,008
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1113
01:03:09,024 --> 01:03:11,280
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1114
01:03:12,600 --> 01:03:14,368
So you have to be very, very careful about that.

1115
01:03:15,296 --> 01:03:16,288
And that's a deep problem.

1116
01:03:16,560 --> 01:03:17,824
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1117
01:03:18,224 --> 01:03:20,144
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1118
01:03:20,160 --> 01:03:21,824
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1119
01:03:22,160 --> 01:03:23,840
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1120
01:03:23,840 --> 01:03:25,088
It's a different kind of problem.

1121
01:03:25,920 --> 01:03:26,896
It's a different semantics.

1122
01:03:27,060 --> 01:03:30,512
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1123
01:03:31,344 --> 01:03:34,432
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1124
01:03:34,576 --> 01:03:35,648
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1125
01:03:36,176 --> 01:03:38,784
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1126
01:03:39,900 --> 01:03:42,944
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1127
01:03:43,584 --> 01:03:45,088
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1128
01:03:46,096 --> 01:03:49,488
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1129
01:03:50,560 --> 01:03:51,536
And linked to logic, the problem is it's a goal that I think has yet to be realized.

1130
01:03:52,464 --> 01:03:56,464
And linked to logic, the problem is it's a goal that I think has yet to be realized.

1131
01:03:58,032 --> 01:04:01,808
And probably one of the very most interesting research questions going on now in languages is how do you somehow make a real logic language?

1132
01:04:02,272 --> 01:04:04,416
And probably one of the very most interesting research questions going on now in languages is how do you somehow make a real logic language?

1133
01:04:04,672 --> 01:04:08,288
And probably one of the very most interesting research questions going on now in languages is how do you somehow make a real logic language?

1134
01:04:09,460 --> 01:04:11,056
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1135
01:04:11,312 --> 01:04:13,152
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1136
01:04:13,520 --> 01:04:16,432
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1137
01:04:16,464 --> 01:04:17,984
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1138
01:04:18,880 --> 01:04:19,680
OK, let's break.

1139
01:04:23,290 --> 01:04:27,740
AUDIENCE: Couldn't you solve that last problem by having the extra rules that imply it?

1140
01:04:27,968 --> 01:04:29,856
The problem here is you have the definition of something, but you don't have the definition of its opposite.

1141
01:04:29,888 --> 01:04:31,824
The problem here is you have the definition of something, but you don't have the definition of its opposite.

1142
01:04:32,080 --> 01:04:33,920
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1143
01:04:35,472 --> 01:04:36,896
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1144
01:04:36,992 --> 01:04:38,704
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1145
01:04:38,752 --> 01:04:40,370
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1146
01:04:43,370 --> 01:04:44,144
PROFESSOR: But the issue is do you put a finite number of those in?

1147
01:04:44,752 --> 01:04:46,384
PROFESSOR: But the issue is do you put a finite number of those in?

1148
01:04:48,656 --> 01:04:53,130
AUDIENCE: If things are specified always in pairs-- PROFESSOR: But the impression is then what do you do about deduction?

1149
01:04:53,616 --> 01:04:57,072
AUDIENCE: If things are specified always in pairs-- PROFESSOR: But the impression is then what do you do about deduction?

1150
01:05:00,200 --> 01:05:02,112
You can't specify NOTs.

1151
01:05:03,400 --> 01:05:04,768
But the problem is, in a big system, it turns out that might not be a finite number of things.

1152
01:05:04,784 --> 01:05:07,960
But the problem is, in a big system, it turns out that might not be a finite number of things.

1153
01:05:12,820 --> 01:05:15,290
There are also sort of two issues.

1154
01:05:15,290 --> 01:05:16,560
Partly it might not be finite.

1155
01:05:16,690 --> 01:05:19,392
Partly it might be that's not what you want.

1156
01:05:21,510 --> 01:05:24,528
So a good example would be suppose I want to do connectivity.

1157
01:05:25,120 --> 01:05:26,544
I want a reason about connectivity.

1158
01:05:28,050 --> 01:05:30,384
And I'm going to tell you there's four things: a and b and c and d.

1159
01:05:30,400 --> 01:05:33,744
And I'm going to tell you there's four things: a and b and c and d.

1160
01:05:35,480 --> 01:05:38,190
And I'll tell you a is connected to b and c's connected to d.

1161
01:05:38,640 --> 01:05:41,424
And I'll tell you a is connected to b and c's connected to d.

1162
01:05:43,200 --> 01:05:44,800
And now I'll tell you is a connected to d?

1163
01:05:45,056 --> 01:05:46,032
That's the question.

1164
01:05:46,780 --> 01:05:50,610
There's an example where I would like something like the closed world assumption.

1165
01:05:54,432 --> 01:05:55,664
That's a tiny toy, but a lot of times, I want to be able to say something like anything that I haven't told you, assume is not true.

1166
01:05:56,240 --> 01:05:58,304
That's a tiny toy, but a lot of times, I want to be able to say something like anything that I haven't told you, assume is not true.

1167
01:05:58,480 --> 01:06:01,340
That's a tiny toy, but a lot of times, I want to be able to say something like anything that I haven't told you, assume is not true.

1168
01:06:04,260 --> 01:06:06,496
So it's not as simple as you only want to put in explicit NOTs all over the place.

1169
01:06:06,560 --> 01:06:08,096
So it's not as simple as you only want to put in explicit NOTs all over the place.

1170
01:06:09,470 --> 01:06:12,704
It's that sometimes it really isn't clear what you even want.

1171
01:06:14,150 --> 01:06:17,920
That having to specify both everything and not everything is too precise, and then you get down into problems there.

1172
01:06:17,936 --> 01:06:20,000
That having to specify both everything and not everything is too precise, and then you get down into problems there.

1173
01:06:20,960 --> 01:06:22,688
But there are a lot of approaches that explicitly put in NOTs and reason based on that.

1174
01:06:23,328 --> 01:06:25,936
But there are a lot of approaches that explicitly put in NOTs and reason based on that.

1175
01:06:26,510 --> 01:06:27,664
So it's a very good idea.

1176
01:06:28,070 --> 01:06:31,456
It's just that then it starts becoming a little cumbersome in the very large problems you'd like to use.

1177
01:06:31,488 --> 01:06:33,490
It's just that then it starts becoming a little cumbersome in the very large problems you'd like to use.

1178
01:06:43,460 --> 01:06:45,968
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1179
01:06:46,000 --> 01:06:47,984
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1180
01:06:48,496 --> 01:06:50,160
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1181
01:06:50,192 --> 01:06:52,064
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1182
01:06:53,440 --> 01:06:55,328
You never really know all the parts to it.

1183
01:06:55,872 --> 01:06:58,160
Isn't that a major problem with any programming?

1184
01:06:58,160 --> 01:06:59,648
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1185
01:06:59,904 --> 01:07:01,568
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1186
01:07:01,584 --> 01:07:03,408
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1187
01:07:04,064 --> 01:07:06,528
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1188
01:07:07,390 --> 01:07:08,540
PROFESSOR: Well, sure, it's true.

1189
01:07:08,540 --> 01:07:09,760
But the problem here is it's that assumption which is the thing that you're making if you believe you're identifying this with logic.

1190
01:07:11,968 --> 01:07:15,472
But the problem here is it's that assumption which is the thing that you're making if you believe you're identifying this with logic.

1191
01:07:15,488 --> 01:07:17,344
But the problem here is it's that assumption which is the thing that you're making if you believe you're identifying this with logic.

1192
01:07:19,600 --> 01:07:20,510
So you're quite right.

1193
01:07:20,510 --> 01:07:22,220
It's a situation you're never in.

1194
01:07:22,220 --> 01:07:25,520
The problem is if you're starting to believe that what this is doing is logic and you look at the rules you write down and say what can I deduce from them, you have to be very careful to remember that NOT means something else.

1195
01:07:26,176 --> 01:07:28,896
The problem is if you're starting to believe that what this is doing is logic and you look at the rules you write down and say what can I deduce from them, you have to be very careful to remember that NOT means something else.

1196
01:07:29,536 --> 01:07:32,800
The problem is if you're starting to believe that what this is doing is logic and you look at the rules you write down and say what can I deduce from them, you have to be very careful to remember that NOT means something else.

1197
01:07:33,470 --> 01:07:35,216
And it means something else based on an assumption which is probably not true.

1198
01:07:35,248 --> 01:07:36,704
And it means something else based on an assumption which is probably not true.

1199
01:07:39,030 --> 01:07:40,544
AUDIENCE: Do I understand you correctly that you cannot fix this problem without killing off all possibilities of inference through altering NOT?

1200
01:07:40,560 --> 01:07:41,824
AUDIENCE: Do I understand you correctly that you cannot fix this problem without killing off all possibilities of inference through altering NOT?

1201
01:07:42,256 --> 01:07:46,080
AUDIENCE: Do I understand you correctly that you cannot fix this problem without killing off all possibilities of inference through altering NOT?

1202
01:07:46,544 --> 01:07:49,808
PROFESSOR: No, that's not quite right.

1203
01:07:52,960 --> 01:07:55,088
There are other--  there are ways to do logic with real NOTs.

1204
01:07:56,340 --> 01:07:58,032
There are actually ways to do that.

1205
01:07:58,540 --> 01:08:00,848
But they're very inefficient as far as anybody knows.

1206
01:08:01,610 --> 01:08:02,560
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1207
01:08:04,096 --> 01:08:06,896
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1208
01:08:07,390 --> 01:08:08,830
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1209
01:08:08,912 --> 01:08:11,296
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1210
01:08:11,980 --> 01:08:16,192
There are ways to automate real logical reasoning.

1211
01:08:16,590 --> 01:08:18,192
But it's not based on that, and logic programming languages don't tend to do that because it's very inefficient as far as anybody knows.

1212
01:08:18,512 --> 01:08:19,840
But it's not based on that, and logic programming languages don't tend to do that because it's very inefficient as far as anybody knows.

1213
01:08:19,872 --> 01:08:23,850
But it's not based on that, and logic programming languages don't tend to do that because it's very inefficient as far as anybody knows.

1214
01:08:29,390 --> 01:08:30,032
All right, thank you.

