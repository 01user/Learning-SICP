1
00:00:18,910 --> 00:00:21,792
我们已经了解了查询语言的使用方式
PROFESSOR: All right, well, we've seen how the query language works.

2
00:00:22,640 --> 00:00:25,072
现在该来讨论如何实现了
Now, let's talk about how it's implemented.

3
00:00:26,280 --> 00:00:27,984
你们也应该能够想象到
You already pretty much can guess

4
00:00:28,592 --> 00:00:29,470
它其中的原理
what's going on there.

5
00:00:29,470 --> 00:00:31,648
它的最底层是一个模式匹配器
At the bottom of it, there's a pattern matcher.

6
00:00:32,810 --> 00:00:34,256
我们在《基于规则的控制语言》一课中
And we looked at a pattern matcher

7
00:00:34,672 --> 00:00:36,944
已经介绍过模式匹配器了
when we did the rule-based control language.

8
00:00:38,110 --> 00:00:40,592
为了让你们回想起来 我举个例子
Just to remind you, here are some sample patterns.

9
00:00:41,520 --> 00:00:43,680
这个模式会匹配
This is a pattern that will match

10
00:00:43,808 --> 00:00:44,928
一个含有三个元素的表
any list of three things

11
00:00:44,960 --> 00:00:47,104
其中 首元素为'A
which the first is a

12
00:00:47,168 --> 00:00:48,336
其次是'C
the second is c

13
00:00:48,480 --> 00:00:50,192
而中间可以为任意元素
and the middle one can be anything.

14
00:00:50,650 --> 00:00:52,272
所以在这个小型的模式匹配语言中
So in this little pattern-matching syntax,

15
00:00:52,304 --> 00:00:54,050
你只能区分一种类型
there's only one distinction you make.

16
00:00:54,050 --> 00:00:57,200
也就是区分字面量或者变量
There's either literal things or variables,

17
00:00:57,232 --> 00:00:58,864
以问号开头的就是变量
and variables begin with question mark.

18
00:01:01,370 --> 00:01:03,648
因此这个模式会匹配任意的三元表
So this matches any list of three things

19
00:01:04,448 --> 00:01:06,500
只要它的首元素为'A 而第三个元素为'C
of which the first is a and the second is c.

20
00:01:06,500 --> 00:01:09,008
而这个模式匹配的三元表
This one matches any list of three things

21
00:01:10,432 --> 00:01:12,530
它的首元素必须是符号'JOB
of which the first is the symbol job.

22
00:01:12,530 --> 00:01:13,904
第二个元素为任意值
The second can be anything.

23
00:01:14,210 --> 00:01:15,904
第三个元素必须是一个二元表
And the third is a list of two things

24
00:01:15,952 --> 00:01:17,728
二元表的首元素为符号'COMPUTER
of which the first is the symbol computer

25
00:01:17,888 --> 00:01:19,424
第二个元素可以为任意值
and the second can be anything.

26
00:01:20,480 --> 00:01:25,552
而下一条模式所匹配的三元表
And this one, this next one matches any list of three things,

27
00:01:25,872 --> 00:01:26,992
区别就在于
and the only difference is,

28
00:01:28,400 --> 00:01:31,320
在于第三个元素的首元素必须为符号'COMPUTER
here, the third list, the first is the symbol computer,

29
00:01:31,760 --> 00:01:33,296
表剩余部分可以是任意值
and then there's some rest of the list.

30
00:01:35,040 --> 00:01:37,536
也就是说 上面是二元表 而下面没有限定数目
So this means two elements and this means arbitrary number.

31
00:01:37,860 --> 00:01:39,744
然而我们的语言实现
And our language implementation isn't

32
00:01:39,856 --> 00:01:42,064
根本不用操心如何去实现这个点号
isn't even going to have to worry about implementing this dot

33
00:01:42,112 --> 00:01:44,176
因为这个由Lisp读取器自动地完成
because that's automatically done by Lisp's reader.

34
00:01:48,340 --> 00:01:50,310
要注意 匹配器还要保持一致性
Remember matchers also have some consistency in them.

35
00:01:50,310 --> 00:01:52,320
这个模式匹配一个三元表
This match is a list of three things

36
00:01:52,592 --> 00:01:53,984
表的首元素是'A
of which the first is a.

37
00:01:54,430 --> 00:01:55,792
而第二个元素和第三个元素可以是任意值
And the second and third can be anything,

38
00:01:55,808 --> 00:01:57,088
但它们必须是相同的
but they have to be the same thing.

39
00:01:57,940 --> 00:01:58,848
它们都是?X
They're both called x.

40
00:01:59,600 --> 00:02:01,552
而这个模式匹配一个四元表
And this matches a list of four things

41
00:02:01,968 --> 00:02:03,264
其中第一个元素与第四个元素相同
of which the first is the fourth

42
00:02:03,664 --> 00:02:05,152
而第二个元素与第三个元素相同
and the second is the same as the third.

43
00:02:05,590 --> 00:02:08,608
最后一个模式匹配以'A开头的任意表
And this last one matches any list that begins with a.

44
00:02:09,680 --> 00:02:11,056
以'A开头
The first thing is a,

45
00:02:11,232 --> 00:02:12,560
余下的可以是任意值
and the rest can be anything.

46
00:02:14,040 --> 00:02:16,608
这是对我们已经学习过的模式匹配语言
So that's just a review of pattern matcher syntax

47
00:02:16,624 --> 00:02:17,872
的一个回顾
that you've already seen.

48
00:02:18,780 --> 00:02:19,648
还记得吗
And remember,

49
00:02:19,792 --> 00:02:22,288
这是由一个叫做MATCH的过程实现的
that's implemented by some procedure called match.

50
00:02:24,870 --> 00:02:36,064
MATCH有三个参数：PATTERN、DATA以及DICTIONARY
And match takes a pattern and some data and a dictionary.

51
00:02:43,200 --> 00:02:47,120
MATCH考虑的是
And match asks the question

52
00:02:47,790 --> 00:02:52,640
利用给定DICTIONAY中的绑定
is there any way to match this pattern against this data object

53
00:02:53,552 --> 00:02:56,736
能够找到一种方法把模式与数据对象匹配起来吗？
subject to the bindings that are already in this dictionary?

54
00:02:58,160 --> 00:02:59,216
比如说
So, for instance,

55
00:02:59,568 --> 00:03:06,432
如果我们想要把模式(?X ?Y ?Y ?X)
if we're going to match the pattern x, y, y, x

56
00:03:07,712 --> 00:03:13,840
与数据对象(A B B A)相匹配
against the data a, b, b, a

57
00:03:15,120 --> 00:03:20,528
又给定了一个字典 X=A
subject to a dictionary, that says x equals a.

58
00:03:22,010 --> 00:03:25,232
MATCH就会说：“它们是一致的”
Then the matcher would say, yes, that's consistent.

59
00:03:25,260 --> 00:03:27,168
再给定的字典说 X=A 的情况下
These match, and it's consistent

60
00:03:27,808 --> 00:03:30,208
模式与数据相匹配
with what's in the dictionary to say that x equals a.

61
00:03:30,320 --> 00:03:31,600
而匹配的结果则是
And the result of the match

62
00:03:32,256 --> 00:03:34,304
一个扩展了的词典
is the extended dictionary

63
00:03:34,464 --> 00:03:37,600
其中包含 X=A Y=B
that says x equals a and y equals b.

64
00:03:39,490 --> 00:03:42,240
MATCH接收PAT、DATA和DICTIONAY
So a matcher takes in pattern data dictionary,

65
00:03:42,384 --> 00:03:44,544
如果成功匹配就输出一个扩展后的词典
puts out an extended dictionary if it matches,

66
00:03:44,976 --> 00:03:46,840
否则就报错
or if it doesn't match, says that it fails.

67
00:03:46,840 --> 00:03:47,712
因此 比如说
So, for example,

68
00:03:47,888 --> 00:03:50,384
如果我在这里使用同样的模式
if I use the same pattern here,

69
00:03:50,976 --> 00:03:55,120
如果我用模式(?X ?Y ?Y ?X)
if I say this x, y, y, x

70
00:03:55,660 --> 00:03:58,496
去匹配(A B B A)
match a, b, b, a

71
00:03:59,470 --> 00:04:02,840
并给定词典 Y=A
with the dictionary y equals a,

72
00:04:05,152 --> 00:04:06,816
那么MATCH就会输出FAIL
then the matcher would put out fail.

73
00:04:12,528 --> 00:04:14,656
由于我们已经降解过模式匹配器的代码了
Well, you've already seen the code for a pattern matcher

74
00:04:15,008 --> 00:04:16,176
我就不会再去细讲
so I'm not going to go over it,

75
00:04:16,640 --> 00:04:19,776
这跟我们以前做的类似
but it's the same thing we've been doing before.

76
00:04:21,190 --> 00:04:23,220
我们在《基于规则的系统》中已经见过了
You saw that in the system on rule-based control.

77
00:04:23,220 --> 00:04:24,560
基本上是同样的匹配器
It's essentially the same matcher.

78
00:04:24,950 --> 00:04:27,664
实际上 我认为这里的语法还更简单一点
In fact, I think the syntax is a little bit simpler

79
00:04:28,160 --> 00:04:29,312
因为我们不用去关心
because we're not worrying about

80
00:04:29,408 --> 00:04:31,400
任意变量、任意表达式之类的东西
arbitrary constants and expressions and things.

81
00:04:31,400 --> 00:04:32,880
这里面只区分变量和常量
There's just variables and constants.

82
00:04:35,790 --> 00:04:37,328
那么 有了模式匹配器以后
OK, well, given that,

83
00:04:38,464 --> 00:04:39,610
基本查询又是怎么样的呢？
what's a primitive query?

84
00:04:42,970 --> 00:04:45,344
基本查询将会是一个相当复杂的东西
Primitive query is going to be a rather complicated thing.

85
00:04:46,672 --> 00:05:03,580
就拿查询(JOB ?X (?D . y))来说
It's going to be-- let's think about the query job of x is d dot y.

86
00:05:07,040 --> 00:05:08,736
我们可能会输入这样的查询
That's a query we might type in.

87
00:05:09,400 --> 00:05:11,392
这又将如何在系统内实现呢？
That's going to be implemented in the system.

88
00:05:14,144 --> 00:05:15,664
我们可以把它想做这个小盒子
We'll think of it as this little box.

89
00:05:15,700 --> 00:05:16,800
这是一条基本查询
Here's the primitive query.

90
00:05:18,880 --> 00:05:20,304
这个小盒子将会
What this little box is going to do

91
00:05:22,240 --> 00:05:27,280
以两条流作为输入
is take in two streams and put out a stream.

92
00:05:31,968 --> 00:05:33,200
并输出一条流
and put out a stream.

93
00:05:34,030 --> 00:05:36,192
因此一条基本查询的形状
So the shape of a primitive query

94
00:05:36,512 --> 00:05:38,464
就将是有两条输入流
is that it's a thing where two streams come in

95
00:05:38,672 --> 00:05:39,968
和一条输出流
and one stream goes out.

96
00:05:41,120 --> 00:05:46,208
而这些流 来自于这里的数据库
What these streams are going to be is down here is the database.

97
00:05:51,952 --> 00:05:53,936
因此我们把数据库中的所有数据
So we imagine all the things in the database

98
00:05:55,930 --> 00:05:57,200
想象成一条流
sort of sitting there in a stream

99
00:05:57,310 --> 00:05:58,400
而这个盒子不断地吸取
and this thing sucks on them.

100
00:06:00,368 --> 00:06:02,432
那么 数据库中有什么呢？
So what are some things that might be in the database?

101
00:06:08,432 --> 00:06:20,320
首先是(JOB (ALYSSA ...))
Oh, job of Alyssa is something

102
00:06:21,968 --> 00:06:23,712
以及还有其它的JOB数据
and some other job is something.

103
00:06:25,770 --> 00:06:30,416
想象一下 数据库中的所有事实都在这条流中
So imagine all of the facts in the database sitting there in the stream.

104
00:06:32,040 --> 00:06:33,104
都到了这里
That's what comes in here.

105
00:06:33,360 --> 00:06:36,528
而这条流送来的 是一些字典
What comes in here is a stream of dictionaries.

106
00:06:38,510 --> 00:06:41,408
其中一个就可能是
So one particular dictionary might say

107
00:06:46,704 --> 00:06:49,312
Y=PROG
might say y equals programmer.

108
00:06:55,470 --> 00:06:56,640
现在 查询工作就是要
Now, what the query does

109
00:06:57,072 --> 00:06:59,808
当它从这条流中取得一个字典后
when it gets in a dictionary from this stream,

110
00:07:02,010 --> 00:07:06,672
它会搜寻数据库中的东西
it finds all possible ways of matching the query

111
00:07:07,456 --> 00:07:10,240
尽可能产生所有匹配结果
against whatever is coming in from the database.

112
00:07:11,390 --> 00:07:12,896
它把查询视作一种模式
It looks at the query as a pattern,

113
00:07:13,152 --> 00:07:16,720
并将它们与数据库中的事实匹配起来
matches it against any fact from the database

114
00:07:16,960 --> 00:07:21,984
结合着相应的字典中的数据
or all possible ways of finding and matching the database

115
00:07:22,944 --> 00:07:25,680
找到数据库中所有匹配的结果
with respect to this dictionary that's coming in.

116
00:07:27,550 --> 00:07:29,696
所以针对数据库中的每条事实
So for each fact in the database,

117
00:07:29,728 --> 00:07:34,350
它都会调用(MATCH PAT FACT DICTIONAY)来检查
it calls the matcher using the pattern, fact, and dictionary.

118
00:07:35,110 --> 00:07:37,680
如果成功匹配
And every time it gets a good match,

119
00:07:38,192 --> 00:07:39,936
它就输出一个扩展了的字典
it puts out the extended dictionary.

120
00:07:40,672 --> 00:07:42,320
比如说 这里进来了一本字典
So, for example, if this one comes in

121
00:07:43,008 --> 00:07:44,096
并且成功匹配
and it finds a match,

122
00:07:44,512 --> 00:07:45,872
那么就会输出一本字典
out will come a dictionary

123
00:07:46,816 --> 00:07:49,792
本例中就是Y=PROGRAMER
that in this case will have y equals programmer

124
00:07:51,520 --> 00:07:52,970
X=...
nd x equals something.

125
00:07:56,544 --> 00:07:58,752
Y=PROGRAMMER X=...
y is programmer, x is something,

126
00:07:58,960 --> 00:08:00,544
D又是一个新的项
and d is whatever it found.

127
00:08:01,728 --> 00:08:02,272
像这样扩展
And that's all.

128
00:08:03,520 --> 00:08:07,824
当然 它会针对数据库中的所有事实做同样的尝试
And, of course, it's going to try this for every fact in the dictionary.

129
00:08:07,980 --> 00:08:09,250
所以就可能有很多的结果
So it might find lots of them.

130
00:08:09,568 --> 00:08:10,592
可能会产生另一本字典
It might find another one

131
00:08:11,280 --> 00:08:17,120
其中 Y=PROGRAMMER X=... D=...
that says y equals programmer and x equals, and d equals.

132
00:08:19,184 --> 00:08:21,550
因此 对于每个输入的框架
So thats, So for one frame coming in,

133
00:08:21,760 --> 00:08:23,696
对于每输入一本字典
it might put out-- for one dictionary coming in,

134
00:08:23,728 --> 00:08:25,240
它可能输出很多本字典
it might put out a lot of dictionaries,

135
00:08:26,544 --> 00:08:28,672
或者什么也不输出
or it might put out none.

136
00:08:30,470 --> 00:08:38,480
可能会有一些不匹配的情况 比如X=FOO
It might have something that wouldn't match like x equals FOO.

137
00:08:39,024 --> 00:08:40,896
这个条目不会匹配任何东西
This one might not match anything

138
00:08:41,520 --> 00:08:45,120
就这个框架来说 不会向输出流中输出东西
in which case nothing will go into this stream corresponding to this frame.

139
00:08:47,510 --> 00:08:51,280
或者你也可以输入一个空框架
Or what you might do is put in an empty frame,

140
00:08:52,910 --> 00:08:56,240
空框架是用来
and an empty frame says try matching all ways--

141
00:08:59,872 --> 00:09:02,336
在没有任何约束的情况下
find all possible ways of matching the query

142
00:09:02,576 --> 00:09:06,144
匹配数据库中所有可能的结果
against something in the database subject to no previous restrictions.

143
00:09:07,570 --> 00:09:09,168
这仅仅代表着
And if you think about what that means, that's just

144
00:09:10,320 --> 00:09:13,872
处理你输入的查询 最初所进行的计算
the computation that's done when you type in a query right off.

145
00:09:14,208 --> 00:09:15,568
它试图找出所有的匹配
It tries to find all matches.

146
00:09:16,650 --> 00:09:18,832
基本查询建立了这种机制
So a primitive query sets up this mechanism.

147
00:09:19,370 --> 00:09:20,576
而语言要做的是
And what the language does,

148
00:09:22,752 --> 00:09:24,672
当你在顶层输入这条查询时
when you type in the query at the top level,

149
00:09:24,848 --> 00:09:26,144
它基于这种机制
it takes this mechanism,

150
00:09:26,160 --> 00:09:28,352
它会输入一本空的字典
feeds in one single empty dictionary,

151
00:09:30,864 --> 00:09:32,560
而对于输出的每个东西
and then for each thing that comes out

152
00:09:33,088 --> 00:09:35,888
然后把最初的查询
takes the original query

153
00:09:36,560 --> 00:09:40,448
用不用的字典来实例化
and instantiates the result with all the different dictionaries,

154
00:09:40,816 --> 00:09:44,368
于是实例化后的模式就形成了一条新的流
producing a new stream of instantiated patterns here.

155
00:09:44,990 --> 00:09:46,512
这就是在终端上打印出来的内容
And that's what gets printed on the terminal.

156
00:09:48,170 --> 00:09:51,248
这也就是其中的基本原理
That's the basic mechanism going on there.

157
00:09:53,510 --> 00:09:55,488
那么 这又为什么复杂呢？
Well, why is that so complicated?

158
00:09:57,712 --> 00:10:01,008
当让 除了用这种遍布四处的基于流的方法
You probably can think of a lot simpler ways to arrange this match for

159
00:10:01,376 --> 00:10:04,256
你们可以想出很多更简单的方法来组织基本查询
a primitive query rather than having all of these streams floating around.

160
00:10:05,184 --> 00:10:06,096
而答案就在于
And the answer is--

161
00:10:07,152 --> 00:10:08,512
你们可能已经在想了
you probably guess already.

162
00:10:10,860 --> 00:10:14,096
答案就是 这种方法能够优雅地
The answer is this thing extends elegantly

163
00:10:14,560 --> 00:10:16,768
实现组合的方法
to implement the means of combination.

164
00:10:17,790 --> 00:10:18,800
比如说
So, for instance,

165
00:10:20,656 --> 00:10:22,470
假设我还想实现其它的效果
suppose I don't only want to do this.

166
00:10:22,470 --> 00:10:26,960
我不只是想查询所有人的工作信心
I don't want to say who to be everybody's job description.

167
00:10:27,230 --> 00:10:28,352
假设我还想查询
Suppose I want to say

168
00:10:29,472 --> 00:10:35,920
(AND (JOB ?X (?D . ?Y))
to say AND the job of x is d dot y

169
00:10:36,800 --> 00:10:47,040
(SUPERVIOSR ?X ?Z))
and the supervisor of x is z.

170
00:10:48,800 --> 00:10:50,672
(SUPERVISOR ?X ?Z)这条查询
Now, supervisor of x is z

171
00:10:51,392 --> 00:10:52,960
是另外的一条基本查询
is going to be another primitive query

172
00:10:53,712 --> 00:10:58,432
它也有类似的形状——接收一条数据对象流
that has the same shape to take in a stream of data objects,

173
00:10:59,184 --> 00:11:01,648
一条初始字典流
a stream of initial dictionaries,

174
00:11:01,680 --> 00:11:05,520
字典是你在进行匹配时 需要遵循的约束
which are the restrictions to try and use when you match,

175
00:11:05,536 --> 00:11:07,440
然后它会输出一条字典流
and it's going to put out a stream of dictionaries.

176
00:11:08,700 --> 00:11:10,800
这就是这条基本查询的形状
So that's what this primitive query looks like.

177
00:11:11,504 --> 00:11:12,910
我又该如何实现AND呢？
And how do I implement the AND?

178
00:11:12,910 --> 00:11:13,450
其实很简单
Well, it's simple.

179
00:11:13,450 --> 00:11:14,448
把它们连接起来就好了
I just hook them together.

180
00:11:14,880 --> 00:11:16,288
我把这条查询的输出
I take the output of this one,

181
00:11:16,960 --> 00:11:18,816
连接在这条查询的输入上
and I put that to the input of that one.

182
00:11:19,830 --> 00:11:21,840
然后把这里的字典扇出开来
And I take the dictionary here and I fan it out.

183
00:11:26,570 --> 00:11:27,968
你们就能发现它是如何工作的了
And then you see how that's going to work,

184
00:11:29,050 --> 00:11:32,448
这里会输出一个框架
because what's going to happen is a frame will now come in here,

185
00:11:32,512 --> 00:11:36,848
其中有X、Y和D的绑定
which has a binding for x, y, and d.

186
00:11:37,920 --> 00:11:39,280
当后面的查询接收到结果后
And then when this one gets it, it'll say,

187
00:11:39,296 --> 00:11:41,600
当它了解了这些约束后
oh, gee, subject to these restrictions,

188
00:11:42,176 --> 00:11:49,248
字典中的是Y、X和D的值
which now already have values in the dictionary for y and x and d,

189
00:11:51,808 --> 00:11:53,088
它会搜寻数据库
it looks in the database and says,

190
00:11:53,120 --> 00:11:54,928
试图找到有关SUPERVISOR关系的事实
gee, can I find any supervisor facts?

191
00:11:56,048 --> 00:11:58,510
如果找到了的话 它就会输出一些词典
And if it finds any, out will come dictionaries

192
00:11:59,584 --> 00:12:09,340
其中有Y、X、D以及Z的绑定
which have bindings for y and x and d and z now.

193
00:12:12,070 --> 00:12:14,096
不过要注意
And then notice that the match---

194
00:12:14,192 --> 00:12:17,248
因为这里输入的框架建立了约束
because the frames coming in here have these restrictions,

195
00:12:17,610 --> 00:12:20,288
它保证了当你执行AND运算时
that's the thing that assures when you do the AND,

196
00:12:20,496 --> 00:12:24,624
这两个X是相同的
this x will mean the same thing as that x.

197
00:12:26,470 --> 00:12:28,960
这是因为通过这条流输出时
Because by the time something comes floating in here,

198
00:12:29,968 --> 00:12:32,656
X已经有值了 你要确保匹配的一致性
x has a value that you have to match against consistently.

199
00:12:34,460 --> 00:12:36,176
然后我们想起在MATCH的代码中
And then you remember from the code from the matcher,

200
00:12:36,190 --> 00:12:38,176
有一种操作字典的特殊组织方法
there was something in the way the matcher did dictionaries

201
00:12:38,208 --> 00:12:39,820
确保了匹配的一致性
that arrange consistent matches.

202
00:12:40,928 --> 00:12:41,776
这就是AND的实现
So there's AND.

203
00:12:44,080 --> 00:12:46,944
关键是要注意它的一般性形状
The important point to notice is the general shape.

204
00:12:48,496 --> 00:12:51,550
我们来看看(AND P Q)
Look at what happened: the AND of two queries, say, P and Q.

205
00:12:52,880 --> 00:12:55,616
这里是P和Q
Here's P and Q.

206
00:12:57,296 --> 00:12:58,608
两条查询的AND
The AND of two queries,

207
00:13:00,272 --> 00:13:01,190
看起来像是这样
well, it looks like this.

208
00:13:01,190 --> 00:13:04,448
每一条查询都通过一条流连接数据库
Each query takes in a stream from the database,

209
00:13:04,544 --> 00:13:05,712
一条输入流
a stream of inputs,

210
00:13:06,336 --> 00:13:08,176
并输出一条输出流
and puts out a stream of outputs.

211
00:13:10,230 --> 00:13:11,728
关键是要注意
And the important point to notice

212
00:13:12,208 --> 00:13:15,024
如果我在它们周围画一个盒子
is that if I draw a box around this thing

213
00:13:19,264 --> 00:13:23,648
这就是(AND P Q)
and say this is AND of P and Q,

214
00:13:25,664 --> 00:13:30,384
那么这个盒子也有同样的形状
then that box has exactly the same overall shape.

215
00:13:32,048 --> 00:13:34,200
它也有一条连接数据库的流
It's something that takes in a stream from the database.

216
00:13:34,200 --> 00:13:35,744
但是在内部会扇出开来
Here it's going to get fanned out inside,

217
00:13:36,608 --> 00:13:37,936
但是在外部你看不到
but from the outside you don't see that.

218
00:13:38,160 --> 00:13:40,640
它接收一个流 并输出一个流
It takes an input stream and puts out an output stream.

219
00:13:42,064 --> 00:13:43,168
这就是AND
So this is AND.

220
00:13:43,570 --> 00:13:45,728
类似地 OR可能看起像这样
And then similarly, OR would look like this.

221
00:13:46,020 --> 00:13:49,584
虽然我没给你们演示过OR的用法
OR would-- although I didn't show you examples of OR.

222
00:13:49,840 --> 00:13:54,704
OR会尝试找出P或Q所有匹配的事实
OR would say can I find all ways of matching P or Q.

223
00:13:55,808 --> 00:13:58,070
P、Q两条查询都有各自的形状
So I have P and Q. Each will have their shape.

224
00:14:04,460 --> 00:14:06,688
OR的实现则是
And the way OR is implemented is

225
00:14:08,544 --> 00:14:10,912
我把来自于数据库的流
I'll take my database stream.

226
00:14:12,500 --> 00:14:13,490
扇出开来
I'll fan it out.

227
00:14:13,490 --> 00:14:16,048
把它们分别送给P和Q
I'll put one into P and one into Q.

228
00:14:17,440 --> 00:14:21,980
我把最初的查询流也给扇出开来
I'll take my initial query stream coming in and fan it out.

229
00:14:26,750 --> 00:14:29,168
这样我不但能够得到P的所有结果
So I'll look at all the answers I might get from P

230
00:14:29,296 --> 00:14:31,088
也能得到Q的所有结果
and all the answers I might get from Q,

231
00:14:31,616 --> 00:14:34,560
把这些输出送入某种“附加器”中
and I'll put them through some sort of thing that appends them

232
00:14:34,624 --> 00:14:37,488
或者把它们“合并”到一条流中
or merges the result into one stream,

233
00:14:39,648 --> 00:14:40,880
然后得到输出
and that's what will come out.

234
00:14:41,080 --> 00:14:48,240
而从外部来看 这整个东西就是OR
And this whole thing from the outside is OR.

235
00:14:52,350 --> 00:14:54,896
同样的 当你们从外部观察它时
And again, you see it has the same overall shape

236
00:14:55,072 --> 00:14:56,544
你会发现它具有相同的形状
And again, you see it has the same overall shape

237
00:15:01,000 --> 00:15:01,616
NOT又如何实现呢？
What's NOT?

238
00:15:02,020 --> 00:15:03,456
NOT的原理有些类似
NOT works kind of the same way.

239
00:15:04,310 --> 00:15:05,952
如果我有一条查询P
If I have some query P,

240
00:15:06,864 --> 00:15:13,504
这是一条基本查询P
If I have P, I take the primitive query for P.

241
00:15:14,690 --> 00:15:16,320
现在我要实现(NOT P)
Here, I'm going to implement NOT P.

242
00:15:18,688 --> 00:15:20,544
NOT的作用像是一个过滤器
And NOT's just going to act as a filter.

243
00:15:20,720 --> 00:15:21,952
这里连接数据库
I'll take in the database

244
00:15:23,840 --> 00:15:28,288
这里是输入的字典流
and my original stream of dictionaries coming in,

245
00:15:28,780 --> 00:15:31,536
(NOT P)要做的就是
and what NOT P will do is

246
00:15:31,888 --> 00:15:37,400
对这些东西做过滤
it will filter these guys.

247
00:15:39,020 --> 00:15:40,096
过滤的方法则是
And the way it will filter it,

248
00:15:40,192 --> 00:15:42,704
如果我在这里获得了一本字典
it will say when I get in a dictionary here,

249
00:15:43,424 --> 00:15:44,656
那么我就去找所有的匹配
I'll find all the matches,

250
00:15:44,832 --> 00:15:46,480
然后丢弃找到的结果
and if I find any, I'll throw it away.

251
00:15:47,460 --> 00:15:49,936
如果我没有在这里找到匹配
And if I don't find any matches to something coming in here,

252
00:15:50,128 --> 00:15:51,376
我就把它传递过去
I'll just pass that through,

253
00:15:52,400 --> 00:15:53,552
NOT就是一个纯粹的过滤器
so NOT is a pure filter.

254
00:15:55,344 --> 00:15:59,980
因此AND就类似于一个电阻
So AND is-- think of these sort of electoral resistors or something.

255
00:15:59,980 --> 00:16:01,856
AND是串行的组合
AND is series combination

256
00:16:02,496 --> 00:16:04,140
OR是并行组合
and OR is parallel combination.

257
00:16:04,960 --> 00:16:07,460
然而NOT并不会对字典做任何扩展
And then NOT is not going to extend any dictionaries at all.

258
00:16:07,460 --> 00:16:08,400
它只会做过滤
It's just going to filter it.

259
00:16:08,750 --> 00:16:11,792
它会丢弃那些能够匹配的结果
It's going to throw away the ones for which it finds a way to match.

260
00:16:12,640 --> 00:16:14,192
LISP-VALUE的原理类似
And lisp-value is sort of the same way.

261
00:16:14,848 --> 00:16:16,600
它的过滤器会复杂点
The filter's a little more complicated.

262
00:16:16,600 --> 00:16:17,376
因为要应用到谓词上
It applies to predicate.

263
00:16:19,936 --> 00:16:21,648
这里需要注意的关键点是
The major point to notice here,

264
00:16:21,920 --> 00:16:23,552
我们之前也强调过了
and it's a major point we've looked at before,

265
00:16:23,648 --> 00:16:25,296
就是关于“闭包性质”的思想
is this idea of closure.

266
00:16:28,220 --> 00:16:31,808
我们通过组合手段构建的东西
The things that we build as a means of combination

267
00:16:31,952 --> 00:16:34,512
跟所使用的基本物件
have the same overall structure

268
00:16:35,696 --> 00:16:37,584
有同样的结构
as the primitive things that we're combining.

269
00:16:39,750 --> 00:16:41,680
所以从外面看
So the AND of two things

270
00:16:41,712 --> 00:16:43,720
查询的AND与基本查询结构相同
looked at from the outside has the same shape.

271
00:16:44,630 --> 00:16:46,144
这就意味着
And what that means is that

272
00:16:46,940 --> 00:16:50,288
这里的盒子可以是AND、OR、NOT或者其它的
this box here could be an AND or an OR or a NOT or something

273
00:16:50,304 --> 00:16:54,220
因为它具有相同的形状来连接更大的东西
because it has the same shape to interface to the larger things.

274
00:16:54,950 --> 00:16:56,688
这种思想能够让我们获得
It's the same thing that allowed us to get

275
00:16:56,928 --> 00:16:58,960
Escher绘图语言中的那种复杂度
complexity in the Escher picture language

276
00:16:59,550 --> 00:17:01,312
让你能够仅仅使用序对
or allows you to immediately build up these

277
00:17:01,344 --> 00:17:03,260
构建出这些复杂结构
complicated structures just out of pairs.

278
00:17:03,936 --> 00:17:04,784
这就是“闭包性质”
It's closure.

279
00:17:06,280 --> 00:17:08,064
这种性质
And that's the thing that

280
00:17:09,648 --> 00:17:11,728
能够让我完成你们现在觉得理所当然的事儿
allowed me to do what by now you took for granted

281
00:17:11,760 --> 00:17:14,912
比如我可以查询(AND JOB SALARY)
I said, gee, there's a query which is AND of job and salary,

282
00:17:14,912 --> 00:17:18,800
当然我也可以查询(AND JOB (NOT ...))等等
and I said, oh, there's another one, which is AND of job, a NOT of something.

283
00:17:19,260 --> 00:17:20,928
这种便利是由
The fact that I can do that is

284
00:17:20,944 --> 00:17:22,910
这种“闭包原则”直接带给我们的
a direct consequence of this closure principle.

285
00:17:25,184 --> 00:17:27,080
好吧 提问时间
OK, let's break and then we'll go on.

286
00:17:29,328 --> 00:17:30,896
学生：字典是从哪里来的？
AUDIENCE: Where does the dictionary come from?

287
00:17:30,990 --> 00:17:36,032
教授：字典最初来自于你的输入
PROFESSOR: The dictionary comes initially from what you type in.

288
00:17:36,096 --> 00:17:37,328
因此当你最初进行查询时
So when you start this up,

289
00:17:39,168 --> 00:17:41,090
它首先会建立起这整个结构
the first thing it does is set up this whole structure.

290
00:17:41,090 --> 00:17:42,640
它先输入一个空字典
It puts in one empty dictionary.

291
00:17:45,000 --> 00:17:47,248
如果你只有一条基本查询的话
And if all you have is one primitive query,

292
00:17:48,240 --> 00:17:51,104
那么它就会输出一系列具有内容的字典
then what will come out is a bunch of dictionaries with things filled in.

293
00:17:52,310 --> 00:17:54,336
这里演示的一般性情况是
The general situation that I have here

294
00:17:54,512 --> 00:17:59,710
某个嵌套组合查询的中间过程
is when this is in the middle of some nest of combined things.

295
00:18:01,552 --> 00:18:02,304
所以在那时
So by the time.

296
00:18:02,380 --> 00:18:03,790
让我们来看看这里
Let's look at the picture over here.

297
00:18:04,384 --> 00:18:06,730
这条SUPERVISOR查询得到了某本字典
This supervisor query gets in some dictionary.

298
00:18:06,730 --> 00:18:08,032
这本字典来自于哪里呢？
Where did this one come from?

299
00:18:08,730 --> 00:18:11,152
它来自于
This dictionary came from the fact that

300
00:18:12,848 --> 00:18:14,896
这条基本查询的输出
I'm looking at the output of this primitive query.

301
00:18:16,260 --> 00:18:17,888
说得更具体一点
So maybe to be very specific,

302
00:18:18,352 --> 00:18:21,728
如果我最初在顶层只输入了这条查询
if I literally typed in just this query at the top level,

303
00:18:22,272 --> 00:18:22,928
这整条AND查询
this AND,

304
00:18:23,072 --> 00:18:25,280
它实际上会构建这种结构
what would actually happen is it would build this structure

305
00:18:25,500 --> 00:18:30,240
并使用一本空字典来启动整个过程
and start up this whole thing with one empty dictionary.

306
00:18:31,770 --> 00:18:34,336
处理过程开始后 会产生一系列的字典
And now this one would process, and a whole bunch of dictionaries

307
00:18:34,368 --> 00:18:37,360
其中就有X、Y以及D
would come out with x, y's and d's in them.

308
00:18:38,640 --> 00:18:39,584
向这边传递
Run it through this one.

309
00:18:40,190 --> 00:18:42,160
这就是这条查询的输入
So now that's the input to this one.

310
00:18:42,160 --> 00:18:43,728
这条查询也会生成其它的东西
This one would now put out some other stuff.

311
00:18:45,040 --> 00:18:48,224
如果这整个查询是构建在一个更大的查询中的话
And if this itself were buried in some larger thing,

312
00:18:49,312 --> 00:18:51,008
比如说一条OR查询
like an OR of something,

313
00:18:53,424 --> 00:18:55,712
那么它将输出到下一个查询中
then that would go feed into the next one.

314
00:18:58,560 --> 00:19:01,280
因此最初开始处理时 只有一本空字典
So you initially get only one empty dictionary when you start it,

315
00:19:01,680 --> 00:19:04,080
但是在处理这些复合查询的过程中
but as you're in the middle of processing these compounds things,

316
00:19:04,112 --> 00:19:06,656
会生成各种不同的字典
that's where these cascades of dictionaries start getting generated.

317
00:19:07,660 --> 00:19:12,280
学生：字典都是查询的结果吗？
AUDIENCE: Dictionaries only come about as a result of using the queries?

318
00:19:15,120 --> 00:19:17,696
它们会变成
Or do they stays, do they become--

319
00:19:18,848 --> 00:19:22,816
它们存储在数据库中吗？
do they stay someplace in space like the database does?

320
00:19:23,680 --> 00:19:24,980
它们是临时数据吗？
Are these temporary items?

321
00:19:24,980 --> 00:19:27,184
它们是在匹配过程中临时创建的
PROFESSOR: They're created temporarily in the matcher.

322
00:19:28,030 --> 00:19:29,880
但它们实际存放在内存中
Really, they're someplace in storage.

323
00:19:29,880 --> 00:19:33,024
最初 某人创建了一本THE-EMPTY-DICT字典
Initially, someone creates a thing called the empty dictionary

324
00:19:34,224 --> 00:19:36,800
送入这个匹配过程
that gets initially fed to this match procedure,

325
00:19:36,810 --> 00:19:39,056
MATCH过程据此构建新字典
and then the match procedure builds some dictionaries,

326
00:19:39,070 --> 00:19:40,272
并把它们传递下去
and they get passed on and on.

327
00:19:40,768 --> 00:19:42,480
学生：因此匹配完成后它们就被丢弃了？
AUDIENCE: OK, so they'll go way after the match?

328
00:19:43,640 --> 00:19:46,256
教授：实际上 当没人需要它们后就被废料回收了
PROFESSOR: They'll go away when no one needs them again, yeah.

329
00:19:51,900 --> 00:19:55,376
学生：似乎AND查询对数据库进行了冗余操作
AUDIENCE: It appears that the AND performs some redundant searches of the database.

330
00:19:55,960 --> 00:19:57,488
如果第一条子句扫描过了
If the first clause matched,

331
00:19:57,504 --> 00:19:59,900
比如说前两个元素没有匹配 而第三个元素匹配了
let's say, the third element and not on the first two elements,

332
00:20:00,256 --> 00:20:03,648
然而第二条子句又会检查这两个元素
the second clause is going to look at those first two elements again,

333
00:20:04,320 --> 00:20:06,592
然后又一次丢弃这些不匹配的元素
discarding them because they don't match.

334
00:20:06,640 --> 00:20:08,720
而字典中已经有匹配的项了
The match is already in the dictionary.

335
00:20:10,000 --> 00:20:12,560
如果我们把数据库中的数据
Would it makes sense to carry the data element

336
00:20:12,576 --> 00:20:14,432
也放到字典中 这样可行么？
from the database along with the dictionary?

337
00:20:15,690 --> 00:20:17,600
教授：实际上 通常来说
PROFESSOR: Yeah, there're... Well, in general,

338
00:20:17,632 --> 00:20:19,480
我们能够以其它方式来安排这些搜索
there are other ways to arrange this search,

339
00:20:20,128 --> 00:20:21,740
你也可以做一些分析
and there's some analysis that you can do.

340
00:20:21,740 --> 00:20:23,168
我记得书里面就有这样的习题
I think there's a problem in the book,

341
00:20:23,872 --> 00:20:26,656
是考察通过安排AND子句的顺序
which talks about a different way that you can cascade AND

342
00:20:27,008 --> 00:20:29,200
来消除不同类型的冗余
to eliminate various kinds of redundancies.

343
00:20:29,850 --> 00:20:30,720
而这里只是为了
This one is meant to be--

344
00:20:31,328 --> 00:20:34,544
用非常简单的情况来向你们展示它们是如何配合的
was mainly meant to be very simple so you can see how they fit together.

345
00:20:34,704 --> 00:20:35,380
但是你说得非常对
But you're quite right.

346
00:20:35,380 --> 00:20:37,328
这些冗余是可以避免的
There are redundancies here that you can get rid of.

347
00:20:38,370 --> 00:20:40,800
这也是这门语言缓慢的原因之一
That's another reason why this language is somewhat slow.

348
00:20:41,190 --> 00:20:42,704
你们可以让它变得更聪明
There are a lot smarter things you can do.

349
00:20:42,930 --> 00:20:46,224
我只是为了向你们演示非常简单的、原理性的实现
We're just trying to show you a very simple, in principle, implementation.

350
00:20:51,220 --> 00:20:53,232
学生：您是根据Prolog来建模这门语言的
AUDIENCE: Did you model this language on Prolog,

351
00:20:53,248 --> 00:20:55,136
还是说它只是偶然地像Prolog？
or did it just come out looking like Prolog?

352
00:21:04,960 --> 00:21:07,088
教授：Gerry教授昨天羞辱了一大堆人
PROFESSOR: Well, Gerry insulted a whole bunch of people yesterday,

353
00:21:07,248 --> 00:21:09,920
我想说真实的情况是
so I might as well say that the MIT attitude towards Prolog is

354
00:21:10,190 --> 00:21:12,608
MIT的研究人员在1971年做了类似的事
is something that people did in about 1971

355
00:21:12,640 --> 00:21:15,600
但是发现这个方向并不正确 并停止了研究
and decided that it wasn't really the right thing and stopped.

356
00:21:16,120 --> 00:21:22,800
因此我们是根据查询处理的基本原理建模的
So we modeled this on the sort of natural way that this thing was done

357
00:21:22,848 --> 00:21:24,730
大概在1971年左右
in about 1971,

358
00:21:25,136 --> 00:21:27,248
只是说 那时候我们还没有用流来实现
except at that point, we didn't do it with streams.

359
00:21:28,272 --> 00:21:33,040
然后我们 -- 但我们使用了它差不多六个月后
And then we... After we were using it for about six months,

360
00:21:33,080 --> 00:21:34,912
发现它存在各种各样的问题
we discovered that it had all these problems,

361
00:21:34,944 --> 00:21:36,300
稍后我会解释
some of which I'll talk about later.

362
00:21:37,330 --> 00:21:38,192
然后我们就想
And we said,

363
00:21:38,448 --> 00:21:39,920
Prolog一定解决了这些问题
gee, Prolog must have fixed those,

364
00:21:39,930 --> 00:21:41,216
但却发现它并没有
and then we found out that it didn't.

365
00:21:41,250 --> 00:21:43,024
从这种意义上来说 它确实跟Prolog一样
So this does about the same thing as Prolog.

366
00:21:43,600 --> 00:21:44,950
学生：Prolog基于流么？
AUDIENCE: Does Prolog use streams?

367
00:21:44,950 --> 00:21:46,200
教授：不 Prolog基于的是
PROFESSOR: No. Prolog --

368
00:21:46,784 --> 00:21:51,040
就行为上来说 我们的语言很像Prolog
In how it behaves, it behaves a lot like Prolog.

369
00:21:51,040 --> 00:21:52,960
Prolog使用回溯策略
Prolog uses a backtracking strategy.

370
00:21:53,800 --> 00:21:55,712
但是Prolog有一个优点非常好
But the other thing that's really good about Prolog

371
00:21:55,728 --> 00:21:57,984
也使得它变得实用
that makes it a usable thing

372
00:21:58,280 --> 00:22:01,504
你知道吗
is that there's a really very, very

373
00:22:01,680 --> 00:22:04,090
它们精心设计了Prolog的编译器
there's a really very, very well-engineered compiler technology

374
00:22:04,112 --> 00:22:05,328
使得它能够高速运行
that makes it run fast.

375
00:22:06,656 --> 00:22:10,816
因此 虽然我们这门语言非常缓慢地输出答案
So although you saw the merge spitting out these answers very, very slowly,

376
00:22:11,664 --> 00:22:13,616
真正的Prolog程序却运行得非常快
a real Prolog will run very, very fast.

377
00:22:14,704 --> 00:22:16,480
这是因为 尽管搜索过程十分低效
Because even though it's sort of doing this,

378
00:22:16,670 --> 00:22:20,816
Prolog卓越的编译器也会高校地完成工作
the real work that went into Prolog is a very, very excellent compiler effort.

379
00:22:24,304 --> 00:22:25,216
休息一下吧
Let's take a break.

380
00:23:16,650 --> 00:23:18,832
我们已经考察过了基本查询
We've looked at the primitive queries

381
00:23:19,216 --> 00:23:23,520
以及如何使用流来实现组合的手段
and the ways that streams are used to implement the means of combination:

382
00:23:23,792 --> 00:23:25,728
AND、OR以及NOT
AND and OR and NOT.

383
00:23:26,950 --> 00:23:28,432
现在 该讨论抽象的手段了
Now, let go on to the means of abstraction.

384
00:23:29,580 --> 00:23:32,800
回想一下 我们这门语言的抽象手段是RULE
Remember, the means of abstraction in this language are rules.

385
00:23:35,150 --> 00:23:37,792
(BOSS ?Z ?D)描述的是
So z is a boss in division d

386
00:23:39,184 --> 00:23:43,776
如果某人在D部门工作
if there's some x who has a job in division d

387
00:23:45,680 --> 00:23:47,472
并且Z是X的上司
and z is the supervisor of x.

388
00:23:48,900 --> 00:23:50,608
这就是所谓的“BOSS”
That's what it means for someone to be a boss.

389
00:23:52,260 --> 00:23:53,152
并且 实际上
So, and in effect,

390
00:23:53,344 --> 00:23:55,616
如果我们考察一下编写的规则与这边的关系
if you think about what we're doing with relation to this,

391
00:23:56,800 --> 00:23:57,904
这是我们编写的查询
there's the query we wrote--

392
00:23:57,936 --> 00:24:01,900
这个是(JOB ?X ?D) 而这个是(SUPERVISOR ?X ?Z)
the job of x is in d and the supervisor of x is z--

393
00:24:02,192 --> 00:24:04,288
我们实际想要把这一大堆东西
what we in effect want to do is take this whole mess

394
00:24:05,072 --> 00:24:06,576
用一个盒子封装起来
and draw a box around it

395
00:24:19,080 --> 00:24:24,544
然后把这个盒子里的所有东西
and say this whole thing inside the box

396
00:24:25,152 --> 00:24:32,480
认为是(BOSS ?Z ?D)
is boss of z in division d.

397
00:24:33,900 --> 00:24:35,250
这是我们想要达到的效果
That's in effect what we want to do.

398
00:24:38,720 --> 00:24:39,728
因此 比如说
So, for instance,

399
00:24:43,184 --> 00:24:44,080
我们这样做了过后
if we've done that,

400
00:24:45,008 --> 00:24:47,840
我们想要检查
and we want to check whether or not it's true

401
00:24:47,952 --> 00:24:50,512
Ben Bitdiddle是否为计算机分部的BOSS
that Ben Bitdiddle is a boss in the computer division,

402
00:24:51,104 --> 00:25:02,864
如果我想查询 (BOSS (BITDIDDLE BEN) COMPUTER)
so if I want to say boss of Ben Bitdiddle in the computer division,

403
00:25:04,784 --> 00:25:07,088
想象一下把这条查询输入系统
imagine typing that in as query to the system,

404
00:25:07,120 --> 00:25:09,168
实际上发生的是
in effect what we want to do

405
00:25:10,672 --> 00:25:12,928
在这里先构建一本字典
is set up a dictionary here,

406
00:25:15,820 --> 00:25:23,632
其中 Z=BITDIDDLE
which has z to Ben Bitdiddle

407
00:25:28,880 --> 00:25:33,310
D=COMPUTER
and d to computer.

408
00:25:37,088 --> 00:25:38,624
这个字典又是来自于哪里呢？
Where did that dictionary come from?

409
00:25:38,688 --> 00:25:40,710
我们来看下幻灯片
Let's look at the slide for one second.

410
00:25:40,710 --> 00:25:43,712
这本字典是通过把
That dictionary came from matching the query

411
00:25:44,304 --> 00:25:46,336
查询(BOSS (BITDIDDLE BEN) COMPUTER)
that said boss of Ben Bitdiddle and computer

412
00:25:46,512 --> 00:25:49,632
与规则的结论(BOSS ?Z ?D)相匹配得到
onto the conclusion of the rule: boss of z and d.

413
00:25:51,650 --> 00:25:54,112
所以我们把规则的结论和查询匹配了起来
So we match the query to the conclusion of the rule.

414
00:25:54,190 --> 00:25:55,536
这样我们就获得了一本字典
That gives us a dictionary,

415
00:25:58,992 --> 00:26:02,544
现在我们就要把这本字典输入到这整个结构中
and that's the thing that we would now like to put into this whole big thing

416
00:26:02,928 --> 00:26:05,568
进行处理 并观察是否有输出
and process and see if anything comes out the other side.

417
00:26:06,670 --> 00:26:09,888
如果输出了结果 那么查询就为真
If anything comes out, it'll be true.

418
00:26:11,330 --> 00:26:12,370
这是基本的思想
That's the basic idea.

419
00:26:12,370 --> 00:26:13,248
因此 通常来说
So in general,

420
00:26:14,032 --> 00:26:15,408
我们实现规则的方法就是
the way we implement a rule

421
00:26:15,856 --> 00:26:18,896
用规则的结论去匹配
is we match the conclusion of the rule

422
00:26:20,864 --> 00:26:22,960
假设为真的查询
against something we might want to check it's true.

423
00:26:23,580 --> 00:26:25,120
这个过程会产生一本字典
That match gives us a dictionary,

424
00:26:25,296 --> 00:26:28,224
在有了相关字典后
and with respect to that dictionary,

425
00:26:30,352 --> 00:26:34,512
我们来处理规则的体
we process the body of the rule.

426
00:26:36,336 --> 00:26:37,680
基本上就是这样了
Well, that's really all there is,

427
00:26:38,640 --> 00:26:41,440
但还有两个技术点
except for two technical points.

428
00:26:43,040 --> 00:26:44,320
首先就是
The first technical point is that

429
00:26:45,744 --> 00:26:47,264
我也可能有其它的问法
I might have said something else.

430
00:26:47,510 --> 00:26:48,416
比如说
I might have said

431
00:26:50,544 --> 00:26:52,368
查询计算机分部的BOSS
who's the boss in the computer division?

432
00:26:52,544 --> 00:26:56,320
就可以查询 (BOSS ?WHO COMPUTER)
So I might say boss of who in computer division.

433
00:27:00,784 --> 00:27:01,632
这样做了以后
And if I did that,

434
00:27:02,576 --> 00:27:04,624
我真正想要做的
what I would really like to do in effect is not

435
00:27:05,040 --> 00:27:06,496
就是先建立一本字典
is start up this dictionary

436
00:27:08,352 --> 00:27:09,888
其中有一些约束
with a match that sort of says,

437
00:27:09,936 --> 00:27:11,200
比如 D=COMPUTER
well, d is computer

438
00:27:14,352 --> 00:27:18,480
而?Z是任意值
and z is whatever who is.

439
00:27:21,700 --> 00:27:23,220
我们的匹配器不会那么做
And our matcher won't quite do that.

440
00:27:23,220 --> 00:27:27,008
这不是模式和数据的匹配方式
That's not quite matching a pattern against data.

441
00:27:28,580 --> 00:27:29,728
这是在匹配两个模式
It's matching two patterns

442
00:27:29,744 --> 00:27:31,584
并判断它们是否一致
sort of saying are they consistent or not

443
00:27:31,904 --> 00:27:33,480
又是什么使它们不一致
or what ways make them consistent.

444
00:27:33,480 --> 00:27:36,432
换句话说 我们需要的不是一个模式匹配器
In other words, what we need is not quite a pattern matcher,

445
00:27:36,960 --> 00:27:38,912
而是一种更一般性的东西
but something a little bit more general

446
00:27:39,136 --> 00:27:40,112
就是“合一”算法
called a unifier.

447
00:27:44,420 --> 00:27:48,064
“合一”是更为一般化的模式匹配算法
And a unifier is a slight generalization of a pattern matcher.

448
00:27:49,530 --> 00:27:52,176
合一算法接收两条模式
What a unifier does is take two patterns

449
00:27:53,232 --> 00:27:57,536
它考虑的是：可以找到哪些一般性的元素
and say what's the most general thing you can substitute

450
00:27:58,208 --> 00:28:00,016
用来代换模式中的变量
for the variables in those two patterns

451
00:28:02,688 --> 00:28:05,088
使得它俩能够同时满足
to make them satisfy the pattern simultaneously?

452
00:28:05,680 --> 00:28:06,608
让我来举个例子
Let me give you an example.

453
00:28:08,864 --> 00:28:14,490
我有一个含有两个元素的模式：(?X ?X)
If I have the pattern two-element list, which is x and x,

454
00:28:15,760 --> 00:28:17,152
它描述的是一个二元表
so this is I have a two-element list

455
00:28:17,320 --> 00:28:18,640
不管元素具体是什么
where both elements are the same

456
00:28:18,672 --> 00:28:20,040
但两个元素是相同的
and otherwise I don't care what they are,

457
00:28:20,400 --> 00:28:22,832
我把它与另一个模式进行“合一”
and I unify that against the pattern

458
00:28:22,920 --> 00:28:24,624
后者描述的是一个二元表
that says there's a two-element list,

459
00:28:24,656 --> 00:28:27,616
首元素一张由'A、任意值、C构成的表
and the first one is a and something and c

460
00:28:28,000 --> 00:28:30,144
而第二个元素是由'A、'B、任意值构成的表
and the second one is a and b and z,

461
00:28:33,070 --> 00:28:34,880
那么 合一算法能够告诉我
then what the unifier should tell me is,

462
00:28:34,896 --> 00:28:36,176
在生成的字典中
oh yeah, in that dictionary,

463
00:28:36,352 --> 00:28:37,968
?X必须是(A B C)
x has to be a, b, c,

464
00:28:39,344 --> 00:28:41,920
?Y必须为B ?Z必须为C
and y has to be d and z has to be c.

465
00:28:43,440 --> 00:28:46,288
这些是我必须对X、Y以及Z施加的约束
Those are the restrictions I'd have to put on the values of x, y, and z

466
00:28:46,336 --> 00:28:47,580
以便让两个模式合一
to make these two unify,

467
00:28:48,120 --> 00:28:50,848
或者换句话来说 让它匹配这个?X
or in other words, to make this match x

468
00:28:51,152 --> 00:28:53,370
让它匹配这个?X
and make this match x.

469
00:28:55,280 --> 00:28:57,760
合一算法需要能够推断出这些
The unifier should be able to deduce that.

470
00:28:58,540 --> 00:29:01,080
但是合一算法也会遇到复杂的情况
But the unifier may-- there are more complicated things.

471
00:29:01,080 --> 00:29:03,072
我可能会询问一些复杂的查询
I might have said something a little bit more complicated.

472
00:29:03,488 --> 00:29:05,744
比如这是一个二元表
I might have said there's a list with two elements,

473
00:29:07,008 --> 00:29:08,288
其中的元素都是相同的
and they're both the same,

474
00:29:08,864 --> 00:29:11,152
它要与这个模式进行合一
and they should unify against something of this form.

475
00:29:12,650 --> 00:29:15,360
合一算法也要能够从中推断出
And the unifier should be able to deduce from that.

476
00:29:16,890 --> 00:29:19,570
?Y必须为B
Like that y would have to be b. y would have to be b.

477
00:29:19,570 --> 00:29:22,128
因为这两个是一样的
Because these two are the same,

478
00:29:22,224 --> 00:29:23,520
因此?Y就是B
so y's got to be b.

479
00:29:24,340 --> 00:29:27,536
这里 ?V应该为A
And v here would have to be a.

480
00:29:28,940 --> 00:29:30,992
只要?Z和?W取值相同
And z and w can be anything,

481
00:29:31,008 --> 00:29:32,432
它们就可以是任意值
but they have to be the same thing.

482
00:29:35,710 --> 00:29:41,760
?X就应该是(B A ?W) 其中?W为任意值
And x would have to be b, followed by a, followed by whatever w

483
00:29:42,832 --> 00:29:44,680
或者是?Z -- 因为?Z和?W是一致的
or whatever z is, which is the same.

484
00:29:44,704 --> 00:29:49,420
发现了么？ 合一算法需要从这些模式中推断出信息
So you see, the unifier somehow has to deduce things to unify these patterns.

485
00:29:50,880 --> 00:29:53,520
所以你们可能认为 这其中有某种魔法般的推理
So you might think there's some kind of magic deduction going on,

486
00:29:54,272 --> 00:29:55,232
但其实并不是
but there's not.

487
00:29:55,850 --> 00:29:59,888
合一算法基本上只是对模式匹配的小小修改
A unifier is basically a very simple modification of a pattern matcher.

488
00:30:00,150 --> 00:30:01,856
如果你们翻阅教材 就会发现
And if you look in the book, you'll see something like

489
00:30:02,256 --> 00:30:06,160
在模式匹配算法中加入了三到四行代码
like three or four lines of code added to the pattern matcher you just saw

490
00:30:06,496 --> 00:30:08,176
来处理对称的情况
to handle the symmetric case.

491
00:30:08,280 --> 00:30:10,816
还记得吗？模式匹配中有一处代码判断
Remember, the pattern matcher has a place where it says

492
00:30:11,664 --> 00:30:14,288
这个变量匹配一个常量吗？
is this variable matching a constant.

493
00:30:14,980 --> 00:30:16,420
如果是的话 就在字典中进行检查
And if so, it checks in the dictionary.

494
00:30:16,420 --> 00:30:18,256
在合一算法中只有另一条子句
There's only one other clause in the unifier,

495
00:30:18,496 --> 00:30:20,752
它判断两个变量是否相匹配
which says is this variable matching a variable,

496
00:30:22,000 --> 00:30:23,424
这种情况下你去查询字典
in which case you go look in the dictionary

497
00:30:23,456 --> 00:30:25,680
看它们在字典的约束下是否一致
and see if that's consistent with what's in the dictionary.

498
00:30:27,030 --> 00:30:31,136
因此 这门语言中的所有“推断”
So all the, quote, deduction that's in this language,

499
00:30:31,280 --> 00:30:34,590
你会发现它蕴含在规则应用中
if you sort of look at it, sort of sits in the rule applications,

500
00:30:34,992 --> 00:30:37,888
更进一步地考察 你会发现在合一算法中
which, if you look at that, sits in the unifier,

501
00:30:38,368 --> 00:30:40,320
如果更进一步地用“显微镜”观察
which, if you look at that under a microscope,

502
00:30:40,560 --> 00:30:43,968
基本上就在模式匹配算法中
sits essentially in the pattern matcher.

503
00:30:44,944 --> 00:30:47,072
这其中并没有什么魔法
There's no magic at all going on in there.

504
00:30:47,410 --> 00:30:50,256
而你们所见到的“推断”
And the, quote, deduction that you see

505
00:30:50,944 --> 00:30:52,896
只是因为其中的递归
is just the fact that there's this recursion,

506
00:30:52,928 --> 00:30:55,696
它一点一点地回绕MATCH过程
which is unwinding the matches bit by bit.

507
00:30:56,030 --> 00:30:58,032
它让这个过程看起来很聪明
So it looks like this thing is being very clever,

508
00:30:58,448 --> 00:31:00,368
但它实际上并不是那么聪明
but in fact, it's not being very clever at all.

509
00:31:02,140 --> 00:31:04,416
当然 合一算法需要聪明地识别出一些情况
There are cases where a unifier might have to be clever.

510
00:31:04,880 --> 00:31:05,872
我来举个例子吧
Let me show you one more.

511
00:31:11,070 --> 00:31:13,360
假设我想要用一个二元表进行合一
Suppose I want to unify a list of two elements,

512
00:31:13,488 --> 00:31:14,816
(?X ?X)
x and x,

513
00:31:17,240 --> 00:31:22,144
另一个模式则是 (?Y (a . ?Y))
with a thing that says it's y followed by a dot y.

514
00:31:24,370 --> 00:31:26,128
现在 如果你想一想它所表达的意思
Now, if you think of what that would have to mean,

515
00:31:26,864 --> 00:31:29,712
它表示了?X应该跟?Y一致
it would have to mean that x had better be the same as y,

516
00:31:30,928 --> 00:31:31,664
同时呢
but also

517
00:31:31,824 --> 00:31:36,160
?X又应该跟(A . ?Y)相同
x had better be the same as a list whose first element is a and whose rest is y.

518
00:31:37,330 --> 00:31:39,456
如果你自习思考它成立的条件
And if you think about what that would have to mean,

519
00:31:42,272 --> 00:31:44,710
你会发现 ?Y必须是一个由A构成的无穷表
it would have to mean that y is the infinite list of a's.

520
00:31:47,500 --> 00:31:48,352
从某种角度来说
In some sense,

521
00:31:49,216 --> 00:31:52,400
为了完成这样的合一
in order to do that unification,

522
00:31:52,608 --> 00:31:54,848
我需要求解一个不动点方程
I have to solve the fixed-point equation

523
00:31:55,056 --> 00:32:01,840
(CONS 'A Y)=Y
cons of a to y is equal to y.

524
00:32:04,570 --> 00:32:06,960
通常来说 --- 我这个例子很简单
And in general, I wrote a very simple one.

525
00:32:07,290 --> 00:32:08,672
但实际进行合一时
Really doing unification

526
00:32:08,976 --> 00:32:11,984
我们可能要求解一个任意的不动点方程
might have to solve an arbitrary fixed-point equation:

527
00:32:12,016 --> 00:32:13,424
(F Y)=Y
f of y equals y.

528
00:32:15,530 --> 00:32:17,088
你基本上不能保证
And basically, you can't do that

529
00:32:17,104 --> 00:32:19,472
总能够找到有限的解
and make the thing finite all the time.

530
00:32:20,570 --> 00:32:23,600
我们的逻辑语言又该如何处理这类情况呢？
So how does the logic language handle that?

531
00:32:24,896 --> 00:32:26,480
答案就是：“不处理”
The answer is it doesn't.

532
00:32:27,168 --> 00:32:28,048
#TBD
It just punts.

533
00:32:28,730 --> 00:32:31,072
合一算法中有一处小检查
And there's a little check in the unifier,

534
00:32:31,312 --> 00:32:33,824
用来判断是否为困难的情况
which says, oh, is this one of the hard cases

535
00:32:34,448 --> 00:32:38,000
也就是 匹配这些东西需要求解不动点方程
which when I go to match things would involve solving a fixed-point equation?

536
00:32:38,650 --> 00:32:40,816
遇到这类情况 我就撒手不干
And in this case, I will throw up my hands.

537
00:32:42,840 --> 00:32:44,656
如果不进行这样的检查
And if that check were not in there,

538
00:32:45,008 --> 00:32:45,888
会发生什么情况？
what would happen?

539
00:32:47,990 --> 00:32:49,104
大多数情况就是
In most cases is

540
00:32:49,136 --> 00:32:51,312
合一算法会陷入无穷循环
that the unifier would just go into an infinite loop.

541
00:32:53,740 --> 00:32:56,544
其它的逻辑语言有类似的工作原理
And other logic programming languages work like that.

542
00:32:56,800 --> 00:32:58,144
因此这其中没有什么魔法
So there's really no magic.

543
00:32:58,220 --> 00:32:59,936
简单的情况由匹配器完成
The easy case is done in a matcher.

544
00:33:00,100 --> 00:33:01,584
困难的情况根本不去处理
The hard case is not done at all.

545
00:33:02,960 --> 00:33:05,472
这就是这种技术的现状
And that's about the state of this technology.

546
00:33:11,888 --> 00:33:14,240
现在 我来形式化地描述一下
OK, Let me just say again formally

547
00:33:14,272 --> 00:33:16,384
规则系统的运行原理 -- 也就是合一算法
how rules work now that I talked about unifiers.

548
00:33:17,390 --> 00:33:18,752
因此 正式的定义就是
So the official definition

549
00:33:19,200 --> 00:33:20,960
应用一条规则
is that to apply a rule,

550
00:33:24,176 --> 00:33:27,136
我们需要使用一些之前的术语
we-- well, let's start using some words we've used before.

551
00:33:28,270 --> 00:33:32,016
#TBD
Let's talk about sticking dictionaries into

552
00:33:32,880 --> 00:33:34,784
#TBD
these big boxes of query things

553
00:33:34,816 --> 00:33:38,544
#TBD
as evaluating these large queries

554
00:33:39,952 --> 00:33:43,850
#TBD
relative to an environment or a frame.

555
00:33:43,850 --> 00:33:45,040
因此 当我们谈及“字典”的时候
So when you think of that dictionary,

556
00:33:45,072 --> 00:33:46,280
“字典”究竟是什么？
what's the dictionary after all?

557
00:33:46,720 --> 00:33:48,180
它是符号的一系列语义
It's a bunch of meanings for symbols.

558
00:33:48,180 --> 00:33:50,224
我们把它叫做“框架”或者“环境”
That's what we've been calling frames or environments.

559
00:33:51,800 --> 00:33:55,970
根据环境进行操作 又是什么？
What does it mean to do some processing relevant to an environment?

560
00:33:55,970 --> 00:33:57,424
我们把这个叫做“求值”
That's what we've been calling evaluation.

561
00:33:58,336 --> 00:34:01,560
因此我们就说 应用一条规则的方法是
So we can say the way that you apply a rule

562
00:34:01,920 --> 00:34:06,160
先通过将给定的查询与规则的结论合一 得到环境
is to evaluate the rule body relative to an environment

563
00:34:06,672 --> 00:34:11,580
在再该环境中求值相应规则的体
that's formed by unifying the rule conclusion with the given query.

564
00:34:13,230 --> 00:34:14,512
我想要让你们注意的是
And the thing I want you to notice

565
00:34:14,800 --> 00:34:17,088
这非常像是
is the complete formal similarity

566
00:34:18,160 --> 00:34:21,504
元循环求值器以及代换模型
to the net of circular evaluator or the substitution model.

567
00:34:21,630 --> 00:34:22,736
规则的应用就是
To apply a procedure,

568
00:34:22,860 --> 00:34:28,368
在一个环境中求值规则的体
we evaluate the procedure body relative to an environment

569
00:34:28,544 --> 00:34:33,136
环境是通过将实际参数与形式参数绑定起来得到的
that's formed by blinding the procedure parameters to the arguments.

570
00:34:34,560 --> 00:34:36,416
规则、规则的应用、过程的应用
There's a complete formal similarity there

571
00:34:36,440 --> 00:34:40,416
它们在形式上完全相似
between the rules, rule application, and procedure application

572
00:34:40,576 --> 00:34:42,304
尽管它们又非常不同
even though these things are very, very different.

573
00:34:43,650 --> 00:34:45,616
再一次地出现了EVAL-APPLY循环
And again, you have the EVAL APPLY loop.

574
00:34:47,290 --> 00:34:49,520
EVAL-APPLY
EVAL and APPLY.

575
00:34:53,392 --> 00:34:57,390
因此通常来说 我们可能会处理一些复合表达式
So in general, I might be processing some combined expression

576
00:34:57,424 --> 00:34:59,136
它们会变成规则的应用
that will turn into a rule application,

577
00:35:00,704 --> 00:35:03,280
进一步又会产生字典、框架或者环境
which will generate some dictionaries or frames or environments--

578
00:35:03,312 --> 00:35:04,720
不管你要怎么叫它
whatever you want to call them-- from match,

579
00:35:05,024 --> 00:35:08,432
它们随后又会作为某个大的复合对象的输入
which will then be the input to some big compound thing like this.

580
00:35:08,660 --> 00:35:11,776
这有它的一部分 并可能有其它规则的应用
This has pieces of it and may have other rule applications.

581
00:35:13,580 --> 00:35:15,680
这基本上就是相同的循环
And you have essentially the same cycle

582
00:35:15,720 --> 00:35:18,688
尽管这里没有什么东西看起来像过程
even though there's nothing here at all that looks like procedures.

583
00:35:19,680 --> 00:35:21,872
这是因为我们创建的语言
It really has to do with the fact you've built a language

584
00:35:22,080 --> 00:35:25,490
它们的组合手段和抽象手段以某种方式展开
whose means of combination and abstraction unwind in certain ways.

585
00:35:28,770 --> 00:35:29,520
通常来说
And then in general,

586
00:35:29,776 --> 00:35:31,392
最顶层所发生的是
what happens at the very top level,

587
00:35:33,792 --> 00:35:35,968
数据库中也有一些规则
you might have rules in your database also,

588
00:35:36,656 --> 00:35:38,704
数据库中的数据也可能是规则
so things in this database might be rules.

589
00:35:40,460 --> 00:35:42,064
它们用来检查对象是否为真
There are ways to check that things are true.

590
00:35:42,920 --> 00:35:44,896
所以这里可能会有规则检查
So it might come in here and have to do a rule check.

591
00:35:46,750 --> 00:35:48,160
然后就会有一些控制结构
And then there's some control structure

592
00:35:48,192 --> 00:35:50,480
用来判断你访问的是规则
which says, well, you look at some rules, and you look at some data elements,

593
00:35:50,512 --> 00:35:51,808
还是数据元素
and you look at some rules and data elements,

594
00:35:51,840 --> 00:35:53,120
然后不断地把它们扇出来开
and these fan out and out and out.

595
00:35:53,350 --> 00:35:55,488
所以基本上不可能说清楚
So it becomes essentially impossible

596
00:35:55,680 --> 00:35:57,696
是用什么样的顺序来查询这些东西的
to say what order it's looking at these things in,

597
00:35:58,208 --> 00:36:00,272
是广度优先还是深度优先
whether it's breadth first or depth first or anything.

598
00:36:00,280 --> 00:36:01,648
另外一个原因是
And it's even more impossible

599
00:36:01,664 --> 00:36:05,584
我们通过惰性流隐藏了实际执行顺序
because the actual order is somehow buried in the delays of the streams.

600
00:36:07,696 --> 00:36:11,168
因此很难说清楚它的扫描顺序
So what's very hard to tell from this is the order in which it's scanned.

601
00:36:11,270 --> 00:36:12,160
但真实的是
But what's true is,

602
00:36:12,192 --> 00:36:13,648
由于你是在流视图观察它的
because you're looking at the stream view,

603
00:36:13,904 --> 00:36:15,820
#TBD
is that all of them eventually get looked at.

604
00:36:24,980 --> 00:36:28,150
这里还有一个小小的技术问题
Let me just mention one tiny technical problem.

605
00:36:37,530 --> 00:36:41,008
假设我输入(BOSS ?Y COMPUTER)
Suppose I tried saying boss of y is computer,

606
00:36:44,224 --> 00:36:45,780
然后就会发生一件有意思的事儿
then a funny thing would happen.

607
00:36:45,780 --> 00:36:50,256
这里的字典就有一项?Y
As I stuck a dictionary with y in here,

608
00:36:52,736 --> 00:36:57,376
而这两个?Y是不相同的
I might get-- this y is not the same as that y,

609
00:36:57,424 --> 00:37:00,624
后者是其它人的工作描述
which was the other piece of somebody's job description.

610
00:37:01,580 --> 00:37:03,808
因此 按照输入“照本宣科”地执行的话
So if I really only did literally what I said,

611
00:37:04,224 --> 00:37:06,448
我们就会遇到变量冲突的问题
we'd get some variable conflict problems.

612
00:37:09,280 --> 00:37:10,480
所以我骗了你们一下
So I lied to you a little bit.

613
00:37:10,930 --> 00:37:13,840
注意 我们之前也遇到过同样的问题
Notice that problem is exactly a problem we've run into before.

614
00:37:14,270 --> 00:37:15,568
具体来说就是
It is precisely

615
00:37:15,968 --> 00:37:18,360
一门语言需要局部变量
the need for local variables in a language.

616
00:37:19,240 --> 00:37:21,744
当我计算SQUARE和SUM-SQUARES的时候
When I square, when I have the sum of squares,

617
00:37:21,792 --> 00:37:23,390
这两个X应该是不同的
that x had better not be that x.

618
00:37:24,960 --> 00:37:26,320
同样的道理
That's exactly the same as

619
00:37:27,392 --> 00:37:29,776
这两个Y应该也不相同
as this y had better not be that y.

620
00:37:31,800 --> 00:37:32,752
我们知道该如何解决
And we know how to solve that.

621
00:37:32,784 --> 00:37:34,490
就是引入环境模型
We built -- That was this whole environment model,

622
00:37:34,512 --> 00:37:37,040
我们构建类类似于“框架链”一类的东西
and we built chains of frames and all sorts of things like that.

623
00:37:37,710 --> 00:37:39,104
还有更加“粗暴”的解决方法
There's a much more brutal way to solve it.

624
00:37:39,104 --> 00:37:41,730
在查询语言中 我们根本不这么做
In the query language, we didn't even do that.

625
00:37:41,730 --> 00:37:43,184
我们的解决方法非常粗暴
We did something completely brutal.

626
00:37:43,540 --> 00:37:45,936
我们规定 每次你在应用一条规则的时候
We said every time you apply a rule,

627
00:37:47,264 --> 00:37:49,632
用一个不会引起冲突的唯一名字
rename consistently all the variables in the rule

628
00:37:49,776 --> 00:37:53,504
统一地为规则中的所有变量更名
to some new unique names that won't conflict with anything.

629
00:37:54,040 --> 00:37:57,104
这个从概念上来说更简单
If you looked at the -- That's conceptually simpler,

630
00:37:57,120 --> 00:37:59,240
但既粗暴 又不是很有效
but really brutal and not particularly efficient.

631
00:37:59,970 --> 00:38:01,152
但是请注意
But notice,

632
00:38:01,392 --> 00:38:04,688
如果我们对Lisp中定义的过程也这么处理
we could have gotten rid of all of our environment structures

633
00:38:05,500 --> 00:38:08,720
那么就不需要环境模型了
if we defined for procedures in Lisp the same thing.

634
00:38:08,752 --> 00:38:11,560
如果我们每次在应用一个过程的时候
If every time we applied a procedure and did the substitution model

635
00:38:11,872 --> 00:38:13,904
我们为过程中的所有变量更名
we renamed all the variables in the procedure,

636
00:38:14,192 --> 00:38:16,288
那么我们就不需要担心局部变量了
then we never would have had to worry about local variables

637
00:38:16,336 --> 00:38:17,392
因为它们不会出现
because they would never arise.

638
00:38:19,040 --> 00:38:20,416
但这种做法比较低效
OK, well, that would be inefficient,

639
00:38:20,912 --> 00:38:23,040
在我们的查询语言中同样也比较低效
and it's inefficient here in the query language, too,

640
00:38:23,296 --> 00:38:24,592
但我们还是这样做了 并让它保持简单
but we did it to keep it simple.

641
00:38:25,610 --> 00:38:26,672
有问题吗？
Let's break for questions.

642
00:38:30,880 --> 00:38:33,392
学生：您这一小节开始的时候
AUDIENCE: When you started this section,

643
00:38:33,408 --> 00:38:39,600
就强调APPLY-EVAL模型是多么的强大
you emphasized how powerful our APPLY EVAL model was

644
00:38:39,632 --> 00:38:41,170
以至于任何语言都适用
that we could use it for any language.

645
00:38:41,170 --> 00:38:43,392
但你又说这门语言将会非常不同
And then you say we're going to have this language which is so different.

646
00:38:43,950 --> 00:38:45,136
但最后却发现这门语言
It turns out that this language,

647
00:38:45,584 --> 00:38:47,880
就像你指出的那样--也是同样的
as you just pointed out, is very much the same.

648
00:38:47,880 --> 00:38:49,856
我在想 您是否是在论证
I'm wondering if you're arguing that all languages end up

649
00:38:50,480 --> 00:38:54,576
所有的语言都可以转化成 规则或过程的应用
coming down to this you can apply a rule or apply a procedure

650
00:38:55,120 --> 00:38:55,984
或者类似的
or some kind of apply?

651
00:38:57,072 --> 00:38:58,880
教授：可以说 几乎所有语言
PROFESSOR: I would say that pretty much any language

652
00:38:58,928 --> 00:39:00,304
我们通过组合手段构建对象
where you really are building up

653
00:39:00,928 --> 00:39:04,400
用简单的名字给它们命名
these means of combination and giving them simpler names

654
00:39:04,704 --> 00:39:06,864
你可以把任何类似的 比如
and you're saying anything of the sort, like

655
00:39:07,790 --> 00:39:09,900
有一种一般性的表达式
here's a general kind of expression,

656
00:39:09,984 --> 00:39:11,408
比如说如何计算某数的平方
like how to square something,

657
00:39:12,032 --> 00:39:14,208
几乎所有的东西都可以称为“过程”
almost anything that you would call a procedure.

658
00:39:14,880 --> 00:39:15,888
如果语言中有这么一部分的话
If that's got to have parts,

659
00:39:15,904 --> 00:39:17,248
那么你就需要能够展开它们
you have to unwind those parts.

660
00:39:18,020 --> 00:39:20,192
你需要有某种组织 使得
You have to have some kind of organization which says

661
00:39:20,570 --> 00:39:24,032
当你查看这些抽象变量 或者说标签的时候
when I look at the abstract variables or tags

662
00:39:24,064 --> 00:39:27,100
它们可能代表着某些特定的东西
or whatever you want to call them that might stand for particular things,

663
00:39:28,336 --> 00:39:29,344
你必须一直跟踪它们
you have to keep track of that,

664
00:39:29,392 --> 00:39:30,912
这就会形成类似于环境的结构
and that's going to be something like an environment.

665
00:39:31,720 --> 00:39:32,544
让后当你要
And then if you say

666
00:39:32,704 --> 00:39:35,264
展开复合对象其中的一个部分的时候
this part can have parts which I have to unwind,

667
00:39:35,808 --> 00:39:37,440
你就需要EVAL-APPLY循环了
you've got to have something like this cycle.

668
00:39:39,970 --> 00:39:43,200
有很多很多的语言有这样的特点
And lots and lots of languages have that character

669
00:39:43,360 --> 00:39:45,408
它们也是按这种方式组织的
as long ... when they sort of get put together in this way.

670
00:39:45,590 --> 00:39:47,200
而这门语言特殊之处在于
This language again really is different

671
00:39:47,216 --> 00:39:49,504
从外界看 并没有“过程”
because there's nothing like procedures on the outside.

672
00:39:50,690 --> 00:39:52,688
而当你剖开表层 深入到实现中去
When you go below the surface and you see the implementation,

673
00:39:52,704 --> 00:39:54,240
当然 你会发现本质是一样的
of course, it starts looking the same.

674
00:39:54,870 --> 00:39:56,950
但是从外界来看 这是一种非常不同的世界观
But from the outside, it's a very different world view.

675
00:39:56,950 --> 00:39:58,544
你没有计算输入的函数
You're not computing functions of inputs.

676
00:40:03,970 --> 00:40:05,712
学生：您之前提到过
AUDIENCE: You mentioned earlier that

677
00:40:06,608 --> 00:40:09,552
当用模式匹配来实现这些规则时
when you build all of these rules in pattern matcher

678
00:40:10,010 --> 00:40:11,424
由于使用了流实现延迟求值
and with the delayed action of streams,

679
00:40:11,456 --> 00:40:12,720
所以没有办法知道
you really have no way to know

680
00:40:13,376 --> 00:40:15,360
对象的求值顺序
in what order things are evaluated.

681
00:40:15,584 --> 00:40:15,940
教授：是这样的
PROFESSOR: Right.

682
00:40:15,940 --> 00:40:18,288
学生：但这就表明
AUDIENCE: And that would indicate then that

683
00:40:18,940 --> 00:40:22,288
我们只能表达总是为真的陈述性知识
you should only express declarative knowledge that's true for all-time,

684
00:40:22,304 --> 00:40:23,790
语言并不支持时间序列
no-time sequence built into it.

685
00:40:23,950 --> 00:40:25,472
否则的话 后果就会--
Otherwise, these things get all--

686
00:40:27,390 --> 00:40:28,768
教授：是的 非常正确
PROFESSOR: Yes. Yes.

687
00:40:28,820 --> 00:40:29,488
问题在于
The question is

688
00:40:30,064 --> 00:40:32,608
这个本来就是用来处理陈述性知识的
this really is set up for doing declarative knowledge,

689
00:40:33,264 --> 00:40:34,816
而就我目前所演示的来说 不支持
and as I presented it-- no

690
00:40:35,712 --> 00:40:39,568
休息之后我会向你们揭露这其中的丑陋之处
and I'll show you some of the ugly warts under this after the break.

691
00:40:40,830 --> 00:40:42,608
就如我目前所展示的 它只是进行逻辑运算
As I presented it, it's just doing logic.

692
00:40:43,070 --> 00:40:44,528
原理上来说 如果我们做的是逻辑运算
And in principle, if it were logic,

693
00:40:44,544 --> 00:40:46,810
用什么顺序完成并不会造成影响
it wouldn't matter what order it's getting done.

694
00:40:48,840 --> 00:40:51,552
但是呢
And it's quite true

695
00:40:51,600 --> 00:40:53,616
当你在进行一些具有副作用的操作的时候
when you start doing things where you have side effects

696
00:40:53,680 --> 00:40:55,200
比如向数据库中添加项
like adding things to the database

697
00:40:55,230 --> 00:40:58,160
从中取出项 等等操作
and taking things out, and we'll see some others,

698
00:40:58,752 --> 00:41:00,832
你就丧失了这类控制
you loose that kind of control.

699
00:41:01,290 --> 00:41:02,940
因此 这就与Prolog完全不同
So, for example, contrasting with Prolog.

700
00:41:02,940 --> 00:41:05,152
Prolog有各种功能
Say Prolog has various features

701
00:41:05,168 --> 00:41:07,792
能够让你利用求值的顺序
where you really exploit the order of evaluation.

702
00:41:09,640 --> 00:41:11,770
人们也这么来写Prolog
And people write Prolog programs that way.

703
00:41:11,770 --> 00:41:14,048
结果发现这样变得非常困难
That turns out to be very complicated in Prolog,

704
00:41:14,320 --> 00:41:17,552
但如果你是Prolog程序专家 你就可以这么做
although if you're an expert Prolog programmer, you can do it.

705
00:41:18,590 --> 00:41:20,210
但是我认为你们现在并不可以
However, here I don't think you can do it at all.

706
00:41:20,210 --> 00:41:21,248
它相当复杂
It's very complicated

707
00:41:21,728 --> 00:41:23,648
因为你们放弃了对事先安排的
because you really are giving up control over

708
00:41:23,776 --> 00:41:25,728
求值顺序的控制权
any prearranged order of trying things.

709
00:41:27,150 --> 00:41:30,160
学生：这就表明 当你有一个函数式映射时
AUDIENCE: Now, that would indicate then that you have a functional mapping.

710
00:41:30,670 --> 00:41:32,512
而你最初在讲这门课的时候
And when you started out this lecture,

711
00:41:32,992 --> 00:41:34,080
你说过
you said that

712
00:41:34,672 --> 00:41:36,704
我们在表述作为关系的陈述性知识
we express the declarative knowledge which is a relation,

713
00:41:37,152 --> 00:41:38,810
因为我们讨论的不是输入和输出
and we don't talk about the inputs and the outputs.

714
00:41:41,216 --> 00:41:43,370
教授：这是关于“函数式”的双关语
PROFESSOR: Well, there's a pun on functional, right?

715
00:41:43,370 --> 00:41:45,792
一种是没有副作用
There's functional in the sense of no side effects

716
00:41:46,208 --> 00:41:48,160
因此并不依赖于求值的顺序
and not depending on what order is going on.

717
00:41:48,700 --> 00:41:51,040
还有就是数学意义上的“函数”
And then there's functional in the sense of mathematical function,

718
00:41:51,072 --> 00:41:52,220
有关于输入和输出
which means input and output.

719
00:41:52,592 --> 00:41:54,368
我想这就是你想表达的双关
And it's just that pun that you're making, I think.

720
00:41:56,510 --> 00:41:58,512
学生：我对其中两条语句不太明白
AUDIENCE: I'm a little unclear on what you're doing with

721
00:41:58,816 --> 00:42:00,704
也就是那两条有关BOSS的语句
two statements, the two boss statements.

722
00:42:01,270 --> 00:42:05,744
是不是 第一条查询构建了一个数据库
Is the first one building up the database

723
00:42:05,760 --> 00:42:08,080
然后第二条查询--
and the second one a query or--

724
00:42:09,072 --> 00:42:10,128
教授：抱歉
PROFESSOR: OK, I'm sorry.

725
00:42:12,440 --> 00:42:15,168
这里的意思是 如果我输入这样的查询
What I meant here, if I type something like this in as a query--

726
00:42:16,128 --> 00:42:18,448
我应该最初就给你们举这个例子
I should have given an example way at the very beginning.

727
00:42:19,470 --> 00:42:23,520
如果我输入(JOB (BITDIDDLE BEN) (COMPUTER WIZARD))
If I type in job, Ben Bitdiddle, computer wizard,

728
00:42:25,040 --> 00:42:27,770
系统会找到一处事实
what the processing will do is if it finds a match,

729
00:42:28,304 --> 00:42:30,288
来完全匹配这条查询
it'll find a match to that exact thing,

730
00:42:30,864 --> 00:42:33,280
然后输出(JOB (BITDIDDLE BEN) (COMPUTER WIZARD))
and it'll type out a job, Ben Bitdiddle, computer wizard.

731
00:42:34,220 --> 00:42:35,600
如果没找到这样的匹配
If it doesn't find a match,

732
00:42:35,696 --> 00:42:36,752
它就什么也不输出
it won't find anything.

733
00:42:37,400 --> 00:42:39,552
我应该这么来表述
So what I should have said is the way

734
00:42:39,568 --> 00:42:42,272
这门语言是用来查询某个表述是否为真
you use the query language to check whether something is true,

735
00:42:43,408 --> 00:42:45,776
这是逻辑式编程的目的之一
that's one of the things you want to do in logic programming,

736
00:42:46,416 --> 00:42:49,344
输入一条查询 要么得到结果 要么没有
is you type in your query and either that comes out or it doesn't.

737
00:42:50,680 --> 00:42:52,384
因此 我这里想要演示的是
So what I was trying to illustrate here,

738
00:42:52,416 --> 00:42:54,800
我想要在介绍合一算法前
I wanted to start with a very simple example

739
00:42:54,832 --> 00:42:56,624
举一个简单的例子
before talking about unifiers.

740
00:42:57,480 --> 00:42:58,112
所以 我应该说
So what I should have said,

741
00:42:58,144 --> 00:43:00,960
如果我想要检查 这个是否为真
if I just wanted to check whether this is true,

742
00:43:01,184 --> 00:43:03,280
我就可以将它输入 并看有没有任何输出
I could type that in and see if anything came out

743
00:43:05,168 --> 00:43:06,272
学生：然后第二条查询
AUDIENCE: And then the second one--

744
00:43:06,288 --> 00:43:07,840
教授：第二条就是真正意义上的“查询”
PROFESSOR: The second one would be a real query.

745
00:43:07,888 --> 00:43:09,120
学生：好的 真正的查询
AUDIENCE: A real query, yeah.

746
00:43:10,770 --> 00:43:13,104
教授：在这里它就会输出#TBD
PROFESSOR: What would come out, see, it would go in here say with WHO,

747
00:43:13,904 --> 00:43:15,744
#TBD
and in would go frame that says z

748
00:43:16,624 --> 00:43:18,816
?Z=?WHO ?D=COMPUTER
z is bound to who and d is bound to computer.

749
00:43:19,560 --> 00:43:20,496
这个会传递下去
And this will pass through,

750
00:43:20,512 --> 00:43:21,952
传递到这里的时候
and then by the time it got out of here,

751
00:43:22,016 --> 00:43:23,250
?WHO就会被绑定起来
who would pick up a binding.

752
00:43:26,950 --> 00:43:28,768
学生：在合一那里
AUDIENCE: On the unifying thing there,

753
00:43:29,180 --> 00:43:35,968
我还是不太清楚?WHO和?Z之间发生了什么
I still am not sure what happens with who and z.

754
00:43:36,460 --> 00:43:39,584
要进行合一的话 这里的规则说
OK being unifying-- the rule here says--

755
00:43:42,032 --> 00:43:46,224
你说过 两个模式变量之间不能互相绑定
OK, so you say that you can't make question mark equal to question mark who.

756
00:43:46,260 --> 00:43:48,080
教授：模式匹配器确实不能这样
PROFESSOR: Right. That's what the matcher can't do.

757
00:43:48,360 --> 00:43:50,832
但对合一算法来说
But unifier, what this will mean to a unifier

758
00:43:51,920 --> 00:43:54,016
就是一个有存储三个变量的环境
is that there's an environment with three variables.

759
00:43:56,690 --> 00:43:57,904
其中?D=COMPUTER
d here is computer.

760
00:43:58,520 --> 00:44:00,192
?Z=?WHO
z is whatever who is.

761
00:44:01,830 --> 00:44:05,264
所以在稍后的匹配过程中
So if later on in the matcher routine

762
00:44:07,200 --> 00:44:10,384
如果?WHO=3
it said, for example, who has to be 3,

763
00:44:12,064 --> 00:44:13,664
那么当我再查找字典的时候
then when I looked up in the dictionary,

764
00:44:14,000 --> 00:44:16,400
它会告诉我 因为?Z=?WHO 所以?Z=3
it will say, oh, z is 3 because it's the same as who.

765
00:44:18,360 --> 00:44:20,448
从某种意义上来说 你就只需要修改这一点
And that's in some sense the only thing you need to do

766
00:44:20,464 --> 00:44:21,984
就可以把合一算法变成模式匹配器
to extend the unifier to a matcher.

767
00:44:22,480 --> 00:44:24,800
学生：但是看起来你好像告诉了它 如何进行合一
AUDIENCE: OK, because it looked like when you were telling how to unify,

768
00:44:24,830 --> 00:44:26,960
就像你已经解好了方程 准备好了值
it looked like you would put the things together in such a way

769
00:44:26,992 --> 00:44:29,232
并把它们安排成这样
that you'd actually solve and have a value for both of them.

770
00:44:29,770 --> 00:44:31,248
现在看起来就像是
And what it looks like now

771
00:44:31,280 --> 00:44:32,832
你传递了一本字典
is that you're actually pass a dictionary

772
00:44:32,880 --> 00:44:34,860
其中的两个变量是关联起来的
with two variables and the variables are linked.

773
00:44:34,880 --> 00:44:37,230
教授：实际上 我们在同时求解它们
PROFESSOR: Right. It only looks like you're solving for both of them

774
00:44:37,520 --> 00:44:39,744
这是因为我们想要一下得到整个答案
because you're sort of looking at the whole solution at once.

775
00:44:40,540 --> 00:44:42,816
如果你观察它们是如何被递归地构建的
If you sort of watch the thing getting built up recursively,

776
00:44:42,816 --> 00:44:43,740
基本上就是这样了
it's merely this.

777
00:44:44,980 --> 00:44:48,400
学生：也就是确实要传递含有两个变量的字典？
AUDIENCE: OK, so you do pass off that dictionary with two variables?

778
00:44:48,400 --> 00:44:49,110
教授：是的
PROFESSOR: That's right.

779
00:44:49,110 --> 00:44:49,680
学生：然后把它们关联起来？
AUDIENCE: And link?

780
00:44:50,384 --> 00:44:52,912
教授：就像通常的字典那样
PROFESSOR: Right. It just looks like an ordinary dictionary.

781
00:44:54,352 --> 00:44:56,064
学生：你在讨论合一算法的时候
AUDIENCE: When you're talking about the unifier,

782
00:44:56,096 --> 00:45:00,192
你说过在某些情况下
is it that there are some cases or some points

783
00:45:00,752 --> 00:45:03,984
合一不能够完成
that you are not able to unify them?

784
00:45:04,032 --> 00:45:04,304
教授：是的
PROFESSOR: Right.

785
00:45:04,970 --> 00:45:08,464
学生：那么 是否可以通过编写规则
AUDIENCE: Can you just by building the rules or

786
00:45:09,160 --> 00:45:15,936
或者 写入那些事先知道可解的形式
writing the forms know in advance if you are going to be able to solve

787
00:45:16,480 --> 00:45:18,540
来使得合一算法能够完成
to get the unification or not?

788
00:45:18,768 --> 00:45:22,944
是否可以在规则中添加一些属性
Can you add some properties either to the rules itself

789
00:45:23,184 --> 00:45:25,456
或者向输入的形式中添加属性
or to the form that you're writing

790
00:45:25,824 --> 00:45:29,040
来避免无法进行合一的窘境
so that you avoid the problem of not finding unification?

791
00:45:29,180 --> 00:45:31,152
PROFESSOR: 我想 你可以同意
Well I mean, you can agree,

792
00:45:31,472 --> 00:45:35,264
#TBD
I think, to write in a fairly restricted way where you won't run into it.

793
00:45:35,600 --> 00:45:36,672
#TBD
See, because what you're getting--

794
00:45:36,880 --> 00:45:39,120
仔细看 你遇到问题是在
see, the place where you get into problems is when you--

795
00:45:39,680 --> 00:45:44,256
用像这样的东西去匹配
well, again, you're trying to match things like that

796
00:45:44,592 --> 00:45:47,200
具有这样结构的模式时
against things where these have structure,

797
00:45:47,552 --> 00:45:55,300
比如((A ?Y B) ?Y)
where a, y, b, y something.

798
00:45:58,980 --> 00:46:01,488
这是你可能遇到问题的一个地方
So this is the kind of place where you're going to get into trouble.

799
00:46:03,070 --> 00:46:05,808
学生：所以你可以在语法层次上处理它么？
AUDIENCE: So you can do that syntactically?

800
00:46:06,140 --> 00:46:08,768
教授：你可以在写查询时
PROFESSOR: So you can kind of watch your rules

801
00:46:08,768 --> 00:46:10,490
注意你的规则
in the kinds of things that your writing.

802
00:46:11,904 --> 00:46:14,080
学生：这个问题应该由
AUDIENCE: So that's the problem that the builder

803
00:46:14,112 --> 00:46:16,272
数据库的构建者考虑么？
of the database has to be concerned?

804
00:46:16,576 --> 00:46:17,808
教授：这个问题
PROFESSOR: That's a problem.

805
00:46:19,930 --> 00:46:22,016
不完全是数据库的构建者
It's a problem either-- not quite the builder of the database,

806
00:46:22,048 --> 00:46:23,616
或者是表述规则的人
the person who is expressing the rules,

807
00:46:24,016 --> 00:46:25,312
所需要考虑的
or the builder of the database.

808
00:46:25,800 --> 00:46:29,792
当你们仔细审查合一算法的代码时
What the unifier actually does is you can check at the next level down

809
00:46:29,920 --> 00:46:31,872
你们会发现
when you actually get to the unifier

810
00:46:32,416 --> 00:46:34,768
它实际上在查询一个字典
and you'll see in the code where it looks up in the dictionary.

811
00:46:34,940 --> 00:46:36,832
它会问 ?Y的取值应该是什么？
If it sort of says what does y have to be?

812
00:46:37,260 --> 00:46:41,424
?Y应该是一个含有自包含的表达式么？
Oh, does y have to be something that contains a y as its expression?

813
00:46:41,960 --> 00:46:43,264
这时候 合一算法就会说
At that point, the unifier and say,

814
00:46:43,280 --> 00:46:46,240
哦 我正在求解一个不动点方程
oh my God, I'm trying to solve a fixed-point equation.

815
00:46:46,240 --> 00:46:46,992
我还是放弃吧
I'll give it up here.

816
00:46:48,592 --> 00:46:51,910
学生：你区分过数据库中的规则
AUDIENCE: You make the distinction between the rules in the database.

817
00:46:51,910 --> 00:46:56,480
这些规则是加入数据库的么？
Are the rules added to the database?

818
00:46:56,950 --> 00:46:57,360
教授：是的
PROFESSOR: Yes.

819
00:46:57,870 --> 00:46:58,870
我应该这么来说
Yes, I should have said that.

820
00:46:58,870 --> 00:47:00,336
你们可以把规则看作
One way to think about rules

821
00:47:00,608 --> 00:47:02,656
数据库中的其它东西
is that they're just other things in the database.

822
00:47:03,712 --> 00:47:06,810
如果你想要检查数据库中需要检查的东西
So if you want to check the things that have to be checked in the database,

823
00:47:06,832 --> 00:47:09,440
它们就是存在于数据库中的虚拟事实
they're kind of virtual facts that are in the database.

824
00:47:09,440 --> 00:47:12,320
学生：但是在这个解释中
AUDIENCE: But in that explanation, you made the differentiation

825
00:47:12,432 --> 00:47:17,264
你就已经区分了数据库和规则本身
between database and the rules itself.

826
00:47:18,230 --> 00:47:19,904
教授：是的 我应该不这么来说
PROFESSOR: Yeah, I probably should not have done that.

827
00:47:20,490 --> 00:47:23,312
这样做的唯一理由就是实现
The only reason to do that is in terms of the implementation.

828
00:47:23,540 --> 00:47:24,672
当你们查看具体实现时
When you look at the implementation,

829
00:47:24,680 --> 00:47:27,504
会发现其中有部分用来检查数据库中的
there's a part which says check either primitive

830
00:47:27,552 --> 00:47:29,850
基本断言或者规则
assertions in the database or check rules.

831
00:47:30,470 --> 00:47:32,720
这其中的真正原因就是
And then the real reason, the real reason why

832
00:47:32,780 --> 00:47:34,560
你不知道查询结果是以什么顺序输出的
you can't tell what order things are going to come out in

833
00:47:34,960 --> 00:47:40,460
而规则数据库和数据数据库
is that the rules database and the data database

834
00:47:40,480 --> 00:47:43,680
是通过某种延迟求值的方式合并的
sort of get merged in a kind of delayed evaluation way.

835
00:47:44,600 --> 00:47:46,800
这就使得顺序变得非常复杂
And so that's what makes the order very complicated.

836
00:47:55,440 --> 00:47:56,096
那好 我们休息一下
OK, let's break.

837
00:48:33,160 --> 00:48:35,376
我们已经学习了逻辑式语言与
We've just seen how the logic language works

838
00:48:35,392 --> 00:48:36,416
规则系统的运行原理
and how rules work.

839
00:48:37,230 --> 00:48:39,376
现在 让我们来探讨一个更加深刻的问题
Now, let's turn to a more profound question.

840
00:48:40,120 --> 00:48:41,280
来看下它们意味着什么？
What do these things mean?

841
00:48:43,180 --> 00:48:46,864
这把我们带入到整查询语言中
That brings us to the subtlest, most devious part

842
00:48:46,992 --> 00:48:48,672
最微妙的部分
of this whole query language business,

843
00:48:49,216 --> 00:48:53,070
也就是它看起来与想象中不同的地方
and that is that it's not quite what it seems to be.

844
00:48:53,570 --> 00:48:56,224
AND、OR以及NOT
AND and OR and NOT

845
00:48:57,024 --> 00:48:58,880
以及规则的逻辑蕴含
and the logical implication of rules

846
00:48:59,696 --> 00:49:06,640
并不是逻辑学中的与、或、非以及蕴含
are not really the AND and OR and NOT and logical implication of logic.

847
00:49:07,690 --> 00:49:09,712
让我来举一个实例
Let me give you an example of that.

848
00:49:09,910 --> 00:49:12,224
当然 如果我们有两个逻辑命题
Certainly, if we have two things in logic,

849
00:49:12,400 --> 00:49:19,440
那么(AND P Q)就应该
it ought to be the case that AND of P and Q

850
00:49:20,000 --> 00:49:22,592
等同于(AND Q P)
is the same as AND of Q and P

851
00:49:23,100 --> 00:49:24,510
而(OR P Q)就应该
and that OR of P and Q

852
00:49:24,780 --> 00:49:26,510
等同于(OR Q P)
is the same as OR of Q and P.

853
00:49:28,672 --> 00:49:30,096
但我们来看看这里
But let's look here.

854
00:49:30,100 --> 00:49:32,016
这里是一个例子
Here's an example.

855
00:49:32,180 --> 00:49:36,160
来看看 在我们的数据库中
Let's talk about somebody outranking somebody else

856
00:49:36,288 --> 00:49:40,140
如何表示某人的级别高于他人
in this our little database organization.

857
00:49:40,140 --> 00:49:42,896
我们定义(OUTRANKED-BY ?S ?D)为
We'll say s is outranked by b

858
00:49:44,640 --> 00:49:48,624
或者?S是?D的上司
if or if either the supervisor of s is b

859
00:49:49,630 --> 00:49:51,072
或者这其中有某个中间经理?M
or there's some middle manager here,

860
00:49:51,104 --> 00:49:55,820
其中?S是?M的上司 ?M的级别又比?B高
that supervisor of s is m, and m is outranked by b.

861
00:49:59,648 --> 00:50:02,310
这是定义OUTRANKED-BY的一种方式
So there's one way to define rule outranked by.

862
00:50:02,310 --> 00:50:04,160
或者我们可以原封不动地写过来
Or we can write exactly the same thing,

863
00:50:05,088 --> 00:50:06,912
除了在最底部的这里
except at the bottom here,

864
00:50:07,216 --> 00:50:09,888
我们颠倒一下这两个子句的顺序
we reversed the order of these two clauses.

865
00:50:11,630 --> 00:50:12,992
当然 如果它们都是逻辑表达式的话
And certainly if this were logic,

866
00:50:13,008 --> 00:50:14,880
它们应该表示的是相同的东西
those ought to mean the same thing.

867
00:50:16,690 --> 00:50:17,312
然而
However,

868
00:50:17,712 --> 00:50:19,616
在我们这个特定的实现中
in our particular implementation,

869
00:50:19,648 --> 00:50:22,880
如果你查询(OUTRANDKED-BY ?WHO (BITDIIDLE BEN))
if you say something like who's outranked by Ben Bitdiddle,

870
00:50:23,488 --> 00:50:25,360
你会发现
what you'll find is that this rule

871
00:50:26,768 --> 00:50:28,720
这条规则会完美地生成答案
will work perfectly well and generate answers,

872
00:50:30,048 --> 00:50:31,984
然而 这条规则会陷入无穷循环
whereas this rule will go into an infinite loop.

873
00:50:34,110 --> 00:50:36,272
其中的原因就是
And the reason for that is that

874
00:50:36,336 --> 00:50:40,336
这条规则会问谁比BEN BITDIDDLE级别高？
this will come in and say, oh, who's outranked by Ben Bitdiddle?

875
00:50:41,920 --> 00:50:43,536
它试图寻找一个?S
Find an s, find an s

876
00:50:43,888 --> 00:50:46,224
使得?S比?B的级别更高 其中?B是BEN BITDIDDLE
which is outranked by b, where b is Ben Bitdiddle,

877
00:50:47,504 --> 00:50:49,632
这会在一个子问题中重复出现
which is going to happen in it a subproblem.

878
00:50:50,330 --> 00:50:51,984
找到一个?M
Oh gee, find an m

879
00:50:52,240 --> 00:50:54,576
使得?M的级别高于BEN BITDIDDLE
such as m is outranked by Ben Bitdiddle

880
00:50:55,616 --> 00:50:57,360
而对?M没有限制
with no restrictions on m.

881
00:50:58,560 --> 00:51:00,400
这就相当于为了解决这个问题
So this will say in order to solve this problem,

882
00:51:01,424 --> 00:51:03,296
我就还需要求解同样的问题
I solve exactly the same problem.

883
00:51:04,570 --> 00:51:07,232
在把它解出来后 我才检查SUPERVISOR关系
And then after I've solved that, I'll check for a supervisory relationship.

884
00:51:08,000 --> 00:51:09,168
然而这条规则没有这样的问题
Whereas this one won't get into that,

885
00:51:09,184 --> 00:51:12,350
因为在它尝试找出这条OUTRANKED-BY规则之前
because before it tries to find this outranked by,

886
00:51:12,944 --> 00:51:15,260
在这里已经对?M施加过约束了
it'll already have had a restriction on m here.

887
00:51:18,384 --> 00:51:20,944
随意 这两条规则理论上是相同的
So these two things which ought to mean the same,

888
00:51:20,992 --> 00:51:22,672
但实际上 其中一条会陷入无穷循环
in fact, one goes into an infinite loop.

889
00:51:22,860 --> 00:51:25,040
而另一条不会
One goes, one does not.

890
00:51:26,720 --> 00:51:29,776
通过这个非常极端的例子
That's a very extreme case

891
00:51:29,790 --> 00:51:32,656
你会发现在逻辑式程序设计中
of a general thing that you'll find in logic programming that

892
00:51:34,288 --> 00:51:38,704
如果你改变了AND或OR所连接子句的顺序
if you start changing the order of the things in the ANDs or ORs,

893
00:51:39,344 --> 00:51:41,584
你会发现效率上的巨大差异
you'll find tremendous differences in efficiency.

894
00:51:42,240 --> 00:51:43,216
我们刚刚就看到了
And we just saw

895
00:51:43,552 --> 00:51:46,544
在无穷循环方面的巨大差异
an infinitely big difference in efficiency and an infinite loop.

896
00:51:49,190 --> 00:51:51,744
同样的 这也跟输入规则
And there are similar things having to do order

897
00:51:52,000 --> 00:51:53,312
的顺序有关
in which you enter rules.

898
00:51:54,070 --> 00:51:56,480
向数据库查询规则的顺序
The order in which it happens to look at rules in the database

899
00:51:56,700 --> 00:51:59,952
会极大程度上影响效率：比如得到答案
may vastly change the efficiency with which it gets out answers or,

900
00:52:00,464 --> 00:52:02,608
或者在某些顺序下陷入无穷循环
in fact, send it into an infinite loop for some orderings.

901
00:52:03,840 --> 00:52:07,296
这些都跟
And this whole thing has to do

902
00:52:07,632 --> 00:52:10,048
你检查这些规则的顺序有关
the fact that you're checking these rules in some order.

903
00:52:10,950 --> 00:52:14,416
有些规则的蕴含路径会相当的长
And some rules may lead to really long paths of implication.

904
00:52:14,448 --> 00:52:16,064
而另外一些不会
Others might, others might not.

905
00:52:16,440 --> 00:52:17,680
但你事先并不知道
And you don't know a priori

906
00:52:17,728 --> 00:52:19,168
哪一个长 哪一个短
which ones are good and which ones are bad.

907
00:52:19,300 --> 00:52:21,488
有很多研究都与此有关
And there's a whole bunch of research having to do with that,

908
00:52:22,160 --> 00:52:23,760
其中大多数都是想通过
mostly having to do with thinking about

909
00:52:23,952 --> 00:52:26,970
用并行的方法来实现逻辑式程序设计语言
making parallel implementations of logic programming languages.

910
00:52:27,320 --> 00:52:29,904
某种意义上来说 就是并行地检查所有规则
And in some sense, what you'd like to do is check all rules in parallel

911
00:52:30,360 --> 00:52:32,800
一旦有一条搜索得到答案 就返回结果
and whichever ones get answers, you bubble them up. And

912
00:52:33,040 --> 00:52:34,992
如果某条路径陷入了无穷的推导
if some go down infinite deductive chain,

913
00:52:35,020 --> 00:52:38,256
那么 你只需知道 内存和处理器都非常廉价
well, you just-- you know, memory is cheap and processors are cheap,

914
00:52:38,288 --> 00:52:40,490
让它们根据你的需要一直搜寻就好了
you just let them buzz for as for as long as you want.

915
00:52:43,472 --> 00:52:44,832
尽管如此 这门逻辑式语言与真正的逻辑相比
There's a deeper problem, though,

916
00:52:45,184 --> 00:52:50,496
还有一个更深刻的问题
in comparing this logic language to real logic.

917
00:52:50,688 --> 00:52:52,528
我给你们演示的例子
The example I just showed you, it

918
00:52:52,976 --> 00:52:54,800
只是会陷入无穷循环
went into an infinite loop maybe,

919
00:52:55,376 --> 00:52:56,992
但至少不会给你错误的答案
but at least it didn't give the wrong answer.

920
00:52:58,370 --> 00:53:03,648
当我们开始严肃地把这门逻辑式语言
There's an actual deeper problem when we start comparing,

921
00:53:03,680 --> 00:53:05,240
与真正的经典逻辑作比较时
you know, seriously comparing

922
00:53:05,712 --> 00:53:08,464
就会发现其中最深层次的问题
this logic language with real classical logic.

923
00:53:09,490 --> 00:53:12,432
让我们来看看真正的经典逻辑
So let's sort of review real classical logic.

924
00:53:13,712 --> 00:53:21,040
所有的人类都是凡人
All humans are mortal.

925
00:53:22,352 --> 00:53:23,456
相当经典的逻辑命题
That's pretty classical logic.

926
00:53:24,390 --> 00:53:28,672
然后我们就依照最经典的传统
Then maybe we'll continue in the very best classical tradition.

927
00:53:29,248 --> 00:53:32,464
我们按照最传统的方式来做
We'll say all-- let's make it really classical.

928
00:53:32,670 --> 00:53:37,168
所有的希腊人都是人类
All Greeks are human,

929
00:53:40,496 --> 00:53:46,064
苏格拉底是希腊人
which has the syllogism that Socrates is a Greek.

930
00:53:48,176 --> 00:53:49,210
然后我们又该写什么呢？
And then what do you write here?

931
00:53:49,210 --> 00:53:51,890
经典逻辑中有一个三点符号
I think three dots, classical logic.

932
00:53:51,890 --> 00:53:54,336
因此 我们得到了一个三段论
Therefore, then the syllogism,

933
00:53:54,640 --> 00:53:59,552
苏格拉底是凡人
Socrates is mortal.

934
00:54:01,360 --> 00:54:04,912
这些都是真正的经典逻辑
So there's some real honest classical logic.

935
00:54:05,880 --> 00:54:11,056
把它跟我们经典逻辑数据库比较一下
Let's compare that with our classical logic database.

936
00:54:12,400 --> 00:54:14,464
这是一个经典逻辑数据库
So here's a classical logic database.

937
00:54:16,270 --> 00:54:17,488
(GREEK SOCRATES)
Socrates is a Greek.

938
00:54:18,030 --> 00:54:18,848
(GREEK PLATO)
Plato is a Greek.

939
00:54:19,600 --> 00:54:20,400
(GREEK ZEUS)
Zeus is a Greek,

940
00:54:20,848 --> 00:54:21,984
(GOD ZEUS)
and Zeus is a god.

941
00:54:24,120 --> 00:54:29,968
所有的人类都是凡人
And all humans are mortal.

942
00:54:30,540 --> 00:54:32,128
为了证明某人是平凡的
To show that something is mortal,

943
00:54:32,160 --> 00:54:33,600
只需要证明他是人类
it's enough to show that it's human.

944
00:54:34,650 --> 00:54:35,900
所有的人类都是不可靠的
All humans are fallible.

945
00:54:38,900 --> 00:54:40,980
并且说所有的希腊人都是人类 并不正确
And all Greeks are humans is not quite right.

946
00:54:40,980 --> 00:54:44,416
这条规则说 所有不是神的希腊人都是人类
This says that all Greeks who are not gods are human.

947
00:54:45,710 --> 00:54:47,040
因此为了证明某人是人类
So to show something's human,

948
00:54:47,072 --> 00:54:48,896
只需要说明他是一个希腊人 并且不是神
it's enough to show it's a Greek and not a god.

949
00:54:49,320 --> 00:54:52,880
任何一个希腊神的住址是奥林匹斯山
And the address of any Greek god is Mount Olympus.

950
00:54:54,320 --> 00:54:57,168
这就是一个小型经典逻辑数据库
So there's a little classical logic database.

951
00:54:57,390 --> 00:54:59,328
确实 它运行得相当好
And indeed, that would work fairly well.

952
00:54:59,490 --> 00:55:02,096
如果我们向其询问
If we type that in and say

953
00:55:03,472 --> 00:55:06,576
苏格拉底是凡人么？不可靠么？
is Socrates mortal or Socrates fallible or mortal?

954
00:55:06,910 --> 00:55:07,690
它会输出：是
It'll say yes.

955
00:55:07,776 --> 00:55:09,710
柏拉图是凡人并且不可靠么？
Is Plato mortal and fallible.

956
00:55:09,710 --> 00:55:10,240
它会回答：是
It'll say yes.

957
00:55:10,680 --> 00:55:12,210
如果我们问宙斯是凡人么
If we say is Zeus mortal?

958
00:55:12,210 --> 00:55:13,232
它什么都不会找到
It won't find anything.

959
00:55:14,900 --> 00:55:15,968
运行得非常完美
And it'll work perfectly well.

960
00:55:16,544 --> 00:55:20,120
然而 如果我们想要把它扩展一下
However, suppose we want to extend this.

961
00:55:20,120 --> 00:55:23,056
让我们来定义一下什么是“完美生命体”
Let's define what it means for someone to be a perfect being.

962
00:55:23,824 --> 00:55:27,216
我们把规则PERFECT定义为
Let's say rule: a perfect being.

963
00:55:34,050 --> 00:55:35,480
我想这样来定义是正确的
And I think this is right.

964
00:55:35,480 --> 00:55:38,144
如果你熟悉中世纪经院哲学
If you're up on your medieval scholastic philosophy,

965
00:55:38,448 --> 00:55:40,176
我想所谓“完美生命体”一定
I believe that perfect beings are ones

966
00:55:40,688 --> 00:55:42,656
既不是凡人 又不会不可靠
who were neither mortal nor fallible.

967
00:55:44,100 --> 00:55:56,848
(AND (NOT (MORTAL ?X)) (NOT (FALLIBLE ?X)))
AND NOT mortal x, NOT fallible x.

968
00:55:59,300 --> 00:56:00,896
这样 我们就定义了一个规则
So we'll define this system

969
00:56:02,672 --> 00:56:04,368
来告诉系统 什么是“完美生命体”
to teach it what a perfect being is.

970
00:56:05,790 --> 00:56:07,696
现在 我们就要
And now what we're going to do is

971
00:56:08,064 --> 00:56:10,176
询问所有“完美生命体”的地址
ask for the address of all the perfect beings.

972
00:56:11,488 --> 00:56:22,304
(AND (ADDRESS ?X ?Y) (PERFECT ?X))
AND the address of x is y and x is perfect.

973
00:56:23,488 --> 00:56:24,976
在这里 我们生成了
And so what we're generating here is

974
00:56:24,992 --> 00:56:27,808
世界上最独有的邮件列表
the world's most exclusive mailing list.

975
00:56:30,160 --> 00:56:32,200
为了查询所有完美生命体的地址
For the address of all the perfect beings,

976
00:56:32,240 --> 00:56:33,472
我们会输入像这样的查询
we might have typed this in.

977
00:56:33,830 --> 00:56:35,440
或者像这样输入
Or we might type in this.

978
00:56:36,240 --> 00:56:50,576
(AND (PERFECT ?X) (ADDRESS ?X ?Y))
We'll say AND perfect of x and the address of x is y.

979
00:56:52,064 --> 00:56:54,960
假设我们把它输入进去 并尝试查询
Well, suppose we type all that in and we try this query.

980
00:56:55,190 --> 00:56:56,768
这条查询会给我们答案
This query is going to give us an answer.

981
00:56:57,650 --> 00:57:00,000
这条查询会输出：奥林匹斯山
This query will say, yeah, Mount Olympus.

982
00:57:04,230 --> 00:57:06,576
而这条查询 什么也不会输出
This query, in fact, is going to give us nothing.

983
00:57:06,740 --> 00:57:09,584
它找不到完美生命体的地址
It will say no addresses of perfect beings.

984
00:57:11,640 --> 00:57:12,510
为什么会这样？
Now, why is that?

985
00:57:12,510 --> 00:57:13,440
这又为什么不同？
Why is there a difference?

986
00:57:14,230 --> 00:57:15,690
这个问题跟无穷循环没什么关系
This is not an infinite loop question.

987
00:57:15,690 --> 00:57:17,088
而是答案不相同的问题
This is a different answer question.

988
00:57:19,488 --> 00:57:20,096
原因就是
The reason is

989
00:57:20,380 --> 00:57:22,320
如果你们还记得NOT的实现的话
that if you remember the implementation of NOT,

990
00:57:23,504 --> 00:57:24,848
NOT是作为一个过滤器
NOT acted as a filter.

991
00:57:25,880 --> 00:57:29,008
NOT会接收一本字典
NOT said I'm going to take some possible dictionaries,

992
00:57:29,050 --> 00:57:31,568
里面有可行解构成的框架
some possible frames, some possible answers, 

993
00:57:31,792 --> 00:57:33,168
然后过滤出那些
and filter out the ones

994
00:57:33,290 --> 00:57:34,940
满足某个条件的解
that happened to satisfy some condition,

995
00:57:34,976 --> 00:57:36,112
这就是我如何实现NOT的
and that's how I implement NOT.

996
00:57:36,928 --> 00:57:38,432
如果你们仔细想想其中的原理
If you think about what's going on here,

997
00:57:40,112 --> 00:57:42,656
我创建了一个查询盒子
I'll build this query box where the address piece

998
00:57:43,320 --> 00:57:47,392
ADDRESS盒子的输出作为了PERFECT的输入
the output of an address piece gets fed into a perfect piece.

999
00:57:50,290 --> 00:57:51,008
这就使得
What will happen is

1000
00:57:51,328 --> 00:57:53,264
ADDRESS盒子会创建出
the address piece will set up some things of

1001
00:57:53,328 --> 00:57:54,832
我知道地址的人
everyone whose address I know.

1002
00:57:55,290 --> 00:57:57,648
Those will get filtered by the NOTs inside perfect here.

1003
00:57:59,880 --> 00:58:01,904
So it will throw out the ones which happened to be either mortal or fallible.

1004
00:58:02,160 --> 00:58:04,112
So it will throw out the ones which happened to be either mortal or fallible.

1005
00:58:04,910 --> 00:58:06,384
In the other order what happens is I set this up, started up with an empty frame.

1006
00:58:06,736 --> 00:58:09,120
In the other order what happens is I set this up, started up with an empty frame.

1007
00:58:09,520 --> 00:58:12,352
The perfect in here doesn't find anything for the NOTs to filter, so nothing comes out here at all.

1008
00:58:12,384 --> 00:58:13,984
The perfect in here doesn't find anything for the NOTs to filter, so nothing comes out here at all.

1009
00:58:18,830 --> 00:58:21,504
And there's sort of nothing there that gets fed into the address thing.

1010
00:58:21,940 --> 00:58:23,152
So here, I don't get an answer.

1011
00:58:23,936 --> 00:58:27,040
And again, the reason for that is NOT isn't generating anything.

1012
00:58:27,440 --> 00:58:28,800
NOT's only throwing out things.

1013
00:58:29,080 --> 00:58:30,512
And if I never started up with anything, there's nothing for it to throw out.

1014
00:58:30,528 --> 00:58:31,744
And if I never started up with anything, there's nothing for it to throw out.

1015
00:58:32,020 --> 00:58:33,770
So out of this thing, I get the wrong answer.

1016
00:58:37,200 --> 00:58:37,970
How can you fix that?

1017
00:58:37,970 --> 00:58:39,070
Well, there are ways to fix that.

1018
00:58:39,360 --> 00:58:40,912
So you might say, well, that's sort of stupid.

1019
00:58:41,410 --> 00:58:44,900
Why are you just doing all your NOT stuff at the beginning?

1020
00:58:44,900 --> 00:58:46,144
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1021
00:58:46,432 --> 00:58:47,392
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1022
00:58:47,840 --> 00:58:50,080
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1023
00:58:50,336 --> 00:58:52,096
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1024
00:58:52,800 --> 00:58:54,976
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1025
00:58:55,520 --> 00:58:57,856
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1026
00:58:58,560 --> 00:59:02,016
And there are implementations of logic languages that work like that that solve this particular problem.

1027
00:59:02,416 --> 00:59:04,050
And there are implementations of logic languages that work like that that solve this particular problem.

1028
00:59:06,800 --> 00:59:08,976
However, there's a more profound problem, which is which one of these is the right answer?

1029
00:59:09,600 --> 00:59:11,536
However, there's a more profound problem, which is which one of these is the right answer?

1030
00:59:12,530 --> 00:59:14,240
Is it Mount Olympus or is it nothing?

1031
00:59:15,320 --> 00:59:16,224
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1032
00:59:17,520 --> 00:59:18,736
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1033
00:59:18,760 --> 00:59:20,730
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1034
00:59:22,528 --> 00:59:25,104
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1035
00:59:29,550 --> 00:59:32,448
So you might say Zeus wants to satisfy NOT mortal Zeus or NOT fallible Zeus.

1036
00:59:34,304 --> 00:59:44,032
So you might say Zeus wants to satisfy NOT mortal Zeus or NOT fallible Zeus.

1037
00:59:44,120 --> 00:59:45,856
But let's actually look at that database.

1038
00:59:47,920 --> 00:59:48,464
Let's look at it.

1039
00:59:49,320 --> 00:59:50,208
There's no way-- how does it know that Zeus is not fallible?

1040
00:59:51,472 --> 00:59:53,248
There's no way-- how does it know that Zeus is not fallible?

1041
00:59:54,810 --> 00:59:56,112
There's nothing in there about that.

1042
00:59:57,930 --> 00:59:59,664
What's in there is that humans are fallible.

1043
01:00:02,160 --> 01:00:04,128
How does it know that Zeus is not mortal?

1044
01:00:04,480 --> 01:00:05,936
There's nothing in there about that.

1045
01:00:07,980 --> 01:00:11,008
It just said I don't have any rule, which-- the only way I can deduce something's mortal is if it's human, and that's all it really knows about mortal.

1046
01:00:11,680 --> 01:00:13,504
It just said I don't have any rule, which-- the only way I can deduce something's mortal is if it's human, and that's all it really knows about mortal.

1047
01:00:13,520 --> 01:00:15,680
It just said I don't have any rule, which-- the only way I can deduce something's mortal is if it's human, and that's all it really knows about mortal.

1048
01:00:16,690 --> 01:00:19,856
And in fact, if you remember your classical mythology, you know that the Greek gods were not mortal but fallible.

1049
01:00:19,872 --> 01:00:23,488
And in fact, if you remember your classical mythology, you know that the Greek gods were not mortal but fallible.

1050
01:00:25,056 --> 01:00:28,656
So the answer is not in the rules there.

1051
01:00:30,850 --> 01:00:32,100
See, why does it deduce that?

1052
01:00:34,496 --> 01:00:38,320
See, Socrates would certainly not have made this error of logic.

1053
01:00:40,080 --> 01:00:42,672
What NOT needs in this language is not NOT.

1054
01:00:43,370 --> 01:00:44,320
It's not the NOT of logic.

1055
01:00:44,930 --> 01:00:46,400
What NOT needs in this language is not deducible from things in the database as opposed to not true.

1056
01:00:47,160 --> 01:00:49,960
What NOT needs in this language is not deducible from things in the database as opposed to not true.

1057
01:00:50,752 --> 01:00:53,344
What NOT needs in this language is not deducible from things in the database as opposed to not true.

1058
01:00:55,312 --> 01:00:56,384
That's a very big difference.

1059
01:00:57,300 --> 01:00:58,640
Subtle, but big.

1060
01:00:59,250 --> 01:01:00,272
So, in fact, this is perfectly happy to say not anything that it doesn't know about.

1061
01:01:00,768 --> 01:01:03,920
So, in fact, this is perfectly happy to say not anything that it doesn't know about.

1062
01:01:04,610 --> 01:01:05,488
So if you ask it is it not true that Zeus likes chocolate ice cream?

1063
01:01:05,504 --> 01:01:07,830
So if you ask it is it not true that Zeus likes chocolate ice cream?

1064
01:01:07,856 --> 01:01:09,120
It will say sure, it's not true.

1065
01:01:10,640 --> 01:01:12,512
Or anything else or anything it doesn't know about.

1066
01:01:12,592 --> 01:01:17,344
NOT means not deducible from the things you've told me.

1067
01:01:18,280 --> 01:01:22,448
In a world where you're identifying not deducible with, in fact, not true, this is called the closed world assumption.

1068
01:01:22,656 --> 01:01:24,000
In a world where you're identifying not deducible with, in fact, not true, this is called the closed world assumption.

1069
01:01:24,416 --> 01:01:26,304
In a world where you're identifying not deducible with, in fact, not true, this is called the closed world assumption.

1070
01:01:37,376 --> 01:01:38,176
The closed world assumption.

1071
01:01:38,200 --> 01:01:42,384
Anything that I cannot deduce from what I know is not true, right?

1072
01:01:43,504 --> 01:01:44,270
Anything that I cannot deduce from what I know is not true, right?

1073
01:01:46,240 --> 01:01:48,010
If I don't know anything about x, the x isn't true.

1074
01:01:48,224 --> 01:01:49,216
If I don't know anything about x, the x isn't true.

1075
01:01:49,290 --> 01:01:50,336
That's very dangerous.

1076
01:01:51,296 --> 01:01:52,448
From a logical point of view, first of all, it doesn't really makes sense.

1077
01:01:52,464 --> 01:01:53,760
From a logical point of view, first of all, it doesn't really makes sense.

1078
01:01:54,480 --> 01:01:56,336
Because if I don't know anything about x, I'm willing to say not x.

1079
01:01:58,384 --> 01:01:59,696
Because if I don't know anything about x, I'm willing to say not x.

1080
01:02:00,240 --> 01:02:03,328
But am I willing to say not not x?

1081
01:02:03,850 --> 01:02:05,664
Well, sure, I don't know anything about that either maybe.

1082
01:02:06,470 --> 01:02:08,656
So not not x is not necessarily the same as x and so on and so on and so on, so there's some sort of funny bias in there.

1083
01:02:09,248 --> 01:02:10,944
So not not x is not necessarily the same as x and so on and so on and so on, so there's some sort of funny bias in there.

1084
01:02:11,712 --> 01:02:13,936
So not not x is not necessarily the same as x and so on and so on and so on, so there's some sort of funny bias in there.

1085
01:02:15,970 --> 01:02:17,290
So that's sort of funny.

1086
01:02:17,290 --> 01:02:18,096
The second thing, if you start building up real reasoning programs based on this, think how dangerous that is.

1087
01:02:20,144 --> 01:02:24,128
The second thing, if you start building up real reasoning programs based on this, think how dangerous that is.

1088
01:02:24,704 --> 01:02:26,112
The second thing, if you start building up real reasoning programs based on this, think how dangerous that is.

1089
01:02:27,000 --> 01:02:27,856
You're saying I know I'm in a position to deduce everything true that's relevant to this problem.

1090
01:02:29,616 --> 01:02:33,888
You're saying I know I'm in a position to deduce everything true that's relevant to this problem.

1091
01:02:34,160 --> 01:02:36,224
You're saying I know I'm in a position to deduce everything true that's relevant to this problem.

1092
01:02:37,480 --> 01:02:38,560
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1093
01:02:38,896 --> 01:02:42,256
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1094
01:02:42,368 --> 01:02:44,208
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1095
01:02:44,240 --> 01:02:46,272
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1096
01:02:48,448 --> 01:02:53,040
There are a lot of big organizations that work like that, right?

1097
01:02:53,168 --> 01:02:56,830
Most corporate marketing divisions work like that.

1098
01:02:56,830 --> 01:02:59,120
You know the consequences to that.

1099
01:03:00,336 --> 01:03:01,680
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1100
01:03:02,272 --> 01:03:06,256
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1101
01:03:07,056 --> 01:03:09,008
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1102
01:03:09,024 --> 01:03:11,280
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1103
01:03:12,600 --> 01:03:14,368
So you have to be very, very careful about that.

1104
01:03:15,296 --> 01:03:16,288
And that's a deep problem.

1105
01:03:16,560 --> 01:03:17,824
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1106
01:03:18,224 --> 01:03:20,144
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1107
01:03:20,160 --> 01:03:21,824
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1108
01:03:22,160 --> 01:03:23,840
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1109
01:03:23,840 --> 01:03:25,088
It's a different kind of problem.

1110
01:03:25,920 --> 01:03:26,896
It's a different semantics.

1111
01:03:27,060 --> 01:03:30,512
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1112
01:03:31,344 --> 01:03:34,432
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1113
01:03:34,576 --> 01:03:35,648
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1114
01:03:36,176 --> 01:03:38,784
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1115
01:03:39,900 --> 01:03:42,944
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1116
01:03:43,584 --> 01:03:45,088
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1117
01:03:46,096 --> 01:03:49,488
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1118
01:03:50,560 --> 01:03:51,536
And linked to logic, the problem is it's a goal that I think has yet to be realized.

1119
01:03:52,464 --> 01:03:56,464
And linked to logic, the problem is it's a goal that I think has yet to be realized.

1120
01:03:58,032 --> 01:04:01,808
And probably one of the very most interesting research questions going on now in languages is how do you somehow make a real logic language?

1121
01:04:02,272 --> 01:04:04,416
And probably one of the very most interesting research questions going on now in languages is how do you somehow make a real logic language?

1122
01:04:04,672 --> 01:04:08,288
And probably one of the very most interesting research questions going on now in languages is how do you somehow make a real logic language?

1123
01:04:09,460 --> 01:04:11,056
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1124
01:04:11,312 --> 01:04:13,152
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1125
01:04:13,520 --> 01:04:16,432
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1126
01:04:16,464 --> 01:04:17,984
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1127
01:04:18,880 --> 01:04:19,680
OK, let's break.

1128
01:04:23,290 --> 01:04:27,740
AUDIENCE: Couldn't you solve that last problem by having the extra rules that imply it?

1129
01:04:27,968 --> 01:04:29,856
The problem here is you have the definition of something, but you don't have the definition of its opposite.

1130
01:04:29,888 --> 01:04:31,824
The problem here is you have the definition of something, but you don't have the definition of its opposite.

1131
01:04:32,080 --> 01:04:33,920
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1132
01:04:35,472 --> 01:04:36,896
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1133
01:04:36,992 --> 01:04:38,704
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1134
01:04:38,752 --> 01:04:40,370
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1135
01:04:43,370 --> 01:04:44,144
PROFESSOR: But the issue is do you put a finite number of those in?

1136
01:04:44,752 --> 01:04:46,384
PROFESSOR: But the issue is do you put a finite number of those in?

1137
01:04:48,656 --> 01:04:53,130
AUDIENCE: If things are specified always in pairs-- PROFESSOR: But the impression is then what do you do about deduction?

1138
01:04:53,616 --> 01:04:57,072
AUDIENCE: If things are specified always in pairs-- PROFESSOR: But the impression is then what do you do about deduction?

1139
01:05:00,200 --> 01:05:02,112
You can't specify NOTs.

1140
01:05:03,400 --> 01:05:04,768
But the problem is, in a big system, it turns out that might not be a finite number of things.

1141
01:05:04,784 --> 01:05:07,960
But the problem is, in a big system, it turns out that might not be a finite number of things.

1142
01:05:12,820 --> 01:05:15,290
There are also sort of two issues.

1143
01:05:15,290 --> 01:05:16,560
Partly it might not be finite.

1144
01:05:16,690 --> 01:05:19,392
Partly it might be that's not what you want.

1145
01:05:21,510 --> 01:05:24,528
So a good example would be suppose I want to do connectivity.

1146
01:05:25,120 --> 01:05:26,544
I want a reason about connectivity.

1147
01:05:28,050 --> 01:05:30,384
And I'm going to tell you there's four things: a and b and c and d.

1148
01:05:30,400 --> 01:05:33,744
And I'm going to tell you there's four things: a and b and c and d.

1149
01:05:35,480 --> 01:05:38,190
And I'll tell you a is connected to b and c's connected to d.

1150
01:05:38,640 --> 01:05:41,424
And I'll tell you a is connected to b and c's connected to d.

1151
01:05:43,200 --> 01:05:44,800
And now I'll tell you is a connected to d?

1152
01:05:45,056 --> 01:05:46,032
That's the question.

1153
01:05:46,780 --> 01:05:50,610
There's an example where I would like something like the closed world assumption.

1154
01:05:54,432 --> 01:05:55,664
That's a tiny toy, but a lot of times, I want to be able to say something like anything that I haven't told you, assume is not true.

1155
01:05:56,240 --> 01:05:58,304
That's a tiny toy, but a lot of times, I want to be able to say something like anything that I haven't told you, assume is not true.

1156
01:05:58,480 --> 01:06:01,340
That's a tiny toy, but a lot of times, I want to be able to say something like anything that I haven't told you, assume is not true.

1157
01:06:04,260 --> 01:06:06,496
So it's not as simple as you only want to put in explicit NOTs all over the place.

1158
01:06:06,560 --> 01:06:08,096
So it's not as simple as you only want to put in explicit NOTs all over the place.

1159
01:06:09,470 --> 01:06:12,704
It's that sometimes it really isn't clear what you even want.

1160
01:06:14,150 --> 01:06:17,920
That having to specify both everything and not everything is too precise, and then you get down into problems there.

1161
01:06:17,936 --> 01:06:20,000
That having to specify both everything and not everything is too precise, and then you get down into problems there.

1162
01:06:20,960 --> 01:06:22,688
But there are a lot of approaches that explicitly put in NOTs and reason based on that.

1163
01:06:23,328 --> 01:06:25,936
But there are a lot of approaches that explicitly put in NOTs and reason based on that.

1164
01:06:26,510 --> 01:06:27,664
So it's a very good idea.

1165
01:06:28,070 --> 01:06:31,456
It's just that then it starts becoming a little cumbersome in the very large problems you'd like to use.

1166
01:06:31,488 --> 01:06:33,490
It's just that then it starts becoming a little cumbersome in the very large problems you'd like to use.

1167
01:06:43,460 --> 01:06:45,968
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1168
01:06:46,000 --> 01:06:47,984
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1169
01:06:48,496 --> 01:06:50,160
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1170
01:06:50,192 --> 01:06:52,064
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1171
01:06:53,440 --> 01:06:55,328
You never really know all the parts to it.

1172
01:06:55,872 --> 01:06:58,160
Isn't that a major problem with any programming?

1173
01:06:58,160 --> 01:06:59,648
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1174
01:06:59,904 --> 01:07:01,568
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1175
01:07:01,584 --> 01:07:03,408
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1176
01:07:04,064 --> 01:07:06,528
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1177
01:07:07,390 --> 01:07:08,540
PROFESSOR: Well, sure, it's true.

1178
01:07:08,540 --> 01:07:09,760
But the problem here is it's that assumption which is the thing that you're making if you believe you're identifying this with logic.

1179
01:07:11,968 --> 01:07:15,472
But the problem here is it's that assumption which is the thing that you're making if you believe you're identifying this with logic.

1180
01:07:15,488 --> 01:07:17,344
But the problem here is it's that assumption which is the thing that you're making if you believe you're identifying this with logic.

1181
01:07:19,600 --> 01:07:20,510
So you're quite right.

1182
01:07:20,510 --> 01:07:22,220
It's a situation you're never in.

1183
01:07:22,220 --> 01:07:25,520
The problem is if you're starting to believe that what this is doing is logic and you look at the rules you write down and say what can I deduce from them, you have to be very careful to remember that NOT means something else.

1184
01:07:26,176 --> 01:07:28,896
The problem is if you're starting to believe that what this is doing is logic and you look at the rules you write down and say what can I deduce from them, you have to be very careful to remember that NOT means something else.

1185
01:07:29,536 --> 01:07:32,800
The problem is if you're starting to believe that what this is doing is logic and you look at the rules you write down and say what can I deduce from them, you have to be very careful to remember that NOT means something else.

1186
01:07:33,470 --> 01:07:35,216
And it means something else based on an assumption which is probably not true.

1187
01:07:35,248 --> 01:07:36,704
And it means something else based on an assumption which is probably not true.

1188
01:07:39,030 --> 01:07:40,544
AUDIENCE: Do I understand you correctly that you cannot fix this problem without killing off all possibilities of inference through altering NOT?

1189
01:07:40,560 --> 01:07:41,824
AUDIENCE: Do I understand you correctly that you cannot fix this problem without killing off all possibilities of inference through altering NOT?

1190
01:07:42,256 --> 01:07:46,080
AUDIENCE: Do I understand you correctly that you cannot fix this problem without killing off all possibilities of inference through altering NOT?

1191
01:07:46,544 --> 01:07:49,808
PROFESSOR: No, that's not quite right.

1192
01:07:52,960 --> 01:07:55,088
There are other--  there are ways to do logic with real NOTs.

1193
01:07:56,340 --> 01:07:58,032
There are actually ways to do that.

1194
01:07:58,540 --> 01:08:00,848
But they're very inefficient as far as anybody knows.

1195
01:08:01,610 --> 01:08:02,560
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1196
01:08:04,096 --> 01:08:06,896
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1197
01:08:07,390 --> 01:08:08,830
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1198
01:08:08,912 --> 01:08:11,296
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1199
01:08:11,980 --> 01:08:16,192
There are ways to automate real logical reasoning.

1200
01:08:16,590 --> 01:08:18,192
But it's not based on that, and logic programming languages don't tend to do that because it's very inefficient as far as anybody knows.

1201
01:08:18,512 --> 01:08:19,840
But it's not based on that, and logic programming languages don't tend to do that because it's very inefficient as far as anybody knows.

1202
01:08:19,872 --> 01:08:23,850
But it's not based on that, and logic programming languages don't tend to do that because it's very inefficient as far as anybody knows.

1203
01:08:29,390 --> 01:08:30,032
All right, thank you.

