1
00:00:18,910 --> 00:00:21,792
PROFESSOR: All right, well, we've seen how the query language works.

2
00:00:22,640 --> 00:00:25,072
Now, let's talk about how it's implemented.

3
00:00:26,280 --> 00:00:27,984
You already pretty much can guess

4
00:00:28,592 --> 00:00:29,470
what's going on there.

5
00:00:29,470 --> 00:00:31,648
At the bottom of it, there's a pattern matcher.

6
00:00:32,810 --> 00:00:34,256
And we looked at a pattern matcher

7
00:00:34,672 --> 00:00:36,944
when we did the rule-based control language.

8
00:00:38,110 --> 00:00:40,592
Just to remind you, here are some sample patterns.

9
00:00:41,520 --> 00:00:43,680
This is a pattern that will match any list of three things of which the first is a and the second is c and the middle one can be anything.

10
00:00:43,808 --> 00:00:44,928
This is a pattern that will match any list of three things of which the first is a and the second is c and the middle one can be anything.

11
00:00:44,960 --> 00:00:47,104
This is a pattern that will match any list of three things of which the first is a and the second is c and the middle one can be anything.

12
00:00:47,168 --> 00:00:48,336
This is a pattern that will match any list of three things of which the first is a and the second is c and the middle one can be anything.

13
00:00:48,480 --> 00:00:50,192
This is a pattern that will match any list of three things of which the first is a and the second is c and the middle one can be anything.

14
00:00:50,650 --> 00:00:52,272
So in this little pattern-matching syntax, there's only one distinction you make.

15
00:00:52,304 --> 00:00:54,050
So in this little pattern-matching syntax, there's only one distinction you make.

16
00:00:54,050 --> 00:00:57,200
There's either literal things or variables, and variables begin with question mark.

17
00:00:57,232 --> 00:00:58,864
There's either literal things or variables, and variables begin with question mark.

18
00:01:01,370 --> 00:01:03,648
So this matches any list of three things of which the first is a and the second is c.

19
00:01:04,448 --> 00:01:06,500
So this matches any list of three things of which the first is a and the second is c.

20
00:01:06,500 --> 00:01:09,008
This one matches any list of three things of which the first is the symbol job.

21
00:01:10,432 --> 00:01:12,530
This one matches any list of three things of which the first is the symbol job.

22
00:01:12,530 --> 00:01:13,904
The second can be anything.

23
00:01:14,210 --> 00:01:15,904
And the third is a list of two things of which the first is the symbol computer and the second can be anything.

24
00:01:15,952 --> 00:01:17,728
And the third is a list of two things of which the first is the symbol computer and the second can be anything.

25
00:01:17,888 --> 00:01:19,424
And the third is a list of two things of which the first is the symbol computer and the second can be anything.

26
00:01:20,480 --> 00:01:23,360
And this one, this next one matches any list of three things, and the only difference is, here, the third list, the first is the symbol computer, and then there's some rest of the list. So this means two elements and this means arbitrary number.

27
00:01:23,792 --> 00:01:25,616
And this one, this next one matches any list of three things, and the only difference is, here, the third list, the first is the symbol computer, and then there's some rest of the list. So this means two elements and this means arbitrary number.

28
00:01:25,872 --> 00:01:26,992
And this one, this next one matches any list of three things, and the only difference is, here, the third list, the first is the symbol computer, and then there's some rest of the list. So this means two elements and this means arbitrary number.

29
00:01:28,400 --> 00:01:31,320
And this one, this next one matches any list of three things, and the only difference is, here, the third list, the first is the symbol computer, and then there's some rest of the list. So this means two elements and this means arbitrary number.

30
00:01:31,760 --> 00:01:33,296
And this one, this next one matches any list of three things, and the only difference is, here, the third list, the first is the symbol computer, and then there's some rest of the list. So this means two elements and this means arbitrary number.

31
00:01:35,040 --> 00:01:37,536
And this one, this next one matches any list of three things, and the only difference is, here, the third list, the first is the symbol computer, and then there's some rest of the list. So this means two elements and this means arbitrary number.

32
00:01:37,860 --> 00:01:39,744
And our language implementation isn't even going to have to worry about implementing this dot because that's automatically done by Lisp's reader.

33
00:01:39,856 --> 00:01:42,064
And our language implementation isn't even going to have to worry about implementing this dot because that's automatically done by Lisp's reader.

34
00:01:42,112 --> 00:01:44,176
And our language implementation isn't even going to have to worry about implementing this dot because that's automatically done by Lisp's reader.

35
00:01:48,340 --> 00:01:50,310
Remember matchers also have some consistency in them.

36
00:01:50,310 --> 00:01:52,320
This match is a list of three things of which the first is a.

37
00:01:52,592 --> 00:01:53,984
This match is a list of three things of which the first is a.

38
00:01:54,430 --> 00:01:55,792
And the second and third can be anything, but they have to be the same thing.

39
00:01:55,808 --> 00:01:57,088
And the second and third can be anything, but they have to be the same thing.

40
00:01:57,940 --> 00:01:58,848
They're both called x.

41
00:01:59,600 --> 00:02:01,552
And this matches a list of four things of which the first is the fourth and the second is the same as the third.

42
00:02:01,968 --> 00:02:03,264
And this matches a list of four things of which the first is the fourth and the second is the same as the third.

43
00:02:03,664 --> 00:02:05,152
And this matches a list of four things of which the first is the fourth and the second is the same as the third.

44
00:02:05,590 --> 00:02:08,608
And this last one matches any list that begins with a.

45
00:02:09,680 --> 00:02:11,056
The first thing is a, and the rest can be anything.

46
00:02:11,232 --> 00:02:12,560
The first thing is a, and the rest can be anything.

47
00:02:14,040 --> 00:02:16,608
So that's just a review of pattern matcher syntax that you've already seen.

48
00:02:16,624 --> 00:02:17,872
So that's just a review of pattern matcher syntax that you've already seen.

49
00:02:18,780 --> 00:02:19,648
And remember, that's implemented by some procedure called match.

50
00:02:19,792 --> 00:02:22,288
And remember, that's implemented by some procedure called match.

51
00:02:24,870 --> 00:02:36,064
And match takes a pattern and some data and a dictionary.

52
00:02:43,200 --> 00:02:47,120
And match asks the question is there any way to match this pattern against this data object subject to the bindings that are already in this dictionary?

53
00:02:47,792 --> 00:02:50,976
And match asks the question is there any way to match this pattern against this data object subject to the bindings that are already in this dictionary?

54
00:02:51,136 --> 00:02:52,528
And match asks the question is there any way to match this pattern against this data object subject to the bindings that are already in this dictionary?

55
00:02:53,552 --> 00:02:56,736
And match asks the question is there any way to match this pattern against this data object subject to the bindings that are already in this dictionary?

56
00:02:58,160 --> 00:02:59,216
So, for instance, if we're going to match the pattern x, y, y, x against the data a, b, b, a subject to a dictionary, that says x equals a.

57
00:02:59,568 --> 00:03:06,432
So, for instance, if we're going to match the pattern x, y, y, x against the data a, b, b, a subject to a dictionary, that says x equals a.

58
00:03:07,712 --> 00:03:13,840
So, for instance, if we're going to match the pattern x, y, y, x against the data a, b, b, a subject to a dictionary, that says x equals a.

59
00:03:15,120 --> 00:03:17,104
So, for instance, if we're going to match the pattern x, y, y, x against the data a, b, b, a subject to a dictionary, that says x equals a.

60
00:03:18,160 --> 00:03:20,464
So, for instance, if we're going to match the pattern x, y, y, x against the data a, b, b, a subject to a dictionary, that says x equals a.

61
00:03:22,010 --> 00:03:23,872
Then the matcher would say, yes, that's consistent.

62
00:03:23,968 --> 00:03:25,260
Then the matcher would say, yes, that's consistent.

63
00:03:25,260 --> 00:03:27,168
These match, and it's consistent with what's in the dictionary to say that x equals a.

64
00:03:27,808 --> 00:03:30,208
These match, and it's consistent with what's in the dictionary to say that x equals a.

65
00:03:30,320 --> 00:03:31,600
And the result of the match is the extended dictionary that says x equals a and y equals b.

66
00:03:32,256 --> 00:03:34,304
And the result of the match is the extended dictionary that says x equals a and y equals b.

67
00:03:34,464 --> 00:03:37,600
And the result of the match is the extended dictionary that says x equals a and y equals b.

68
00:03:39,490 --> 00:03:42,240
So a matcher takes in pattern data dictionary, puts out an extended dictionary if it matches, or if it doesn't match, says that it fails.

69
00:03:42,384 --> 00:03:44,544
So a matcher takes in pattern data dictionary, puts out an extended dictionary if it matches, or if it doesn't match, says that it fails.

70
00:03:44,976 --> 00:03:46,840
So a matcher takes in pattern data dictionary, puts out an extended dictionary if it matches, or if it doesn't match, says that it fails.

71
00:03:46,840 --> 00:03:47,712
So, for example, if I use the same pattern here, if I say this x, y, y, x match a, b, b, a with the dictionary y equals a, then the matcher would put out fail.

72
00:03:47,888 --> 00:03:50,384
So, for example, if I use the same pattern here, if I say this x, y, y, x match a, b, b, a with the dictionary y equals a, then the matcher would put out fail.

73
00:03:50,976 --> 00:03:55,120
So, for example, if I use the same pattern here, if I say this x, y, y, x match a, b, b, a with the dictionary y equals a, then the matcher would put out fail.

74
00:03:55,660 --> 00:03:58,496
So, for example, if I use the same pattern here, if I say this x, y, y, x match a, b, b, a with the dictionary y equals a, then the matcher would put out fail.

75
00:03:59,470 --> 00:04:02,840
So, for example, if I use the same pattern here, if I say this x, y, y, x match a, b, b, a with the dictionary y equals a, then the matcher would put out fail.

76
00:04:05,152 --> 00:04:06,816
So, for example, if I use the same pattern here, if I say this x, y, y, x match a, b, b, a with the dictionary y equals a, then the matcher would put out fail.

77
00:04:12,528 --> 00:04:14,656
Well, you've already seen the code for a pattern matcher so I'm not going to go over it, but it's the same thing we've been doing before.

78
00:04:15,008 --> 00:04:16,176
Well, you've already seen the code for a pattern matcher so I'm not going to go over it, but it's the same thing we've been doing before.

79
00:04:16,640 --> 00:04:19,776
Well, you've already seen the code for a pattern matcher so I'm not going to go over it, but it's the same thing we've been doing before.

80
00:04:21,190 --> 00:04:23,220
You saw that in the system on rule-based control.

81
00:04:23,220 --> 00:04:24,560
It's essentially the same matcher.

82
00:04:24,950 --> 00:04:27,664
In fact, I think the syntax is a little bit simpler because we're not worrying about arbitrary constants and expressions and things.

83
00:04:28,160 --> 00:04:29,312
In fact, I think the syntax is a little bit simpler because we're not worrying about arbitrary constants and expressions and things.

84
00:04:29,408 --> 00:04:31,400
In fact, I think the syntax is a little bit simpler because we're not worrying about arbitrary constants and expressions and things.

85
00:04:31,400 --> 00:04:32,880
There's just variables and constants.

86
00:04:35,790 --> 00:04:37,328
OK, well, given that, what's a primitive query?

87
00:04:38,464 --> 00:04:39,610
OK, well, given that, what's a primitive query?

88
00:04:42,970 --> 00:04:45,344
Primitive query is going to be a rather complicated thing.

89
00:04:46,720 --> 00:04:47,392
It's going to be-- let's think about the query job of x is d dot y.

90
00:04:48,208 --> 00:05:03,584
It's going to be-- let's think about the query job of x is d dot y.

91
00:05:07,040 --> 00:05:08,736
That's a query we might type in.

92
00:05:09,400 --> 00:05:11,392
That's going to be implemented in the system.

93
00:05:14,144 --> 00:05:15,664
We'll think of it as this little box.

94
00:05:15,700 --> 00:05:16,800
Here's the primitive query.

95
00:05:18,880 --> 00:05:20,304
What this little box is going to do is take in two streams and put out a stream.

96
00:05:22,240 --> 00:05:27,280
What this little box is going to do is take in two streams and put out a stream.

97
00:05:31,968 --> 00:05:33,200
What this little box is going to do is take in two streams and put out a stream.

98
00:05:34,030 --> 00:05:36,192
So the shape of a primitive query is that it's a thing where two streams come in and one stream goes out.

99
00:05:36,512 --> 00:05:38,464
So the shape of a primitive query is that it's a thing where two streams come in and one stream goes out.

100
00:05:38,672 --> 00:05:39,968
So the shape of a primitive query is that it's a thing where two streams come in and one stream goes out.

101
00:05:41,120 --> 00:05:42,480
What these streams are going to be is down here is the database.

102
00:05:42,912 --> 00:05:46,256
What these streams are going to be is down here is the database.

103
00:05:51,952 --> 00:05:53,936
So we imagine all the things in the database sort of sitting there in a stream and this thing sucks on them.

104
00:05:55,930 --> 00:05:57,200
So we imagine all the things in the database sort of sitting there in a stream and this thing sucks on them.

105
00:05:57,310 --> 00:05:58,400
So we imagine all the things in the database sort of sitting there in a stream and this thing sucks on them.

106
00:06:00,368 --> 00:06:02,432
So what are some things that might be in the database?

107
00:06:02,800 --> 00:06:03,296
Oh, job of Alyssa is something and some other job is something.

108
00:06:08,432 --> 00:06:20,320
Oh, job of Alyssa is something and some other job is something.

109
00:06:21,968 --> 00:06:23,712
Oh, job of Alyssa is something and some other job is something.

110
00:06:25,770 --> 00:06:30,416
So imagine all of the facts in the database sitting there in the stream.

111
00:06:32,040 --> 00:06:33,104
That's what comes in here.

112
00:06:33,360 --> 00:06:36,528
What comes in here is a stream of dictionaries.

113
00:06:38,510 --> 00:06:41,408
So one particular dictionary might say y equals programmer.

114
00:06:46,704 --> 00:06:49,312
So one particular dictionary might say y equals programmer.

115
00:06:55,470 --> 00:06:56,640
Now, what the query does when it gets in a dictionary from this stream, it finds all possible ways of matching the query against whatever is coming in from the database.

116
00:06:57,072 --> 00:06:59,808
Now, what the query does when it gets in a dictionary from this stream, it finds all possible ways of matching the query against whatever is coming in from the database.

117
00:07:02,016 --> 00:07:03,872
Now, what the query does when it gets in a dictionary from this stream, it finds all possible ways of matching the query against whatever is coming in from the database.

118
00:07:04,288 --> 00:07:10,240
Now, what the query does when it gets in a dictionary from this stream, it finds all possible ways of matching the query against whatever is coming in from the database.

119
00:07:11,390 --> 00:07:12,896
It looks at the query as a pattern, matches it against any fact from the database or all possible ways of finding and matching the database with respect to this dictionary that's coming in.

120
00:07:13,152 --> 00:07:16,720
It looks at the query as a pattern, matches it against any fact from the database or all possible ways of finding and matching the database with respect to this dictionary that's coming in.

121
00:07:16,960 --> 00:07:21,984
It looks at the query as a pattern, matches it against any fact from the database or all possible ways of finding and matching the database with respect to this dictionary that's coming in.

122
00:07:22,944 --> 00:07:25,680
It looks at the query as a pattern, matches it against any fact from the database or all possible ways of finding and matching the database with respect to this dictionary that's coming in.

123
00:07:27,550 --> 00:07:34,352
So for each fact in the database, it calls the matcher using the pattern, fact, and dictionary.

124
00:07:35,110 --> 00:07:37,680
And every time it gets a good match, it puts out the extended dictionary.

125
00:07:38,192 --> 00:07:39,936
And every time it gets a good match, it puts out the extended dictionary.

126
00:07:40,672 --> 00:07:42,320
So, for example, if this one comes in and it finds a match, out will come a dictionary that in this case will have y equals programmer and x equals something.

127
00:07:43,008 --> 00:07:44,096
So, for example, if this one comes in and it finds a match, out will come a dictionary that in this case will have y equals programmer and x equals something.

128
00:07:44,512 --> 00:07:45,872
So, for example, if this one comes in and it finds a match, out will come a dictionary that in this case will have y equals programmer and x equals something.

129
00:07:46,816 --> 00:07:49,792
So, for example, if this one comes in and it finds a match, out will come a dictionary that in this case will have y equals programmer and x equals something.

130
00:07:51,520 --> 00:07:52,970
So, for example, if this one comes in and it finds a match, out will come a dictionary that in this case will have y equals programmer and x equals something.

131
00:07:56,544 --> 00:07:58,752
y is programmer, x is something, and d is whatever it found.

132
00:07:58,960 --> 00:08:00,544
y is programmer, x is something, and d is whatever it found.

133
00:08:01,728 --> 00:08:02,272
And that's all.

134
00:08:03,520 --> 00:08:07,824
And, of course, it's going to try this for every fact in the dictionary.

135
00:08:07,980 --> 00:08:09,250
So it might find lots of them.

136
00:08:09,568 --> 00:08:10,592
It might find another one that says y equals programmer and x equals, and d equals.

137
00:08:11,488 --> 00:08:12,960
It might find another one that says y equals programmer and x equals, and d equals.

138
00:08:13,584 --> 00:08:16,350
It might find another one that says y equals programmer and x equals, and d equals.

139
00:08:20,040 --> 00:08:21,552
So for one frame coming in, it might put out-- for one dictionary coming in, it might put out a lot of dictionaries, or it might put out none.

140
00:08:21,760 --> 00:08:25,248
So for one frame coming in, it might put out-- for one dictionary coming in, it might put out a lot of dictionaries, or it might put out none.

141
00:08:26,544 --> 00:08:28,672
So for one frame coming in, it might put out-- for one dictionary coming in, it might put out a lot of dictionaries, or it might put out none.

142
00:08:30,470 --> 00:08:33,408
It might have something that wouldn't match like x equals FOO.

143
00:08:34,560 --> 00:08:38,400
It might have something that wouldn't match like x equals FOO.

144
00:08:39,024 --> 00:08:40,896
This one might not match anything in which case nothing will go into this stream corresponding to this frame.

145
00:08:41,520 --> 00:08:45,120
This one might not match anything in which case nothing will go into this stream corresponding to this frame.

146
00:08:47,510 --> 00:08:51,280
Or what you might do is put in an empty frame, and an empty frame says try matching all ways--  find all possible ways of matching the query against something in the database subject to no previous restrictions.

147
00:08:52,912 --> 00:08:54,240
Or what you might do is put in an empty frame, and an empty frame says try matching all ways--  find all possible ways of matching the query against something in the database subject to no previous restrictions.

148
00:08:54,416 --> 00:08:56,208
Or what you might do is put in an empty frame, and an empty frame says try matching all ways--  find all possible ways of matching the query against something in the database subject to no previous restrictions.

149
00:08:59,872 --> 00:09:02,336
Or what you might do is put in an empty frame, and an empty frame says try matching all ways--  find all possible ways of matching the query against something in the database subject to no previous restrictions.

150
00:09:02,576 --> 00:09:06,144
Or what you might do is put in an empty frame, and an empty frame says try matching all ways--  find all possible ways of matching the query against something in the database subject to no previous restrictions.

151
00:09:07,570 --> 00:09:09,168
And if you think about what that means, that's just the computation that's done when you type in a query right off.

152
00:09:10,320 --> 00:09:13,872
And if you think about what that means, that's just the computation that's done when you type in a query right off.

153
00:09:14,208 --> 00:09:15,568
It tries to find all matches.

154
00:09:16,650 --> 00:09:18,832
So a primitive query sets up this mechanism.

155
00:09:19,370 --> 00:09:20,576
And what the language does, when you type in the query at the top level, it takes this mechanism, feeds in one single empty dictionary, and then for each thing that comes out takes the original query and instantiates the result with all the different dictionaries, producing a new stream of instantiated patterns here.

156
00:09:22,752 --> 00:09:24,672
And what the language does, when you type in the query at the top level, it takes this mechanism, feeds in one single empty dictionary, and then for each thing that comes out takes the original query and instantiates the result with all the different dictionaries, producing a new stream of instantiated patterns here.

157
00:09:24,848 --> 00:09:26,144
And what the language does, when you type in the query at the top level, it takes this mechanism, feeds in one single empty dictionary, and then for each thing that comes out takes the original query and instantiates the result with all the different dictionaries, producing a new stream of instantiated patterns here.

158
00:09:26,160 --> 00:09:28,352
And what the language does, when you type in the query at the top level, it takes this mechanism, feeds in one single empty dictionary, and then for each thing that comes out takes the original query and instantiates the result with all the different dictionaries, producing a new stream of instantiated patterns here.

159
00:09:30,864 --> 00:09:32,560
And what the language does, when you type in the query at the top level, it takes this mechanism, feeds in one single empty dictionary, and then for each thing that comes out takes the original query and instantiates the result with all the different dictionaries, producing a new stream of instantiated patterns here.

160
00:09:33,088 --> 00:09:35,888
And what the language does, when you type in the query at the top level, it takes this mechanism, feeds in one single empty dictionary, and then for each thing that comes out takes the original query and instantiates the result with all the different dictionaries, producing a new stream of instantiated patterns here.

161
00:09:36,560 --> 00:09:40,448
And what the language does, when you type in the query at the top level, it takes this mechanism, feeds in one single empty dictionary, and then for each thing that comes out takes the original query and instantiates the result with all the different dictionaries, producing a new stream of instantiated patterns here.

162
00:09:40,816 --> 00:09:44,368
And what the language does, when you type in the query at the top level, it takes this mechanism, feeds in one single empty dictionary, and then for each thing that comes out takes the original query and instantiates the result with all the different dictionaries, producing a new stream of instantiated patterns here.

163
00:09:44,990 --> 00:09:46,512
And that's what gets printed on the terminal.

164
00:09:48,170 --> 00:09:51,248
That's the basic mechanism going on there.

165
00:09:53,510 --> 00:09:55,488
Well, why is that so complicated?

166
00:09:57,712 --> 00:10:01,008
You probably can think of a lot simpler ways to arrange this match for a primitive query rather than having all of these streams floating around.

167
00:10:01,376 --> 00:10:04,256
You probably can think of a lot simpler ways to arrange this match for a primitive query rather than having all of these streams floating around.

168
00:10:05,184 --> 00:10:06,096
And the answer is-- you probably guess already.

169
00:10:07,152 --> 00:10:08,512
And the answer is-- you probably guess already.

170
00:10:10,860 --> 00:10:14,096
The answer is this thing extends elegantly to implement the means of combination.

171
00:10:14,560 --> 00:10:16,768
The answer is this thing extends elegantly to implement the means of combination.

172
00:10:17,790 --> 00:10:18,800
So, for instance, suppose I don't only want to do this.

173
00:10:20,656 --> 00:10:22,470
So, for instance, suppose I don't only want to do this.

174
00:10:22,470 --> 00:10:26,960
I don't want to say who to be everybody's job description.

175
00:10:27,230 --> 00:10:28,352
Suppose I want to say AND the job of x is d dot y and the supervisor of x is z.

176
00:10:29,472 --> 00:10:35,920
Suppose I want to say AND the job of x is d dot y and the supervisor of x is z.

177
00:10:36,800 --> 00:10:47,040
Suppose I want to say AND the job of x is d dot y and the supervisor of x is z.

178
00:10:48,800 --> 00:10:50,672
Now, supervisor of x is z

179
00:10:51,392 --> 00:10:52,960
Now, supervisor of x is z is going to be another primitive query that has the same shape to take in a stream of data objects, a stream of initial dictionaries, which are the restrictions to try and use when you match, and it's going to put out a stream of dictionaries.

180
00:10:53,712 --> 00:10:58,432
Now, supervisor of x is z is going to be another primitive query that has the same shape to take in a stream of data objects, a stream of initial dictionaries, which are the restrictions to try and use when you match, and it's going to put out a stream of dictionaries.

181
00:10:59,184 --> 00:11:01,648
Now, supervisor of x is z is going to be another primitive query that has the same shape to take in a stream of data objects, a stream of initial dictionaries, which are the restrictions to try and use when you match, and it's going to put out a stream of dictionaries.

182
00:11:01,680 --> 00:11:05,520
Now, supervisor of x is z is going to be another primitive query that has the same shape to take in a stream of data objects, a stream of initial dictionaries, which are the restrictions to try and use when you match, and it's going to put out a stream of dictionaries.

183
00:11:05,536 --> 00:11:07,440
Now, supervisor of x is z is going to be another primitive query that has the same shape to take in a stream of data objects, a stream of initial dictionaries, which are the restrictions to try and use when you match, and it's going to put out a stream of dictionaries.

184
00:11:08,700 --> 00:11:10,800
So that's what this primitive query looks like.

185
00:11:11,504 --> 00:11:12,910
And how do I implement the AND?

186
00:11:12,910 --> 00:11:13,450
Well, it's simple.

187
00:11:13,450 --> 00:11:14,448
I just hook them together.

188
00:11:14,880 --> 00:11:16,288
I take the output of this one, and I put that to the input of that one.

189
00:11:16,960 --> 00:11:18,816
I take the output of this one, and I put that to the input of that one.

190
00:11:19,830 --> 00:11:21,840
And I take the dictionary here and I fan it out.

191
00:11:26,570 --> 00:11:27,968
And then you see how that's going to work, because what's going to happen is a frame will now come in here, which has a binding for x, y, and d.

192
00:11:29,050 --> 00:11:32,448
And then you see how that's going to work, because what's going to happen is a frame will now come in here, which has a binding for x, y, and d.

193
00:11:32,512 --> 00:11:36,848
And then you see how that's going to work, because what's going to happen is a frame will now come in here, which has a binding for x, y, and d.

194
00:11:37,920 --> 00:11:39,280
And then when this one gets it, it'll say, oh, gee, subject to these restrictions, which now already have values in the dictionary for y and x and d, it looks in the database and says, gee, can I find any supervisor facts?

195
00:11:39,296 --> 00:11:41,600
And then when this one gets it, it'll say, oh, gee, subject to these restrictions, which now already have values in the dictionary for y and x and d, it looks in the database and says, gee, can I find any supervisor facts?

196
00:11:42,176 --> 00:11:49,248
And then when this one gets it, it'll say, oh, gee, subject to these restrictions, which now already have values in the dictionary for y and x and d, it looks in the database and says, gee, can I find any supervisor facts?

197
00:11:51,808 --> 00:11:53,088
And then when this one gets it, it'll say, oh, gee, subject to these restrictions, which now already have values in the dictionary for y and x and d, it looks in the database and says, gee, can I find any supervisor facts?

198
00:11:53,120 --> 00:11:54,928
And then when this one gets it, it'll say, oh, gee, subject to these restrictions, which now already have values in the dictionary for y and x and d, it looks in the database and says, gee, can I find any supervisor facts?

199
00:11:56,080 --> 00:11:57,024
And if it finds any, out will come dictionaries which have bindings for y and x and d and z now.

200
00:11:57,184 --> 00:11:58,512
And if it finds any, out will come dictionaries which have bindings for y and x and d and z now.

201
00:11:59,584 --> 00:12:09,340
And if it finds any, out will come dictionaries which have bindings for y and x and d and z now.

202
00:12:12,070 --> 00:12:14,096
And then notice that because the frames coming in here have these restrictions, that's the thing that assures that when you do the AND, this x will mean the same thing as that x.

203
00:12:14,192 --> 00:12:17,248
And then notice that because the frames coming in here have these restrictions, that's the thing that assures that when you do the AND, this x will mean the same thing as that x.

204
00:12:17,616 --> 00:12:18,880
And then notice that because the frames coming in here have these restrictions, that's the thing that assures that when you do the AND, this x will mean the same thing as that x.

205
00:12:19,152 --> 00:12:20,272
And then notice that because the frames coming in here have these restrictions, that's the thing that assures that when you do the AND, this x will mean the same thing as that x.

206
00:12:20,496 --> 00:12:24,624
And then notice that because the frames coming in here have these restrictions, that's the thing that assures that when you do the AND, this x will mean the same thing as that x.

207
00:12:26,470 --> 00:12:28,960
Because by the time something comes floating in here, x has a value that you have to match against consistently.

208
00:12:29,968 --> 00:12:32,656
Because by the time something comes floating in here, x has a value that you have to match against consistently.

209
00:12:34,460 --> 00:12:36,176
And then you remember from the code from the matcher, there was something in the way the matcher did dictionaries that arrange consistent matches.

210
00:12:36,192 --> 00:12:39,824
And then you remember from the code from the matcher, there was something in the way the matcher did dictionaries that arrange consistent matches.

211
00:12:40,928 --> 00:12:41,776
So there's AND.

212
00:12:44,080 --> 00:12:46,944
The important point to notice is the general shape.

213
00:12:48,570 --> 00:12:49,312
Look at what happened: the AND of two queries, say, P and Q.

214
00:12:49,424 --> 00:12:51,552
Look at what happened: the AND of two queries, say, P and Q.

215
00:12:52,880 --> 00:12:55,616
Here's P and Q. The AND of two queries, well, it looks like this.

216
00:12:57,296 --> 00:12:58,608
Here's P and Q. The AND of two queries, well, it looks like this.

217
00:13:00,272 --> 00:13:01,190
Here's P and Q. The AND of two queries, well, it looks like this.

218
00:13:01,190 --> 00:13:04,448
Each query takes in a stream from the database, a stream of inputs, and puts out a stream of outputs.

219
00:13:04,544 --> 00:13:05,712
Each query takes in a stream from the database, a stream of inputs, and puts out a stream of outputs.

220
00:13:06,336 --> 00:13:08,176
Each query takes in a stream from the database, a stream of inputs, and puts out a stream of outputs.

221
00:13:10,230 --> 00:13:11,728
And the important point to notice is that if I draw a box around this thing and say this is AND of P and Q, then that box has exactly the same overall shape.

222
00:13:12,208 --> 00:13:15,024
And the important point to notice is that if I draw a box around this thing and say this is AND of P and Q, then that box has exactly the same overall shape.

223
00:13:19,264 --> 00:13:23,648
And the important point to notice is that if I draw a box around this thing and say this is AND of P and Q, then that box has exactly the same overall shape.

224
00:13:25,664 --> 00:13:30,384
And the important point to notice is that if I draw a box around this thing and say this is AND of P and Q, then that box has exactly the same overall shape.

225
00:13:32,048 --> 00:13:34,200
It's something that takes in a stream from the database.

226
00:13:34,200 --> 00:13:35,744
Here it's going to get fanned out inside, but from the outside you don't see that.

227
00:13:36,608 --> 00:13:37,936
Here it's going to get fanned out inside, but from the outside you don't see that.

228
00:13:38,160 --> 00:13:40,640
It takes an input stream and puts out an output stream.

229
00:13:42,064 --> 00:13:43,168
So this is AND.

230
00:13:43,570 --> 00:13:45,728
And then similarly, OR would look like this.

231
00:13:46,020 --> 00:13:49,584
OR would-- although I didn't show you examples of OR.

232
00:13:49,840 --> 00:13:54,704
OR would say can I find all ways of matching P or Q. So I have P and Q. Each will have their shape.

233
00:13:55,808 --> 00:13:58,070
OR would say can I find all ways of matching P or Q. So I have P and Q. Each will have their shape.

234
00:14:04,460 --> 00:14:06,688
And the way OR is implemented is I'll take my database stream.

235
00:14:08,544 --> 00:14:10,912
And the way OR is implemented is I'll take my database stream.

236
00:14:12,500 --> 00:14:13,490
I'll fan it out.

237
00:14:13,490 --> 00:14:16,048
I'll put one into P and one into Q. I'll take my initial query stream coming in and fan it out.

238
00:14:17,440 --> 00:14:21,980
I'll put one into P and one into Q. I'll take my initial query stream coming in and fan it out.

239
00:14:26,750 --> 00:14:29,168
So I'll look at all the answers I might get from P and all the answers I might get from Q, and I'll put them through some sort of thing that appends them or merges the result into one stream, and that's what will come out.

240
00:14:29,296 --> 00:14:31,088
So I'll look at all the answers I might get from P and all the answers I might get from Q, and I'll put them through some sort of thing that appends them or merges the result into one stream, and that's what will come out.

241
00:14:31,616 --> 00:14:34,560
So I'll look at all the answers I might get from P and all the answers I might get from Q, and I'll put them through some sort of thing that appends them or merges the result into one stream, and that's what will come out.

242
00:14:34,624 --> 00:14:37,488
So I'll look at all the answers I might get from P and all the answers I might get from Q, and I'll put them through some sort of thing that appends them or merges the result into one stream, and that's what will come out.

243
00:14:39,648 --> 00:14:40,880
So I'll look at all the answers I might get from P and all the answers I might get from Q, and I'll put them through some sort of thing that appends them or merges the result into one stream, and that's what will come out.

244
00:14:41,080 --> 00:14:48,240
And this whole thing from the outside is OR.

245
00:14:52,350 --> 00:14:54,896
And again, you see it has the same overall shape when looked at from the outside.

246
00:14:55,072 --> 00:14:56,544
And again, you see it has the same overall shape when looked at from the outside.

247
00:15:01,000 --> 00:15:01,616
What's NOT?

248
00:15:02,020 --> 00:15:03,456
NOT works kind of the same way.

249
00:15:04,310 --> 00:15:05,952
If I have some query P, I take the primitive query for P.

250
00:15:06,864 --> 00:15:13,504
If I have some query P, I take the primitive query for P.

251
00:15:14,690 --> 00:15:16,320
Here, I'm going to implement NOT P. And NOT's just going to act as a filter.

252
00:15:18,688 --> 00:15:20,544
Here, I'm going to implement NOT P. And NOT's just going to act as a filter.

253
00:15:20,720 --> 00:15:21,952
I'll take in the database and my original stream of dictionaries coming in, and what NOT P will do is it will filter these guys.

254
00:15:23,840 --> 00:15:28,288
I'll take in the database and my original stream of dictionaries coming in, and what NOT P will do is it will filter these guys.

255
00:15:28,784 --> 00:15:37,408
I'll take in the database and my original stream of dictionaries coming in, and what NOT P will do is it will filter these guys.

256
00:15:39,020 --> 00:15:40,096
And the way it will filter it, it will say when I get in a dictionary here, I'll find all the matches, and if I find any, I'll throw it away.

257
00:15:40,192 --> 00:15:42,704
And the way it will filter it, it will say when I get in a dictionary here, I'll find all the matches, and if I find any, I'll throw it away.

258
00:15:43,424 --> 00:15:44,656
And the way it will filter it, it will say when I get in a dictionary here, I'll find all the matches, and if I find any, I'll throw it away.

259
00:15:44,832 --> 00:15:46,480
And the way it will filter it, it will say when I get in a dictionary here, I'll find all the matches, and if I find any, I'll throw it away.

260
00:15:47,460 --> 00:15:49,936
And if I don't find any matches to something coming in here, I'll just pass that through, so NOT is a pure filter.

261
00:15:50,128 --> 00:15:51,376
And if I don't find any matches to something coming in here, I'll just pass that through, so NOT is a pure filter.

262
00:15:52,400 --> 00:15:53,552
And if I don't find any matches to something coming in here, I'll just pass that through, so NOT is a pure filter.

263
00:15:55,344 --> 00:15:59,980
So AND is-- think of these sort of electoral resistors or something.

264
00:15:59,980 --> 00:16:01,856
AND is series combination and OR is parallel combination.

265
00:16:02,496 --> 00:16:04,140
AND is series combination and OR is parallel combination.

266
00:16:04,960 --> 00:16:07,460
And then NOT is not going to extend any dictionaries at all.

267
00:16:07,460 --> 00:16:08,400
It's just going to filter it.

268
00:16:08,750 --> 00:16:11,792
It's going to throw away the ones for which it finds a way to match.

269
00:16:12,640 --> 00:16:14,192
And lisp-value is sort of the same way.

270
00:16:14,848 --> 00:16:16,600
The filter's a little more complicated.

271
00:16:16,600 --> 00:16:17,376
It applies to predicate.

272
00:16:19,936 --> 00:16:21,648
The major point to notice here, and it's a major point we've looked at before, is this idea of closure.

273
00:16:21,920 --> 00:16:23,552
The major point to notice here, and it's a major point we've looked at before, is this idea of closure.

274
00:16:23,648 --> 00:16:25,296
The major point to notice here, and it's a major point we've looked at before, is this idea of closure.

275
00:16:28,224 --> 00:16:30,192
The things that we build as a means of combination have the same overall structure as the primitive things that we're combining.

276
00:16:30,528 --> 00:16:31,792
The things that we build as a means of combination have the same overall structure as the primitive things that we're combining.

277
00:16:31,952 --> 00:16:34,512
The things that we build as a means of combination have the same overall structure as the primitive things that we're combining.

278
00:16:35,696 --> 00:16:37,584
The things that we build as a means of combination have the same overall structure as the primitive things that we're combining.

279
00:16:39,750 --> 00:16:43,728
So the AND of two things when looked at from the outside has the same shape.

280
00:16:44,630 --> 00:16:46,144
And what that means is that this box here could be an AND or an OR or a NOT or something because it has the same shape to interface to the larger things.

281
00:16:46,944 --> 00:16:49,328
And what that means is that this box here could be an AND or an OR or a NOT or something because it has the same shape to interface to the larger things.

282
00:16:49,408 --> 00:16:50,176
And what that means is that this box here could be an AND or an OR or a NOT or something because it has the same shape to interface to the larger things.

283
00:16:50,208 --> 00:16:54,224
And what that means is that this box here could be an AND or an OR or a NOT or something because it has the same shape to interface to the larger things.

284
00:16:54,950 --> 00:16:56,688
It's the same thing that allowed us to get complexity in the Escher picture language or allows you to immediately build up these complicated structures just out of pairs.

285
00:16:56,928 --> 00:16:58,960
It's the same thing that allowed us to get complexity in the Escher picture language or allows you to immediately build up these complicated structures just out of pairs.

286
00:16:59,552 --> 00:17:03,264
It's the same thing that allowed us to get complexity in the Escher picture language or allows you to immediately build up these complicated structures just out of pairs.

287
00:17:03,936 --> 00:17:04,784
It's closure.

288
00:17:06,280 --> 00:17:08,064
And that's the thing that allowed me to do what by now you took for granted when I said, gee, there's a query which is AND of job and salary, and I said, oh, there's another one, which is AND of job, a NOT of something.

289
00:17:09,648 --> 00:17:11,728
And that's the thing that allowed me to do what by now you took for granted when I said, gee, there's a query which is AND of job and salary, and I said, oh, there's another one, which is AND of job, a NOT of something.

290
00:17:11,760 --> 00:17:13,600
And that's the thing that allowed me to do what by now you took for granted when I said, gee, there's a query which is AND of job and salary, and I said, oh, there's another one, which is AND of job, a NOT of something.

291
00:17:13,952 --> 00:17:16,720
And that's the thing that allowed me to do what by now you took for granted when I said, gee, there's a query which is AND of job and salary, and I said, oh, there's another one, which is AND of job, a NOT of something.

292
00:17:17,168 --> 00:17:18,896
And that's the thing that allowed me to do what by now you took for granted when I said, gee, there's a query which is AND of job and salary, and I said, oh, there's another one, which is AND of job, a NOT of something.

293
00:17:19,260 --> 00:17:22,912
The fact that I can do that is a direct consequence of this closure principle.

294
00:17:25,920 --> 00:17:27,088
OK, let's break and then we'll go on.

295
00:17:29,328 --> 00:17:30,896
AUDIENCE: Where does the dictionary come from?

296
00:17:30,990 --> 00:17:32,970
PROFESSOR: The dictionary comes initially from what you type in.

297
00:17:34,880 --> 00:17:36,064
PROFESSOR: The dictionary comes initially from what you type in.

298
00:17:36,096 --> 00:17:37,328
So when you start this up, the first thing it does is set up this whole structure.

299
00:17:39,168 --> 00:17:41,090
So when you start this up, the first thing it does is set up this whole structure.

300
00:17:41,090 --> 00:17:42,640
It puts in one empty dictionary.

301
00:17:45,000 --> 00:17:47,248
And if all you have is one primitive query, then what will come out is a bunch of dictionaries with things filled in.

302
00:17:48,240 --> 00:17:51,104
And if all you have is one primitive query, then what will come out is a bunch of dictionaries with things filled in.

303
00:17:52,310 --> 00:17:54,336
The general situation that I have here is when this is in the middle of some nest of combined things.

304
00:17:54,464 --> 00:17:56,048
The general situation that I have here is when this is in the middle of some nest of combined things.

305
00:17:56,380 --> 00:17:59,710
The general situation that I have here is when this is in the middle of some nest of combined things.

306
00:18:01,552 --> 00:18:02,304
So by the time.

307
00:18:02,380 --> 00:18:03,790
Let's look at the picture over here.

308
00:18:04,384 --> 00:18:06,730
This supervisor query gets in some dictionary.

309
00:18:06,730 --> 00:18:08,032
Where did this one come from?

310
00:18:08,730 --> 00:18:11,152
This dictionary came from the fact that I'm looking at the output of this primitive query.

311
00:18:12,848 --> 00:18:14,896
This dictionary came from the fact that I'm looking at the output of this primitive query.

312
00:18:16,260 --> 00:18:17,888
So maybe to be very specific, if I literally typed in just this query at the top level, this AND, what would actually happen is it would build this structure and start up this whole thing with one empty dictionary.

313
00:18:18,352 --> 00:18:21,728
So maybe to be very specific, if I literally typed in just this query at the top level, this AND, what would actually happen is it would build this structure and start up this whole thing with one empty dictionary.

314
00:18:22,272 --> 00:18:22,928
So maybe to be very specific, if I literally typed in just this query at the top level, this AND, what would actually happen is it would build this structure and start up this whole thing with one empty dictionary.

315
00:18:23,072 --> 00:18:25,280
So maybe to be very specific, if I literally typed in just this query at the top level, this AND, what would actually happen is it would build this structure and start up this whole thing with one empty dictionary.

316
00:18:25,504 --> 00:18:26,944
So maybe to be very specific, if I literally typed in just this query at the top level, this AND, what would actually happen is it would build this structure and start up this whole thing with one empty dictionary.

317
00:18:28,528 --> 00:18:30,224
So maybe to be very specific, if I literally typed in just this query at the top level, this AND, what would actually happen is it would build this structure and start up this whole thing with one empty dictionary.

318
00:18:31,770 --> 00:18:34,336
And now this one would process, and a whole bunch of dictionaries would come out with x, y's and d's in them.

319
00:18:34,368 --> 00:18:37,360
And now this one would process, and a whole bunch of dictionaries would come out with x, y's and d's in them.

320
00:18:38,640 --> 00:18:39,584
Run it through this one.

321
00:18:40,190 --> 00:18:42,160
So now that's the input to this one.

322
00:18:42,160 --> 00:18:43,728
This one would now put out some other stuff.

323
00:18:45,040 --> 00:18:48,224
And if this itself were buried in some larger thing, like an OR of something, then that would go feed into the next one.

324
00:18:49,312 --> 00:18:51,008
And if this itself were buried in some larger thing, like an OR of something, then that would go feed into the next one.

325
00:18:53,424 --> 00:18:55,712
And if this itself were buried in some larger thing, like an OR of something, then that would go feed into the next one.

326
00:18:58,560 --> 00:19:01,280
So you initially get only one empty dictionary when you start it, but as you're in the middle of processing these compounds things, that's where these cascades of dictionaries start getting generated.

327
00:19:01,680 --> 00:19:04,080
So you initially get only one empty dictionary when you start it, but as you're in the middle of processing these compounds things, that's where these cascades of dictionaries start getting generated.

328
00:19:04,112 --> 00:19:06,656
So you initially get only one empty dictionary when you start it, but as you're in the middle of processing these compounds things, that's where these cascades of dictionaries start getting generated.

329
00:19:07,660 --> 00:19:12,280
AUDIENCE: Dictionaries only come about as a result of using the queries?

330
00:19:15,120 --> 00:19:17,696
Or do they become-- do they stay someplace in space like the database does?

331
00:19:18,848 --> 00:19:22,816
Or do they become-- do they stay someplace in space like the database does?

332
00:19:23,680 --> 00:19:24,980
Are these temporary items?

333
00:19:24,980 --> 00:19:27,184
PROFESSOR: They're created temporarily in the matcher.

334
00:19:28,030 --> 00:19:29,880
Really, they're someplace in storage.

335
00:19:29,880 --> 00:19:33,024
Initially, someone creates a thing called the empty dictionary that gets initially fed to this match procedure, and then the match procedure builds some dictionaries, and they get passed on and on.

336
00:19:34,224 --> 00:19:36,800
Initially, someone creates a thing called the empty dictionary that gets initially fed to this match procedure, and then the match procedure builds some dictionaries, and they get passed on and on.

337
00:19:36,816 --> 00:19:40,352
Initially, someone creates a thing called the empty dictionary that gets initially fed to this match procedure, and then the match procedure builds some dictionaries, and they get passed on and on.

338
00:19:40,768 --> 00:19:42,480
AUDIENCE: OK, so they'll go way after the match?

339
00:19:43,648 --> 00:19:45,456
PROFESSOR: They'll go away when no one needs them again, yeah.

340
00:19:51,900 --> 00:19:55,376
AUDIENCE: It appears that the AND performs some redundant searches of the database.

341
00:19:55,968 --> 00:19:59,904
If the first clause matched, let's say, the third element and not on the first two elements, the second clause is going to look at those first two elements again, discarding them because they don't match.

342
00:20:00,256 --> 00:20:03,648
If the first clause matched, let's say, the third element and not on the first two elements, the second clause is going to look at those first two elements again, discarding them because they don't match.

343
00:20:04,320 --> 00:20:06,592
If the first clause matched, let's say, the third element and not on the first two elements, the second clause is going to look at those first two elements again, discarding them because they don't match.

344
00:20:06,700 --> 00:20:08,720
The match is already in the dictionary.

345
00:20:10,000 --> 00:20:12,560
Would it makes sense to carry the data element from the database along with the dictionary?

346
00:20:12,576 --> 00:20:14,432
Would it makes sense to carry the data element from the database along with the dictionary?

347
00:20:15,696 --> 00:20:19,488
PROFESSOR: Well, in general, there are other ways to arrange this search, and there's some analysis that you can do.

348
00:20:20,128 --> 00:20:21,740
PROFESSOR: Well, in general, there are other ways to arrange this search, and there's some analysis that you can do.

349
00:20:21,740 --> 00:20:23,168
I think there's a problem in the book, which talks about a different way that you can cascade AND to eliminate various kinds of redundancies.

350
00:20:23,872 --> 00:20:26,656
I think there's a problem in the book, which talks about a different way that you can cascade AND to eliminate various kinds of redundancies.

351
00:20:27,008 --> 00:20:29,200
I think there's a problem in the book, which talks about a different way that you can cascade AND to eliminate various kinds of redundancies.

352
00:20:29,850 --> 00:20:30,720
This one is meant to be-- was mainly meant to be very simple so you can see how they fit together.

353
00:20:31,328 --> 00:20:34,544
This one is meant to be-- was mainly meant to be very simple so you can see how they fit together.

354
00:20:34,704 --> 00:20:35,380
But you're quite right.

355
00:20:35,380 --> 00:20:37,328
There are redundancies here that you can get rid of.

356
00:20:38,370 --> 00:20:40,800
That's another reason why this language is somewhat slow.

357
00:20:41,190 --> 00:20:42,704
There are a lot smarter things you can do.

358
00:20:42,930 --> 00:20:46,224
We're just trying to show you a very simple, in principle, implementation.

359
00:20:51,220 --> 00:20:53,232
AUDIENCE: Did you model this language on Prolog, or did it just come out looking like Prolog?

360
00:20:53,248 --> 00:20:55,136
AUDIENCE: Did you model this language on Prolog, or did it just come out looking like Prolog?

361
00:21:04,960 --> 00:21:07,088
PROFESSOR: Well, Jerry insulted a whole bunch of people yesterday, so I might as well say that the MIT attitude towards Prolog is something that people did in about 1971 and decided that it wasn't really the right thing and stopped.

362
00:21:07,248 --> 00:21:09,920
PROFESSOR: Well, Jerry insulted a whole bunch of people yesterday, so I might as well say that the MIT attitude towards Prolog is something that people did in about 1971 and decided that it wasn't really the right thing and stopped.

363
00:21:10,192 --> 00:21:12,800
PROFESSOR: Well, Jerry insulted a whole bunch of people yesterday, so I might as well say that the MIT attitude towards Prolog is something that people did in about 1971 and decided that it wasn't really the right thing and stopped.

364
00:21:12,832 --> 00:21:15,600
PROFESSOR: Well, Jerry insulted a whole bunch of people yesterday, so I might as well say that the MIT attitude towards Prolog is something that people did in about 1971 and decided that it wasn't really the right thing and stopped.

365
00:21:16,120 --> 00:21:24,736
So we modeled this on the sort of natural way that this thing was done in about 1971, except at that point, we didn't do it with streams. After we were using it for about six months, we discovered that it had all these problems, some of which I'll talk about later.

366
00:21:25,136 --> 00:21:27,248
So we modeled this on the sort of natural way that this thing was done in about 1971, except at that point, we didn't do it with streams. After we were using it for about six months, we discovered that it had all these problems, some of which I'll talk about later.

367
00:21:28,272 --> 00:21:33,040
So we modeled this on the sort of natural way that this thing was done in about 1971, except at that point, we didn't do it with streams. After we were using it for about six months, we discovered that it had all these problems, some of which I'll talk about later.

368
00:21:33,088 --> 00:21:36,304
So we modeled this on the sort of natural way that this thing was done in about 1971, except at that point, we didn't do it with streams. After we were using it for about six months, we discovered that it had all these problems, some of which I'll talk about later.

369
00:21:37,330 --> 00:21:38,192
And we said, gee, Prolog must have fixed those, and then we found out that it didn't.

370
00:21:38,512 --> 00:21:41,250
And we said, gee, Prolog must have fixed those, and then we found out that it didn't.

371
00:21:41,250 --> 00:21:43,024
So this does about the same thing as Prolog.

372
00:21:43,600 --> 00:21:44,950
AUDIENCE: Does Prolog use streams?

373
00:21:44,950 --> 00:21:46,200
PROFESSOR: No.

374
00:21:46,784 --> 00:21:51,040
In how it behaves, it behaves a lot like Prolog.

375
00:21:51,040 --> 00:21:52,960
Prolog uses a backtracking strategy.

376
00:21:53,800 --> 00:21:55,712
But the other thing that's really good about Prolog that makes it a usable thing is that there's a really very, very well-engineered compiler technology that makes it run fast. So although you saw the merge spitting out these answers very, very slowly, a real Prolog will run very, very fast. Because even though it's sort of doing this, the real work that went into Prolog is a very, very excellent compiler effort.

377
00:21:55,728 --> 00:21:57,984
But the other thing that's really good about Prolog that makes it a usable thing is that there's a really very, very well-engineered compiler technology that makes it run fast. So although you saw the merge spitting out these answers very, very slowly, a real Prolog will run very, very fast. Because even though it's sort of doing this, the real work that went into Prolog is a very, very excellent compiler effort.

378
00:21:58,288 --> 00:22:04,096
But the other thing that's really good about Prolog that makes it a usable thing is that there's a really very, very well-engineered compiler technology that makes it run fast. So although you saw the merge spitting out these answers very, very slowly, a real Prolog will run very, very fast. Because even though it's sort of doing this, the real work that went into Prolog is a very, very excellent compiler effort.

379
00:22:04,112 --> 00:22:05,328
But the other thing that's really good about Prolog that makes it a usable thing is that there's a really very, very well-engineered compiler technology that makes it run fast. So although you saw the merge spitting out these answers very, very slowly, a real Prolog will run very, very fast. Because even though it's sort of doing this, the real work that went into Prolog is a very, very excellent compiler effort.

380
00:22:06,656 --> 00:22:10,816
But the other thing that's really good about Prolog that makes it a usable thing is that there's a really very, very well-engineered compiler technology that makes it run fast. So although you saw the merge spitting out these answers very, very slowly, a real Prolog will run very, very fast. Because even though it's sort of doing this, the real work that went into Prolog is a very, very excellent compiler effort.

381
00:22:11,664 --> 00:22:13,616
But the other thing that's really good about Prolog that makes it a usable thing is that there's a really very, very well-engineered compiler technology that makes it run fast. So although you saw the merge spitting out these answers very, very slowly, a real Prolog will run very, very fast. Because even though it's sort of doing this, the real work that went into Prolog is a very, very excellent compiler effort.

382
00:22:14,704 --> 00:22:16,480
But the other thing that's really good about Prolog that makes it a usable thing is that there's a really very, very well-engineered compiler technology that makes it run fast. So although you saw the merge spitting out these answers very, very slowly, a real Prolog will run very, very fast. Because even though it's sort of doing this, the real work that went into Prolog is a very, very excellent compiler effort.

383
00:22:16,672 --> 00:22:18,240
But the other thing that's really good about Prolog that makes it a usable thing is that there's a really very, very well-engineered compiler technology that makes it run fast. So although you saw the merge spitting out these answers very, very slowly, a real Prolog will run very, very fast. Because even though it's sort of doing this, the real work that went into Prolog is a very, very excellent compiler effort.

384
00:22:18,592 --> 00:22:20,736
But the other thing that's really good about Prolog that makes it a usable thing is that there's a really very, very well-engineered compiler technology that makes it run fast. So although you saw the merge spitting out these answers very, very slowly, a real Prolog will run very, very fast. Because even though it's sort of doing this, the real work that went into Prolog is a very, very excellent compiler effort.

385
00:22:24,304 --> 00:22:25,216
Let's take a break.

386
00:23:16,650 --> 00:23:18,832
We've looked at the primitive queries and the ways that streams are used to implement the means of combination: AND and OR and NOT.

387
00:23:19,216 --> 00:23:23,520
We've looked at the primitive queries and the ways that streams are used to implement the means of combination: AND and OR and NOT.

388
00:23:23,792 --> 00:23:25,728
We've looked at the primitive queries and the ways that streams are used to implement the means of combination: AND and OR and NOT.

389
00:23:26,950 --> 00:23:28,432
Now, let go on to the means of abstraction.

390
00:23:29,580 --> 00:23:32,800
Remember, the means of abstraction in this language are rules.

391
00:23:35,150 --> 00:23:37,792
So z is a boss in division d if there's some x who has a job in division d and z is the supervisor of x.

392
00:23:39,184 --> 00:23:43,776
So z is a boss in division d if there's some x who has a job in division d and z is the supervisor of x.

393
00:23:45,680 --> 00:23:47,472
So z is a boss in division d if there's some x who has a job in division d and z is the supervisor of x.

394
00:23:48,900 --> 00:23:50,608
That's what it means for someone to be a boss.

395
00:23:52,260 --> 00:23:53,152
And in effect, if you think about what we're doing with relation to this, there's the query we wrote-- the job of x is in d and the supervisor of x is z-- what we in effect want to do is take this whole mess and draw a box around it and say this whole thing inside the box is boss of z in division d.

396
00:23:53,344 --> 00:23:55,616
And in effect, if you think about what we're doing with relation to this, there's the query we wrote-- the job of x is in d and the supervisor of x is z-- what we in effect want to do is take this whole mess and draw a box around it and say this whole thing inside the box is boss of z in division d.

397
00:23:56,800 --> 00:24:01,904
And in effect, if you think about what we're doing with relation to this, there's the query we wrote-- the job of x is in d and the supervisor of x is z-- what we in effect want to do is take this whole mess and draw a box around it and say this whole thing inside the box is boss of z in division d.

398
00:24:02,192 --> 00:24:04,288
And in effect, if you think about what we're doing with relation to this, there's the query we wrote-- the job of x is in d and the supervisor of x is z-- what we in effect want to do is take this whole mess and draw a box around it and say this whole thing inside the box is boss of z in division d.

399
00:24:05,072 --> 00:24:06,576
And in effect, if you think about what we're doing with relation to this, there's the query we wrote-- the job of x is in d and the supervisor of x is z-- what we in effect want to do is take this whole mess and draw a box around it and say this whole thing inside the box is boss of z in division d.

400
00:24:19,050 --> 00:24:22,170
And in effect, if you think about what we're doing with relation to this, there's the query we wrote-- the job of x is in d and the supervisor of x is z-- what we in effect want to do is take this whole mess and draw a box around it and say this whole thing inside the box is boss of z in division d.

401
00:24:23,376 --> 00:24:32,480
And in effect, if you think about what we're doing with relation to this, there's the query we wrote-- the job of x is in d and the supervisor of x is z-- what we in effect want to do is take this whole mess and draw a box around it and say this whole thing inside the box is boss of z in division d.

402
00:24:33,900 --> 00:24:35,250
That's in effect what we want to do.

403
00:24:38,720 --> 00:24:39,728
So, for instance, if we've done that, and we want to check whether or not it's true that Ben Bitdiddle is a boss in the computer division, so if I want to say boss of Ben Bitdiddle in the computer division, imagine typing that in as query to the system, in effect what we want to do is set up a dictionary here, which has z to Ben Bitdiddle and d to computer.

404
00:24:43,184 --> 00:24:44,080
So, for instance, if we've done that, and we want to check whether or not it's true that Ben Bitdiddle is a boss in the computer division, so if I want to say boss of Ben Bitdiddle in the computer division, imagine typing that in as query to the system, in effect what we want to do is set up a dictionary here, which has z to Ben Bitdiddle and d to computer.

405
00:24:45,008 --> 00:24:47,840
So, for instance, if we've done that, and we want to check whether or not it's true that Ben Bitdiddle is a boss in the computer division, so if I want to say boss of Ben Bitdiddle in the computer division, imagine typing that in as query to the system, in effect what we want to do is set up a dictionary here, which has z to Ben Bitdiddle and d to computer.

406
00:24:47,952 --> 00:24:50,512
So, for instance, if we've done that, and we want to check whether or not it's true that Ben Bitdiddle is a boss in the computer division, so if I want to say boss of Ben Bitdiddle in the computer division, imagine typing that in as query to the system, in effect what we want to do is set up a dictionary here, which has z to Ben Bitdiddle and d to computer.

407
00:24:51,104 --> 00:25:02,864
So, for instance, if we've done that, and we want to check whether or not it's true that Ben Bitdiddle is a boss in the computer division, so if I want to say boss of Ben Bitdiddle in the computer division, imagine typing that in as query to the system, in effect what we want to do is set up a dictionary here, which has z to Ben Bitdiddle and d to computer.

408
00:25:04,784 --> 00:25:07,088
So, for instance, if we've done that, and we want to check whether or not it's true that Ben Bitdiddle is a boss in the computer division, so if I want to say boss of Ben Bitdiddle in the computer division, imagine typing that in as query to the system, in effect what we want to do is set up a dictionary here, which has z to Ben Bitdiddle and d to computer.

409
00:25:07,120 --> 00:25:09,168
So, for instance, if we've done that, and we want to check whether or not it's true that Ben Bitdiddle is a boss in the computer division, so if I want to say boss of Ben Bitdiddle in the computer division, imagine typing that in as query to the system, in effect what we want to do is set up a dictionary here, which has z to Ben Bitdiddle and d to computer.

410
00:25:10,672 --> 00:25:12,928
So, for instance, if we've done that, and we want to check whether or not it's true that Ben Bitdiddle is a boss in the computer division, so if I want to say boss of Ben Bitdiddle in the computer division, imagine typing that in as query to the system, in effect what we want to do is set up a dictionary here, which has z to Ben Bitdiddle and d to computer.

411
00:25:15,824 --> 00:25:33,312
So, for instance, if we've done that, and we want to check whether or not it's true that Ben Bitdiddle is a boss in the computer division, so if I want to say boss of Ben Bitdiddle in the computer division, imagine typing that in as query to the system, in effect what we want to do is set up a dictionary here, which has z to Ben Bitdiddle and d to computer.

412
00:25:37,088 --> 00:25:38,624
Where did that dictionary come from?

413
00:25:38,688 --> 00:25:40,710
Let's look at the slide for one second.

414
00:25:40,710 --> 00:25:43,712
That dictionary came from matching the query that said boss of Ben Bitdiddle and computer onto the conclusion of the rule: boss of z and d.

415
00:25:44,304 --> 00:25:46,336
That dictionary came from matching the query that said boss of Ben Bitdiddle and computer onto the conclusion of the rule: boss of z and d.

416
00:25:46,512 --> 00:25:49,632
That dictionary came from matching the query that said boss of Ben Bitdiddle and computer onto the conclusion of the rule: boss of z and d.

417
00:25:51,650 --> 00:25:54,112
So we match the query to the conclusion of the rule.

418
00:25:54,190 --> 00:25:55,536
That gives us a dictionary, and that's the thing that we would now like to put into this whole big thing and process and see if anything comes out the other side.

419
00:25:58,992 --> 00:26:02,544
That gives us a dictionary, and that's the thing that we would now like to put into this whole big thing and process and see if anything comes out the other side.

420
00:26:02,928 --> 00:26:05,568
That gives us a dictionary, and that's the thing that we would now like to put into this whole big thing and process and see if anything comes out the other side.

421
00:26:06,670 --> 00:26:07,728
If anything comes out, it'll be true.

422
00:26:08,992 --> 00:26:09,880
If anything comes out, it'll be true.

423
00:26:11,330 --> 00:26:12,370
That's the basic idea.

424
00:26:12,370 --> 00:26:13,248
So in general, the way we implement a rule is we match the conclusion of the rule against something we might want to check it's true.

425
00:26:14,032 --> 00:26:15,408
So in general, the way we implement a rule is we match the conclusion of the rule against something we might want to check it's true.

426
00:26:15,856 --> 00:26:18,896
So in general, the way we implement a rule is we match the conclusion of the rule against something we might want to check it's true.

427
00:26:20,864 --> 00:26:22,960
So in general, the way we implement a rule is we match the conclusion of the rule against something we might want to check it's true.

428
00:26:23,580 --> 00:26:25,120
That match gives us a dictionary, and with respect to that dictionary, we process the body of the rule.

429
00:26:25,296 --> 00:26:28,224
That match gives us a dictionary, and with respect to that dictionary, we process the body of the rule.

430
00:26:30,352 --> 00:26:34,512
That match gives us a dictionary, and with respect to that dictionary, we process the body of the rule.

431
00:26:36,336 --> 00:26:37,680
Well, that's really all there is, except for two technical points.

432
00:26:38,640 --> 00:26:41,440
Well, that's really all there is, except for two technical points.

433
00:26:43,040 --> 00:26:44,320
The first technical point is that I might have said something else.

434
00:26:45,744 --> 00:26:47,264
The first technical point is that I might have said something else.

435
00:26:47,510 --> 00:26:48,416
I might have said who's the boss in the computer division?

436
00:26:50,544 --> 00:26:52,368
I might have said who's the boss in the computer division?

437
00:26:52,544 --> 00:26:56,320
So I might say boss of who in computer division.

438
00:27:00,784 --> 00:27:01,632
And if I did that, what I would really like to do in effect is start up this dictionary with a match that sort of says, well, d is computer and z is whatever who is.

439
00:27:02,576 --> 00:27:04,624
And if I did that, what I would really like to do in effect is start up this dictionary with a match that sort of says, well, d is computer and z is whatever who is.

440
00:27:05,040 --> 00:27:06,496
And if I did that, what I would really like to do in effect is start up this dictionary with a match that sort of says, well, d is computer and z is whatever who is.

441
00:27:08,352 --> 00:27:09,888
And if I did that, what I would really like to do in effect is start up this dictionary with a match that sort of says, well, d is computer and z is whatever who is.

442
00:27:09,936 --> 00:27:11,200
And if I did that, what I would really like to do in effect is start up this dictionary with a match that sort of says, well, d is computer and z is whatever who is.

443
00:27:14,352 --> 00:27:18,480
And if I did that, what I would really like to do in effect is start up this dictionary with a match that sort of says, well, d is computer and z is whatever who is.

444
00:27:21,700 --> 00:27:23,220
And our matcher won't quite do that.

445
00:27:23,220 --> 00:27:27,008
That's not quite matching a pattern against data.

446
00:27:28,580 --> 00:27:29,728
It's matching two patterns and saying are they consistent or not or what ways make them consistent.

447
00:27:29,744 --> 00:27:31,584
It's matching two patterns and saying are they consistent or not or what ways make them consistent.

448
00:27:31,904 --> 00:27:33,480
It's matching two patterns and saying are they consistent or not or what ways make them consistent.

449
00:27:33,480 --> 00:27:36,432
In other words, what we need is not quite a pattern matcher, but something a little bit more general called a unifier.

450
00:27:36,960 --> 00:27:38,912
In other words, what we need is not quite a pattern matcher, but something a little bit more general called a unifier.

451
00:27:39,136 --> 00:27:40,112
In other words, what we need is not quite a pattern matcher, but something a little bit more general called a unifier.

452
00:27:44,420 --> 00:27:48,064
And a unifier is a slight generalization of a pattern matcher.

453
00:27:49,530 --> 00:27:52,176
What a unifier does is take two patterns and say what's the most general thing you can substitute for the variables in those two patterns to make them satisfy the pattern simultaneously?

454
00:27:53,232 --> 00:27:57,536
What a unifier does is take two patterns and say what's the most general thing you can substitute for the variables in those two patterns to make them satisfy the pattern simultaneously?

455
00:27:58,208 --> 00:28:00,016
What a unifier does is take two patterns and say what's the most general thing you can substitute for the variables in those two patterns to make them satisfy the pattern simultaneously?

456
00:28:02,688 --> 00:28:05,088
What a unifier does is take two patterns and say what's the most general thing you can substitute for the variables in those two patterns to make them satisfy the pattern simultaneously?

457
00:28:05,680 --> 00:28:06,608
Let me give you an example.

458
00:28:08,900 --> 00:28:09,872
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

459
00:28:12,064 --> 00:28:14,496
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

460
00:28:15,760 --> 00:28:17,152
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

461
00:28:17,328 --> 00:28:20,048
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

462
00:28:20,400 --> 00:28:22,832
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

463
00:28:22,920 --> 00:28:25,440
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

464
00:28:25,632 --> 00:28:27,616
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

465
00:28:28,000 --> 00:28:30,144
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

466
00:28:33,070 --> 00:28:34,880
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

467
00:28:34,896 --> 00:28:36,176
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

468
00:28:36,352 --> 00:28:37,968
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

469
00:28:39,344 --> 00:28:41,920
If I have the pattern two-element list, which is x and x, so I have a two-element list where both elements are the same and otherwise I don't care what they are, and I unify that against the pattern that says there's a two-element list, and the first one is a and something in c and the second one is a and b and z, then what the unifier should tell me is, oh yeah, in that dictionary, x has to be a, b, c, and y has to be d and z has to be c.

470
00:28:43,440 --> 00:28:45,120
Those are the restrictions I'd have to put on the values of x, y, and z to make these two unify, or in other words, to make this match x and make this match x.

471
00:28:45,168 --> 00:28:47,584
Those are the restrictions I'd have to put on the values of x, y, and z to make these two unify, or in other words, to make this match x and make this match x.

472
00:28:48,144 --> 00:28:49,184
Those are the restrictions I'd have to put on the values of x, y, and z to make these two unify, or in other words, to make this match x and make this match x.

473
00:28:49,840 --> 00:28:53,376
Those are the restrictions I'd have to put on the values of x, y, and z to make these two unify, or in other words, to make this match x and make this match x.

474
00:28:55,280 --> 00:28:57,760
The unifier should be able to deduce that.

475
00:28:58,540 --> 00:29:01,080
But the unifier may-- there are more complicated things.

476
00:29:01,080 --> 00:29:03,072
I might have said something a little bit more complicated.

477
00:29:03,488 --> 00:29:05,744
I might have said there's a list with two elements, and they're both the same, and they should unify against something of this form.

478
00:29:07,008 --> 00:29:08,288
I might have said there's a list with two elements, and they're both the same, and they should unify against something of this form.

479
00:29:08,864 --> 00:29:11,152
I might have said there's a list with two elements, and they're both the same, and they should unify against something of this form.

480
00:29:12,650 --> 00:29:15,360
And the unifier should be able to deduce from that.

481
00:29:16,890 --> 00:29:19,570
Like that y would have to be b. y would have to be b.

482
00:29:19,570 --> 00:29:22,128
Because these two are the same, so y's got to be b.

483
00:29:22,224 --> 00:29:23,520
Because these two are the same, so y's got to be b.

484
00:29:24,340 --> 00:29:27,536
And v here would have to be a.

485
00:29:28,940 --> 00:29:30,992
And z and w can be anything, but they have to be the same thing.

486
00:29:31,008 --> 00:29:32,432
And z and w can be anything, but they have to be the same thing.

487
00:29:35,710 --> 00:29:39,216
And x would have to be b, followed by a, followed by whatever w is or whatever z is, which is the same.

488
00:29:39,232 --> 00:29:41,664
And x would have to be b, followed by a, followed by whatever w is or whatever z is, which is the same.

489
00:29:42,864 --> 00:29:44,680
And x would have to be b, followed by a, followed by whatever w is or whatever z is, which is the same.

490
00:29:44,680 --> 00:29:46,096
So you see, the unifier somehow has to deduce things to unify these patterns.

491
00:29:46,832 --> 00:29:49,424
So you see, the unifier somehow has to deduce things to unify these patterns.

492
00:29:50,880 --> 00:29:53,520
So you might think there's some kind of magic deduction going on, but there's not.

493
00:29:54,272 --> 00:29:55,232
So you might think there's some kind of magic deduction going on, but there's not.

494
00:29:55,850 --> 00:29:59,888
A unifier is basically a very simple modification of a pattern matcher.

495
00:30:00,150 --> 00:30:01,856
And if you look in the book, you'll see something like three or four lines of code added to the pattern matcher you just saw to handle the symmetric case.

496
00:30:02,224 --> 00:30:04,016
And if you look in the book, you'll see something like three or four lines of code added to the pattern matcher you just saw to handle the symmetric case.

497
00:30:04,176 --> 00:30:06,160
And if you look in the book, you'll see something like three or four lines of code added to the pattern matcher you just saw to handle the symmetric case.

498
00:30:06,496 --> 00:30:08,176
And if you look in the book, you'll see something like three or four lines of code added to the pattern matcher you just saw to handle the symmetric case.

499
00:30:08,280 --> 00:30:10,816
Remember, the pattern matcher has a place where it says is this variable matching a constant.

500
00:30:11,664 --> 00:30:14,288
Remember, the pattern matcher has a place where it says is this variable matching a constant.

501
00:30:14,980 --> 00:30:16,420
And if so, it checks in the dictionary.

502
00:30:16,420 --> 00:30:18,256
There's only one other clause in the unifier, which says is this variable matching a variable, in which case you go look in the dictionary and see if that's consistent with what's in the dictionary.

503
00:30:18,496 --> 00:30:20,752
There's only one other clause in the unifier, which says is this variable matching a variable, in which case you go look in the dictionary and see if that's consistent with what's in the dictionary.

504
00:30:22,000 --> 00:30:23,424
There's only one other clause in the unifier, which says is this variable matching a variable, in which case you go look in the dictionary and see if that's consistent with what's in the dictionary.

505
00:30:23,456 --> 00:30:25,680
There's only one other clause in the unifier, which says is this variable matching a variable, in which case you go look in the dictionary and see if that's consistent with what's in the dictionary.

506
00:30:27,030 --> 00:30:31,136
So all the, quote, deduction that's in this language, if you sort of look at it, sort of sits in the rule applications, which, if you look at that, sits in the unifier, which, if you look at that under a microscope, sits essentially in the pattern matcher.

507
00:30:31,280 --> 00:30:32,448
So all the, quote, deduction that's in this language, if you sort of look at it, sort of sits in the rule applications, which, if you look at that, sits in the unifier, which, if you look at that under a microscope, sits essentially in the pattern matcher.

508
00:30:32,816 --> 00:30:34,592
So all the, quote, deduction that's in this language, if you sort of look at it, sort of sits in the rule applications, which, if you look at that, sits in the unifier, which, if you look at that under a microscope, sits essentially in the pattern matcher.

509
00:30:34,992 --> 00:30:37,888
So all the, quote, deduction that's in this language, if you sort of look at it, sort of sits in the rule applications, which, if you look at that, sits in the unifier, which, if you look at that under a microscope, sits essentially in the pattern matcher.

510
00:30:38,368 --> 00:30:40,320
So all the, quote, deduction that's in this language, if you sort of look at it, sort of sits in the rule applications, which, if you look at that, sits in the unifier, which, if you look at that under a microscope, sits essentially in the pattern matcher.

511
00:30:40,560 --> 00:30:43,968
So all the, quote, deduction that's in this language, if you sort of look at it, sort of sits in the rule applications, which, if you look at that, sits in the unifier, which, if you look at that under a microscope, sits essentially in the pattern matcher.

512
00:30:44,944 --> 00:30:47,072
There's no magic at all going on in there.

513
00:30:47,410 --> 00:30:50,256
And the, quote, deduction that you see is just the fact that there's this recursion, which is unwinding the matches bit by bit.

514
00:30:50,944 --> 00:30:52,896
And the, quote, deduction that you see is just the fact that there's this recursion, which is unwinding the matches bit by bit.

515
00:30:52,928 --> 00:30:55,696
And the, quote, deduction that you see is just the fact that there's this recursion, which is unwinding the matches bit by bit.

516
00:30:56,030 --> 00:30:58,032
So it looks like this thing is being very clever, but in fact, it's not being very clever at all.

517
00:30:58,448 --> 00:31:00,368
So it looks like this thing is being very clever, but in fact, it's not being very clever at all.

518
00:31:02,140 --> 00:31:04,416
There are cases where a unifier might have to be clever.

519
00:31:04,880 --> 00:31:05,872
Let me show you one more.

520
00:31:11,070 --> 00:31:13,360
Suppose I want to unify a list of two elements, x and x, with a thing that says it's y followed by a dot y.

521
00:31:13,488 --> 00:31:14,816
Suppose I want to unify a list of two elements, x and x, with a thing that says it's y followed by a dot y.

522
00:31:17,248 --> 00:31:18,432
Suppose I want to unify a list of two elements, x and x, with a thing that says it's y followed by a dot y.

523
00:31:19,392 --> 00:31:22,128
Suppose I want to unify a list of two elements, x and x, with a thing that says it's y followed by a dot y.

524
00:31:24,370 --> 00:31:26,128
Now, if you think of what that would have to mean, it would have to mean that x had better be the same as y, but also x had better be the same as a list whose first element is a and whose rest is y.

525
00:31:26,864 --> 00:31:29,712
Now, if you think of what that would have to mean, it would have to mean that x had better be the same as y, but also x had better be the same as a list whose first element is a and whose rest is y.

526
00:31:30,928 --> 00:31:31,664
Now, if you think of what that would have to mean, it would have to mean that x had better be the same as y, but also x had better be the same as a list whose first element is a and whose rest is y.

527
00:31:31,824 --> 00:31:36,160
Now, if you think of what that would have to mean, it would have to mean that x had better be the same as y, but also x had better be the same as a list whose first element is a and whose rest is y.

528
00:31:37,330 --> 00:31:39,456
And if you think about what that would have to mean, it would have to mean that y is the infinite list of a's.

529
00:31:42,272 --> 00:31:44,710
And if you think about what that would have to mean, it would have to mean that y is the infinite list of a's.

530
00:31:47,500 --> 00:31:48,352
In some sense, in order to do that unification, I have to solve the fixed-point equation cons of a to y is equal to y.

531
00:31:49,216 --> 00:31:52,400
In some sense, in order to do that unification, I have to solve the fixed-point equation cons of a to y is equal to y.

532
00:31:52,608 --> 00:31:54,848
In some sense, in order to do that unification, I have to solve the fixed-point equation cons of a to y is equal to y.

533
00:31:55,056 --> 00:32:01,840
In some sense, in order to do that unification, I have to solve the fixed-point equation cons of a to y is equal to y.

534
00:32:04,570 --> 00:32:06,960
And in general, I wrote a very simple one.

535
00:32:07,290 --> 00:32:08,672
Really doing unification might have to solve an arbitrary fixed-point equation: f of y equals y.

536
00:32:08,976 --> 00:32:11,984
Really doing unification might have to solve an arbitrary fixed-point equation: f of y equals y.

537
00:32:12,016 --> 00:32:13,424
Really doing unification might have to solve an arbitrary fixed-point equation: f of y equals y.

538
00:32:15,530 --> 00:32:17,088
And basically, you can't do that and make the thing finite all the time.

539
00:32:17,104 --> 00:32:19,472
And basically, you can't do that and make the thing finite all the time.

540
00:32:20,570 --> 00:32:23,600
So how does the logic language handle that?

541
00:32:24,896 --> 00:32:26,480
The answer is it doesn't.

542
00:32:27,168 --> 00:32:28,048
It just punts.

543
00:32:28,730 --> 00:32:31,072
And there's a little check in the unifier, which says, oh, is this one of the hard cases which when I go to match things would involve solving a fixed-point equation?

544
00:32:31,312 --> 00:32:33,824
And there's a little check in the unifier, which says, oh, is this one of the hard cases which when I go to match things would involve solving a fixed-point equation?

545
00:32:34,448 --> 00:32:38,000
And there's a little check in the unifier, which says, oh, is this one of the hard cases which when I go to match things would involve solving a fixed-point equation?

546
00:32:38,650 --> 00:32:40,816
And in this case, I will throw up my hands.

547
00:32:42,840 --> 00:32:44,656
And if that check were not in there, what would happen?

548
00:32:45,008 --> 00:32:45,888
And if that check were not in there, what would happen?

549
00:32:47,990 --> 00:32:49,104
In most cases is that the unifier would just go into an infinite loop.

550
00:32:49,136 --> 00:32:51,312
In most cases is that the unifier would just go into an infinite loop.

551
00:32:53,740 --> 00:32:56,544
And other logic programming languages work like that.

552
00:32:56,800 --> 00:32:58,144
So there's really no magic.

553
00:32:58,220 --> 00:32:59,936
The easy case is done in a matcher.

554
00:33:00,100 --> 00:33:01,584
The hard case is not done at all.

555
00:33:02,960 --> 00:33:05,472
And that's about the state of this technology.

556
00:33:11,888 --> 00:33:14,240
Let me just say again formally how rules work now that I talked about unifiers.

557
00:33:14,272 --> 00:33:16,384
Let me just say again formally how rules work now that I talked about unifiers.

558
00:33:17,390 --> 00:33:18,752
So the official definition is that to apply a rule, we-- well, let's start using some words we've used before.

559
00:33:19,200 --> 00:33:20,960
So the official definition is that to apply a rule, we-- well, let's start using some words we've used before.

560
00:33:24,176 --> 00:33:27,136
So the official definition is that to apply a rule, we-- well, let's start using some words we've used before.

561
00:33:28,270 --> 00:33:32,016
Let's talk about sticking dictionaries into these big boxes of query things as evaluating these large queries relative to an environment or a frame.

562
00:33:32,880 --> 00:33:34,784
Let's talk about sticking dictionaries into these big boxes of query things as evaluating these large queries relative to an environment or a frame.

563
00:33:34,816 --> 00:33:38,544
Let's talk about sticking dictionaries into these big boxes of query things as evaluating these large queries relative to an environment or a frame.

564
00:33:39,952 --> 00:33:43,850
Let's talk about sticking dictionaries into these big boxes of query things as evaluating these large queries relative to an environment or a frame.

565
00:33:43,850 --> 00:33:45,216
So when you think of that dictionary, what's the dictionary after all?

566
00:33:45,232 --> 00:33:46,288
So when you think of that dictionary, what's the dictionary after all?

567
00:33:46,720 --> 00:33:48,180
It's a bunch of meanings for symbols.

568
00:33:48,180 --> 00:33:50,224
That's what we've been calling frames or environments.

569
00:33:51,800 --> 00:33:55,970
What does it mean to do some processing relevant to an environment?

570
00:33:55,970 --> 00:33:57,424
That's what we've been calling evaluation.

571
00:33:58,310 --> 00:33:58,944
So we can say the way that you apply a rule is to evaluate the rule body relative to an environment that's formed by unifying the rule conclusion with the given query.

572
00:33:59,120 --> 00:34:01,568
So we can say the way that you apply a rule is to evaluate the rule body relative to an environment that's formed by unifying the rule conclusion with the given query.

573
00:34:01,920 --> 00:34:03,808
So we can say the way that you apply a rule is to evaluate the rule body relative to an environment that's formed by unifying the rule conclusion with the given query.

574
00:34:04,432 --> 00:34:06,064
So we can say the way that you apply a rule is to evaluate the rule body relative to an environment that's formed by unifying the rule conclusion with the given query.

575
00:34:06,640 --> 00:34:08,656
So we can say the way that you apply a rule is to evaluate the rule body relative to an environment that's formed by unifying the rule conclusion with the given query.

576
00:34:09,136 --> 00:34:11,584
So we can say the way that you apply a rule is to evaluate the rule body relative to an environment that's formed by unifying the rule conclusion with the given query.

577
00:34:13,230 --> 00:34:14,512
And the thing I want you to notice is the complete formal similarity to the net of circular evaluator or the substitution model.

578
00:34:14,800 --> 00:34:17,088
And the thing I want you to notice is the complete formal similarity to the net of circular evaluator or the substitution model.

579
00:34:18,160 --> 00:34:19,552
And the thing I want you to notice is the complete formal similarity to the net of circular evaluator or the substitution model.

580
00:34:20,512 --> 00:34:21,630
And the thing I want you to notice is the complete formal similarity to the net of circular evaluator or the substitution model.

581
00:34:21,630 --> 00:34:22,736
To apply a procedure, we evaluate the procedure body relative to an environment that's formed by blinding the procedure parameters to the arguments.

582
00:34:22,864 --> 00:34:25,872
To apply a procedure, we evaluate the procedure body relative to an environment that's formed by blinding the procedure parameters to the arguments.

583
00:34:27,024 --> 00:34:28,432
To apply a procedure, we evaluate the procedure body relative to an environment that's formed by blinding the procedure parameters to the arguments.

584
00:34:28,544 --> 00:34:33,136
To apply a procedure, we evaluate the procedure body relative to an environment that's formed by blinding the procedure parameters to the arguments.

585
00:34:34,560 --> 00:34:36,416
There's a complete formal similarity here between the rules, rule application, and procedure application even though these things are very, very different.

586
00:34:36,440 --> 00:34:40,416
There's a complete formal similarity here between the rules, rule application, and procedure application even though these things are very, very different.

587
00:34:40,576 --> 00:34:42,304
There's a complete formal similarity here between the rules, rule application, and procedure application even though these things are very, very different.

588
00:34:43,650 --> 00:34:45,616
And again, you have the EVAL APPLY loop.

589
00:34:47,290 --> 00:34:49,520
EVAL and APPLY.

590
00:34:53,360 --> 00:34:54,736
So in general, I might be processing some combined expression that will turn into a rule application, which will generate some dictionaries or frames or environments-- whatever you want to call them-- from match, which will then be the input to some big compound thing like this.

591
00:34:55,632 --> 00:34:57,392
So in general, I might be processing some combined expression that will turn into a rule application, which will generate some dictionaries or frames or environments-- whatever you want to call them-- from match, which will then be the input to some big compound thing like this.

592
00:34:57,424 --> 00:34:59,136
So in general, I might be processing some combined expression that will turn into a rule application, which will generate some dictionaries or frames or environments-- whatever you want to call them-- from match, which will then be the input to some big compound thing like this.

593
00:35:00,704 --> 00:35:03,280
So in general, I might be processing some combined expression that will turn into a rule application, which will generate some dictionaries or frames or environments-- whatever you want to call them-- from match, which will then be the input to some big compound thing like this.

594
00:35:03,312 --> 00:35:04,720
So in general, I might be processing some combined expression that will turn into a rule application, which will generate some dictionaries or frames or environments-- whatever you want to call them-- from match, which will then be the input to some big compound thing like this.

595
00:35:05,024 --> 00:35:08,432
So in general, I might be processing some combined expression that will turn into a rule application, which will generate some dictionaries or frames or environments-- whatever you want to call them-- from match, which will then be the input to some big compound thing like this.

596
00:35:08,660 --> 00:35:11,776
This has pieces of it and may have other rule applications.

597
00:35:13,580 --> 00:35:15,680
And you have essentially the same cycle even though there's nothing here at all that looks like procedures.

598
00:35:15,728 --> 00:35:17,088
And you have essentially the same cycle even though there's nothing here at all that looks like procedures.

599
00:35:17,488 --> 00:35:18,704
And you have essentially the same cycle even though there's nothing here at all that looks like procedures.

600
00:35:19,680 --> 00:35:21,872
It really has to do with the fact you've built a language whose means of combination and abstraction unwind in certain ways.

601
00:35:22,080 --> 00:35:25,490
It really has to do with the fact you've built a language whose means of combination and abstraction unwind in certain ways.

602
00:35:28,770 --> 00:35:29,520
And then in general, what happens at the very top level, you might have rules in your database also, so things in this database might be rules.

603
00:35:29,776 --> 00:35:31,392
And then in general, what happens at the very top level, you might have rules in your database also, so things in this database might be rules.

604
00:35:33,792 --> 00:35:35,968
And then in general, what happens at the very top level, you might have rules in your database also, so things in this database might be rules.

605
00:35:36,656 --> 00:35:38,704
And then in general, what happens at the very top level, you might have rules in your database also, so things in this database might be rules.

606
00:35:40,460 --> 00:35:42,064
There are ways to check that things are true.

607
00:35:42,920 --> 00:35:44,896
So it might come in here and have to do a rule check.

608
00:35:46,750 --> 00:35:50,480
And then there's some control structure which says, well, you look at some rules, and you look at some data elements, and you look at some rules and data elements, and these fan out and out and out.

609
00:35:50,512 --> 00:35:51,808
And then there's some control structure which says, well, you look at some rules, and you look at some data elements, and you look at some rules and data elements, and these fan out and out and out.

610
00:35:51,840 --> 00:35:53,120
And then there's some control structure which says, well, you look at some rules, and you look at some data elements, and you look at some rules and data elements, and these fan out and out and out.

611
00:35:53,350 --> 00:35:55,488
So it becomes essentially impossible to say what order it's looking at these things in, whether it's breadth first or depth first or anything.

612
00:35:55,680 --> 00:35:57,696
So it becomes essentially impossible to say what order it's looking at these things in, whether it's breadth first or depth first or anything.

613
00:35:58,208 --> 00:36:00,272
So it becomes essentially impossible to say what order it's looking at these things in, whether it's breadth first or depth first or anything.

614
00:36:00,280 --> 00:36:01,648
And it's even more impossible because the actual order is somehow buried in the delays of the streams. So what's very hard to tell from this is the order in which it's scanned.

615
00:36:01,664 --> 00:36:05,584
And it's even more impossible because the actual order is somehow buried in the delays of the streams. So what's very hard to tell from this is the order in which it's scanned.

616
00:36:07,696 --> 00:36:11,168
And it's even more impossible because the actual order is somehow buried in the delays of the streams. So what's very hard to tell from this is the order in which it's scanned.

617
00:36:11,270 --> 00:36:12,160
But what's true, because you're looking at the stream view, is that all of them eventually get looked at.

618
00:36:12,192 --> 00:36:13,648
But what's true, because you're looking at the stream view, is that all of them eventually get looked at.

619
00:36:13,904 --> 00:36:15,820
But what's true, because you're looking at the stream view, is that all of them eventually get looked at.

620
00:36:24,980 --> 00:36:28,150
Let me just mention one tiny technical problem.

621
00:36:37,530 --> 00:36:41,008
Suppose I tried saying boss of y is computer, then a funny thing would happen.

622
00:36:44,224 --> 00:36:45,780
Suppose I tried saying boss of y is computer, then a funny thing would happen.

623
00:36:45,780 --> 00:36:50,256
As I stuck a dictionary with y in here, I might get-- this y is not the same as that y, which was the other piece of somebody's job description.

624
00:36:52,736 --> 00:36:57,376
As I stuck a dictionary with y in here, I might get-- this y is not the same as that y, which was the other piece of somebody's job description.

625
00:36:57,424 --> 00:37:00,624
As I stuck a dictionary with y in here, I might get-- this y is not the same as that y, which was the other piece of somebody's job description.

626
00:37:01,580 --> 00:37:03,808
So if I really only did literally what I said, we'd get some variable conflict problems. So I lied to you a little bit.

627
00:37:04,224 --> 00:37:06,448
So if I really only did literally what I said, we'd get some variable conflict problems. So I lied to you a little bit.

628
00:37:09,280 --> 00:37:10,480
So if I really only did literally what I said, we'd get some variable conflict problems. So I lied to you a little bit.

629
00:37:10,930 --> 00:37:13,840
Notice that problem is exactly a problem we've run into before.

630
00:37:14,360 --> 00:37:15,600
It is precisely the need for local variables in a language.

631
00:37:15,984 --> 00:37:18,368
It is precisely the need for local variables in a language.

632
00:37:19,240 --> 00:37:23,392
When I have the sum of squares, that x had better not be that x.

633
00:37:24,960 --> 00:37:26,320
That's exactly the same as this y had better not be that y.

634
00:37:27,392 --> 00:37:29,776
That's exactly the same as this y had better not be that y.

635
00:37:31,800 --> 00:37:33,100
And we know how to solve that.

636
00:37:33,100 --> 00:37:34,496
That was this whole environment model, and we built chains of frames and all sorts of things like that.

637
00:37:34,512 --> 00:37:37,040
That was this whole environment model, and we built chains of frames and all sorts of things like that.

638
00:37:37,710 --> 00:37:39,104
There's a much more brutal way to solve it.

639
00:37:39,104 --> 00:37:41,730
In the query language, we didn't even do that.

640
00:37:41,730 --> 00:37:43,184
We did something completely brutal.

641
00:37:43,540 --> 00:37:45,936
We said every time you apply a rule, rename consistently all the variables in the rule to some new unique names that won't conflict with anything.

642
00:37:47,264 --> 00:37:49,632
We said every time you apply a rule, rename consistently all the variables in the rule to some new unique names that won't conflict with anything.

643
00:37:49,776 --> 00:37:53,504
We said every time you apply a rule, rename consistently all the variables in the rule to some new unique names that won't conflict with anything.

644
00:37:54,048 --> 00:37:59,248
That's conceptually simpler, but really brutal and not particularly efficient.

645
00:37:59,970 --> 00:38:01,152
But notice, we could have gotten rid of all of our environment structures if we defined for procedures in Lisp the same thing.

646
00:38:01,392 --> 00:38:04,688
But notice, we could have gotten rid of all of our environment structures if we defined for procedures in Lisp the same thing.

647
00:38:05,504 --> 00:38:08,896
But notice, we could have gotten rid of all of our environment structures if we defined for procedures in Lisp the same thing.

648
00:38:08,920 --> 00:38:11,568
If every time we applied a procedure and did the substitution model we renamed all the variables in the procedure, then we never would have had to worry about local variables because they would never arise.

649
00:38:11,872 --> 00:38:13,904
If every time we applied a procedure and did the substitution model we renamed all the variables in the procedure, then we never would have had to worry about local variables because they would never arise.

650
00:38:14,192 --> 00:38:16,288
If every time we applied a procedure and did the substitution model we renamed all the variables in the procedure, then we never would have had to worry about local variables because they would never arise.

651
00:38:16,336 --> 00:38:17,392
If every time we applied a procedure and did the substitution model we renamed all the variables in the procedure, then we never would have had to worry about local variables because they would never arise.

652
00:38:19,040 --> 00:38:20,416
OK, well, that would be inefficient, and it's inefficient here in the query language, too, but we did it to keep it simple.

653
00:38:20,912 --> 00:38:23,040
OK, well, that would be inefficient, and it's inefficient here in the query language, too, but we did it to keep it simple.

654
00:38:23,296 --> 00:38:24,592
OK, well, that would be inefficient, and it's inefficient here in the query language, too, but we did it to keep it simple.

655
00:38:25,610 --> 00:38:26,672
Let's break for questions.

656
00:38:30,880 --> 00:38:33,344
AUDIENCE: When you started this section, you emphasized how powerful our APPLY EVAL model was that we could use it for any language.

657
00:38:33,408 --> 00:38:39,600
AUDIENCE: When you started this section, you emphasized how powerful our APPLY EVAL model was that we could use it for any language.

658
00:38:39,632 --> 00:38:41,170
AUDIENCE: When you started this section, you emphasized how powerful our APPLY EVAL model was that we could use it for any language.

659
00:38:41,170 --> 00:38:43,392
And then you say we're going to have this language which is so different.

660
00:38:43,950 --> 00:38:45,136
It turns out that this language, as you just pointed out, is very much the same.

661
00:38:45,584 --> 00:38:47,880
It turns out that this language, as you just pointed out, is very much the same.

662
00:38:47,880 --> 00:38:49,856
I'm wondering if you're arguing that all languages end up coming down to this you can apply a rule or apply a procedure or some kind of apply?

663
00:38:50,480 --> 00:38:54,576
I'm wondering if you're arguing that all languages end up coming down to this you can apply a rule or apply a procedure or some kind of apply?

664
00:38:55,120 --> 00:38:55,984
I'm wondering if you're arguing that all languages end up coming down to this you can apply a rule or apply a procedure or some kind of apply?

665
00:38:57,072 --> 00:38:58,880
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

666
00:38:58,928 --> 00:39:00,304
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

667
00:39:00,928 --> 00:39:04,400
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

668
00:39:04,704 --> 00:39:06,864
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

669
00:39:07,790 --> 00:39:09,900
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

670
00:39:09,984 --> 00:39:11,408
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

671
00:39:12,032 --> 00:39:14,208
PROFESSOR: I would say that pretty much any language where you really are building up these means of combination and giving them simpler names and you're saying anything of the sort, like here's a general kind of expression, like how to square something, almost anything that you would call a procedure.

672
00:39:14,880 --> 00:39:15,888
If that's got to have parts, you have to unwind those parts.

673
00:39:15,904 --> 00:39:17,248
If that's got to have parts, you have to unwind those parts.

674
00:39:18,020 --> 00:39:20,192
You have to have some kind of organization which says when I look at the abstract variables or tags or whatever you want to call them that might stand for particular things, you have to keep track of that, and that's going to be something like an environment.

675
00:39:20,576 --> 00:39:24,944
You have to have some kind of organization which says when I look at the abstract variables or tags or whatever you want to call them that might stand for particular things, you have to keep track of that, and that's going to be something like an environment.

676
00:39:25,088 --> 00:39:27,104
You have to have some kind of organization which says when I look at the abstract variables or tags or whatever you want to call them that might stand for particular things, you have to keep track of that, and that's going to be something like an environment.

677
00:39:28,336 --> 00:39:29,344
You have to have some kind of organization which says when I look at the abstract variables or tags or whatever you want to call them that might stand for particular things, you have to keep track of that, and that's going to be something like an environment.

678
00:39:29,392 --> 00:39:30,912
You have to have some kind of organization which says when I look at the abstract variables or tags or whatever you want to call them that might stand for particular things, you have to keep track of that, and that's going to be something like an environment.

679
00:39:31,720 --> 00:39:32,544
And then if you say this part can have parts which I have to unwind, you've got to have something like this cycle.

680
00:39:32,704 --> 00:39:35,264
And then if you say this part can have parts which I have to unwind, you've got to have something like this cycle.

681
00:39:35,808 --> 00:39:37,440
And then if you say this part can have parts which I have to unwind, you've got to have something like this cycle.

682
00:39:39,970 --> 00:39:43,200
And lots and lots of languages have that character when they sort of get put together in this way.

683
00:39:43,360 --> 00:39:45,408
And lots and lots of languages have that character when they sort of get put together in this way.

684
00:39:45,590 --> 00:39:47,200
This language again really is different because there's nothing like procedures on the outside.

685
00:39:47,216 --> 00:39:49,504
This language again really is different because there's nothing like procedures on the outside.

686
00:39:50,690 --> 00:39:52,688
When you go below the surface and you see the implementation, of course, it starts looking the same.

687
00:39:52,704 --> 00:39:54,240
When you go below the surface and you see the implementation, of course, it starts looking the same.

688
00:39:54,870 --> 00:39:56,950
But from the outside, it's a very different world view.

689
00:39:56,950 --> 00:39:58,544
You're not computing functions of inputs.

690
00:40:03,970 --> 00:40:05,712
AUDIENCE: You mentioned earlier that when you build all of these rules in pattern matcher and with the delayed action of streams, you really have no way to know in what order things are evaluated.

691
00:40:06,608 --> 00:40:09,552
AUDIENCE: You mentioned earlier that when you build all of these rules in pattern matcher and with the delayed action of streams, you really have no way to know in what order things are evaluated.

692
00:40:10,016 --> 00:40:12,720
AUDIENCE: You mentioned earlier that when you build all of these rules in pattern matcher and with the delayed action of streams, you really have no way to know in what order things are evaluated.

693
00:40:13,376 --> 00:40:15,360
AUDIENCE: You mentioned earlier that when you build all of these rules in pattern matcher and with the delayed action of streams, you really have no way to know in what order things are evaluated.

694
00:40:15,584 --> 00:40:15,940
PROFESSOR: Right.

695
00:40:15,940 --> 00:40:18,288
AUDIENCE: And that would indicate then that you should only express declarative knowledge that's true for all-time, no-time sequence built into it.

696
00:40:18,944 --> 00:40:23,792
AUDIENCE: And that would indicate then that you should only express declarative knowledge that's true for all-time, no-time sequence built into it.

697
00:40:23,950 --> 00:40:25,472
Otherwise, these things get all-- PROFESSOR: Yes.

698
00:40:27,392 --> 00:40:27,824
Otherwise, these things get all-- PROFESSOR: Yes.

699
00:40:28,490 --> 00:40:28,820
Yes.

700
00:40:28,820 --> 00:40:29,488
The question is this really is set up for doing declarative knowledge, and as I presented it-- and I'll show you some of the ugly warts under this after the break.

701
00:40:30,064 --> 00:40:32,608
The question is this really is set up for doing declarative knowledge, and as I presented it-- and I'll show you some of the ugly warts under this after the break.

702
00:40:33,264 --> 00:40:34,816
The question is this really is set up for doing declarative knowledge, and as I presented it-- and I'll show you some of the ugly warts under this after the break.

703
00:40:35,712 --> 00:40:39,568
The question is this really is set up for doing declarative knowledge, and as I presented it-- and I'll show you some of the ugly warts under this after the break.

704
00:40:40,830 --> 00:40:42,608
As I presented it, it's just doing logic.

705
00:40:43,070 --> 00:40:46,816
And in principle, if it were logic, it wouldn't matter what order it's getting done.

706
00:40:48,840 --> 00:40:51,552
And it's quite true when you start doing things where you have side effects like adding things to the database and taking things out, and we'll see some others, you use that kind of control.

707
00:40:51,600 --> 00:40:53,616
And it's quite true when you start doing things where you have side effects like adding things to the database and taking things out, and we'll see some others, you use that kind of control.

708
00:40:53,680 --> 00:40:56,304
And it's quite true when you start doing things where you have side effects like adding things to the database and taking things out, and we'll see some others, you use that kind of control.

709
00:40:57,320 --> 00:40:58,144
And it's quite true when you start doing things where you have side effects like adding things to the database and taking things out, and we'll see some others, you use that kind of control.

710
00:40:58,752 --> 00:41:00,832
And it's quite true when you start doing things where you have side effects like adding things to the database and taking things out, and we'll see some others, you use that kind of control.

711
00:41:01,290 --> 00:41:02,940
So, for example, contrasting with Prolog.

712
00:41:02,940 --> 00:41:05,152
Say Prolog has various features where you really exploit the order of evaluation.

713
00:41:05,168 --> 00:41:07,792
Say Prolog has various features where you really exploit the order of evaluation.

714
00:41:09,640 --> 00:41:11,770
And people write Prolog programs that way.

715
00:41:11,770 --> 00:41:14,048
That turns out to be very complicated in Prolog, although if you're an expert Prolog programmer, you can do it.

716
00:41:14,320 --> 00:41:17,552
That turns out to be very complicated in Prolog, although if you're an expert Prolog programmer, you can do it.

717
00:41:18,590 --> 00:41:20,210
However, here I don't think you can do it at all.

718
00:41:20,210 --> 00:41:21,248
It's very complicated because you really are giving up control over any prearranged order of trying things.

719
00:41:21,728 --> 00:41:23,648
It's very complicated because you really are giving up control over any prearranged order of trying things.

720
00:41:23,776 --> 00:41:25,728
It's very complicated because you really are giving up control over any prearranged order of trying things.

721
00:41:27,150 --> 00:41:30,160
AUDIENCE: Now, that would indicate then that you have a functional mapping.

722
00:41:30,670 --> 00:41:32,512
And when you started out this lecture, you said that we express the declarative knowledge which is a relation, and we don't talk about the inputs and the outputs.

723
00:41:32,992 --> 00:41:34,080
And when you started out this lecture, you said that we express the declarative knowledge which is a relation, and we don't talk about the inputs and the outputs.

724
00:41:34,672 --> 00:41:36,704
And when you started out this lecture, you said that we express the declarative knowledge which is a relation, and we don't talk about the inputs and the outputs.

725
00:41:37,152 --> 00:41:38,810
And when you started out this lecture, you said that we express the declarative knowledge which is a relation, and we don't talk about the inputs and the outputs.

726
00:41:41,216 --> 00:41:43,370
PROFESSOR: Well, there's a pun on functional, right?

727
00:41:43,370 --> 00:41:45,792
There's function in the sense of no side effects and not depending on what order is going on.

728
00:41:46,208 --> 00:41:48,160
There's function in the sense of no side effects and not depending on what order is going on.

729
00:41:48,700 --> 00:41:51,040
And then there's functional in the sense of mathematical function, which means input and output.

730
00:41:51,072 --> 00:41:52,220
And then there's functional in the sense of mathematical function, which means input and output.

731
00:41:52,592 --> 00:41:54,368
And it's just that pun that you're making, I think.

732
00:41:56,510 --> 00:41:58,512
AUDIENCE: I'm a little unclear on what you're doing with these two statements, the two boss statements.

733
00:41:58,816 --> 00:42:00,704
AUDIENCE: I'm a little unclear on what you're doing with these two statements, the two boss statements.

734
00:42:01,270 --> 00:42:05,744
Is the first one building up the database and the second one a query or-- PROFESSOR: OK, I'm sorry.

735
00:42:05,760 --> 00:42:08,080
Is the first one building up the database and the second one a query or-- PROFESSOR: OK, I'm sorry.

736
00:42:09,072 --> 00:42:10,128
Is the first one building up the database and the second one a query or-- PROFESSOR: OK, I'm sorry.

737
00:42:12,440 --> 00:42:15,168
What I meant here, if I type something like this in as a query-- I should have given an example way at the very beginning.

738
00:42:16,128 --> 00:42:18,448
What I meant here, if I type something like this in as a query-- I should have given an example way at the very beginning.

739
00:42:19,470 --> 00:42:23,520
If I type in job, Ben Bitdiddle, computer wizard, what the processing will do is if it finds a match, it'll find a match to that exact thing, and it'll type out a job, Ben Bitdiddle, computer wizard.

740
00:42:25,072 --> 00:42:26,384
If I type in job, Ben Bitdiddle, computer wizard, what the processing will do is if it finds a match, it'll find a match to that exact thing, and it'll type out a job, Ben Bitdiddle, computer wizard.

741
00:42:26,496 --> 00:42:27,776
If I type in job, Ben Bitdiddle, computer wizard, what the processing will do is if it finds a match, it'll find a match to that exact thing, and it'll type out a job, Ben Bitdiddle, computer wizard.

742
00:42:28,304 --> 00:42:30,288
If I type in job, Ben Bitdiddle, computer wizard, what the processing will do is if it finds a match, it'll find a match to that exact thing, and it'll type out a job, Ben Bitdiddle, computer wizard.

743
00:42:30,864 --> 00:42:33,280
If I type in job, Ben Bitdiddle, computer wizard, what the processing will do is if it finds a match, it'll find a match to that exact thing, and it'll type out a job, Ben Bitdiddle, computer wizard.

744
00:42:34,220 --> 00:42:35,600
If it doesn't find a match, it won't find anything.

745
00:42:35,696 --> 00:42:36,752
If it doesn't find a match, it won't find anything.

746
00:42:37,400 --> 00:42:39,136
So what I should have said is the way you use the query language to check whether something is true, remember, that's one of the things you want to do in logic programming, is you type in your query and either that comes out or it doesn't.

747
00:42:39,152 --> 00:42:42,208
So what I should have said is the way you use the query language to check whether something is true, remember, that's one of the things you want to do in logic programming, is you type in your query and either that comes out or it doesn't.

748
00:42:43,408 --> 00:42:45,776
So what I should have said is the way you use the query language to check whether something is true, remember, that's one of the things you want to do in logic programming, is you type in your query and either that comes out or it doesn't.

749
00:42:46,416 --> 00:42:49,344
So what I should have said is the way you use the query language to check whether something is true, remember, that's one of the things you want to do in logic programming, is you type in your query and either that comes out or it doesn't.

750
00:42:50,680 --> 00:42:52,384
So what I was trying to illustrate here, I wanted to start with a very simple example before talking about unifiers.

751
00:42:52,416 --> 00:42:54,800
So what I was trying to illustrate here, I wanted to start with a very simple example before talking about unifiers.

752
00:42:54,832 --> 00:42:56,624
So what I was trying to illustrate here, I wanted to start with a very simple example before talking about unifiers.

753
00:42:57,480 --> 00:42:58,112
So what I should have said, if I just wanted to check whether this is true, I could type that in and see if anything came out AUDIENCE: And then the second one-- PROFESSOR: The second one would be a real query.

754
00:42:58,144 --> 00:43:00,960
So what I should have said, if I just wanted to check whether this is true, I could type that in and see if anything came out AUDIENCE: And then the second one-- PROFESSOR: The second one would be a real query.

755
00:43:01,184 --> 00:43:03,280
So what I should have said, if I just wanted to check whether this is true, I could type that in and see if anything came out AUDIENCE: And then the second one-- PROFESSOR: The second one would be a real query.

756
00:43:05,168 --> 00:43:06,272
So what I should have said, if I just wanted to check whether this is true, I could type that in and see if anything came out AUDIENCE: And then the second one-- PROFESSOR: The second one would be a real query.

757
00:43:06,288 --> 00:43:07,840
So what I should have said, if I just wanted to check whether this is true, I could type that in and see if anything came out AUDIENCE: And then the second one-- PROFESSOR: The second one would be a real query.

758
00:43:08,240 --> 00:43:09,760
AUDIENCE: A real query, yeah.

759
00:43:10,770 --> 00:43:13,104
PROFESSOR: What would come out, see, it would go in here say with FOO, and in would go frame that says z is bound to who and d is bound to computer.

760
00:43:13,904 --> 00:43:15,744
PROFESSOR: What would come out, see, it would go in here say with FOO, and in would go frame that says z is bound to who and d is bound to computer.

761
00:43:16,624 --> 00:43:18,816
PROFESSOR: What would come out, see, it would go in here say with FOO, and in would go frame that says z is bound to who and d is bound to computer.

762
00:43:19,560 --> 00:43:20,496
And this will pass through, and then by the time it got out of here, who would pick up a binding.

763
00:43:20,512 --> 00:43:21,952
And this will pass through, and then by the time it got out of here, who would pick up a binding.

764
00:43:22,016 --> 00:43:23,250
And this will pass through, and then by the time it got out of here, who would pick up a binding.

765
00:43:26,950 --> 00:43:28,768
AUDIENCE: On the unifying thing there, I still am not sure what happens with who and z.

766
00:43:29,184 --> 00:43:32,912
AUDIENCE: On the unifying thing there, I still am not sure what happens with who and z.

767
00:43:32,928 --> 00:43:35,904
AUDIENCE: On the unifying thing there, I still am not sure what happens with who and z.

768
00:43:36,460 --> 00:43:39,584
If the unifying-- the rule here says--  OK, so you say that you can't make question mark equal to question mark who.

769
00:43:42,032 --> 00:43:46,224
If the unifying-- the rule here says--  OK, so you say that you can't make question mark equal to question mark who.

770
00:43:46,260 --> 00:43:46,410
PROFESSOR: Right.

771
00:43:46,410 --> 00:43:48,032
That's what the matcher can't do.

772
00:43:48,360 --> 00:43:50,832
But what this will mean to a unifier is that there's an environment with three variables.

773
00:43:51,920 --> 00:43:54,016
But what this will mean to a unifier is that there's an environment with three variables.

774
00:43:56,690 --> 00:43:57,904
d here is computer.

775
00:43:58,520 --> 00:44:00,192
z is whatever who is.

776
00:44:01,830 --> 00:44:05,264
So if later on in the matcher routine it said, for example, who has to be 3, then when I looked up in the dictionary, it will say, oh, z is 3 because it's the same as who.

777
00:44:07,200 --> 00:44:10,384
So if later on in the matcher routine it said, for example, who has to be 3, then when I looked up in the dictionary, it will say, oh, z is 3 because it's the same as who.

778
00:44:12,064 --> 00:44:13,664
So if later on in the matcher routine it said, for example, who has to be 3, then when I looked up in the dictionary, it will say, oh, z is 3 because it's the same as who.

779
00:44:14,000 --> 00:44:16,400
So if later on in the matcher routine it said, for example, who has to be 3, then when I looked up in the dictionary, it will say, oh, z is 3 because it's the same as who.

780
00:44:18,360 --> 00:44:20,448
And that's in some sense the only thing you need to do to extend the unifier to a matcher.

781
00:44:20,464 --> 00:44:21,984
And that's in some sense the only thing you need to do to extend the unifier to a matcher.

782
00:44:22,880 --> 00:44:24,896
AUDIENCE: OK, because it looked like when you were telling how to unify it, it looked like you would put the things together in such a way that you'd actually solve and have a value for both of them.

783
00:44:24,912 --> 00:44:27,584
AUDIENCE: OK, because it looked like when you were telling how to unify it, it looked like you would put the things together in such a way that you'd actually solve and have a value for both of them.

784
00:44:27,616 --> 00:44:29,392
AUDIENCE: OK, because it looked like when you were telling how to unify it, it looked like you would put the things together in such a way that you'd actually solve and have a value for both of them.

785
00:44:29,770 --> 00:44:31,248
And what it looks like now is that you're actually pass a dictionary with two variables and the variables are linked.

786
00:44:31,280 --> 00:44:33,072
And what it looks like now is that you're actually pass a dictionary with two variables and the variables are linked.

787
00:44:33,264 --> 00:44:34,860
And what it looks like now is that you're actually pass a dictionary with two variables and the variables are linked.

788
00:44:34,860 --> 00:44:35,130
PROFESSOR: Right.

789
00:44:35,130 --> 00:44:37,232
It only looks like you're solving for both of them because you're sort of looking at the whole solution at once.

790
00:44:37,520 --> 00:44:39,744
It only looks like you're solving for both of them because you're sort of looking at the whole solution at once.

791
00:44:40,540 --> 00:44:42,880
If you sort of watch the thing getting built up recursively, it's merely this.

792
00:44:42,928 --> 00:44:43,696
If you sort of watch the thing getting built up recursively, it's merely this.

793
00:44:44,980 --> 00:44:48,400
AUDIENCE: OK, so you do pass off that dictionary with two variables?

794
00:44:48,400 --> 00:44:49,110
PROFESSOR: That's right.

795
00:44:49,110 --> 00:44:49,680
AUDIENCE: And link?

796
00:44:50,384 --> 00:44:52,912
PROFESSOR: Right. It just looks like an ordinary dictionary.

797
00:44:54,352 --> 00:44:56,064
AUDIENCE: When you're talking about the unifier, is it that there are some cases or some points that you are not able to use by them?

798
00:44:56,096 --> 00:45:00,192
AUDIENCE: When you're talking about the unifier, is it that there are some cases or some points that you are not able to use by them?

799
00:45:00,752 --> 00:45:03,984
AUDIENCE: When you're talking about the unifier, is it that there are some cases or some points that you are not able to use by them?

800
00:45:04,032 --> 00:45:04,304
PROFESSOR: Right.

801
00:45:04,970 --> 00:45:08,464
AUDIENCE: Can you just by building the rules or writing the forms know in advance if you are going to be able to solve to get the unification or not?

802
00:45:09,168 --> 00:45:13,168
AUDIENCE: Can you just by building the rules or writing the forms know in advance if you are going to be able to solve to get the unification or not?

803
00:45:13,232 --> 00:45:15,856
AUDIENCE: Can you just by building the rules or writing the forms know in advance if you are going to be able to solve to get the unification or not?

804
00:45:16,480 --> 00:45:18,540
AUDIENCE: Can you just by building the rules or writing the forms know in advance if you are going to be able to solve to get the unification or not?

805
00:45:18,768 --> 00:45:22,944
Can you add some properties either to the rules itself or to the formula that you're writing so that you avoid the problem of not finding unification?

806
00:45:23,184 --> 00:45:25,456
Can you add some properties either to the rules itself or to the formula that you're writing so that you avoid the problem of not finding unification?

807
00:45:25,824 --> 00:45:29,040
Can you add some properties either to the rules itself or to the formula that you're writing so that you avoid the problem of not finding unification?

808
00:45:29,180 --> 00:45:31,152
PROFESSOR: I mean, you can agree, I think, to write in a fairly restricted way where you won't run into it.

809
00:45:31,472 --> 00:45:35,264
PROFESSOR: I mean, you can agree, I think, to write in a fairly restricted way where you won't run into it.

810
00:45:35,600 --> 00:45:36,672
See, because what you're getting-- see, the place where you get into problems is when you-- well, again, you're trying to match things like that against things where these have structure, where a, y, b, y something.

811
00:45:36,880 --> 00:45:39,120
See, because what you're getting-- see, the place where you get into problems is when you-- well, again, you're trying to match things like that against things where these have structure, where a, y, b, y something.

812
00:45:39,680 --> 00:45:44,256
See, because what you're getting-- see, the place where you get into problems is when you-- well, again, you're trying to match things like that against things where these have structure, where a, y, b, y something.

813
00:45:44,592 --> 00:45:47,200
See, because what you're getting-- see, the place where you get into problems is when you-- well, again, you're trying to match things like that against things where these have structure, where a, y, b, y something.

814
00:45:47,552 --> 00:45:55,300
See, because what you're getting-- see, the place where you get into problems is when you-- well, again, you're trying to match things like that against things where these have structure, where a, y, b, y something.

815
00:45:58,980 --> 00:46:01,488
So this is the kind of place where you're going to get into trouble.

816
00:46:03,070 --> 00:46:05,808
AUDIENCE: So you can do that syntactically?

817
00:46:06,144 --> 00:46:08,832
PROFESSOR: So you can kind of watch your rules in the kinds of things that your writing.

818
00:46:08,848 --> 00:46:10,496
PROFESSOR: So you can kind of watch your rules in the kinds of things that your writing.

819
00:46:11,904 --> 00:46:14,080
AUDIENCE: So that's the problem that the builder of the database has to be concerned?

820
00:46:14,112 --> 00:46:16,272
AUDIENCE: So that's the problem that the builder of the database has to be concerned?

821
00:46:16,576 --> 00:46:17,808
PROFESSOR: That's a problem.

822
00:46:19,930 --> 00:46:22,016
It's a problem either-- not quite the builder of the database, the person who is expressing the rules, or the builder of the database.

823
00:46:22,048 --> 00:46:23,616
It's a problem either-- not quite the builder of the database, the person who is expressing the rules, or the builder of the database.

824
00:46:24,016 --> 00:46:25,312
It's a problem either-- not quite the builder of the database, the person who is expressing the rules, or the builder of the database.

825
00:46:25,800 --> 00:46:28,224
What the unifier actually does is you can check at the next level down when you actually get to the unifier and you'll see in the code where it looks up in the dictionary.

826
00:46:28,240 --> 00:46:29,856
What the unifier actually does is you can check at the next level down when you actually get to the unifier and you'll see in the code where it looks up in the dictionary.

827
00:46:29,920 --> 00:46:31,872
What the unifier actually does is you can check at the next level down when you actually get to the unifier and you'll see in the code where it looks up in the dictionary.

828
00:46:32,416 --> 00:46:34,768
What the unifier actually does is you can check at the next level down when you actually get to the unifier and you'll see in the code where it looks up in the dictionary.

829
00:46:34,940 --> 00:46:36,832
If it sort of says what does y have to be?

830
00:46:37,260 --> 00:46:38,928
Oh, does y have to be something that contains a y as its expression?

831
00:46:39,504 --> 00:46:41,424
Oh, does y have to be something that contains a y as its expression?

832
00:46:41,960 --> 00:46:43,264
At that point, the unifier and say, oh my God, I'm trying to solve a fixed-point equation.

833
00:46:43,280 --> 00:46:46,240
At that point, the unifier and say, oh my God, I'm trying to solve a fixed-point equation.

834
00:46:46,240 --> 00:46:46,992
I'll give it up here.

835
00:46:48,592 --> 00:46:51,910
AUDIENCE: You make the distinction between the rules in the database.

836
00:46:51,910 --> 00:46:56,480
Are the rules added to the database?

837
00:46:56,950 --> 00:46:57,360
PROFESSOR: Yes.

838
00:46:57,870 --> 00:46:58,870
Yes, I should have said that.

839
00:46:58,870 --> 00:47:00,336
One way to think about rules is that they're just other things in the database.

840
00:47:00,608 --> 00:47:02,656
One way to think about rules is that they're just other things in the database.

841
00:47:03,760 --> 00:47:04,944
So if you want to check the things that have to be checked in the database, they're kind of virtual facts that are in the database.

842
00:47:04,976 --> 00:47:06,816
So if you want to check the things that have to be checked in the database, they're kind of virtual facts that are in the database.

843
00:47:06,832 --> 00:47:09,440
So if you want to check the things that have to be checked in the database, they're kind of virtual facts that are in the database.

844
00:47:09,440 --> 00:47:12,320
AUDIENCE: But in that explanation, you made the differentiation between database and the rules itself.

845
00:47:12,432 --> 00:47:17,264
AUDIENCE: But in that explanation, you made the differentiation between database and the rules itself.

846
00:47:18,230 --> 00:47:19,904
PROFESSOR: Yeah, I probably should not have done that.

847
00:47:20,490 --> 00:47:23,312
The only reason to do that is in terms of the implementation.

848
00:47:23,540 --> 00:47:25,808
When you look at the implementation, there's a part which says check either primitive assertions in the database or check rules.

849
00:47:26,350 --> 00:47:28,720
When you look at the implementation, there's a part which says check either primitive assertions in the database or check rules.

850
00:47:28,928 --> 00:47:29,856
When you look at the implementation, there's a part which says check either primitive assertions in the database or check rules.

851
00:47:30,470 --> 00:47:32,720
And then the real reason why you can't tell what order things are going to come out in and is that the rules database and the data database sort of get merged in a kind of delayed evaluation way.

852
00:47:32,780 --> 00:47:34,560
And then the real reason why you can't tell what order things are going to come out in and is that the rules database and the data database sort of get merged in a kind of delayed evaluation way.

853
00:47:34,970 --> 00:47:40,464
And then the real reason why you can't tell what order things are going to come out in and is that the rules database and the data database sort of get merged in a kind of delayed evaluation way.

854
00:47:40,480 --> 00:47:43,680
And then the real reason why you can't tell what order things are going to come out in and is that the rules database and the data database sort of get merged in a kind of delayed evaluation way.

855
00:47:44,600 --> 00:47:46,800
And so that's what makes the order very complicated.

856
00:47:55,440 --> 00:47:56,096
OK, let's break.

857
00:48:33,160 --> 00:48:35,376
We've just seen how the logic language works and how rules work.

858
00:48:35,392 --> 00:48:36,416
We've just seen how the logic language works and how rules work.

859
00:48:37,230 --> 00:48:39,376
Now, let's turn to a more profound question.

860
00:48:40,120 --> 00:48:41,280
What do these things mean?

861
00:48:43,180 --> 00:48:46,864
That brings us to the subtlest, most devious part of this whole query language business, and that is that it's not quite what it seems to be.

862
00:48:46,992 --> 00:48:48,672
That brings us to the subtlest, most devious part of this whole query language business, and that is that it's not quite what it seems to be.

863
00:48:49,248 --> 00:48:50,112
That brings us to the subtlest, most devious part of this whole query language business, and that is that it's not quite what it seems to be.

864
00:48:51,360 --> 00:48:53,072
That brings us to the subtlest, most devious part of this whole query language business, and that is that it's not quite what it seems to be.

865
00:48:53,570 --> 00:48:56,224
AND and OR and NOT and the logical implication of rules are not really the AND and OR and NOT and logical implication of logic.

866
00:48:57,024 --> 00:48:58,880
AND and OR and NOT and the logical implication of rules are not really the AND and OR and NOT and logical implication of logic.

867
00:48:59,680 --> 00:49:01,280
AND and OR and NOT and the logical implication of rules are not really the AND and OR and NOT and logical implication of logic.

868
00:49:01,968 --> 00:49:06,640
AND and OR and NOT and the logical implication of rules are not really the AND and OR and NOT and logical implication of logic.

869
00:49:07,690 --> 00:49:09,712
Let me give you an example of that.

870
00:49:09,910 --> 00:49:12,224
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

871
00:49:12,448 --> 00:49:14,992
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

872
00:49:16,752 --> 00:49:19,440
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

873
00:49:20,000 --> 00:49:22,592
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

874
00:49:23,100 --> 00:49:24,510
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

875
00:49:24,780 --> 00:49:26,510
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

876
00:49:28,672 --> 00:49:30,096
Certainly, if we have two things in logic, it ought to be the case that AND of P and Q is the same as AND of Q and P and that OR of P and Q is the same as OR of Q and P. But let's look here.

877
00:49:30,100 --> 00:49:32,016
Here's an example.

878
00:49:32,180 --> 00:49:36,160
Let's talk about somebody outranking somebody else in our little database organization.

879
00:49:36,288 --> 00:49:40,140
Let's talk about somebody outranking somebody else in our little database organization.

880
00:49:40,140 --> 00:49:42,896
We'll say s is outranked by b or if either the supervisor of this is b or there's some middle manager here, that supervisor of s is m, and m is outranked by b.

881
00:49:44,640 --> 00:49:46,080
We'll say s is outranked by b or if either the supervisor of this is b or there's some middle manager here, that supervisor of s is m, and m is outranked by b.

882
00:49:46,912 --> 00:49:48,688
We'll say s is outranked by b or if either the supervisor of this is b or there's some middle manager here, that supervisor of s is m, and m is outranked by b.

883
00:49:49,630 --> 00:49:52,750
We'll say s is outranked by b or if either the supervisor of this is b or there's some middle manager here, that supervisor of s is m, and m is outranked by b.

884
00:49:53,680 --> 00:49:55,824
We'll say s is outranked by b or if either the supervisor of this is b or there's some middle manager here, that supervisor of s is m, and m is outranked by b.

885
00:49:59,648 --> 00:50:02,310
So there's one way to define rule outranked by.

886
00:50:02,310 --> 00:50:04,160
Or we can write exactly the same thing, except at the bottom here, we reversed the order of these two clauses.

887
00:50:05,088 --> 00:50:06,912
Or we can write exactly the same thing, except at the bottom here, we reversed the order of these two clauses.

888
00:50:07,216 --> 00:50:09,888
Or we can write exactly the same thing, except at the bottom here, we reversed the order of these two clauses.

889
00:50:11,630 --> 00:50:12,992
And certainly if this were logic, those ought to mean the same thing.

890
00:50:13,008 --> 00:50:14,880
And certainly if this were logic, those ought to mean the same thing.

891
00:50:16,690 --> 00:50:17,312
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

892
00:50:17,712 --> 00:50:19,616
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

893
00:50:19,648 --> 00:50:22,880
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

894
00:50:23,488 --> 00:50:25,360
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

895
00:50:26,768 --> 00:50:28,720
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

896
00:50:30,048 --> 00:50:31,984
However, in our particular implementation, if you say something like who's outranked by Ben Bitdiddle, what you'll find is that this rule will work perfectly well and generate answers, whereas this rule will go into an infinite loop.

897
00:50:34,110 --> 00:50:36,272
And the reason for that is that this will come in and say, oh, who's outranked by Ben Bitdiddle?

898
00:50:36,336 --> 00:50:40,336
And the reason for that is that this will come in and say, oh, who's outranked by Ben Bitdiddle?

899
00:50:41,920 --> 00:50:43,536
Find an s which is outranked by b, where b is Ben Bitdiddle, which is going to happen in it a subproblem.

900
00:50:43,888 --> 00:50:46,224
Find an s which is outranked by b, where b is Ben Bitdiddle, which is going to happen in it a subproblem.

901
00:50:47,504 --> 00:50:49,632
Find an s which is outranked by b, where b is Ben Bitdiddle, which is going to happen in it a subproblem.

902
00:50:50,330 --> 00:50:51,984
Oh gee, find an m such as m is outranked by Ben Bitdiddle with no restrictions on m.

903
00:50:52,240 --> 00:50:54,576
Oh gee, find an m such as m is outranked by Ben Bitdiddle with no restrictions on m.

904
00:50:55,616 --> 00:50:57,360
Oh gee, find an m such as m is outranked by Ben Bitdiddle with no restrictions on m.

905
00:50:58,560 --> 00:51:00,400
So this will say in order to solve this problem, I solve exactly the same problem.

906
00:51:01,424 --> 00:51:03,296
So this will say in order to solve this problem, I solve exactly the same problem.

907
00:51:04,570 --> 00:51:07,232
And then after I've solved that, I'll check for a supervisory relationship.

908
00:51:08,000 --> 00:51:12,352
Whereas this one won't get into that, because before it tries to find this outranked by, it'll already have had a restriction on m here.

909
00:51:12,944 --> 00:51:15,260
Whereas this one won't get into that, because before it tries to find this outranked by, it'll already have had a restriction on m here.

910
00:51:18,384 --> 00:51:20,944
So these two things which ought to mean the same, in fact, one goes into an infinite loop.

911
00:51:20,992 --> 00:51:22,672
So these two things which ought to mean the same, in fact, one goes into an infinite loop.

912
00:51:22,860 --> 00:51:25,040
One does not.

913
00:51:26,720 --> 00:51:29,776
That's a very extreme case of a general thing that you'll find in logic programming that if you start changing the order of the things in the ANDs or ORs, you'll find tremendous differences in efficiency.

914
00:51:29,790 --> 00:51:32,656
That's a very extreme case of a general thing that you'll find in logic programming that if you start changing the order of the things in the ANDs or ORs, you'll find tremendous differences in efficiency.

915
00:51:34,288 --> 00:51:38,704
That's a very extreme case of a general thing that you'll find in logic programming that if you start changing the order of the things in the ANDs or ORs, you'll find tremendous differences in efficiency.

916
00:51:39,344 --> 00:51:41,584
That's a very extreme case of a general thing that you'll find in logic programming that if you start changing the order of the things in the ANDs or ORs, you'll find tremendous differences in efficiency.

917
00:51:42,240 --> 00:51:43,216
And we just saw an infinitely big difference in efficiency and an infinite loop.

918
00:51:43,552 --> 00:51:46,544
And we just saw an infinitely big difference in efficiency and an infinite loop.

919
00:51:49,190 --> 00:51:51,744
And there are similar things having to do with the order in which you enter rules.

920
00:51:52,000 --> 00:51:53,312
And there are similar things having to do with the order in which you enter rules.

921
00:51:54,070 --> 00:51:56,480
The order in which it happens to look at rules in the database may vastly change the efficiency with which it gets out answers or, in fact, send it into an infinite loop for some orderings.

922
00:51:56,704 --> 00:52:00,240
The order in which it happens to look at rules in the database may vastly change the efficiency with which it gets out answers or, in fact, send it into an infinite loop for some orderings.

923
00:52:00,464 --> 00:52:02,608
The order in which it happens to look at rules in the database may vastly change the efficiency with which it gets out answers or, in fact, send it into an infinite loop for some orderings.

924
00:52:03,840 --> 00:52:07,296
And this whole thing has to do with the fact that you're checking these rules in some order.

925
00:52:07,632 --> 00:52:10,048
And this whole thing has to do with the fact that you're checking these rules in some order.

926
00:52:10,950 --> 00:52:14,416
And some rules may lead to really long paths of implication.

927
00:52:14,448 --> 00:52:16,064
Others might not.

928
00:52:16,440 --> 00:52:17,680
And you don't know a priori which ones are good and which ones are bad.

929
00:52:17,728 --> 00:52:19,168
And you don't know a priori which ones are good and which ones are bad.

930
00:52:19,300 --> 00:52:21,488
And there's a whole bunch of research having to do with that, mostly having to do with thinking about making parallel implementations of logic programming languages.

931
00:52:22,160 --> 00:52:23,760
And there's a whole bunch of research having to do with that, mostly having to do with thinking about making parallel implementations of logic programming languages.

932
00:52:23,952 --> 00:52:26,970
And there's a whole bunch of research having to do with that, mostly having to do with thinking about making parallel implementations of logic programming languages.

933
00:52:27,328 --> 00:52:28,640
And in some sense, what you'd like to do is check all rules in parallel and whichever ones get answers, you bubble them up.

934
00:52:28,672 --> 00:52:29,968
And in some sense, what you'd like to do is check all rules in parallel and whichever ones get answers, you bubble them up.

935
00:52:30,360 --> 00:52:32,528
And in some sense, what you'd like to do is check all rules in parallel and whichever ones get answers, you bubble them up.

936
00:52:32,560 --> 00:52:35,580
And if some go down infinite deductive changed, well, you just-- you know, memory is cheap and processors are cheap, and you just let them buzz for as for as long as you want.

937
00:52:36,128 --> 00:52:38,208
And if some go down infinite deductive changed, well, you just-- you know, memory is cheap and processors are cheap, and you just let them buzz for as for as long as you want.

938
00:52:38,240 --> 00:52:40,496
And if some go down infinite deductive changed, well, you just-- you know, memory is cheap and processors are cheap, and you just let them buzz for as for as long as you want.

939
00:52:43,472 --> 00:52:44,832
There's a deeper problem, though, in comparing this logic language to real logic.

940
00:52:45,184 --> 00:52:50,496
There's a deeper problem, though, in comparing this logic language to real logic.

941
00:52:50,688 --> 00:52:52,528
The example I just showed you, it went into an infinite loop maybe, but at least it didn't give the wrong answer.

942
00:52:52,976 --> 00:52:54,800
The example I just showed you, it went into an infinite loop maybe, but at least it didn't give the wrong answer.

943
00:52:55,376 --> 00:52:56,992
The example I just showed you, it went into an infinite loop maybe, but at least it didn't give the wrong answer.

944
00:52:58,370 --> 00:53:01,552
There's an actual deeper problem when we start comparing, seriously comparing this logic language with real classical logic.

945
00:53:02,224 --> 00:53:05,248
There's an actual deeper problem when we start comparing, seriously comparing this logic language with real classical logic.

946
00:53:05,712 --> 00:53:08,464
There's an actual deeper problem when we start comparing, seriously comparing this logic language with real classical logic.

947
00:53:09,490 --> 00:53:12,432
So let's sort of review real classical logic.

948
00:53:13,712 --> 00:53:21,040
All humans are mortal.

949
00:53:22,352 --> 00:53:23,456
That's pretty classical logic.

950
00:53:24,390 --> 00:53:28,672
Then maybe we'll continue in the very best classical tradition.

951
00:53:29,248 --> 00:53:32,464
We'll say all-- let's make it really classical.

952
00:53:32,670 --> 00:53:37,168
All Greeks are human, which has the syllogism that Socrates is a Greek.

953
00:53:40,496 --> 00:53:46,064
All Greeks are human, which has the syllogism that Socrates is a Greek.

954
00:53:48,176 --> 00:53:49,210
And then what do you write here?

955
00:53:49,210 --> 00:53:51,890
I think three dots, classical logic.

956
00:53:51,890 --> 00:53:54,336
Therefore, then the syllogism, Socrates is mortal.

957
00:53:54,640 --> 00:53:59,552
Therefore, then the syllogism, Socrates is mortal.

958
00:54:01,360 --> 00:54:04,912
So there's some real honest classical logic.

959
00:54:05,880 --> 00:54:11,056
Let's compare that with our classical logic database.

960
00:54:12,400 --> 00:54:14,464
So here's a classical logic database.

961
00:54:16,270 --> 00:54:17,488
Socrates is a Greek.

962
00:54:18,030 --> 00:54:18,848
Plato is a Greek.

963
00:54:19,600 --> 00:54:20,400
Zeus is a Greek, and Zeus is a god.

964
00:54:20,848 --> 00:54:21,984
Zeus is a Greek, and Zeus is a god.

965
00:54:24,120 --> 00:54:29,968
And all humans are mortal.

966
00:54:30,540 --> 00:54:32,128
To show that something is mortal, it's enough to show that it's human.

967
00:54:32,160 --> 00:54:33,600
To show that something is mortal, it's enough to show that it's human.

968
00:54:34,650 --> 00:54:35,900
All humans are fallible.

969
00:54:38,900 --> 00:54:40,980
And all Greeks are humans is not quite right.

970
00:54:40,980 --> 00:54:44,416
This says that all Greeks who are not gods are human.

971
00:54:45,710 --> 00:54:47,040
So to show something's human, it's enough to show it's a Greek and not a god.

972
00:54:47,072 --> 00:54:48,896
So to show something's human, it's enough to show it's a Greek and not a god.

973
00:54:49,320 --> 00:54:52,880
And the address of any Greek god is Mount Olympus.

974
00:54:54,320 --> 00:54:57,168
So there's a little classical logic database.

975
00:54:57,390 --> 00:54:59,328
And indeed, that would work fairly well.

976
00:54:59,490 --> 00:55:02,096
If we type that in and say is Socrates mortal or Socrates fallible or mortal?

977
00:55:03,472 --> 00:55:06,576
If we type that in and say is Socrates mortal or Socrates fallible or mortal?

978
00:55:06,910 --> 00:55:07,690
It'll say yes.

979
00:55:07,776 --> 00:55:09,710
Is Plato mortal and fallible.

980
00:55:09,710 --> 00:55:10,240
It'll say yes.

981
00:55:10,680 --> 00:55:12,210
If we say is Zeus mortal?

982
00:55:12,210 --> 00:55:13,232
It won't find anything.

983
00:55:14,900 --> 00:55:15,968
And it'll work perfectly well.

984
00:55:16,544 --> 00:55:20,120
However, suppose we want to extend this.

985
00:55:20,120 --> 00:55:23,056
Let's define what it means for someone to be a perfect being.

986
00:55:23,824 --> 00:55:27,216
Let's say rule: a perfect being.

987
00:55:34,050 --> 00:55:35,480
And I think this is right.

988
00:55:35,480 --> 00:55:38,144
If you're up on your medieval scholastic philosophy, I believe that perfect beings are ones who were neither mortal nor fallible.

989
00:55:38,448 --> 00:55:40,176
If you're up on your medieval scholastic philosophy, I believe that perfect beings are ones who were neither mortal nor fallible.

990
00:55:40,688 --> 00:55:42,656
If you're up on your medieval scholastic philosophy, I believe that perfect beings are ones who were neither mortal nor fallible.

991
00:55:44,100 --> 00:55:56,848
AND NOT mortal x, NOT fallible x.

992
00:55:59,300 --> 00:56:00,896
So we'll define this system to teach it what a perfect being is.

993
00:56:02,672 --> 00:56:04,368
So we'll define this system to teach it what a perfect being is.

994
00:56:05,790 --> 00:56:07,696
And now what we're going to do is he ask for the address of all the perfect beings.

995
00:56:08,064 --> 00:56:10,176
And now what we're going to do is he ask for the address of all the perfect beings.

996
00:56:11,488 --> 00:56:22,304
AND the address of x is y and x is perfect.

997
00:56:23,488 --> 00:56:24,976
And so what we're generating here is the world's most exclusive mailing list. For the address of all the perfect things, we might have typed this in.

998
00:56:24,992 --> 00:56:27,808
And so what we're generating here is the world's most exclusive mailing list. For the address of all the perfect things, we might have typed this in.

999
00:56:30,160 --> 00:56:32,200
And so what we're generating here is the world's most exclusive mailing list. For the address of all the perfect things, we might have typed this in.

1000
00:56:32,240 --> 00:56:33,472
And so what we're generating here is the world's most exclusive mailing list. For the address of all the perfect things, we might have typed this in.

1001
00:56:33,830 --> 00:56:35,440
Or we might type in this.

1002
00:56:36,240 --> 00:56:50,576
We'll say AND perfect of x and the address of x is y.

1003
00:56:52,140 --> 00:56:53,328
Well, suppose we type all that in and we try this query.

1004
00:56:53,728 --> 00:56:54,848
Well, suppose we type all that in and we try this query.

1005
00:56:55,190 --> 00:56:56,768
This query is going to give us an answer.

1006
00:56:57,650 --> 00:57:00,000
This query will say, yeah, Mount Olympus.

1007
00:57:04,230 --> 00:57:06,576
This query, in fact, is going to give us nothing.

1008
00:57:06,740 --> 00:57:09,584
It will say no addresses of perfect beings.

1009
00:57:11,640 --> 00:57:12,510
Now, why is that?

1010
00:57:12,510 --> 00:57:13,440
Why is there a difference?

1011
00:57:14,230 --> 00:57:15,690
This is not an infinite loop question.

1012
00:57:15,690 --> 00:57:17,088
This is a different answer question.

1013
00:57:19,488 --> 00:57:20,096
The reason is that if you remember the implementation of NOT, NOT acted as a filter.

1014
00:57:20,380 --> 00:57:22,320
The reason is that if you remember the implementation of NOT, NOT acted as a filter.

1015
00:57:23,504 --> 00:57:24,848
The reason is that if you remember the implementation of NOT, NOT acted as a filter.

1016
00:57:25,880 --> 00:57:29,008
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1017
00:57:29,056 --> 00:57:30,144
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1018
00:57:30,400 --> 00:57:31,568
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1019
00:57:31,792 --> 00:57:33,168
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1020
00:57:33,290 --> 00:57:34,940
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1021
00:57:34,976 --> 00:57:36,112
NOT said I'm going to take some possible dictionaries, some possible frames, some possible answers, and filter out the ones that happened to satisfy some condition, and that's how I implement NOT.

1022
00:57:36,928 --> 00:57:38,432
If you think about what's going on here, I'll build this query box where the output of an address piece gets fed into a perfect piece.

1023
00:57:40,112 --> 00:57:42,656
If you think about what's going on here, I'll build this query box where the output of an address piece gets fed into a perfect piece.

1024
00:57:43,328 --> 00:57:45,648
If you think about what's going on here, I'll build this query box where the output of an address piece gets fed into a perfect piece.

1025
00:57:46,064 --> 00:57:47,328
If you think about what's going on here, I'll build this query box where the output of an address piece gets fed into a perfect piece.

1026
00:57:50,290 --> 00:57:51,008
What will happen is the address piece will set up some things of everyone whose address I know.

1027
00:57:51,328 --> 00:57:53,264
What will happen is the address piece will set up some things of everyone whose address I know.

1028
00:57:53,328 --> 00:57:54,832
What will happen is the address piece will set up some things of everyone whose address I know.

1029
00:57:55,290 --> 00:57:57,648
Those will get filtered by the NOTs inside perfect here.

1030
00:57:59,880 --> 00:58:01,904
So it will throw out the ones which happened to be either mortal or fallible.

1031
00:58:02,160 --> 00:58:04,112
So it will throw out the ones which happened to be either mortal or fallible.

1032
00:58:04,910 --> 00:58:06,384
In the other order what happens is I set this up, started up with an empty frame.

1033
00:58:06,736 --> 00:58:09,120
In the other order what happens is I set this up, started up with an empty frame.

1034
00:58:09,520 --> 00:58:12,352
The perfect in here doesn't find anything for the NOTs to filter, so nothing comes out here at all.

1035
00:58:12,384 --> 00:58:13,984
The perfect in here doesn't find anything for the NOTs to filter, so nothing comes out here at all.

1036
00:58:18,830 --> 00:58:21,504
And there's sort of nothing there that gets fed into the address thing.

1037
00:58:21,940 --> 00:58:23,152
So here, I don't get an answer.

1038
00:58:23,936 --> 00:58:27,040
And again, the reason for that is NOT isn't generating anything.

1039
00:58:27,440 --> 00:58:28,800
NOT's only throwing out things.

1040
00:58:29,080 --> 00:58:30,512
And if I never started up with anything, there's nothing for it to throw out.

1041
00:58:30,528 --> 00:58:31,744
And if I never started up with anything, there's nothing for it to throw out.

1042
00:58:32,020 --> 00:58:33,770
So out of this thing, I get the wrong answer.

1043
00:58:37,200 --> 00:58:37,970
How can you fix that?

1044
00:58:37,970 --> 00:58:39,070
Well, there are ways to fix that.

1045
00:58:39,360 --> 00:58:40,912
So you might say, well, that's sort of stupid.

1046
00:58:41,410 --> 00:58:44,900
Why are you just doing all your NOT stuff at the beginning?

1047
00:58:44,900 --> 00:58:46,144
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1048
00:58:46,432 --> 00:58:47,392
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1049
00:58:47,840 --> 00:58:50,080
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1050
00:58:50,336 --> 00:58:52,096
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1051
00:58:52,800 --> 00:58:54,976
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1052
00:58:55,520 --> 00:58:57,856
The right way to implement NOT is to realize that when you have conditions like NOT, you should generate all your answers first, and then with each of these dictionaries pass along until at the very end I'll do filtering.

1053
00:58:58,560 --> 00:59:02,016
And there are implementations of logic languages that work like that that solve this particular problem.

1054
00:59:02,416 --> 00:59:04,050
And there are implementations of logic languages that work like that that solve this particular problem.

1055
00:59:06,800 --> 00:59:08,976
However, there's a more profound problem, which is which one of these is the right answer?

1056
00:59:09,600 --> 00:59:11,536
However, there's a more profound problem, which is which one of these is the right answer?

1057
00:59:12,530 --> 00:59:14,240
Is it Mount Olympus or is it nothing?

1058
00:59:15,320 --> 00:59:16,224
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1059
00:59:17,520 --> 00:59:18,736
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1060
00:59:18,760 --> 00:59:20,730
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1061
00:59:22,528 --> 00:59:25,104
So you might say it's Mount Olympus, because after all, Zeus is in that database, and Zeus was neither mortal nor fallible.

1062
00:59:29,550 --> 00:59:32,448
So you might say Zeus wants to satisfy NOT mortal Zeus or NOT fallible Zeus.

1063
00:59:34,304 --> 00:59:44,032
So you might say Zeus wants to satisfy NOT mortal Zeus or NOT fallible Zeus.

1064
00:59:44,120 --> 00:59:45,856
But let's actually look at that database.

1065
00:59:47,920 --> 00:59:48,464
Let's look at it.

1066
00:59:49,320 --> 00:59:50,208
There's no way-- how does it know that Zeus is not fallible?

1067
00:59:51,472 --> 00:59:53,248
There's no way-- how does it know that Zeus is not fallible?

1068
00:59:54,810 --> 00:59:56,112
There's nothing in there about that.

1069
00:59:57,930 --> 00:59:59,664
What's in there is that humans are fallible.

1070
01:00:02,160 --> 01:00:04,128
How does it know that Zeus is not mortal?

1071
01:00:04,480 --> 01:00:05,936
There's nothing in there about that.

1072
01:00:07,980 --> 01:00:11,008
It just said I don't have any rule, which-- the only way I can deduce something's mortal is if it's human, and that's all it really knows about mortal.

1073
01:00:11,680 --> 01:00:13,504
It just said I don't have any rule, which-- the only way I can deduce something's mortal is if it's human, and that's all it really knows about mortal.

1074
01:00:13,520 --> 01:00:15,680
It just said I don't have any rule, which-- the only way I can deduce something's mortal is if it's human, and that's all it really knows about mortal.

1075
01:00:16,690 --> 01:00:19,856
And in fact, if you remember your classical mythology, you know that the Greek gods were not mortal but fallible.

1076
01:00:19,872 --> 01:00:23,488
And in fact, if you remember your classical mythology, you know that the Greek gods were not mortal but fallible.

1077
01:00:25,056 --> 01:00:28,656
So the answer is not in the rules there.

1078
01:00:30,850 --> 01:00:32,100
See, why does it deduce that?

1079
01:00:34,496 --> 01:00:38,320
See, Socrates would certainly not have made this error of logic.

1080
01:00:40,080 --> 01:00:42,672
What NOT needs in this language is not NOT.

1081
01:00:43,370 --> 01:00:44,320
It's not the NOT of logic.

1082
01:00:44,930 --> 01:00:46,400
What NOT needs in this language is not deducible from things in the database as opposed to not true.

1083
01:00:47,160 --> 01:00:49,960
What NOT needs in this language is not deducible from things in the database as opposed to not true.

1084
01:00:50,752 --> 01:00:53,344
What NOT needs in this language is not deducible from things in the database as opposed to not true.

1085
01:00:55,312 --> 01:00:56,384
That's a very big difference.

1086
01:00:57,300 --> 01:00:58,640
Subtle, but big.

1087
01:00:59,250 --> 01:01:00,272
So, in fact, this is perfectly happy to say not anything that it doesn't know about.

1088
01:01:00,768 --> 01:01:03,920
So, in fact, this is perfectly happy to say not anything that it doesn't know about.

1089
01:01:04,610 --> 01:01:05,488
So if you ask it is it not true that Zeus likes chocolate ice cream?

1090
01:01:05,504 --> 01:01:07,830
So if you ask it is it not true that Zeus likes chocolate ice cream?

1091
01:01:07,856 --> 01:01:09,120
It will say sure, it's not true.

1092
01:01:10,640 --> 01:01:12,512
Or anything else or anything it doesn't know about.

1093
01:01:12,592 --> 01:01:17,344
NOT means not deducible from the things you've told me.

1094
01:01:18,280 --> 01:01:22,448
In a world where you're identifying not deducible with, in fact, not true, this is called the closed world assumption.

1095
01:01:22,656 --> 01:01:24,000
In a world where you're identifying not deducible with, in fact, not true, this is called the closed world assumption.

1096
01:01:24,416 --> 01:01:26,304
In a world where you're identifying not deducible with, in fact, not true, this is called the closed world assumption.

1097
01:01:37,376 --> 01:01:38,176
The closed world assumption.

1098
01:01:38,200 --> 01:01:42,384
Anything that I cannot deduce from what I know is not true, right?

1099
01:01:43,504 --> 01:01:44,270
Anything that I cannot deduce from what I know is not true, right?

1100
01:01:46,240 --> 01:01:48,010
If I don't know anything about x, the x isn't true.

1101
01:01:48,224 --> 01:01:49,216
If I don't know anything about x, the x isn't true.

1102
01:01:49,290 --> 01:01:50,336
That's very dangerous.

1103
01:01:51,296 --> 01:01:52,448
From a logical point of view, first of all, it doesn't really makes sense.

1104
01:01:52,464 --> 01:01:53,760
From a logical point of view, first of all, it doesn't really makes sense.

1105
01:01:54,480 --> 01:01:56,336
Because if I don't know anything about x, I'm willing to say not x.

1106
01:01:58,384 --> 01:01:59,696
Because if I don't know anything about x, I'm willing to say not x.

1107
01:02:00,240 --> 01:02:03,328
But am I willing to say not not x?

1108
01:02:03,850 --> 01:02:05,664
Well, sure, I don't know anything about that either maybe.

1109
01:02:06,470 --> 01:02:08,656
So not not x is not necessarily the same as x and so on and so on and so on, so there's some sort of funny bias in there.

1110
01:02:09,248 --> 01:02:10,944
So not not x is not necessarily the same as x and so on and so on and so on, so there's some sort of funny bias in there.

1111
01:02:11,712 --> 01:02:13,936
So not not x is not necessarily the same as x and so on and so on and so on, so there's some sort of funny bias in there.

1112
01:02:15,970 --> 01:02:17,290
So that's sort of funny.

1113
01:02:17,290 --> 01:02:18,096
The second thing, if you start building up real reasoning programs based on this, think how dangerous that is.

1114
01:02:20,144 --> 01:02:24,128
The second thing, if you start building up real reasoning programs based on this, think how dangerous that is.

1115
01:02:24,704 --> 01:02:26,112
The second thing, if you start building up real reasoning programs based on this, think how dangerous that is.

1116
01:02:27,000 --> 01:02:27,856
You're saying I know I'm in a position to deduce everything true that's relevant to this problem.

1117
01:02:29,616 --> 01:02:33,888
You're saying I know I'm in a position to deduce everything true that's relevant to this problem.

1118
01:02:34,160 --> 01:02:36,224
You're saying I know I'm in a position to deduce everything true that's relevant to this problem.

1119
01:02:37,480 --> 01:02:38,560
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1120
01:02:38,896 --> 01:02:42,256
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1121
01:02:42,368 --> 01:02:44,208
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1122
01:02:44,240 --> 01:02:46,272
I'm reasoning, and built into my reasoning mechanism is the assumption that anything that I don't know can't possibly be relevant to this problem, right?

1123
01:02:48,448 --> 01:02:53,040
There are a lot of big organizations that work like that, right?

1124
01:02:53,168 --> 01:02:56,830
Most corporate marketing divisions work like that.

1125
01:02:56,830 --> 01:02:59,120
You know the consequences to that.

1126
01:03:00,336 --> 01:03:01,680
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1127
01:03:02,272 --> 01:03:06,256
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1128
01:03:07,056 --> 01:03:09,008
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1129
01:03:09,024 --> 01:03:11,280
So it's very dangerous to start really typing in these big logical implication systems and going on what they say, because they have this really limiting assumption built in.

1130
01:03:12,600 --> 01:03:14,368
So you have to be very, very careful about that.

1131
01:03:15,296 --> 01:03:16,288
And that's a deep problem.

1132
01:03:16,560 --> 01:03:17,824
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1133
01:03:18,224 --> 01:03:20,144
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1134
01:03:20,160 --> 01:03:21,824
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1135
01:03:22,160 --> 01:03:23,840
That's not a problem about we can make a little bit cleverer implementation and do the filters and organize the infinite loops to make them go away.

1136
01:03:23,840 --> 01:03:25,088
It's a different kind of problem.

1137
01:03:25,920 --> 01:03:26,896
It's a different semantics.

1138
01:03:27,060 --> 01:03:30,512
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1139
01:03:31,344 --> 01:03:34,432
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1140
01:03:34,576 --> 01:03:35,648
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1141
01:03:36,176 --> 01:03:38,784
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1142
01:03:39,900 --> 01:03:42,944
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1143
01:03:43,584 --> 01:03:45,088
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1144
01:03:46,096 --> 01:03:49,488
So I think to wrap this up, it's fair to say that logic programming I think is a terrifically exciting idea, the idea that you can bridge this gap from the imperative to the declarative, that you can start talking about relations and really get tremendous power by going above the abstraction of what's my input and what's my output.

1145
01:03:50,560 --> 01:03:51,536
And linked to logic, the problem is it's a goal that I think has yet to be realized.

1146
01:03:52,464 --> 01:03:56,464
And linked to logic, the problem is it's a goal that I think has yet to be realized.

1147
01:03:58,032 --> 01:04:01,808
And probably one of the very most interesting research questions going on now in languages is how do you somehow make a real logic language?

1148
01:04:02,272 --> 01:04:04,416
And probably one of the very most interesting research questions going on now in languages is how do you somehow make a real logic language?

1149
01:04:04,672 --> 01:04:08,288
And probably one of the very most interesting research questions going on now in languages is how do you somehow make a real logic language?

1150
01:04:09,460 --> 01:04:11,056
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1151
01:04:11,312 --> 01:04:13,152
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1152
01:04:13,520 --> 01:04:16,432
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1153
01:04:16,464 --> 01:04:17,984
And secondly, how do you bridge the gap from this world of logic and relations to the worlds of more traditional languages and somehow combine the power of both.

1154
01:04:18,880 --> 01:04:19,680
OK, let's break.

1155
01:04:23,290 --> 01:04:27,740
AUDIENCE: Couldn't you solve that last problem by having the extra rules that imply it?

1156
01:04:27,968 --> 01:04:29,856
The problem here is you have the definition of something, but you don't have the definition of its opposite.

1157
01:04:29,888 --> 01:04:31,824
The problem here is you have the definition of something, but you don't have the definition of its opposite.

1158
01:04:32,080 --> 01:04:33,920
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1159
01:04:35,472 --> 01:04:36,896
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1160
01:04:36,992 --> 01:04:38,704
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1161
01:04:38,752 --> 01:04:40,370
If you include in the database something that says something implies mortal x, something else implies not mortal x, haven't you basically solved the problem?

1162
01:04:43,370 --> 01:04:44,144
PROFESSOR: But the issue is do you put a finite number of those in?

1163
01:04:44,752 --> 01:04:46,384
PROFESSOR: But the issue is do you put a finite number of those in?

1164
01:04:48,656 --> 01:04:53,130
AUDIENCE: If things are specified always in pairs-- PROFESSOR: But the impression is then what do you do about deduction?

1165
01:04:53,616 --> 01:04:57,072
AUDIENCE: If things are specified always in pairs-- PROFESSOR: But the impression is then what do you do about deduction?

1166
01:05:00,200 --> 01:05:02,112
You can't specify NOTs.

1167
01:05:03,400 --> 01:05:04,768
But the problem is, in a big system, it turns out that might not be a finite number of things.

1168
01:05:04,784 --> 01:05:07,960
But the problem is, in a big system, it turns out that might not be a finite number of things.

1169
01:05:12,820 --> 01:05:15,290
There are also sort of two issues.

1170
01:05:15,290 --> 01:05:16,560
Partly it might not be finite.

1171
01:05:16,690 --> 01:05:19,392
Partly it might be that's not what you want.

1172
01:05:21,510 --> 01:05:24,528
So a good example would be suppose I want to do connectivity.

1173
01:05:25,120 --> 01:05:26,544
I want a reason about connectivity.

1174
01:05:28,050 --> 01:05:30,384
And I'm going to tell you there's four things: a and b and c and d.

1175
01:05:30,400 --> 01:05:33,744
And I'm going to tell you there's four things: a and b and c and d.

1176
01:05:35,480 --> 01:05:38,190
And I'll tell you a is connected to b and c's connected to d.

1177
01:05:38,640 --> 01:05:41,424
And I'll tell you a is connected to b and c's connected to d.

1178
01:05:43,200 --> 01:05:44,800
And now I'll tell you is a connected to d?

1179
01:05:45,056 --> 01:05:46,032
That's the question.

1180
01:05:46,780 --> 01:05:50,610
There's an example where I would like something like the closed world assumption.

1181
01:05:54,432 --> 01:05:55,664
That's a tiny toy, but a lot of times, I want to be able to say something like anything that I haven't told you, assume is not true.

1182
01:05:56,240 --> 01:05:58,304
That's a tiny toy, but a lot of times, I want to be able to say something like anything that I haven't told you, assume is not true.

1183
01:05:58,480 --> 01:06:01,340
That's a tiny toy, but a lot of times, I want to be able to say something like anything that I haven't told you, assume is not true.

1184
01:06:04,260 --> 01:06:06,496
So it's not as simple as you only want to put in explicit NOTs all over the place.

1185
01:06:06,560 --> 01:06:08,096
So it's not as simple as you only want to put in explicit NOTs all over the place.

1186
01:06:09,470 --> 01:06:12,704
It's that sometimes it really isn't clear what you even want.

1187
01:06:14,150 --> 01:06:17,920
That having to specify both everything and not everything is too precise, and then you get down into problems there.

1188
01:06:17,936 --> 01:06:20,000
That having to specify both everything and not everything is too precise, and then you get down into problems there.

1189
01:06:20,960 --> 01:06:22,688
But there are a lot of approaches that explicitly put in NOTs and reason based on that.

1190
01:06:23,328 --> 01:06:25,936
But there are a lot of approaches that explicitly put in NOTs and reason based on that.

1191
01:06:26,510 --> 01:06:27,664
So it's a very good idea.

1192
01:06:28,070 --> 01:06:31,456
It's just that then it starts becoming a little cumbersome in the very large problems you'd like to use.

1193
01:06:31,488 --> 01:06:33,490
It's just that then it starts becoming a little cumbersome in the very large problems you'd like to use.

1194
01:06:43,460 --> 01:06:45,968
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1195
01:06:46,000 --> 01:06:47,984
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1196
01:06:48,496 --> 01:06:50,160
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1197
01:06:50,192 --> 01:06:52,064
AUDIENCE: I'm not sure how directly related to the argument this is, but one of your points was that one of the dangers of the closed rule is you never really know all the things that are there.

1198
01:06:53,440 --> 01:06:55,328
You never really know all the parts to it.

1199
01:06:55,872 --> 01:06:58,160
Isn't that a major problem with any programming?

1200
01:06:58,160 --> 01:06:59,648
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1201
01:06:59,904 --> 01:07:01,568
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1202
01:07:01,584 --> 01:07:03,408
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1203
01:07:04,064 --> 01:07:06,528
I always write programs where I assume that I've got all the cases, and so I check for them all or whatever, and somewhere down the road, I find out that I didn't check for one of them.

1204
01:07:07,390 --> 01:07:08,540
PROFESSOR: Well, sure, it's true.

1205
01:07:08,540 --> 01:07:09,760
But the problem here is it's that assumption which is the thing that you're making if you believe you're identifying this with logic.

1206
01:07:11,968 --> 01:07:15,472
But the problem here is it's that assumption which is the thing that you're making if you believe you're identifying this with logic.

1207
01:07:15,488 --> 01:07:17,344
But the problem here is it's that assumption which is the thing that you're making if you believe you're identifying this with logic.

1208
01:07:19,600 --> 01:07:20,510
So you're quite right.

1209
01:07:20,510 --> 01:07:22,220
It's a situation you're never in.

1210
01:07:22,220 --> 01:07:25,520
The problem is if you're starting to believe that what this is doing is logic and you look at the rules you write down and say what can I deduce from them, you have to be very careful to remember that NOT means something else.

1211
01:07:26,176 --> 01:07:28,896
The problem is if you're starting to believe that what this is doing is logic and you look at the rules you write down and say what can I deduce from them, you have to be very careful to remember that NOT means something else.

1212
01:07:29,536 --> 01:07:32,800
The problem is if you're starting to believe that what this is doing is logic and you look at the rules you write down and say what can I deduce from them, you have to be very careful to remember that NOT means something else.

1213
01:07:33,470 --> 01:07:35,216
And it means something else based on an assumption which is probably not true.

1214
01:07:35,248 --> 01:07:36,704
And it means something else based on an assumption which is probably not true.

1215
01:07:39,030 --> 01:07:40,544
AUDIENCE: Do I understand you correctly that you cannot fix this problem without killing off all possibilities of inference through altering NOT?

1216
01:07:40,560 --> 01:07:41,824
AUDIENCE: Do I understand you correctly that you cannot fix this problem without killing off all possibilities of inference through altering NOT?

1217
01:07:42,256 --> 01:07:46,080
AUDIENCE: Do I understand you correctly that you cannot fix this problem without killing off all possibilities of inference through altering NOT?

1218
01:07:46,544 --> 01:07:49,808
PROFESSOR: No, that's not quite right.

1219
01:07:52,960 --> 01:07:55,088
There are other--  there are ways to do logic with real NOTs.

1220
01:07:56,340 --> 01:07:58,032
There are actually ways to do that.

1221
01:07:58,540 --> 01:08:00,848
But they're very inefficient as far as anybody knows.

1222
01:08:01,610 --> 01:08:02,560
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1223
01:08:04,096 --> 01:08:06,896
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1224
01:08:07,390 --> 01:08:08,830
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1225
01:08:08,912 --> 01:08:11,296
And they're much more--  the, quote, inference in here is built into this unifier and this pattern matching unification algorithm.

1226
01:08:11,980 --> 01:08:16,192
There are ways to automate real logical reasoning.

1227
01:08:16,590 --> 01:08:18,192
But it's not based on that, and logic programming languages don't tend to do that because it's very inefficient as far as anybody knows.

1228
01:08:18,512 --> 01:08:19,840
But it's not based on that, and logic programming languages don't tend to do that because it's very inefficient as far as anybody knows.

1229
01:08:19,872 --> 01:08:23,850
But it's not based on that, and logic programming languages don't tend to do that because it's very inefficient as far as anybody knows.

1230
01:08:29,390 --> 01:08:30,032
All right, thank you.

