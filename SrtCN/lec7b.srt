1
00:00:00,010 --> 00:00:01,632
Learning-SICP学习小组
倾情制作

2
00:00:01,630 --> 00:00:04,336
翻译&&时间轴：邓雄飞、张大伟
压制&&特效：邓雄飞（Dysprosium）
校对：邓雄飞（Dysprosium）

3
00:00:04,384 --> 00:00:07,344
特别感谢：裘宗燕教授

4
00:00:07,360 --> 00:00:09,488
计算机程序的构造和解释

5
00:00:09,520 --> 00:00:13,664
元循环求值器 II
Metacircular Evaluator II

6
00:00:17,216 --> 00:00:17,968
教授：目前为止
PROFESSOR: Well, let's see.

7
00:00:19,520 --> 00:00:21,296
我们学的东西都非常有趣
What we did so far was a lot of fun,

8
00:00:21,520 --> 00:00:23,050
但它有什么实际的用途吗？
was it useful for anything?

9
00:00:26,330 --> 00:00:27,968
我想答案是“是的”
I suppose the answer is going to be yes.

10
00:00:29,380 --> 00:00:31,920
这些元循环求值器
If these metacircular interpreters

11
00:00:32,960 --> 00:00:34,608
非常值得琢磨
are a valuable thing to play with.

12
00:00:34,624 --> 00:00:36,176
我花了大概
I spend, say

13
00:00:38,050 --> 00:00:41,856
我曾花了半年时间
there have been times I spend 50% of my time, over a year,

14
00:00:42,864 --> 00:00:45,264
用上节课你们见到的
trying various design alternatives

15
00:00:45,760 --> 00:00:48,192
那种元循环求值器来试验
by experimenting with them with metacircular interpreters--

16
00:00:49,472 --> 00:00:52,016
各种各样不同的设计
metacircular interpreters like the sort you just saw.

17
00:00:52,570 --> 00:00:54,112
用元循环求值是因为
Metacircular is because

18
00:00:54,720 --> 00:00:56,944
#TBD
they are defined in terms of themselves in such a way

19
00:00:56,976 --> 00:00:59,712
#TBD
that the language they interpret contains itself.

20
00:01:01,270 --> 00:01:03,872
这样的求值器是一种的媒介
Such interpreters are a convenient medium

21
00:01:03,888 --> 00:01:05,584
帮助我们探索语言问题
for exploring language issues.

22
00:01:06,800 --> 00:01:09,440
如果你想添加一个新的FEATURE
If you want to try adding a new feature,

23
00:01:10,512 --> 00:01:12,384
这就是小菜一碟
it's sort of a snap, it's easy,

24
00:01:12,736 --> 00:01:15,104
你只需要稍作修改 然后观察结果
you just do it and see what happens.

25
00:01:15,490 --> 00:01:17,200
在尝试了一会儿新语言后
You play with that language for a while you say,

26
00:01:17,248 --> 00:01:19,472
你可能觉得它不好 就把它扔到一边去了
gee, I'm didn't like that, you throw it away.

27
00:01:20,960 --> 00:01:23,552
或者你也想研究
Or you might want to see what

28
00:01:23,648 --> 00:01:27,376
不同的绑定策略的差异
the difference is if you'd make a slight difference in the binding strategy,

29
00:01:28,816 --> 00:01:31,904
或者是一些更复杂的东西
or some more complicated things that might occur.

30
00:01:33,720 --> 00:01:35,488
事实上 这些元循环求值器
In fact, these metacircular interpreters

31
00:01:36,170 --> 00:01:37,888
非常适合作为交换媒介
are an excellent medium for people

32
00:01:38,208 --> 00:01:42,560
承载人们关于语言设计想法
exchanging ideas about language design,

33
00:01:43,984 --> 00:01:45,744
因为它们易于理解
because they're pretty easy to understand,

34
00:01:46,288 --> 00:01:48,464
它们短小、紧凑而且简洁
and they're short, and compact, and simple.

35
00:01:49,328 --> 00:01:50,800
如果我有一些点子
If I have some idea

36
00:01:51,536 --> 00:01:53,776
想让其它人评论一下
that I want somebody to criticize

37
00:01:54,256 --> 00:01:58,320
比如Indiana大学的Dan Friedman教授
like say, Dan Friedman at Indiana,

38
00:01:59,050 --> 00:02:02,000
我就编写一个小型的元循环求值器
I'd write a little metacircular interpreter

39
00:02:02,560 --> 00:02:05,450
然后把求值器作为附件给他发一封电子邮件
send him some network mail with this interpreter in it.

40
00:02:05,450 --> 00:02:07,904
他就可以在电脑上按照并运行这个求值器
He could whip it up on his machine and play with it

41
00:02:07,920 --> 00:02:09,824
可能他会觉得这个设计并不好
and say, that's no good.

42
00:02:11,940 --> 00:02:13,104
然后他会给我回一封邮件
And then send it back to me and say,

43
00:02:13,136 --> 00:02:14,830
“为什么不试试这个 这个更好一点”
well, why don't you try this one, it's a little better.

44
00:02:16,880 --> 00:02:19,360
所以我将会讲一些这方面的技术
So I want to show you some of that technology.

45
00:02:20,160 --> 00:02:24,208
因为在设计你自己的特定用途语言时
See, because, really, it's the essential, simple technology

46
00:02:24,720 --> 00:02:28,688
这种简单的技术非常重要
for getting started in designing your own languages for particular purposes.

47
00:02:30,790 --> 00:02:32,080
我们试着先在Lisp中
Let's start by adding

48
00:02:32,512 --> 00:02:34,210
添加一个非常简单的FEATURE
a very simple feature to a Lisp.

49
00:02:40,640 --> 00:02:44,370
在这之前 我先来谈谈FEATURE吧
Now, one thing I want to tell you about is features, before I start.

50
00:02:49,560 --> 00:02:52,176
很多语言添加了大量的FEATURE
There are many languages that have made a mess of themselves

51
00:02:53,056 --> 00:02:54,912
把它们本身搞得混乱不堪
by adding huge numbers of features.

52
00:02:56,864 --> 00:02:58,384
计算机科学家有一个笑话
Computer scientists have a joke

53
00:02:59,280 --> 00:03:02,520
“这不是BUG 这是FEATURE”
about bugs that transform it to features all the time.

54
00:03:05,030 --> 00:03:06,464
而我宁愿认为
But I like to think of it is that

55
00:03:08,912 --> 00:03:11,440
很多系统都在遭受着“功能蔓延”的影响
 many systems suffer from what's called creeping featurism.

56
00:03:12,820 --> 00:03:13,440
比方说
Which is that

57
00:03:14,944 --> 00:03:18,160
George希望系统中有某个FEATURE
George has a pet feature he'd like in the system,

58
00:03:18,720 --> 00:03:19,360
他就把它加入了系统
so he adds it.

59
00:03:20,170 --> 00:03:22,144
Harry也想着
And then Harry says, go says

60
00:03:22,176 --> 00:03:24,208
这个系统现在也不是我喜欢的那个了
gee, this system is no longer what exactly I like,

61
00:03:24,240 --> 00:03:25,920
然后加入了自己最喜欢的FEATURE
so I'm going to add my favorite feature.

62
00:03:26,640 --> 00:03:30,240
Jim也这样做
And then Jim adds his favorite feature.

63
00:03:30,832 --> 00:03:31,792
一段时间过后
And, after a while,

64
00:03:31,808 --> 00:03:34,816
操作手册就多达500页
the thing has a manual 500 pages long

65
00:03:35,152 --> 00:03:36,512
以至于没人能看得懂
that no one can understand.

66
00:03:37,790 --> 00:03:39,328
有时候也可能只是
And sometimes it's the same person

67
00:03:39,904 --> 00:03:41,376
同一个人在添加FEATURE
who writes all of these features

68
00:03:41,392 --> 00:03:43,232
也会导致同样糟糕的结果
and produces this terribly complicated thing.

69
00:03:44,140 --> 00:03:46,096
很多情况下 比如编辑器
In some cases, like editors,

70
00:03:47,376 --> 00:03:49,120
具有很多FEATURE就很合理
it's sort of reasonable to have lots of features,

71
00:03:50,920 --> 00:03:52,656
因为你想要能够完成
because there are a lot of things you want to be able to do

72
00:03:52,688 --> 00:03:53,760
各种不同的事情
and many of them arbitrary.

73
00:03:56,112 --> 00:03:57,296
但对计算机语言来说
But in computer languages,

74
00:03:57,850 --> 00:03:58,912
我认为太多的FEATURE
I think it's a disaster

75
00:04:00,016 --> 00:04:01,290
是一个灾难
to have too much stuff in them.

76
00:04:04,032 --> 00:04:08,000
#TBD
The other alternative you get into is something called feeping creaturism,

77
00:04:09,520 --> 00:04:11,392
假设你有一个盒子
which is where you have a box

78
00:04:11,808 --> 00:04:15,290
它有一个鼠标和花哨的显示器
which has a display, a fancy display, and a mouse,

79
00:04:15,952 --> 00:04:20,048
#TBD
and there is all sorts of complexity associated with all this fancy IO.

80
00:04:21,010 --> 00:04:22,800
#TBD
And your computer language becomes

81
00:04:23,344 --> 00:04:25,376
#TBD
a dismal, little, tiny thing that barely works

82
00:04:25,408 --> 00:04:27,904
#TBD
because of all the swapping, and disk twitching, and so on,

83
00:04:28,096 --> 00:04:29,360
#TBD
caused by your Windows system.

84
00:04:30,080 --> 00:04:31,824
每当你使用计算机的时候
And every time you go near the computer,

85
00:04:31,936 --> 00:04:33,456
鼠标处理进程就会唤醒
the mouse process wakes up and says,

86
00:04:33,850 --> 00:04:35,950
你有什么事情要我做的吗？
gee do you have something for me to do,

87
00:04:36,144 --> 00:04:37,232
然后又回去休眠
and then it goes back to sleep.

88
00:04:37,440 --> 00:04:39,440
如果你的胳膊肘不小心碰到了鼠标
And if you accidentally push mouse with you elbow,

89
00:04:39,616 --> 00:04:42,320
一大堆烟雾就会从你的电脑出来 类似于这样
a big puff of smoke comes out of your computer and things like that.

90
00:04:42,940 --> 00:04:45,296
这就是由于添加FEATURE
So two ways to disastrously

91
00:04:45,552 --> 00:04:47,216
导致系统不能用的两种典型情况
destroy a system by adding features.

92
00:04:47,500 --> 00:04:49,730
现在我们要添加的是 一个非常简单的FEATURE
But try right now to add a little, simple feature.

93
00:04:52,608 --> 00:04:53,776
这个FEATURE非常好
This actually is a good one,

94
00:04:53,856 --> 00:04:56,176
事实上 Lisp中就有这个FEATURE
and in fact, real Lisps have it.

95
00:04:57,250 --> 00:04:58,176
我们都知道
As you've seen,

96
00:04:59,296 --> 00:05:03,136
像+、*这样的过程
there are procedures like plus and times

97
00:05:03,376 --> 00:05:04,896
可以接受不定数目的参数
that take any number of arguments.

98
00:05:05,430 --> 00:05:06,448
因此我们就可以写
So we can write things

99
00:05:06,576 --> 00:05:10,944
(+ (* A X X)
like the sum of the product of a and x and x,

100
00:05:12,096 --> 00:05:16,992
(* B X) C)
 and the product of b and x and c.

101
00:05:17,540 --> 00:05:18,688
这里可以看到
As you can see here,

102
00:05:18,928 --> 00:05:21,760
+有两到三个参数
addition takes three arguments or two arguments,

103
00:05:22,304 --> 00:05:24,816
*也有两到三个参数
multiplication takes two arguments or three arguments,

104
00:05:25,088 --> 00:05:28,496
不管多少个参数都同样可以计算
taking numbers of arguments all of which are to be treated in the same way.

105
00:05:30,000 --> 00:05:34,016
支持不定数目的参数 这一点非常有用
This is a valuable thing, indefinite numbers of arguments.

106
00:05:34,960 --> 00:05:38,416
而我上节课所讲的Lisp求值器
Yet the particular Lisp system that I show you

107
00:05:39,232 --> 00:05:41,856
只能处理固定数目的参数
is one where the numbers of arguments is fixed,

108
00:05:42,620 --> 00:05:45,280
因为我要用BIND过程中的PAIR-UP过程
because I had to match the arguments against the formal parameters

109
00:05:45,632 --> 00:05:47,920
让形式参数与实际参数一一对应
in the binder, where there's a pairup.

110
00:05:50,810 --> 00:05:53,808
假如我想能够定义像这样的过程
Well, I'd like to be able to define new procedures like this

111
00:05:54,896 --> 00:05:57,328
它们可以接收任意个数的参数
that can have any number of arguments.

112
00:05:58,752 --> 00:06:00,400
这个问题有好几部分
Well there's several parts to this problem.

113
00:06:01,344 --> 00:06:04,816
首先是合适的语法描述
The first part is coming up with the syntactic specification,

114
00:06:05,720 --> 00:06:11,216
我们需要能够标注额外的参数
some way of notating the additional arguments,

115
00:06:12,176 --> 00:06:13,632
标注那些不知道个数的参数
of which you don't know how many there are.

116
00:06:15,480 --> 00:06:16,624
另外就是
And then there's the other thing,

117
00:06:17,104 --> 00:06:18,704
一旦我们标注出来后
which is once we've notated it,

118
00:06:19,072 --> 00:06:20,784
我们怎样解释这些个记号
how are we going to interpret that notation

119
00:06:21,740 --> 00:06:23,100
才能得到
so as to do the right thing,

120
00:06:23,856 --> 00:06:25,376
正确的结果呢？
whatever the right thing is?

121
00:06:26,980 --> 00:06:28,800
让我们来考虑一种
So let's consider an example of a sort of thing

122
00:06:28,848 --> 00:06:30,272
我们可能会遇到的情况
we might want to be able to do.

123
00:06:33,070 --> 00:06:34,512
比如说
So an example might be,

124
00:06:35,424 --> 00:06:37,344
我想要定义这样的一个过程
that I might want to be able to define a procedure

125
00:06:37,952 --> 00:06:41,360
它有一个必选参数X
which is a procedure of one required argument x

126
00:06:42,200 --> 00:06:45,264
还有个可选参数 -- 或者说一堆参数
and a non-required -- bunch of arguments,

127
00:06:45,280 --> 00:06:47,230
我不知道它们的数目 就记作Y吧
I don't know how many there are, called y.

128
00:06:49,090 --> 00:06:50,368
X是必选的
So x is required,

129
00:06:55,888 --> 00:06:57,440
然而有很多参数Y
and there are many y's,

130
00:06:59,536 --> 00:07:05,990
这些参数形成的表 -- 我就记作Y
many arguments-- y will be the list of them.

131
00:07:14,480 --> 00:07:16,064
写好了参数列表
Now, with such a thing,

132
00:07:16,096 --> 00:07:17,680
我现在要这样定义过程体
we might be able to say something like,

133
00:07:19,024 --> 00:07:21,984
我要对每一个元素都做同样的处理
map-- I'm going to do something to every one--

134
00:07:22,520 --> 00:07:25,760
(MAP (LAMBDA (U)
of that procedure of one argument u,

135
00:07:27,000 --> 00:07:34,544
(* X U)) Y)
which multiplies x by u, and we'll apply that to y.

136
00:07:36,890 --> 00:07:38,048
这里 我用了一个“点号”
I've used a dot here

137
00:07:38,592 --> 00:07:41,312
来表明点号后面的东西
to indicate that the thing after this

138
00:07:42,192 --> 00:07:44,304
是剩下的所有参数构成的表
is a list of all the rest of the arguments.

139
00:07:46,300 --> 00:07:48,128
这就是一个语法规范
I'm making a syntactic specification.

140
00:07:53,320 --> 00:07:54,640
为什么这样来写呢？
Now, what this depends upon,

141
00:07:55,712 --> 00:07:58,064
这种语法规范之所以合理
 the reason why this is sort of a reasonable thing to do,

142
00:07:59,776 --> 00:08:01,968
是因为Lisp的源码读取器
is because this happens to be a syntax

143
00:08:02,000 --> 00:08:03,600
刚好使用这种语法
 that's used in the Lisp reader

144
00:08:04,416 --> 00:08:07,152
来表示序对
for representing conses.

145
00:08:08,944 --> 00:08:11,080
我们之前没有介绍过
We've never introduced that before.You never see.

146
00:08:11,080 --> 00:08:12,784
你在自己尝试的时候可能遇到过
You may have seen when playing with the system

147
00:08:13,040 --> 00:08:14,624
当你调用(CONS X Y)时
if you cons two things together, you get the

148
00:08:14,896 --> 00:08:18,128
你会得到 X . Y
first, space, dot, the second, space--

149
00:08:19,790 --> 00:08:22,832
准确来说是(X . Y)
the first, space, dot, space, the second

150
00:08:23,088 --> 00:08:24,640
两边还有括号
with parentheses around the whole thing.

151
00:08:26,980 --> 00:08:28,160
举例来说吧
So that, for example,

152
00:08:28,970 --> 00:08:35,040
这里的(X . Y)对应着一个序对
 this x dot y corresponds to a pair,

153
00:08:36,336 --> 00:08:39,296
X是CAR部分 Y是CDR部分
which has got an x in it and a y in it.

154
00:08:41,488 --> 00:08:43,984
你们目前为止见过的其它记号
The other notations that you've seen so far

155
00:08:44,944 --> 00:08:46,672
是像
are things like, like

156
00:08:46,920 --> 00:08:55,248
(LAMBDA (X Y Z) ...)这样的
a procedure of arguments x and y and z which do things

157
00:08:55,710 --> 00:08:57,630
它们则是像这样的
and that looks like--

158
00:09:02,000 --> 00:09:03,616
就拿形式参数表来说
Just looking at the bound variable list,

159
00:09:04,224 --> 00:09:05,296
它实际上是这样
it looks like this,

160
00:09:09,936 --> 00:09:17,328
这里分别是 X、Y、Z和空表
x, y, z, and the empty thing.

161
00:09:18,280 --> 00:09:21,088
如果我有一个想要与之匹配的参数表的话
If I have a list of arguments I wish to match this against,

162
00:09:22,608 --> 00:09:25,600
假设实际参数表是'(1 2 3)
I have a list of arguments one, two, three,

163
00:09:25,872 --> 00:09:27,264
我想把它们和形参相匹配
I want to match these against.

164
00:09:28,384 --> 00:09:37,104
所以这里 可能有个三个元素的表
OK? So I might have here a list of three things,

165
00:09:42,448 --> 00:09:46,944
分别是1、2、3
one, two, three.

166
00:09:48,990 --> 00:09:53,168
用'(1 2 3)来匹配'(X Y Z)
And I want to match x, y, z against one, two, three.

167
00:09:54,220 --> 00:09:56,288
很显然1和X相匹配
Well, it's clear that the one matches the x,

168
00:09:56,320 --> 00:09:58,016
因为我可以顺着这个结构来
because I can just sort of follow the structure,

169
00:09:58,864 --> 00:10:01,568
2和Y相匹配
and the two matches the y,

170
00:10:02,464 --> 00:10:04,048
3和Z相匹配
and the three matches the z.

171
00:10:05,480 --> 00:10:09,536
假设我现在要把这个(X . Y)
But now, supposing I were to compare this x dot y.

172
00:10:09,552 --> 00:10:11,840
这个是(X . Y)
this is x dot y--

173
00:10:12,512 --> 00:10:16,912
如果我想把它跟'(1 2 3)相匹配的话
supposing I compare that with a list of three arguments, one, two, three.

174
00:10:19,088 --> 00:10:20,000
我们再来看
Let's look at that again.

175
00:10:28,000 --> 00:10:30,320
这里是1、2、3
One, two, three--

176
00:10:30,864 --> 00:10:32,880
我可以沿着这里遍历
Well, I can walk along here

177
00:10:32,992 --> 00:10:35,504
会发现 1和X相匹配
and say, oh yes, x matches the one,

178
00:10:37,568 --> 00:10:41,840
而Y和'(2 3)相匹配
Ah, the y matches the list, which is two and three.

179
00:10:43,740 --> 00:10:46,224
所以这里选用的表示法
So the notation I'm choosing here

180
00:10:46,416 --> 00:10:50,160
对于Lisp来说是非常自然的
is one that's very natural for Lisp system.

181
00:10:52,660 --> 00:10:54,144
所以我就选择用这个记号
But I'm going to choose this as a notation

182
00:10:54,176 --> 00:10:55,808
来表示数目不定的参数
for representing a bunch of arguments.

183
00:10:58,290 --> 00:11:00,096
还有一种可能性
Now, there's an alternative possibility.

184
00:11:00,592 --> 00:11:02,784
#TBD
If I don't want to take one special out,

185
00:11:03,008 --> 00:11:05,008
#TBD
or two special ones out or something like that,

186
00:11:06,544 --> 00:11:07,568
如果我不想那样的话
if I don't want to do that,

187
00:11:08,780 --> 00:11:10,448
如果我想像+那样
if I want to talk about

188
00:11:10,528 --> 00:11:12,520
一下子引用所有的参数
just the list of all the arguments like in addition，

189
00:11:13,880 --> 00:11:17,960
那么我就应该把参数列表写成
well then the argument list I'm going to choose to be

190
00:11:18,200 --> 00:11:23,456
(LAMBDA X ...)
that procedure of all the arguments x, which does something with x

191
00:11:25,140 --> 00:11:26,304
举例来说
And which, for example,

192
00:11:26,816 --> 00:11:27,968
如果我定义一个过程
if I take the procedure,

193
00:11:28,064 --> 00:11:30,448
它把接收所有的参数
which takes all the arguments x

194
00:11:31,120 --> 00:11:32,704
然后返回一个由它们组成的表X
and returned the list of them,

195
00:11:34,810 --> 00:11:38,672
返回的结果就是过程的参数表 明白吗？
OK? That's list. That's the procedure list.

196
00:11:45,850 --> 00:11:46,672
这又是怎么回事呢？
How does this work?

197
00:11:46,840 --> 00:11:50,064
确实 本例中我有的是形式参数表#TBD
Well, indeed what I had as the bound variable list in this case,

198
00:11:50,608 --> 00:11:53,680
不管它们是什么 都要与实际参数相匹配
whatever it is, is being matched against a list of arguments.

199
00:11:55,140 --> 00:11:57,145
现在 这个符号就是所有的实际参数了
This symbol now is all of the arguments.

200
00:12:01,490 --> 00:12:05,136
所以 我选择使用这个特定的语法规范
And so this is the choice I'm making for a particular syntactic specification,

201
00:12:05,648 --> 00:12:07,632
来描述那些
for the description of procedures

202
00:12:08,048 --> 00:12:10,560
接收不定数目参数的过程
which take indefinite numbers of arguments.

203
00:12:13,456 --> 00:12:14,608
一共就两种情况，上面这种和下面这种
There are two cases of it, this one and this one.

204
00:12:15,400 --> 00:12:16,350
一共就两种情况，上面这种和下面这种
There are two cases of it, this one and this one.

205
00:12:17,440 --> 00:12:18,368
一共就两种情况，上面这种和下面这种
There are two cases of it, this one and this one.

206
00:12:18,420 --> 00:12:20,112
当你构建新的语法描述的时候，一定要注意，不要与现有的语法混淆或者矛盾
When you make syntactic specifications, it's important that it's unambiguous, that neither of these can be confused with a representation we already have, this one.

207
00:12:20,448 --> 00:12:22,544
当你构建新的语法描述的时候，一定要注意，不要与现有的语法混淆或者矛盾
When you make syntactic specifications, it's important that it's unambiguous, that neither of these can be confused with a representation we already have, this one.

208
00:12:23,568 --> 00:12:27,360
当你构建新的语法描述的时候，一定要注意，不要与现有的语法混淆或者矛盾
When you make syntactic specifications, it's important that it's unambiguous, that neither of these can be confused with a representation we already have, this one.

209
00:12:27,664 --> 00:12:31,200
当你构建新的语法描述的时候，一定要注意，不要与现有的语法混淆或者矛盾
When you make syntactic specifications, it's important that it's unambiguous, that neither of these can be confused with a representation we already have, this one.

210
00:12:33,610 --> 00:12:35,824
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.

211
00:12:36,544 --> 00:12:39,808
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.

212
00:12:40,288 --> 00:12:41,760
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.

213
00:12:42,640 --> 00:12:43,130
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.

214
00:12:43,280 --> 00:12:45,360
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.

215
00:12:45,440 --> 00:12:48,016
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.

216
00:12:49,424 --> 00:12:53,520
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.

217
00:12:53,680 --> 00:12:56,528
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.

218
00:12:56,992 --> 00:12:58,848
引入了新的语法描述，我也总是可以分清是接收固定数目的参数，还是一定固定参数后再接不定数目的参数，更或者是参数的个数完全不确定全部由x来表示
I can always tell whether I have a fixed number of explicitly named arguments made by these formal parameters, or a fixed number of named formal parameters followed by a thing which picks up all the rest of them, or a list of all the arguments which will be matched against this particular formal parameter called x, because these are syntactically distinguishable.

219
00:13:02,250 --> 00:13:04,624
有很多语言都是由于语法描述方面出现了混淆或者矛盾导致语言解释器的错误
Many languages make terrible errors in that form where whole segments of interpretation are cut off, because there are syntactic ambiguities in the language.

220
00:13:05,040 --> 00:13:08,032
有很多语言都是由于语法描述方面出现了混淆或者矛盾导致语言解释器的错误
Many languages make terrible errors in that form where whole segments of interpretation are cut off, because there are syntactic ambiguities in the language.

221
00:13:08,640 --> 00:13:13,920
有很多语言都是由于语法描述方面出现了混淆或者矛盾导致语言解释器的错误
Many languages make terrible errors in that form where whole segments of interpretation are cut off, because there are syntactic ambiguities in the language.

222
00:13:14,560 --> 00:13:16,096
比如 类ALGOL语言的嵌套if问题
They are the traditional problems with ALGOL like languages having to do with the nesting of ifs in the predicate part.

223
00:13:16,112 --> 00:13:18,128
比如 类ALGOL语言的嵌套if问题
They are the traditional problems with ALGOL like languages having to do with the nesting of ifs in the predicate part.

224
00:13:19,136 --> 00:13:23,392
比如 类ALGOL语言的嵌套if问题
They are the traditional problems with ALGOL like languages having to do with the nesting of ifs in the predicate part.

225
00:13:25,060 --> 00:13:25,936
现在我已经告诉你们可行的语法了，接下来要怎么做呢？
In any case, now, so I've told you about the syntax, now, what are we going to do about the semantics of this?

226
00:13:27,520 --> 00:13:29,440
现在我已经告诉你们可行的语法了，接下来要怎么做呢？
In any case, now, so I've told you about the syntax, now, what are we going to do about the semantics of this?

227
00:13:30,272 --> 00:13:34,832
现在我已经告诉你们可行的语法了，接下来要怎么做呢？
In any case, now, so I've told you about the syntax, now, what are we going to do about the semantics of this?

228
00:13:35,250 --> 00:13:36,112
我们如何来解释它？
How do we interpret it?

229
00:13:36,590 --> 00:13:37,968
其实很简单
Well this is just super easy.

230
00:13:38,440 --> 00:13:42,576
现在我来修改一下元循环
I'm going to modify the metacircular interpreter to do it.

231
00:13:43,712 --> 00:13:44,768
只需要修改一行
And that's a one liner.

232
00:13:45,984 --> 00:13:46,576
在这里
There it is.

233
00:13:47,590 --> 00:13:49,560
把pair-up修改一下就行
I'm changing the way you pair things up.

234
00:13:56,768 --> 00:14:00,048
pair-up就是那个用来匹配形参与实参的过程
Here's the procedure that pairs the variables, the formal parameters, with the arguments that were passed from the last description of the metacircular interpreter.

235
00:14:01,472 --> 00:14:07,120
pair-up就是那个用来匹配形参与实参的过程
Here's the procedure that pairs the variables, the formal parameters, with the arguments that were passed from the last description of the metacircular interpreter.

236
00:14:07,920 --> 00:14:09,648
pair-up就是那个用来匹配形参与实参的过程
Here's the procedure that pairs the variables, the formal parameters, with the arguments that were passed from the last description of the metacircular interpreter.

237
00:14:12,160 --> 00:14:16,688
pair-up就是那个用来匹配形参与实参的过程
Here's the procedure that pairs the variables, the formal parameters, with the arguments that were passed from the last description of the metacircular interpreter.

238
00:14:18,960 --> 00:14:19,936
大部分地方都不需要修改
And here's some things that are the same as they were before.

239
00:14:20,160 --> 00:14:21,808
大部分地方都不需要修改
And here's some things that are the same as they were before.

240
00:14:22,670 --> 00:14:23,232
如果变量列表为空，而且值的列表也是空，就返回空列表
In other words, if the list of variables is empty, then if the list of values is empty, then I have an empty list.

241
00:14:23,312 --> 00:14:25,072
如果变量列表为空，而且值的列表也是空，就返回空列表
In other words, if the list of variables is empty, then if the list of values is empty, then I have an empty list.

242
00:14:25,520 --> 00:14:27,312
如果变量列表为空，而且值的列表也是空，就返回空列表
In other words, if the list of variables is empty, then if the list of values is empty, then I have an empty list.

243
00:14:27,456 --> 00:14:29,616
如果变量列表为空，而且值的列表也是空，就返回空列表
In other words, if the list of variables is empty, then if the list of values is empty, then I have an empty list.

244
00:14:31,050 --> 00:14:33,008
否则，就是值太多了，也即变量列表为空而值列表不是空的
Otherwise, I have too many arguments, that is, if I have empty variables but not empty values.

245
00:14:33,984 --> 00:14:36,016
否则，就是值太多了，也即变量列表为空而值列表不是空的
Otherwise, I have too many arguments, that is, if I have empty variables but not empty values.

246
00:14:36,800 --> 00:14:40,128
否则，就是值太多了，也即变量列表为空而值列表不是空的
Otherwise, I have too many arguments, that is, if I have empty variables but not empty values.

247
00:14:41,580 --> 00:14:44,000
如果值列表为空，但是变量列表不为空，那么就是实参给少了
If I have empty values, but the variables are not empty, I have too few arguments.

248
00:14:44,960 --> 00:14:47,456
如果值列表为空，但是变量列表不为空，那么就是实参给少了
If I have empty values, but the variables are not empty, I have too few arguments.

249
00:14:47,456 --> 00:14:47,472
如果值列表为空，但是变量列表不为空，那么就是实参给少了
If I have empty values, but the variables are not empty, I have too few arguments.
如果值列表为空，但是变量列表不为空，那么就是实参给少了
If I have empty values, but the variables are not empty, I have too few arguments.

250
00:14:47,472 --> 00:14:48,560
如果值列表为空，但是变量列表不为空，那么就是实参给少了
If I have empty values, but the variables are not empty, I have too few arguments.

251
00:14:48,944 --> 00:14:51,312
如果变量是一个符号，开始有意思了，这是一种特殊情况，这是一个符号尾
The variables are a symbol-- interesting case-- then, what I should do is say, oh yes, this is the special case that I have a symbolic tail.

252
00:14:55,536 --> 00:14:56,496
如果变量是一个符号，开始有意思了，这是一种特殊情况，这是一个符号尾
The variables are a symbol-- interesting case-- then, what I should do is say, oh yes, this is the special case that I have a symbolic tail.

253
00:14:58,300 --> 00:15:02,752
如果变量是一个符号，开始有意思了，这是一种特殊情况，这是一个符号尾
The variables are a symbol-- interesting case-- then, what I should do is say, oh yes, this is the special case that I have a symbolic tail.

254
00:15:03,184 --> 00:15:06,512
如果变量是一个符号，开始有意思了，这是一种特殊情况，这是一个符号尾
The variables are a symbol-- interesting case-- then, what I should do is say, oh yes, this is the special case that I have a symbolic tail.

255
00:15:08,352 --> 00:15:14,048
情况就像这里的一样
I have here a thing just like we looked over here.

256
00:15:14,900 --> 00:15:17,872
tail部分的y是一个符号
This is a tail which is a symbol, y.

257
00:15:18,630 --> 00:15:19,392
它不是nil
It's not a nil.

258
00:15:20,730 --> 00:15:21,728
也不是空列表，这里的符号尾x就是最开始的那种情况
It's not the empty list. Here's a symbolic tail that is just the very beginning of the tail.

259
00:15:23,264 --> 00:15:25,600
也不是空列表，这里的符号尾x就是最开始的那种情况
It's not the empty list. Here's a symbolic tail that is just the very beginning of the tail.

260
00:15:25,984 --> 00:15:26,816
不是另外的情况
There is nothing else.

261
00:15:27,790 --> 00:15:28,720
这种情况下，我就用这个符号去匹配整个值列表
In that case, I wish to match that variable with all the values and add that to the pairing that I'm making.

262
00:15:29,968 --> 00:15:34,336
这种情况下，我就用这个符号去匹配整个值列表
In that case, I wish to match that variable with all the values and add that to the pairing that I'm making.

263
00:15:36,016 --> 00:15:42,528
这种情况下，我就用这个符号去匹配整个值列表
In that case, I wish to match that variable with all the values and add that to the pairing that I'm making.

264
00:15:44,500 --> 00:15:46,912
否则，我就回到以往的正常情况来一一匹配
Otherwise, I go through the normal arrangement of making up the whole pairing.

265
00:15:47,152 --> 00:15:48,528
否则，我就回到以往的正常情况来一一匹配
Otherwise, I go through the normal arrangement of making up the whole pairing.

266
00:15:52,020 --> 00:15:53,824
我认为这很容易理解
I suppose that's very simple.

267
00:15:54,510 --> 00:15:55,840
就是这些
And that's all there is to it.

268
00:15:57,080 --> 00:15:58,330
现在  答疑时间
And now I'll answer some questions.

269
00:16:02,620 --> 00:16:05,056
有什么问题吗？
The first one-- Are there any questions?

270
00:16:06,600 --> 00:16:06,944
你说
Yes?

271
00:16:07,376 --> 00:16:09,920
你能再解释一下第三种形式吗？
AUDIENCE: Could you explain that third form?

272
00:16:09,980 --> 00:16:12,128
这个？
PROFESSOR: Third form. This one? OK.

273
00:16:12,590 --> 00:16:16,200
或许你用表结构来思考它会更容易理解一些
Well, maybe we should look at the thing as a piece of list structure.

274
00:16:17,344 --> 00:16:17,808
或许你用表结构来思考它会更容易理解一些
Well, maybe we should look at the thing as a piece of list structure.

275
00:16:18,570 --> 00:16:22,736
这是一个过程，包含一个lambda
This is a procedure which contains a lambda.

276
00:16:25,856 --> 00:16:29,616
我来画出表示上面这个过程的表结构
I'm just looking at the list structure which represents this.

277
00:16:31,264 --> 00:16:32,448
这里是x
Here's x.

278
00:16:32,730 --> 00:16:33,980
这些是我们的符号
These are our symbols.

279
00:16:37,410 --> 00:16:39,580
过程体就是x而已
And then the body is nothing but x.

280
00:16:44,840 --> 00:16:48,752
如果我来查找这个过程的形参部分，取整个结构的CADR，返回一个符号x
If I were looking for the bound variable list part of this procedure, I would go looking at the CADR, and I'd find a symbol.

281
00:16:50,096 --> 00:16:51,584
如果我来查找这个过程的形参部分，取整个结构的CADR，返回一个符号x
If I were looking for the bound variable list part of this procedure, I would go looking at the CADR, and I'd find a symbol.

282
00:16:52,144 --> 00:16:53,168
如果我来查找这个过程的形参部分，取整个结构的CADR，返回一个符号x
If I were looking for the bound variable list part of this procedure, I would go looking at the CADR, and I'd find a symbol.

283
00:16:54,010 --> 00:16:57,168
所以，很自然地，在pair-up中，我就用一个符号去匹配整个实参的列表
So the, naturally, which is this pairup thing I just showed you, is going to be matching a symbolic object against a list of arguments that were passed.

284
00:16:58,240 --> 00:17:00,448
所以，很自然地，在pair-up中，我就用一个符号去匹配整个实参的列表
So the, naturally, which is this pairup thing I just showed you, is going to be matching a symbolic object against a list of arguments that were passed.

285
00:17:01,568 --> 00:17:04,400
所以，很自然地，在pair-up中，我就用一个符号去匹配整个实参的列表
So the, naturally, which is this pairup thing I just showed you, is going to be matching a symbolic object against a list of arguments that were passed.

286
00:17:05,760 --> 00:17:09,559
这个符号与实参的列表相绑定
And it will bind that symbol to the list of arguments.

287
00:17:11,344 --> 00:17:12,000
上面这种情况，如果我用CADR，得到这样的结构去匹配实参列表
In this case, if I'm looking for it, the match will be against this in the bound variable list position.

288
00:17:13,910 --> 00:17:16,480
上面这种情况，如果我用CADR，得到这样的结构去匹配实参列表
In this case, if I'm looking for it, the match will be against this in the bound variable list position.

289
00:17:16,928 --> 00:17:20,976
上面这种情况，如果我用CADR，得到这样的结构去匹配实参列表
In this case, if I'm looking for it, the match will be against this in the bound variable list position.

290
00:17:24,140 --> 00:17:27,536
这里的x就匹配到整个实参的列表然后返回x这个列表，这就是这个过程所做的事
Now, if what this does is it gets a list of arguments and returns it, that's list. That's what the procedure is.

291
00:17:28,480 --> 00:17:31,450
这里的x就匹配到整个实参的列表然后返回x这个列表，这就是这个过程所做的事
Now, if what this does is it gets a list of arguments and returns it, that's list. That's what the procedure is.

292
00:17:34,510 --> 00:17:35,488
好的
Oh well, thank you.

293
00:17:36,140 --> 00:17:37,280
大家休息一下吧
Let's take a break.

294
00:17:37,830 --> 00:17:55,360
[音乐]
[JESU, JOY OF MAN'S DESIRING]

295
00:17:55,360 --> 00:17:59,024
《计算机程序的构造和解释》

296
00:18:03,530 --> 00:18:07,568
讲师：哈罗德·艾伯森教授 及 格兰德·杰·萨斯曼教授

297
00:18:07,560 --> 00:18:11,696
《计算机程序的构造和解释》

298
00:18:12,256 --> 00:18:16,110
元循环求值器 II

299
00:18:20,358 --> 00:18:23,260
我们接着来看
PROFESSOR: Well let's see.

300
00:18:23,260 --> 00:18:38,250
我将要介绍另一种Lisp变式，这项feature非常出名，早期的很多Lisp实现都有它
Now, I'm going to tell you about a rather more substantial variation, one that's a famous variation that many early Lisps had.

301
00:18:38,250 --> 00:18:41,770
它被称为变量的动态绑定
It's called dynamic binding of variables.

302
00:18:41,770 --> 00:18:44,680
我们现在来研究一下
And we'll investigate a little bit about that right now.

303
00:18:47,620 --> 00:18:53,740
我先来介绍一下是什么情况导致人们会有动态绑定这样的想法的
I'm going to first introduce this by showing you the sort of thing that would make someone want this idea.

304
00:18:53,740 --> 00:18:58,640
我不具体说是到底是什么情况，我只来举一些例子，你们说不定也会有同样的想法的
I'm not going to tell what it is yet, I'm going to show you why you might want it.

305
00:18:58,640 --> 00:19:08,140
假设，我们再来考虑sum这个过程，对一串东西求和
Suppose, for example, we looked at the sum procedure again for summing up a bunch of things.

306
00:19:08,140 --> 00:20:08,220
(define sum (lambda (term a next b) (cond ((> a b) 0) (else (+ (term a) (sum term (next a) next b))))))
To be that procedure, of a term, lower bound, method of computing the next index, and upper bound, such that, if a is greater than b then the result is 0, otherwise, it's the sum, of the term, procedure, applied to a and the result of adding up, terms, with the next a being the a, the next procedure passed along, and the upper bound being passed along.

307
00:20:14,510 --> 00:20:25,450
当我使用sum过程的时候，我可以这样来用
Blink, blink, blink-- Now, when I use this sum procedure, I can use it, for example, like this.

308
00:20:25,450 --> 00:21:11,440
(define sum-powers (lambda (a b n) (sum (lambda (x) (expt x n)) a 1+ b)))
We can define the sum of the powers to be, for example, sum of a bunch of powers x to the n, to be that procedure of a, b, and n-- lower bound, the upper bound, and n-- which is sum, of lambda of x, the procedure of one argument x, which exponentiates x to the n, with the a, the incrementer, and b, being passed along.

309
00:21:11,440 --> 00:21:16,340
计算x^n
So we're adding up x to n, given an x.

310
00:21:16,340 --> 00:21:19,740
x从a到b取值，加1递增
x takes on values from a to b, incrementing by one.

311
00:21:22,940 --> 00:21:29,780
我也可以写 -- 对了
I can also write the-- That's right.

312
00:21:29,780 --> 00:21:31,910
乘积
Product, excuse me.

313
00:21:31,910 --> 00:21:33,220
product-powers
The product of a bunch of powers.

314
00:21:38,080 --> 00:21:40,020
名字有点奇怪
It's a strange name.

315
00:21:40,020 --> 00:21:41,960
还是不改了
I'm going to leave it there.

316
00:21:41,960 --> 00:21:50,890
有点怪，就按原来的吧
Weird-- I write up what I have. I'm sure that's right.

317
00:21:50,890 --> 00:22:03,400
如果我想写product-powers，That was 12 brain cells, that double-take.[此句不明了]
And if I want the product of a bunch of powers-- That was 12 brain cells, that double-take.

318
00:22:03,400 --> 00:22:11,450
这个过程就像刚才的sum-powers差不多
I can for example use the procedure which is like sum, which is for making products, but it's similar to that, that you've seen before.

319
00:22:11,450 --> 00:22:16,725
也是一个有三个参数的过程
There's a procedure of three arguments again.

320
00:22:16,725 --> 00:22:37,850
过程具体为(product (lambda (x) (expt x n)) a 1+ b)
Which is the product of terms that are constructed, or factors in this case, constructed from exponentiating x to the n, where I start with a, I increment, and I go to b.

321
00:22:41,530 --> 00:22:50,750
你可能马上就意识到一些问题
Now, there's some sort of thing here that should disturb you immediately.

322
00:22:50,750 --> 00:22:53,180
它们看起来几乎一样
These look the same.

323
00:22:53,180 --> 00:22:56,590
为什么要重复写代码呢？
Why am I writing this code so many times?

324
00:22:56,590 --> 00:23:01,270
现在就和之前我们遇到的情况很相似了
Here I am, in the same boat I've been in before.

325
00:23:01,270 --> 00:23:03,810
构造一个抽象不是挺好的吗？
Wouldn't it be nice to make an abstraction here?

326
00:23:03,810 --> 00:23:05,980
如何构建良好的抽象呢？
What's an example of a good abstraction to make?

327
00:23:05,980 --> 00:23:08,470
我看到有一些完全相同的代码
Well, I see some codes that's identical.

328
00:23:08,470 --> 00:23:11,080
这有一段，还有这里
Here's one, and here's another.

329
00:23:14,450 --> 00:23:17,090
所以我应该把它们提取出来
And so maybe I should be able to pull that out.

330
00:23:17,090 --> 00:23:25,710
所以我就会想，sum-powers可以用名为nth-powers的过程来表示
I should be able to say, oh yes, the sum of the powers could be written in terms of something called the nth power procedure.

331
00:23:25,710 --> 00:23:30,030
假如有人想写一个稍微不同的过程
Imagine somebody wanted to write a slightly different procedure that looks like this.

332
00:23:37,630 --> 00:23:53,556
(define sum-powers (lambda (a b n)
The sum powers to be a procedure of a, b, and n, as the result of summing up the nth power.

333
00:23:53,556 --> 00:24:02,170
(sum nth-power a 1+ b)
We're going to give a name to that idea, for starting at a, going by one, and ending at b.

334
00:24:06,000 --> 00:24:16,270
相似地，我用这种方式来重写product-powers
And similarly, I might want to write the product powers this way, abstracting out this idea.

335
00:24:16,270 --> 00:24:17,520
应该这样
I might want this.

336
00:24:22,100 --> 00:24:58,380
(define product-powers (lambda (a b n) (product nth-powers a 1+ b)))
Product powers, to be a procedure of a, b, and n, which is the product of the nth power operation on a with the incrementation and b being my arguments for the analogous-thing product.

337
00:24:58,380 --> 00:25:05,930
我们还需要定义过程nth-powers，我把它写在这边
And I'd like to be able to define, I'd like to be able to define nth power-- I'll put it over here.

338
00:25:11,215 --> 00:25:12,990
写在上面
I'll put it at the top.

339
00:25:25,410 --> 00:25:35,390
这个过程就应该是 (define nth-powers (lambda (x) (expt x n)))
--to be, in fact, my procedure of one argument x which is the result of exponentiating x to the n.

340
00:25:35,390 --> 00:25:38,640
但是我遇到一个问题
But I have a problem.

341
00:25:38,640 --> 00:25:48,810
我们用环境模型来解释这一段代码，但是找不到n的定义
My environment model, that is my means of interpretation for the language that we've defined so far, does not give me a meaning for this n.

342
00:25:52,520 --> 00:26:06,410
因为，在这个过程内，n是自由变量
Because, as you know, this n is free in this procedure.

343
00:26:06,410 --> 00:26:16,640
环境模型告诉我们自由变量的值取决于过程被定义时所在的环境
The environment model tells us that the meaning of a free variable is determined in the environment in which this procedure is defined.

344
00:26:16,640 --> 00:26:25,850
假设所有的过程就像我在黑板上写的这样来定义，nth-powers就定义在全局环境下，没有n的定义
In a way I have written it, assuming these things are defined on the blackboard as is, this is defined in the global environment, where there is no end.

345
00:26:25,850 --> 00:26:28,720
因此，n是未绑定的变量
Therefore, n is unbound variable.

346
00:26:28,720 --> 00:26:36,220
这种写法很简洁，但是我们都希望n是这里的n和这里的n
But it's perfectly clear, to most of us, that we would like it to be this n and this n.

347
00:26:38,990 --> 00:26:42,840
这样就太完美了
On the other hand, it would be nice.

348
00:26:42,840 --> 00:26:52,900
当然我们也要确定这里的n是这里的n，这边的也一样
Certainly we've got to be careful here of keeping this to be this, and this one over here, wherever it is to be this one.

349
00:26:57,390 --> 00:27:04,040
这种想法造就了一个非常著名的bug
Well, the desire to make this work has led to a very famous bug.

350
00:27:04,040 --> 00:27:07,310
我来细说下这个bug
I'll tell you about the famous bug.

351
00:27:07,310 --> 00:27:10,660
这张幻灯片
Look at this slide.

352
00:27:10,660 --> 00:27:13,990
这是一种新的设计想法，动态绑定
This is an idea called dynamic binding.

353
00:27:13,990 --> 00:27:29,125
不在过程定义时的环境下解释自由变量，而在调用过程的环境下解释被调用过程内部的自由变量
Where, instead of the free variable being interpreted in the environment of definition of a procedure, the free variable is interpreted as having its value in the environment of the caller of the procedure.

354
00:27:31,850 --> 00:28:04,470
在这个系统中，你从调用程序的链中搜索自由变量，在这个例子里，nth-powers在product的内部被调用 -- sum也是相似的 -- product被product-powers调用，所以你看，product-powers绑定了变量n之后，nth-powers就可以解释自由变量n了
So what you have is a system where you search up the chain of callers of a particular procedure, and, of course, in this case, since nth power is called from inside product whatever it is-- I had to write our own sum which is the analogous procedure-- and product is presumably called from product powers, as you see over here, then since product powers bind with variable n , then nth powers n would be derived through that chain.

355
00:28:08,140 --> 00:28:15,800
相似地，sum这边，nth-powers中的n会通过sum-powers sum这样的调用关系中解释自由变量n
Similarly, this n, the nth power in n in this case, would come through nth power here being called from inside sum.

356
00:28:15,800 --> 00:28:19,730
它被sum调用了
You can see it being called from inside sum here.

357
00:28:19,730 --> 00:28:22,900
对应这里的term
It's called term here.

358
00:28:22,900 --> 00:28:28,930
sum在sum-powers内部被调用，而sum-powers绑定了变量n
But sum was called from inside of sum powers, which bound n.

359
00:28:28,930 --> 00:28:36,495
因此nth-powers这里的n就得到了解释
Therefore, there would be an n available for that n to get it's value from.

360
00:28:39,430 --> 00:28:46,540
这边白线以下的情况，就是我们所称的动态绑定
What we have below this white line plus over here, is what's called a dynamic binding view of the world.

361
00:28:46,540 --> 00:28:50,850
用动态绑定的角度来解释，就可以正常运行
If that works, that's a dynamic binding view.

362
00:28:50,850 --> 00:28:55,990
我们来看看，要怎么实现这个功能
Now, let's take a look, for example, at just what it takes to implement that.

363
00:28:55,990 --> 00:28:57,480
非常简单
That's real easy.

364
00:28:57,480 --> 00:29:06,490
事实上，最开始的Lisp实现凡是可以对自由变量进行解释的，都是用的动态绑定方法
In fact, the very first Lisps that had any interpretations of the free variables at all, had dynamic binding interpretations for the free variables.

365
00:29:06,490 --> 00:29:15,220
APL就是用动态绑定来解释自由变量的，而不是静态绑定
APL has dynamic binding interpretation for the free variables, not lexical or static binding.

366
00:29:15,220 --> 00:29:18,790
要实现动态绑定，要从eval下手
So, of course, the change is in eval.

367
00:29:18,790 --> 00:29:22,780
只需修改两个地方就行
And it's really in two places.

368
00:29:22,780 --> 00:29:29,010
第一个地方修改的更为简单
First of all, one thing we see, is that things become a little simpler.

369
00:29:32,460 --> 00:29:42,030
如果是动态绑定的话，过程在定义的时候就无需关乎环境的问题
If I don't have to have the environment be the environment of definition for procedure, the procedure need not capture the environment at the time it's defined.

370
00:29:42,030 --> 00:30:01,290
所以我们看到，在lambda表达式的这一行，只需要返回exp本身就行了，不需要像之前那样加上类型标签'closure并且和环境结构绑定在一起
And so if we look here at this slide, we see that the clause for a lambda expression, which is the way a procedure is defined, does not make up a thing which has a type closure and a attached environment structure.

371
00:30:01,290 --> 00:30:02,540
就是exp本身
It's just the expression itself.

372
00:30:02,540 --> 00:30:06,440
相应的，解读lambda过程的地方也要修改一些
And we'll decompose that some other way somewhere else.

373
00:30:06,440 --> 00:30:14,290
另外要注意的是，在apply的时候必须要知道调用者的环境
The other thing we see is the applicator must be able to get the environment of the caller.

374
00:30:14,290 --> 00:30:19,560
调用者的环境就在这里
The caller of a procedure is right here.

375
00:30:19,560 --> 00:30:26,980
如果表达式是一个过程应用或者组合式，然后我们就执行过程，也就是操作符的值
If the expression we're evaluating is anpplication or a combination, then we're going to call a procedure which is the value of the operator.

376
00:30:29,840 --> 00:30:35,890
调用者的环境就是我们当前的环境
The environment of the caller is the environment we have right here, available now.

377
00:30:35,890 --> 00:30:41,490
所以我要把这个环境传递予apply
So all I have to do is pass that environment to the applicator, to apply.

378
00:30:41,490 --> 00:31:06,810
我们再来看看apply，增加了一个环境参数，绑定参数的时候就来扩展这个环境，而不是去扩展原先绑定在'closure过程内的环境了
And if we look at that here, the only change we have to make is that fellow takes that environment and uses that environment for the purpose of extending that environment when abiding the formal parameters of the procedure to the arguments that were passed, not an environment that was captured in the procedure.

379
00:31:06,810 --> 00:31:14,130
为什么早期的Lisp如此来实现呢？原因也很清楚，碰巧实现了
The reason why the first Lisps were implemented this way, is the sort of the obvious, accidental implementation.

380
00:31:14,130 --> 00:31:17,250
然后大家也就习惯了
And, of course, as usual, people got used to it and liked it.

381
00:31:17,250 --> 00:31:21,590
因此不少人就说Lisp就应该这样做
And there were some people said, this is the way to do it.

382
00:31:21,590 --> 00:31:35,460
不幸地是这导致了不小的问题，最严重的一点是，动态绑定破坏了模块性
Unfortunately that causes some serious problems. The most important, serious problem in using dynamic binding is there's a modularity crisis that's involved it.

383
00:31:35,460 --> 00:31:44,580
如果有两个人在一个大型系统上协同工作，其中一个重要的事情就是两个人的命名不能相互冲突
If two people are working together on some big system, then an important thing to want is that the names used by each one don't interfere with the names of the other.

384
00:31:47,930 --> 00:31:59,850
这一点很重要，不能说 你使用了我代码中的命名就导致我的代码停止工作
It's important that when I invent some segment of code that no one can make my code stop working by using my names that I use internal to my code, internal to his code.

385
00:31:59,850 --> 00:32:06,670
然而，很明显地 动态绑定和特定的模块性约束相冲突
However, dynamic binding violates that particular modularity constraint in a clear way.

386
00:32:06,670 --> 00:32:12,540
我们考虑一下，这样会发生什么
Consider, for example, what happens over here.

387
00:32:12,540 --> 00:32:19,810
假如我把next命名为别的
Suppose it was the case that I decided to change the word next.

388
00:32:19,810 --> 00:32:28,970
假设两个人，一个人写sum过程，另一个人使用sum过程
Supposing somebody is writing sum, and somebody else is going to use sum.

389
00:32:28,970 --> 00:32:33,790
sum的编写者有权利来选择sum内部的命名
The writer of sum has a choice of what names he may use.

390
00:32:33,790 --> 00:32:36,760
假设我就是那个编写者
Let's say, I'm that writer.

391
00:32:36,760 --> 00:32:39,300
刚巧，这里我不想用next来表示
Well, by gosh, just happens I didn't want to call this next.

392
00:32:39,300 --> 00:32:41,500
只写一个n
I called it n.

393
00:32:41,500 --> 00:32:48,140
所以下面的代码就把next都换成n
So all places where you see next, I called it n.

394
00:32:48,140 --> 00:32:49,940
哎呀
Whoops.

395
00:32:49,940 --> 00:32:56,110
我只是改变了过程内部的命名而已，但是整个程序就宕掉了
I changed nothing about the specifications of this program, but this program stops working.

396
00:32:56,110 --> 00:32:59,730
不仅如此，这边也出现了问题
Not only that, unfortunately, this one does too.

397
00:32:59,730 --> 00:33:02,260
为什么会这样？
Why do these programs stop working?

398
00:33:02,260 --> 00:33:04,480
答案非常明显
Well, it's sort of clear.

399
00:33:04,480 --> 00:33:24,370
为了找出nth-powers中n的值，如果根据环境模型，这个n总是这个n
Instead of chasing out the value of the n that occurs in nth power over here or over here, through the environment of definition, where this one is always linked to this one, if it was through the environment of definition, because here is the definition.

400
00:33:24,370 --> 00:33:30,700
lambda表达式总在n被定义的环境下运行
This lambda expression was executed in the environment where that n was defined.

401
00:33:30,700 --> 00:33:37,320
然而如果是动态绑定，我必须追踪过程的调用链，就会有糟糕的事情发生
If instead of doing that, I have to chase through the call chain, then look what horrible thing happens.

402
00:33:37,320 --> 00:33:44,780
这个lambda部分其实是在sum内作为term来调用
Well, this was called from inside sum as term, term a.

403
00:33:44,780 --> 00:33:47,350
这时再来查找n的定义
I'm looking for a value of n.

404
00:33:47,350 --> 00:33:50,700
这样我们找到的n就不是sum-powers的n了，而变成了sum这里的n
Instead of getting this one, I get that one.

405
00:33:50,700 --> 00:33:54,680
因此，在过程的内部的小小修改就导致了整个程序停止工作
So by changing the insides of this program, this program stops working.

406
00:33:56,770 --> 00:34:00,020
这里的n就不再是一个量词了
So I no longer have a quantifier, as I described before.

407
00:34:02,700 --> 00:34:05,430
在这个lambda里n应该是一个量词才对
The lambda symbol is supposed to be a quantifier.

408
00:34:05,430 --> 00:34:24,040
一个事物所绑定的名字应该是不重要的，如果我在这里针对一个名字统一换成别的，表达式的含义也应该保持不变
A thing which has the property that the names that are bound by it are unimportant, that I can uniformly substitute any names for these throughout this thing, so long as they don't occur in here, the new names, and the meaning of this expression should remain unchanged.

409
00:34:24,040 --> 00:34:28,690
但是刚才我只是对next换成了n而已，就导致nth-powers改变了意思
I've just changed the meaning of the expression by changing the one of the names.

410
00:34:28,690 --> 00:34:32,170
所以这里用lambda也就不妥当了
So lambda is no longer a well defined idea.

411
00:34:32,170 --> 00:34:34,550
这个问题非常严重
It's a very serious problem.

412
00:34:34,550 --> 00:34:48,090
因为这个原因，我和同事们放弃了动态绑定，相对的我更喜欢模块化原则
So for that reason, I and my buddies have given up this particular kind of abstraction, which I would like to have, in favor of a modularity principle.

413
00:34:48,090 --> 00:34:54,530
这也是一种针对求值器的探索
But this is the kind of experiment you can do if you want to play with these interpreters.

414
00:34:54,530 --> 00:34:58,270
你可以尝试多种方法
You can try them out this way, that way, and the other way.

415
00:34:58,270 --> 00:35:00,070
从中你会了解到 是什么使一个语言更加优雅
You see what makes a nicer language.

416
00:35:02,680 --> 00:35:04,990
所以元循环真的很重要
So that's a very important thing to be able to do.

417
00:35:04,990 --> 00:35:10,880
现在我们来想想在动态绑定的前提下 怎么样使得这里的程序可以正常运行
Now, I would like to give you a feeling for I think the right thing to do is here.

418
00:35:10,880 --> 00:35:16,280
如何正确的利用动态绑定带来的好处呢？
How are you going to I get this kind of power in a lexical system?

419
00:35:16,280 --> 00:35:23,690
答案是，我只想要一个针对n求指数的过程
And the answer is, of course, what I really want is a something that makes up for me an exponentiator for a particular n.

420
00:35:23,690 --> 00:35:26,280
给定一个n，它就返回一个求n次方的过程
Given an n, it will make me an exponentiator.

421
00:35:26,280 --> 00:35:28,170
这非常简单
Oh, but that's easy too.

422
00:35:28,170 --> 00:35:30,570
换言之，我可以这样来写
In other words, I can write my program this way.

423
00:35:35,450 --> 00:35:45,240
我定义一个过程PGEN，达到刚才所说的效果
I'm going to define a thing called PGEN, which is a procedure of n which produces for me an exponentiator.

424
00:35:50,240 --> 00:35:51,490
(lambda (n) (lambda (x) (expt x n)))
--x to the n.

425
00:35:56,900 --> 00:36:07,890
这样来写的话会更好一些，封装就不会被改名的情况而破坏了
Given that I have that, then I can capture the abstraction I wanted even better, because now it's encapsulated in a way where I can't be destroyed by a change of names.

426
00:36:07,890 --> 00:36:37,590
(define sum-powers (lambda (a b n) (sum (pgen n) a 1+ b)))
I can define some powers to be a procedure again of a, b, and n which is the sum of the term function generated by using this generator, PGEN, n, with a, incrementer, and b.

427
00:36:42,490 --> 00:37:11,150
再定义product-powers，(define product-powers (lambda (a b n) (product (pgen n) a 1+ b)))
And I can define the product of powers to be a procedure of a, b, and n which is the product PGEN, n, with a, increment, and b.

428
00:37:11,150 --> 00:37:17,280
当然，这里的这个例子针对的抽象很简单
Now, of course, this is a very simple example where this object that I'm trying to abstract over is small.

429
00:37:17,280 --> 00:37:20,100
但是这样来写的话就导致要写更多的代码
But it could be a 100 lines of code.

430
00:37:20,100 --> 00:37:23,670
这样写的目的在于使其清晰一些
And so, the purpose of this is, of course, to make it simple.

431
00:37:23,670 --> 00:37:28,200
确保这里的n引用的是正确的n
I'd give a name to it, it's just that here it's a parameterized name.

432
00:37:28,200 --> 00:37:34,050
pgen这里的n明显的就是product-powers这里的n
It's a name that depends upon, explicitly, the lexically apparent value of n.

433
00:37:37,130 --> 00:37:40,210
你也可以认为这个过程调用是一个很长的名字
So you can think of this as a long name.

434
00:37:40,210 --> 00:37:49,220
这里我用一个n为参数可以生成新过程的过程来避免了之前的问题
And here, I've solved my problem by naming the term generation procedures within an n in them.

435
00:37:55,080 --> 00:37:57,140
有什么问题吗？
Are there any questions?

436
00:37:57,140 --> 00:37:58,380
你说，David
Oh, yes, David.

437
00:37:58,380 --> 00:38:06,470
刚才那个问题只有这一种解决办法吗？
AUDIENCE: Is the only solution to the problem you raise to create another procedure?

438
00:38:06,470 --> 00:38:12,402
换句话说，是不是只有那些过程可作为对象的语言才可以用这样的方法来解决？
In other words, can this only work in languages that are capable of defining objects as procedures?

439
00:38:12,402 --> 00:38:13,765
我想想
PROFESSOR: Oh, I see.

440
00:38:16,530 --> 00:38:28,190
我的解决方法是构造抽象，我没有把过程用lambda定义在sum里，而是定义在外面，然后这个过程生成一个新过程
My solution to making this abstraction, when I didn't want include the procedure inside the body, depends upon my ability to return a procedure or export one.

441
00:38:28,190 --> 00:38:30,410
没错
And that's right.

442
00:38:30,410 --> 00:38:43,000
如果过程作为对象，我就不能这样来解决符号冲突的问题了
If I don't have that, then I just don't have this ability to make an abstraction in a way where I don't have possibilities of symbol conflicts that were unanticipated.

443
00:38:43,000 --> 00:38:45,610
你说的对
That's right.

444
00:38:45,610 --> 00:39:03,700
我可以把过程作为函数返回值，也只能在过程是一类公民的语言中可以做到，这一点对于模块化编程非常重要
I consider being able to return the procedural value and, therefore, to sort of have first class procedures, in general, as being essential to doing very good modular programming.

445
00:39:03,700 --> 00:39:07,440
有很多种方式来解决这个问题
Now, indeed there are many other ways to skin this cat.

446
00:39:07,440 --> 00:39:15,840
你需要的做的就是考虑所有你认为糟糕的情况，然后做一个feature来解决它
What you can do is take for each of the bad things that you have to worry about, you can make a special feature that covers that thing.

447
00:39:15,840 --> 00:39:17,930
你可以做一个包系统
You can make a package system.

448
00:39:17,930 --> 00:39:22,240
或者像Ada中的模块系统
You can make a module system as in Ada, et cetera.

449
00:39:22,240 --> 00:39:26,440
这些都可以，可能区别只是解决的程度不一
And all of those work, or they cover little regions of it.

450
00:39:26,440 --> 00:39:45,590
过程作为返回值这一点可以解决所有问题，这种最简单的机制，却可以给予你最好的模块性
The thing is that returning procedures as values cover all of those problems. And so it's the simplest mechanism that gives you the best modularity, gives you all of the known modularity mechanisms.

451
00:39:45,590 --> 00:39:48,248
好的，该休息一会儿了
Well, I suppose it's time for the next break, thank you.

452
00:39:48,248 --> 00:40:41,871
[MUSIC PLAYING]
[MUSIC PLAYING]

453
00:40:41,871 --> 00:40:55,420
昨天你们学习流的时候，哈罗德向你们提到过求值顺序与过程参数延时求值的问题
PROFESSOR: Well, yesterday when you learned about streams, Hal worried to you about the order of evaluation and delayed arguments to procedures.

454
00:40:55,420 --> 00:41:15,250
我们昨天讲了流，其中调用者和被调用者都必须了解参数是被delay的，然后被调用者对参数force而得到结果
The way we played with streams yesterday, it was the responsibility of the caller and the callee to both agree that an argument was delayed, and the callee must force the argument if it needs the answer.

455
00:41:15,250 --> 00:41:26,100
这样的话，过程的开发者和过程的使用者就需要太多的交流与协商
So there had to be a lot of hand shaking between the designer of a procedure and user of it over delayedness.

456
00:41:26,100 --> 00:41:45,900
这看起来很糟糕，但是对于流来说没什么不妥。但是，广泛着来看，我们想要的是一个广泛层面的设计决策，而且可以显式的清晰的表述出来
That turns out, of course, to be a fairly bad thing, it works all right with streams. But as a general thing, what you want is an idea to have a locus, a decision, a design decision in general, to have a place where it's made, explicitly, and notated in a clear way.

457
00:41:45,900 --> 00:41:59,500
所以，如果过程编写者和过程使用者需要花费不少的精力去协商比如参数是否求值、求值顺序的问题，那是十分不妥当的
And so it's not a very good idea to have to have an agreement, between the person who writes a procedure and the person who calls it, about such details as, maybe, the arguments of evaluation, the order of evaluation.

458
00:41:59,500 --> 00:42:00,750
但是也不是太糟糕
Although, that's not so bad.

459
00:42:00,750 --> 00:42:04,540
我的意思是，可能参数输入的是一个数字
I mean, we have other such agreements like, the input's a number.

460
00:42:04,540 --> 00:42:11,020
但是，如果其中一个人可以全权负责这部分的事情是再好不过了
But it would be nice if only one of these guys could take responsibility, completely.

461
00:42:11,020 --> 00:42:15,510
这个想法已经不算新潮了
Now this is not a new idea.

462
00:42:15,510 --> 00:42:22,020
ALGOL就提供了完全不同的两种方式来执行过程
ALGOL 60 had two different ways of calling a procedure.

463
00:42:22,020 --> 00:42:25,590
参数作为名称传递或者值传递
The arguments could be passed by name or by value.

464
00:42:25,590 --> 00:42:31,110
按名字传递的意思即这个参数会延时求值
And what that meant was that a name argument was delayed.

465
00:42:31,110 --> 00:42:39,620
当你按名字传递一个参数，只有你去取它的值的时候，它的值才会被计算出来
That when you passed an argument by name, that its value would only be obtained if you accessed that argument.

466
00:42:42,290 --> 00:42:50,320
我们接下来，还要对语言进行一些小的修改
So what I'd like to do now is show you, first of all, a little bit about, again, we're going to make a modification to a language.

467
00:42:50,320 --> 00:42:53,370
这里，我们再添加一个新的feature
In this case, we're going to add a feature.

468
00:42:53,370 --> 00:43:00,430
可以称作为“名称参数”，或者你就理解为 延时参数 就行
We're going to add the feature of, by name parameters, if you will, or delayed parameters.

469
00:43:00,430 --> 00:43:08,220
因为事实上，我们的Lisp中默认传递的是指针的值
Because, in fact, the default in our Lisp system is by the value of a pointer.

470
00:43:08,220 --> 00:43:13,410
指针被复制了，但是它所指向的数据结构却没有变化 [在没有赋值与副作用的情况下，这不会造成什么影响]
A pointer is copied, but the data structure it points at is not.

471
00:43:13,410 --> 00:43:19,990
我也会讲到，如何来使用名称参数
But I'd like to, in fact, show you is how you add name arguments as well.

472
00:43:19,990 --> 00:43:23,100
为什么我们需要这样的feature呢？
Now again, why would we need such a thing?

473
00:43:23,100 --> 00:43:29,720
语言中的保留字在eval中都属于特殊形式，假如我们开发出具有保留字那样的功能
Well supposing we wanted to invent certain kinds of what otherwise would be special forms, reserve words?

474
00:43:29,720 --> 00:43:32,180
但是并不是添加新的保留字
But I'd rather not take up reserve words.

475
00:43:32,180 --> 00:43:36,360
我想用一个过程来达到if的效果
I want procedures that can do things like if.

476
00:43:36,360 --> 00:43:39,420
if很特殊，cond也是
If is special, or cond, or whatever it is.

477
00:43:39,420 --> 00:43:40,600
它们很一样
It's the same thing.

478
00:43:40,600 --> 00:43:50,840
if特殊在它会根据谓词的真假来判断是执行真语句还是假语句
It's special in that it determines whether or not to evaluate the consequent or the alternative based on the value of the predicate part of an expression.

479
00:43:50,840 --> 00:43:57,270
谓词的值决定了做不做后续的事
So taking the value of one thing determines whether or not to do something else.

480
00:43:57,270 --> 00:44:08,670
然而像 + 之类的过程，它们的参数可以在过程应用之前求值
Whereas all the procedures like plus, the ones that we can define right now, evaluate all of their arguments before application.

481
00:44:08,670 --> 00:44:19,452
假如我现在用保留字if来定义一个与if相反含义的过程
So, for example, supposing I wish to be able to define something like the reverse of if in terms of if.

482
00:44:19,452 --> 00:44:20,702
叫它unless
Call it unless.

483
00:44:24,890 --> 00:44:28,190
一个谓词，一个真语句，一个假语句
We've a predicate, a consequent, and an alternative.

484
00:44:28,190 --> 00:44:32,440
接下来的是，哦，我用的是cond来定义，不是if，前面说错了
Now what I would like to sort of be able to do is say-- oh, I'll do it in terms of cond.

485
00:44:32,440 --> 00:44:45,350
(cond ((not p) c) (else a))
Cond, if not the predicate, then take the consequent, otherwise, take the alternative.

486
00:44:51,290 --> 00:44:56,920
在这种情况下，假设我继续做下面的
Now, what I'd like this to mean, is supposing I do something like this.

487
00:44:56,920 --> 00:45:11,350
(unless (= 1 0) 2 (/ 1 0))
I'd like this unless say if equals one, 0, then the answer is two, otherwise, the quotient of one and 0.

488
00:45:15,980 --> 00:45:25,580
接下来要做的是进行代换，下面的1 2 3参数分别对应上面的p c a
What I'd like that to mean is the result of substituting equal one, 0, and two, and the quotient of one, 0 for p, c, and a.

489
00:45:25,580 --> 00:45:51,160
代换过后就像是，(cond ((not (= 1 0)) 2) (else (/ 1 0)))
I'd like that to mean, and this is funny, I'd like it to transform into or mean cond not equal one, 0, then the result is two, otherwise I want it to be the quotient one and 0.

490
00:45:54,480 --> 00:45:59,970
如果你直接把cond这一部分输入Lisp，会得到结果2
Now, you know that if I were to type this into Lisp, I'd get a two.

491
00:45:59,970 --> 00:46:02,910
没问题
There's no problem with that.

492
00:46:02,910 --> 00:46:10,840
然而，如果我把unless这一部分输入Lisp，参数会在过程执行之前先求值，这样(/ 1 0)这里就会报错
However, if I were to type this into Lisp, because all the arguments are evaluated before I start, then I'm going to get an error out of this.

493
00:46:13,380 --> 00:46:16,880
如果代换为cond，我可以得到正确的结果
So that if the substitutions work at all, of course, I would get the right answer.

494
00:46:16,880 --> 00:46:20,160
但是这里这种情况，代换并不能进行
But here's a case where the substitutions don't work.

495
00:46:22,920 --> 00:46:23,860
我得到了错误的结果
I don't get the wrong answer.

496
00:46:23,860 --> 00:46:24,670
没结果
I get no answer.

497
00:46:24,670 --> 00:46:25,920
还是一个错误
I get an error.

498
00:46:28,420 --> 00:46:34,270
现在，我要想办法使这样的定义可以成功运行
Now, however, I'd like to be able to make my definition so that this kind of thing works.

499
00:46:34,270 --> 00:46:39,930
这里我要对 c 和 a 动点手脚
What I want to do is say something special about c and a.

500
00:46:39,930 --> 00:46:42,715
我想使它们自动延时求值
I want them to be delayed automatically.

501
00:46:46,300 --> 00:46:51,520
不想使它们在执行过程之前就求值
I don't want them to be evaluated at the time I call.

502
00:46:51,520 --> 00:46:55,600
所以按照惯例，我先构造一种语法描述，之后我们再来具体的实现它
So I'm going to make a declaration, and then I'm going to see how to implement such a declaration.

503
00:46:55,600 --> 00:47:02,140
你们应该深信，我正在添加一个有趣的kluge[不知怎么译的准确]
But again, I want you to say to yourself, oh, this is an interesting kluge he's adding in here.

504
00:47:02,140 --> 00:47:05,750
太多的kluge会使得系统混乱复杂
The piles of kluges make a big complicated mess.

505
00:47:05,750 --> 00:47:10,120
还会搞砸以后要添加的功能
And is this going to foul up something else that might occur.

506
00:47:10,120 --> 00:47:13,860
新的语法描述，先来看，是否有语法上混淆的问题
First of all, is it syntactically unambiguous?

507
00:47:13,860 --> 00:47:17,840
当然，这里我要写的是一个清晰的无二义的新语法
Well, it will be syntactically unambiguous with what we've seen so far.

508
00:47:17,840 --> 00:47:21,670
但是接下来要做的却会导致另外的问题
But what I'm going to do may, in fact, cause trouble.

509
00:47:21,670 --> 00:47:34,300
可能以后我们会为了优化系统或者编译器而引入类型声明的机制，我一会儿要定义的新语法可能会与之冲突
It may be that the thing I had will conflict with type declarations I might want to add in the future for giving some system, some compiler or something, the ability to optimize given the types are known.

510
00:47:34,300 --> 00:47:40,570
或者会与那些声明参数类型这样的机制相冲突
Or it might conflict with other types of declarations I might want to make about the formal parameters.

511
00:47:40,570 --> 00:47:44,925
所以我这里要添加的机制并不是一个完整的机制
So I'm not making a general mechanism here where I can add declarations.

512
00:47:44,925 --> 00:47:46,750
只是能解决目前的问题而已
And I would like to be able to do that.

513
00:47:46,750 --> 00:47:51,010
具体怎么样完整就不在这里说了
But I don't want to talk about that right now.

514
00:47:51,010 --> 00:47:53,680
接下来
So here I'm going to do, I'm going to build a kluge.

515
00:47:57,050 --> 00:48:14,930
我再来定义unless，一个谓词，真真假语句都按名称来传递，即(name c) (name a)
So we're going to define unless of a predicate-- and I'm going to call these by name-- the consequent, and name the alternative.

516
00:48:19,850 --> 00:48:25,280
哦没估计好，卡在黑板边了
Huh, huh-- I got caught in the corner.

517
00:48:31,240 --> 00:48:41,360
(cond ((not p) c) (else a))
If not p then the result is c, else-- that's what I'd like.

518
00:48:44,670 --> 00:48:51,650
我可以显式的来声明，哪些参数按名称传递延时求值
Where I can explicitly declare certain of the parameters to be delayed, to be computed later.

519
00:48:55,008 --> 00:49:00,450
这样的话，要对求值器做出的修改可就比之前的feature要复杂多了
Now, this is actually a very complicated modification to an interpreter rather than a simple one.

520
00:49:00,450 --> 00:49:09,280
之前的动态绑定，或者不定参数，相比比较简单
The ones you saw before, dynamic binding or adding indefinite argument procedures, is relatively simple.

521
00:49:09,280 --> 00:49:12,120
但是这里，是一个基本原则的改变
But this one changes a basic strategy.

522
00:49:12,120 --> 00:49:36,110
我们之前的解释器，解释组合式时，先求值操作符，再求值操作数，最后再用操作符应用于操作数得到结果
The problem here is that our interpreter, as written, evaluates a combination by evaluating the procedure, the operator producing the procedure, and evaluating the operands producing the arguments, and then doing apply of the procedure to the arguments.

523
00:49:36,110 --> 00:49:46,810
然而这里，在我检测过整个过程的声明之前，我并不想立即求值操作数
However, here, I don't want to evaluate the operands to produce the arguments until after I examined the procedure to see what the procedure's declarations look like.

524
00:49:49,590 --> 00:49:52,680
我们来看这个
So let's look at that.

525
00:49:52,680 --> 00:49:57,480
对求值器的修改
Here we have a changed evaluator.

526
00:49:57,480 --> 00:50:09,750
这是从最开始的那个求值器修改得来的，不是动态绑定的那个  这里的修改和之前的有些相似
I'm starting with the simple lexical evaluator, not dynamic, but we're going to have to do something sort of similar in some ways.

527
00:50:09,750 --> 00:50:19,360
如果我延时一个过程 -- 哦说错了 -- 延时一个过程的参数，就必须把当前的环境和参数关联在一起
Because of the fact that, if I delay a procedure-- I'm sorry-- delay an argument to a procedure, I'm going to have to attach and environment to it.

528
00:50:19,360 --> 00:50:23,380
还记得哈罗德教授是怎么实现delay的吧
Remember how Hal implemented delay.

529
00:50:23,380 --> 00:50:31,180
哈罗德教授把delay实现为一个没有参数的过程，其中包含了要延时的操作
Hal implemented delay as being a procedure of no arguments which does some expression.

530
00:50:31,180 --> 00:50:32,670
就像这样
That's what delay of the expression is.

531
00:50:35,370 --> 00:50:36,620
(delay e)
--of that expression.

532
00:50:39,180 --> 00:50:40,950
返回下面的(lambda () e)
This turned into something like this.

533
00:50:44,520 --> 00:50:49,010
然而，我要执行这个lambda，就必须要在一定的环境下
Now, however, if I evaluate a lambda expression, I have to capture the environment.

534
00:50:51,410 --> 00:51:01,530
原因是因为其中有一些自由变量只有在正确的上下文中才能正确解读
The reason why is because there are variables in there who's meaning I wish to derive from the context where this was written.

535
00:51:04,010 --> 00:51:06,095
这也是 用lambda来实现delay的原因
So that's why a lambda does the job.

536
00:51:06,095 --> 00:51:08,070
非常合适
It's the right thing.

537
00:51:08,070 --> 00:51:21,090
相对应的，对延时对象force就是执行这个无参数的过程
And such that the forcing of a delayed expression was same thing as calling that with no arguments.

538
00:51:21,090 --> 00:51:24,100
和上面恰恰相对
It's just the opposite of this.

539
00:51:24,100 --> 00:51:33,132
为过程调用生成了新的环境就是在过程定义的时候所附加的新frame
Producing an environment of the call which is, in fact, the environment where this was defined with an extra frame in it that's empty.

540
00:51:33,132 --> 00:51:36,240
这里就不细细讨论了
I don't care about that.

541
00:51:36,240 --> 00:51:51,980
我们再来看这张幻灯片，仔细看一会儿，会发现大部分都是相同的，只有最下面处理组合式的地方不同
Well, if we go back to this slide, since it's the case, if we look at this for a second, everything is the same as it was before except the case of applications or combinations.

542
00:51:51,980 --> 00:51:54,680
这种情况有两个部分
And combinations are going to do two things.

543
00:51:54,680 --> 00:52:00,425
一是我得先求值操作符
One, is I have to evaluate the procedure-- forget the procedure-- by evaluating the operator.

544
00:52:00,425 --> 00:52:02,380
也就是这一部分
That's what you see right here.

545
00:52:02,380 --> 00:52:10,730
这里我要保证它已经被求出值的，也即用undelay来确保操作符不再是延时对象
I have to make sure that that's current, that is not a delayed object, and evaluate that to the point where it's forced now.

546
00:52:10,730 --> 00:52:18,460
然后应用于操作数
And then I have to somehow apply that to the operands.

547
00:52:18,460 --> 00:52:21,530
这里还要保存下当前的环境，作为第三个参数传递过去
But I have to keep the environment, pass that environmental along.

548
00:52:21,530 --> 00:52:23,710
如果有一些参数是延时了的
So some of those operands I may have to delay.

549
00:52:23,710 --> 00:52:29,302
就需要用此时的环境来求值
I may have to attach that environment to those operands.

550
00:52:29,302 --> 00:52:32,990
看起来已经十分复杂了
This is a rather complicated thing happening here.

551
00:52:32,990 --> 00:52:34,240
再来看看apply
Looking at that in apply.

552
00:52:36,400 --> 00:52:42,610
这一部分还是判断基本过程，和之前一样
Apply, well it has a primitive procedure thing just like before.

553
00:52:42,610 --> 00:52:44,390
组合过程的部分就比较有意思了
But the compound one is a little more interesting.

554
00:52:47,250 --> 00:53:00,290
我要在过程定义时绑定的环境下求值过程，但是参数要在和延时参数关联起来的环境下求值
I have to evaluate the body, just as before, in an environment which is the result of binding some formal parameters to arguments in the environment.

555
00:53:00,290 --> 00:53:01,530
两个环境
That's true.

556
00:53:01,530 --> 00:53:03,820
这个环境是定义过程时关联的环境
The environment is the one that comes from the procedure now.

557
00:53:03,820 --> 00:53:08,040
静态绑定
It's a lexical language, statically bound.

558
00:53:08,040 --> 00:53:12,960
我还需要的是去掉name声明，获得变量的实际名字
However, one thing I have to do is strip off the declarations to get the names of the variables.

559
00:53:12,960 --> 00:53:15,450
也就是vnames过程所要做的
That's what this guy does, vnames.

560
00:53:15,450 --> 00:53:33,770
然后要做的就是，这些操作数，哪些要马上求值，哪些要先用延时封装起来
And the other thing I have to do is process these declarations, deciding which of these operands-- that's the operands now, as opposed to the arguments-- which of these operands to evaluate, and which of them are to be encapsulated in delays of some sort.

561
00:53:37,280 --> 00:53:45,820
另外，如果遇到的基本过程，操作数还是要马上求值
The other thing you see here is that we got a primitive, a primitive like plus, had better get at the real operands.

562
00:53:45,820 --> 00:53:47,690
也就是这里
So here is a place where we're going to have to force them.

563
00:53:47,690 --> 00:53:51,340
evlist中其中做了很多force的工作
And we're going to look at what evlist is going to have to do a bunch of forces.

564
00:53:51,340 --> 00:53:52,780
所以这里有两个evlist
So we have two different kinds of evlist now.

565
00:53:52,780 --> 00:53:59,870
evlist和gevlist gevlist对要延时的参数加以封装，对其它的则马上求值
We have evlist and gevlist. Gevlist is going to wrap delays around some things and force others, evaluate others.

566
00:53:59,870 --> 00:54:07,900
evlist的话就是单纯的去求值
And this guy's going to do some forcing of things.

567
00:54:07,900 --> 00:54:12,250
来看evlist，这里我们只需做我们自己的事就行，大家已经很熟悉了
Just looking at this a little bit, this is a game you must play for yourself, you know.

568
00:54:12,250 --> 00:54:19,730
这里不会有求值器传递过来的多种情况
It's not something that you're going to see all possible variations on an evaluator talking to me.

569
00:54:19,730 --> 00:54:21,410
我们只需要一味求值就可以了
What you have to do is do this for yourself.

570
00:54:21,410 --> 00:54:29,930
在你感觉过这种方式之后，你将会看到另一种方式，这里你需要处理不同的设计决策，了解它们的具体意思，清楚它们如何相互关联
And after you feel this, you play this a bit, you get to see all the possible design decisions and what they might mean, and how they interact with each other.

571
00:54:29,930 --> 00:54:33,160
任何语言都是这样
So what languages might have in them.

572
00:54:33,160 --> 00:54:37,200
普遍通用的规则与少量特殊的规则，协同构建一门合理的语言
And what are some of the consistent sets that make a legitimate language.

573
00:54:37,200 --> 00:54:41,850
然后如果有太多的kluge，就会对语言造成破坏
Whereas what things are complicated kluges that are just piles of junk.

574
00:54:41,850 --> 00:54:50,750
回到evlist上来，针对所有的操作数force求值
So evlist of course, over here, just as I said, is a list of operands which are going to be undelayed after evaluation.

575
00:54:50,750 --> 00:54:56,050
无论操作数是否是延时对象
So these are going to be forced, whatever that's going to mean.

576
00:54:56,050 --> 00:55:04,040
下一个，gevlist
And gevlist, which is the next thing-- Thank you.

577
00:55:04,040 --> 00:55:09,810
这里，就会发现有很多种情况
What we see here, well there's a couple of possibilities.

578
00:55:09,810 --> 00:55:19,390
如果不是用name延时的参数，就像unless中谓词部分，对应这一部分代码
Either it's a normal, ordinary thing, a symbol sitting there like the predicate in the unless, and that's what we have here.

579
00:55:19,390 --> 00:55:23,340
这一部分就使用应用序求值
In which case, this is intended to be evaluated in applicative order.

580
00:55:23,340 --> 00:55:25,630
就像以前一样
And it's, essentially, just what we had before.

581
00:55:25,630 --> 00:55:37,900
然后递归求值，就是对CAR求值之后，再用gevlist对剩下的求值
It's mapping eval down the list. In other words, I evaluate the first expression and continue gevlisting the CDR of the expression in the environment.

582
00:55:37,900 --> 00:55:43,600
然而，有可能我们遇到一个延时参数
However, it's possible that this is a name parameter.

583
00:55:43,600 --> 00:56:02,790
如果是一个延时参数，就delay这个参数，还要记得封装当前的环境
If it's a name parameter, I want to put a delay in which combines that expression, which I'm calling by name, with the environment that's available at this time and passing that as the parameter.

584
00:56:02,790 --> 00:56:05,600
然后继续递归
And this is part of the mapping process that you see here.

585
00:56:09,070 --> 00:56:14,700
另一个有意思的地方是evcond
The only other interesting place in this interpreter is cond.

586
00:56:14,700 --> 00:56:18,550
人们可能认为这一部分没什么特别的，就草草写完
People tend to write this thing, and then they leave this one out.

587
00:56:18,550 --> 00:56:20,510
这里有一个地方是需要force的，值得注意
There's a place where you have to force.

588
00:56:20,510 --> 00:56:25,990
条件式必须先知道谓词的真假
Conditionals have to know whether or not the answer is true or false.

589
00:56:25,990 --> 00:56:28,550
就像一个基本过程一样
It's like a primitive.

590
00:56:28,550 --> 00:56:31,890
当你定义条件式的时候，你必须需要force
When you do a conditional, you have to force.

591
00:56:31,890 --> 00:56:34,350
剩下的细节就没什么特别的了
Now, I'm not going to look at any more of this in any detail.

592
00:56:34,350 --> 00:56:36,750
就先不深究了
It isn't very exciting.

593
00:56:36,750 --> 00:56:38,990
剩下的就是delay的实现了
And what's left is how you make delays.

594
00:56:38,990 --> 00:56:44,840
delay就是一个数据结构，其中包括了类型'trunk，表达式和环境
Well, delays are data structures which contain an expression, an environment, and a type on them.

595
00:56:44,840 --> 00:56:46,680
'thunk标明这是一个trunk
And it says they're a thunk.

596
00:56:46,680 --> 00:56:52,970
是从ALGOL借用过来的，原义大概是把什么压在栈中
That comes from ALGOL language, and it's claimed to be the sound of something being pushed on a stack.

597
00:56:52,970 --> 00:56:53,410
记不清了
I don't know.

598
00:56:53,410 --> 00:56:58,740
我对ALGOL了解的不深入
I was not an ALGOLician or an ALGOLite or whatever, so I don't know.

599
00:56:58,740 --> 00:57:00,270
但是我们就在这里借用它了
But that's what was claimed.

600
00:57:00,270 --> 00:57:07,860
undelay不断递归的force求值，直到遇到不是'trunk的对象
And undelay is something which will recursively undelay thunks until the thunk becomes something which isn't a thunk.

601
00:57:07,860 --> 00:57:12,050
这就是具体的实现
This is the way you implement a call by name like thing in ALGOL.

602
00:57:12,050 --> 00:57:15,210
全部都在这里了
And that's about all there is.

603
00:57:15,210 --> 00:57:16,460
有什么问题吗？
Are there any questions?

604
00:57:26,840 --> 00:57:27,560
Gerry？
AUDIENCE: Gerry?

605
00:57:27,560 --> 00:57:29,626
你说，Vesko
PROFESSOR: Yes, Vesko?

606
00:57:29,626 --> 00:57:39,350
我注意到，在调用基本过程的时候，你避免用名字传递参数，这样做有什么原因吗？
AUDIENCE: I noticed you avoided calling by name in the primitive procedures, I was wondering what cause you have on that?

607
00:57:39,350 --> 00:57:40,070
需要这样吗？
You never need that?

608
00:57:40,070 --> 00:57:47,140
Vesko想问的是 基本过程的参数如果按名字传递是否合理？
PROFESSOR: Vesko is asking if it's ever reasonable to call a primitive procedure by name?

609
00:57:47,140 --> 00:57:49,270
答案是 是的
The answer is, yes.

610
00:57:49,270 --> 00:57:52,930
有一种情况下是可以的，哦两种
There's one particular case where it's reasonable, actually two.

611
00:57:56,050 --> 00:58:03,690
比如用cons来构建一个数组的数据结构
Construction of a data structure like cons where making an array if you have arrays with any number of elements.

612
00:58:03,690 --> 00:58:07,440
没必要求值参数
It's unnecessary to evaluate those arguments.

613
00:58:07,440 --> 00:58:11,160
你只需要一个约定，一个需要计算参数的时候就可以得到结果的约定
All you need is promises to evaluate those arguments if you look at them.

614
00:58:11,160 --> 00:58:21,830
如果我用cons把两个东西连接起来，连接两个约定和连接两个实际的东西一样简单
If I cons together two things, then I could cons together the promises just as easily as I can cons together the things.

615
00:58:21,830 --> 00:58:24,840
甚至在用CAR CDR取出的时候也不用计算
And it's not even when I CAR CDR them that I have to look at them.

616
00:58:24,840 --> 00:58:28,260
直接把约定传递给其它人
That just gets out the promises and passes them to somebody.

617
00:58:28,260 --> 00:58:34,420
这也是阿隆佐 丘奇用lambda演算定义的cons能够说得通的原因
That's why the lambda calculus definition, the Alonzo Church definition of CAR, CDR, and cons makes sense.

618
00:58:34,420 --> 00:58:40,760
因为在cons car cdr中并没有什么计算，它们不过是存东西取东西而已
It's because no work is done in CAR, CDR, and cons, it's just shuffling data, it's just routing, if you will.

619
00:58:40,760 --> 00:58:45,280
然而像 + 这样的过程必须要了解参数是什么
However, the things that do have to look at data are things like plus.

620
00:58:45,280 --> 00:58:52,460
因为 + 需要和实际组成数字的比特打交道，如果遇到一个lambda就搞笑了
Because they have a look at the bits that the numbers are made out of, unless they're lambda calculus numbers which are funny.

621
00:58:52,460 --> 00:58:55,880
它要从数字的比特层面来实际计算
They have to look at the bits to be able to crunch them together to do the add.

622
00:58:59,210 --> 00:59:13,300
可能在一种最懒惰的解释器实现中，数据构造器，数据选择器，包括像有副作用的一些对象都是不需要force求值的
So, in fact, data constructors, data selectors, and, in fact, things that side-effect data objects don't need to do any forcing in the laziest possible interpreters.

623
00:59:16,460 --> 00:59:18,700
话说回来判断数据结构的谓词还是需要force的
On the other hand predicates on data structures have to.

624
00:59:21,710 --> 00:59:23,560
这是一个序对吗？
Is this a pair?

625
00:59:23,560 --> 00:59:24,640
或者是一个符号？
Or is it a symbol?

626
00:59:24,640 --> 00:59:25,690
最好搞清楚是什么
Well, you better find out.

627
00:59:25,690 --> 00:59:26,940
这点还是挺重要的
You got to look at it then.

628
00:59:30,300 --> 00:59:31,550
还有问题吗？
Any other questions?

629
00:59:40,050 --> 00:59:41,610
没了，下面是休息时间
Oh, well, I suppose it's time for a break.

630
00:59:41,610 --> 00:59:42,106
下课
Thank you.

631
00:59:42,106 --> 01:00:02,950
[MUSIC PLAYING]
[MUSIC PLAYING]

